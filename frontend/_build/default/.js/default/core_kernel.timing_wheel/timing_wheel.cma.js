// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Timing_wheel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Timing_wheel = [0];
   runtime.caml_register_global(0, Timing_wheel, "Timing_wheel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Import
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Import = "Timing_wheel__Import",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Expect_test_collector[6][1], "timing_wheel/src/import.ml");
   caml_call2(Ppx_inline_test_lib[5], cst_timing_wheel, "import.ml");
   caml_call1(Ppx_inline_test_lib[6], cst_timing_wheel);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Import);
   var Timing_wheel_Import = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Import, cst_Timing_wheel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Timing_wheel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Timing_wheel_ = "Timing_wheel__Timing_wheel_intf",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Timing_wheel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1
    (Expect_test_collector[6][1], "timing_wheel/src/timing_wheel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[5], cst_timing_wheel, "timing_wheel_intf.ml");
   caml_call1(Ppx_inline_test_lib[6], cst_timing_wheel);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Timing_wheel_);
   var Timing_wheel_Timing_wheel_intf = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Timing_wheel_intf, cst_Timing_wheel_Timing_wheel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel
//# unitInfo: Requires: Base__Field, Base__Invariant, Base__Sexpable, Core, Core__Array, Core__Binable, Core__Int, Core__Int63, Core__List, Core__Time_ns, Core__Time_ns_alternate_sexp, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_record, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel = "Timing_wheel",
    cst_Timing_wheel_max_alarm_tim$1 =
      "Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel",
    cst = "_",
    cst_alarm_precision$0 = "alarm_precision",
    cst_at = "at",
    cst_bits = "bits",
    cst_bits_per_slot = "bits_per_slot",
    cst_capacity$0 = "capacity",
    cst_config = "config",
    cst_diff_max_min_allowed_key = "diff_max_min_allowed_key",
    cst_elt_key_lower_bound = "elt_key_lower_bound",
    cst_index = "index",
    cst_interval_num = "interval_num",
    cst_key = "key",
    cst_keys_per_slot = "keys_per_slot",
    cst_length = "length",
    cst_level_bits$0 = "level_bits",
    cst_levels = "levels",
    cst_max_allowed_alarm_time = "max_allowed_alarm_time",
    cst_max_allowed_key = "max_allowed_key",
    cst_max_interval_num = "max_interval_num",
    cst_min_allowed_key = "min_allowed_key",
    cst_min_elt = "min_elt",
    cst_min_key_in_same_slot_mask = "min_key_in_same_slot_mask",
    cst_now = "now",
    cst_now_interval_num_start = "now_interval_num_start",
    cst_pool = "pool",
    cst_priority_queue = "priority_queue",
    cst_slots = "slots",
    cst_slots_mask = "slots_mask",
    cst_start = "start",
    cst_timing_wheel = "timing_wheel",
    cst_timing_wheel_src_timing_wh = "timing_wheel/src/timing_wheel.ml",
    cst_value = "value",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) === 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$9 = "timing_wheel/src/timing_wheel.ml:1619:26",
    pos$8 = "timing_wheel/src/timing_wheel.ml:1616:26",
    pos$7 = "timing_wheel/src/timing_wheel.ml:1632:26",
    pos$6 = "timing_wheel/src/timing_wheel.ml:1637:26",
    arg_087 = [0, cst],
    pos$5 = "timing_wheel/src/timing_wheel.ml:995:32",
    pos$4 = "timing_wheel/src/timing_wheel.ml:992:32",
    pos$3 = "timing_wheel/src/timing_wheel.ml:902:31",
    pos$2 = "timing_wheel/src/timing_wheel.ml:909:30",
    pos$1 = "timing_wheel/src/timing_wheel.ml:920:31",
    pos$0 = "timing_wheel/src/timing_wheel.ml:938:32",
    pos = "timing_wheel/src/timing_wheel.ml:943:30",
    error_source_019 = "timing_wheel/src/timing_wheel.ml.Config.t",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_List = global_data.Core__List;
   global_data.Base__Field;
   var
    Core_Int63 = global_data.Core__Int63,
    Core_Array = global_data.Core__Array,
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Core_Binable = global_data.Core__Binable,
    Base_Sexpable = global_data.Base__Sexpable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Expect_test_collector[6][1], cst_timing_wheel_src_timing_wh);
   caml_call2(Ppx_inline_test_lib[5], cst_timing_wheel, "timing_wheel.ml");
   var
    max_time = Core_Time_ns_alternate_sexp[45],
    min_time = Core_Time_ns_alternate_sexp[43],
    zero = Core_Int[57],
    to_int = Core_Int[63],
    t_of_sexp = Core_Int[81],
    sexp_of_t = Core_Int[82],
    symbol = Core_Int[86],
    symbol$0 = Core_Int[87],
    symbol$1 = Core_Int[89],
    equal = Core_Int[92],
    max_num_bits = Core_Int63[59] - 1 | 0,
    min_value = 0,
    _a_ = [0, cst_timing_wheel_src_timing_wh, 83, 4],
    _b_ = [0, cst_timing_wheel_src_timing_wh, 82, 4],
    _c_ = [0, cst_timing_wheel_src_timing_wh, 114, 4],
    _d_ = [0, cst_timing_wheel_src_timing_wh, 117, 6],
    cst_Level_bits_create_exn_requ =
      "Level_bits.create_exn requires a nonempty list",
    cst_Level_bits_create_exn_got_ =
      "Level_bits.create_exn got nonpositive num bits",
    _e_ = [0, "max_num_bits"],
    _f_ = [0, "got"],
    cst_Level_bits_create_exn_got_$0 =
      "Level_bits.create_exn got too many bits";
   function invariant(t){
    if(! caml_call2(symbol, t, min_value))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(caml_call2(symbol$0, t, max_num_bits)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function of_int(i){invariant(i); return i;}
   function symbol$2(t1, t2){var t = t1 + t2 | 0; invariant(t); return t;}
   function symbol$3(t1, t2){var t = t1 - t2 | 0; invariant(t); return t;}
   function pow2(t){return caml_call2(Core_Int63[48], Core_Int63[15], t);}
   function sexp_of_t$0(x_007){
    return caml_call2(Core[431], sexp_of_t, x_007);
   }
   function num_bits_internal(t){
    return caml_call3(Core_List[20], t, zero, symbol$2);
   }
   function num_bits(t){return num_bits_internal(t);}
   function invariant$0(t){
    if(caml_call1(Core_List[18], t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    caml_call2
     (Core_List[19],
      t,
      function(num_key_bits){
       invariant(num_key_bits);
       if(caml_call2(symbol$1, num_key_bits, zero)) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      });
    return invariant(num_bits_internal(t));
   }
   function t_of_sexp$0(x_006){
    var t = caml_call2(Core[432], t_of_sexp, x_006);
    invariant$0(t);
    return t;
   }
   function create_exn(opt, x_008){
    var extend_to_max_num_bits = opt ? opt[1] : 0;
    if(caml_call1(Core_List[18], x_008))
     caml_call1(Core[5], cst_Level_bits_create_exn_requ);
    if
     (caml_call2
       (Core_List[23],
        x_008,
        function(bits){return caml_call2(Core[88], bits, 0);})){
     var
      _dO_ = [0, caml_call2(Core[431], Core[363], x_008), 0],
      _dP_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_),
          _dO_]];
     caml_call1(Core[255], _dP_);
    }
    var
     num_bits =
       caml_call3
        (Core_List[20],
         x_008,
         0,
         function(_dX_, _dW_){return _dX_ + _dW_ | 0;});
    if(caml_call2(Core[90], num_bits, max_num_bits)){
     var
      _dQ_ =
        [0, [1, [0, _e_, [0, caml_call1(Core[363], max_num_bits), 0]]], 0],
      _dR_ = [0, [1, [0, _f_, [0, caml_call1(Core[363], num_bits), 0]]], _dQ_],
      _dS_ = [0, caml_call2(Core[431], Core[363], x_008), _dR_],
      _dT_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_$0),
          _dS_]];
     caml_call1(Core[255], _dT_);
    }
    if(extend_to_max_num_bits)
     var
      _dU_ = caml_call1(Core[236], 1),
      _dV_ = caml_call2(Core_List[40], max_num_bits - num_bits | 0, _dU_),
      ints = caml_call2(Core[155], x_008, _dV_);
    else
     var ints = x_008;
    return caml_call2(Core_List[50], ints, of_int);
   }
   var
    level_bits_default =
      create_exn
       (0, [0, 11, [0, 10, [0, 10, [0, 10, [0, 10, [0, 10, [0, 1, 0]]]]]]]),
    compare = Core[358],
    cst_Alarm_precision_to_span_of =
      "[Alarm_precision.to_span] of negative power of two nanoseconds";
   function equal$0(x_012, x_013){
    return 0 === caml_call2(compare, x_012, x_013) ? 1 : 0;
   }
   function to_sexpable(t){
    if(caml_call2(Core[91], t, 0)){
     var
      _dL_ = [0, caml_call1(Core[363], t), 0],
      _dM_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_to_span_of),
          _dL_]];
     caml_call1(Core[255], _dM_);
    }
    var _dN_ = caml_call1(caml_call1(Core_Int63[48], Core_Int63[15]), t);
    return caml_call1(Core_Time_ns[1][130], _dN_);
   }
   function sexp_of_t$1(t){
    var _dK_ = to_sexpable(t);
    return caml_call1(Core_Time_ns[1][10], _dK_);
   }
   var
    about_one_microsecond = 10,
    _g_ = [0, "span"],
    cst_Alarm_precision_of_span_fl =
      "[Alarm_precision.of_span_floor_pow2_ns] got non-positive span";
   function mul(t, pow2){return t + pow2 | 0;}
   function div(t, pow2){return t - pow2 | 0;}
   function of_span_floor_pow2_ns(span){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][75])){
     var
      _dH_ =
        [0, [1, [0, _g_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _dI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_of_span_fl),
          _dH_]];
     caml_call1(Core[255], _dI_);
    }
    var _dJ_ = caml_call1(Core_Time_ns[1][129], span);
    return caml_call1(Core_Int63[87], _dJ_);
   }
   var
    _h_ = Core_Time_ns[1],
    _i_ =
      caml_call1
       (caml_call1
         (Core_Binable[6], [0, _h_[5], _h_[1], _h_[2], _h_[3], _h_[4]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    bin_size_t = _i_[1],
    bin_write_t = _i_[2],
    bin_read_t = _i_[3],
    bin_read_t$0 = _i_[4],
    bin_shape_t = _i_[5],
    bin_writer_t = _i_[6],
    bin_reader_t = _i_[7],
    bin_t = _i_[8],
    _j_ = Core_Time_ns[1],
    include =
      caml_call1
       (caml_call1(Base_Sexpable[1], [0, _j_[9], _j_[10]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    t_of_sexp$1 = include[1],
    sexp_of_t$2 = include[2],
    _k_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       compare,
       t_of_sexp$1,
       sexp_of_t$2];
   function level_bits(r){return r[2];}
   var
    level_bits$0 =
      [0,
       function(param){return 0;},
       cst_level_bits$0,
       0,
       level_bits,
       function(r, v){return [0, r[1], v, r[3]];}],
    cst_capacity = cst_capacity$0,
    cst_level_bits = cst_level_bits$0,
    cst_alarm_precision = cst_alarm_precision$0,
    _l_ = [0, cst_capacity$0],
    _m_ = [0, cst_level_bits$0],
    _n_ = [0, cst_alarm_precision$0],
    _o_ = [0, cst_timing_wheel_src_timing_wh, 257, 6],
    _p_ = [0, cst_timing_wheel_src_timing_wh, 256, 8261, 8285],
    _q_ = [0, 10, [0, 10, [0, 6, [0, 6, [0, 5, 0]]]]];
   function t_of_sexp$2(x_021){
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_019,
             [0,
              cst_alarm_precision,
              1,
              _k_[10],
              [0,
               cst_level_bits,
               [0, function(param){return level_bits_default;}],
               t_of_sexp$0,
               [0, cst_capacity, 5, Core[364], 0]]],
             function(param){
              return param !== cst_alarm_precision$0
                      ? param
                        !== cst_capacity$0
                        ? param !== cst_level_bits$0 ? -1 : 1
                        : 2
                      : 0;
             },
             0,
             function(param){
              var
               _dG_ = param[2],
               capacity = _dG_[2][1],
               level_bits = _dG_[1],
               alarm_precision = param[1];
              return [0, alarm_precision, level_bits, capacity];
             },
             x_021);
   }
   function sexp_of_t$3(param){
    var
     capacity_027 = param[3],
     level_bits_025 = param[2],
     alarm_precision_023 = param[1],
     bnds_022 = 0;
    if(capacity_027)
     var
      v_028 = capacity_027[1],
      arg_030 = caml_call1(Core[363], v_028),
      bnd_029 = [1, [0, _l_, [0, arg_030, 0]]],
      bnds_022$0 = [0, bnd_029, bnds_022];
    else
     var bnds_022$0 = bnds_022;
    var
     arg_026 = sexp_of_t$0(level_bits_025),
     bnds_022$1 = [0, [1, [0, _m_, [0, arg_026, 0]]], bnds_022$0],
     arg_024 = caml_call1(_k_[11], alarm_precision_023),
     bnds_022$2 = [0, [1, [0, _n_, [0, arg_024, 0]]], bnds_022$1];
    return [1, bnds_022$2];
   }
   function alarm_precision(t){return to_sexpable(t[1]);}
   function max_num_level_bits(alarm_precision){
    invariant(alarm_precision);
    return symbol$3(max_num_bits, alarm_precision);
   }
   function invariant$1(t){
    return caml_call4
            (Base_Invariant[1],
             _p_,
             t,
             sexp_of_t$3,
             function(param){
              var _dF_ = max_num_level_bits(t[1]);
              if(! caml_call2(symbol$0, num_bits_internal(t[2]), _dF_))
               throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
              var
               level_bits_fun = caml_call2(Base_Invariant[2], t, invariant$0);
              caml_call1(level_bits_fun, level_bits$0);
              return 0;
             });
   }
   function create(capacity, opt, alarm_precision, param){
    var
     level_bits = opt ? opt[1] : level_bits_default,
     max_num_bits = max_num_level_bits(alarm_precision);
    if(caml_call2(symbol$0, num_bits_internal(level_bits), max_num_bits))
     var level_bits$0 = level_bits;
    else
     var
      loop =
        function(t, remaining){
         if(! t) return 0;
         var t$0 = t[2], b = t[1];
         return caml_call2(symbol, b, remaining)
                 ? [0, remaining, 0]
                 : [0, b, loop(t$0, symbol$3(remaining, b))];
        },
      level_bits$0 = loop(level_bits, max_num_bits);
    return [0, alarm_precision, level_bits$0, capacity];
   }
   function microsecond_precision(param){
    return create(0, [0, create_exn(0, _q_)], about_one_microsecond, 0);
   }
   function durations(t){
    var t$0 = t[1];
    invariant(t$0);
    var _dD_ = caml_call1(to_int, t$0);
    return caml_call3
            (Core_List[88],
             t[2],
             _dD_,
             function(num_bits_accum, level_num_bits){
              var
               num_bits_accum$0 =
                 num_bits_accum + caml_call1(to_int, level_num_bits) | 0,
               _dE_ =
                 caml_call2
                   (Core[89], num_bits_accum$0, Core_Int63[59] - 1 | 0)
                  ? Core_Int63[60]
                  : caml_call2
                    (Core_Int63[48], Core_Int63[15], num_bits_accum$0),
               duration = caml_call1(Core_Time_ns[1][130], _dE_);
              return [0, num_bits_accum$0, duration];
             });
   }
   var compare$0 = Core_Int63[111], sexp_of_t$4 = Core_Int63[100];
   function create$0(level_bits){
    var _dB_ = Core_Int63[15], _dC_ = pow2(level_bits);
    return caml_call2(Core_Int63[18], _dC_, _dB_);
   }
   var
    one = Core_Int63[15],
    symbol$4 = Core_Int63[18],
    bit_not = Core_Int63[46],
    sexp_of_t$5 = Core_Int63[100],
    equal$1 = Core_Int63[110];
   function create$1(bits_per_slot){
    return caml_call1(bit_not, caml_call2(symbol$4, pow2(bits_per_slot), one));
   }
   var
    to_int_exn = Core_Int63[5],
    zero$0 = Core_Int63[14],
    one$0 = Core_Int63[15],
    symbol$5 = Core_Int63[17],
    symbol$6 = Core_Int63[19],
    succ = Core_Int63[40],
    pred = Core_Int63[41],
    max_value = Core_Int63[60],
    of_int$0 = Core_Int63[70],
    sexp_of_t$6 = Core_Int63[100],
    symbol$7 = Core_Int63[104],
    symbol$8 = Core_Int63[105],
    symbol$9 = Core_Int63[106],
    symbol$10 = Core_Int63[107],
    symbol$11 = Core_Int63[108],
    symbol$12 = Core_Int63[109],
    equal$2 = Core_Int63[110],
    compare$1 = Core_Int63[111],
    min = Core_Int63[112],
    max = Core_Int63[113],
    ascending = Core_Int63[114],
    descending = Core_Int63[115],
    between = Core_Int63[116],
    clamp_exn = Core_Int63[117],
    clamp = Core_Int63[118],
    Replace_polymorphic_compare = Core_Int63[119],
    comparator = Core_Int63[120],
    Map = Core_Int63[121],
    Set = Core_Int63[122],
    validate_lbound = Core_Int63[129],
    validate_ubound = Core_Int63[130],
    validate_bound = Core_Int63[131];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   function scale_int(t, i){
    return caml_call2(symbol$6, t, caml_call1(of_int$0, i));
   }
   var
    to_int_exn$0 = Core_Int63[5],
    zero$1 = Core_Int63[14],
    one$1 = Core_Int63[15],
    symbol$13 = Core_Int63[17],
    symbol$14 = Core_Int63[18],
    rem = Core_Int63[26],
    succ$0 = Core_Int63[40],
    pred$0 = Core_Int63[41],
    bit_and = Core_Int63[43],
    shift_right = Core_Int63[49],
    max_value$0 = Core_Int63[60],
    min_value$0 = Core_Int63[61],
    of_int$1 = Core_Int63[70],
    sexp_of_t$7 = Core_Int63[100],
    symbol$15 = Core_Int63[104],
    symbol$16 = Core_Int63[105],
    symbol$17 = Core_Int63[106],
    symbol$18 = Core_Int63[107],
    symbol$19 = Core_Int63[108],
    symbol$20 = Core_Int63[109],
    equal$3 = Core_Int63[110],
    compare$2 = Core_Int63[111],
    min$0 = Core_Int63[112],
    max$0 = Core_Int63[113],
    ascending$0 = Core_Int63[114],
    descending$0 = Core_Int63[115],
    between$0 = Core_Int63[116],
    clamp_exn$0 = Core_Int63[117],
    clamp$0 = Core_Int63[118],
    Replace_polymorphic_compare$0 = Core_Int63[119],
    comparator$0 = Core_Int63[120],
    Map$0 = Core_Int63[121],
    Set$0 = Core_Int63[122],
    hash_fold_t = Core_Int63[123],
    hash = Core_Int63[124],
    hashable = Core_Int63[125],
    Table = Core_Int63[126],
    Hash_set = Core_Int63[127],
    Hash_queue = Core_Int63[128],
    validate_lbound$0 = Core_Int63[129],
    validate_ubound$0 = Core_Int63[130],
    validate_bound$0 = Core_Int63[131];
   function of_int63$0(i){return i;}
   function to_int63$0(t){return t;}
   function add(t, i){return caml_call2(symbol$13, t, i);}
   function add_clamp_to_max(t, i){
    return caml_call2(symbol$18, t, caml_call2(symbol$14, max_value$0, i))
            ? max_value$0
            : caml_call2(symbol$13, t, i);
   }
   function sub(t, i){return caml_call2(symbol$14, t, i);}
   function diff(t1, t2){return caml_call2(symbol$14, t1, t2);}
   var
    _r_ = Set$0[1],
    _s_ = Map$0[1],
    _t_ = Set[1],
    _u_ = Map[1],
    _v_ =
      [0,
       sexp_of_t$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       equal$2,
       compare$1,
       min,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       [0,
        [0, _u_[9], _u_[10], _u_[11]],
        Map[2],
        Map[3],
        Map[4],
        Map[5],
        Map[6],
        Map[7],
        Map[8],
        Map[9],
        Map[10],
        Map[11],
        Map[12],
        Map[13],
        Map[14],
        Map[15],
        Map[16],
        Map[17],
        Map[18],
        Map[19],
        Map[20],
        Map[21],
        Map[22],
        Map[23],
        Map[24],
        Map[25],
        Map[26],
        Map[27],
        Map[28],
        Map[29],
        Map[30],
        Map[31],
        Map[32],
        Map[33],
        Map[34],
        Map[35],
        Map[36],
        Map[37],
        Map[38],
        Map[39],
        Map[40],
        Map[41],
        Map[42]],
       [0,
        [0, _t_[1], _t_[2], _t_[11]],
        Set[2],
        Set[3],
        Set[4],
        Set[5],
        Set[6],
        Set[7],
        Set[8],
        Set[9],
        Set[10],
        Set[11],
        Set[12],
        Set[13],
        Set[14],
        Set[15],
        Set[16],
        Set[17],
        Set[18],
        Set[19],
        Set[20],
        Set[21],
        Set[22],
        Set[23],
        Set[24],
        Set[25],
        Set[26],
        Set[27]],
       max,
       zero$0,
       one$0,
       max_value,
       of_int63,
       to_int63,
       of_int$0,
       to_int_exn,
       scale_int,
       pred,
       succ,
       symbol$5];
   function sexp_of_pool_slots(of_a_033, x_034){
    var
     _dx_ =
       caml_call1
        (Tuple_pool[36][3][1],
         function(_dA_){return sexp_of_pool_slots(of_a_033, _dA_);}),
     _dy_ =
       caml_call1
        (Tuple_pool[36][3][1],
         function(_dz_){return sexp_of_pool_slots(of_a_033, _dz_);});
    return caml_call7
            (Tuple_pool[36][1][8],
             sexp_of_t$7,
             Core_Time_ns_alternate_sexp[92],
             of_a_033,
             Core[363],
             _dy_,
             _dx_,
             x_034);
   }
   function sexp_of_t$8(of_a_035, x_036){
    return caml_call2
            (Tuple_pool[36][3][1],
             function(_dw_){return sexp_of_pool_slots(of_a_035, _dw_);},
             x_036);
   }
   var
    null$0 = Tuple_pool[36][3][4],
    null$1 = Tuple_pool[36][3][4],
    is_null = Tuple_pool[36][3][5],
    free = Tuple_pool[36][14];
   function key(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][3]);
   }
   function at(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][4]);
   }
   function value(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][5]);
   }
   function level_index(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][6]);
   }
   function prev(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][7]);
   }
   function set_prev(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][7], x);
   }
   function next(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][8]);
   }
   function set_next(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][8], x);
   }
   function is_valid(p, t){return caml_call2(Tuple_pool[36][6], p, t);}
   var
    grow = Tuple_pool[36][12],
    is_full = Tuple_pool[36][13],
    cst_Timing_wheel_got_invalid_a = "Timing_wheel got invalid alarm";
   function of_external_exn(pool, t){
    if(is_valid(pool, t)) return t;
    var
     _dv_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_got_invalid_a);
    return caml_call1(Core[255], _dv_);
   }
   function link(pool, prev, next){
    set_next(pool, prev, next);
    return set_prev(pool, next, prev);
   }
   function iter(pool, first, f){
    var current = [0, first], continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return 0;
     var next$0 = next(pool, current[1]);
     caml_call1(f, current[1]);
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function slots(r){return r[11];}
   function max_allowed_key(r){return r[10];}
   function set_max_allowed_key(r, v){r[10] = v; return 0;}
   function min_allowed_key(r){return r[9];}
   function set_min_allowed_key(r, v){r[9] = v; return 0;}
   function length(r){return r[8];}
   function set_length(r, v){r[8] = v; return 0;}
   function diff_max_min_allowed_key(r){return r[7];}
   function min_key_in_same_slot_mask(r){return r[6];}
   function keys_per_slot(r){return r[5];}
   function bits_per_slot(r){return r[4];}
   function slots_mask(r){return r[3];}
   function bits(r){return r[2];}
   function index(r){return r[1];}
   var
    slots$0 =
      [0,
       function(param){return 0;},
       cst_slots,
       0,
       slots,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                v];
       }],
    max_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_key,
       [0, set_max_allowed_key],
       max_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                v,
                r[11]];
       }],
    min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_min_allowed_key,
       [0, set_min_allowed_key],
       min_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                v,
                r[10],
                r[11]];
       }],
    length$0 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length],
       length,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                v,
                r[9],
                r[10],
                r[11]];
       }],
    diff_max_min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_diff_max_min_allowed_key,
       0,
       diff_max_min_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                v,
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    min_key_in_same_slot_mask$0 =
      [0,
       function(param){return 0;},
       cst_min_key_in_same_slot_mask,
       0,
       min_key_in_same_slot_mask,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                v,
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    keys_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_keys_per_slot,
       0,
       keys_per_slot,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                v,
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    bits_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_bits_per_slot,
       0,
       bits_per_slot,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                v,
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    slots_mask$0 =
      [0,
       function(param){return 0;},
       cst_slots_mask,
       0,
       slots_mask,
       function(r, v){
        return [0,
                r[1],
                r[2],
                v,
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    bits$0 =
      [0,
       function(param){return 0;},
       cst_bits,
       0,
       bits,
       function(r, v){
        return [0,
                r[1],
                v,
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    index$0 =
      [0,
       function(param){return 0;},
       cst_index,
       0,
       index,
       function(r, v){
        return [0,
                v,
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    _B_ = [0, cst_slots],
    _C_ = [0, cst_max_allowed_key],
    _D_ = [0, cst_min_allowed_key],
    _E_ = [0, cst_length],
    _F_ = [0, cst_diff_max_min_allowed_key],
    _G_ = [0, cst_min_key_in_same_slot_mask],
    _H_ = [0, cst_keys_per_slot],
    _I_ = [0, cst_bits_per_slot],
    _J_ = [0, cst_slots_mask],
    _K_ = [0, cst_bits],
    _L_ = [0, cst_index];
   function sexp_of_t$9(of_a_044, param){
    var
     diff_max_min_allowed_key_058 = param[7],
     min_key_in_same_slot_mask_056 = param[6],
     keys_per_slot_054 = param[5],
     bits_per_slot_052 = param[4],
     slots_mask_050 = param[3],
     bits_048 = param[2],
     index_046 = param[1],
     length_060 = param[8],
     min_allowed_key_062 = param[9],
     max_allowed_key_064 = param[10],
     slots_066 = param[11],
     arg_067 = caml_call1(Sexplib0_Sexp_conv[23], slots_066),
     bnds_045 = [0, [1, [0, _B_, [0, arg_067, 0]]], 0],
     arg_065 = caml_call1(sexp_of_t$7, max_allowed_key_064),
     bnds_045$0 = [0, [1, [0, _C_, [0, arg_065, 0]]], bnds_045],
     arg_063 = caml_call1(sexp_of_t$7, min_allowed_key_062),
     bnds_045$1 = [0, [1, [0, _D_, [0, arg_063, 0]]], bnds_045$0],
     arg_061 = caml_call1(Core[363], length_060),
     bnds_045$2 = [0, [1, [0, _E_, [0, arg_061, 0]]], bnds_045$1],
     arg_059 = caml_call1(_v_[1], diff_max_min_allowed_key_058),
     bnds_045$3 = [0, [1, [0, _F_, [0, arg_059, 0]]], bnds_045$2],
     arg_057 = caml_call1(sexp_of_t$5, min_key_in_same_slot_mask_056),
     bnds_045$4 = [0, [1, [0, _G_, [0, arg_057, 0]]], bnds_045$3],
     arg_055 = caml_call1(_v_[1], keys_per_slot_054),
     bnds_045$5 = [0, [1, [0, _H_, [0, arg_055, 0]]], bnds_045$4],
     arg_053 = caml_call1(sexp_of_t, bits_per_slot_052),
     bnds_045$6 = [0, [1, [0, _I_, [0, arg_053, 0]]], bnds_045$5],
     arg_051 = caml_call1(sexp_of_t$4, slots_mask_050),
     bnds_045$7 = [0, [1, [0, _J_, [0, arg_051, 0]]], bnds_045$6],
     arg_049 = caml_call1(sexp_of_t, bits_048),
     bnds_045$8 = [0, [1, [0, _K_, [0, arg_049, 0]]], bnds_045$7],
     arg_047 = caml_call1(Core[363], index_046),
     bnds_045$9 = [0, [1, [0, _L_, [0, arg_047, 0]]], bnds_045$8];
    return [1, bnds_045$9];
   }
   function slot(t, key){
    var slots_mask = t[3], bits_per_slot = t[4];
    return caml_call1
            (to_int_exn$0,
             caml_call2
              (bit_and,
               caml_call2(shift_right, key, bits_per_slot),
               slots_mask));
   }
   function next_slot(t, slot){
    var t$0 = t[3];
    return (slot + 1 | 0) & caml_call1(Core_Int63[5], t$0);
   }
   function min_key_in_same_slot(t, key){
    var min_key_in_same_slot_mask = t[6];
    return caml_call2(bit_and, key, min_key_in_same_slot_mask);
   }
   function compute_min_allowed_key(t, prev_level_max_allowed_key){
    return caml_call2(equal$3, prev_level_max_allowed_key, max_value$0)
            ? max_value$0
            : min_key_in_same_slot
              (t, caml_call1(succ$0, prev_level_max_allowed_key));
   }
   function levels(r){return r[5];}
   function elt_key_lower_bound(r){return r[4];}
   function set_elt_key_lower_bound(r, v){r[4] = v; return 0;}
   function min_elt(r){return r[3];}
   function set_min_elt(r, v){r[3] = v; return 0;}
   function pool(r){return r[2];}
   function set_pool(r, v){r[2] = v; return 0;}
   function length$1(r){return r[1];}
   function set_length$0(r, v){r[1] = v; return 0;}
   var
    levels$0 =
      [0,
       function(param){return 0;},
       cst_levels,
       0,
       levels,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v];}],
    elt_key_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_elt_key_lower_bound,
       [0, set_elt_key_lower_bound],
       elt_key_lower_bound,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5]];}],
    min_elt$0 =
      [0,
       function(param){return 0;},
       cst_min_elt,
       [0, set_min_elt],
       min_elt,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5]];}],
    pool$0 =
      [0,
       function(param){return 0;},
       cst_pool,
       [0, set_pool],
       pool,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5]];}],
    length$2 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length$0],
       length$1,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5]];}],
    _R_ = [0, cst_value],
    _S_ = [0, cst_key],
    _T_ = [0, "elts"],
    _U_ = [0, cst_max_allowed_key],
    _V_ = [0, cst_min_allowed_key],
    _as_ = [0, cst_priority_queue],
    _at_ = [0, "max_allowed_key t"],
    _au_ = [0, "min_allowed_key t"],
    _av_ = [0, cst_key],
    cst_Priority_queue_add_elt_key =
      "Priority_queue.add_elt key out of bounds",
    _aw_ = [0, cst],
    _ax_ = [0, "level"],
    _ay_ = [0, cst_key],
    cst_Priority_queue_add_elt_key$0 =
      "Priority_queue.add_elt key out of level bounds",
    _az_ = [0, "max_allowed_alarm_interval_num"],
    _aA_ = [0, "min_allowed_alarm_interval_num"],
    _aB_ = [0, cst_interval_num],
    cst_Timing_wheel_add_at_interv =
      "Timing_wheel.add_at_interval_num got invalid interval num",
    dummy = 0;
   function is_empty(t){return caml_call2(Core[89], t[1], 0);}
   function num_levels(t){return t[5].length - 1;}
   function min_allowed_key$1(t){
    var r = caml_check_bound(t[5], 0)[1];
    return r[9];
   }
   function max_allowed_key$1(t){
    var
     _du_ = num_levels(t) - 1 | 0,
     r = caml_check_bound(t[5], _du_)[1 + _du_];
    return r[10];
   }
   function internal_iter(t, f){
    var _dm_ = caml_call2(Core[90], t[1], 0);
    if(_dm_){
     var pool = t[2], levels = t[5], _do_ = levels.length - 2 | 0, _dn_ = 0;
     if(_do_ >= 0){
      var level_index = _dn_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[90], level[8], 0)){
        var slots = level[11], _dr_ = slots.length - 2 | 0, _dq_ = 0;
        if(_dr_ >= 0){
         var slot_index = _dq_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)) iter(pool, elt, f);
          var _dt_ = slot_index + 1 | 0;
          if(_dr_ === slot_index) break;
          slot_index = _dt_;
         }
        }
       }
       var _ds_ = level_index + 1 | 0;
       if(_do_ === level_index) break;
       level_index = _ds_;
      }
     }
     var _dp_ = 0;
    }
    else
     var _dp_ = _dm_;
    return _dp_;
   }
   function compute_diff_max_min_allowed_k(level_bits, bits_per_slot){
    var num_bits = symbol$2(level_bits, bits_per_slot);
    if(caml_call2(equal, num_bits, max_num_bits)) return _v_[26];
    var _dl_ = pow2(num_bits);
    return caml_call1(_v_[32], _dl_);
   }
   function min_elt$1(t){
    if(is_empty(t)) return caml_call1(null$1, 0);
    if(! caml_call1(is_null, t[3])) return t[3];
    var
     pool = t[2],
     min_elt_already_found = [0, caml_call1(null$1, 0)],
     min_key_already_found = [0, max_value$0],
     level_index = [0, 0],
     num_levels$0 = num_levels(t);
    for(;;){
     if(! caml_call2(Core[91], level_index[1], num_levels$0)){
      t[3] = min_elt_already_found[1];
      t[4] = min_key_already_found[1];
      return t[3];
     }
     var
      _di_ = level_index[1],
      level = caml_check_bound(t[5], _di_)[1 + _di_];
     if(caml_call2(symbol$18, level[9], min_key_already_found[1]))
      level_index[1] = num_levels$0;
     else if(caml_call2(Core[89], level[8], 0))
      level_index[1]++;
     else{
      var
       slots = level[11],
       slot_min_key =
         [0, min_key_in_same_slot(level, caml_call2(max$0, level[9], t[4]))],
       slot$0 = [0, slot(level, slot_min_key[1])];
      for(;;){
       var _dj_ = slot$0[1];
       if(! caml_call1(is_null, caml_check_bound(slots, _dj_)[1 + _dj_]))
        break;
       if(! caml_call2(symbol$19, slot_min_key[1], min_key_already_found[1]))
        break;
       slot$0[1] = next_slot(level, slot$0[1]);
       var i = level[5], t$0 = slot_min_key[1];
       slot_min_key[1] = caml_call2(symbol$13, t$0, i);
      }
      var _dk_ = slot$0[1], first = caml_check_bound(slots, _dk_)[1 + _dk_];
      if(1 - caml_call1(is_null, first)){
       var continue$0 = [0, 1], current = [0, first];
       for(;;){
        if(! continue$0[1]) break;
        var current_key = key(pool, current[1]);
        if(caml_call2(symbol$16, current_key, min_key_already_found[1])){
         min_elt_already_found[1] = current[1];
         min_key_already_found[1] = current_key;
        }
        var next$0 = next(pool, current[1]);
        a:
        {
         if(next$0 !== first && ! caml_call2(Core[89], level_index[1], 0)){current[1] = next$0; break a;}
         continue$0[1] = 0;
        }
       }
      }
      level_index[1]++;
     }
    }
   }
   function add_elt(x_114, to_add){
    var
     pool$0 = x_114[2],
     key$0 = key(pool$0, to_add),
     _db_ = caml_call2(symbol$15, key$0, min_allowed_key$1(x_114)),
     _dc_ =
       _db_ ? caml_call2(symbol$16, key$0, max_allowed_key$1(x_114)) : _db_;
    if(1 - _dc_){
     var pool = x_114[2], r = [0, 0];
     internal_iter
      (x_114,
       function(elt){
        var _dg_ = r[1], _dh_ = value(pool, elt);
        r[1] = [0, [0, key(pool, elt), _dh_], _dg_];
        return 0;
       });
     var
      elts_094 = caml_call1(Core_List[57], r[1]),
      max_allowed_key_092 = max_allowed_key$1(x_114),
      min_allowed_key_090 = min_allowed_key$1(x_114),
      arg_095 =
        caml_call2
         (Core[431],
          function(param){
           var
            key_084 = param[1],
            bnds_083 = [0, [1, [0, _R_, [0, arg_087, 0]]], 0],
            arg_085 = caml_call1(sexp_of_t$7, key_084),
            bnds_083$0 = [0, [1, [0, _S_, [0, arg_085, 0]]], bnds_083];
           return [1, bnds_083$0];
          },
          elts_094),
      bnds_089 = [0, [1, [0, _T_, [0, arg_095, 0]]], 0],
      arg_093 = caml_call1(sexp_of_t$7, max_allowed_key_092),
      bnds_089$0 = [0, [1, [0, _U_, [0, arg_093, 0]]], bnds_089],
      arg_091 = caml_call1(sexp_of_t$7, min_allowed_key_090),
      bnds_089$1 = [0, [1, [0, _V_, [0, arg_091, 0]]], bnds_089$0],
      _c6_ =
        [0,
         [1,
          [0, _at_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(x_114)), 0]]],
         [0, [1, [0, _as_, [0, [1, bnds_089$1], 0]]], 0]],
      _c7_ =
        [0,
         [1,
          [0, _au_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(x_114)), 0]]],
         _c6_],
      _c8_ = [0, [1, [0, _av_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _c7_],
      _c9_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key),
          _c8_]];
     caml_call1(Core[255], _c9_);
    }
    var level_index = [0, 0];
    for(;;){
     var
      _dd_ = level_index[1],
      r$0 = caml_check_bound(x_114[5], _dd_)[1 + _dd_];
     if(! caml_call2(symbol$18, key$0, r$0[10])) break;
     level_index[1]++;
    }
    var
     level_index$0 = level_index[1],
     level = caml_check_bound(x_114[5], level_index$0)[1 + level_index$0],
     _de_ = caml_call2(symbol$15, key$0, level[9]),
     _df_ = _de_ ? caml_call2(symbol$16, key$0, level[10]) : _de_;
    if(1 - _df_){
     var
      _c__ =
        [0,
         [1,
          [0, _ax_, [0, sexp_of_t$9(function(param){return _aw_;}, level), 0]]],
         0],
      _c$_ = [0, [1, [0, _ay_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _c__],
      _da_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key$0),
          _c$_]];
     caml_call1(Core[255], _da_);
    }
    level[8] = level[8] + 1 | 0;
    caml_call4
     (Tuple_pool[36][33], pool$0, to_add, Tuple_pool[36][2][6], level_index$0);
    var
     slot$0 = slot(level, key$0),
     slots = level[11],
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(caml_call1(is_null, first)){
     caml_check_bound(slots, slot$0)[1 + slot$0] = to_add;
     return link(pool$0, to_add, to_add);
    }
    var prev$0 = prev(pool$0, first);
    link(pool$0, prev$0, to_add);
    return link(pool$0, to_add, first);
   }
   function internal_add_elt(t, elt){
    var key$0 = key(t[2], elt);
    if(caml_call2(symbol$19, key$0, t[4])){t[3] = elt; t[4] = key$0;}
    add_elt(t, elt);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function ensure_valid_key(t, key){
    var
     _c4_ = caml_call2(symbol$19, key, min_allowed_key$1(t)),
     _c5_ = _c4_ || caml_call2(symbol$18, key, max_allowed_key$1(t));
    if(! _c5_) return _c5_;
    var
     _c0_ =
       [0,
        [1, [0, _az_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(t)), 0]]],
        0],
     _c1_ =
       [0,
        [1, [0, _aA_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(t)), 0]]],
        _c0_],
     _c2_ = [0, [1, [0, _aB_, [0, caml_call1(sexp_of_t$7, key), 0]]], _c1_],
     _c3_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_add_at_interv),
         _c2_]];
    return caml_call1(Core[255], _c3_);
   }
   function internal_add(t, key, at, value){
    ensure_valid_key(t, key);
    if(caml_call1(is_full, t[2])) t[2] = caml_call2(grow, 0, t[2]);
    var
     pool = t[2],
     _cY_ = caml_call1(null$1, 0),
     _cZ_ = caml_call1(null$1, 0),
     elt =
       caml_call7(Tuple_pool[36][21], pool, key, at, value, -1, _cZ_, _cY_);
    internal_add_elt(t, elt);
    return elt;
   }
   function internal_remove(t, elt){
    var pool = t[2], t2 = t[3];
    if(caml_call2(Tuple_pool[36][3][7], elt, t2))
     t[3] = caml_call1(null$1, 0);
    t[1] = t[1] - 1 | 0;
    var
     _cV_ = level_index(pool, elt),
     level = caml_check_bound(t[5], _cV_)[1 + _cV_];
    level[8] = level[8] - 1 | 0;
    var
     slots = level[11],
     slot$0 = slot(level, key(pool, elt)),
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(elt === next(pool, elt)){
     var _cW_ = caml_call1(null$1, 0);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _cW_;
     return;
    }
    if(elt === first){
     var _cX_ = next(pool, elt);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _cX_;
    }
    var _cT_ = next(pool, elt);
    set_next(pool, prev(pool, elt), _cT_);
    var _cU_ = prev(pool, elt);
    return set_prev(pool, next(pool, elt), _cU_);
   }
   var
    _aC_ =
      [0,
       _v_,
       sexp_of_t$7,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       equal$3,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       validate_lbound$0,
       validate_ubound$0,
       validate_bound$0,
       Replace_polymorphic_compare$0,
       [0,
        [0, _s_[9], _s_[10], _s_[11]],
        Map$0[2],
        Map$0[3],
        Map$0[4],
        Map$0[5],
        Map$0[6],
        Map$0[7],
        Map$0[8],
        Map$0[9],
        Map$0[10],
        Map$0[11],
        Map$0[12],
        Map$0[13],
        Map$0[14],
        Map$0[15],
        Map$0[16],
        Map$0[17],
        Map$0[18],
        Map$0[19],
        Map$0[20],
        Map$0[21],
        Map$0[22],
        Map$0[23],
        Map$0[24],
        Map$0[25],
        Map$0[26],
        Map$0[27],
        Map$0[28],
        Map$0[29],
        Map$0[30],
        Map$0[31],
        Map$0[32],
        Map$0[33],
        Map$0[34],
        Map$0[35],
        Map$0[36],
        Map$0[37],
        Map$0[38],
        Map$0[39],
        Map$0[40],
        Map$0[41],
        Map$0[42]],
       [0,
        [0, _r_[1], _r_[2], _r_[11]],
        Set$0[2],
        Set$0[3],
        Set$0[4],
        Set$0[5],
        Set$0[6],
        Set$0[7],
        Set$0[8],
        Set$0[9],
        Set$0[10],
        Set$0[11],
        Set$0[12],
        Set$0[13],
        Set$0[14],
        Set$0[15],
        Set$0[16],
        Set$0[17],
        Set$0[18],
        Set$0[19],
        Set$0[20],
        Set$0[21],
        Set$0[22],
        Set$0[23],
        Set$0[24],
        Set$0[25],
        Set$0[26],
        Set$0[27]],
       compare$2,
       hash_fold_t,
       hash,
       hashable,
       [0,
        Table[1],
        Table[2],
        Table[3],
        Table[4],
        Table[5],
        Table[6],
        Table[7],
        Table[8],
        Table[9],
        Table[10],
        Table[11],
        Table[12],
        Table[13],
        Table[14],
        Table[15],
        Table[16],
        Table[17],
        Table[18]],
       [0,
        Hash_set[1],
        Hash_set[2],
        Hash_set[3],
        Hash_set[4],
        Hash_set[5],
        Hash_set[6],
        Hash_set[7]],
       Hash_queue,
       max$0,
       min$0,
       zero$1,
       one$1,
       min_value$0,
       max_value$0,
       of_int63$0,
       to_int63$0,
       of_int$1,
       to_int_exn$0,
       add,
       sub,
       diff,
       succ$0,
       pred$0,
       rem],
    min_interval_num = _aC_[31];
   function priority_queue(r){return r[7];}
   function max_allowed_alarm_time(r){return r[6];}
   function set_max_allowed_alarm_time(r, v){r[6] = v; return 0;}
   function now_interval_num_start(r){return r[5];}
   function set_now_interval_num_start(r, v){r[5] = v; return 0;}
   function now(r){return r[4];}
   function set_now(r, v){r[4] = v; return 0;}
   function max_interval_num(r){return r[3];}
   function start(r){return r[2];}
   function config(r){return r[1];}
   var
    priority_queue$0 =
      [0,
       function(param){return 0;},
       cst_priority_queue,
       0,
       priority_queue,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}],
    max_allowed_alarm_time$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_alarm_time,
       [0, set_max_allowed_alarm_time],
       max_allowed_alarm_time,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}],
    now_interval_num_start$0 =
      [0,
       function(param){return 0;},
       cst_now_interval_num_start,
       [0, set_now_interval_num_start],
       now_interval_num_start,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}],
    now$0 =
      [0,
       function(param){return 0;},
       cst_now,
       [0, set_now],
       now,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}],
    max_interval_num$0 =
      [0,
       function(param){return 0;},
       cst_max_interval_num,
       0,
       max_interval_num,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}],
    start$0 =
      [0,
       function(param){return 0;},
       cst_start,
       0,
       start,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}],
    config$0 =
      [0,
       function(param){return 0;},
       cst_config,
       0,
       config,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}],
    _w_ = [0, cst_timing_wheel_src_timing_wh, 653, 8],
    _x_ = [0, cst_timing_wheel_src_timing_wh, 651, 8],
    _y_ = [0, cst_timing_wheel_src_timing_wh, 648, 8],
    _z_ = [0, cst],
    _A_ = [0, cst_timing_wheel_src_timing_wh, 647, 23049, 23075],
    _M_ = [0, cst_levels],
    _N_ = [0, cst_elt_key_lower_bound],
    _O_ = [0, cst_min_elt],
    _P_ = [0, cst_pool],
    _Q_ = [0, cst_length],
    _W_ = [0, cst_timing_wheel_src_timing_wh, 959, 21],
    _X_ = [0, cst_timing_wheel_src_timing_wh, 958, 21],
    _Y_ = [0, cst_timing_wheel_src_timing_wh, 957, 21],
    _Z_ = [0, cst_timing_wheel_src_timing_wh, 956, 21],
    ___ = [0, cst_timing_wheel_src_timing_wh, 935, 15],
    _$_ = [0, cst_timing_wheel_src_timing_wh, 927, 15],
    _aa_ = [0, cst_timing_wheel_src_timing_wh, 914, 15],
    _ab_ = [0, cst_timing_wheel_src_timing_wh, 906, 15],
    _ac_ = [0, cst_timing_wheel_src_timing_wh, 899, 36],
    _ad_ = [0, cst_timing_wheel_src_timing_wh, 898, 38],
    _ae_ = [0, cst],
    _af_ = [0, cst_timing_wheel_src_timing_wh, 895, 31577, 31603],
    _ag_ = [0, cst_timing_wheel_src_timing_wh, 986, 15],
    _ah_ = [0, cst_timing_wheel_src_timing_wh, 984, 13],
    _ai_ = [0, cst_timing_wheel_src_timing_wh, 981, 15],
    _aj_ = [0, cst_timing_wheel_src_timing_wh, 978, 13],
    _ak_ = [0, cst_timing_wheel_src_timing_wh, 977, 13],
    _al_ = [0, cst_timing_wheel_src_timing_wh, 974, 15],
    _am_ = [0, cst_timing_wheel_src_timing_wh, 973, 15],
    _an_ = [0, cst_timing_wheel_src_timing_wh, 967, 38],
    _ao_ = [0, cst_timing_wheel_src_timing_wh, 965, 6],
    _ap_ = [0, cst_timing_wheel_src_timing_wh, 964, 6],
    _aq_ = [0, cst],
    _ar_ = [0, cst_timing_wheel_src_timing_wh, 962, 34674, 34698],
    _aD_ = [0, cst_value],
    _aE_ = [0, cst_at],
    _aF_ = [0, "alarms"],
    _aG_ = [0, cst_now],
    _aH_ = [0, cst_max_interval_num],
    _aI_ = [0, cst_start],
    _aJ_ = [0, cst_config],
    _aK_ = [0, cst],
    _aL_ = [0, cst_timing_wheel],
    cst_Timing_wheel_next_alarm_fi =
      "Timing_wheel.next_alarm_fires_at_exn of empty timing wheel",
    _aM_ = [0, cst],
    _aN_ = [0, cst_timing_wheel],
    cst_Timing_wheel_next_alarm_fi$0 =
      "Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval",
    _aO_ = [0, "time"],
    cst_Timing_wheel_interval_num_ =
      "Timing_wheel.interval_num got time too far in the past",
    _aP_ = [0, "min_interval_num"],
    _aQ_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$0 =
      "Timing_wheel.interval_num_start got too small interval_num",
    _aR_ = [0, "t.max_interval_num"],
    _aS_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$1 =
      "Timing_wheel.interval_num_start got too large interval_num",
    _aT_ = [0, cst_timing_wheel_src_timing_wh, 1626, 11],
    _aU_ = [0, cst_timing_wheel_src_timing_wh, 1625, 11],
    _aV_ = [0, cst_timing_wheel_src_timing_wh, 1624, 11],
    _aW_ = [0, cst_timing_wheel_src_timing_wh, 1613, 11],
    _aX_ = [0, cst_timing_wheel_src_timing_wh, 1612, 11],
    _aY_ = [0, cst_timing_wheel_src_timing_wh, 1648, 6],
    _aZ_ = [0, cst_timing_wheel_src_timing_wh, 1646, 6],
    _a0_ = [0, cst_timing_wheel_src_timing_wh, 1642, 6],
    _a1_ = [0, cst],
    _a2_ = [0, cst_timing_wheel_src_timing_wh, 1606, 58039, 58061];
   function sexp_of_t_now(param, t){
    return caml_call1(Core_Time_ns_alternate_sexp[92], t[4]);
   }
   function alarm_precision$0(t){return alarm_precision(t[1]);}
   function at$0(tw, t){
    var p = tw[7], _cS_ = of_external_exn(p[2], t);
    return at(p[2], _cS_);
   }
   function value$0(tw, t){
    var p = tw[7], _cR_ = of_external_exn(p[2], t);
    return value(p[2], _cR_);
   }
   function interval_num(tw, t){
    var p = tw[7], _cQ_ = of_external_exn(p[2], t);
    return key(p[2], _cQ_);
   }
   function iter$0(t, f){var t$0 = t[7]; return internal_iter(t$0, f);}
   function compare$3(t1, t2){
    return caml_call2(Core_Time_ns_alternate_sexp[101], t1[1], t2[1]);
   }
   function sexp_of_t$10(sexp_of_a, t){
    var
     max_interval_num_146 = t[3],
     start_144 = t[2],
     config_142 = t[1],
     now_148 = t[4],
     r = [0, 0];
    iter$0
     (t,
      function(alarm){
       var _cP_ = r[1], _cO_ = value$0(t, alarm);
       r[1] = [0, [0, at$0(t, alarm), _cO_], _cP_];
       return 0;
      });
    var
     alarms_150 = caml_call2(Core_List[77], r[1], compare$3),
     arg_151 =
       caml_call2
        (Core[431],
         function(param){
          var
           value_138 = param[2],
           at_136 = param[1],
           arg_139 = caml_call1(sexp_of_a, value_138),
           bnds_135 = [0, [1, [0, _aD_, [0, arg_139, 0]]], 0],
           arg_137 = caml_call1(Core_Time_ns_alternate_sexp[92], at_136),
           bnds_135$0 = [0, [1, [0, _aE_, [0, arg_137, 0]]], bnds_135];
          return [1, bnds_135$0];
         },
         alarms_150),
     bnds_141 = [0, [1, [0, _aF_, [0, arg_151, 0]]], 0],
     arg_149 = caml_call1(Core_Time_ns_alternate_sexp[92], now_148),
     bnds_141$0 = [0, [1, [0, _aG_, [0, arg_149, 0]]], bnds_141],
     arg_147 = caml_call1(_aC_[2], max_interval_num_146),
     bnds_141$1 = [0, [1, [0, _aH_, [0, arg_147, 0]]], bnds_141$0],
     arg_145 = caml_call1(Core_Time_ns_alternate_sexp[92], start_144),
     bnds_141$2 = [0, [1, [0, _aI_, [0, arg_145, 0]]], bnds_141$1],
     arg_143 = sexp_of_t$3(config_142),
     bnds_141$3 = [0, [1, [0, _aJ_, [0, arg_143, 0]]], bnds_141$2];
    return [1, bnds_141$3];
   }
   function length$3(t){var r = t[7]; return r[1];}
   function is_empty$0(t){
    var _cN_ = length$3(t);
    return caml_call2(Core[89], _cN_, 0);
   }
   function pool$1(t){var r = t[7]; return r[2];}
   function interval_num_internal(time, alarm_precision){
    var
     _cL_ = caml_call1(Core_Time_ns_alternate_sexp[61], time),
     _cM_ = caml_call2(Core_Int63[49], _cL_, alarm_precision);
    return caml_call1(_aC_[35], _cM_);
   }
   function interval_num_unchecked(t, time){
    return interval_num_internal(time, t[1][1]);
   }
   function interval_num$0(t, time){
    if(caml_call2(Core_Time_ns_alternate_sexp[98], time, min_time)){
     var
      _cJ_ =
        [0,
         [1,
          [0, _aO_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], time), 0]]],
         0],
      _cK_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_),
          _cJ_]];
     caml_call1(Core[255], _cK_);
    }
    return interval_num_unchecked(t, time);
   }
   function interval_num_start_unchecked(t, interval_num){
    var
     interval_num$0 = caml_call1(_aC_[36], interval_num),
     t$0 = t[1][1],
     _cI_ = caml_call2(Core_Int63[48], interval_num$0, t$0);
    return caml_call1(Core_Time_ns_alternate_sexp[62], _cI_);
   }
   function interval_num_start(t, interval_num){
    if(caml_call2(_aC_[7], interval_num, min_interval_num)){
     var
      _cC_ =
        [0, [1, [0, _aP_, [0, caml_call1(_aC_[2], min_interval_num), 0]]], 0],
      _cD_ =
        [0, [1, [0, _aQ_, [0, caml_call1(_aC_[2], interval_num), 0]]], _cC_],
      _cE_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$0),
          _cD_]];
     caml_call1(Core[255], _cE_);
    }
    if(caml_call2(_aC_[6], interval_num, t[3])){
     var
      _cF_ = [0, [1, [0, _aR_, [0, caml_call1(_aC_[2], t[3]), 0]]], 0],
      _cG_ =
        [0, [1, [0, _aS_, [0, caml_call1(_aC_[2], interval_num), 0]]], _cF_],
      _cH_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$1),
          _cG_]];
     caml_call1(Core[255], _cH_);
    }
    return interval_num_start_unchecked(t, interval_num);
   }
   function next_alarm_fires_at_internal(t, key){
    return interval_num_start(t, caml_call1(_aC_[42], key));
   }
   function next_alarm_fires_at(t){
    var elt = min_elt$1(t[7]);
    if(caml_call1(is_null, elt)) return 0;
    var key$0 = key(pool$1(t), elt);
    return caml_call2(_aC_[9], key$0, t[3])
            ? 0
            : [0, next_alarm_fires_at_internal(t, key$0)];
   }
   function next_alarm_fires_at_exn(x_153){
    var elt = min_elt$1(x_153[7]);
    if(caml_call1(is_null, elt)){
     var
      _cy_ =
        [0,
         [1,
          [0,
           _aL_,
           [0, sexp_of_t$10(function(param){return _aK_;}, x_153), 0]]],
         0],
      _cz_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi),
          _cy_]];
     caml_call1(Core[255], _cz_);
    }
    var key$0 = key(pool$1(x_153), elt);
    if(caml_call2(_aC_[9], key$0, x_153[3])){
     var
      _cA_ =
        [0,
         [1,
          [0,
           _aN_,
           [0, sexp_of_t$10(function(param){return _aM_;}, x_153), 0]]],
         0],
      _cB_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi$0),
          _cA_]];
     caml_call1(Core[255], _cB_);
    }
    return next_alarm_fires_at_internal(x_153, key$0);
   }
   function compute_max_allowed_alarm_time(t){
    var max_allowed_key = max_allowed_key$1(t[7]);
    if(caml_call2(_aC_[3], max_allowed_key, t[3])) return max_time;
    var
     _cu_ = Core_Time_ns[1][67],
     _cv_ = alarm_precision$0(t),
     _cw_ = caml_call2(Core_Time_ns[1][101], _cv_, _cu_),
     _cx_ = interval_num_start_unchecked(t, max_allowed_key);
    return caml_call2(Core_Time_ns_alternate_sexp[51], _cx_, _cw_);
   }
   function now_interval_num(t){return min_allowed_key$1(t[7]);}
   function max_allowed_alarm_interval_num(t){return interval_num$0(t, t[6]);}
   function interval_start(t, time){
    return interval_num_start_unchecked(t, interval_num$0(t, time));
   }
   function invariant$2(invariant_a, t){
    return caml_call4
            (Base_Invariant[1],
             _a2_,
             t,
             function(x_155){
              return sexp_of_t$10(function(param){return _a1_;}, x_155);
             },
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               priority_queue_fun =
                 check
                  (function(t){
                    var pool = t[2];
                    return caml_call4
                            (Base_Invariant[1],
                             _ar_,
                             t,
                             function(x_109){
                              function of_a_068(param){return _aq_;}
                              var
                               length_070 = x_109[1],
                               pool_072 = x_109[2],
                               min_elt_074 = x_109[3],
                               elt_key_lower_bound_076 = x_109[4],
                               levels_078 = x_109[5],
                               arg_079 =
                                 caml_call2
                                  (Core[291],
                                   function(_ct_){return sexp_of_t$9(of_a_068, _ct_);},
                                   levels_078),
                               bnds_069 = [0, [1, [0, _M_, [0, arg_079, 0]]], 0],
                               arg_077 = caml_call1(sexp_of_t$7, elt_key_lower_bound_076),
                               bnds_069$0 = [0, [1, [0, _N_, [0, arg_077, 0]]], bnds_069],
                               arg_075 = sexp_of_t$8(of_a_068, min_elt_074),
                               bnds_069$1 = [0, [1, [0, _O_, [0, arg_075, 0]]], bnds_069$0],
                               arg_073 =
                                 caml_call2
                                  (Tuple_pool[36][4],
                                   function(_cs_){return sexp_of_pool_slots(of_a_068, _cs_);},
                                   pool_072),
                               bnds_069$2 = [0, [1, [0, _P_, [0, arg_073, 0]]], bnds_069$1],
                               arg_071 = caml_call1(Core[363], length_070),
                               bnds_069$3 = [0, [1, [0, _Q_, [0, arg_071, 0]]], bnds_069$2];
                              return [1, bnds_069$3];
                             },
                             function(param){
                              function check(f){
                               return caml_call2(Base_Invariant[2], t, f);
                              }
                              if(! caml_call2(symbol$15, min_allowed_key$1(t), zero$1))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _ap_], 1);
                              var _ca_ = min_allowed_key$1(t);
                              if(! caml_call2(symbol$15, max_allowed_key$1(t), _ca_))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _ao_], 1);
                              var
                               levels_fun =
                                 check
                                  (function(levels){
                                    var _cf_ = num_levels(t);
                                    if(caml_call2(Core[90], _cf_, 0))
                                     return caml_call2
                                             (Core_Array[47],
                                              levels,
                                              function(level_index$0, level){
                                               if(! caml_call2(Core[89], level_index$0, level[1]))
                                                throw caml_maybe_attach_backtrace
                                                       ([0, Assert_failure, _ag_], 1);
                                               caml_call4
                                                (Base_Invariant[1],
                                                 _af_,
                                                 level,
                                                 function(x_098){
                                                  return sexp_of_t$9(function(param){return _ae_;}, x_098);
                                                 },
                                                 function(param){
                                                  function check(f){
                                                   return caml_call2(Base_Invariant[2], level, f);
                                                  }
                                                  var
                                                   slots_fun =
                                                     check
                                                      (function(slots){
                                                        return caml_call2
                                                                (Core_Array[32],
                                                                 slots,
                                                                 function(elt){
                                                                  var _ck_ = 1 - caml_call1(is_null, elt);
                                                                  return _ck_
                                                                          ? (caml_call4
                                                                             (Base_Invariant[1],
                                                                              _A_,
                                                                              elt,
                                                                              function(x_041){
                                                                               return sexp_of_t$8(function(param){return _z_;}, x_041);
                                                                              },
                                                                              function(param){
                                                                               if(! is_valid(pool, elt))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _y_], 1);
                                                                               caml_call1(invariant_a, value(pool, elt));
                                                                               var n = next(pool, elt);
                                                                               if(! caml_call1(is_null, n)){
                                                                                var _cm_ = prev(pool, n);
                                                                                if(! caml_call2(Tuple_pool[36][3][7], elt, _cm_))
                                                                                 throw caml_maybe_attach_backtrace
                                                                                        ([0, Assert_failure, _x_], 1);
                                                                               }
                                                                               var p = prev(pool, elt);
                                                                               if(! caml_call1(is_null, p)){
                                                                                var _cl_ = next(pool, p);
                                                                                if(! caml_call2(Tuple_pool[36][3][7], elt, _cl_))
                                                                                 throw caml_maybe_attach_backtrace
                                                                                        ([0, Assert_failure, _w_], 1);
                                                                               }
                                                                               return 0;
                                                                              }),
                                                                            iter
                                                                             (pool,
                                                                              elt,
                                                                              function(elt){
                                                                               var _cn_ = level[9];
                                                                               if(! caml_call2(symbol$15, key(pool, elt), _cn_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _Z_], 1);
                                                                               var _co_ = level[10];
                                                                               if(! caml_call2(symbol$16, key(pool, elt), _co_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _Y_], 1);
                                                                               var _cp_ = t[4];
                                                                               if(! caml_call2(symbol$15, key(pool, elt), _cp_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _X_], 1);
                                                                               var _cq_ = level[1], _cr_ = level_index(pool, elt);
                                                                               if(caml_call2(Core[89], _cr_, _cq_))
                                                                                return caml_call1(invariant_a, value(pool, elt));
                                                                               throw caml_maybe_attach_backtrace
                                                                                      ([0, Assert_failure, _W_], 1);
                                                                              }))
                                                                          : _ck_;
                                                                 });
                                                       }),
                                                   max_allowed_key_fun =
                                                     check
                                                      (function(max_allowed_key){
                                                        var expect = add_clamp_to_max(level[9], level[7]);
                                                        function comparator(a_107, b_108){
                                                         return caml_call2(compare$2, a_107, b_108);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos,
                                                                 sexp_of_t$7,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 max_allowed_key);
                                                       }),
                                                   min_allowed_key_fun =
                                                     check
                                                      (function(min_allowed_key){
                                                        if(! caml_call2(symbol$15, min_allowed_key, zero$1))
                                                         throw caml_maybe_attach_backtrace
                                                                ([0, Assert_failure, ___], 1);
                                                        var
                                                         _cj_ = caml_call2(symbol$19, min_allowed_key, max_value$0);
                                                        if(! _cj_) return _cj_;
                                                        var
                                                         got = caml_call2(rem, min_allowed_key, level[5]),
                                                         expect = _v_[24],
                                                         sexpifier = _v_[1];
                                                        function comparator(a_105, b_106){
                                                         return caml_call2(_v_[9], a_105, b_106);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$0,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 got);
                                                       }),
                                                   length_fun =
                                                     check
                                                      (function(length){
                                                        var
                                                         _ci_ =
                                                           caml_call3
                                                            (Core_Array[33],
                                                             level[11],
                                                             0,
                                                             function(n, first){
                                                              if(caml_call1(is_null, first)) return n;
                                                              var r = [0, 0], current = [0, first], continue$0 = [0, 1];
                                                              for(;;){
                                                               if(! continue$0[1]) return n + r[1] | 0;
                                                               r[1]++;
                                                               var next$0 = next(pool, current[1]);
                                                               if(next$0 === first)
                                                                continue$0[1] = 0;
                                                               else
                                                                current[1] = next$0;
                                                              }
                                                             });
                                                        if(caml_call2(Core[89], length, _ci_)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _$_], 1);
                                                       }),
                                                   expect = compute_diff_max_min_allowed_k(level[2], level[4]),
                                                   diff_max_min_allowed_key_fun =
                                                     check
                                                      (function(eta){
                                                        var sexpifier = _v_[1];
                                                        function comparator(a_103, b_104){
                                                         return caml_call2(_v_[9], a_103, b_104);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$1,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 eta);
                                                       }),
                                                   min_key_in_same_slot_mask_fun =
                                                     check
                                                      (function(min_key_in_same_slot_mask){
                                                        if
                                                         (caml_call2
                                                           (equal$1, min_key_in_same_slot_mask, create$1(level[4])))
                                                         return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _aa_], 1);
                                                       }),
                                                   keys_per_slot_fun =
                                                     check
                                                      (function(keys_per_slot){
                                                        var
                                                         num_bits = level[4],
                                                         expect = pow2(num_bits),
                                                         sexpifier = _v_[1];
                                                        function comparator(a_101, b_102){
                                                         return caml_call2(_v_[9], a_101, b_102);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$2,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 keys_per_slot);
                                                       }),
                                                   bits_per_slot_fun =
                                                     check
                                                      (function(bits_per_slot){
                                                        if(caml_call2(symbol, bits_per_slot, zero)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ab_], 1);
                                                       }),
                                                   expect$0 = create$0(level[2]),
                                                   slots_mask_fun =
                                                     check
                                                      (function(eta){
                                                        function comparator(a_099, b_100){
                                                         return caml_call2(compare$0, a_099, b_100);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$3,
                                                                 sexp_of_t$4,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect$0,
                                                                 eta);
                                                       }),
                                                   bits_fun =
                                                     check
                                                      (function(bits){
                                                        if(caml_call2(symbol$1, bits, zero)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ac_], 1);
                                                       }),
                                                   index_fun =
                                                     check
                                                      (function(index){
                                                        if(caml_call2(Core[87], index, 0)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ad_], 1);
                                                       });
                                                  caml_call1(index_fun, index$0);
                                                  caml_call1(bits_fun, bits$0);
                                                  caml_call1(slots_mask_fun, slots_mask$0);
                                                  caml_call1(bits_per_slot_fun, bits_per_slot$0);
                                                  caml_call1(keys_per_slot_fun, keys_per_slot$0);
                                                  caml_call1
                                                   (min_key_in_same_slot_mask_fun, min_key_in_same_slot_mask$0);
                                                  caml_call1
                                                   (diff_max_min_allowed_key_fun, diff_max_min_allowed_key$0);
                                                  caml_call1(length_fun, length$0);
                                                  caml_call1(min_allowed_key_fun, min_allowed_key$0);
                                                  caml_call1(max_allowed_key_fun, max_allowed_key$0);
                                                  return caml_call1(slots_fun, slots$0);
                                                 });
                                               var _cg_ = caml_call2(Core[90], level_index$0, 0);
                                               if(! _cg_) return _cg_;
                                               var
                                                _ch_ = level_index$0 - 1 | 0,
                                                prev_level = caml_check_bound(levels, _ch_)[1 + _ch_],
                                                got$0 = level[5],
                                                expect = caml_call1(_v_[33], prev_level[7]),
                                                sexpifier = _v_[1];
                                               function comparator(a_110, b_111){
                                                return caml_call2(_v_[9], a_110, b_111);
                                               }
                                               caml_call8
                                                (Ppx_assert_lib_Runtime[3],
                                                 pos$4,
                                                 sexpifier,
                                                 comparator,
                                                 0,
                                                 0,
                                                 0,
                                                 expect,
                                                 got$0);
                                               var
                                                got = level[9],
                                                expect$0 = compute_min_allowed_key(level, prev_level[10]);
                                               function comparator$0(a_112, b_113){
                                                return caml_call2(compare$2, a_112, b_113);
                                               }
                                               return caml_call8
                                                       (Ppx_assert_lib_Runtime[3],
                                                        pos$5,
                                                        sexp_of_t$7,
                                                        comparator$0,
                                                        0,
                                                        0,
                                                        0,
                                                        expect$0,
                                                        got);
                                              });
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _ah_], 1);
                                   }),
                               elt_key_lower_bound_fun =
                                 check
                                  (function(elt_key_lower_bound){
                                    if
                                     (!
                                      caml_call2
                                       (symbol$15, elt_key_lower_bound, min_allowed_key$1(t)))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _ak_], 1);
                                    if
                                     (!
                                      caml_call2
                                       (symbol$16, elt_key_lower_bound, max_allowed_key$1(t)))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _aj_], 1);
                                    var _ce_ = 1 - caml_call1(is_null, t[3]);
                                    if(! _ce_) return _ce_;
                                    if
                                     (caml_call2(equal$3, elt_key_lower_bound, key(t[2], t[3])))
                                     return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _ai_], 1);
                                   }),
                               min_elt_fun =
                                 check
                                  (function(elt){
                                    var _cc_ = 1 - caml_call1(is_null, elt);
                                    if(! _cc_) return _cc_;
                                    if(! is_valid(t[2], elt))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _am_], 1);
                                    var _cd_ = key(t[2], elt);
                                    if(caml_call2(equal$3, t[4], _cd_)) return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _al_], 1);
                                   }),
                               pool_fun =
                                 check
                                  (function(t){
                                    return caml_call2
                                            (Tuple_pool[36][5], function(_cb_){return 0;}, t);
                                   }),
                               length_fun =
                                 check
                                  (function(length){
                                    if(caml_call2(Core[87], length, 0)) return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _an_], 1);
                                   });
                              caml_call1(length_fun, length$2);
                              caml_call1(pool_fun, pool$0);
                              caml_call1(min_elt_fun, min_elt$0);
                              caml_call1(elt_key_lower_bound_fun, elt_key_lower_bound$0);
                              return caml_call1(levels_fun, levels$0);
                             });
                   }),
               max_allowed_alarm_time_fun =
                 check
                  (function(max_allowed_alarm_time){
                    var
                     expect = compute_max_allowed_alarm_time(t),
                     sexpifier = Core_Time_ns_alternate_sexp[92];
                    function comparator(a_162, b_163){
                     return caml_call2
                             (Core_Time_ns_alternate_sexp[101], a_162, b_163);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$6,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             max_allowed_alarm_time);
                   }),
               now_interval_num_start_fun =
                 check
                  (function(now_interval_num_start){
                    var
                     expect = interval_num_start(t, now_interval_num(t)),
                     sexpifier = Core_Time_ns_alternate_sexp[92];
                    function comparator(a_160, b_161){
                     return caml_call2
                             (Core_Time_ns_alternate_sexp[101], a_160, b_161);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$7,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             now_interval_num_start);
                   }),
               now_fun =
                 check
                  (function(now){
                    if(! caml_call2(Core_Time_ns_alternate_sexp[94], now, t[2]))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aV_], 1);
                    if
                     (!
                      caml_call2(Core_Time_ns_alternate_sexp[95], now, max_time))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aU_], 1);
                    var
                     _b__ = min_allowed_key$1(t[7]),
                     _b$_ = interval_num$0(t, t[4]);
                    if(caml_call2(_aC_[9], _b$_, _b__)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aT_], 1);
                   }),
               max_interval_num_fun =
                 check
                  (function(max_interval_num){
                    var got = interval_num$0(t, max_time), sexpifier = _aC_[2];
                    function comparator(a_156, b_157){
                     return caml_call2(_aC_[22], a_156, b_157);
                    }
                    caml_call8
                     (Ppx_assert_lib_Runtime[3],
                      pos$8,
                      sexpifier,
                      comparator,
                      0,
                      0,
                      0,
                      max_interval_num,
                      got);
                    var
                     got$0 =
                       interval_num$0(t, interval_num_start(t, max_interval_num)),
                     sexpifier$0 = _aC_[2];
                    function comparator$0(a_158, b_159){
                     return caml_call2(_aC_[22], a_158, b_159);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$9,
                             sexpifier$0,
                             comparator$0,
                             0,
                             0,
                             0,
                             max_interval_num,
                             got$0);
                   }),
               start_fun =
                 check
                  (function(start){
                    if
                     (!
                      caml_call2(Core_Time_ns_alternate_sexp[94], start, min_time))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aX_], 1);
                    if
                     (caml_call2
                       (Core_Time_ns_alternate_sexp[95], start, max_time))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aW_], 1);
                   }),
               config_fun = check(invariant$1);
              caml_call1(config_fun, config$0);
              caml_call1(start_fun, start$0);
              caml_call1(max_interval_num_fun, max_interval_num$0);
              caml_call1(now_fun, now$0);
              caml_call1(now_interval_num_start_fun, now_interval_num_start$0);
              caml_call1(max_allowed_alarm_time_fun, max_allowed_alarm_time$0);
              caml_call1(priority_queue_fun, priority_queue$0);
              return iter$0
                      (t,
                       function(alarm){
                        var
                         _b3_ = interval_num$0(t, at$0(t, alarm)),
                         _b4_ = interval_num(t, alarm);
                        if(! caml_call2(_aC_[9], _b4_, _b3_))
                         throw caml_maybe_attach_backtrace
                                ([0, Assert_failure, _a0_], 1);
                        var
                         _b5_ = interval_start(t, t[4]),
                         _b6_ = interval_start(t, at$0(t, alarm));
                        if
                         (! caml_call2(Core_Time_ns_alternate_sexp[94], _b6_, _b5_))
                         throw caml_maybe_attach_backtrace
                                ([0, Assert_failure, _aZ_], 1);
                        var
                         _b7_ = alarm_precision$0(t),
                         _b8_ =
                           caml_call2(Core_Time_ns_alternate_sexp[54], t[4], _b7_),
                         _b9_ = at$0(t, alarm);
                        if(caml_call2(Core_Time_ns_alternate_sexp[97], _b9_, _b8_))
                         return 0;
                        throw caml_maybe_attach_backtrace
                               ([0, Assert_failure, _aY_], 1);
                       });
             });
   }
   var
    debug = 0,
    _a3_ = [0, cst_start],
    cst_Timing_wheel_create_got_st =
      "Timing_wheel.create got start before the epoch",
    _a4_ = [0, cst_timing_wheel_src_timing_wh, 1692, 53],
    _a5_ = [0, cst_max_allowed_alarm_time],
    _a6_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu =
      "Timing_wheel cannot schedule alarm that far in the future",
    _a7_ = [0, cst_now_interval_num_start],
    _a8_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu$0 =
      "Timing_wheel cannot schedule alarm before start of current interval",
    cst_Timing_wheel_cannot_resche =
      "Timing_wheel cannot reschedule alarm not in timing wheel",
    _a9_ = [0, cst],
    _a__ = [0, cst_timing_wheel],
    cst_Timing_wheel_min_alarm_int =
      "Timing_wheel.min_alarm_interval_num_exn of empty timing_wheel",
    _a$_ = [0, cst],
    _ba_ = [0, cst_timing_wheel],
    cst_Timing_wheel_max_alarm_tim = cst_Timing_wheel_max_alarm_tim$1,
    _bb_ = [0, cst],
    _bc_ = [0, cst_timing_wheel],
    cst_Timing_wheel_max_alarm_tim$0 = cst_Timing_wheel_max_alarm_tim$1;
   function advance_clock(t$0, to, handle_removed){
    var _b1_ = caml_call2(Core_Time_ns_alternate_sexp[97], to, t$0[4]);
    if(_b1_){
     t$0[4] = to;
     var t_min_allowed_key = interval_num_unchecked(t$0, to);
     t$0[5] = interval_num_start_unchecked(t$0, t_min_allowed_key);
     var t$1 = t$0[7];
     if(caml_call2(symbol$16, t_min_allowed_key, min_allowed_key$1(t$1)))
      var match = 0;
     else{
      var
       level_index = [0, 0],
       result = [0, 1],
       prev_level_max_allowed_key = [0, caml_call1(pred$0, t_min_allowed_key)],
       levels = t$1[5],
       num_levels$0 = num_levels(t$1);
      for(;;){
       if(! caml_call2(Core[91], level_index[1], num_levels$0)){
        if(caml_call2(symbol$18, t_min_allowed_key, t$1[4])){
         t$1[3] = caml_call1(null$1, 0);
         t$1[4] = min_allowed_key$1(t$1);
        }
        var match = result[1];
        break;
       }
       var
        _b0_ = level_index[1],
        level = caml_check_bound(levels, _b0_)[1 + _b0_],
        min_allowed_key_before = level[9],
        prev_level_max_allowed_key$0 = prev_level_max_allowed_key[1],
        desired_min_allowed_key =
          compute_min_allowed_key(level, prev_level_max_allowed_key$0),
        level_min_allowed_key =
          min_key_in_same_slot
           (level,
            caml_call2
             (min$0,
              desired_min_allowed_key,
              caml_call2(max$0, level[9], t$1[4]))),
        level_min_allowed_key$0 = [0, level_min_allowed_key],
        slot$0 = [0, slot(level, level_min_allowed_key$0[1])],
        keys_per_slot = level[5],
        slots = level[11];
       for(;;){
        if
         (!
          caml_call2
           (symbol$19, level_min_allowed_key$0[1], desired_min_allowed_key))
         break;
        if(caml_call2(Core[89], level[8], 0))
         level_min_allowed_key$0[1] = desired_min_allowed_key;
        else{
         var
          _bX_ = slot$0[1],
          first = caml_check_bound(slots, _bX_)[1 + _bX_];
         if(1 - caml_call1(is_null, first)){
          var _bY_ = caml_call1(null$1, 0), _bZ_ = slot$0[1];
          caml_check_bound(slots, _bZ_)[1 + _bZ_] = _bY_;
          var pool = t$1[2], current = [0, first], continue$0 = [0, 1];
          for(;;){
           if(! continue$0[1]) break;
           var next$0 = next(pool, current[1]);
           level[8] = level[8] - 1 | 0;
           if(caml_call2(symbol$15, key(pool, current[1]), t_min_allowed_key))
            add_elt(t$1, current[1]);
           else{
            t$1[1] = t$1[1] - 1 | 0;
            var t = current[1];
            caml_call1(handle_removed, t);
            caml_call2(free, pool, current[1]);
           }
           if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
          }
         }
         slot$0[1] = next_slot(level, slot$0[1]);
         level_min_allowed_key$0[1] =
          add_clamp_to_max(level_min_allowed_key$0[1], keys_per_slot);
        }
       }
       level[9] = desired_min_allowed_key;
       level[10] = add_clamp_to_max(desired_min_allowed_key, level[7]);
       if(caml_call2(equal$3, level[9], min_allowed_key_before)){level_index[1] = num_levels$0; result[1] = 0;}
       else{
        level_index[1] = level_index[1] + 1 | 0;
        prev_level_max_allowed_key[1] = level[10];
       }
      }
     }
     if(match){t$0[6] = compute_max_allowed_alarm_time(t$0); return 0;}
     var _b2_ = debug;
    }
    else
     var _b2_ = _b1_;
    return _b2_;
   }
   function create$2(config, start){
    if
     (caml_call2
       (Core_Time_ns_alternate_sexp[98],
        start,
        Core_Time_ns_alternate_sexp[43])){
     var
      _bN_ =
        [0,
         [1,
          [0,
           _a3_,
           [0, caml_call1(Core_Time_ns_alternate_sexp[92], start), 0]]],
         0],
      _bO_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_create_got_st),
          _bN_]];
     caml_call1(Core[255], _bO_);
    }
    var
     level_bits = config[2],
     capacity$0 = config[3],
     levels =
       caml_call3
         (Core_List[33],
          level_bits,
          [0, zero, zero$1, 0],
          function(index, param, level_bits){
           var
            levels = param[3],
            max_level_min_allowed_key = param[2],
            bits_per_slot = param[1],
            keys_per_slot = pow2(bits_per_slot),
            diff_max_min_allowed_key =
              compute_diff_max_min_allowed_k(level_bits, bits_per_slot),
            min_key_in_same_slot_mask = create$1(bits_per_slot),
            min_allowed_key =
              caml_call2
               (bit_and, max_level_min_allowed_key, min_key_in_same_slot_mask),
            max_allowed_key =
              add_clamp_to_max(min_allowed_key, diff_max_min_allowed_key),
            _bR_ = caml_call1(null$1, 0),
            _bS_ = pow2(level_bits),
            _bT_ = caml_call1(Core_Int63[5], _bS_),
            _bU_ = caml_call2(Core_Array[60], _bT_, _bR_),
            level =
              [0,
               index,
               level_bits,
               create$0(level_bits),
               bits_per_slot,
               keys_per_slot,
               min_key_in_same_slot_mask,
               diff_max_min_allowed_key,
               0,
               min_allowed_key,
               max_allowed_key,
               _bU_],
            _bV_ = [0, level, levels],
            _bW_ =
              caml_call2(symbol$17, max_allowed_key, max_value$0)
               ? max_value$0
               : caml_call1(succ$0, max_allowed_key);
           return [0, symbol$2(level_bits, bits_per_slot), _bW_, _bV_];
          })
        [3],
     _bK_ = caml_call1(Core_Array[96], levels),
     _bL_ = caml_call1(null$1, 0),
     capacity = capacity$0 ? capacity$0[1] : 1,
     _bM_ =
       [0,
        0,
        caml_call2(Tuple_pool[36][35], Tuple_pool[36][1][22], capacity),
        _bL_,
        zero$1,
        _bK_],
     _bP_ = Core_Time_ns_alternate_sexp[46],
     _bQ_ = Core_Time_ns_alternate_sexp[46],
     t =
       [0,
        config,
        start,
        interval_num_internal(max_time, config[1]),
        _bQ_,
        _bP_,
        max_time,
        _bM_];
    t[6] = compute_max_allowed_alarm_time(t);
    advance_clock
     (t,
      start,
      function(param){
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a4_], 1);
      });
    return t;
   }
   function add_at_interval_num(t, at, value){
    var
     _bJ_ = interval_num_start(t, at),
     t$0 = internal_add(t[7], at, _bJ_, value);
    return t$0;
   }
   function ensure_can_schedule_alarm(t, at){
    if(caml_call2(Core_Time_ns_alternate_sexp[97], at, t[6])){
     var
      _bC_ =
        [0,
         [1,
          [0, _a5_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[6]), 0]]],
         0],
      _bD_ =
        [0,
         [1,
          [0, _a6_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
         _bC_],
      _bE_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu),
          _bD_]];
     caml_call1(Core[255], _bE_);
    }
    var _bI_ = caml_call2(Core_Time_ns_alternate_sexp[98], at, t[5]);
    if(! _bI_) return _bI_;
    var
     _bF_ =
       [0,
        [1,
         [0, _a7_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[5]), 0]]],
        0],
     _bG_ =
       [0,
        [1,
         [0, _a8_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
        _bF_],
     _bH_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu$0),
         _bG_]];
    return caml_call1(Core[255], _bH_);
   }
   function add$0(t, at, value){
    ensure_can_schedule_alarm(t, at);
    var
     _bB_ = interval_num_unchecked(t, at),
     t$0 = internal_add(t[7], _bB_, at, value);
    return t$0;
   }
   function remove(t, alarm){
    var t$0 = t[7], pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    return caml_call2(free, pool, elt);
   }
   function clear(t){
    var t$0 = t[7], _bs_ = 1 - is_empty(t$0);
    if(_bs_){
     t$0[1] = 0;
     var
      pool = t$0[2],
      free_elt = function(elt){return caml_call2(free, pool, elt);},
      levels = t$0[5],
      _bu_ = levels.length - 2 | 0,
      _bt_ = 0;
     if(_bu_ >= 0){
      var level_index = _bt_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[90], level[8], 0)){
        level[8] = 0;
        var slots = level[11], _bx_ = slots.length - 2 | 0, _bw_ = 0;
        if(_bx_ >= 0){
         var slot_index = _bw_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)){
           iter(pool, elt, free_elt);
           var _bz_ = caml_call1(null$1, 0);
           caml_check_bound(slots, slot_index)[1 + slot_index] = _bz_;
          }
          var _bA_ = slot_index + 1 | 0;
          if(_bx_ === slot_index) break;
          slot_index = _bA_;
         }
        }
       }
       var _by_ = level_index + 1 | 0;
       if(_bu_ === level_index) break;
       level_index = _by_;
      }
     }
     var _bv_ = 0;
    }
    else
     var _bv_ = _bs_;
    return _bv_;
   }
   function mem(t, alarm){var t$0 = t[7]; return is_valid(t$0[2], alarm);}
   function reschedule_gen(t, alarm, key, at){
    if(1 - mem(t, alarm)) caml_call1(Core[5], cst_Timing_wheel_cannot_resche);
    ensure_can_schedule_alarm(t, at);
    var t$0 = t[7];
    ensure_valid_key(t$0, key);
    var pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][3], key);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][4], at);
    return internal_add_elt(t$0, elt);
   }
   function reschedule(t, alarm, at){
    return reschedule_gen(t, alarm, interval_num_unchecked(t, at), at);
   }
   function reschedule_at_interval_num(t, alarm, at){
    return reschedule_gen(t, alarm, at, interval_num_start(t, at));
   }
   function min_alarm_interval_num(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, key(pool$1(t), elt)];
   }
   function min_alarm_interval_num_exn(x_164){
    var elt = min_elt$1(x_164[7]);
    if(! caml_call1(is_null, elt)) return key(pool$1(x_164), elt);
    var
     _bq_ =
       [0,
        [1,
         [0, _a__, [0, sexp_of_t$10(function(param){return _a9_;}, x_164), 0]]],
        0],
     _br_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_min_alarm_int),
         _bq_]];
    return caml_call1(Core[255], _br_);
   }
   function max_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     max_alarm_time = [0, Core_Time_ns_alternate_sexp[43]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return max_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _bo_ = max_alarm_time[1], _bp_ = at(pool, current[1]);
      max_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[103], _bp_, _bo_);
     }
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function min_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     min_alarm_time = [0, Core_Time_ns_alternate_sexp[45]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return min_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _bm_ = min_alarm_time[1], _bn_ = at(pool, current[1]);
      min_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[102], _bn_, _bm_);
     }
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function max_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, max_alarm_time_in_list(t, elt)];
   }
   function min_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, min_alarm_time_in_list(t, elt)];
   }
   function max_alarm_time_in_min_interval$0(x_165){
    var elt = min_elt$1(x_165[7]);
    if(caml_call1(is_null, elt)){
     var
      _bk_ =
        [0,
         [1,
          [0,
           _ba_,
           [0, sexp_of_t$10(function(param){return _a$_;}, x_165), 0]]],
         0],
      _bl_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim),
          _bk_]];
     caml_call1(Core[255], _bl_);
    }
    return max_alarm_time_in_list(x_165, elt);
   }
   function min_alarm_time_in_min_interval$0(x_166){
    var elt = min_elt$1(x_166[7]);
    if(caml_call1(is_null, elt)){
     var
      _bi_ =
        [0,
         [1,
          [0,
           _bc_,
           [0, sexp_of_t$10(function(param){return _bb_;}, x_166), 0]]],
         0],
      _bj_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim$0),
          _bi_]];
     caml_call1(Core[255], _bj_);
    }
    return min_alarm_time_in_list(x_166, elt);
   }
   function fire_past_alarms(t, handle_fired){
    var
     now = t[4],
     key = now_interval_num(t),
     t$0 = t[7],
     level = caml_check_bound(t$0[5], 0)[1],
     _bd_ = caml_call2(Core[90], level[8], 0);
    if(_bd_){
     var
      slot$0 = slot(level, key),
      slots = level[11],
      pool = t$0[2],
      first = [0, caml_check_bound(slots, slot$0)[1 + slot$0]],
      _be_ = 1 - caml_call1(is_null, first[1]);
     if(_be_){
      var current = [0, first[1]], continue$0 = [0, 1];
      for(;;){
       if(! continue$0[1]){var _bg_ = 0; break;}
       var elt = current[1], next$0 = next(pool, elt);
       if(next$0 === first[1]) continue$0[1] = 0; else current[1] = next$0;
       var _bf_ = at(pool, elt);
       if(caml_call2(Core_Time_ns_alternate_sexp[95], _bf_, now)){
        caml_call1(handle_fired, elt);
        internal_remove(t$0, elt);
        caml_call2(free, pool, elt);
        first[1] = caml_check_bound(slots, slot$0)[1 + slot$0];
       }
      }
     }
     else
      var _bg_ = _be_;
     var _bh_ = _bg_;
    }
    else
     var _bh_ = _bd_;
    return _bh_;
   }
   caml_call1(Ppx_inline_test_lib[6], cst_timing_wheel);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel);
   var
    Timing_wheel =
      [0,
       [0,
        compare,
        sexp_of_t$1,
        equal$0,
        of_span_floor_pow2_ns,
        of_span_floor_pow2_ns,
        to_sexpable,
        0,
        46,
        about_one_microsecond,
        20,
        30,
        mul,
        div,
        _k_],
       sexp_of_t$10,
       sexp_of_t_now,
       _aC_,
       [0, sexp_of_t$8, null$0, at$0, interval_num, value$0],
       invariant$2,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        invariant$0,
        max_num_bits,
        create_exn,
        level_bits_default,
        num_bits],
       [0,
        t_of_sexp$2,
        sexp_of_t$3,
        invariant$1,
        create,
        alarm_precision,
        level_bits,
        durations,
        microsecond_precision],
       create$2,
       alarm_precision$0,
       now,
       start,
       is_empty$0,
       length$3,
       iter$0,
       interval_num$0,
       now_interval_num,
       interval_num_start,
       interval_start,
       advance_clock,
       fire_past_alarms,
       max_allowed_alarm_time,
       now_interval_num,
       max_allowed_alarm_interval_num,
       add$0,
       add_at_interval_num,
       mem,
       remove,
       reschedule,
       reschedule_at_interval_num,
       clear,
       min_alarm_interval_num,
       min_alarm_interval_num_exn,
       max_alarm_time_in_min_interval,
       min_alarm_time_in_min_interval,
       max_alarm_time_in_min_interval$0,
       min_alarm_time_in_min_interval$0,
       next_alarm_fires_at,
       next_alarm_fires_at_exn,
       [0, max_time, interval_num_internal, [0, invariant, zero]]];
   runtime.caml_register_global(220, Timing_wheel, cst_Timing_wheel);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltaW5nX3doZWVsLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIlRpbWluZ193aGVlbCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InRpbWluZ193aGVlbC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X1RpbWluZ193aGVlbF9JbXBvcnQiLCJjc3RfdGltaW5nX3doZWVsIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiUHB4X21vZHVsZV90aW1lcl9ydW50aW1lIiwiUHB4X2JlbmNoX2xpYl9CZW5jaG1hcmtfYWNjdW11IiwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yIiwiUHB4X2lubGluZV90ZXN0X2xpYiIsIlRpbWluZ193aGVlbF9JbXBvcnQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvY29yZV9rZXJuZWwvdGltaW5nX3doZWVsL2ltcG9ydC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsR0NBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxzQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEQVYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIENvcmVcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo2MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9UaW1pbmdfd2hlZWxfVGltaW5nX3doZWVsXyIsImNzdF90aW1pbmdfd2hlZWwiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiVGltaW5nX3doZWVsX1RpbWluZ193aGVlbF9pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2NvcmVfa2VybmVsL3RpbWluZ193aGVlbC90aW1pbmdfd2hlZWxfaW50Zi5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsR0M2RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0ErV0c7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxpQ0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVENWJIIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiogQSBzcGVjaWFsaXplZCBwcmlvcml0eSBxdWV1ZSBmb3IgYSBzZXQgb2YgdGltZS1iYXNlZCBhbGFybXMuXG5cbiAgICBBIHRpbWluZyB3aGVlbCBpcyBhIGRhdGEgc3RydWN0dXJlIHRoYXQgbWFpbnRhaW5zIGEgY2xvY2sgd2l0aCB0aGUgY3VycmVudCB0aW1lIGFuZCBhXG4gICAgc2V0IG9mIGFsYXJtcyBzY2hlZHVsZWQgdG8gZmlyZSBpbiB0aGUgZnV0dXJlLiAgT25lIGNhbiBhZGQgYW5kIHJlbW92ZSBhbGFybXMsIGFuZFxuICAgIGFkdmFuY2UgdGhlIGNsb2NrIHRvIGNhdXNlIGFsYXJtcyB0byBmaXJlLiAgVGhlcmUgaXMgbm90aGluZyBhc3luY2hyb25vdXMgYWJvdXQgYVxuICAgIHRpbWluZyB3aGVlbC4gIEFsYXJtcyBvbmx5IGZpcmUgaW4gcmVzcG9uc2UgdG8gYW4gW2FkdmFuY2VfY2xvY2tdIGNhbGwuXG5cbiAgICBXaGVuIG9uZSBbY3JlYXRlXXMgYSB0aW1pbmcgd2hlZWwsIG9uZSBzdXBwbGllcyBhbiBpbml0aWFsIHRpbWUsIFtzdGFydF0sIGFuZCBhblxuICAgIFthbGFybV9wcmVjaXNpb25dLiAgVGhlIHRpbWluZyB3aGVlbCBicmVha3MgYWxsIHRpbWUgZnJvbSB0aGUgZXBvY2ggb253YXJkcyBpbnRvXG4gICAgaGFsZi1vcGVuIGludGVydmFscyBvZiBzaXplIFthbGFybV9wcmVjaXNpb25dLCB3aXRoIHRoZSBib3R0b20gaGFsZiBvZiBlYWNoIGludGVydmFsXG4gICAgY2xvc2VkLCBhbmQgdGhlIHRvcCBoYWxmIG9wZW4uICBBbGFybXMgaW4gdGhlIHNhbWUgaW50ZXJ2YWwgZmlyZSBpbiB0aGUgc2FtZSBjYWxsIHRvXG4gICAgW2FkdmFuY2VfY2xvY2tdLCBhcyBzb29uIGFzIFtub3cgdF0gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdGltZXMgaW4gdGhlIGludGVydmFsLlxuICAgIFdoZW4gYW4gYWxhcm0gW2FdIGZpcmVzIG9uIGEgdGltaW5nIHdoZWVsIFt0XSwgdGhlIGltcGxlbWVudGF0aW9uIGd1YXJhbnRlZXMgdGhhdDpcblxuICAgIHtbXG4gICAgICBBbGFybS5hdCBhIDwgbm93IHRcbiAgICBdfVxuXG4gICAgVGhhdCBpcywgYWxhcm1zIG5ldmVyIGZpcmUgZWFybHkuICBGdXJ0aGVybW9yZSwgdGhlIGltcGxlbWVudGF0aW9uIGd1YXJhbnRlZXMgdGhhdFxuICAgIGFsYXJtcyBkb24ndCBnbyBvZmYgdG9vIGxhdGUuICBNb3JlIHByZWNpc2VseSwgZm9yIGFsbCBhbGFybXMgW2FdIGluIFt0XTpcblxuICAgIHtbXG4gICAgICBpbnRlcnZhbF9zdGFydCB0IChBbGFybS5hdCBhKSA+PSBpbnRlcnZhbF9zdGFydCB0IChub3cgdClcbiAgICBdfVxuXG4gICAgVGhpcyBpbXBsaWVzIHRoYXQgZm9yIGFsbCBhbGFybXMgW2FdIGluIFt0XTpcblxuICAgIHtbXG4gICAgICBBbGFybS5hdCBhID4gbm93IHQgLSBhbGFybV9wcmVjaXNpb24gdFxuICAgIF19XG5cbiAgICBPZiBjb3Vyc2UsIGFuIFthZHZhbmNlX2Nsb2NrXSBjYWxsIGNhbiBhZHZhbmNlIHRoZSBjbG9jayB0byBhbiBhcmJpdHJhcnkgdGltZSBpbiB0aGVcbiAgICBmdXR1cmUsIGFuZCB0aHVzIGFsYXJtcyBtYXkgZmlyZSBhdCBhIGNsb2NrIHRpbWUgYXJiaXRyYXJpbHkgZmFyIGJleW9uZCB0aGUgdGltZSBmb3JcbiAgICB3aGljaCB0aGV5IHdlcmUgc2V0LiAgQnV0IHRoZSBpbXBsZW1lbnRhdGlvbiBoYXMgbm8gY29udHJvbCBvdmVyIHRoZSB0aW1lcyBzdXBwbGllZCB0b1xuICAgIFthZHZhbmNlX2Nsb2NrXTsgaXQgY2FuIG9ubHkgZ3VhcmFudGVlIHRoYXQgYWxhcm1zIHdpbGwgZmlyZSB3aGVuIFthZHZhbmNlX2Nsb2NrXSBpc1xuICAgIGNhbGxlZCB3aXRoIGEgdGltZSBhdCBsZWFzdCBbYWxhcm1fcHJlY2lzaW9uXSBncmVhdGVyIHRoYW4gdGhlaXIgc2NoZWR1bGVkIHRpbWUuXG5cbiAgICB7MiBJbXBsZW1lbnRhdGlvbn1cblxuICAgIEEgdGltaW5nIHdoZWVsIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3BlY2lhbGl6ZWQgcHJpb3JpdHkgcXVldWUgaW4gd2hpY2ggdGhlXG4gICAgaGFsZi1vcGVuIGludGVydmFscyBmcm9tIHRoZSBlcG9jaCBvbndhcmRzIGFyZSBudW1iZXJlZCAwLCAxLCAyLCBldGMuICBFYWNoIHRpbWUgaXNcbiAgICBzdG9yZWQgaW4gdGhlIHByaW9yaXR5IHF1ZXVlIHdpdGggdGhlIGtleSBvZiBpdHMgaW50ZXJ2YWwgbnVtYmVyLiAgVGh1cyBhbGwgYWxhcm1zXG4gICAgd2l0aCBhIHRpbWUgaW4gdGhlIHNhbWUgaW50ZXJ2YWwgZ2V0IHRoZSBzYW1lIGtleSwgYW5kIGhlbmNlIGZpcmUgYXQgdGhlIHNhbWVcbiAgICB0aW1lLiBNb3JlIHNwZWNpZmljYWxseSwgYW4gYWxhcm0gaXMgZmlyZWQgd2hlbiB0aGUgY2xvY2sgcmVhY2hlcyBvciBwYXNzZXMgdGhlIHRpbWVcbiAgICBhdCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgaW50ZXJ2YWwuXG5cbiAgICBBbGFybXMgdGhhdCBmaXJlIGluIHRoZSBzYW1lIGludGVydmFsIHdpbGwgZmlyZSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkXG4gICAgdG8gdGhlIHRpbWluZyB3aGVlbCwgcmF0aGVyIHRoYW4gdGhlIHRpbWUgdGhleSB3ZXJlIHNldCB0byBnbyBvZmYuICBUaGlzIGlzIGNvbnNpc3RlbnRcbiAgICB3aXRoIHRoZSBndWFyYW50ZWVzIG9mIHRpbWluZyB3aGVlbCBtZW50aW9uZWQgYWJvdmUsIGJ1dCBtYXkgbm9udGhlbGVzcyBiZSBzdXJwcmlzaW5nXG4gICAgdG8gdXNlcnMuXG5cbiAgICBUaGUgcHJpb3JpdHkgcXVldWUgaXMgaW1wbGVtZW50ZWQgd2l0aCBhbiBhcnJheSBvZiBsZXZlbHMgb2YgZGVjcmVhc2luZyBwcmVjaXNpb24sXG4gICAgd2l0aCB0aGUgbG93ZXN0IGxldmVsIGhhdmluZyB0aGUgbW9zdCBwcmVjaXNpb24gYW5kIHN0b3JpbmcgdGhlIGNsb3Nlc3QgdXBjb21pbmdcbiAgICBhbGFybXMsIHdoaWxlIHRoZSBoaWdoZXN0IGxldmVsIGhhcyB0aGUgbGVhc3QgcHJlY2lzaW9uIGFuZCBzdG9yZXMgdGhlIGFsYXJtcyBmYXJ0aGVzdFxuICAgIGluIHRoZSBmdXR1cmUuICBBcyB0aW1lIGluY3JlYXNlcywgdGhlIHRpbWluZyB3aGVlbCBkb2VzIGEgbGF6eSByYWRpeCBzb3J0IG9mIHRoZVxuICAgIGFsYXJtIGtleXMuXG5cbiAgICBUaGlzIGltcGxlbWVudGF0aW9uIG1ha2VzIFthZGRfYWxhcm1dIGFuZCBbcmVtb3ZlX2FsYXJtXSBjb25zdGFudCB0aW1lLCB3aGlsZVxuICAgIFthZHZhbmNlX2Nsb2NrXSB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byB0aGUgYW1vdW50IG9mIHRpbWUgdGhlIGNsb2NrIGlzIGFkdmFuY2VkLlxuICAgIFdpdGggYSBzdWZmaWNpZW50IG51bWJlciBvZiBhbGFybXMsIHRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBhIGxvZyhOKSBoZWFwXG4gICAgaW1wbGVtZW50YXRpb24gb2YgYSBwcmlvcml0eSBxdWV1ZS5cblxuICAgIHsyIFJlcHJlc2VudGFibGUgdGltZXN9XG5cbiAgICBBIHRpbWluZyB3aGVlbCBbdF0gY2FuIG9ubHkgaGFuZGxlIGEgKHR5cGljYWxseSBsYXJnZSkgYm91bmRlZCByYW5nZSBvZiB0aW1lcyBhc1xuICAgIGRldGVybWluZWQgYnkgdGhlIGN1cnJlbnQgdGltZSwgW25vdyB0XSwgYW5kIHRoZSBbbGV2ZWxfYml0c10gYW5kIFthbGFybV9wcmVjaXNpb25dXG4gICAgYXJndW1lbnRzIHN1cHBsaWVkIHRvIFtjcmVhdGVdLiAgVmFyaW91cyBmdW5jdGlvbnMgcmFpc2UgaWYgdGhleSBhcmUgc3VwcGxpZWQgYSB0aW1lXG4gICAgc21hbGxlciB0aGFuIFtub3cgdF0gb3IgWz4gbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0XS4gIFRoaXMgc2l0dWF0aW9uIGxpa2VseSBpbmRpY2F0ZXNcbiAgICBhIG1pc2NvbmZpZ3VyYXRpb24gb2YgdGhlIFtsZXZlbF9iaXRzXSBhbmQvb3IgW2FsYXJtX3ByZWNpc2lvbl0uICBIZXJlIGlzIHRoZSBkdXJhdGlvblxuICAgIG9mIFttYXhfYWxsb3dlZF9hbGFybV90aW1lIHQgLSBub3cgdF0gdXNpbmcgdGhlIGRlZmF1bHQgW2xldmVsX2JpdHNdLlxuXG4gICAge3ZcbiAgICAgIHwgIyBpbnRlcnZhbHMgfCBhbGFybV9wcmVjaXNpb24gfCBkdXJhdGlvbiB8XG4gICAgICArLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tfFxuICAgICAgfCAgICAgICAgMl42MSB8IG5hbm9zZWNvbmQgICAgICB8IDczIHllYXJzIHxcbiAgICB2fSAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxuKCoqIEFuIFtJbnRlcnZhbF9udW0udF0gaXMgYW4gaW5kZXggb2Ygb25lIG9mIHRoZSBpbnRlcnZhbHMgaW50byB3aGljaCBhIHRpbWluZy13aGVlbFxuICAgIHBhcnRpdGlvbnMgdGltZS4gKilcbm1vZHVsZSB0eXBlIEludGVydmFsX251bSA9IHNpZ1xuICBtb2R1bGUgU3BhbiA6IHNpZ1xuICAgIHR5cGUgdCA9IHByaXZhdGUgSW50NjMudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIG1heCA6IHQgLT4gdCAtPiB0XG4gICAgdmFsIHplcm8gOiB0XG4gICAgdmFsIG9uZSA6IHRcbiAgICB2YWwgbWF4X3ZhbHVlIDogdFxuICAgIHZhbCBvZl9pbnQ2MyA6IEludDYzLnQgLT4gdFxuICAgIHZhbCB0b19pbnQ2MyA6IHQgLT4gSW50NjMudFxuICAgIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICAgIHZhbCB0b19pbnRfZXhuIDogdCAtPiBpbnRcbiAgICB2YWwgc2NhbGVfaW50IDogdCAtPiBpbnQgLT4gdFxuICAgIHZhbCBwcmVkIDogdCAtPiB0XG4gICAgdmFsIHN1Y2MgOiB0IC0+IHRcbiAgICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICBlbmRcblxuICB0eXBlIHQgPSBwcml2YXRlIEludDYzLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBpbmNsdWRlIENvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgSGFzaGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIG1heCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBtaW4gOiB0IC0+IHQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIG9uZSA6IHRcbiAgdmFsIG1pbl92YWx1ZSA6IHRcbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIG9mX2ludDYzIDogSW50NjMudCAtPiB0XG4gIHZhbCB0b19pbnQ2MyA6IHQgLT4gSW50NjMudFxuICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgdmFsIHRvX2ludF9leG4gOiB0IC0+IGludFxuICB2YWwgYWRkIDogdCAtPiBTcGFuLnQgLT4gdFxuICB2YWwgc3ViIDogdCAtPiBTcGFuLnQgLT4gdFxuICB2YWwgZGlmZiA6IHQgLT4gdCAtPiBTcGFuLnRcbiAgdmFsIHN1Y2MgOiB0IC0+IHRcbiAgdmFsIHByZWQgOiB0IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gU3Bhbi50IC0+IFNwYW4udFxuZW5kXG5cbigqKiBBbiBbQWxhcm1fcHJlY2lzaW9uXSBpcyBhIHRpbWUgc3BhbiB0aGF0IGlzIGEgcG93ZXIgb2YgdHdvIG51bWJlciBvZiBuYW5vc2Vjb25kcywgdXNlZFxuICAgIHRvIHNwZWNpZnkgdGhlIHByZWNpc2lvbiBvZiBhIHRpbWluZyB3aGVlbC4gKilcbm1vZHVsZSB0eXBlIEFsYXJtX3ByZWNpc2lvbiA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIEVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBvZl9zcGFuIDogVGltZV9ucy5TcGFuLnQgLT4gdFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTgtMDFdIFVzZSBbb2Zfc3Bhbl9mbG9vcl9wb3cyX25zXVwiXVxuXG4gICgqKiBbb2Zfc3Bhbl9mbG9vcl9wb3cyX25zIHNwYW5dIHJldHVybnMgdGhlIGxhcmdlc3QgYWxhcm0gcHJlY2lzaW9uIGxlc3MgdGhhbiBvciBlcXVhbFxuICAgICAgdG8gW3NwYW5dIHRoYXQgaXMgYSBwb3dlciBvZiB0d28gbnVtYmVyIG9mIG5hbm9zZWNvbmRzLiAqKVxuICB2YWwgb2Zfc3Bhbl9mbG9vcl9wb3cyX25zIDogVGltZV9ucy5TcGFuLnQgLT4gdFxuXG4gIHZhbCB0b19zcGFuIDogdCAtPiBUaW1lX25zLlNwYW4udFxuICB2YWwgb25lX25hbm9zZWNvbmQgOiB0XG5cbiAgKCoqIENvbnN0YW50cyB0aGF0IGFyZSB0aGUgY2xvc2VzdCBwb3dlciBvZiB0d28gbnVtYmVyIG9mIG5hbm9zZWNvbmRzIHRvIHRoZSBzdGF0ZWRcbiAgICAgIHNwYW4uICopXG5cbiAgKCoqIH4xOS41IGggICopXG4gIHZhbCBhYm91dF9vbmVfZGF5IDogdFxuXG4gICgqKiAxMDI0IHVzICopXG4gIHZhbCBhYm91dF9vbmVfbWljcm9zZWNvbmQgOiB0XG5cbiAgKCoqIH4xLjA1IG1zICopXG4gIHZhbCBhYm91dF9vbmVfbWlsbGlzZWNvbmQgOiB0XG5cbiAgKCoqIH4xLjA3IHMgICopXG4gIHZhbCBhYm91dF9vbmVfc2Vjb25kIDogdFxuXG4gICgqKiBbbXVsIHQgfnBvdzJdIGlzIFt0ICogMl5wb3cyXS4gIFtwb3cyXSBtYXkgYmUgbmVnYXRpdmUsIGJ1dCBbbXVsXSBkb2VzIG5vdCBjaGVjayBmb3JcbiAgICAgIG92ZXJmbG93IG9yIHVuZGVyZmxvdy4gKilcbiAgdmFsIG11bCA6IHQgLT4gcG93MjppbnQgLT4gdFxuXG4gICgqKiBbZGl2IHQgfnBvdzJdIGlzIFt0IC8gMl5wb3cyXS4gIFtwb3cyXSBtYXkgYmUgbmVnYXRpdmUsIGJ1dCBbZGl2XSBkb2VzIG5vdCBjaGVja1xuICAgICAgZm9yIG92ZXJmbG93IG9yIHVuZGVyZmxvdy4gKilcbiAgdmFsIGRpdiA6IHQgLT4gcG93MjppbnQgLT4gdFxuXG4gICgqKiBUaGUgdW5zdGFibGUgYmluIGFuZCBzZXhwIGZvcm1hdCBpcyB0aGF0IG9mIFtUaW1lX25zLlNwYW5dLCB3aXRoIHRoZSBjYXZlYXQgdGhhdFxuICAgICAgZGVzZXJpYWxpemF0aW9uIGltcGxpY2l0bHkgZmxvb3JzIHRoZSB0aW1lIHNwYW4gdG8gdGhlIG5lYXJlc3QgcG93ZXIgb2YgdHdvXG4gICAgICBuYW5vc2Vjb25kcy4gIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBhbGFybSBwcmVjaXNpb24gdGhhdCBpcyB1c2VkIGlzIGF0IGxlYXN0IGFzXG4gICAgICBwcmVjaXNlIHRoYW4gdGhlIGFsYXJtIHByZWNpc2lvbiB0aGF0IGlzIHN0YXRlZC4gKilcbiAgbW9kdWxlIFVuc3RhYmxlIDogc2lnXG4gICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBzZXhwXVxuICBlbmRcbmVuZFxuXG4oKiogQSB0aW1pbmcgd2hlZWwgY2FuIGJlIHRob3VnaHQgb2YgYXMgYSBzZXQgb2YgYWxhcm1zLiAqKVxubW9kdWxlIHR5cGUgVGltaW5nX3doZWVsID0gc2lnXG4gIG1vZHVsZSBBbGFybV9wcmVjaXNpb24gOiBBbGFybV9wcmVjaXNpb25cblxuICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSB0aW1pbmdfd2hlZWwgPSAnYSB0XG5cbiAgKCoqIFs8OnNleHBfb2Y8IF8gdF9ub3cgPj5dIGRpc3BsYXlzIG9ubHkgW25vdyB0XSwgbm90IGFsbCB0aGUgYWxhcm1zLiAqKVxuICB0eXBlICdhIHRfbm93ID0gJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIG1vZHVsZSBJbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW1cblxuICBtb2R1bGUgQWxhcm0gOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgICgqKiBbbnVsbCAoKV0gcmV0dXJucyBhbiBhbGFybSBbdF0gc3VjaCB0aGF0IFtub3QgKG1lbSB0aW1pbmdfd2hlZWwgdCldIGZvciBhbGxcbiAgICAgICAgW3RpbWluZ193aGVlbF1zLiAqKVxuICAgIHZhbCBudWxsIDogdW5pdCAtPiBfIHRcblxuICAgICgqKiBBbGwgW0FsYXJtXSBmdW5jdGlvbnMgd2lsbCByYWlzZSBpZiBbbm90IChUaW1pbmdfd2hlZWwubWVtIHRpbWluZ193aGVlbCB0KV0uICopXG4gICAgdmFsIGF0IDogJ2EgdGltaW5nX3doZWVsIC0+ICdhIHQgLT4gVGltZV9ucy50XG5cbiAgICB2YWwgaW50ZXJ2YWxfbnVtIDogJ2EgdGltaW5nX3doZWVsIC0+ICdhIHQgLT4gSW50ZXJ2YWxfbnVtLnRcbiAgICB2YWwgdmFsdWUgOiAnYSB0aW1pbmdfd2hlZWwgLT4gJ2EgdCAtPiAnYVxuICBlbmRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgbW9kdWxlIExldmVsX2JpdHMgOiBzaWdcbiAgICAoKiogVGhlIHRpbWluZy13aGVlbCBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGFycmF5IG9mIFwibGV2ZWxzXCIsIHdoZXJlIGxldmVsIFtpXSBpcyBhblxuICAgICAgICBhcnJheSBvZiBsZW5ndGggWzJeYl9pXSwgd2hlcmUgdGhlIFtiX2ldIGFyZSB0aGUgXCJsZXZlbCBiaXRzXCIgc3BlY2lmaWVkIHZpYVxuICAgICAgICBbTGV2ZWxfYml0cy5jcmVhdGVfZXhuIFtiXzAsIGJfMTsgLi4uXV0uXG5cbiAgICAgICAgQSB0aW1pbmcgd2hlZWwgY2FuIGhhbmRsZSBhcHByb3hpbWF0ZWx5IFsyICoqIG51bV9iaXRzIHRdIGludGVydmFscy9rZXlzIGJleW9uZFxuICAgICAgICB0aGUgY3VycmVudCBtaW5pbXVtIHRpbWUva2V5LCB3aGVyZSBbbnVtX2JpdHMgdCA9IGJfMCArIGJfMSArIC4uLl0uXG5cbiAgICAgICAgT25lIGNhbiB1c2UgYSBbTGV2ZWxfYml0cy50XSB0byB0cmFkZSBvZmYgcnVuIHRpbWUgYW5kIHNwYWNlIHVzYWdlIG9mIGEgdGltaW5nXG4gICAgICAgIHdoZWVsLiAgRm9yIGEgZml4ZWQgW251bV9iaXRzXSwgYXMgdGhlIG51bWJlciBvZiBsZXZlbHMgaW5jcmVhc2VzLCB0aGUgbGVuZ3RoIG9mXG4gICAgICAgIHRoZSBsZXZlbHMgZGVjcmVhc2VzIGFuZCB0aGUgdGltaW5nIHdoZWVsIHVzZXMgbGVzcyBzcGFjZSwgYnV0IHRoZSBjb25zdGFudCBmYWN0b3JcbiAgICAgICAgZm9yIHRoZSBydW5uaW5nIHRpbWUgb2YgW2FkZF0gYW5kIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcy4gKilcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmcgc2V4cF1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgKCoqIFttYXhfbnVtX2JpdHNdIGlzIGhvdyBtYW55IGJpdHMgaW4gYSBrZXkgdGhlIHRpbWluZyB3aGVlbCBjYW4gdXNlLCBpLmUuIDYxLiAgV2VcbiAgICAgICAgc3VidHJhY3QgMyBmb3IgdGhlIGJpdHMgaW4gdGhlIHdvcmQgdGhhdCB3ZSB3b24ndCB1c2U6XG5cbiAgICAgICAgLSBmb3IgdGhlIHRhZyBiaXRcbiAgICAgICAgLSBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgICAtIHNvIHdlIGNhbiBkbyBhcml0aG1ldGljIGFyb3VuZCB0aGUgYm91bmQgd2l0aG91dCB3b3JyeWluZyBhYm91dCBvdmVyZmxvdyAqKVxuICAgIHZhbCBtYXhfbnVtX2JpdHMgOiBpbnRcblxuICAgICgqKiBJbiBbY3JlYXRlX2V4biBiaXRzXSwgaXQgaXMgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBbYl9pXSBpbiBbYml0c10gaGFzIFtiX2kgPD0gMF0sXG4gICAgICAgIG9yIGlmIHRoZSBzdW0gb2YgdGhlIFtiX2ldIGluIFtiaXRzXSBpcyBncmVhdGVyIHRoYW4gW21heF9udW1fYml0c10uICBXaXRoXG4gICAgICAgIFt+ZXh0ZW5kX3RvX21heF9udW1fYml0czp0cnVlXSwgdGhlIHJlc3VsdGluZyBbdF0gaXMgZXh0ZW5kZWQgd2l0aCBzdWZmaWNpZW50IFtiX2lcbiAgICAgICAgPSAxXSBzbyB0aGF0IFtudW1fYml0cyB0ID0gbWF4X251bV9iaXRzXS4gKilcbiAgICB2YWwgY3JlYXRlX2V4blxuICAgICAgOiAgP2V4dGVuZF90b19tYXhfbnVtX2JpdHM6Ym9vbCAoKiogZGVmYXVsdCBpcyBbZmFsc2VdICopXG4gICAgICAtPiBpbnQgbGlzdFxuICAgICAgLT4gdFxuXG4gICAgKCoqIFtkZWZhdWx0XSByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIG9mIFtsZXZlbF9iaXRzXSB1c2VkIGJ5IFtUaW1pbmdfd2hlZWwuY3JlYXRlXVxuICAgICAgICBhbmQgW1RpbWluZ193aGVlbC5Qcmlvcml0eV9xdWV1ZS5jcmVhdGVdLlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgZGVmYXVsdCA9IFsxMTsgMTA7IDEwOyAxMDsgMTA7IDEwXVxuICAgICAgICBdfVxuXG4gICAgICAgIFRoaXMgZGVmYXVsdCB1c2VzIDYxIGJpdHMsIGkuZS4gW21heF9udW1fYml0c10sIGFuZCBsZXNzIHRoYW4gMTBrIHdvcmRzIG9mXG4gICAgICAgIG1lbW9yeS4gKilcbiAgICB2YWwgZGVmYXVsdCA6IHRcblxuICAgICgqKiBbbnVtX2JpdHMgdF0gaXMgdGhlIHN1bSBvZiB0aGUgW2JfaV0gaW4gW3RdLiAqKVxuICAgIHZhbCBudW1fYml0cyA6IHQgLT4gaW50XG4gIGVuZFxuXG4gIG1vZHVsZSBDb25maWcgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmcgc2V4cF1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgKCoqIFtjcmVhdGVdIHJhaXNlcyBpZiBbYWxhcm1fcHJlY2lzaW9uIDw9IDBdLiAqKVxuICAgIHZhbCBjcmVhdGVcbiAgICAgIDogID9jYXBhY2l0eTppbnQgKCoqIGRlZmF1bHQgaXMgWzFdICopXG4gICAgICAtPiA/bGV2ZWxfYml0czpMZXZlbF9iaXRzLnRcbiAgICAgIC0+IGFsYXJtX3ByZWNpc2lvbjpBbGFybV9wcmVjaXNpb24udFxuICAgICAgLT4gdW5pdFxuICAgICAgLT4gdFxuXG4gICAgKCoqIGFjY2Vzc29ycyAqKVxuICAgIHZhbCBhbGFybV9wcmVjaXNpb24gOiB0IC0+IFRpbWVfbnMuU3Bhbi50XG5cbiAgICB2YWwgbGV2ZWxfYml0cyA6IHQgLT4gTGV2ZWxfYml0cy50XG5cbiAgICAoKiogW2R1cmF0aW9ucyB0XSByZXR1cm5zIHRoZSBkdXJhdGlvbnMgb2YgdGhlIGxldmVscyBpbiBbdF0gKilcbiAgICB2YWwgZHVyYXRpb25zIDogdCAtPiBUaW1lX25zLlNwYW4udCBsaXN0XG5cbiAgICAoKiogW21pY3Jvc2Vjb25kX3ByZWNpc2lvbiAoKV0gcmV0dXJucyBhIHJlYXNvbmFibGUgY29uZmlndXJhdGlvbiBmb3IgYSB0aW1pbmcgd2hlZWxcbiAgICAgICAgd2l0aCBtaWNyb3NlY29uZCBbYWxhcm1fcHJlY2lzaW9uXSwgYW5kIGxldmVsIGR1cmF0aW9ucyBvZiAxbXMsIDFzLCAxbSwgMWgsIDFkLlxuICAgICAgICBTZWUgdGhlIHJlbGV2YW50IGV4cGVjdCB0ZXN0IGluIFtDb3JlX3Rlc3RdIGxpYnJhcnkuICopXG4gICAgdmFsIG1pY3Jvc2Vjb25kX3ByZWNpc2lvbiA6IHVuaXQgLT4gdFxuICBlbmRcblxuICAoKiogW2NyZWF0ZSB+Y29uZmlnIH5zdGFydF0gY3JlYXRlcyBhIG5ldyB0aW1pbmcgd2hlZWwgd2l0aCBjdXJyZW50IHRpbWUgW3N0YXJ0XS5cbiAgICAgIFtjcmVhdGVdIHJhaXNlcyBpZiBbc3RhcnQgPCBUaW1lX25zLmVwb2NoXS4gIEZvciBhIGZpeGVkIFtsZXZlbF9iaXRzXSwgYSBzbWFsbGVyXG4gICAgICAoaS5lLiBtb3JlIHByZWNpc2UpIFthbGFybV9wcmVjaXNpb25dIGRlY3JlYXNlcyB0aGUgcmVwcmVzZW50YWJsZSByYW5nZSBvZlxuICAgICAgdGltZXMva2V5cyBhbmQgaW5jcmVhc2VzIHRoZSBjb25zdGFudCBmYWN0b3IgZm9yIFthZHZhbmNlX2Nsb2NrXS4gKilcbiAgdmFsIGNyZWF0ZSA6IGNvbmZpZzpDb25maWcudCAtPiBzdGFydDpUaW1lX25zLnQgLT4gJ2EgdFxuXG4gICgqKiBBY2Nlc3NvcnMgKilcbiAgdmFsIGFsYXJtX3ByZWNpc2lvbiA6IF8gdCAtPiBUaW1lX25zLlNwYW4udFxuXG4gIHZhbCBub3cgOiBfIHQgLT4gVGltZV9ucy50XG4gIHZhbCBzdGFydCA6IF8gdCAtPiBUaW1lX25zLnRcblxuICAoKiogT25lIGNhbiB0aGluayBvZiBhIHRpbWluZyB3aGVlbCBhcyBhIHNldCBvZiBhbGFybXMuICBIZXJlIGFyZSB2YXJpb3VzIGNvbnRhaW5lclxuICAgICAgZnVuY3Rpb25zIGFsb25nIHRob3NlIGxpbmVzLiAqKVxuXG4gIHZhbCBpc19lbXB0eSA6IF8gdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSBBbGFybS50IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ludGVydmFsX251bSB0IHRpbWVdIHJldHVybnMgdGhlIG51bWJlciBvZiB0aGUgaW50ZXJ2YWwgdGhhdCBbdGltZV0gaXMgaW4sIHdoZXJlXG4gICAgICBbMF0gaXMgdGhlIGludGVydmFsIHRoYXQgc3RhcnRzIGF0IFtUaW1lX25zLmVwb2NoXS4gIFtpbnRlcnZhbF9udW1dIHJhaXNlcyBpZlxuICAgICAgW1RpbWVfbnMuKCA8ICkgdGltZSBUaW1lX25zLmVwb2NoXS4gKilcbiAgdmFsIGludGVydmFsX251bSA6IF8gdCAtPiBUaW1lX25zLnQgLT4gSW50ZXJ2YWxfbnVtLnRcblxuICAoKiogW25vd19pbnRlcnZhbF9udW0gdCA9IGludGVydmFsX251bSB0IChub3cgdCldLiAqKVxuICB2YWwgbm93X2ludGVydmFsX251bSA6IF8gdCAtPiBJbnRlcnZhbF9udW0udFxuXG4gICgqKiBbaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgbl0gaXMgdGhlIHN0YXJ0IG9mIHRoZSBbbl0ndGggaW50ZXJ2YWwgaW4gW3RdLCBpLmUuXG4gICAgICBbbiAqIGFsYXJtX3ByZWNpc2lvbiB0XSBhZnRlciB0aGUgZXBvY2guXG5cbiAgICAgIFtpbnRlcnZhbF9zdGFydCB0IHRpbWVdIGlzIHRoZSBzdGFydCBvZiB0aGUgaGFsZi1vcGVuIGludGVydmFsIGNvbnRhaW5pbmcgW3RpbWVdLFxuICAgICAgaS5lLjpcblxuICAgICAge1tcbiAgICAgICAgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgKGludGVydmFsX251bSB0IHRpbWUpXG4gICAgICBdfSAqKVxuICB2YWwgaW50ZXJ2YWxfbnVtX3N0YXJ0IDogXyB0IC0+IEludGVydmFsX251bS50IC0+IFRpbWVfbnMudFxuXG4gICgqKiBbaW50ZXJ2YWxfc3RhcnRdIHJhaXNlcyBpbiB0aGUgc2FtZSBjYXNlcyB0aGF0IFtpbnRlcnZhbF9udW1dIGRvZXMuICopXG4gIHZhbCBpbnRlcnZhbF9zdGFydCA6IF8gdCAtPiBUaW1lX25zLnQgLT4gVGltZV9ucy50XG5cblxuICAoKiogW2FkdmFuY2VfY2xvY2sgdCB+dG9fIH5oYW5kbGVfZmlyZWRdIGFkdmFuY2VzIFt0XSdzIGNsb2NrIHRvIFt0b19dLiAgSXQgZmlyZXMgYW5kXG4gICAgICByZW1vdmVzIGFsbCBhbGFybXMgW2FdIGluIFt0XSB3aXRoIFtUaW1lX25zLig8KSAoQWxhcm0uYXQgdCBhKSAoaW50ZXJ2YWxfc3RhcnQgdFxuICAgICAgdG9fKV0sIGFwcGx5aW5nIFtoYW5kbGVfZmlyZWRdIHRvIGVhY2ggc3VjaCBbYV0uXG5cbiAgICAgIElmIFt0b18gPD0gbm93IHRdLCB0aGVuIFthZHZhbmNlX2Nsb2NrXSBkb2VzIG5vdGhpbmcuXG5cbiAgICAgIFthZHZhbmNlX2Nsb2NrXSBmYWlscyBpZiBbdG9fXSBpcyB0b28gZmFyIGluIHRoZSBmdXR1cmUgdG8gcmVwcmVzZW50LlxuXG4gICAgICBCZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbaGFuZGxlX2ZpcmVkXSBhY2Nlc3NlcyBbdF0gaW4gYW55IHdheSBvdGhlciB0aGFuXG4gICAgICBbQWxhcm1dIGZ1bmN0aW9ucy4gKilcbiAgdmFsIGFkdmFuY2VfY2xvY2sgOiAnYSB0IC0+IHRvXzpUaW1lX25zLnQgLT4gaGFuZGxlX2ZpcmVkOignYSBBbGFybS50IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkXSBmaXJlcyBhbmQgcmVtb3ZlcyBhbGwgYWxhcm1zIFthXSBpbiBbdF0gd2l0aFxuICAgICAgW1RpbWVfbnMuKCA8PSApIChBbGFybS5hdCB0IGEpIChub3cgdCldLCBhcHBseWluZyBbaGFuZGxlX2ZpcmVkXSB0byBlYWNoIHN1Y2ggW2FdLlxuXG4gICAgICBbZmlyZV9wYXN0X2FsYXJtc10gdmlzaXRzIGFsbCBhbGFybXMgaW4gaW50ZXJ2YWwgW25vd19pbnRlcnZhbF9udW1dLCB0byBjaGVjayB0aGVpclxuICAgICAgW0FsYXJtLmF0XS5cblxuICAgICAgQmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW2hhbmRsZV9maXJlZF0gYWNjZXNzZXMgW3RdIGluIGFueSB3YXkgb3RoZXIgdGhhblxuICAgICAgW0FsYXJtXSBmdW5jdGlvbnMuICopXG4gIHZhbCBmaXJlX3Bhc3RfYWxhcm1zIDogJ2EgdCAtPiBoYW5kbGVfZmlyZWQ6KCdhIEFsYXJtLnQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0XSByZXR1cm5zIHRoZSBncmVhdGVzdCBbYXRdIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHRvIFthZGRdLlxuICAgICAgW21heF9hbGxvd2VkX2FsYXJtX3RpbWVdIGlzIG5vdCBjb25zdGFudDsgaXRzIHZhbHVlIGluY3JlYXNlcyBhcyBbbm93IHRdXG4gICAgICBpbmNyZWFzZXMuICopXG4gIHZhbCBtYXhfYWxsb3dlZF9hbGFybV90aW1lIDogXyB0IC0+IFRpbWVfbnMudFxuXG4gICgqKiBbbWluX2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtIHQgPSBub3dfaW50ZXJ2YWxfbnVtIHRdICopXG4gIHZhbCBtaW5fYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW0gOiBfIHQgLT4gSW50ZXJ2YWxfbnVtLnRcblxuICAoKiogW21heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSB0ID0gaW50ZXJ2YWxfbnVtIHQgKG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCldICopXG4gIHZhbCBtYXhfYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW0gOiBfIHQgLT4gSW50ZXJ2YWxfbnVtLnRcblxuICAoKiogW2FkZCB0IH5hdCBhXSBhZGRzIGEgbmV3IHZhbHVlIFthXSB0byBbdF0gYW5kIHJldHVybnMgYW4gYWxhcm0gdGhhdCBjYW4gbGF0ZXIgYmVcbiAgICAgIHN1cHBsaWVkIHRvIFtyZW1vdmVdIHRoZSBhbGFybSBmcm9tIFt0XS4gIFthZGRdIHJhaXNlcyBpZiBbaW50ZXJ2YWxfbnVtIHQgYXQgPFxuICAgICAgbm93X2ludGVydmFsX251bSB0IHx8IGF0ID4gbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0XS4gKilcbiAgdmFsIGFkZCA6ICdhIHQgLT4gYXQ6VGltZV9ucy50IC0+ICdhIC0+ICdhIEFsYXJtLnRcblxuICAoKiogW2FkZF9hdF9pbnRlcnZhbF9udW0gdCB+YXQgYV0gaXMgZXF1aXZhbGVudCB0byBbYWRkIHQgfmF0OihpbnRlcnZhbF9udW1fc3RhcnQgdCBhdClcbiAgICAgIGFdLiAqKVxuICB2YWwgYWRkX2F0X2ludGVydmFsX251bSA6ICdhIHQgLT4gYXQ6SW50ZXJ2YWxfbnVtLnQgLT4gJ2EgLT4gJ2EgQWxhcm0udFxuXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIEFsYXJtLnQgLT4gYm9vbFxuXG4gICgqKiBbcmVtb3ZlIHQgYWxhcm1dIHJlbW92ZXMgW2FsYXJtXSBmcm9tIFt0XS4gIFtyZW1vdmVdIHJhaXNlcyBpZiBbbm90IChtZW0gdFxuICAgICAgYWxhcm0pXS4gKilcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4gJ2EgQWxhcm0udCAtPiB1bml0XG5cbiAgKCoqIFtyZXNjaGVkdWxlIHQgYWxhcm0gfmF0XSBtdXRhdGVzIFthbGFybV0gc28gdGhhdCBpdCB3aWxsIGZpcmUgYXQgW2F0XSwgaS5lLiBzbyB0aGF0XG4gICAgICBbQWxhcm0uYXQgdCBhbGFybSA9IGF0XS4gIFtyZXNjaGVkdWxlXSByYWlzZXMgaWYgW25vdCAobWVtIHQgYWxhcm0pXSBvciBpZiBbYXRdIGlzXG4gICAgICBhbiBpbnZhbGlkIHRpbWUgZm9yIFt0XSwgaW4gdGhlIHNhbWUgc2l0dWF0aW9ucyB0aGF0IFthZGRdIHJhaXNlcy4gKilcbiAgdmFsIHJlc2NoZWR1bGUgOiAnYSB0IC0+ICdhIEFsYXJtLnQgLT4gYXQ6VGltZV9ucy50IC0+IHVuaXRcblxuICAoKiogW3Jlc2NoZWR1bGVfYXRfaW50ZXJ2YWxfbnVtIHQgYWxhcm0gfmF0XSBpcyBlcXVpdmFsZW50IHRvOlxuICAgICAge1tcbiAgICAgICAgcmVzY2hlZHVsZSB0IGFsYXJtIH5hdDooaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgYXQpXG4gICAgICBdfSAqKVxuICB2YWwgcmVzY2hlZHVsZV9hdF9pbnRlcnZhbF9udW0gOiAnYSB0IC0+ICdhIEFsYXJtLnQgLT4gYXQ6SW50ZXJ2YWxfbnVtLnQgLT4gdW5pdFxuXG4gICgqKiBbY2xlYXIgdF0gcmVtb3ZlcyBhbGwgYWxhcm1zIGZyb20gW3RdLiAqKVxuICB2YWwgY2xlYXIgOiBfIHQgLT4gdW5pdFxuXG4gICgqKiBbbWluX2FsYXJtX2ludGVydmFsX251bSB0XSBpcyB0aGUgbWluaW11bSBbQWxhcm0uaW50ZXJ2YWxfbnVtXSBvZiBhbGwgYWxhcm1zIGluXG4gICAgICBbdF0uICopXG4gIHZhbCBtaW5fYWxhcm1faW50ZXJ2YWxfbnVtIDogXyB0IC0+IEludGVydmFsX251bS50IG9wdGlvblxuXG4gICgqKiBbbWluX2FsYXJtX2ludGVydmFsX251bV9leG4gdF0gaXMgbGlrZSBbbWluX2FsYXJtX2ludGVydmFsX251bV0sIGV4Y2VwdCBpdCByYWlzZXMgaWZcbiAgICAgIFtpc19lbXB0eSB0XS4gKilcbiAgdmFsIG1pbl9hbGFybV9pbnRlcnZhbF9udW1fZXhuIDogXyB0IC0+IEludGVydmFsX251bS50XG5cbiAgKCoqIFttYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwgdF0gcmV0dXJucyB0aGUgbWF4aW11bSBbQWxhcm0uYXRdIG92ZXIgYWxsIGFsYXJtcyBpblxuICAgICAgW3RdIHdob3NlIFtBbGFybS5pbnRlcnZhbF9udW1dIGlzIFttaW5fYWxhcm1faW50ZXJ2YWxfbnVtIHRdLiAgVGhpcyBmdW5jdGlvbiBpc1xuICAgICAgdXNlZnVsIGZvciBhZHZhbmNpbmcgdG8gdGhlIFttaW5fYWxhcm1faW50ZXJ2YWxfbnVtXSBvZiBhIHRpbWluZyB3aGVlbCBhbmQgdGhlblxuICAgICAgY2FsbGluZyBbZmlyZV9wYXN0X2FsYXJtc10gdG8gZmlyZSB0aGUgYWxhcm1zIGluIHRoYXQgaW50ZXJ2YWwuICBUaGF0IGlzIHVzZWZ1bCB3aGVuXG4gICAgICBzaW11bGF0aW5nIHRpbWUsIHRvIGVuc3VyZSB0aGF0IGFsYXJtcyBhcmUgcHJvY2Vzc2VkIGluIG9yZGVyLiAqKVxuICB2YWwgbWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIDogJ2EgdCAtPiBUaW1lX25zLnQgb3B0aW9uXG5cblxuICAoKiogW21pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0XSByZXR1cm5zIHRoZSBtaW5pbXVtIFtBbGFybS5hdF0gb3ZlciBhbGwgYWxhcm1zIGluXG4gICAgICBbdF0uICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBmb3IgYWR2YW5jaW5nIHRvIHRoZSBleGFjdCB0aW1lIHdoZW4gdGhlIG5leHQgYWxhcm1cbiAgICAgIGlzIHNjaGVkdWxlZCB0byBmaXJlLiAqKVxuICB2YWwgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIDogJ2EgdCAtPiBUaW1lX25zLnQgb3B0aW9uXG5cbiAgKCoqIFttYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHRdIGlzIGxpa2UgW21heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0sXG4gICAgICBleGNlcHQgdGhhdCBpdCByYWlzZXMgaWYgW2lzX2VtcHR5IHRdLiAqKVxuICB2YWwgbWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biA6ICdhIHQgLT4gVGltZV9ucy50XG5cbiAgKCoqIFttaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHRdIGlzIGxpa2UgW21pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0sXG4gICAgICBleGNlcHQgdGhhdCBpdCByYWlzZXMgaWYgW2lzX2VtcHR5IHRdLiAqKVxuICB2YWwgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biA6ICdhIHQgLT4gVGltZV9ucy50XG5cbiAgKCoqIFRoZSBuYW1lIG9mIHRoaXMgZnVuY3Rpb24gaXMgbWlzbGVhZGluZzogaXQgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgZXZlbnRzIHRoYXRcbiAgICAgIGNhbiBmaXJlIGR1ZSB0byBbZmlyZV9wYXN0X2FsYXJtc10uXG5cbiAgICAgIFtuZXh0X2FsYXJtX2ZpcmVzX2F0IHRdIHJldHVybnMgdGhlIG1pbmltdW0gdGltZSB0byB3aGljaCB0aGUgY2xvY2sgY2FuIGJlIGFkdmFuY2VkXG4gICAgICBzdWNoIHRoYXQgYW4gYWxhcm0gd2lsbCBiZSBmaXJlZCBieSBbYWR2YW5jZV9jbG9ja10sIG9yIFtOb25lXSBpZiBbdF0gaGFzIG5vIGFsYXJtc1xuICAgICAgKG9yIGFsbCBhbGFybXMgYXJlIGluIHRoZSBtYXggaW50ZXJ2YWwsIGFuZCBoZW5jZSBjYW5ub3QgZmlyZSBieSBbYWR2YW5jZV9jbG9ja10pLlxuICAgICAgSWYgW25leHRfYWxhcm1fZmlyZXNfYXQgdCA9IFNvbWUgbmV4dF0sIHRoZW4gZm9yIHRoZSBtaW5pbXVtIGFsYXJtIHRpbWUgW21pbl0gdGhhdFxuICAgICAgb2NjdXJzIGluIFt0XSwgaXQgaXMgZ3VhcmFudGVlZCB0aGF0OiBbbmV4dCAtIGFsYXJtX3ByZWNpc2lvbiB0IDw9IG1pbiA8IG5leHRdLlxuICAqKVxuICB2YWwgbmV4dF9hbGFybV9maXJlc19hdCA6IF8gdCAtPiBUaW1lX25zLnQgb3B0aW9uXG5cbiAgKCoqIFtuZXh0X2FsYXJtX2ZpcmVzX2F0X2V4bl0gaXMgbGlrZSBbbmV4dF9hbGFybV9maXJlc19hdF0sIGV4Y2VwdCB0aGF0IGl0IHJhaXNlcyBpZlxuICAgICAgW2lzX2VtcHR5IHRdLiAqKVxuICB2YWwgbmV4dF9hbGFybV9maXJlc19hdF9leG4gOiBfIHQgLT4gVGltZV9ucy50XG5cbiAgKCpfIFNlZSB0aGUgSmFuZSBTdHJlZXQgU3R5bGUgR3VpZGUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIFtQcml2YXRlXSBzdWJtb2R1bGVzOlxuXG4gICAgaHR0cHM6Ly9vcGVuc291cmNlLmphbmVzdHJlZXQuY29tL3N0YW5kYXJkcy8jcHJpdmF0ZS1zdWJtb2R1bGVzICopXG4gIG1vZHVsZSBQcml2YXRlIDogc2lnXG4gICAgdmFsIG1heF90aW1lIDogVGltZV9ucy50XG5cbiAgICB2YWwgaW50ZXJ2YWxfbnVtX2ludGVybmFsXG4gICAgICA6ICB0aW1lOlRpbWVfbnMudFxuICAgICAgLT4gYWxhcm1fcHJlY2lzaW9uOkFsYXJtX3ByZWNpc2lvbi50XG4gICAgICAtPiBJbnRlcnZhbF9udW0udFxuXG4gICAgbW9kdWxlIE51bV9rZXlfYml0cyA6IHNpZ1xuICAgICAgdHlwZSB0XG5cbiAgICAgIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgICB2YWwgemVybyA6IHRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltaW5nX3doZWVsLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfVGltaW5nX3doZWVsIiwiY3N0X1RpbWluZ193aGVlbF9tYXhfYWxhcm1fdGltIiwiY3N0IiwiY3N0X2FsYXJtX3ByZWNpc2lvbiIsImNzdF9hdCIsImNzdF9iaXRzIiwiY3N0X2JpdHNfcGVyX3Nsb3QiLCJjc3RfY2FwYWNpdHkiLCJjc3RfY29uZmlnIiwiY3N0X2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleSIsImNzdF9lbHRfa2V5X2xvd2VyX2JvdW5kIiwiY3N0X2luZGV4IiwiY3N0X2ludGVydmFsX251bSIsImNzdF9rZXkiLCJjc3Rfa2V5c19wZXJfc2xvdCIsImNzdF9sZW5ndGgiLCJjc3RfbGV2ZWxfYml0cyIsImNzdF9sZXZlbHMiLCJjc3RfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSIsImNzdF9tYXhfYWxsb3dlZF9rZXkiLCJjc3RfbWF4X2ludGVydmFsX251bSIsImNzdF9taW5fYWxsb3dlZF9rZXkiLCJjc3RfbWluX2VsdCIsImNzdF9taW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIiwiY3N0X25vdyIsImNzdF9ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IiwiY3N0X3Bvb2wiLCJjc3RfcHJpb3JpdHlfcXVldWUiLCJjc3Rfc2xvdHMiLCJjc3Rfc2xvdHNfbWFzayIsImNzdF9zdGFydCIsImNzdF90aW1pbmdfd2hlZWwiLCJjc3RfdGltaW5nX3doZWVsX3NyY190aW1pbmdfd2giLCJjc3RfdmFsdWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDYiLCJhNCIsImE1IiwiY2FtbF9jYWxsNyIsImE2IiwiY2FtbF9jYWxsOCIsImE3IiwiZ2xvYmFsX2RhdGEiLCJwb3MiLCJhcmdfMDg3IiwiZXJyb3Jfc291cmNlXzAxOSIsIlNleHBsaWIwX1NleHBfY29udiIsIkNvcmUiLCJDb3JlX1RpbWVfbnNfYWx0ZXJuYXRlX3NleHAiLCJBc3NlcnRfZmFpbHVyZSIsIlBweF9hc3NlcnRfbGliX1J1bnRpbWUiLCJCYXNlX0ludmFyaWFudCIsIkNvcmVfVGltZV9ucyIsIkNvcmVfTGlzdCIsIkNvcmVfSW50NjMiLCJDb3JlX0FycmF5IiwiVHVwbGVfcG9vbCIsIlNleHBsaWIwX1NleHBfY29udl9yZWNvcmQiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiQ29yZV9JbnQiLCJDb3JlX0JpbmFibGUiLCJCYXNlX1NleHBhYmxlIiwibWF4X3RpbWUiLCJtaW5fdGltZSIsInplcm8iLCJ0b19pbnQiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJzeW1ib2wiLCJlcXVhbCIsIm1heF9udW1fYml0cyIsIm1pbl92YWx1ZSIsImNzdF9MZXZlbF9iaXRzX2NyZWF0ZV9leG5fcmVxdSIsImNzdF9MZXZlbF9iaXRzX2NyZWF0ZV9leG5fZ290XyIsImludmFyaWFudCIsInQiLCJvZl9pbnQiLCJpIiwidDEiLCJ0MiIsInBvdzIiLCJ4XzAwNyIsIm51bV9iaXRzX2ludGVybmFsIiwibnVtX2JpdHMiLCJudW1fa2V5X2JpdHMiLCJ4XzAwNiIsImNyZWF0ZV9leG4iLCJvcHQiLCJ4XzAwOCIsImV4dGVuZF90b19tYXhfbnVtX2JpdHMiLCJiaXRzIiwiaW50cyIsImxldmVsX2JpdHNfZGVmYXVsdCIsImNvbXBhcmUiLCJjc3RfQWxhcm1fcHJlY2lzaW9uX3RvX3NwYW5fb2YiLCJ4XzAxMiIsInhfMDEzIiwidG9fc2V4cGFibGUiLCJhYm91dF9vbmVfbWljcm9zZWNvbmQiLCJjc3RfQWxhcm1fcHJlY2lzaW9uX29mX3NwYW5fZmwiLCJtdWwiLCJkaXYiLCJvZl9zcGFuX2Zsb29yX3BvdzJfbnMiLCJzcGFuIiwiYmluX3NpemVfdCIsImJpbl93cml0ZV90IiwiYmluX3JlYWRfdCIsImJpbl9zaGFwZV90IiwiYmluX3dyaXRlcl90IiwiYmluX3JlYWRlcl90IiwiYmluX3QiLCJpbmNsdWRlIiwibGV2ZWxfYml0cyIsInIiLCJwYXJhbSIsInYiLCJ4XzAyMSIsImNhcGFjaXR5IiwiYWxhcm1fcHJlY2lzaW9uIiwiY2FwYWNpdHlfMDI3IiwibGV2ZWxfYml0c18wMjUiLCJhbGFybV9wcmVjaXNpb25fMDIzIiwiYm5kc18wMjIiLCJ2XzAyOCIsImFyZ18wMzAiLCJibmRfMDI5IiwiYXJnXzAyNiIsImFyZ18wMjQiLCJtYXhfbnVtX2xldmVsX2JpdHMiLCJsZXZlbF9iaXRzX2Z1biIsImNyZWF0ZSIsImxvb3AiLCJyZW1haW5pbmciLCJiIiwibWljcm9zZWNvbmRfcHJlY2lzaW9uIiwiZHVyYXRpb25zIiwibnVtX2JpdHNfYWNjdW0iLCJsZXZlbF9udW1fYml0cyIsImR1cmF0aW9uIiwib25lIiwiYml0X25vdCIsImJpdHNfcGVyX3Nsb3QiLCJ0b19pbnRfZXhuIiwic3VjYyIsInByZWQiLCJtYXhfdmFsdWUiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIiwiY29tcGFyYXRvciIsIk1hcCIsIlNldCIsInZhbGlkYXRlX2xib3VuZCIsInZhbGlkYXRlX3Vib3VuZCIsInZhbGlkYXRlX2JvdW5kIiwidG9faW50NjMiLCJvZl9pbnQ2MyIsInNjYWxlX2ludCIsInJlbSIsImJpdF9hbmQiLCJzaGlmdF9yaWdodCIsImhhc2hfZm9sZF90IiwiaGFzaCIsImhhc2hhYmxlIiwiVGFibGUiLCJIYXNoX3NldCIsIkhhc2hfcXVldWUiLCJhZGQiLCJhZGRfY2xhbXBfdG9fbWF4Iiwic3ViIiwiZGlmZiIsInNleHBfb2ZfcG9vbF9zbG90cyIsIm9mX2FfMDMzIiwieF8wMzQiLCJvZl9hXzAzNSIsInhfMDM2IiwibnVsbCIsImlzX251bGwiLCJmcmVlIiwia2V5IiwicCIsImF0IiwidmFsdWUiLCJsZXZlbF9pbmRleCIsInByZXYiLCJzZXRfcHJldiIsIngiLCJuZXh0Iiwic2V0X25leHQiLCJpc192YWxpZCIsImdyb3ciLCJpc19mdWxsIiwiY3N0X1RpbWluZ193aGVlbF9nb3RfaW52YWxpZF9hIiwib2ZfZXh0ZXJuYWxfZXhuIiwicG9vbCIsImxpbmsiLCJpdGVyIiwiZmlyc3QiLCJjdXJyZW50IiwiY29udGludWUiLCJzbG90cyIsIm1heF9hbGxvd2VkX2tleSIsInNldF9tYXhfYWxsb3dlZF9rZXkiLCJtaW5fYWxsb3dlZF9rZXkiLCJzZXRfbWluX2FsbG93ZWRfa2V5IiwibGVuZ3RoIiwic2V0X2xlbmd0aCIsImRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2siLCJrZXlzX3Blcl9zbG90Iiwic2xvdHNfbWFzayIsImluZGV4Iiwib2ZfYV8wNDQiLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXlfMDU4IiwibWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza18wNTYiLCJrZXlzX3Blcl9zbG90XzA1NCIsImJpdHNfcGVyX3Nsb3RfMDUyIiwic2xvdHNfbWFza18wNTAiLCJiaXRzXzA0OCIsImluZGV4XzA0NiIsImxlbmd0aF8wNjAiLCJtaW5fYWxsb3dlZF9rZXlfMDYyIiwibWF4X2FsbG93ZWRfa2V5XzA2NCIsInNsb3RzXzA2NiIsImFyZ18wNjciLCJibmRzXzA0NSIsImFyZ18wNjUiLCJhcmdfMDYzIiwiYXJnXzA2MSIsImFyZ18wNTkiLCJhcmdfMDU3IiwiYXJnXzA1NSIsImFyZ18wNTMiLCJhcmdfMDUxIiwiYXJnXzA0OSIsImFyZ18wNDciLCJzbG90IiwibmV4dF9zbG90IiwibWluX2tleV9pbl9zYW1lX3Nsb3QiLCJjb21wdXRlX21pbl9hbGxvd2VkX2tleSIsInByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5IiwibGV2ZWxzIiwiZWx0X2tleV9sb3dlcl9ib3VuZCIsInNldF9lbHRfa2V5X2xvd2VyX2JvdW5kIiwibWluX2VsdCIsInNldF9taW5fZWx0Iiwic2V0X3Bvb2wiLCJjc3RfUHJpb3JpdHlfcXVldWVfYWRkX2VsdF9rZXkiLCJjc3RfVGltaW5nX3doZWVsX2FkZF9hdF9pbnRlcnYiLCJkdW1teSIsImlzX2VtcHR5IiwibnVtX2xldmVscyIsImludGVybmFsX2l0ZXIiLCJsZXZlbCIsInNsb3RfaW5kZXgiLCJlbHQiLCJjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2siLCJtaW5fZWx0X2FscmVhZHlfZm91bmQiLCJtaW5fa2V5X2FscmVhZHlfZm91bmQiLCJzbG90X21pbl9rZXkiLCJjdXJyZW50X2tleSIsImFkZF9lbHQiLCJ4XzExNCIsInRvX2FkZCIsImVsdHNfMDk0IiwibWF4X2FsbG93ZWRfa2V5XzA5MiIsIm1pbl9hbGxvd2VkX2tleV8wOTAiLCJhcmdfMDk1Iiwia2V5XzA4NCIsImJuZHNfMDgzIiwiYXJnXzA4NSIsImJuZHNfMDg5IiwiYXJnXzA5MyIsImFyZ18wOTEiLCJpbnRlcm5hbF9hZGRfZWx0IiwiZW5zdXJlX3ZhbGlkX2tleSIsImludGVybmFsX2FkZCIsImludGVybmFsX3JlbW92ZSIsIm1pbl9pbnRlcnZhbF9udW0iLCJwcmlvcml0eV9xdWV1ZSIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJzZXRfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnQiLCJzZXRfbm93X2ludGVydmFsX251bV9zdGFydCIsIm5vdyIsInNldF9ub3ciLCJtYXhfaW50ZXJ2YWxfbnVtIiwic3RhcnQiLCJjb25maWciLCJjc3RfVGltaW5nX3doZWVsX25leHRfYWxhcm1fZmkiLCJjc3RfVGltaW5nX3doZWVsX2ludGVydmFsX251bV8iLCJzZXhwX29mX3Rfbm93IiwidHciLCJpbnRlcnZhbF9udW0iLCJzZXhwX29mX2EiLCJtYXhfaW50ZXJ2YWxfbnVtXzE0NiIsInN0YXJ0XzE0NCIsImNvbmZpZ18xNDIiLCJub3dfMTQ4IiwiYWxhcm0iLCJhbGFybXNfMTUwIiwiYXJnXzE1MSIsInZhbHVlXzEzOCIsImF0XzEzNiIsImFyZ18xMzkiLCJibmRzXzEzNSIsImFyZ18xMzciLCJibmRzXzE0MSIsImFyZ18xNDkiLCJhcmdfMTQ3IiwiYXJnXzE0NSIsImFyZ18xNDMiLCJpbnRlcnZhbF9udW1faW50ZXJuYWwiLCJ0aW1lIiwiaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCIsImludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQiLCJpbnRlcnZhbF9udW1fc3RhcnQiLCJuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIiwibmV4dF9hbGFybV9maXJlc19hdCIsIm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIiwieF8xNTMiLCJjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJub3dfaW50ZXJ2YWxfbnVtIiwibWF4X2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtIiwiaW50ZXJ2YWxfc3RhcnQiLCJpbnZhcmlhbnRfYSIsInhfMTU1IiwiY2hlY2siLCJwcmlvcml0eV9xdWV1ZV9mdW4iLCJ4XzEwOSIsIm9mX2FfMDY4IiwibGVuZ3RoXzA3MCIsInBvb2xfMDcyIiwibWluX2VsdF8wNzQiLCJlbHRfa2V5X2xvd2VyX2JvdW5kXzA3NiIsImxldmVsc18wNzgiLCJhcmdfMDc5IiwiYm5kc18wNjkiLCJhcmdfMDc3IiwiYXJnXzA3NSIsImFyZ18wNzMiLCJhcmdfMDcxIiwibGV2ZWxzX2Z1biIsInhfMDk4Iiwic2xvdHNfZnVuIiwieF8wNDEiLCJuIiwibWF4X2FsbG93ZWRfa2V5X2Z1biIsImV4cGVjdCIsImFfMTA3IiwiYl8xMDgiLCJtaW5fYWxsb3dlZF9rZXlfZnVuIiwiZ290Iiwic2V4cGlmaWVyIiwiYV8xMDUiLCJiXzEwNiIsImxlbmd0aF9mdW4iLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXlfZnVuIiwiZXRhIiwiYV8xMDMiLCJiXzEwNCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfZnVuIiwia2V5c19wZXJfc2xvdF9mdW4iLCJhXzEwMSIsImJfMTAyIiwiYml0c19wZXJfc2xvdF9mdW4iLCJzbG90c19tYXNrX2Z1biIsImFfMDk5IiwiYl8xMDAiLCJiaXRzX2Z1biIsImluZGV4X2Z1biIsInByZXZfbGV2ZWwiLCJhXzExMCIsImJfMTExIiwiYV8xMTIiLCJiXzExMyIsImVsdF9rZXlfbG93ZXJfYm91bmRfZnVuIiwibWluX2VsdF9mdW4iLCJwb29sX2Z1biIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWVfZnVuIiwiYV8xNjIiLCJiXzE2MyIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnRfZnVuIiwiYV8xNjAiLCJiXzE2MSIsIm5vd19mdW4iLCJtYXhfaW50ZXJ2YWxfbnVtX2Z1biIsImFfMTU2IiwiYl8xNTciLCJhXzE1OCIsImJfMTU5Iiwic3RhcnRfZnVuIiwiY29uZmlnX2Z1biIsImRlYnVnIiwiY3N0X1RpbWluZ193aGVlbF9jcmVhdGVfZ290X3N0IiwiY3N0X1RpbWluZ193aGVlbF9jYW5ub3Rfc2NoZWR1IiwiY3N0X1RpbWluZ193aGVlbF9jYW5ub3RfcmVzY2hlIiwiY3N0X1RpbWluZ193aGVlbF9taW5fYWxhcm1faW50IiwiYWR2YW5jZV9jbG9jayIsInRvIiwiaGFuZGxlX3JlbW92ZWQiLCJ0X21pbl9hbGxvd2VkX2tleSIsIm1hdGNoIiwicmVzdWx0IiwibWluX2FsbG93ZWRfa2V5X2JlZm9yZSIsImRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwibWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSIsImFkZF9hdF9pbnRlcnZhbF9udW0iLCJlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIiwicmVtb3ZlIiwiY2xlYXIiLCJmcmVlX2VsdCIsIm1lbSIsInJlc2NoZWR1bGVfZ2VuIiwicmVzY2hlZHVsZSIsInJlc2NoZWR1bGVfYXRfaW50ZXJ2YWxfbnVtIiwibWluX2FsYXJtX2ludGVydmFsX251bSIsIm1pbl9hbGFybV9pbnRlcnZhbF9udW1fZXhuIiwieF8xNjQiLCJtYXhfYWxhcm1fdGltZV9pbl9saXN0Iiwid2l0aF9rZXkiLCJtYXhfYWxhcm1fdGltZSIsIm1pbl9hbGFybV90aW1lX2luX2xpc3QiLCJtaW5fYWxhcm1fdGltZSIsIm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCIsIm1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCIsInhfMTY1IiwieF8xNjYiLCJmaXJlX3Bhc3RfYWxhcm1zIiwiaGFuZGxlX2ZpcmVkIiwiVGltaW5nX3doZWVsIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2NvcmVfa2VybmVsL3RpbWluZ193aGVlbC90aW1pbmdfd2hlZWwubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLCtCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0NBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBWCxHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQWIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUQsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsTUFBQTtBQUFBLElBQUFFLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsR0MyQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUE7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBLElBc0NX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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEaHlESCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogQmUgc3VyZSBhbmQgZmlyc3QgcmVhZCB0aGUgaW1wbGVtZW50YXRpb24gb3ZlcnZpZXcgaW4gdGltaW5nX3doZWVsX2ludGYubWwuXG5cbiAgIEEgdGltaW5nIHdoZWVsIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIFwibGV2ZWxzXCIsIHdoZXJlIGVhY2ggbGV2ZWwgaXMgYW4gYXJyYXkgb2ZcbiAgIFwic2xvdHNcIi4gIEVhY2ggc2xvdCByZXByZXNlbnRzIGEgcmFuZ2Ugb2Yga2V5cywgYW5kIGhvbGRzIGVsZW1lbnRzIGFzc29jaWF0ZWQgd2l0aFxuICAgdGhvc2Uga2V5cy4gIEVhY2ggbGV2ZWwgaXMgZGV0ZXJtaW5lZCBieSB0d28gcGFyYW1ldGVyczogW2JpdHNdLCB0aGUgbnVtYmVyIG9mIGtleSBiaXRzXG4gICB0aGF0IHRoYXQgbGV2ZWwgaXMgcmVzcG9uc2libGUgZm9yIGRpc3Rpbmd1aXNoaW5nLCBhbmQgW2JpdHNfcGVyX3Nsb3RdLCB0aGUgc2l6ZSBvZiB0aGVcbiAgIHJhbmdlIG9mIGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIGEgc2luZ2xlIHNsb3QgaW4gdGhlIGFycmF5LiAgQ29uY2VwdHVhbGx5LCBlYWNoIGxldmVsXG4gICBicmVha3MgdXAgYWxsIHBvc3NpYmxlIGtleXMgaW50byByYW5nZXMgb2Ygc2l6ZSBbMl5iaXRzX3Blcl9zbG90XS4gIFRoZSBsZW5ndGggb2YgYVxuICAgbGV2ZWwgYXJyYXkgaXMgWzJeYml0c10sIGFuZCB0aGUgYXJyYXkgaXMgdXNlZCBsaWtlIGEgY2lyY3VsYXIgYnVmZmVyIHRvIHRyYXZlcnNlIHRoZVxuICAgcmFuZ2VzIGFzIHRoZSB0aW1pbmcgd2hlZWwncyBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMuICBBIGtleSBba10sIGlmIHN0b3JlZCBpbiB0aGVcbiAgIGxldmVsLCBpcyBzdG9yZWQgYXQgaW5kZXggWyhrIC8gMl5iaXRzX3Blcl9zbG90KSBtb2QgMl5iaXRzXS5cblxuICAgVGhlIHNldHRpbmdzIG9mIHRoZSBbYml0c10gdmFsdWVzIGFyZSBjb25maWd1cmFibGUgYnkgdXNlciBjb2RlIHVzaW5nIFtMZXZlbF9iaXRzXSxcbiAgIGFsdGhvdWdoIHRoZXJlIGlzIGEgcmVhc29uYWJsZSBkZWZhdWx0IHNldHRpbmcuICBHaXZlbiB0aGUgW2JpdHNdIHZhbHVlcywgdGhlXG4gICBbYml0c19wZXJfc2xvdF0gYXJlIGNob3NlbiBzbyB0aGF0IFtiaXRzX3Blcl9zbG90XSBhdCBsZXZlbCBbaV0gaXMgdGhlIHN1bSBvZiB0aGVcbiAgIFtiaXRzXSBhdCBhbGwgbG93ZXIgbGV2ZWxzLiAgVGh1cywgYSBzbG90J3MgcmFuZ2UgYXQgbGV2ZWwgW2ldIGlzIGFzIGxhcmdlIGFzIHRoZVxuICAgZW50aXJlIHJhbmdlIG9mIHRoZSBhcnJheSBhdCBsZXZlbCBbaSAtIDFdLlxuXG4gICBFYWNoIGxldmVsIGhhcyBhIFttaW5fYWxsb3dlZF9rZXldIGFuZCBhIFttYXhfYWxsb3dlZF9rZXldIHRoYXQgZGV0ZXJtaW5lIHRoZSByYW5nZSBvZlxuICAga2V5cyB0aGF0IGl0IGN1cnJlbnRseSByZXByZXNlbnRzLiAgVGhlIGNydWNpYWwgaW52YXJpYW50IG9mIHRoZSB0aW1pbmcgd2hlZWwgZGF0YVxuICAgc3RydWN0dXJlIGlzIHRoYXQgdGhlIFttaW5fYWxsb3dlZF9rZXldIGF0IGxldmVsIFtpXSBpcyBubyBtb3JlIHRoYW4gdGhlXG4gICBbbWF4X2FsbG93ZWRfa2V5ICsgMV0gb2YgbGV2ZWwgW2kgLSAxXS4gIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBsZXZlbHMgY2FuIHJlcHJlc2VudCBhbGxcbiAgIGtleXMgZnJvbSB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgdGhlIGxvd2VzdCBsZXZlbCB0byB0aGUgW21heF9hbGxvd2VkX2tleV0gb2YgdGhlXG4gICBoaWdoZXN0IGxldmVsLiAgVGhlIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciByZXN0b3JpbmdcbiAgIHRoaXMgaW52YXJpYW50LlxuXG4gICBBdCBsZXZlbCAwLCBbYml0c19wZXJfc2xvdCA9IDBdLCBhbmQgc28gdGhlIHNpemUgb2YgZWFjaCBzbG90IGlzIFsxXS4gIFRoYXQgaXMsIGxldmVsIDBcbiAgIHByZWNpc2VseSBkaXN0aW5ndWlzaGVzIGFsbCB0aGUga2V5cyBiZXR3ZWVuIGl0cyBbbWluX2FsbG93ZWRfa2V5XSAod2hpY2ggaXMgdGhlIHNhbWVcbiAgIGFzIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiB0aGUgZW50aXJlIHRpbWluZyB3aGVlbCkgYW5kIFttYXhfYWxsb3dlZF9rZXldLiAgQXMgdGhlXG4gICBsZXZlbHMgaW5jcmVhc2UsIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMsIHRoZSBbYml0c19wZXJfc2xvdF0gaW5jcmVhc2VzLCBhbmRcbiAgIHRoZSByYW5nZSBvZiBrZXlzIHN0b3JlZCBpbiB0aGUgbGV2ZWwgaW5jcmVhc2VzIChkcmFtYXRpY2FsbHkpLlxuXG4gICBUaGUgaWRlYSBvZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgc2ltaWxhciB0byB0aGUgaGllcmFyY2hpY2FsIGFwcHJvYWNoIGRlc2NyaWJlZCBpbjpcblxuICAge3ZcbiAgICAgSGFzaGVkIGFuZCBIaWVyYXJjaGljYWwgVGltaW5nIFdoZWVsczpcbiAgICAgRWZmaWNpZW50IERhdGEgU3RydWN0dXJlcyBmb3IgSW1wbGVtZW50aW5nIGEgVGltZXIgRmFjaWxpdHlcblxuICAgICBWYXJnaGVzZSAmIExhdWNrLCAxOTk2XG4gICB2fVxuXG4gICBIb3dldmVyLCB0aGUgY29kZSBpcyBjb21wbGV0ZWx5IG5ldy4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBUaW1pbmdfd2hlZWxfaW50ZlxubW9kdWxlIFBvb2wgPSBUdXBsZV9wb29sXG5tb2R1bGUgVGltZV9ucyA9IENvcmVfcHJpdmF0ZS5UaW1lX25zX2FsdGVybmF0ZV9zZXhwXG5cbmxldCBzZXhwX29mX3Rfc3R5bGUgOiBbIGBQcmV0dHkgfCBgSW50ZXJuYWwgXSByZWYgPSByZWYgYFByZXR0eVxuXG4oKiBbe21heCxtaW59X3RpbWVdIGFyZSBib3VuZHMgb24gdGhlIHRpbWVzIHN1cHBvcnRlZCBieSBhIHRpbWluZyB3aGVlbC4gKilcblxubGV0IG1heF90aW1lID0gVGltZV9ucy5tYXhfdmFsdWVfcmVwcmVzZW50YWJsZVxubGV0IG1pbl90aW1lID0gVGltZV9ucy5lcG9jaFxuXG5tb2R1bGUgTnVtX2tleV9iaXRzIDogc2lnXG4gIHR5cGUgdCA9IHByaXZhdGUgaW50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgaW5jbHVkZSBDb21wYXJhYmxlIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHplcm8gOiB0XG5cbiAgKCogdmFsIG1pbl92YWx1ZSA6IHQgKilcblxuICB2YWwgbWF4X3ZhbHVlIDogdFxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3cyIDogdCAtPiBJbnQ2My50XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRcblxuICBsZXQgbWluX3ZhbHVlID0gMFxuXG4gICgqKiBXZSBzdXBwb3J0IGFsbCBub24tbmVnYXRpdmUgW1RpbWVfbnMudF0gdmFsdWVzLiAqKVxuICBsZXQgbWF4X3ZhbHVlID0gSW50NjMubnVtX2JpdHMgLSAxXG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBhc3NlcnQgKHQgPj0gbWluX3ZhbHVlKTtcbiAgICBhc3NlcnQgKHQgPD0gbWF4X3ZhbHVlKVxuICA7O1xuXG4gIGxldCBvZl9pbnQgaSA9XG4gICAgaW52YXJpYW50IGk7XG4gICAgaVxuICA7O1xuXG4gIGxldCAoICsgKSB0MSB0MiA9XG4gICAgbGV0IHQgPSB0MSArIHQyIGluXG4gICAgaW52YXJpYW50IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCAoIC0gKSB0MSB0MiA9XG4gICAgbGV0IHQgPSB0MSAtIHQyIGluXG4gICAgaW52YXJpYW50IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBwb3cyIHQgPSBJbnQ2My5zaGlmdF9sZWZ0IEludDYzLm9uZSB0XG5lbmRcblxubW9kdWxlIExldmVsX2JpdHMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gTnVtX2tleV9iaXRzLnQgbGlzdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGxldCBtYXhfbnVtX2JpdHMgPSAoTnVtX2tleV9iaXRzLm1heF92YWx1ZSA6PiBpbnQpXG4gIGxldCBudW1fYml0c19pbnRlcm5hbCB0ID0gTGlzdC5mb2xkIHQgfmluaXQ6TnVtX2tleV9iaXRzLnplcm8gfmY6TnVtX2tleV9iaXRzLiggKyApXG4gIGxldCBudW1fYml0cyB0ID0gKG51bV9iaXRzX2ludGVybmFsIHQgOj4gaW50KVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgYXNzZXJ0IChub3QgKExpc3QuaXNfZW1wdHkgdCkpO1xuICAgIExpc3QuaXRlciB0IH5mOihmdW4gbnVtX2tleV9iaXRzIC0+XG4gICAgICBOdW1fa2V5X2JpdHMuaW52YXJpYW50IG51bV9rZXlfYml0cztcbiAgICAgIGFzc2VydCAoTnVtX2tleV9iaXRzLiggPiApIG51bV9rZXlfYml0cyBOdW1fa2V5X2JpdHMuemVybykpO1xuICAgIE51bV9rZXlfYml0cy5pbnZhcmlhbnQgKG51bV9iaXRzX2ludGVybmFsIHQpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgdCA9IHNleHAgfD4gWyVvZl9zZXhwOiB0XSBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlX2V4biA/KGV4dGVuZF90b19tYXhfbnVtX2JpdHMgPSBmYWxzZSkgaW50cyA9XG4gICAgaWYgTGlzdC5pc19lbXB0eSBpbnRzIHRoZW4gZmFpbHdpdGggXCJMZXZlbF9iaXRzLmNyZWF0ZV9leG4gcmVxdWlyZXMgYSBub25lbXB0eSBsaXN0XCI7XG4gICAgaWYgTGlzdC5leGlzdHMgaW50cyB+ZjooZnVuIGJpdHMgLT4gYml0cyA8PSAwKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIGdvdCBub25wb3NpdGl2ZSBudW0gYml0c1wiIH5fOihpbnRzIDogaW50IGxpc3QpXTtcbiAgICBsZXQgbnVtX2JpdHMgPSBMaXN0LmZvbGQgaW50cyB+aW5pdDowIH5mOiggKyApIGluXG4gICAgaWYgbnVtX2JpdHMgPiBtYXhfbnVtX2JpdHNcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIGdvdCB0b28gbWFueSBiaXRzXCJcbiAgICAgICAgICAgIH5fOihpbnRzIDogaW50IGxpc3QpXG4gICAgICAgICAgICB+Z290OihudW1fYml0cyA6IGludClcbiAgICAgICAgICAgIChtYXhfbnVtX2JpdHMgOiBpbnQpXTtcbiAgICBsZXQgaW50cyA9XG4gICAgICBpZiBleHRlbmRfdG9fbWF4X251bV9iaXRzXG4gICAgICB0aGVuIGludHMgQCBMaXN0LmluaXQgKG1heF9udW1fYml0cyAtIG51bV9iaXRzKSB+ZjooY29uc3QgMSlcbiAgICAgIGVsc2UgaW50c1xuICAgIGluXG4gICAgTGlzdC5tYXAgaW50cyB+ZjpOdW1fa2V5X2JpdHMub2ZfaW50XG4gIDs7XG5cbiAgbGV0IGRlZmF1bHQgPSBjcmVhdGVfZXhuIFsgMTE7IDEwOyAxMDsgMTA7IDEwOyAxMDsgMSBdXG5cbiAgbGV0IHRyaW0gdCB+bWF4X251bV9iaXRzID1cbiAgICBpZiBOdW1fa2V5X2JpdHMuKCA8PSApIChudW1fYml0c19pbnRlcm5hbCB0KSBtYXhfbnVtX2JpdHNcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCB0IH5yZW1haW5pbmcgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiBbXVxuICAgICAgICB8IGIgOjogdCAtPlxuICAgICAgICAgIGlmIE51bV9rZXlfYml0cy4oID49ICkgYiByZW1haW5pbmdcbiAgICAgICAgICB0aGVuIFsgcmVtYWluaW5nIF1cbiAgICAgICAgICBlbHNlIGIgOjogbG9vcCB0IH5yZW1haW5pbmc6KE51bV9rZXlfYml0cy4oIC0gKSByZW1haW5pbmcgYilcbiAgICAgIGluXG4gICAgICBsb29wIHQgfnJlbWFpbmluZzptYXhfbnVtX2JpdHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIEFsYXJtX3ByZWNpc2lvbiA6IHNpZ1xuICBpbmNsdWRlIEFsYXJtX3ByZWNpc2lvblxuXG4gIHZhbCBudW1fa2V5X2JpdHMgOiB0IC0+IE51bV9rZXlfYml0cy50XG4gIHZhbCBpbnRlcnZhbF9udW0gOiB0IC0+IFRpbWVfbnMudCAtPiBJbnQ2My50XG4gIHZhbCBpbnRlcnZhbF9udW1fc3RhcnQgOiB0IC0+IEludDYzLnQgLT4gVGltZV9ucy50XG5lbmQgPSBzdHJ1Y3RcbiAgKCoqIFt0XSBpcyByZXByZXNlbnRlZCBhcyB0aGUgbG9nMiBvZiBhIG51bWJlciBvZiBuYW5vc2Vjb25kcy4gKilcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nIGNvbXBhcmUsIGhhc2hdXG5cbiAgbGV0IGVxdWFsID0gWyVjb21wYXJlLmVxdWFsOiB0XVxuICBsZXQgbnVtX2tleV9iaXRzIHQgPSB0IHw+IE51bV9rZXlfYml0cy5vZl9pbnRcblxuICBsZXQgdG9fc3BhbiB0ID1cbiAgICBpZiB0IDwgMFxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbQWxhcm1fcHJlY2lzaW9uLnRvX3NwYW5dIG9mIG5lZ2F0aXZlIHBvd2VyIG9mIHR3byBuYW5vc2Vjb25kc1wiIH5fOih0IDogaW50KV07XG4gICAgSW50NjMuKHNoaWZ0X2xlZnQgb25lKSB0IHw+IFRpbWVfbnMuU3Bhbi5vZl9pbnQ2M19uc1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFslc2V4cCAodCB8PiB0b19zcGFuIDogVGltZV9ucy5TcGFuLnQpXVxuICBsZXQgb25lX25hbm9zZWNvbmQgPSAwXG4gIGxldCBhYm91dF9vbmVfbWljcm9zZWNvbmQgPSAxMFxuICBsZXQgYWJvdXRfb25lX21pbGxpc2Vjb25kID0gMjBcbiAgbGV0IGFib3V0X29uZV9zZWNvbmQgPSAzMFxuICBsZXQgYWJvdXRfb25lX2RheSA9IDQ2XG4gIGxldCBtdWwgdCB+cG93MiA9IHQgKyBwb3cyXG4gIGxldCBkaXYgdCB+cG93MiA9IHQgLSBwb3cyXG4gIGxldCBpbnRlcnZhbF9udW0gdCB0aW1lID0gSW50NjMuc2hpZnRfcmlnaHQgKHRpbWUgfD4gVGltZV9ucy50b19pbnQ2M19uc19zaW5jZV9lcG9jaCkgdFxuXG4gIGxldCBpbnRlcnZhbF9udW1fc3RhcnQgdCBpbnRlcnZhbF9udW0gPVxuICAgIEludDYzLnNoaWZ0X2xlZnQgaW50ZXJ2YWxfbnVtIHQgfD4gVGltZV9ucy5vZl9pbnQ2M19uc19zaW5jZV9lcG9jaFxuICA7O1xuXG4gIGxldCBvZl9zcGFuX2Zsb29yX3BvdzJfbnMgc3BhbiA9XG4gICAgaWYgVGltZV9ucy5TcGFuLiggPD0gKSBzcGFuIFRpbWVfbnMuU3Bhbi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIltBbGFybV9wcmVjaXNpb24ub2Zfc3Bhbl9mbG9vcl9wb3cyX25zXSBnb3Qgbm9uLXBvc2l0aXZlIHNwYW5cIlxuICAgICAgICAgICAgKHNwYW4gOiBUaW1lX25zLlNwYW4udCldO1xuICAgIHNwYW4gfD4gVGltZV9ucy5TcGFuLnRvX2ludDYzX25zIHw+IEludDYzLmZsb29yX2xvZzJcbiAgOztcblxuICBsZXQgb2Zfc3BhbiA9IG9mX3NwYW5fZmxvb3JfcG93Ml9uc1xuXG4gIG1vZHVsZSBVbnN0YWJsZSA9IHN0cnVjdFxuICAgIG1vZHVsZSBUID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBjb21wYXJlXVxuXG4gICAgICBsZXQgb2ZfYmluYWJsZSA9IG9mX3NwYW5fZmxvb3JfcG93Ml9uc1xuICAgICAgbGV0IHRvX2JpbmFibGUgPSB0b19zcGFuXG4gICAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcbiAgICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX3NwYW5cbiAgICBlbmRcblxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQmluYWJsZS5PZl9iaW5hYmxlX3dpdGhvdXRfdXVpZCBbQGFsZXJ0IFwiLWxlZ2FjeVwiXSAoVGltZV9ucy5TcGFuKSAoVClcbiAgICBpbmNsdWRlIFNleHBhYmxlLk9mX3NleHBhYmxlIChUaW1lX25zLlNwYW4pIChUKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gIGxldCBsZXZlbF9iaXRzX2RlZmF1bHQgPSBMZXZlbF9iaXRzLmRlZmF1bHRcblxuICB0eXBlIHQgPVxuICAgIHsgYWxhcm1fcHJlY2lzaW9uIDogQWxhcm1fcHJlY2lzaW9uLlVuc3RhYmxlLnRcbiAgICA7IGxldmVsX2JpdHMgOiBMZXZlbF9iaXRzLnQgW0BkZWZhdWx0IGxldmVsX2JpdHNfZGVmYXVsdF1cbiAgICA7IGNhcGFjaXR5IDogaW50IG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwXVxuXG4gIGxldCBhbGFybV9wcmVjaXNpb24gdCA9IEFsYXJtX3ByZWNpc2lvbi50b19zcGFuIHQuYWxhcm1fcHJlY2lzaW9uXG5cbiAgKCogW21heF9udW1fbGV2ZWxfYml0cyBhbGFybV9wcmVjaXNpb25dIHJldHVybnMgdGhlIG51bWJlciBvZiBsZXZlbCBiaXRzIG5lZWRlZCBmb3IgYVxuICAgICB0aW1pbmcgd2hlZWwgd2l0aCB0aGUgc3BlY2lmaWVkIFthbGFybV9wcmVjaXNpb25dIHRvIGJlIGFibGUgdG8gcmVwcmVzZW50IGFsbFxuICAgICBwb3NzaWJsZSB0aW1lcyBmcm9tIFtUaW1lX25zLmVwb2NoXSBvbndhcmQuICBTaW5jZSBub24tbmVnYXRpdmUgdGltZXMgaGF2ZSA2MiBiaXRzLFxuICAgICB3ZSByZXF1aXJlIFtMIDw9IDYyIC0gQV0sIHdoZXJlIFtBXSBpcyB0aGUgbnVtYmVyIG9mIGFsYXJtIGJpdHMgYW5kIFtMXSBpcyB0aGVcbiAgICAgbnVtYmVyIG9mIGxldmVsIGJpdHMuICopXG4gIGxldCBtYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uID1cbiAgICBOdW1fa2V5X2JpdHMuKCAtIClcbiAgICAgIE51bV9rZXlfYml0cy5tYXhfdmFsdWVcbiAgICAgIChBbGFybV9wcmVjaXNpb24ubnVtX2tleV9iaXRzIGFsYXJtX3ByZWNpc2lvbilcbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgYXNzZXJ0IChcbiAgICAgICAgTnVtX2tleV9iaXRzLiggPD0gKVxuICAgICAgICAgIChMZXZlbF9iaXRzLm51bV9iaXRzX2ludGVybmFsIHQubGV2ZWxfYml0cylcbiAgICAgICAgICAobWF4X251bV9sZXZlbF9iaXRzIHQuYWxhcm1fcHJlY2lzaW9uKSk7XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5hbGFybV9wcmVjaXNpb246aWdub3JlXG4gICAgICAgIH5jYXBhY2l0eTppZ25vcmVcbiAgICAgICAgfmxldmVsX2JpdHM6KGNoZWNrIExldmVsX2JpdHMuaW52YXJpYW50KSlcbiAgOztcblxuICBsZXQgY3JlYXRlID9jYXBhY2l0eSA/KGxldmVsX2JpdHMgPSBsZXZlbF9iaXRzX2RlZmF1bHQpIH5hbGFybV9wcmVjaXNpb24gKCkgPVxuICAgIGxldCBsZXZlbF9iaXRzID1cbiAgICAgIExldmVsX2JpdHMudHJpbSBsZXZlbF9iaXRzIH5tYXhfbnVtX2JpdHM6KG1heF9udW1fbGV2ZWxfYml0cyBhbGFybV9wcmVjaXNpb24pXG4gICAgaW5cbiAgICB7IGFsYXJtX3ByZWNpc2lvbjsgbGV2ZWxfYml0czsgY2FwYWNpdHkgfVxuICA7O1xuXG4gIGxldCBtaWNyb3NlY29uZF9wcmVjaXNpb24gKCkgPVxuICAgIGNyZWF0ZVxuICAgICAgKClcbiAgICAgIH5hbGFybV9wcmVjaXNpb246QWxhcm1fcHJlY2lzaW9uLmFib3V0X29uZV9taWNyb3NlY29uZFxuICAgICAgfmxldmVsX2JpdHM6KExldmVsX2JpdHMuY3JlYXRlX2V4biBbIDEwOyAxMDsgNjsgNjsgNSBdKVxuICA7O1xuXG4gIGxldCBkdXJhdGlvbnMgdCA9XG4gICAgTGlzdC5mb2xkaW5nX21hcFxuICAgICAgdC5sZXZlbF9iaXRzXG4gICAgICB+aW5pdDooQWxhcm1fcHJlY2lzaW9uLm51bV9rZXlfYml0cyB0LmFsYXJtX3ByZWNpc2lvbiB8PiBOdW1fa2V5X2JpdHMudG9faW50KVxuICAgICAgfmY6KGZ1biBudW1fYml0c19hY2N1bSBsZXZlbF9udW1fYml0cyAtPlxuICAgICAgICBsZXQgbnVtX2JpdHNfYWNjdW0gPSBudW1fYml0c19hY2N1bSArIChsZXZlbF9udW1fYml0cyB8PiBOdW1fa2V5X2JpdHMudG9faW50KSBpblxuICAgICAgICBsZXQgZHVyYXRpb24gPVxuICAgICAgICAgIFRpbWVfbnMuU3Bhbi5vZl9pbnQ2M19uc1xuICAgICAgICAgICAgKGlmIG51bV9iaXRzX2FjY3VtID0gSW50NjMubnVtX2JpdHMgLSAxXG4gICAgICAgICAgICAgdGhlbiBJbnQ2My5tYXhfdmFsdWVcbiAgICAgICAgICAgICBlbHNlIEludDYzLnNoaWZ0X2xlZnQgSW50NjMub25lIG51bV9iaXRzX2FjY3VtKVxuICAgICAgICBpblxuICAgICAgICBudW1fYml0c19hY2N1bSwgZHVyYXRpb24pXG4gIDs7XG5lbmRcblxuXG4oKiogVGltaW5nIHdoZWVsIGlzIGltcGxlbWVudGVkIGFzIGEgcHJpb3JpdHkgcXVldWUgaW4gd2hpY2ggdGhlIGtleXMgYXJlXG4gICAgbm9uLW5lZ2F0aXZlIGludGVnZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGludGVydmFscyBvZiB0aW1lLiAgVGhlIHByaW9yaXR5IHF1ZXVlIGlzXG4gICAgdW5saWtlIGEgdHlwaWNhbCBwcmlvcml0eSBxdWV1ZSBpbiB0aGF0IHJhdGhlciB0aGFuIGhhdmluZyBhIFwiZGVsZXRlIG1pblwiIG9wZXJhdGlvbixcbiAgICBpdCBoYXMgYSBub25kZWNyZWFzaW5nIG1pbmltdW0gYWxsb3dlZCBrZXksIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJyZW50IHRpbWUsXG4gICAgYW5kIGFuIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIG9wZXJhdGlvbiwgd2hpY2ggaW1wbGVtZW50cyBbYWR2YW5jZV9jbG9ja10uXG4gICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gYXMgYSBzaWRlIGVmZmVjdCByZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSB0aW1pbmdcbiAgICB3aGVlbCB3aG9zZSBrZXkgaXMgc21hbGxlciB0aGFuIHRoZSBuZXcgbWluaW11bSwgd2hpY2ggaW1wbGVtZW50cyBmaXJpbmcgdGhlIGFsYXJtc1xuICAgIHdob3NlIHRpbWUgaGFzIGV4cGlyZWQuXG5cbiAgICBBZGRpbmcgZWxlbWVudHMgdG8gYW5kIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gYSB0aW1pbmcgd2hlZWwgdGFrZXMgY29uc3RhbnQgdGltZSxcbiAgICB1bmxpa2UgYSBoZWFwLWJhc2VkIHByaW9yaXR5IHF1ZXVlIHdoaWNoIHRha2VzIGxvZyhOKSwgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mXG4gICAgZWxlbWVudHMgaW4gdGhlIGhlYXAuICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byB0aGVcbiAgICBhbW91bnQgb2YgaW5jcmVhc2UgaW4gdGhlIG1pbi1hbGxvd2VkIGtleSwgYXMgY29tcGFyZWQgdG8gbG9nKE4pIGZvciBhIGhlYXAuICBJdCBpc1xuICAgIHRoZXNlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VzIHRoYXQgbW90aXZhdGUgdGhlIGV4aXN0ZW5jZSBvZiB0aW1pbmcgd2hlZWxzIGFuZCBtYWtlXG4gICAgdGhlbSBhIGdvb2QgY2hvaWNlIGZvciBtYWludGFpbmcgYSBzZXQgb2YgYWxhcm1zLiAgV2l0aCBhIHRpbWluZyB3aGVlbCwgb25lIGNhblxuICAgIHN1cHBvcnQgYW55IG51bWJlciBvZiBhbGFybXMgcGF5aW5nIGNvbnN0YW50IG92ZXJoZWFkIHBlciBhbGFybSwgd2hpbGUgcGF5aW5nIGFcbiAgICBzbWFsbCBjb25zdGFudCBvdmVyaGVhZCBwZXIgdW5pdCBvZiB0aW1lIHBhc3NlZC5cblxuICAgIEFzIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGluY3JlYXNlcywgdGhlIHRpbWluZyB3aGVlbCBkb2VzIGEgbGF6eSByYWRpeCBzb3J0IG9mIHRoZVxuICAgIGVsZW1lbnQga2V5cywgd2l0aCBsZXZlbCAwIGhhbmRsaW5nIHRoZSBsZWFzdCBzaWduaWZpY2FudCBbYl8wXSBiaXRzIGluIGEga2V5LCBhbmRcbiAgICBlYWNoIHN1YnNlcXVlbnQgbGV2ZWwgW2ldIGhhbmRsaW5nIHRoZSBuZXh0IG1vc3Qgc2lnbmlmaWNhbnQgW2JfaV0gYml0cy4gIFRoZSBsZXZlbHNcbiAgICBob2xkIGluY3JlYXNpbmdseSBsYXJnZXIgcmFuZ2VzIG9mIGtleXMsIHdoZXJlIHRoZSB1bmlvbiBvZiBhbGwgdGhlIGxldmVscyBjYW4gaG9sZFxuICAgIGFueSBrZXkgZnJvbSBbbWluX2FsbG93ZWRfa2V5IHRdIHRvIFttYXhfYWxsb3dlZF9rZXkgdF0uICBXaGVuIGEga2V5IGlzIGFkZGVkIHRvIHRoZVxuICAgIHRpbWluZyB3aGVlbCwgaXQgaXMgYWRkZWQgYXQgdGhlIGxvd2VzdCBwb3NzaWJsZSBsZXZlbCB0aGF0IGNhbiBzdG9yZSB0aGUga2V5LiAgQXNcbiAgICB0aGUgbWluaW11bSBhbGxvd2VkIGtleSBpbmNyZWFzZXMsIHRpbWluZy13aGVlbCBlbGVtZW50cyBtb3ZlIGRvd24gbGV2ZWxzIHVudGlsIHRoZXlcbiAgICByZWFjaCBsZXZlbCAwLCBhbmQgdGhlbiBhcmUgZXZlbnR1YWxseSByZW1vdmVkLiAgKilcbm1vZHVsZSBQcmlvcml0eV9xdWV1ZSA6IHNpZ1xuICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSBwcmlvcml0eV9xdWV1ZSA9ICdhIHRcblxuICBtb2R1bGUgS2V5IDogSW50ZXJ2YWxfbnVtXG5cbiAgbW9kdWxlIEVsdCA6IHNpZ1xuICAgICgqKiBBbiBbRWx0LnRdIHJlcHJlc2VudHMgYW4gZWxlbWVudCB0aGF0IHdhcyBhZGRlZCB0byBhIHRpbWluZyB3aGVlbC4gKilcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBhdCA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gVGltZV9ucy50XG4gICAgdmFsIGtleSA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgdmFsdWUgOiAnYSBwcmlvcml0eV9xdWV1ZSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIG51bGwgOiB1bml0IC0+ICdhIHRcbiAgZW5kXG5cbiAgbW9kdWxlIEludGVybmFsX2VsdCA6IHNpZ1xuICAgIG1vZHVsZSBQb29sIDogc2lnXG4gICAgICB0eXBlICdhIHRcbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGtleSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IEtleS50XG4gICAgdmFsIG1heF9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gICAgdmFsIG1pbl9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gICAgdmFsIGlzX251bGwgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCB0b19leHRlcm5hbCA6ICdhIHQgLT4gJ2EgRWx0LnRcbiAgZW5kXG5cbiAgdmFsIHBvb2wgOiAnYSB0IC0+ICdhIEludGVybmFsX2VsdC5Qb29sLnRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgKCoqIFtjcmVhdGUgP2xldmVsX2JpdHMgKCldIGNyZWF0ZXMgYSBuZXcgZW1wdHkgdGltaW5nIHdoZWVsLCBbdF0sIHdpdGggW2xlbmd0aCB0ID0gMF1cbiAgICAgIGFuZCBbbWluX2FsbG93ZWRfa2V5IHQgPSAwXS4gKilcbiAgdmFsIGNyZWF0ZSA6ID9jYXBhY2l0eTppbnQgLT4gP2xldmVsX2JpdHM6TGV2ZWxfYml0cy50IC0+IHVuaXQgLT4gJ2EgdFxuXG4gICgqKiBbbGVuZ3RoIHRdIHJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdGltaW5nIHdoZWVsLiAqKVxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuXG4gICgqKiBbbWluX2FsbG93ZWRfa2V5IHRdIGlzIHRoZSBtaW5pbXVtIGtleSB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gW3RdLiAgVGhpcyBvbmx5XG4gICAgICBpbmRpY2F0ZXMgdGhlIHBvc3NpYmlsaXR5OyB0aGVyZSBuZWVkIG5vdCBiZSBhbiBlbGVtZW50IFtlbHRdIGluIFt0XSB3aXRoIFtFbHQua2V5XG4gICAgICBlbHQgPSBtaW5fYWxsb3dlZF9rZXkgdF0uICBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgXCJtaW5fa2V5XCIgb3BlcmF0aW9uIGluIGFcbiAgICAgIHR5cGljYWwgcHJpb3JpdHkgcXVldWUuXG5cbiAgICAgIFttaW5fYWxsb3dlZF9rZXkgdF0gY2FuIGluY3JlYXNlIG92ZXIgdGltZSwgdmlhIGNhbGxzIHRvXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XS4gKilcbiAgdmFsIG1pbl9hbGxvd2VkX2tleSA6IF8gdCAtPiBLZXkudFxuXG4gICgqKiBbbWF4X2FsbG93ZWRfa2V5IHRdIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQga2V5IHRoYXQgY2FuIGJlIHN0b3JlZCBpbiBbdF0uICBBc1xuICAgICAgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLCBzbyBkb2VzIFttYXhfYWxsb3dlZF9rZXldOyBob3dldmVyIGl0IGlzIG5vdCB0aGUgY2FzZVxuICAgICAgdGhhdCBbbWF4X2FsbG93ZWRfa2V5IHQgLSBtaW5fYWxsb3dlZF9rZXkgdF0gaXMgYSBjb25zdGFudC4gIEl0IGlzIGd1YXJhbnRlZWQgdGhhdFxuICAgICAgW21heF9hbGxvd2VkX2tleSB0ID49IG1pbl9hbGxvd2VkX2tleSB0ICsgMl5CIC0gMV0sXG4gICAgICB3aGVyZSBbQl0gaXMgdGhlIHN1bSBvZiB0aGUgYl9pIGluIFtsZXZlbF9iaXRzXS4gKilcbiAgdmFsIG1heF9hbGxvd2VkX2tleSA6IF8gdCAtPiBLZXkudFxuXG4gIHZhbCBtaW5fZWx0XyA6ICdhIHQgLT4gJ2EgSW50ZXJuYWxfZWx0LnRcbiAgdmFsIGludGVybmFsX2FkZCA6ICdhIHQgLT4ga2V5OktleS50IC0+IGF0OlRpbWVfbnMudCAtPiAnYSAtPiAnYSBJbnRlcm5hbF9lbHQudFxuXG4gICgqKiBbcmVtb3ZlIHQgZWx0XSByZW1vdmVzIFtlbHRdIGZyb20gW3RdLiAgSXQgaXMgYW4gZXJyb3IgaWYgW2VsdF0gaXMgbm90IGN1cnJlbnRseVxuICAgICAgaW4gW3RdLCBhbmQgdGhpcyBlcnJvciBtYXkgb3IgbWF5IG5vdCBiZSBkZXRlY3RlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4gJ2EgRWx0LnQgLT4gdW5pdFxuXG4gIHZhbCBjaGFuZ2UgOiAnYSB0IC0+ICdhIEVsdC50IC0+IGtleTpLZXkudCAtPiBhdDpUaW1lX25zLnQgLT4gdW5pdFxuXG4gICgqKiBbY2xlYXIgdF0gcmVtb3ZlcyBhbGwgZWx0cyBmcm9tIFt0XS4gKilcbiAgdmFsIGNsZWFyIDogXyB0IC0+IHVuaXRcblxuICB2YWwgbWVtIDogJ2EgdCAtPiAnYSBFbHQudCAtPiBib29sXG5cbiAgbW9kdWxlIEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQgOiBzaWdcbiAgICB0eXBlIHQgPVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2VcbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWRcbiAgZW5kXG5cbiAgKCoqIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXkgdCB+a2V5IH5oYW5kbGVfcmVtb3ZlZF0gaW5jcmVhc2VzIHRoZSBtaW5pbXVtIGFsbG93ZWRcbiAgICAgIGtleSBpbiBbdF0gdG8gW2tleV0sIGFuZCByZW1vdmVzIGFsbCBlbGVtZW50cyB3aXRoIGtleXMgbGVzcyB0aGFuIFtrZXldLCBhcHBseWluZ1xuICAgICAgW2hhbmRsZV9yZW1vdmVkXSB0byBlYWNoIGVsZW1lbnQgdGhhdCBpcyByZW1vdmVkLiAgSWYgW2tleSA8PSBtaW5fYWxsb3dlZF9rZXkgdF0sXG4gICAgICB0aGVuIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGRvZXMgbm90aGluZy4gIE90aGVyd2lzZSwgaWZcbiAgICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIHJldHVybnMgc3VjY2Vzc2Z1bGx5LCBbbWluX2FsbG93ZWRfa2V5IHQgPSBrZXldLlxuXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byBba2V5IC0gbWluX2FsbG93ZWRfa2V5IHRdLFxuICAgICAgYWx0aG91Z2ggcG9zc2libHkgbGVzcyB0aW1lLlxuXG4gICAgICBCZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbaGFuZGxlX3JlbW92ZWRdIGFjY2Vzc2VzIFt0XSBpbiBhbnkgd2F5IG90aGVyIHRoYW5cbiAgICAgIFtFbHRdIGZ1bmN0aW9ucy4gKilcbiAgdmFsIGluY3JlYXNlX21pbl9hbGxvd2VkX2tleVxuICAgIDogICdhIHRcbiAgICAtPiBrZXk6S2V5LnRcbiAgICAtPiBoYW5kbGVfcmVtb3ZlZDooJ2EgRWx0LnQgLT4gdW5pdClcbiAgICAtPiBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0LnRcblxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgRWx0LnQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBmaXJlX3Bhc3RfYWxhcm1zXG4gICAgOiAgJ2EgdFxuICAgIC0+IGhhbmRsZV9maXJlZDooJ2EgRWx0LnQgLT4gdW5pdClcbiAgICAtPiBrZXk6S2V5LnRcbiAgICAtPiBub3c6VGltZV9ucy50XG4gICAgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gICgqKiBFYWNoIHNsb3QgaW4gYSBsZXZlbCBpcyBhIChwb3NzaWJseSBudWxsKSBwb2ludGVyIHRvIGEgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0XG4gICAgICBvZiBlbGVtZW50cy4gIFdlIHBvb2wgdGhlIGVsZW1lbnRzIHNvIHRoYXQgd2UgY2FuIHJldXNlIHRoZW0gYWZ0ZXIgdGhleSBhcmUgcmVtb3ZlZFxuICAgICAgZnJvbSB0aGUgdGltaW5nIHdoZWVsIChlaXRoZXIgdmlhIFtyZW1vdmVdIG9yIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldKS4gIEluXG4gICAgICBhZGRpdGlvbiB0byBzdG9yaW5nIHRoZSBba2V5XSwgW2F0XSwgYW5kIFt2YWx1ZV0gaW4gdGhlIGVsZW1lbnQsIHdlIHN0b3JlIHRoZVxuICAgICAgW2xldmVsX2luZGV4XSBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IGdldCB0byB0aGUgbGV2ZWwgaG9sZGluZyBhbiBlbGVtZW50IHdoZW4gd2VcbiAgICAgIFtyZW1vdmVdIGl0LlxuXG4gICAgICBXZSBkaXN0aW5ndWlzaCBiZXR3ZWVuIFtFeHRlcm5hbF9lbHRdIGFuZCBbSW50ZXJuYWxfZWx0XSwgd2hpY2ggYXJlIHRoZSBzYW1lXG4gICAgICB1bmRlcm5lYXRoLiAgV2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IGFuIFtJbnRlcm5hbF9lbHRdIGlzIGVpdGhlciBbbnVsbF0gb3IgYVxuICAgICAgdmFsaWQgcG9pbnRlci4gIE9uIHRoZSBvdGhlciBoYW5kLCBbRXh0ZXJuYWxfZWx0XXMgYXJlIHJldHVybmVkIHRvIHVzZXIgY29kZSwgc29cbiAgICAgIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB2YWxpZGl0eSAtLSB3ZSBhbHdheXMgdmFsaWRhdGUgYW4gW0V4dGVybmFsX2VsdF0gYmVmb3JlXG4gICAgICBkb2luZyBhbnl0aGluZyB3aXRoIGl0LlxuXG4gICAgICBJdCBpcyB0aGVyZWZvcmUgT0sgdG8gdXNlIFtQb29sLlVuc2FmZV0sIGJlY2F1c2Ugd2Ugd2lsbCBuZXZlciBhdHRlbXB0IHRvIGFjY2VzcyBhXG4gICAgICBzbG90IG9mIGFuIGludmFsaWQgcG9pbnRlci4gKilcbiAgbW9kdWxlIFBvb2wgPSBQb29sLlVuc2FmZVxuXG4gIG1vZHVsZSBQb2ludGVyID0gUG9vbC5Qb2ludGVyXG5cbiAgbW9kdWxlIEtleSA6IHNpZ1xuICAgICgqKiBbSW50ZXJ2YWxfbnVtXSBpcyB0aGUgcHVibGljIEFQSS4gIEV2ZXJ5dGhpbmcgZm9sbG93aW5nIGluIHRoZSBzaWduYXR1cmUgaXNcbiAgICAgICAgZm9yIGludGVybmFsIHVzZS4gKilcbiAgICBpbmNsdWRlIFRpbWluZ193aGVlbF9pbnRmLkludGVydmFsX251bVxuXG4gICAgKCoqIFthZGRfY2xhbXBfdG9fbWF4XSBkb2Vzbid0IHdvcmsgYXQgYWxsIHdpdGggbmVnYXRpdmUgc3BhbnMgKilcbiAgICB2YWwgYWRkX2NsYW1wX3RvX21heCA6IHQgLT4gU3Bhbi50IC0+IHRcblxuICAgIHZhbCBzdWNjX2NsYW1wX3RvX21heCA6IHQgLT4gdFxuXG4gICAgKCoqIFtTbG90c19tYXNrXSBpcyB1c2VkIHRvIHF1aWNrbHkgZGV0ZXJtaW5lIGEga2V5J3Mgc2xvdCBpbiBhIGdpdmVuIGxldmVsLiAqKVxuICAgIG1vZHVsZSBTbG90c19tYXNrIDogc2lnXG4gICAgICB0eXBlIHQgPSBwcml2YXRlIEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgdmFsIGNyZWF0ZSA6IGxldmVsX2JpdHM6TnVtX2tleV9iaXRzLnQgLT4gdFxuICAgICAgdmFsIG5leHRfc2xvdCA6IHQgLT4gaW50IC0+IGludFxuICAgIGVuZFxuXG4gICAgKCoqIFtNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXSBpcyB1c2VkIHRvIHF1aWNrbHkgZGV0ZXJtaW5lIHRoZSBtaW5pbXVtIGtleSBpbiB0aGVcbiAgICAgICAgc2FtZSBzbG90IGFzIGEgZ2l2ZW4ga2V5LiAqKVxuICAgIG1vZHVsZSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIDogc2lnXG4gICAgICB0eXBlIHQgPSBwcml2YXRlIEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgaW5jbHVkZSBFcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgICAgdmFsIGNyZWF0ZSA6IGJpdHNfcGVyX3Nsb3Q6TnVtX2tleV9iaXRzLnQgLT4gdFxuICAgIGVuZFxuXG4gICAgdmFsIG51bV9rZXlzIDogTnVtX2tleV9iaXRzLnQgLT4gU3Bhbi50XG4gICAgdmFsIG1pbl9rZXlfaW5fc2FtZV9zbG90IDogdCAtPiBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLnQgLT4gdFxuICAgIHZhbCBzbG90IDogdCAtPiBiaXRzX3Blcl9zbG90Ok51bV9rZXlfYml0cy50IC0+IHNsb3RzX21hc2s6U2xvdHNfbWFzay50IC0+IGludFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgU2xvdHNfbWFzayA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gSW50NjMudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICBsZXQgY3JlYXRlIH5sZXZlbF9iaXRzID0gSW50NjMuKCAtICkgKE51bV9rZXlfYml0cy5wb3cyIGxldmVsX2JpdHMpIEludDYzLm9uZVxuICAgICAgbGV0IG5leHRfc2xvdCB0IHNsb3QgPSAoc2xvdCArIDEpIGxhbmQgSW50NjMudG9faW50X2V4biB0XG4gICAgZW5kXG5cbiAgICBsZXQgbnVtX2tleXMgbnVtX2JpdHMgPSBOdW1fa2V5X2JpdHMucG93MiBudW1fYml0c1xuXG4gICAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgSW50NjNcblxuICAgICAgbGV0IGNyZWF0ZSB+Yml0c19wZXJfc2xvdCA9IGJpdF9ub3QgKE51bV9rZXlfYml0cy5wb3cyIGJpdHNfcGVyX3Nsb3QgLSBvbmUpXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgU3BhbiA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgICBsZXQgdG9faW50NjMgdCA9IHRcbiAgICAgIGxldCBvZl9pbnQ2MyBpID0gaVxuICAgICAgbGV0IHNjYWxlX2ludCB0IGkgPSB0ICogb2ZfaW50IGlcbiAgICBlbmRcblxuICAgIGluY2x1ZGUgSW50NjNcblxuICAgIGxldCBvZl9pbnQ2MyBpID0gaVxuICAgIGxldCB0b19pbnQ2MyB0ID0gdFxuICAgIGxldCBhZGQgdCBpID0gdCArIGlcbiAgICBsZXQgYWRkX2NsYW1wX3RvX21heCB0IGkgPSBpZiB0ID4gbWF4X3ZhbHVlIC0gaSB0aGVuIG1heF92YWx1ZSBlbHNlIHQgKyBpXG4gICAgbGV0IHN1Y2NfY2xhbXBfdG9fbWF4IHQgPSBpZiB0ID0gbWF4X3ZhbHVlIHRoZW4gbWF4X3ZhbHVlIGVsc2Ugc3VjYyB0XG4gICAgbGV0IHN1YiB0IGkgPSB0IC0gaVxuICAgIGxldCBkaWZmIHQxIHQyID0gdDEgLSB0MlxuXG4gICAgbGV0IHNsb3QgdCB+KGJpdHNfcGVyX3Nsb3QgOiBOdW1fa2V5X2JpdHMudCkgfnNsb3RzX21hc2sgPVxuICAgICAgdG9faW50X2V4biAoYml0X2FuZCAoc2hpZnRfcmlnaHQgdCAoYml0c19wZXJfc2xvdCA6PiBpbnQpKSBzbG90c19tYXNrKVxuICAgIDs7XG5cbiAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID1cbiAgICAgIGJpdF9hbmQgdCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPSBLZXkuTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICBtb2R1bGUgU2xvdHNfbWFzayA9IEtleS5TbG90c19tYXNrXG5cbiAgbW9kdWxlIEV4dGVybmFsX2VsdCA9IHN0cnVjdFxuXG4gICAgKCoqIFRoZSBbcG9vbF9zbG90c10gaGVyZSBoYXMgbm90aGluZyB0byBkbyB3aXRoIHRoZSBzbG90cyBpbiBhIGxldmVsIGFycmF5LiAgVGhpcyBpc1xuICAgICAgICBmb3IgdGhlIHNsb3RzIGluIHRoZSBwb29sIHR1cGxlIHJlcHJlc2VudGluZyBhIGxldmVsIGVsZW1lbnQuICopXG4gICAgdHlwZSAnYSBwb29sX3Nsb3RzID1cbiAgICAgICggS2V5LnRcbiAgICAgICwgVGltZV9ucy50XG4gICAgICAsICdhXG4gICAgICAsIGludFxuICAgICAgLCAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudFxuICAgICAgLCAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudCApXG4gICAgICAgIFBvb2wuU2xvdHMudDZcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdHlwZSAnYSB0ID0gJ2EgcG9vbF9zbG90cyBQb2ludGVyLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gUG9pbnRlci5udWxsXG4gIGVuZFxuXG4gIG1vZHVsZSBJbnRlcm5hbF9lbHQgOiBzaWdcbiAgICBtb2R1bGUgUG9vbCA6IHNpZ1xuICAgICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICAgIGluY2x1ZGUgSW52YXJpYW50LlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgICAgdmFsIGNyZWF0ZSA6ID9jYXBhY2l0eTppbnQgLT4gdW5pdCAtPiBfIHRcbiAgICAgIHZhbCBpc19mdWxsIDogXyB0IC0+IGJvb2xcbiAgICAgIHZhbCBncm93IDogP2NhcGFjaXR5OmludCAtPiAnYSB0IC0+ICdhIHRcbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdCA9IHByaXZhdGUgJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBudWxsIDogdW5pdCAtPiBfIHRcbiAgICB2YWwgaXNfbnVsbCA6IF8gdCAtPiBib29sXG4gICAgdmFsIGlzX3ZhbGlkIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gYm9vbFxuXG4gICAgKCoqIERlYWxpbmcgd2l0aCBbRXh0ZXJuYWxfZWx0XXMuICopXG5cbiAgICB2YWwgZXh0ZXJuYWxfaXNfdmFsaWQgOiAnYSBQb29sLnQgLT4gJ2EgRXh0ZXJuYWxfZWx0LnQgLT4gYm9vbFxuICAgIHZhbCB0b19leHRlcm5hbCA6ICdhIHQgLT4gJ2EgRXh0ZXJuYWxfZWx0LnRcbiAgICB2YWwgb2ZfZXh0ZXJuYWxfZXhuIDogJ2EgUG9vbC50IC0+ICdhIEV4dGVybmFsX2VsdC50IC0+ICdhIHRcbiAgICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBQb29sLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuXG4gICAgKCoqIFtjcmVhdGVdIHJldHVybnMgYW4gZWxlbWVudCB3aG9zZSBbbmV4dF0gYW5kIFtwcmV2XSBhcmUgW251bGxdLiAqKVxuICAgIHZhbCBjcmVhdGVcbiAgICAgIDogICdhIFBvb2wudFxuICAgICAgLT4ga2V5OktleS50XG4gICAgICAoKiogW2F0XSBpcyB1c2VkIHdoZW4gdGhlIHByaW9yaXR5IHF1ZXVlIGlzIHVzZWQgdG8gaW1wbGVtZW50IGEgdGltaW5nIHdoZWVsLiAgSWZcbiAgICAgICAgICB1bnVzZWQsIGl0IHdpbGwgYmUgW1RpbWVfbnMuZXBvY2hdLiAqKVxuICAgICAgLT4gYXQ6VGltZV9ucy50XG4gICAgICAtPiB2YWx1ZTonYVxuICAgICAgLT4gbGV2ZWxfaW5kZXg6aW50XG4gICAgICAtPiAnYSB0XG5cbiAgICB2YWwgZnJlZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBhY2Nlc3NvcnMgKilcblxuICAgIHZhbCBrZXkgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBLZXkudFxuICAgIHZhbCBhdCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IFRpbWVfbnMudFxuICAgIHZhbCBsZXZlbF9pbmRleCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBuZXh0IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB2YWx1ZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+ICdhXG5cbiAgICAoKiogbXV0YXRvcnMgKilcblxuICAgIHZhbCBzZXRfa2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnQgLT4gdW5pdFxuICAgIHZhbCBzZXRfYXQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBUaW1lX25zLnQgLT4gdW5pdFxuICAgIHZhbCBzZXRfbGV2ZWxfaW5kZXggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnQgLT4gdW5pdFxuXG4gICAgKCoqIFtpbnNlcnRfYXRfZW5kIHBvb2wgdCB+dG9fYWRkXSB0cmVhdHMgW3RdIGFzIHRoZSBoZWFkIG9mIHRoZSBsaXN0IGFuZCBhZGRzIFt0b19hZGRdXG4gICAgICAgIHRvIHRoZSBlbmQgb2YgaXQuICopXG4gICAgdmFsIGluc2VydF9hdF9lbmQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB0b19hZGQ6J2EgdCAtPiB1bml0XG5cbiAgICAoKiogW2xpbmtfdG9fc2VsZiBwb29sIHRdIG1ha2VzIFt0XSBiZSBhIHNpbmdsZXRvbiBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QuICopXG4gICAgdmFsIGxpbmtfdG9fc2VsZiA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBbdW5saW5rIHAgdF0gdW5saW5rcyBbdF0gZnJvbSB0aGUgY2lyY3VsYXJseSBkb3VibHktbGlua2VkIGxpc3QgdGhhdCBpdCBpcyBpbi4gIEl0XG4gICAgICAgIGNoYW5nZXMgdGhlIHBvaW50ZXJzIG9mIFt0XSdzIFtwcmV2XSBhbmQgW25leHRdIGVsdHMsIGJ1dCBub3QgW3RdJ3MgW3ByZXZdIGFuZFxuICAgICAgICBbbmV4dF0gcG9pbnRlcnMuICBbdW5saW5rXSBpcyBtZWFuaW5nbGVzcyBpZiBbdF0gaXMgYSBzaW5nbGV0b24uICopXG4gICAgdmFsIHVubGluayA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBJdGVyYXRvcnMuICBbaXRlciBwIHQgfmluaXQgfmZdIHZpc2l0cyBlYWNoIGVsZW1lbnQgaW4gdGhlIGRvdWJseS1saW5rZWQgbGlzdFxuICAgICAgICBjb250YWluaW5nIFt0XSwgc3RhcnRpbmcgYXQgW3RdLCBhbmQgZm9sbG93aW5nIFtuZXh0XSBwb2ludGVycy4gIFtsZW5ndGhdIGNvdW50c1xuICAgICAgICBieSB2aXNpdGluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGxpc3QuICopXG4gICAgdmFsIGl0ZXIgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBmOignYSB0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAgIHZhbCBsZW5ndGggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnRcblxuICAgICgqKiBbbWF4X2FsYXJtX3RpbWUgdCBlbHQgfndpdGhfa2V5XSBmaW5kcyB0aGUgbWF4IFthdF0gaW4gW2VsdF0ncyBsaXN0IGFtb25nIHRoZSBlbHRzXG4gICAgICAgIHdob3NlIGtleSBpcyBbd2l0aF9rZXldLCByZXR1cm5pbmcgW1RpbWVfbnMuZXBvY2hdIGlmIHRoZSBsaXN0IGlzIGVtcHR5LiAqKVxuICAgIHZhbCBtYXhfYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuXG4gICAgdmFsIG1pbl9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgcG9vbF9zbG90cyA9ICdhIEV4dGVybmFsX2VsdC5wb29sX3Nsb3RzIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgdHlwZSAnYSB0ID0gJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gUG9pbnRlci5udWxsXG4gICAgbGV0IGlzX251bGwgPSBQb2ludGVyLmlzX251bGxcbiAgICBsZXQgZXF1YWwgdDEgdDIgPSBQb2ludGVyLnBoeXNfZXF1YWwgdDEgdDJcblxuICAgIGxldCBjcmVhdGUgcG9vbCB+a2V5IH5hdCB+dmFsdWUgfmxldmVsX2luZGV4ID1cbiAgICAgIFBvb2wubmV3NiBwb29sIGtleSBhdCB2YWx1ZSBsZXZlbF9pbmRleCAobnVsbCAoKSkgKG51bGwgKCkpXG4gICAgOztcblxuICAgIGxldCBmcmVlID0gUG9vbC5mcmVlXG4gICAgbGV0IGtleSBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQwXG4gICAgbGV0IHNldF9rZXkgcCB0IGsgPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQwIGtcbiAgICBsZXQgYXQgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MVxuICAgIGxldCBzZXRfYXQgcCB0IHggPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQxIHhcbiAgICBsZXQgdmFsdWUgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MlxuICAgIGxldCBsZXZlbF9pbmRleCBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQzXG4gICAgbGV0IHNldF9sZXZlbF9pbmRleCBwIHQgaSA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDMgaVxuICAgIGxldCBwcmV2IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDRcbiAgICBsZXQgc2V0X3ByZXYgcCB0IHggPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQ0IHhcbiAgICBsZXQgbmV4dCBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQ1XG4gICAgbGV0IHNldF9uZXh0IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50NSB4XG4gICAgbGV0IGlzX3ZhbGlkIHAgdCA9IFBvb2wucG9pbnRlcl9pc192YWxpZCBwIHRcbiAgICBsZXQgZXh0ZXJuYWxfaXNfdmFsaWQgPSBpc192YWxpZFxuXG4gICAgbGV0IGludmFyaWFudCBwb29sIGludmFyaWFudF9hIHQgPVxuICAgICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICAgICAgYXNzZXJ0IChpc192YWxpZCBwb29sIHQpO1xuICAgICAgICBpbnZhcmlhbnRfYSAodmFsdWUgcG9vbCB0KTtcbiAgICAgICAgbGV0IG4gPSBuZXh0IHBvb2wgdCBpblxuICAgICAgICBhc3NlcnQgKGlzX251bGwgbiB8fCBQb2ludGVyLnBoeXNfZXF1YWwgdCAocHJldiBwb29sIG4pKTtcbiAgICAgICAgbGV0IHAgPSBwcmV2IHBvb2wgdCBpblxuICAgICAgICBhc3NlcnQgKGlzX251bGwgcCB8fCBQb2ludGVyLnBoeXNfZXF1YWwgdCAobmV4dCBwb29sIHApKSlcbiAgICA7O1xuXG4gICAgbW9kdWxlIFBvb2wgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIHBvb2xfc2xvdHMgUG9vbC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICAgIGxldCBpbnZhcmlhbnQgX2ludmFyaWFudF9hIHQgPSBQb29sLmludmFyaWFudCBpZ25vcmUgdFxuICAgICAgbGV0IGNyZWF0ZSA/KGNhcGFjaXR5ID0gMSkgKCkgPSBQb29sLmNyZWF0ZSBQb29sLlNsb3RzLnQ2IH5jYXBhY2l0eVxuICAgICAgbGV0IGdyb3cgPSBQb29sLmdyb3dcbiAgICAgIGxldCBpc19mdWxsID0gUG9vbC5pc19mdWxsXG4gICAgZW5kXG5cbiAgICBsZXQgdG9fZXh0ZXJuYWwgdCA9IHRcblxuICAgIGxldCBvZl9leHRlcm5hbF9leG4gcG9vbCB0ID1cbiAgICAgIGlmIGlzX3ZhbGlkIHBvb2wgdCB0aGVuIHQgZWxzZSByYWlzZV9zIFslbWVzc2FnZSBcIlRpbWluZ193aGVlbCBnb3QgaW52YWxpZCBhbGFybVwiXVxuICAgIDs7XG5cbiAgICBsZXQgdW5saW5rIHBvb2wgdCA9XG4gICAgICBzZXRfbmV4dCBwb29sIChwcmV2IHBvb2wgdCkgKG5leHQgcG9vbCB0KTtcbiAgICAgIHNldF9wcmV2IHBvb2wgKG5leHQgcG9vbCB0KSAocHJldiBwb29sIHQpXG4gICAgOztcblxuICAgIGxldCBsaW5rIHBvb2wgcHJldiBuZXh0ID1cbiAgICAgIHNldF9uZXh0IHBvb2wgcHJldiBuZXh0O1xuICAgICAgc2V0X3ByZXYgcG9vbCBuZXh0IHByZXZcbiAgICA7O1xuXG4gICAgbGV0IGxpbmtfdG9fc2VsZiBwb29sIHQgPSBsaW5rIHBvb2wgdCB0XG5cbiAgICBsZXQgaW5zZXJ0X2F0X2VuZCBwb29sIHQgfnRvX2FkZCA9XG4gICAgICBsZXQgcHJldiA9IHByZXYgcG9vbCB0IGluXG4gICAgICBsaW5rIHBvb2wgcHJldiB0b19hZGQ7XG4gICAgICBsaW5rIHBvb2wgdG9fYWRkIHRcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIgcG9vbCBmaXJzdCB+ZiA9XG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAoKiBXZSBnZXQgW25leHRdIGJlZm9yZSBjYWxsaW5nIFtmXSBzbyB0aGF0IFtmXSBjYW4gbW9kaWZ5IG9yIFtmcmVlXSBbIWN1cnJlbnRdLiAqKVxuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICBmICFjdXJyZW50O1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZVxuICAgIDs7XG5cbiAgICBsZXQgbGVuZ3RoIHBvb2wgZmlyc3QgPVxuICAgICAgbGV0IHIgPSByZWYgMCBpblxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgaW5jciByO1xuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFyXG4gICAgOztcblxuICAgIGxldCBtYXhfYWxhcm1fdGltZSBwb29sIGZpcnN0IH53aXRoX2tleSA9XG4gICAgICBsZXQgbWF4X2FsYXJtX3RpbWUgPSByZWYgVGltZV9ucy5lcG9jaCBpblxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgaWYgS2V5LmVxdWFsIChrZXkgcG9vbCAhY3VycmVudCkgd2l0aF9rZXlcbiAgICAgICAgdGhlbiBtYXhfYWxhcm1fdGltZSA6PSBUaW1lX25zLm1heCAoYXQgcG9vbCAhY3VycmVudCkgIW1heF9hbGFybV90aW1lO1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFtYXhfYWxhcm1fdGltZVxuICAgIDs7XG5cbiAgICBsZXQgbWluX2FsYXJtX3RpbWUgcG9vbCBmaXJzdCB+d2l0aF9rZXkgPVxuICAgICAgbGV0IG1pbl9hbGFybV90aW1lID0gcmVmIFRpbWVfbnMubWF4X3ZhbHVlX3JlcHJlc2VudGFibGUgaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgICgqIFRoZSBba2V5XSBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBmb3IgW21heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0gYmVjYXVzZVxuICAgICAgICAgICBtYXggdGltZSBwZXIgaW50ZXJ2YWwgaXMgbm90IHRoZSBzYW1lIGFzIG1heCB0aW1lIGdsb2JhbGx5LlxuXG4gICAgICAgICAgIFRoaXMgaXMgbm90IHNvIGZvciBbbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsXSwgc28gdGhpcyBjYW4gcG90ZW50aWFsbHlcbiAgICAgICAgICAgYmUgc2ltcGxpZmllZC5cblxuICAgICAgICAgICBQcm9iYWJseSBhIGJldHRlciBjaGFuZ2Ugd291bGQgYmUgdG8gc2ltcGx5IHRyYW5zZmVyIHRoZSBldmVudHMgdG8gdGhlXG4gICAgICAgICAgIFwiZmlyZWRcIiBjb2xsZWN0aW9uIChhbmQgcmVuYW1lIGl0IHRvIFwiYWJvdXQgdG8gZmlyZVwiKSwgd2hpY2ggaXMgc29ydGVkIGJ5IHRpbWUsXG4gICAgICAgICAgIHNvIGdldHRpbmcgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGF0IGNvbGxlY3Rpb24gaXMgZWZmaWNpZW50LlxuICAgICAgICAqKVxuICAgICAgICBpZiBLZXkuZXF1YWwgKGtleSBwb29sICFjdXJyZW50KSB3aXRoX2tleVxuICAgICAgICB0aGVuIG1pbl9hbGFybV90aW1lIDo9IFRpbWVfbnMubWluIChhdCBwb29sICFjdXJyZW50KSAhbWluX2FsYXJtX3RpbWU7XG4gICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICBkb25lO1xuICAgICAgIW1pbl9hbGFybV90aW1lXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIExldmVsID0gc3RydWN0XG4gICAgKCoqIEZvciBnaXZlbiBsZXZlbCwgb25lIGNhbiBicmVhayB0aGUgYml0cyBpbnRvIGEga2V5IGludG8gdGhyZWUgcmVnaW9uczpcblxuICAgICAgICB7dlxuICAgICAgICAgfCBoaWdoZXIgbGV2ZWxzIHwgdGhpcyBsZXZlbCB8IGxvd2VyIGxldmVscyB8XG4gICAgICAgIHZ9XG5cbiAgICAgICAgXCJMb3dlciBsZXZlbHNcIiBpcyBbYml0c19wZXJfc2xvdF0gYml0cyB3aWRlLiAgXCJUaGlzIGxldmVsXCIgaXMgW2JpdHNdIHdpZGUuICopXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgKCogVGhlIFtpbmRleF0gaW4gdGhlIHRpbWluZyB3aGVlbCdzIGFycmF5IG9mIGxldmVscyB3aGVyZSB0aGlzIGxldmVsIGlzLiAqKVxuICAgICAgICBpbmRleCA6IGludFxuICAgICAgOyAoKiBIb3cgbWFueSBbYml0c10gdGhpcyBsZXZlbCBpcyByZXNwb25zaWJsZSBmb3IuICopXG4gICAgICAgIGJpdHMgOiBOdW1fa2V5X2JpdHMudFxuICAgICAgOyAoKiBbc2xvdHNfbWFzayA9IFNsb3RzX21hc2suY3JlYXRlIH5sZXZlbF9iaXRzOnQuYml0c10uICopXG4gICAgICAgIHNsb3RzX21hc2sgOiBTbG90c19tYXNrLnRcbiAgICAgIDsgKCogW2JpdHNfcGVyX3Nsb3RdIGlzIGhvdyBtYW55IGJpdHMgZWFjaCBzbG90IGRpc3Rpbmd1aXNoZXMsIGFuZCBpcyB0aGUgc3VtIG9mIG9mXG4gICAgICAgICAgIHRoZSBbYml0c10gb2YgYWxsIHRoZSBsb3dlciBsZXZlbHMuICopXG4gICAgICAgIGJpdHNfcGVyX3Nsb3QgOiBOdW1fa2V5X2JpdHMudFxuICAgICAgOyBrZXlzX3Blcl9zbG90IDogS2V5LlNwYW4udFxuICAgICAgOyBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIDogTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay50XG4gICAgICA7ICgqIFtkaWZmX21heF9taW5fYWxsb3dlZF9rZXkgPSBrZXlzX3Blcl9zbG90ICogQXJyYXkubGVuZ3RoIHNsb3RzIC0gMV0gKilcbiAgICAgICAgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IDogS2V5LlNwYW4udFxuICAgICAgOyAoKiBbbGVuZ3RoXSBpcyB0aGUgbnVtYmVyIG9mIGVsdHMgY3VycmVudGx5IGluIHRoaXMgbGV2ZWwuICopXG4gICAgICAgIG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgICA7ICgqIEFsbCBlbGVtZW50cyBhdCB0aGlzIGxldmVsIGhhdmUgdGhlaXIgW2tleV0gc2F0aXNmeSBbbWluX2FsbG93ZWRfa2V5IDw9IGtleSA8PVxuICAgICAgICAgICBtYXhfYWxsb3dlZF9rZXldLiAgQWxzbywgW21pbl9hbGxvd2VkX2tleV0gaXMgYSBtdWx0aXBsZSBvZiBba2V5c19wZXJfc2xvdF0uICopXG4gICAgICAgIG11dGFibGUgbWluX2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgbXV0YWJsZSBtYXhfYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyAoKiBbc2xvdHNdIGhvbGRzIHRoZSAocG9zc2libHkgbnVsbCkgcG9pbnRlcnMgdG8gdGhlIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdHNcbiAgICAgICAgICAgb2YgZWx0cy4gIFtBcnJheS5sZW5ndGggc2xvdHMgPSAxIGxzbCBiaXRzXS4gKilcbiAgICAgICAgc2xvdHMgOiAoJ2EgSW50ZXJuYWxfZWx0LnQgYXJyYXlbQHNleHAub3BhcXVlXSlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgICBsZXQgc2xvdCB0IH5rZXkgPSBLZXkuc2xvdCBrZXkgfmJpdHNfcGVyX3Nsb3Q6dC5iaXRzX3Blcl9zbG90IH5zbG90c19tYXNrOnQuc2xvdHNfbWFza1xuICAgIGxldCBuZXh0X3Nsb3QgdCBzbG90ID0gU2xvdHNfbWFzay5uZXh0X3Nsb3QgdC5zbG90c19tYXNrIHNsb3RcblxuICAgIGxldCBtaW5fa2V5X2luX3NhbWVfc2xvdCB0IH5rZXkgPVxuICAgICAgS2V5Lm1pbl9rZXlfaW5fc2FtZV9zbG90IGtleSB0Lm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICA7O1xuXG4gICAgbGV0IGNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IHQgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5ID1cbiAgICAgICgqIFRoaXMgY29tcHV0YXRpb24gZW5zdXJlcyB0aGF0IFt0XSdzIFttaW5fYWxsb3dlZF9rZXldIGlzIGFzIGxhcmdlIGFzIHBvc3NpYmxlXG4gICAgICAgICBzdWJqZWN0IHRvIHRoZSBjb25zdHJhaW50IHRoYXQgdGhlcmUgaXMgbm8gaW50ZXItbGV2ZWwgZ2FwLiAqKVxuICAgICAgaWYgS2V5LmVxdWFsIHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5IEtleS5tYXhfdmFsdWVcbiAgICAgIHRoZW4gS2V5Lm1heF92YWx1ZVxuICAgICAgZWxzZSBtaW5fa2V5X2luX3NhbWVfc2xvdCB0IH5rZXk6KEtleS5zdWNjIHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5KVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAgIDsgbXV0YWJsZSBwb29sIDogJ2EgSW50ZXJuYWxfZWx0LlBvb2wudFxuICAgIDsgKCogW21pbl9lbHRdIGlzIGVpdGhlciBudWxsIG9yIGFuIGVsZW1lbnQgd2hvc2Uga2V5IGlzIFtlbHRfa2V5X2xvd2VyX2JvdW5kXS4gKilcbiAgICAgIG11dGFibGUgbWluX2VsdCA6ICdhIEludGVybmFsX2VsdC50XG4gICAgOyAoKiBBbGwgZWxlbWVudHMgaW4gdGhlIHByaW9yaXR5IHF1ZXVlIGhhdmUgdGhlaXIga2V5IFs+PSBlbHRfa2V5X2xvd2VyX2JvdW5kXS4gKilcbiAgICAgIG11dGFibGUgZWx0X2tleV9sb3dlcl9ib3VuZCA6IEtleS50XG4gICAgOyBsZXZlbHMgOiAnYSBMZXZlbC50IGFycmF5XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgdHlwZSAnYSBwcmlvcml0eV9xdWV1ZSA9ICdhIHRcblxuICBtb2R1bGUgRWx0ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gRXh0ZXJuYWxfZWx0Lm51bGxcbiAgICBsZXQgYXQgcCB0ID0gSW50ZXJuYWxfZWx0LmF0IHAucG9vbCAoSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwLnBvb2wgdClcbiAgICBsZXQga2V5IHAgdCA9IEludGVybmFsX2VsdC5rZXkgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICAgIGxldCB2YWx1ZSBwIHQgPSBJbnRlcm5hbF9lbHQudmFsdWUgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICBlbmRcblxuICBsZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG4gIGxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG4gIGxldCBudW1fbGV2ZWxzIHQgPSBBcnJheS5sZW5ndGggdC5sZXZlbHNcbiAgbGV0IG1pbl9hbGxvd2VkX2tleSB0ID0gTGV2ZWwubWluX2FsbG93ZWRfa2V5IHQubGV2ZWxzLigwKVxuICBsZXQgbWF4X2FsbG93ZWRfa2V5IHQgPSBMZXZlbC5tYXhfYWxsb3dlZF9rZXkgdC5sZXZlbHMuKG51bV9sZXZlbHMgdCAtIDEpXG5cbiAgbGV0IGludGVybmFsX2l0ZXIgdCB+ZiA9XG4gICAgaWYgdC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBmb3IgbGV2ZWxfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBsZXZlbHMgLSAxIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBmb3Igc2xvdF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIHNsb3RzIC0gMSBkb1xuICAgICAgICAgICAgbGV0IGVsdCA9IHNsb3RzLihzbG90X2luZGV4KSBpblxuICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpIHRoZW4gSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmZcbiAgICAgICAgICBkb25lKVxuICAgICAgZG9uZSlcbiAgOztcblxuICBsZXQgaXRlciB0IH5mID0gaW50ZXJuYWxfaXRlciB0IH5mOihmIDogXyBFbHQudCAtPiB1bml0IDo+IF8gSW50ZXJuYWxfZWx0LnQgLT4gdW5pdClcblxuICBtb2R1bGUgUHJldHR5ID0gc3RydWN0XG4gICAgbW9kdWxlIEVsdCA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgeyBrZXkgOiBLZXkudFxuICAgICAgICA7IHZhbHVlIDogJ2FcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG1pbl9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IG1heF9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IGVsdHMgOiAnYSBFbHQudCBsaXN0XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IHByZXR0eSB0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIHsgUHJldHR5Lm1pbl9hbGxvd2VkX2tleSA9IG1pbl9hbGxvd2VkX2tleSB0XG4gICAgOyBtYXhfYWxsb3dlZF9rZXkgPSBtYXhfYWxsb3dlZF9rZXkgdFxuICAgIDsgZWx0cyA9XG4gICAgICAgIChsZXQgciA9IHJlZiBbXSBpblxuICAgICAgICAgaW50ZXJuYWxfaXRlciB0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIHJcbiAgICAgICAgICAgOj0geyBQcmV0dHkuRWx0LmtleSA9IEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHRcbiAgICAgICAgICAgICAgOyB2YWx1ZSA9IEludGVybmFsX2VsdC52YWx1ZSBwb29sIGVsdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDo6ICFyKTtcbiAgICAgICAgIExpc3QucmV2ICFyKVxuICAgIH1cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBtYXRjaCAhc2V4cF9vZl90X3N0eWxlIHdpdGhcbiAgICB8IGBJbnRlcm5hbCAtPiBbJXNleHAgKHQgOiBhIHRfaW50ZXJuYWwpXVxuICAgIHwgYFByZXR0eSAtPiBbJXNleHAgKHByZXR0eSB0IDogYSBQcmV0dHkudCldXG4gIDs7XG5cbiAgbGV0IGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IH5sZXZlbF9iaXRzIH5iaXRzX3Blcl9zbG90ID1cbiAgICBsZXQgYml0cyA9IE51bV9rZXlfYml0cy4oICsgKSBsZXZlbF9iaXRzIGJpdHNfcGVyX3Nsb3QgaW5cbiAgICBpZiBOdW1fa2V5X2JpdHMuZXF1YWwgYml0cyBOdW1fa2V5X2JpdHMubWF4X3ZhbHVlXG4gICAgdGhlbiBLZXkuU3Bhbi5tYXhfdmFsdWVcbiAgICBlbHNlIEtleS5TcGFuLnByZWQgKEtleS5udW1fa2V5cyBiaXRzKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA6IHVuaXQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGxldmVsX2ludmFyaWFudCBsZXZlbCA9XG4gICAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gbGV2ZWwgWyVzZXhwX29mOiBfIExldmVsLnRdIChmdW4gKCkgLT5cbiAgICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgbGV2ZWwgZiBpblxuICAgICAgICBMZXZlbC5GaWVsZHMuaXRlclxuICAgICAgICAgIH5pbmRleDooY2hlY2sgKGZ1biBpbmRleCAtPiBhc3NlcnQgKGluZGV4ID49IDApKSlcbiAgICAgICAgICB+Yml0czooY2hlY2sgKGZ1biBiaXRzIC0+IGFzc2VydCAoTnVtX2tleV9iaXRzLiggPiApIGJpdHMgTnVtX2tleV9iaXRzLnplcm8pKSlcbiAgICAgICAgICB+c2xvdHNfbWFzazpcbiAgICAgICAgICAgIChjaGVja1xuICAgICAgICAgICAgICAgKFsldGVzdF9yZXN1bHQ6IFNsb3RzX21hc2sudF1cbiAgICAgICAgICAgICAgICAgIH5leHBlY3Q6KFNsb3RzX21hc2suY3JlYXRlIH5sZXZlbF9iaXRzOmxldmVsLmJpdHMpKSlcbiAgICAgICAgICB+Yml0c19wZXJfc2xvdDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIGJpdHNfcGVyX3Nsb3QgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoTnVtX2tleV9iaXRzLiggPj0gKSBiaXRzX3Blcl9zbG90IE51bV9rZXlfYml0cy56ZXJvKSkpXG4gICAgICAgICAgfmtleXNfcGVyX3Nsb3Q6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBrZXlzX3Blcl9zbG90IC0+XG4gICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICBrZXlzX3Blcl9zbG90XG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6KEtleS5udW1fa2V5cyBsZXZlbC5iaXRzX3Blcl9zbG90KSkpXG4gICAgICAgICAgfm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2s6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLmVxdWFsXG4gICAgICAgICAgICAgICAgICAgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgICAgICAgICAgICAgICAgIChNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLmNyZWF0ZSB+Yml0c19wZXJfc2xvdDpsZXZlbC5iaXRzX3Blcl9zbG90KSkpKVxuICAgICAgICAgIH5kaWZmX21heF9taW5fYWxsb3dlZF9rZXk6XG4gICAgICAgICAgICAoY2hlY2tcbiAgICAgICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgfmV4cGVjdDpcbiAgICAgICAgICAgICAgICAgICAgKGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgIH5sZXZlbF9iaXRzOmxldmVsLmJpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgfmJpdHNfcGVyX3Nsb3Q6bGV2ZWwuYml0c19wZXJfc2xvdCkpKVxuICAgICAgICAgIH5sZW5ndGg6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICAgICAgICAgICA9IEFycmF5LmZvbGQgbGV2ZWwuc2xvdHMgfmluaXQ6MCB+ZjooZnVuIG4gZWx0IC0+XG4gICAgICAgICAgICAgICAgICAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gICAgICAgICAgICAgICAgICAgdGhlbiBuXG4gICAgICAgICAgICAgICAgICAgZWxzZSBuICsgSW50ZXJuYWxfZWx0Lmxlbmd0aCBwb29sIGVsdCkpKSlcbiAgICAgICAgICB+bWluX2FsbG93ZWRfa2V5OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWluX2FsbG93ZWRfa2V5IC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgbWluX2FsbG93ZWRfa2V5IEtleS56ZXJvKTtcbiAgICAgICAgICAgICAgIGlmIEtleS4oIDwgKSBtaW5fYWxsb3dlZF9rZXkgS2V5Lm1heF92YWx1ZVxuICAgICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgIChLZXkucmVtIG1pbl9hbGxvd2VkX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90KVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6S2V5LlNwYW4uemVybykpXG4gICAgICAgICAgfm1heF9hbGxvd2VkX2tleTpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIG1heF9hbGxvd2VkX2tleSAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LnRdXG4gICAgICAgICAgICAgICAgIG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgIChLZXkuYWRkX2NsYW1wX3RvX21heFxuICAgICAgICAgICAgICAgICAgICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgICAgIGxldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSkpKVxuICAgICAgICAgIH5zbG90czpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIHNsb3RzIC0+XG4gICAgICAgICAgICAgICBBcnJheS5pdGVyIHNsb3RzIH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KVxuICAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgICBJbnRlcm5hbF9lbHQuaW52YXJpYW50IHBvb2wgaW52YXJpYW50X2EgZWx0O1xuICAgICAgICAgICAgICAgICAgIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgKEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpIGxldmVsLm1pbl9hbGxvd2VkX2tleSk7XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKEtleS4oIDw9ICkgKEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpIGxldmVsLm1heF9hbGxvd2VkX2tleSk7XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgKEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpIHQuZWx0X2tleV9sb3dlcl9ib3VuZCk7XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKEludGVybmFsX2VsdC5sZXZlbF9pbmRleCBwb29sIGVsdCA9IGxldmVsLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgIGludmFyaWFudF9hIChJbnRlcm5hbF9lbHQudmFsdWUgcG9vbCBlbHQpKSkpKSkpXG4gICAgaW5cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF9pbnRlcm5hbF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBhc3NlcnQgKEtleS4oID49ICkgKG1pbl9hbGxvd2VkX2tleSB0KSBLZXkuemVybyk7XG4gICAgICBhc3NlcnQgKEtleS4oID49ICkgKG1heF9hbGxvd2VkX2tleSB0KSAobWluX2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5sZW5ndGg6KGNoZWNrIChmdW4gbGVuZ3RoIC0+IGFzc2VydCAobGVuZ3RoID49IDApKSlcbiAgICAgICAgfnBvb2w6KGNoZWNrIChJbnRlcm5hbF9lbHQuUG9vbC5pbnZhcmlhbnQgaWdub3JlKSlcbiAgICAgICAgfm1pbl9lbHQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gZWx0XyAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XylcbiAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgIGFzc2VydCAoSW50ZXJuYWxfZWx0LmlzX3ZhbGlkIHQucG9vbCBlbHRfKTtcbiAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LmVxdWFsIHQuZWx0X2tleV9sb3dlcl9ib3VuZCAoSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgZWx0XykpKSkpXG4gICAgICAgIH5lbHRfa2V5X2xvd2VyX2JvdW5kOlxuICAgICAgICAgIChjaGVjayAoZnVuIGVsdF9rZXlfbG93ZXJfYm91bmQgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgZWx0X2tleV9sb3dlcl9ib3VuZCAobWluX2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgICAgICAgICBhc3NlcnQgKEtleS4oIDw9ICkgZWx0X2tleV9sb3dlcl9ib3VuZCAobWF4X2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIHQubWluX2VsdClcbiAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICBhc3NlcnQgKEtleS5lcXVhbCBlbHRfa2V5X2xvd2VyX2JvdW5kIChJbnRlcm5hbF9lbHQua2V5IHQucG9vbCB0Lm1pbl9lbHQpKSkpXG4gICAgICAgIH5sZXZlbHM6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbGV2ZWxzIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChudW1fbGV2ZWxzIHQgPiAwKTtcbiAgICAgICAgICAgICBBcnJheS5pdGVyaSBsZXZlbHMgfmY6KGZ1biBsZXZlbF9pbmRleCBsZXZlbCAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChsZXZlbF9pbmRleCA9IExldmVsLmluZGV4IGxldmVsKTtcbiAgICAgICAgICAgICAgIGxldmVsX2ludmFyaWFudCBsZXZlbDtcbiAgICAgICAgICAgICAgIGlmIGxldmVsX2luZGV4ID4gMFxuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgIGxldCBwcmV2X2xldmVsID0gbGV2ZWxzLihsZXZlbF9pbmRleCAtIDEpIGluXG4gICAgICAgICAgICAgICAgIGxldCBtb2R1bGUgTCA9IExldmVsIGluXG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgICAgKEwua2V5c19wZXJfc2xvdCBsZXZlbClcbiAgICAgICAgICAgICAgICAgICB+ZXhwZWN0OihLZXkuU3Bhbi5zdWNjIHByZXZfbGV2ZWwuZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5KTtcbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LnRdXG4gICAgICAgICAgICAgICAgICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdDpcbiAgICAgICAgICAgICAgICAgICAgIChMZXZlbC5jb21wdXRlX21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleTpwcmV2X2xldmVsLm1heF9hbGxvd2VkX2tleSkpKSkpKVxuICA7O1xuXG4gICgqKiBbbWluX2VsdF9dIHJldHVybnMgW251bGxdIGlmIGl0IGNhbid0IGZpbmQgdGhlIGRlc2lyZWQgZWxlbWVudC4gIFdlIHdyYXAgaXQgdXBcbiAgICAgIGFmdGVyd2FyZHMgdG8gcmV0dXJuIGFuIFtvcHRpb25dLiAqKVxuICBsZXQgbWluX2VsdF8gdCA9XG4gICAgaWYgaXNfZW1wdHkgdFxuICAgIHRoZW4gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICBlbHNlIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgdC5taW5fZWx0KVxuICAgIHRoZW4gdC5taW5fZWx0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IG1pbl9lbHRfYWxyZWFkeV9mb3VuZCA9IHJlZiAoSW50ZXJuYWxfZWx0Lm51bGwgKCkpIGluXG4gICAgICBsZXQgbWluX2tleV9hbHJlYWR5X2ZvdW5kID0gcmVmIEtleS5tYXhfdmFsdWUgaW5cbiAgICAgIGxldCBsZXZlbF9pbmRleCA9IHJlZiAwIGluXG4gICAgICBsZXQgbnVtX2xldmVscyA9IG51bV9sZXZlbHMgdCBpblxuICAgICAgd2hpbGUgIWxldmVsX2luZGV4IDwgbnVtX2xldmVscyBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4oIWxldmVsX2luZGV4KSBpblxuICAgICAgICBpZiBLZXkuKCA+ICkgKExldmVsLm1pbl9hbGxvd2VkX2tleSBsZXZlbCkgIW1pbl9rZXlfYWxyZWFkeV9mb3VuZFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogV2UgZG9uJ3QgbmVlZCB0byBjb25zaWRlciBhbnkgbW9yZSBsZXZlbHMuICBRdWl0IHRoZSBsb29wLiAqKVxuICAgICAgICAgIGxldmVsX2luZGV4IDo9IG51bV9sZXZlbHNcbiAgICAgICAgZWxzZSBpZiBsZXZlbC5sZW5ndGggPSAwXG4gICAgICAgIHRoZW4gaW5jciBsZXZlbF9pbmRleFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBMb29rIGluIFtsZXZlbF0uICopXG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBsZXQgc2xvdF9taW5fa2V5ID1cbiAgICAgICAgICAgIHJlZlxuICAgICAgICAgICAgICAoTGV2ZWwubWluX2tleV9pbl9zYW1lX3Nsb3RcbiAgICAgICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgfmtleTooS2V5Lm1heCBsZXZlbC5taW5fYWxsb3dlZF9rZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kKSlcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBzbG90ID0gcmVmIChMZXZlbC5zbG90IGxldmVsIH5rZXk6IXNsb3RfbWluX2tleSkgaW5cbiAgICAgICAgICAoKiBGaW5kIHRoZSBmaXJzdCBub25lbXB0eSBzbG90IHdpdGggYSBzbWFsbCBlbm91Z2ggW3Nsb3RfbWluX2tleV0uICopXG4gICAgICAgICAgd2hpbGVcbiAgICAgICAgICAgIEludGVybmFsX2VsdC5pc19udWxsIHNsb3RzLighc2xvdClcbiAgICAgICAgICAgICYmIEtleS4oIDwgKSAhc2xvdF9taW5fa2V5ICFtaW5fa2V5X2FscmVhZHlfZm91bmRcbiAgICAgICAgICBkb1xuICAgICAgICAgICAgc2xvdCA6PSBMZXZlbC5uZXh0X3Nsb3QgbGV2ZWwgIXNsb3Q7XG4gICAgICAgICAgICBzbG90X21pbl9rZXkgOj0gS2V5LmFkZCAhc2xvdF9taW5fa2V5IGxldmVsLmtleXNfcGVyX3Nsb3RcbiAgICAgICAgICBkb25lO1xuICAgICAgICAgIGxldCBmaXJzdCA9IHNsb3RzLighc2xvdCkgaW5cbiAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGZpcnN0KVxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgKCogVmlzaXQgYWxsIG9mIHRoZSBlbHRzIGluIHRoaXMgc2xvdCBhbmQgZmluZCBvbmUgd2l0aCBtaW5pbXVtIGtleS4gKilcbiAgICAgICAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgICAgICAgIGxldCBjdXJyZW50X2tleSA9IEludGVybmFsX2VsdC5rZXkgcG9vbCAhY3VycmVudCBpblxuICAgICAgICAgICAgICBpZiBLZXkuKCA8PSApIGN1cnJlbnRfa2V5ICFtaW5fa2V5X2FscmVhZHlfZm91bmRcbiAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgbWluX2VsdF9hbHJlYWR5X2ZvdW5kIDo9ICFjdXJyZW50O1xuICAgICAgICAgICAgICAgIG1pbl9rZXlfYWxyZWFkeV9mb3VuZCA6PSBjdXJyZW50X2tleSk7XG4gICAgICAgICAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICAgICAgICAoKiBJZiBbIWxldmVsX2luZGV4ID0gMF0gdGhlbiBhbGwgZWx0cyBpbiB0aGlzIHNsb3QgaGF2ZSB0aGUgc2FtZSBba2V5XSxcbiAgICAgICAgICAgICAgICAgaS5lLiBbIXNsb3RfbWluX2tleV0uICBTbywgd2UgZG9uJ3QgaGF2ZSB0byBjaGVjayBhbnkgZWxlbWVudHMgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgW2ZpcnN0XS4gIFRoaXMgaXMgYSB1c2VmdWwgc2hvcnQgY3V0IGluIHRoZSBjb21tb24gY2FzZSB0aGF0IHRoZXJlIGFyZVxuICAgICAgICAgICAgICAgICBtdWx0aXBsZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBtaW4gc2xvdCBpbiBsZXZlbCAwLiAqKVxuICAgICAgICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgfHwgIWxldmVsX2luZGV4ID0gMFxuICAgICAgICAgICAgICB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlXG4gICAgICAgICAgICAgIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICAgICAgICBkb25lKTtcbiAgICAgICAgICAoKiBGaW5pc2hlZCBsb29raW5nIGluIFtsZXZlbF0uICBNb3ZlIHVwIHRvIHRoZSBuZXh0IGxldmVsLiAqKVxuICAgICAgICAgIGluY3IgbGV2ZWxfaW5kZXgpXG4gICAgICBkb25lO1xuICAgICAgdC5taW5fZWx0IDwtICFtaW5fZWx0X2FscmVhZHlfZm91bmQ7XG4gICAgICB0LmVsdF9rZXlfbG93ZXJfYm91bmQgPC0gIW1pbl9rZXlfYWxyZWFkeV9mb3VuZDtcbiAgICAgIHQubWluX2VsdClcbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9ib3VuZHMgdCBrZXkgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlByaW9yaXR5X3F1ZXVlLmFkZF9lbHQga2V5IG91dCBvZiBib3VuZHNcIlxuICAgICAgICAgIChrZXkgOiBLZXkudClcbiAgICAgICAgICAobWluX2FsbG93ZWRfa2V5IHQgOiBLZXkudClcbiAgICAgICAgICAobWF4X2FsbG93ZWRfa2V5IHQgOiBLZXkudClcbiAgICAgICAgICB+cHJpb3JpdHlfcXVldWU6KHQgOiBfIHQpXVxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2xldmVsX2JvdW5kcyBrZXkgbGV2ZWwgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlByaW9yaXR5X3F1ZXVlLmFkZF9lbHQga2V5IG91dCBvZiBsZXZlbCBib3VuZHNcIiAoa2V5IDogS2V5LnQpIChsZXZlbCA6IF8gTGV2ZWwudCldXG4gIDs7XG5cbiAgbGV0IGFkZF9lbHQgdCBlbHQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQgaW5cbiAgICBpZiBub3QgKEtleS4oID49ICkga2V5IChtaW5fYWxsb3dlZF9rZXkgdCkgJiYgS2V5LiggPD0gKSBrZXkgKG1heF9hbGxvd2VkX2tleSB0KSlcbiAgICB0aGVuIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9ib3VuZHMgdCBrZXk7XG4gICAgKCogRmluZCB0aGUgbG93ZXN0IGxldmVsIHRoYXQgd2lsbCBob2xkIFtlbHRdLiAqKVxuICAgIGxldCBsZXZlbF9pbmRleCA9XG4gICAgICBsZXQgbGV2ZWxfaW5kZXggPSByZWYgMCBpblxuICAgICAgd2hpbGUgS2V5LiggPiApIGtleSAoTGV2ZWwubWF4X2FsbG93ZWRfa2V5IHQubGV2ZWxzLighbGV2ZWxfaW5kZXgpKSBkb1xuICAgICAgICBpbmNyIGxldmVsX2luZGV4XG4gICAgICBkb25lO1xuICAgICAgIWxldmVsX2luZGV4XG4gICAgaW5cbiAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgaWYgbm90IChLZXkuKCA+PSApIGtleSBsZXZlbC5taW5fYWxsb3dlZF9rZXkgJiYgS2V5LiggPD0gKSBrZXkgbGV2ZWwubWF4X2FsbG93ZWRfa2V5KVxuICAgIHRoZW4gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2xldmVsX2JvdW5kcyBrZXkgbGV2ZWw7XG4gICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCArIDE7XG4gICAgSW50ZXJuYWxfZWx0LnNldF9sZXZlbF9pbmRleCBwb29sIGVsdCBsZXZlbF9pbmRleDtcbiAgICBsZXQgc2xvdCA9IExldmVsLnNsb3QgbGV2ZWwgfmtleSBpblxuICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgbGV0IGZpcnN0ID0gc2xvdHMuKHNsb3QpIGluXG4gICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICB0aGVuIEludGVybmFsX2VsdC5pbnNlcnRfYXRfZW5kIHBvb2wgZmlyc3QgfnRvX2FkZDplbHRcbiAgICBlbHNlIChcbiAgICAgIHNsb3RzLihzbG90KSA8LSBlbHQ7XG4gICAgICBJbnRlcm5hbF9lbHQubGlua190b19zZWxmIHBvb2wgZWx0KVxuICA7O1xuXG4gIGxldCBpbnRlcm5hbF9hZGRfZWx0IHQgZWx0ID1cbiAgICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgZWx0IGluXG4gICAgaWYgS2V5LiggPCApIGtleSB0LmVsdF9rZXlfbG93ZXJfYm91bmRcbiAgICB0aGVuIChcbiAgICAgIHQubWluX2VsdCA8LSBlbHQ7XG4gICAgICB0LmVsdF9rZXlfbG93ZXJfYm91bmQgPC0ga2V5KTtcbiAgICBhZGRfZWx0IHQgZWx0O1xuICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfZ290X2ludmFsaWRfa2V5IHQga2V5ID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwuYWRkX2F0X2ludGVydmFsX251bSBnb3QgaW52YWxpZCBpbnRlcnZhbCBudW1cIlxuICAgICAgICAgIH5pbnRlcnZhbF9udW06KGtleSA6IEtleS50KVxuICAgICAgICAgIH5taW5fYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW06KG1pbl9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bToobWF4X2FsbG93ZWRfa2V5IHQgOiBLZXkudCldXG4gIDs7XG5cbiAgbGV0IGVuc3VyZV92YWxpZF9rZXkgdCB+a2V5ID1cbiAgICBpZiBLZXkuKCA8ICkga2V5IChtaW5fYWxsb3dlZF9rZXkgdCkgfHwgS2V5LiggPiApIGtleSAobWF4X2FsbG93ZWRfa2V5IHQpXG4gICAgdGhlbiByYWlzZV9nb3RfaW52YWxpZF9rZXkgdCBrZXlcbiAgOztcblxuICBsZXQgaW50ZXJuYWxfYWRkIHQgfmtleSB+YXQgdmFsdWUgPVxuICAgIGVuc3VyZV92YWxpZF9rZXkgdCB+a2V5O1xuICAgIGlmIEludGVybmFsX2VsdC5Qb29sLmlzX2Z1bGwgdC5wb29sIHRoZW4gdC5wb29sIDwtIEludGVybmFsX2VsdC5Qb29sLmdyb3cgdC5wb29sO1xuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQuY3JlYXRlIHQucG9vbCB+a2V5IH5hdCB+dmFsdWUgfmxldmVsX2luZGV4OigtMSkgaW5cbiAgICBpbnRlcm5hbF9hZGRfZWx0IHQgZWx0O1xuICAgIGVsdFxuICA7O1xuXG4gICgqKiBbcmVtb3ZlX29yX3JlX2FkZF9lbHRzXSB2aXNpdHMgZWFjaCBlbGVtZW50IGluIHRoZSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3RcbiAgICAgIFtmaXJzdF0uICBJZiB0aGUgZWxlbWVudCdzIGtleSBpcyBbPj0gdF9taW5fYWxsb3dlZF9rZXldLCB0aGVuIGl0IGFkZHMgdGhlIGVsZW1lbnRcbiAgICAgIGJhY2sgYXQgYSBsb3dlciBsZXZlbC4gIElmIG5vdCwgdGhlbiBpdCBjYWxscyBbaGFuZGxlX3JlbW92ZWRdIGFuZCBbZnJlZV1zIHRoZVxuICAgICAgZWxlbWVudC4gKilcbiAgbGV0IHJlbW92ZV9vcl9yZV9hZGRfZWx0cyB0IChsZXZlbCA6IF8gTGV2ZWwudCkgZmlyc3QgfnRfbWluX2FsbG93ZWRfa2V5IH5oYW5kbGVfcmVtb3ZlZFxuICAgID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICgqIFdlIGV4dHJhY3QgW25leHRdIGZyb20gW2N1cnJlbnRdIGZpcnN0LCBiZWNhdXNlIHdlIHdpbGwgbW9kaWZ5IG9yIFtmcmVlXVxuICAgICAgICAgW2N1cnJlbnRdIGJlZm9yZSBjb250aW51aW5nIHRoZSBsb29wLiAqKVxuICAgICAgbGV0IG5leHQgPSBJbnRlcm5hbF9lbHQubmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICBsZXZlbC5sZW5ndGggPC0gbGV2ZWwubGVuZ3RoIC0gMTtcbiAgICAgIGlmIEtleS4oID49ICkgKEludGVybmFsX2VsdC5rZXkgcG9vbCAhY3VycmVudCkgdF9taW5fYWxsb3dlZF9rZXlcbiAgICAgIHRoZW4gYWRkX2VsdCB0ICFjdXJyZW50XG4gICAgICBlbHNlIChcbiAgICAgICAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICAgICAgICBoYW5kbGVfcmVtb3ZlZCAoSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsICFjdXJyZW50KTtcbiAgICAgICAgSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCAhY3VycmVudCk7XG4gICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgIGRvbmVcbiAgOztcblxuICAoKiogW2luY3JlYXNlX2xldmVsX21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiBbbGV2ZWxdIHRvIGFzXG4gICAgICBsYXJnZSBhIHZhbHVlIGFzIHBvc3NpYmxlLCBidXQgbm8gbW9yZSB0aGFuIFttYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XS5cbiAgICAgIFt0X21pbl9hbGxvd2VkX2tleV0gaXMgdGhlIG1pbmltdW0gYWxsb3dlZCBrZXkgZm9yIHRoZSBlbnRpcmUgdGltaW5nIHdoZWVsLiAgQXNcbiAgICAgIGVsZW1lbnRzIGFyZSBlbmNvdW50ZXJlZCwgdGhleSBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB0aW1pbmcgd2hlZWwgaWYgdGhlaXIga2V5IGlzXG4gICAgICBzbWFsbGVyIHRoYW4gW3RfbWluX2FsbG93ZWRfa2V5XSwgb3IgYWRkZWQgYXQgYSBsb3dlciBsZXZlbCBpZiBub3QuICopXG4gIGxldCBpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgdFxuICAgICAgICAobGV2ZWwgOiBfIExldmVsLnQpXG4gICAgICAgIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleVxuICAgICAgICB+dF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgfmhhbmRsZV9yZW1vdmVkXG4gICAgPVxuICAgIGxldCBkZXNpcmVkX21pbl9hbGxvd2VkX2tleSA9XG4gICAgICBMZXZlbC5jb21wdXRlX21pbl9hbGxvd2VkX2tleSBsZXZlbCB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICBpblxuICAgICgqIFdlIHJlcXVpcmUgdGhhdCBbbW9kIGxldmVsLm1pbl9hbGxvd2VkX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90ID0gMF0uICBTbyxcbiAgICAgICB3ZSBzdGFydCBbbGV2ZWxfbWluX2FsbG93ZWRfa2V5XSB3aGVyZSB0aGF0IGlzIHRydWUsIGFuZCB0aGVuIGluY3JlYXNlIGl0IGJ5XG4gICAgICAgW2tleXNfcGVyX3Nsb3RdIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBsb29wLiAqKVxuICAgIGxldCBsZXZlbF9taW5fYWxsb3dlZF9rZXkgPVxuICAgICAgTGV2ZWwubWluX2tleV9pbl9zYW1lX3Nsb3RcbiAgICAgICAgbGV2ZWxcbiAgICAgICAgfmtleTpcbiAgICAgICAgICAoS2V5Lm1pblxuICAgICAgICAgICAgIGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgKEtleS5tYXggbGV2ZWwubWluX2FsbG93ZWRfa2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZCkpXG4gICAgaW5cbiAgICBsZXQgbGV2ZWxfbWluX2FsbG93ZWRfa2V5ID0gcmVmIGxldmVsX21pbl9hbGxvd2VkX2tleSBpblxuICAgIGxldCBzbG90ID0gcmVmIChMZXZlbC5zbG90IGxldmVsIH5rZXk6IWxldmVsX21pbl9hbGxvd2VkX2tleSkgaW5cbiAgICBsZXQga2V5c19wZXJfc2xvdCA9IGxldmVsLmtleXNfcGVyX3Nsb3QgaW5cbiAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgIHdoaWxlIEtleS4oIDwgKSAhbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IGRvXG4gICAgICBpZiBsZXZlbC5sZW5ndGggPSAwXG4gICAgICB0aGVuXG4gICAgICAgICgqIElmIG5vIGVsZW1lbnRzIHJlbWFpbiBhdCB0aGlzIGxldmVsLCB3ZSBjYW4ganVzdCBzZXQgW21pbl9hbGxvd2VkX2tleV0gdG8gdGhlXG4gICAgICAgICAgIGRlc2lyZWQgdmFsdWUuICopXG4gICAgICAgIGxldmVsX21pbl9hbGxvd2VkX2tleSA6PSBkZXNpcmVkX21pbl9hbGxvd2VkX2tleVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBmaXJzdCA9IHNsb3RzLighc2xvdCkgaW5cbiAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgc2xvdHMuKCFzbG90KSA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKTtcbiAgICAgICAgICByZW1vdmVfb3JfcmVfYWRkX2VsdHMgdCBsZXZlbCBmaXJzdCB+dF9taW5fYWxsb3dlZF9rZXkgfmhhbmRsZV9yZW1vdmVkKTtcbiAgICAgICAgc2xvdCA6PSBMZXZlbC5uZXh0X3Nsb3QgbGV2ZWwgIXNsb3Q7XG4gICAgICAgIGxldmVsX21pbl9hbGxvd2VkX2tleSA6PSBLZXkuYWRkX2NsYW1wX3RvX21heCAhbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGtleXNfcGVyX3Nsb3QpXG4gICAgZG9uZTtcbiAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXkgPC0gZGVzaXJlZF9taW5fYWxsb3dlZF9rZXk7XG4gICAgbGV2ZWwubWF4X2FsbG93ZWRfa2V5XG4gICAgPC0gS2V5LmFkZF9jbGFtcF90b19tYXggZGVzaXJlZF9taW5fYWxsb3dlZF9rZXkgbGV2ZWwuZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gIDs7XG5cbiAgbW9kdWxlIEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2VcbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWRcbiAgZW5kXG5cbiAgbGV0IGluY3JlYXNlX21pbl9hbGxvd2VkX2tleSB0IH5rZXkgfmhhbmRsZV9yZW1vdmVkIDogSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdC50ID1cbiAgICBpZiBLZXkuKCA8PSApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpXG4gICAgdGhlbiBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2VcbiAgICBlbHNlIChcbiAgICAgICgqIFdlIGluY3JlYXNlIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiBsZXZlbHMgaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGUgaW52YXJpYW50XG4gICAgICAgICB0aGF0IHRoZXkgaGF2ZSBhcyBsYXJnZSBhcyBwb3NzaWJsZSBhIFttaW5fYWxsb3dlZF9rZXldLCB3aGlsZSBsZWF2aW5nIG5vIGdhcHNcbiAgICAgICAgIGluIGtleXMuICopXG4gICAgICBsZXQgbGV2ZWxfaW5kZXggPSByZWYgMCBpblxuICAgICAgbGV0IHJlc3VsdCA9IHJlZiBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0Lk1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkIGluXG4gICAgICBsZXQgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgPSByZWYgKEtleS5wcmVkIGtleSkgaW5cbiAgICAgIGxldCBsZXZlbHMgPSB0LmxldmVscyBpblxuICAgICAgbGV0IG51bV9sZXZlbHMgPSBudW1fbGV2ZWxzIHQgaW5cbiAgICAgIHdoaWxlICFsZXZlbF9pbmRleCA8IG51bV9sZXZlbHMgZG9cbiAgICAgICAgbGV0IGxldmVsID0gbGV2ZWxzLighbGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGxldCBtaW5fYWxsb3dlZF9rZXlfYmVmb3JlID0gbGV2ZWwubWluX2FsbG93ZWRfa2V5IGluXG4gICAgICAgIGluY3JlYXNlX2xldmVsX21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgIHRcbiAgICAgICAgICBsZXZlbFxuICAgICAgICAgIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleTohcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgICB+dF9taW5fYWxsb3dlZF9rZXk6a2V5XG4gICAgICAgICAgfmhhbmRsZV9yZW1vdmVkO1xuICAgICAgICBpZiBLZXkuZXF1YWwgKExldmVsLm1pbl9hbGxvd2VkX2tleSBsZXZlbCkgbWluX2FsbG93ZWRfa2V5X2JlZm9yZVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBUaGlzIGxldmVsIGRpZCBub3Qgc2hpZnQuICBEb24ndCBzaGlmdCBhbnkgaGlnaGVyIGxldmVscy4gKilcbiAgICAgICAgICBsZXZlbF9pbmRleCA6PSBudW1fbGV2ZWxzO1xuICAgICAgICAgIHJlc3VsdCA6PSBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2UpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIExldmVsIFtsZXZlbF9pbmRleF0gc2hpZnRlZC4gIENvbnNpZGVyIHNoaWZ0aW5nIGhpZ2hlciBsZXZlbHMuICopXG4gICAgICAgICAgbGV2ZWxfaW5kZXggOj0gIWxldmVsX2luZGV4ICsgMTtcbiAgICAgICAgICBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSA6PSBMZXZlbC5tYXhfYWxsb3dlZF9rZXkgbGV2ZWwpXG4gICAgICBkb25lO1xuICAgICAgaWYgS2V5LiggPiApIGtleSB0LmVsdF9rZXlfbG93ZXJfYm91bmRcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBXZSBoYXZlIHJlbW92ZWQgW3QubWluX2VsdF0gb3IgaXQgd2FzIGFscmVhZHkgbnVsbCwgc28ganVzdCBzZXQgaXQgdG9cbiAgICAgICAgICAgbnVsbC4gKilcbiAgICAgICAgdC5taW5fZWx0IDwtIEludGVybmFsX2VsdC5udWxsICgpO1xuICAgICAgICB0LmVsdF9rZXlfbG93ZXJfYm91bmQgPC0gbWluX2FsbG93ZWRfa2V5IHQpO1xuICAgICAgIXJlc3VsdClcbiAgOztcblxuICBsZXQgY3JlYXRlID9jYXBhY2l0eSA/bGV2ZWxfYml0cyAoKSA9XG4gICAgbGV0IGxldmVsX2JpdHMgPVxuICAgICAgbWF0Y2ggbGV2ZWxfYml0cyB3aXRoXG4gICAgICB8IFNvbWUgbCAtPiBsXG4gICAgICB8IE5vbmUgLT4gTGV2ZWxfYml0cy5kZWZhdWx0XG4gICAgaW5cbiAgICBsZXQgXywgXywgbGV2ZWxzID1cbiAgICAgIExpc3QuZm9sZGlcbiAgICAgICAgbGV2ZWxfYml0c1xuICAgICAgICB+aW5pdDooTnVtX2tleV9iaXRzLnplcm8sIEtleS56ZXJvLCBbXSlcbiAgICAgICAgfmY6XG4gICAgICAgICAgKGZ1blxuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIChiaXRzX3Blcl9zbG90LCBtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5LCBsZXZlbHMpXG4gICAgICAgICAgICAobGV2ZWxfYml0cyA6IE51bV9rZXlfYml0cy50KVxuICAgICAgICAgICAgLT5cbiAgICAgICAgICAgICAgbGV0IGtleXNfcGVyX3Nsb3QgPSBLZXkubnVtX2tleXMgYml0c19wZXJfc2xvdCBpblxuICAgICAgICAgICAgICBsZXQgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgICAgICAgICAgICBjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleSB+bGV2ZWxfYml0cyB+Yml0c19wZXJfc2xvdFxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9IE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2suY3JlYXRlIH5iaXRzX3Blcl9zbG90IGluXG4gICAgICAgICAgICAgIGxldCBtaW5fYWxsb3dlZF9rZXkgPVxuICAgICAgICAgICAgICAgIEtleS5taW5fa2V5X2luX3NhbWVfc2xvdCBtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IG1heF9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgICAgICAgS2V5LmFkZF9jbGFtcF90b19tYXggbWluX2FsbG93ZWRfa2V5IGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgbGV2ZWwgPVxuICAgICAgICAgICAgICAgIHsgTGV2ZWwuaW5kZXhcbiAgICAgICAgICAgICAgICA7IGJpdHMgPSBsZXZlbF9iaXRzXG4gICAgICAgICAgICAgICAgOyBzbG90c19tYXNrID0gU2xvdHNfbWFzay5jcmVhdGUgfmxldmVsX2JpdHNcbiAgICAgICAgICAgICAgICA7IGJpdHNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICA7IGtleXNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICA7IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgICA7IGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgIDsgbGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgIDsgbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgOyBtYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICA7IHNsb3RzID1cbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgICAgfmxlbjooSW50NjMudG9faW50X2V4biAoTnVtX2tleV9iaXRzLnBvdzIgbGV2ZWxfYml0cykpXG4gICAgICAgICAgICAgICAgICAgICAgKEludGVybmFsX2VsdC5udWxsICgpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCBOdW1fa2V5X2JpdHMuKCArICkgbGV2ZWxfYml0cyBiaXRzX3Blcl9zbG90XG4gICAgICAgICAgICAgICwgS2V5LnN1Y2NfY2xhbXBfdG9fbWF4IG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAsIGxldmVsIDo6IGxldmVscyApKVxuICAgIGluXG4gICAgeyBsZW5ndGggPSAwXG4gICAgOyBwb29sID0gSW50ZXJuYWxfZWx0LlBvb2wuY3JlYXRlID9jYXBhY2l0eSAoKVxuICAgIDsgbWluX2VsdCA9IEludGVybmFsX2VsdC5udWxsICgpXG4gICAgOyBlbHRfa2V5X2xvd2VyX2JvdW5kID0gS2V5Lnplcm9cbiAgICA7IGxldmVscyA9IEFycmF5Lm9mX2xpc3RfcmV2IGxldmVsc1xuICAgIH1cbiAgOztcblxuICBsZXQgbWVtIHQgZWx0ID0gSW50ZXJuYWxfZWx0LmV4dGVybmFsX2lzX3ZhbGlkIHQucG9vbCBlbHRcblxuICBsZXQgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGlmIEludGVybmFsX2VsdC5lcXVhbCBlbHQgdC5taW5fZWx0XG4gICAgdGhlblxuICAgICAgdC5taW5fZWx0IDwtIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgKCogV2Uga2VlcCBbdC5lbHRfbG93ZXJfYm91bmRdIHNpbmNlIGl0IGlzIHZhbGlkIGV2ZW4gdGhvdWdoIFt0Lm1pbl9lbHRdIGlzIGJlaW5nXG4gICAgICAgcmVtb3ZlZC4gKik7XG4gICAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLihJbnRlcm5hbF9lbHQubGV2ZWxfaW5kZXggcG9vbCBlbHQpIGluXG4gICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCAtIDE7XG4gICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICBsZXQgc2xvdCA9IExldmVsLnNsb3QgbGV2ZWwgfmtleTooSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCkgaW5cbiAgICBsZXQgZmlyc3QgPSBzbG90cy4oc2xvdCkgaW5cbiAgICBpZiBwaHlzX2VxdWFsIGVsdCAoSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCBlbHQpXG4gICAgdGhlbiAoKiBbZWx0XSBpcyB0aGUgb25seSBlbGVtZW50IGluIHRoZSBzbG90ICopXG4gICAgICBzbG90cy4oc2xvdCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICBlbHNlIChcbiAgICAgIGlmIHBoeXNfZXF1YWwgZWx0IGZpcnN0IHRoZW4gc2xvdHMuKHNsb3QpIDwtIEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0O1xuICAgICAgSW50ZXJuYWxfZWx0LnVubGluayBwb29sIGVsdClcbiAgOztcblxuICBsZXQgcmVtb3ZlIHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHBvb2wgZWx0IGluXG4gICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgZWx0XG4gIDs7XG5cbiAgbGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkIH5rZXkgfm5vdyA9XG4gICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKDApIGluXG4gICAgaWYgbGV2ZWwubGVuZ3RoID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXkgaW5cbiAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IGZpcnN0ID0gcmVmIHNsb3RzLihzbG90KSBpblxuICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCAhZmlyc3QpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGN1cnJlbnQgPSByZWYgIWZpcnN0IGluXG4gICAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAgIGxldCBlbHQgPSAhY3VycmVudCBpblxuICAgICAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCBlbHQgaW5cbiAgICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgIWZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHQ7XG4gICAgICAgICAgaWYgVGltZV9ucy4oIDw9ICkgKEludGVybmFsX2VsdC5hdCBwb29sIGVsdCkgbm93XG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBoYW5kbGVfZmlyZWQgKEludGVybmFsX2VsdC50b19leHRlcm5hbCBlbHQpO1xuICAgICAgICAgICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgICAgICAgICAgSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCBlbHQ7XG4gICAgICAgICAgICAoKiBXZSByZWNvbXB1dGUgW2ZpcnN0XSBiZWNhdXNlIFtpbnRlcm5hbF9yZW1vdmVdIG1heSBoYXZlIGNoYW5nZWQgaXQuICopXG4gICAgICAgICAgICBmaXJzdCA6PSBzbG90cy4oc2xvdCkpXG4gICAgICAgIGRvbmUpKVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgdCBlbHQgfmtleSB+YXQgPVxuICAgIGVuc3VyZV92YWxpZF9rZXkgdCB+a2V5O1xuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGVsdCA9IEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcG9vbCBlbHQgaW5cbiAgICBpbnRlcm5hbF9yZW1vdmUgdCBlbHQ7XG4gICAgSW50ZXJuYWxfZWx0LnNldF9rZXkgcG9vbCBlbHQga2V5O1xuICAgIEludGVybmFsX2VsdC5zZXRfYXQgcG9vbCBlbHQgYXQ7XG4gICAgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdFxuICA7O1xuXG4gIGxldCBjbGVhciB0ID1cbiAgICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gICAgdGhlbiAoXG4gICAgICB0Lmxlbmd0aCA8LSAwO1xuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBmcmVlX2VsdCBlbHQgPSBJbnRlcm5hbF9lbHQuZnJlZSBwb29sIGVsdCBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBmb3IgbGV2ZWxfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBsZXZlbHMgLSAxIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV2ZWwubGVuZ3RoIDwtIDA7XG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBmb3Igc2xvdF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIHNsb3RzIC0gMSBkb1xuICAgICAgICAgICAgbGV0IGVsdCA9IHNsb3RzLihzbG90X2luZGV4KSBpblxuICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpXG4gICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmY6ZnJlZV9lbHQ7XG4gICAgICAgICAgICAgIHNsb3RzLihzbG90X2luZGV4KSA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKSlcbiAgICAgICAgICBkb25lKVxuICAgICAgZG9uZSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgSW50ZXJuYWxfZWx0ID0gUHJpb3JpdHlfcXVldWUuSW50ZXJuYWxfZWx0XG5tb2R1bGUgS2V5ID0gUHJpb3JpdHlfcXVldWUuS2V5XG5tb2R1bGUgSW50ZXJ2YWxfbnVtID0gS2V5XG5cbmxldCBtaW5faW50ZXJ2YWxfbnVtID0gSW50ZXJ2YWxfbnVtLnplcm9cblxuKCogQWxsIHRpbWUgZnJvbSB0aGUgZXBvY2ggb253YXJkcyBpcyBicm9rZW4gaW50byBoYWxmLW9wZW4gaW50ZXJ2YWxzIG9mIHNpemVcbiAgIFtDb25maWcuYWxhcm1fcHJlY2lzaW9uIGNvbmZpZ10uICBUaGUgaW50ZXJ2YWxzIGFyZSBudW1iZXJlZCBzdGFydGluZyBhdCB6ZXJvLCBhbmQgYVxuICAgdGltZSdzIGludGVydmFsIG51bWJlciBzZXJ2ZXMgYXMgaXRzIGtleSBpbiBbcHJpb3JpdHlfcXVldWVdLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBjb25maWcgOiBDb25maWcudFxuICA7IHN0YXJ0IDogVGltZV9ucy50XG4gIDsgKCogW21heF9pbnRlcnZhbF9udW1dIGlzIHRoZSBpbnRlcnZhbCBudW1iZXIgb2YgW21heF90aW1lXS4gKilcbiAgICBtYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnRcbiAgOyBtdXRhYmxlIG5vdyA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgbm93X2ludGVydmFsX251bV9zdGFydCA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA6IFRpbWVfbnMudFxuICA7IHByaW9yaXR5X3F1ZXVlIDogJ2EgUHJpb3JpdHlfcXVldWUudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbnR5cGUgJ2EgdGltaW5nX3doZWVsID0gJ2EgdFxudHlwZSAnYSB0X25vdyA9ICdhIHRcblxubGV0IHNleHBfb2ZfdF9ub3cgXyB0ID0gWyVzZXhwICh0Lm5vdyA6IFRpbWVfbnMudCldXG5sZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBDb25maWcuYWxhcm1fcHJlY2lzaW9uIHQuY29uZmlnXG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBQcmlvcml0eV9xdWV1ZS5FbHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBudWxsID0gUHJpb3JpdHlfcXVldWUuRWx0Lm51bGxcbiAgbGV0IGF0IHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQuYXQgdHcucHJpb3JpdHlfcXVldWUgdFxuICBsZXQgdmFsdWUgdHcgdCA9IFByaW9yaXR5X3F1ZXVlLkVsdC52YWx1ZSB0dy5wcmlvcml0eV9xdWV1ZSB0XG4gIGxldCBpbnRlcnZhbF9udW0gdHcgdCA9IFByaW9yaXR5X3F1ZXVlLkVsdC5rZXkgdHcucHJpb3JpdHlfcXVldWUgdFxuZW5kXG5cbmxldCBzZXhwX29mX3RfaW50ZXJuYWwgPSBzZXhwX29mX3RcbmxldCBpdGVyIHQgfmYgPSBQcmlvcml0eV9xdWV1ZS5pdGVyIHQucHJpb3JpdHlfcXVldWUgfmZcblxubW9kdWxlIFByZXR0eSA9IHN0cnVjdFxuICBtb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBhdCA6IFRpbWVfbnMudFxuICAgICAgOyB2YWx1ZSA6ICdhXG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gICAgbGV0IGNyZWF0ZSB0IGFsYXJtID0geyBhdCA9IEFsYXJtLmF0IHQgYWxhcm07IHZhbHVlID0gQWxhcm0udmFsdWUgdCBhbGFybSB9XG4gICAgbGV0IGNvbXBhcmUgdDEgdDIgPSBUaW1lX25zLmNvbXBhcmUgKGF0IHQxKSAoYXQgdDIpXG4gIGVuZFxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBjb25maWcgOiBDb25maWcudFxuICAgIDsgc3RhcnQgOiBUaW1lX25zLnRcbiAgICA7IG1heF9pbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udFxuICAgIDsgbm93IDogVGltZV9ucy50XG4gICAgOyBhbGFybXMgOiAnYSBBbGFybS50IGxpc3RcbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IHByZXR0eVxuICAgICAgKHsgY29uZmlnXG4gICAgICAgOyBzdGFydFxuICAgICAgIDsgbWF4X2ludGVydmFsX251bVxuICAgICAgIDsgbm93XG4gICAgICAgOyBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0ID0gX1xuICAgICAgIDsgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA9IF9cbiAgICAgICA7IHByaW9yaXR5X3F1ZXVlID0gX1xuICAgICAgIH0gYXMgdClcbiAgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IHIgOj0gUHJldHR5LkFsYXJtLmNyZWF0ZSB0IGEgOjogIXIpO1xuICBsZXQgYWxhcm1zID0gTGlzdC5zb3J0ICFyIH5jb21wYXJlOlByZXR0eS5BbGFybS5jb21wYXJlIGluXG4gIHsgUHJldHR5LmNvbmZpZzsgc3RhcnQ7IG1heF9pbnRlcnZhbF9udW07IG5vdzsgYWxhcm1zIH1cbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICBtYXRjaCAhc2V4cF9vZl90X3N0eWxlIHdpdGhcbiAgfCBgSW50ZXJuYWwgLT4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2ZfYSB0XG4gIHwgYFByZXR0eSAtPiBbJXNleHAgKHByZXR0eSB0IDogYSBQcmV0dHkudCldXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSBQcmlvcml0eV9xdWV1ZS5sZW5ndGggdC5wcmlvcml0eV9xdWV1ZVxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0W0Bjb2xkXSByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4bl9vZl9lbXB0eV90aW1pbmdfd2hlZWwgdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X3dpdGhfYWxsX2FsYXJtc19pbl9tYXhfaW50ZXJ2YWwgdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHdpdGggYWxsIGFsYXJtcyBpbiBtYXggaW50ZXJ2YWxcIlxuICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbjs7XG5cbmxldCBwb29sIHQgPSBQcmlvcml0eV9xdWV1ZS5wb29sIHQucHJpb3JpdHlfcXVldWVcblxubGV0IGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZSB+YWxhcm1fcHJlY2lzaW9uID1cbiAgSW50ZXJ2YWxfbnVtLm9mX2ludDYzIChBbGFybV9wcmVjaXNpb24uaW50ZXJ2YWxfbnVtIGFsYXJtX3ByZWNpc2lvbiB0aW1lKVxuOztcblxubGV0IGludGVydmFsX251bV91bmNoZWNrZWQgdCB0aW1lID1cbiAgaW50ZXJ2YWxfbnVtX2ludGVybmFsIH50aW1lIH5hbGFybV9wcmVjaXNpb246dC5jb25maWcuYWxhcm1fcHJlY2lzaW9uXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtIHQgdGltZSA9XG4gIGlmIFRpbWVfbnMuKCA8ICkgdGltZSBtaW5fdGltZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bSBnb3QgdGltZSB0b28gZmFyIGluIHRoZSBwYXN0XCIgKHRpbWUgOiBUaW1lX25zLnQpXTtcbiAgaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IHRpbWVcbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgaW50ZXJ2YWxfbnVtID1cbiAgQWxhcm1fcHJlY2lzaW9uLmludGVydmFsX251bV9zdGFydFxuICAgIHQuY29uZmlnLmFsYXJtX3ByZWNpc2lvblxuICAgIChpbnRlcnZhbF9udW0gfD4gSW50ZXJ2YWxfbnVtLnRvX2ludDYzKVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19zbWFsbCBpbnRlcnZhbF9udW0gPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5pbnRlcnZhbF9udW1fc3RhcnQgZ290IHRvbyBzbWFsbCBpbnRlcnZhbF9udW1cIlxuICAgICAgICAoaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXG4gICAgICAgIChtaW5faW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19sYXJnZSB0IGludGVydmFsX251bSA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bV9zdGFydCBnb3QgdG9vIGxhcmdlIGludGVydmFsX251bVwiXG4gICAgICAgIChpbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udClcbiAgICAgICAgKHQubWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50KV1cbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fc3RhcnQgdCBpbnRlcnZhbF9udW0gPVxuICBpZiBJbnRlcnZhbF9udW0uKCA8ICkgaW50ZXJ2YWxfbnVtIG1pbl9pbnRlcnZhbF9udW1cbiAgdGhlbiByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19zbWFsbCBpbnRlcnZhbF9udW07XG4gIGlmIEludGVydmFsX251bS4oID4gKSBpbnRlcnZhbF9udW0gdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fbGFyZ2UgdCBpbnRlcnZhbF9udW07XG4gIGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBpbnRlcnZhbF9udW1cbjs7XG5cbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIHQga2V5ID1cbiAgKCogW2ludGVydmFsX251bV9zdGFydCB0IGtleV0gaXMgdGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGFydCBvZiB0aGUgdGltZSBpbnRlcnZhbFxuICAgICBob2xkaW5nIHRoZSBmaXJzdCBhbGFybSBpbiBbdF0uICBBZHZhbmNpbmcgdG8gdGhhdCB3b3VsZCBub3QgYmUgZW5vdWdoLCBzaW5jZSB0aGVcbiAgICAgYWxhcm1zIGluIHRoYXQgaW50ZXJ2YWwgZG9uJ3QgZmlyZSB1bnRpbCB0aGUgY2xvY2sgaXMgYWR2YW5jZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICBuZXh0IGludGVydmFsLiAgU28sIHdlIHVzZSBbc3VjYyBrZXldIHRvIGFkdmFuY2UgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgIGludGVydmFsLiAqKVxuICBpbnRlcnZhbF9udW1fc3RhcnQgdCAoS2V5LnN1Y2Mga2V5KVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXQgdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0IGluXG4gICAgaWYgSW50ZXJ2YWxfbnVtLmVxdWFsIGtleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIFNvbWUgKG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXkpKVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4bl9vZl9lbXB0eV90aW1pbmdfd2hlZWwgdDtcbiAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0IGluXG4gIGlmIEludGVydmFsX251bS5lcXVhbCBrZXkgdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF93aXRoX2FsbF9hbGFybXNfaW5fbWF4X2ludGVydmFsIHQ7XG4gIG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXlcbjs7XG5cbmxldCBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCA9XG4gIGxldCBtYXhfYWxsb3dlZF9rZXkgPSBQcmlvcml0eV9xdWV1ZS5tYXhfYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcnZhbF9udW0uKCA+PSApIG1heF9hbGxvd2VkX2tleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgdGhlbiBtYXhfdGltZVxuICBlbHNlXG4gICAgVGltZV9ucy5hZGRcbiAgICAgIChpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgbWF4X2FsbG93ZWRfa2V5KVxuICAgICAgKFRpbWVfbnMuU3Bhbi4oIC0gKSAoYWxhcm1fcHJlY2lzaW9uIHQpIFRpbWVfbnMuU3Bhbi5uYW5vc2Vjb25kKVxuOztcblxubGV0IG5vd19pbnRlcnZhbF9udW0gdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9hbGxvd2VkX2tleSB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgbWluX2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtID0gbm93X2ludGVydmFsX251bVxubGV0IG1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSB0ID0gaW50ZXJ2YWxfbnVtIHQgKG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdClcbmxldCBpbnRlcnZhbF9zdGFydCB0IHRpbWUgPSBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgKGludGVydmFsX251bSB0IHRpbWUpXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5jb25maWc6KGNoZWNrIENvbmZpZy5pbnZhcmlhbnQpXG4gICAgICB+c3RhcnQ6XG4gICAgICAgIChjaGVjayAoZnVuIHN0YXJ0IC0+XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oID49ICkgc3RhcnQgbWluX3RpbWUpO1xuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIHN0YXJ0IG1heF90aW1lKSkpXG4gICAgICB+bWF4X2ludGVydmFsX251bTpcbiAgICAgICAgKGNoZWNrIChmdW4gbWF4X2ludGVydmFsX251bSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBJbnRlcnZhbF9udW0udF1cbiAgICAgICAgICAgICB+ZXhwZWN0Om1heF9pbnRlcnZhbF9udW1cbiAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgbWF4X3RpbWUpO1xuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBJbnRlcnZhbF9udW0udF1cbiAgICAgICAgICAgICB+ZXhwZWN0Om1heF9pbnRlcnZhbF9udW1cbiAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgKGludGVydmFsX251bV9zdGFydCB0IG1heF9pbnRlcnZhbF9udW0pKSkpXG4gICAgICB+bm93OlxuICAgICAgICAoY2hlY2sgKGZ1biBub3cgLT5cbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPj0gKSBub3cgdC5zdGFydCk7XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oIDw9ICkgbm93IG1heF90aW1lKTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBJbnRlcnZhbF9udW0uZXF1YWxcbiAgICAgICAgICAgICAgIChpbnRlcnZhbF9udW0gdCB0Lm5vdylcbiAgICAgICAgICAgICAgIChQcmlvcml0eV9xdWV1ZS5taW5fYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZSkpKSlcbiAgICAgIH5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0OlxuICAgICAgICAoY2hlY2sgKGZ1biBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFRpbWVfbnMudF1cbiAgICAgICAgICAgICBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0XG4gICAgICAgICAgICAgfmV4cGVjdDooaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgKG5vd19pbnRlcnZhbF9udW0gdCkpKSlcbiAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV90aW1lOlxuICAgICAgICAoY2hlY2sgKGZ1biBtYXhfYWxsb3dlZF9hbGFybV90aW1lIC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFRpbWVfbnMudF1cbiAgICAgICAgICAgICBtYXhfYWxsb3dlZF9hbGFybV90aW1lXG4gICAgICAgICAgICAgfmV4cGVjdDooY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpKSlcbiAgICAgIH5wcmlvcml0eV9xdWV1ZTooY2hlY2sgKFByaW9yaXR5X3F1ZXVlLmludmFyaWFudCBpbnZhcmlhbnRfYSkpO1xuICAgIGl0ZXIgdCB+ZjooZnVuIGFsYXJtIC0+XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBJbnRlcnZhbF9udW0uZXF1YWxcbiAgICAgICAgICAoQWxhcm0uaW50ZXJ2YWxfbnVtIHQgYWxhcm0pXG4gICAgICAgICAgKGludGVydmFsX251bSB0IChBbGFybS5hdCB0IGFsYXJtKSkpO1xuICAgICAgYXNzZXJ0IChcbiAgICAgICAgVGltZV9ucy4oID49ICkgKGludGVydmFsX3N0YXJ0IHQgKEFsYXJtLmF0IHQgYWxhcm0pKSAoaW50ZXJ2YWxfc3RhcnQgdCAobm93IHQpKSk7XG4gICAgICBhc3NlcnQgKFRpbWVfbnMuKCA+ICkgKEFsYXJtLmF0IHQgYWxhcm0pIChUaW1lX25zLnN1YiAobm93IHQpIChhbGFybV9wcmVjaXNpb24gdCkpKSkpXG47O1xuXG5sZXQgZGVidWcgPSBmYWxzZVxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH50b18gfmhhbmRsZV9maXJlZCA9XG4gIGlmIFRpbWVfbnMuKCA+ICkgdG9fIChub3cgdClcbiAgdGhlbiAoXG4gICAgdC5ub3cgPC0gdG9fO1xuICAgIGxldCBrZXkgPSBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdG9fIGluXG4gICAgdC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IDwtIGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBrZXk7XG4gICAgbWF0Y2hcbiAgICAgIFByaW9yaXR5X3F1ZXVlLmluY3JlYXNlX21pbl9hbGxvd2VkX2tleVxuICAgICAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgICAgIH5rZXlcbiAgICAgICAgfmhhbmRsZV9yZW1vdmVkOmhhbmRsZV9maXJlZFxuICAgIHdpdGhcbiAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZSAtPlxuICAgICAgaWYgZGVidWdcbiAgICAgIHRoZW5cbiAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPSApIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSAoY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpKVxuICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWQgLT5cbiAgICAgIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdClcbjs7XG5cbmxldCBjcmVhdGUgfmNvbmZpZyB+c3RhcnQgPVxuICBpZiBUaW1lX25zLiggPCApIHN0YXJ0IFRpbWVfbnMuZXBvY2hcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIlRpbWluZ193aGVlbC5jcmVhdGUgZ290IHN0YXJ0IGJlZm9yZSB0aGUgZXBvY2hcIiAoc3RhcnQgOiBUaW1lX25zLnQpXTtcbiAgbGV0IHQgPVxuICAgIHsgY29uZmlnXG4gICAgOyBzdGFydFxuICAgIDsgbWF4X2ludGVydmFsX251bSA9XG4gICAgICAgIGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZTptYXhfdGltZSB+YWxhcm1fcHJlY2lzaW9uOmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbiAgICA7IG5vdyA9IFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbm93X2ludGVydmFsX251bV9zdGFydCA9XG4gICAgICAgIFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA9IG1heF90aW1lICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IHByaW9yaXR5X3F1ZXVlID1cbiAgICAgICAgUHJpb3JpdHlfcXVldWUuY3JlYXRlID9jYXBhY2l0eTpjb25maWcuY2FwYWNpdHkgfmxldmVsX2JpdHM6Y29uZmlnLmxldmVsX2JpdHMgKClcbiAgICB9XG4gIGluXG4gIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdDtcbiAgYWR2YW5jZV9jbG9jayB0IH50b186c3RhcnQgfmhhbmRsZV9maXJlZDooZnVuIF8gLT4gYXNzZXJ0IGZhbHNlKTtcbiAgdFxuOztcblxubGV0IGFkZF9hdF9pbnRlcnZhbF9udW0gdCB+YXQgdmFsdWUgPVxuICBJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWxcbiAgICAoUHJpb3JpdHlfcXVldWUuaW50ZXJuYWxfYWRkXG4gICAgICAgdC5wcmlvcml0eV9xdWV1ZVxuICAgICAgIH5rZXk6YXRcbiAgICAgICB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuICAgICAgIHZhbHVlKVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV90aGF0X2Zhcl9pbl90aGVfZnV0dXJlIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gdGhhdCBmYXIgaW4gdGhlIGZ1dHVyZVwiXG4gICAgICAgIChhdCA6IFRpbWVfbnMudClcbiAgICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX3RpbWU6KHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA6IFRpbWVfbnMudCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2JlZm9yZV9zdGFydF9vZl9jdXJyZW50X2ludGVydmFsIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gYmVmb3JlIHN0YXJ0IG9mIGN1cnJlbnQgaW50ZXJ2YWxcIlxuICAgICAgICAoYXQgOiBUaW1lX25zLnQpXG4gICAgICAgIH5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Oih0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnQgOiBUaW1lX25zLnQpXVxuOztcblxubGV0IGVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0gdCB+YXQgPVxuICBpZiBUaW1lX25zLiggPiApIGF0IHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0aGVuIHJhaXNlX3RoYXRfZmFyX2luX3RoZV9mdXR1cmUgdCBhdDtcbiAgaWYgVGltZV9ucy4oIDwgKSBhdCB0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnRcbiAgdGhlbiByYWlzZV9iZWZvcmVfc3RhcnRfb2ZfY3VycmVudF9pbnRlcnZhbCB0IGF0XG47O1xuXG5sZXQgYWRkIHQgfmF0IHZhbHVlID1cbiAgZW5zdXJlX2Nhbl9zY2hlZHVsZV9hbGFybSB0IH5hdDtcbiAgSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsXG4gICAgKFByaW9yaXR5X3F1ZXVlLmludGVybmFsX2FkZFxuICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICB+a2V5OihpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgYXQpXG4gICAgICAgfmF0XG4gICAgICAgdmFsdWUpXG47O1xuXG5sZXQgcmVtb3ZlIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5yZW1vdmUgdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxubGV0IGNsZWFyIHQgPSBQcmlvcml0eV9xdWV1ZS5jbGVhciB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgbWVtIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5tZW0gdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxuXG5sZXQgcmVzY2hlZHVsZV9nZW4gdCBhbGFybSB+a2V5IH5hdCA9XG4gIGlmIG5vdCAobWVtIHQgYWxhcm0pXG4gIHRoZW4gZmFpbHdpdGggXCJUaW1pbmdfd2hlZWwgY2Fubm90IHJlc2NoZWR1bGUgYWxhcm0gbm90IGluIHRpbWluZyB3aGVlbFwiO1xuICBlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIHQgfmF0O1xuICBQcmlvcml0eV9xdWV1ZS5jaGFuZ2UgdC5wcmlvcml0eV9xdWV1ZSBhbGFybSB+a2V5IH5hdFxuOztcblxubGV0IHJlc2NoZWR1bGUgdCBhbGFybSB+YXQgPSByZXNjaGVkdWxlX2dlbiB0IGFsYXJtIH5rZXk6KGludGVydmFsX251bV91bmNoZWNrZWQgdCBhdCkgfmF0XG5cbmxldCByZXNjaGVkdWxlX2F0X2ludGVydmFsX251bSB0IGFsYXJtIH5hdCA9XG4gIHJlc2NoZWR1bGVfZ2VuIHQgYWxhcm0gfmtleTphdCB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuOztcblxubGV0IG1pbl9hbGFybV9pbnRlcnZhbF9udW0gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIE5vbmUgZWxzZSBTb21lIChJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdClcbjs7XG5cbmxldCBtaW5fYWxhcm1faW50ZXJ2YWxfbnVtX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWluX2FsYXJtX2ludGVydmFsX251bV9leG4gb2YgZW1wdHkgdGltaW5nX3doZWVsXCJcbiAgICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbiAgZWxzZSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdFxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWF4X2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWluX2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQpXG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiBOb25lIGVsc2UgU29tZSAobWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdClcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiXG4gICAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldO1xuICBtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0XG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIlxuICAgICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXTtcbiAgbWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdFxuOztcblxubGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkID1cbiAgUHJpb3JpdHlfcXVldWUuZmlyZV9wYXN0X2FsYXJtc1xuICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICB+aGFuZGxlX2ZpcmVkXG4gICAgfmtleToobm93X2ludGVydmFsX251bSB0KVxuICAgIH5ub3c6dC5ub3dcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBOdW1fa2V5X2JpdHMgPSBOdW1fa2V5X2JpdHNcblxuICBsZXQgaW50ZXJ2YWxfbnVtX2ludGVybmFsID0gaW50ZXJ2YWxfbnVtX2ludGVybmFsXG4gIGxldCBtYXhfdGltZSA9IG1heF90aW1lXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fV19
