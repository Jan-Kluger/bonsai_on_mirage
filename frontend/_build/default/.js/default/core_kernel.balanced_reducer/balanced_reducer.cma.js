// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Balanced_reducer
//# unitInfo: Requires: Base, Base__Int, Base__List, Base__Option_array, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Balanced_reducer = "Balanced_reducer",
    cst_balanced_reducer = "balanced_reducer",
    cst_balanced_reducer_src_balan =
      "balanced_reducer/src/balanced_reducer.ml",
    cst_index = "index",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Option_array = global_data.Base__Option_array,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base = global_data.Base,
    Base_Int = global_data.Base__Int,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Balanced_reducer);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_balanced_reducer);
   caml_call1(Expect_test_collector[6][1], cst_balanced_reducer_src_balan);
   caml_call2
    (Ppx_inline_test_lib[5], cst_balanced_reducer, "balanced_reducer.ml");
   var
    _a_ = [0, cst_balanced_reducer_src_balan, 76, 9],
    _b_ = [0, cst_balanced_reducer_src_balan, 78, 6],
    _c_ = [0, "num_leaves"],
    cst_non_positive_number_of_lea =
      "non-positive number of leaves in balanced reducer",
    _d_ = [0, "_"],
    _e_ = [0, cst_index],
    cst_attempt_to_access_negative =
      "attempt to access negative index in balanced reducer",
    _f_ = [0, "length"],
    _g_ = [0, cst_index],
    cst_attempt_to_access_out_of_b =
      "attempt to access out of bounds index in balanced reducer",
    _i_ = [0, cst_balanced_reducer],
    cst_attempt_to_compute_balance =
      "attempt to compute balanced reducer with unset elements";
   function left_child_index(parent_index){return (parent_index * 2 | 0) + 1 | 0;
   }
   function num_branches(t){return t[2] - 1 | 0;}
   function index_is_leaf(t, i){return num_branches(t) <= i ? 1 : 0;}
   function leaf_index(t, i){
    var
     offset_from_start_of_leaves_in = i + t[3] | 0,
     rotated_index =
       offset_from_start_of_leaves_in < t[2]
        ? offset_from_start_of_leaves_in
        : offset_from_start_of_leaves_in - t[2] | 0;
    return rotated_index + num_branches(t) | 0;
   }
   function sexp_of_t(sexp_of_a, t){
    var
     x_001 =
       caml_call2
        (Base_List[40],
         t[2],
         function(i){
          var _D_ = leaf_index(t, i);
          return caml_call2(Base_Option_array[34], t[1], _D_);
         }),
     _C_ = caml_call1(Base[163], sexp_of_a);
    return caml_call2(Base[148], _C_, x_001);
   }
   function invariant(invariant_a, t){
    var
     data = t[1],
     _x_ = caml_call1(Base_Option_array[28], data) - 1 | 0,
     _w_ = 0;
    if(_x_ >= 0){
     var i$0 = _w_;
     for(;;){
      var match = caml_call2(Base_Option_array[34], data, i$0);
      if(match){var a = match[1]; caml_call1(invariant_a, a);}
      var _B_ = i$0 + 1 | 0;
      if(_x_ === i$0) break;
      i$0 = _B_;
     }
    }
    var _z_ = num_branches(t) - 1 | 0, _y_ = 0;
    if(_z_ >= 0){
     var i = _y_;
     for(;;){
      var
       left_child_index$0 = left_child_index(i),
       right = left_child_index$0 + 1 | 0,
       left_is_none =
         caml_call2(Base_Option_array[36], data, left_child_index$0),
       right_is_none = caml_call2(Base_Option_array[36], data, right);
      a:
      {
       if(caml_call2(Base_Option_array[37], data, i)){
        if(! left_is_none && ! right_is_none) break a;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
       }
       if
        (!
         index_is_leaf(t, left_child_index$0)
         && ! index_is_leaf(t, right) && ! left_is_none && ! right_is_none)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      var _A_ = i + 1 | 0;
      if(_z_ === i) break;
      i = _A_;
     }
    }
    return 0;
   }
   function create_exn(opt, param, num_leaves, reduce){
    var sexp_of_a = opt ? opt[1] : function(param){return _d_;};
    if(num_leaves < 1){
     var
      _u_ = [0, [1, [0, _c_, [0, caml_call1(Base[125], num_leaves), 0]]], 0],
      _v_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_non_positive_number_of_lea),
          _u_]];
     caml_call1(Base[217], _v_);
    }
    var
     num_branches = num_leaves - 1 | 0,
     num_leaves_not_in_bottom_level =
       caml_call1(Base_Int[65], num_leaves) - num_leaves | 0,
     data = caml_call1(Base_Option_array[5], num_branches + num_leaves | 0);
    return [0,
            data,
            num_leaves,
            num_leaves_not_in_bottom_level,
            reduce,
            sexp_of_a];
   }
   function validate_index(t, i){
    if(i < 0){
     var
      _o_ = [0, [1, [0, _e_, [0, caml_call1(Base[125], i), 0]]], 0],
      _p_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_access_negative),
          _o_]];
     caml_call1(Base[217], _p_);
    }
    var length = t[2], _q_ = length <= i ? 1 : 0;
    if(! _q_) return _q_;
    var
     _r_ = [0, [1, [0, _f_, [0, caml_call1(Base[125], length), 0]]], 0],
     _s_ = [0, [1, [0, _g_, [0, caml_call1(Base[125], i), 0]]], _r_],
     _t_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_access_out_of_b),
         _s_]];
    return caml_call1(Base[217], _t_);
   }
   function set_exn(t, i, a){
    validate_index(t, i);
    var data = t[1], i$0 = [0, leaf_index(t, i)];
    caml_call3(Base_Option_array[43], data, i$0[1], a);
    for(;;){
     if(0 === i$0[1]) return 0;
     var child_index = i$0[1], parent = (child_index - 1 | 0) / 2 | 0;
     if(caml_call2(Base_Option_array[36], data, parent))
      i$0[1] = 0;
     else{caml_call2(Base_Option_array[51], data, parent); i$0[1] = parent;}
    }
   }
   function get_exn(t, i){
    validate_index(t, i);
    var _n_ = leaf_index(t, i);
    return caml_call2(Base_Option_array[35], t[1], _n_);
   }
   function _h_(x_002, i){
    if(caml_call2(Base_Option_array[37], x_002[1], i))
     return caml_call2(Base_Option_array[39], x_002[1], i);
    var
     left_child_index$0 = left_child_index(i),
     right = left_child_index$0 + 1 | 0;
    if(caml_call1(Base_Option_array[28], x_002[1]) <= left_child_index$0){
     var
      sexp_of_a = x_002[5],
      _j_ = [0, [1, [0, _i_, [0, sexp_of_t(sexp_of_a, x_002), 0]]], 0],
      _k_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_compute_balance),
          _j_]];
     caml_call1(Base[217], _k_);
    }
    var
     _l_ = _h_(x_002, right),
     _m_ = _h_(x_002, left_child_index$0),
     a = caml_call2(x_002[4], _m_, _l_);
    caml_call3(Base_Option_array[50], x_002[1], i, a);
    return a;
   }
   function compute_exn(t){return _h_(t, 0);}
   caml_call1(Ppx_inline_test_lib[6], cst_balanced_reducer);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Balanced_reducer);
   var
    Balanced_reducer =
      [0, sexp_of_t, invariant, create_exn, set_exn, get_exn, compute_exn];
   runtime.caml_register_global(29, Balanced_reducer, cst_Balanced_reducer);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFsYW5jZWRfcmVkdWNlci5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFsYW5jZWRfcmVkdWNlci5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0JhbGFuY2VkX3JlZHVjZXIiLCJjc3RfYmFsYW5jZWRfcmVkdWNlciIsImNzdF9iYWxhbmNlZF9yZWR1Y2VyX3NyY19iYWxhbiIsImNzdF9pbmRleCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfT3B0aW9uX2FycmF5IiwiU2V4cGxpYjBfU2V4cF9jb252IiwiQmFzZSIsIkJhc2VfSW50IiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0xpc3QiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiY3N0X25vbl9wb3NpdGl2ZV9udW1iZXJfb2ZfbGVhIiwiY3N0X2F0dGVtcHRfdG9fYWNjZXNzX25lZ2F0aXZlIiwiY3N0X2F0dGVtcHRfdG9fYWNjZXNzX291dF9vZl9iIiwiY3N0X2F0dGVtcHRfdG9fY29tcHV0ZV9iYWxhbmNlIiwibGVmdF9jaGlsZF9pbmRleCIsInBhcmVudF9pbmRleCIsIm51bV9icmFuY2hlcyIsInQiLCJpbmRleF9pc19sZWFmIiwiaSIsImxlYWZfaW5kZXgiLCJvZmZzZXRfZnJvbV9zdGFydF9vZl9sZWF2ZXNfaW4iLCJyb3RhdGVkX2luZGV4Iiwic2V4cF9vZl90Iiwic2V4cF9vZl9hIiwieF8wMDEiLCJpbnZhcmlhbnQiLCJpbnZhcmlhbnRfYSIsImRhdGEiLCJtYXRjaCIsImEiLCJyaWdodCIsImxlZnRfaXNfbm9uZSIsInJpZ2h0X2lzX25vbmUiLCJjcmVhdGVfZXhuIiwib3B0IiwicGFyYW0iLCJudW1fbGVhdmVzIiwicmVkdWNlIiwibnVtX2xlYXZlc19ub3RfaW5fYm90dG9tX2xldmVsIiwidmFsaWRhdGVfaW5kZXgiLCJsZW5ndGgiLCJzZXRfZXhuIiwiY2hpbGRfaW5kZXgiLCJwYXJlbnQiLCJnZXRfZXhuIiwieF8wMDIiLCJjb21wdXRlX2V4biIsIkJhbGFuY2VkX3JlZHVjZXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvY29yZV9rZXJuZWwvYmFsYW5jZWRfcmVkdWNlci9iYWxhbmNlZF9yZWR1Y2VyLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLEdDQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FB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LElBQXVDO0FBQUEsR0FDckM7QUFBQSxZQUFBaUIsWUFBQTlCLEdBR2MsZ0JBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQStCO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUEsRURuSm5DIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5cbigqIFRoZSBbZGF0YV0gYXJyYXkgaXMgYW4gaW1wbGljaXQgYmluYXJ5IHRyZWUgd2l0aCBbY2hpbGRyZW5fbGVuZ3RoICogMiAtIDFdIG5vZGVzLFxuICAgd2l0aCBlYWNoIG5vZGUgYmVpbmcgdGhlIHN1bSBvZiB0aGUgdHdvIGNoaWxkIG5vZGVzIGFuZCB0aGUgcm9vdCBub2RlIGJlaW5nIHRoZSAwdGhcbiAgIG5vZGUuICBUaGUgbGVhdmVzIG9mIHRoZSB0cmVlIGFyZSB0aGUgbGFzdCBbbnVtX2xlYXZlc10gbm9kZXMuXG5cbiAgIFRoZSBjaGlsZHJlbiBhcmUgbm90IG5lY2Vzc2FyaWx5IGFsbCBhdCB0aGUgc2FtZSBsZXZlbCBvZiB0aGUgdHJlZS4gRm9yIGluc3RhbmNlIGlmXG4gICB5b3UgaGF2ZSAzIGNoaWxkcmVuIFt8IGE7IGI7IGMgfF06XG5cbiAgIHt2XG4gICAgICAgICAgb1xuICAgICAgICAgLyBcXFxuICAgICAgICBvICAgY1xuICAgICAgIC8gXFxcbiAgICAgIGEgICBiXG4gICB2fVxuXG4gICBXZSB3YW50IHRoaXMgdHJlZSB0byBiZSByZXByZXNlbnRhdGVkIGFzIFt8IG87IG87IGM7IGE7IGIgfF0sIGkuZS4gd2UgbmVlZCB0byBhcHBseVxuICAgZmlyc3QgYSByb3RhdGlvbiB0aGVuIGEgdHJhbnNsYXRpb24gdG8gY29udmVydCBhbiBpbmRleCBpbiBbfCBhOyBiOyBjIHxdIHRvIGEgKGxlYWYpXG4gICBpbmRleCBpbiBbfCBvOyBvOyBjOyBhOyBiIHxdLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBkYXRhIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgOyBudW1fbGVhdmVzIDogaW50XG4gIDsgbnVtX2xlYXZlc19ub3RfaW5fYm90dG9tX2xldmVsIDogaW50XG4gIDsgcmVkdWNlIDogJ2EgLT4gJ2EgLT4gJ2FcbiAgOyBzZXhwX29mX2EgOiAnYSAtPiBTZXhwLnRcbiAgfVxuXG5sZXQgbGVuZ3RoIHQgPSB0Lm51bV9sZWF2ZXNcblxuKCoge3ZcbiAgICAgcGFyZW50OiAgICAgIDAgIDEgIDIgIDMgIDQgIDUgIDYgIDcgIDggIDkgMTAgMTEgMTIgMTMgMTQgMTUgMTYgMTcgMTggMTkgLi4uXG4gICAgIGxlZnQgY2hpbGQ6ICAxICAzICA1ICA3ICA5IDExIDEzIDE1IDE3IDE5IDIxIDIzIDI1IDI3IDI5IDMxIDMzIDM1IDM3IDM5IC4uLlxuICAgICByaWdodCBjaGlsZDogMiAgNCAgNiAgOCAxMCAxMiAxNCAxNiAxOCAyMCAyMiAyNCAyNiAyOCAzMCAzMiAzNCAzNiAzOCA0MCAuLi4gdn0gKilcbmxldCBwYXJlbnRfaW5kZXggfmNoaWxkX2luZGV4ID0gKGNoaWxkX2luZGV4IC0gMSkgLyAyXG5sZXQgbGVmdF9jaGlsZF9pbmRleCB+cGFyZW50X2luZGV4ID0gKHBhcmVudF9pbmRleCAqIDIpICsgMVxubGV0IHJpZ2h0X2NoaWxkX2luZGV4IH5sZWZ0X2NoaWxkX2luZGV4ID0gbGVmdF9jaGlsZF9pbmRleCArIDFcblxuKCogVGhlIGZpcnN0IFtudW1fbGVhdmVzLTFdIGVsZW1lbnRzIGFyZSBpbnRlcm5hbCBub2RlcyBvZiB0aGUgdHJlZS4gIFRoZSBuZXh0XG4gICBbbnVtX2xlYXZlc10gZWxlbWVudHMgYXJlIHRoZSBsZWF2ZXMuICopXG5sZXQgbnVtX2JyYW5jaGVzIHQgPSB0Lm51bV9sZWF2ZXMgLSAxXG5sZXQgaW5kZXhfaXNfbGVhZiB0IGkgPSBpID49IG51bV9icmFuY2hlcyB0XG5cbigqIFRoZSB0cmVlIGlzIGNvbXBsZXRlLCBidXQgbm90IG5lY2Vzc2FyaWx5IHBlcmZlY3QsIHNvIHdlIHBlcmZvcm0gc29tZSByb3RhdGlvbiBvZiB0aGVcbiAgIGxlYXZlcyB0byBlbnN1cmUgdGhhdCBvdXIgcmVkdWN0aW9ucyBwcmVzZXJ2ZSBvcmRlcmluZy4gKilcbmxldCBsZWFmX2luZGV4IHQgaSA9XG4gICgqIFRoZSB0cmVlIGxheW91dCBpcyBsZXZlbCBvcmRlci4gIEFueSBsZWF2ZXMgaW4gdGhlIHNlY29uZCB0byBsYXN0IGxldmVsIG5lZWQgdG8gb2NjdXJcbiAgICAgaW4gdGhlIGFycmF5IGJlZm9yZSB0aGUgbGVhdmVzIGluIHRoZSBib3R0b20gbGV2ZWwuICopXG4gIGxldCByb3RhdGVkX2luZGV4ID1cbiAgICBsZXQgb2Zmc2V0X2Zyb21fc3RhcnRfb2ZfbGVhdmVzX2luX2FycmF5ID0gaSArIHQubnVtX2xlYXZlc19ub3RfaW5fYm90dG9tX2xldmVsIGluXG4gICAgaWYgb2Zmc2V0X2Zyb21fc3RhcnRfb2ZfbGVhdmVzX2luX2FycmF5IDwgdC5udW1fbGVhdmVzXG4gICAgdGhlbiBvZmZzZXRfZnJvbV9zdGFydF9vZl9sZWF2ZXNfaW5fYXJyYXlcbiAgICBlbHNlIG9mZnNldF9mcm9tX3N0YXJ0X29mX2xlYXZlc19pbl9hcnJheSAtIHQubnVtX2xlYXZlc1xuICBpblxuICAoKiBUaGUgbGVhdmVzIG9jY3VyIGFmdGVyIHRoZSBicmFuY2hlcyBpbiB0aGUgYXJyYXkuICopXG4gIHJvdGF0ZWRfaW5kZXggKyBudW1fYnJhbmNoZXMgdFxuOztcblxubGV0IGdldF9sZWFmIHQgaSA9IE9wdGlvbl9hcnJheS5nZXQgdC5kYXRhIChsZWFmX2luZGV4IHQgaSlcbmxldCB0b19saXN0IHQgPSBMaXN0LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gZ2V0X2xlYWYgdCBpKVxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IFslc2V4cCAodG9fbGlzdCB0IDogYSBvcHRpb24gbGlzdCldXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIGxldCBkYXRhID0gdC5kYXRhIGluXG4gIGZvciBpID0gMCB0byBPcHRpb25fYXJyYXkubGVuZ3RoIGRhdGEgLSAxIGRvXG4gICAgbWF0Y2ggT3B0aW9uX2FycmF5LmdldCBkYXRhIGkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBhIC0+IGludmFyaWFudF9hIGFcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG51bV9icmFuY2hlcyB0IC0gMSBkb1xuICAgIGxldCBsZWZ0ID0gbGVmdF9jaGlsZF9pbmRleCB+cGFyZW50X2luZGV4OmkgaW5cbiAgICBsZXQgcmlnaHQgPSByaWdodF9jaGlsZF9pbmRleCB+bGVmdF9jaGlsZF9pbmRleDpsZWZ0IGluXG4gICAgbGV0IGxlZnRfaXNfbm9uZSA9IE9wdGlvbl9hcnJheS5pc19ub25lIGRhdGEgbGVmdCBpblxuICAgIGxldCByaWdodF9pc19ub25lID0gT3B0aW9uX2FycmF5LmlzX25vbmUgZGF0YSByaWdodCBpblxuICAgIGlmIE9wdGlvbl9hcnJheS5pc19zb21lIGRhdGEgaVxuICAgIHRoZW4gYXNzZXJ0IChub3QgKGxlZnRfaXNfbm9uZSB8fCByaWdodF9pc19ub25lKSlcbiAgICBlbHNlXG4gICAgICBhc3NlcnQgKFxuICAgICAgICBpbmRleF9pc19sZWFmIHQgbGVmdCB8fCBpbmRleF9pc19sZWFmIHQgcmlnaHQgfHwgbGVmdF9pc19ub25lIHx8IHJpZ2h0X2lzX25vbmUpXG4gIGRvbmVcbjs7XG5cbmxldCBjcmVhdGVfZXhuID8oc2V4cF9vZl9hID0gWyVzZXhwX29mOiBfXSkgKCkgfmxlbjpudW1fbGVhdmVzIH5yZWR1Y2UgPVxuICBpZiBudW1fbGVhdmVzIDwgMVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwibm9uLXBvc2l0aXZlIG51bWJlciBvZiBsZWF2ZXMgaW4gYmFsYW5jZWQgcmVkdWNlclwiIChudW1fbGVhdmVzIDogaW50KV07XG4gIGxldCBudW1fYnJhbmNoZXMgPSBudW1fbGVhdmVzIC0gMSBpblxuICBsZXQgbnVtX2xlYXZlc19ub3RfaW5fYm90dG9tX2xldmVsID0gSW50LmNlaWxfcG93MiBudW1fbGVhdmVzIC0gbnVtX2xlYXZlcyBpblxuICBsZXQgZGF0YSA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjoobnVtX2JyYW5jaGVzICsgbnVtX2xlYXZlcykgaW5cbiAgeyBkYXRhOyBudW1fbGVhdmVzOyBudW1fbGVhdmVzX25vdF9pbl9ib3R0b21fbGV2ZWw7IHJlZHVjZTsgc2V4cF9vZl9hIH1cbjs7XG5cbmxldCB2YWxpZGF0ZV9pbmRleCB0IGkgPVxuICBpZiBpIDwgMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiYXR0ZW1wdCB0byBhY2Nlc3MgbmVnYXRpdmUgaW5kZXggaW4gYmFsYW5jZWQgcmVkdWNlclwiIH5pbmRleDooaSA6IGludCldO1xuICBsZXQgbGVuZ3RoID0gdC5udW1fbGVhdmVzIGluXG4gIGlmIGkgPj0gbGVuZ3RoXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJhdHRlbXB0IHRvIGFjY2VzcyBvdXQgb2YgYm91bmRzIGluZGV4IGluIGJhbGFuY2VkIHJlZHVjZXJcIlxuICAgICAgICAgIH5pbmRleDooaSA6IGludClcbiAgICAgICAgICAobGVuZ3RoIDogaW50KV1cbjs7XG5cbmxldCBzZXRfZXhuIHQgaSBhID1cbiAgdmFsaWRhdGVfaW5kZXggdCBpO1xuICBsZXQgZGF0YSA9IHQuZGF0YSBpblxuICBsZXQgaSA9IHJlZiAobGVhZl9pbmRleCB0IGkpIGluXG4gIE9wdGlvbl9hcnJheS5zZXRfc29tZSBkYXRhICFpIGE7XG4gIHdoaWxlICFpIDw+IDAgZG9cbiAgICBsZXQgcGFyZW50ID0gcGFyZW50X2luZGV4IH5jaGlsZF9pbmRleDohaSBpblxuICAgIGlmIE9wdGlvbl9hcnJheS5pc19ub25lIGRhdGEgcGFyZW50XG4gICAgdGhlbiBpIDo9IDBcbiAgICBlbHNlIChcbiAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgZGF0YSBwYXJlbnQ7XG4gICAgICBpIDo9IHBhcmVudClcbiAgZG9uZVxuOztcblxubGV0IGdldF9leG4gdCBpID1cbiAgdmFsaWRhdGVfaW5kZXggdCBpO1xuICBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZGF0YSAobGVhZl9pbmRleCB0IGkpXG47O1xuXG5sZXQgcmVjIGNvbXB1dGVfZXhuIHQgaSA9XG4gIGlmIE9wdGlvbl9hcnJheS5pc19zb21lIHQuZGF0YSBpXG4gIHRoZW4gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5kYXRhIGlcbiAgZWxzZSAoXG4gICAgbGV0IGxlZnQgPSBsZWZ0X2NoaWxkX2luZGV4IH5wYXJlbnRfaW5kZXg6aSBpblxuICAgIGxldCByaWdodCA9IHJpZ2h0X2NoaWxkX2luZGV4IH5sZWZ0X2NoaWxkX2luZGV4OmxlZnQgaW5cbiAgICBpZiBsZWZ0ID49IE9wdGlvbl9hcnJheS5sZW5ndGggdC5kYXRhXG4gICAgdGhlbiAoXG4gICAgICAoKiBJZiB3ZSBnZXQgaGVyZSwgdGhlIHBhcmVudCB3YXMgYW4gdW5zZXQgbGVhZi4gKilcbiAgICAgIGxldCBzZXhwX29mX2EgPSB0LnNleHBfb2ZfYSBpblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcImF0dGVtcHQgdG8gY29tcHV0ZSBiYWxhbmNlZCByZWR1Y2VyIHdpdGggdW5zZXQgZWxlbWVudHNcIlxuICAgICAgICAgICAgfmJhbGFuY2VkX3JlZHVjZXI6KHQgOiBhIHQpXSk7XG4gICAgbGV0IGEgPSB0LnJlZHVjZSAoY29tcHV0ZV9leG4gdCBsZWZ0KSAoY29tcHV0ZV9leG4gdCByaWdodCkgaW5cbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZGF0YSBpIGE7XG4gICAgYSlcbjs7XG5cbmxldCBjb21wdXRlX2V4biB0ID0gY29tcHV0ZV9leG4gdCAwXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
