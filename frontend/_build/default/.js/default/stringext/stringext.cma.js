// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Stringext
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = cst$4,
    cst$0 = cst$4,
    cst = cst$4,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer;
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[16], s, n, caml_ml_string_length(s) - n | 0);
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_call1(Stdlib_Buffer[1], 2 * len | 0),
     _Z_ = len - 1 | 0,
     _Y_ = 0;
    if(_Z_ >= 0){
     var i = _Y_;
     for(;;){
      var c = caml_string_get(s, i), ___ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < ___ >>> 0){
         var _$_ = ___ + 27 | 0;
         if(10 < _$_ >>> 0) break b;
         switch(_$_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= ___ - 1 >>> 0) break b;
        caml_call2(Stdlib_Buffer[12], buf, 92);
        caml_call2(Stdlib_Buffer[12], buf, c);
        break a;
       }
       caml_call2(Stdlib_Buffer[12], buf, c);
      }
      var _aa_ = i + 1 | 0;
      if(_Z_ === i) break;
      i = _aa_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_char = caml_call1(Stdlib_String[1], 1);
   function full_split(str, on){
    if(str === cst$4) return 0;
    var sep = caml_call1(of_char, on);
    function loop(acc, offset){
     try{
      var index = caml_call3(Stdlib_String[34], str, offset, on);
      if(index === offset)
       var _W_ = loop([0, sep, acc], index - 1 | 0);
      else
       var
        token =
          caml_call3
           (Stdlib_String[16], str, index + 1 | 0, offset - index | 0),
        _W_ = loop([0, sep, [0, token, acc]], index - 1 | 0);
      return _W_;
     }
     catch(_X_){
      var _V_ = caml_wrap_exception(_X_);
      if(_V_ === Stdlib[8])
       return 0 <= offset
               ? [0,
                 caml_call3(Stdlib_String[16], str, 0, offset + 1 | 0),
                 acc]
               : acc;
      throw caml_maybe_attach_backtrace(_V_, 0);
     }
    }
    return loop(0, caml_ml_string_length(str) - 1 | 0);
   }
   function split(max, str, on){
    if(max){
     var max$0 = max[1];
     if(str === cst$4) return 0;
     if(1 === max$0) return [0, str, 0];
     var
      loop =
        function(offset, tokens){
         if(tokens === (max$0 - 1 | 0))
          return [0,
                  caml_call3
                   (Stdlib_String[16],
                    str,
                    offset,
                    caml_ml_string_length(str) - offset | 0),
                  0];
         try{
          var index = caml_call3(Stdlib_String[32], str, offset, on);
          if(index === offset)
           var _T_ = [0, cst, loop(offset + 1 | 0, tokens + 1 | 0)];
          else
           var
            token =
              caml_call3(Stdlib_String[16], str, offset, index - offset | 0),
            _T_ = [0, token, loop(index + 1 | 0, tokens + 1 | 0)];
          return _T_;
         }
         catch(_U_){
          var _S_ = caml_wrap_exception(_U_);
          if(_S_ === Stdlib[8])
           return [0,
                   caml_call3
                    (Stdlib_String[16],
                     str,
                     offset,
                     caml_ml_string_length(str) - offset | 0),
                   0];
          throw caml_maybe_attach_backtrace(_S_, 0);
         }
        };
     return loop(0, 0);
    }
    if(str === cst$4) return 0;
    function loop$0(acc, offset){
     try{
      var index = caml_call3(Stdlib_String[34], str, offset, on);
      if(index === offset)
       var _Q_ = loop$0([0, cst$0, acc], index - 1 | 0);
      else
       var
        token =
          caml_call3
           (Stdlib_String[16], str, index + 1 | 0, offset - index | 0),
        _Q_ = loop$0([0, token, acc], index - 1 | 0);
      return _Q_;
     }
     catch(_R_){
      var _P_ = caml_wrap_exception(_R_);
      if(_P_ === Stdlib[8])
       return [0, caml_call3(Stdlib_String[16], str, 0, offset + 1 | 0), acc];
      throw caml_maybe_attach_backtrace(_P_, 0);
     }
    }
    return loop$0(0, caml_ml_string_length(str) - 1 | 0);
   }
   function trim_left_sub(s, last_char, len, chars){
    var final$0 = last_char + len | 0, last_char$0 = last_char, i = last_char;
    for(;;){
     if(i !== final$0){
      var _O_ = caml_string_get(s, i);
      if(caml_call2(Stdlib_String[15], chars, _O_)){
       var i$0 = i + 1 | 0, last_char$1 = i + 1 | 0;
       last_char$0 = last_char$1;
       i = i$0;
       continue;
      }
     }
     var new_len = len - (last_char$0 - last_char | 0) | 0;
     return caml_call3(Stdlib_String[16], s, last_char$0, new_len);
    }
   }
   function split_trim_left(str, on, trim){
    if(str === cst$4) return 0;
    function loop(acc, offset){
     try{
      var index = offset;
      for(;;){
       if(0 > index) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var _K_ = caml_string_get(str, index);
       if(caml_call2(Stdlib_String[15], on, _K_)){
        if(index === offset)
         var _M_ = loop([0, cst$1, acc], index - 1 | 0);
        else
         var
          token = trim_left_sub(str, index + 1 | 0, offset - index | 0, trim),
          _M_ = loop([0, token, acc], index - 1 | 0);
        return _M_;
       }
       var i = index - 1 | 0;
       index = i;
      }
     }
     catch(_N_){
      var _L_ = caml_wrap_exception(_N_);
      if(_L_ === Stdlib[8])
       return [0, trim_left_sub(str, 0, offset + 1 | 0, trim), acc];
      throw caml_maybe_attach_backtrace(_L_, 0);
     }
    }
    return loop(0, caml_ml_string_length(str) - 1 | 0);
   }
   var Found_int = [248, "Stringext.Found_int", caml_fresh_oo_id(0)];
   function trim_left(s){
    var
     _F_ = 0 < caml_ml_string_length(s) ? 1 : 0,
     _G_ = _F_ ? caml_string_get(s, 0) !== 32 ? 1 : 0 : _F_;
    if(_G_) return s;
    var len = caml_ml_string_length(s);
    try{
     var _I_ = len - 1 | 0, _H_ = 0;
     if(_I_ >= 0){
      var i = _H_;
      for(;;){
       if(32 !== caml_string_get(s, i))
        throw caml_maybe_attach_backtrace([0, Found_int, i], 1);
       var _J_ = i + 1 | 0;
       if(_I_ === i) break;
       i = _J_;
      }
     }
     return cst$2;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Found_int) throw caml_maybe_attach_backtrace(exn, 0);
     var non_space = exn[2];
     return caml_call3(Stdlib_String[16], s, non_space, len - non_space | 0);
    }
   }
   function find_from(opt, str, pattern){
    var start = opt ? opt[1] : 0;
    try{
     var
      _A_ = caml_ml_string_length(str) - caml_ml_string_length(pattern) | 0;
     if(_A_ >= start){
      var start$0 = start;
      for(;;){
       try{
        var _w_ = caml_ml_string_length(pattern) - 1 | 0, _v_ = 0;
        if(_w_ >= 0){
         var i = _v_;
         for(;;){
          var _y_ = caml_string_get(pattern, i);
          if(caml_string_get(str, i + start$0 | 0) !== _y_)
           throw caml_maybe_attach_backtrace(Stdlib[3], 1);
          var _z_ = i + 1 | 0;
          if(_w_ === i) break;
          i = _z_;
         }
        }
        var _x_ = 1, _C_ = _x_;
       }
       catch(_E_){var _C_ = 0;}
       if(_C_) throw caml_maybe_attach_backtrace([0, Found_int, start$0], 1);
       var _D_ = start$0 + 1 | 0;
       if(_A_ === start$0) break;
       start$0 = _D_;
      }
     }
     var _B_ = 0;
     return _B_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Found_int) return 0;
     var i$0 = exn[2];
     return [0, i$0];
    }
   }
   function replace_all(str, pattern, with$0){
    var
     plen = caml_ml_string_length(pattern),
     slen = caml_ml_string_length(str),
     buf = caml_call1(Stdlib_Buffer[1], slen),
     i = 0;
    for(;;){
     var match = find_from([0, i], str, pattern);
     if(! match){
      caml_call4(Stdlib_Buffer[18], buf, str, i, slen - i | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var j = match[1];
     caml_call4(Stdlib_Buffer[18], buf, str, i, j - i | 0);
     caml_call2(Stdlib_Buffer[16], buf, with$0);
     var i$0 = j + plen | 0;
     i = i$0;
    }
   }
   var
    Found_replace = [248, "Stringext.Found_replace", caml_fresh_oo_id(0)],
    cst_Stringext_cut_empty_separa = "Stringext.cut: empty separator",
    cst_Stringext_rcut_empty_separ = "Stringext.rcut: empty separator";
   function replace_all_assoc(str, tbl){
    var
     slen = caml_ml_string_length(str),
     buf = caml_call1(Stdlib_Buffer[1], slen),
     i = 0;
    for(;;){
     if(slen <= i) return caml_call1(Stdlib_Buffer[2], buf);
     try{
      var found = [0, 0];
      let i$0 = i, found$0 = found;
      var
       f =
         function(param){
          var
           with$0 = param[2],
           pattern = param[1],
           match = find_from([0, i$0], str, pattern);
          if(! match) return Stdlib[19];
          var j = match[1];
          if(j === i$0)
           throw caml_maybe_attach_backtrace
                  ([0, Found_replace, j, pattern, with$0], 1);
          found$0[1] = 1;
          return j;
         };
      if(tbl){
       var
        xs$0 = tbl[2],
        x$1 = tbl[1],
        fx$1 = f(x$1),
        x = x$1,
        fx = fx$1,
        param = xs$0;
       for(;;){
        if(! param) break;
        var xs = param[2], x$0 = param[1], fx$0 = f(x$0);
        if(runtime.caml_lessthan(fx$0, fx)){x = x$0; fx = fx$0; param = xs;}
        else
         param = xs;
       }
       var e = [0, [0, x, fx]];
      }
      else
       var e = 0;
      if(e)
       var
        _s_ = e[1],
        j$1 = _s_[2],
        match$0 = _s_[1],
        with$2 = match$0[2],
        pattern$1 = match$0[1],
        _t_ = found[1] ? [0, [0, j$1, pattern$1, with$2]] : 0,
        _u_ = _t_;
      else
       var _u_ = 0;
      var r = _u_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] !== Found_replace) throw caml_maybe_attach_backtrace(exn, 0);
      var
       with$0 = exn[4],
       pattern = exn[3],
       j = exn[2],
       r = [0, [0, j, pattern, with$0]];
     }
     if(! r){
      caml_call4(Stdlib_Buffer[18], buf, str, i, slen - i | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var
      match = r[1],
      with$1 = match[3],
      pattern$0 = match[2],
      j$0 = match[1];
     caml_call4(Stdlib_Buffer[18], buf, str, i, j$0 - i | 0);
     caml_call2(Stdlib_Buffer[16], buf, with$1);
     var i$0 = j$0 + caml_ml_string_length(pattern$0) | 0;
     i = i$0;
    }
   }
   function of_list(xs$0){
    var
     l = caml_call1(Stdlib_List[1], xs$0),
     s = caml_create_bytes(l),
     i = 0,
     param = xs$0;
    for(;;){
     if(! param) return caml_call1(Stdlib_Bytes[44], s);
     var xs = param[2], x = param[1];
     caml_bytes_set(s, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = xs;
    }
   }
   function to_list(s){
    var i$1 = caml_ml_string_length(s) - 1 | 0, acc = 0, i = i$1;
    for(;;){
     if(-1 === i) return acc;
     var i$0 = i - 1 | 0, acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function of_array(a){
    var
     len = a.length - 1,
     bytes = caml_create_bytes(len),
     _q_ = len - 1 | 0,
     _p_ = 0;
    if(_q_ >= 0){
     var i = _p_;
     for(;;){
      caml_bytes_set(bytes, i, runtime.caml_check_bound(a, i)[1 + i]);
      var _r_ = i + 1 | 0;
      if(_q_ === i) break;
      i = _r_;
     }
    }
    return caml_call1(Stdlib_Bytes[44], bytes);
   }
   function to_array(s){
    return caml_call2
            (Stdlib_Array[1],
             caml_ml_string_length(s),
             function(_o_){return caml_string_get(s, _o_);});
   }
   function cut(s, on){
    var sep_max = caml_ml_string_length(on) - 1 | 0;
    if(0 > sep_max)
     return caml_call1(Stdlib[1], cst_Stringext_cut_empty_separa);
    var s_max = caml_ml_string_length(s) - 1 | 0;
    if(0 > s_max) return 0;
    var k = [0, 0], i = [0, 0];
    try{
     for(;;){
      if((i[1] + sep_max | 0) > s_max){var _m_ = 0; return _m_;}
      if(caml_string_unsafe_get(s, i[1]) !== caml_string_unsafe_get(on, 0))
       i[1]++;
      else{
       k[1] = 1;
       for(;;){
        if(k[1] > sep_max) break;
        if
         (caml_string_unsafe_get(s, i[1] + k[1] | 0)
          !== caml_string_unsafe_get(on, k[1]))
         break;
        k[1]++;
       }
       if(k[1] > sep_max) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       i[1]++;
      }
     }
    }
    catch(_n_){
     var _k_ = caml_wrap_exception(_n_);
     if(_k_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_k_, 0);
     var
      left_end = i[1] - 1 | 0,
      right_start = (i[1] + sep_max | 0) + 1 | 0,
      _l_ =
        caml_call3
         (Stdlib_String[16],
          s,
          right_start,
          (s_max - right_start | 0) + 1 | 0);
     return [0,
             [0, caml_call3(Stdlib_String[16], s, 0, left_end + 1 | 0), _l_]];
    }
   }
   function rcut(s, on){
    var sep_max = caml_ml_string_length(on) - 1 | 0;
    if(0 > sep_max)
     return caml_call1(Stdlib[1], cst_Stringext_rcut_empty_separ);
    var s_max = caml_ml_string_length(s) - 1 | 0;
    if(0 > s_max) return 0;
    var k = [0, 0], i = [0, s_max];
    try{
     for(;;){
      if(sep_max > i[1]){var _i_ = 0; return _i_;}
      if
       (caml_string_unsafe_get(s, i[1])
        !== caml_string_unsafe_get(on, sep_max))
       i[1]--;
      else{
       var sep_start = i[1] - sep_max | 0;
       k[1] = sep_max - 1 | 0;
       for(;;){
        if(0 > k[1]) break;
        if
         (caml_string_unsafe_get(s, sep_start + k[1] | 0)
          !== caml_string_unsafe_get(on, k[1]))
         break;
        k[1]--;
       }
       if(0 > k[1]) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       i[1]--;
      }
     }
    }
    catch(_j_){
     var _g_ = caml_wrap_exception(_j_);
     if(_g_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_g_, 0);
     var
      left_end = (i[1] - sep_max | 0) - 1 | 0,
      right_start = i[1] + 1 | 0,
      _h_ =
        caml_call3
         (Stdlib_String[16],
          s,
          right_start,
          (s_max - right_start | 0) + 1 | 0);
     return [0,
             [0, caml_call3(Stdlib_String[16], s, 0, left_end + 1 | 0), _h_]];
    }
   }
   function chop_prefix(s, prefix){
    var
     prefix_l = caml_ml_string_length(prefix),
     string_l = caml_ml_string_length(s);
    if(string_l < prefix_l) return 0;
    try{
     var _b_ = prefix_l - 1 | 0, _a_ = 0;
     if(_b_ >= 0){
      var i = _a_;
      for(;;){
       var _d_ = caml_string_get(prefix, i);
       if(caml_string_get(s, i) !== _d_)
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var _e_ = i + 1 | 0;
       if(_b_ === i) break;
       i = _e_;
      }
     }
     var
      _c_ =
        [0,
         caml_call3(Stdlib_String[16], s, prefix_l, string_l - prefix_l | 0)];
     return _c_;
    }
    catch(_f_){return 0;}
   }
   function drop(s, n){
    var l = caml_ml_string_length(s);
    return l <= n ? cst$3 : caml_call3(Stdlib_String[16], s, n, l - n | 0);
   }
   function take(s, n){
    return caml_ml_string_length(s) <= n
            ? s
            : caml_call3(Stdlib_String[16], s, 0, n);
   }
   var
    Stringext =
      [0,
       string_after,
       quote,
       split,
       full_split,
       trim_left,
       split_trim_left,
       of_char,
       of_list,
       to_list,
       to_array,
       of_array,
       find_from,
       replace_all,
       replace_all_assoc,
       cut,
       rcut,
       chop_prefix,
       drop,
       take,
       trim_left_sub];
   runtime.caml_register_global(19, Stringext, "Stringext");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nZXh0LmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzdHJpbmdleHQuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliIiwiU3RkbGliX0FycmF5IiwiU3RkbGliX0J5dGVzIiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfQnVmZmVyIiwic3RyaW5nX2FmdGVyIiwicyIsIm4iLCJxdW90ZSIsImxlbiIsImJ1ZiIsImkiLCJjIiwib2ZfY2hhciIsImZ1bGxfc3BsaXQiLCJzdHIiLCJvbiIsInNlcCIsImxvb3AiLCJhY2MiLCJvZmZzZXQiLCJpbmRleCIsInRva2VuIiwic3BsaXQiLCJtYXgiLCJ0b2tlbnMiLCJ0cmltX2xlZnRfc3ViIiwibGFzdF9jaGFyIiwiY2hhcnMiLCJmaW5hbCIsIm5ld19sZW4iLCJzcGxpdF90cmltX2xlZnQiLCJ0cmltIiwiRm91bmRfaW50IiwidHJpbV9sZWZ0IiwiZXhuIiwibm9uX3NwYWNlIiwiZmluZF9mcm9tIiwib3B0IiwicGF0dGVybiIsInN0YXJ0IiwicmVwbGFjZV9hbGwiLCJ3aXRoIiwicGxlbiIsInNsZW4iLCJtYXRjaCIsImoiLCJGb3VuZF9yZXBsYWNlIiwiY3N0X1N0cmluZ2V4dF9jdXRfZW1wdHlfc2VwYXJhIiwiY3N0X1N0cmluZ2V4dF9yY3V0X2VtcHR5X3NlcGFyIiwicmVwbGFjZV9hbGxfYXNzb2MiLCJ0YmwiLCJmb3VuZCIsInBhcmFtIiwieHMiLCJ4IiwiZngiLCJlIiwiciIsIm9mX2xpc3QiLCJsIiwidG9fbGlzdCIsIm9mX2FycmF5IiwiYSIsImJ5dGVzIiwidG9fYXJyYXkiLCJjdXQiLCJzZXBfbWF4Iiwic19tYXgiLCJrIiwibGVmdF9lbmQiLCJyaWdodF9zdGFydCIsInJjdXQiLCJzZXBfc3RhcnQiLCJjaG9wX3ByZWZpeCIsInByZWZpeCIsInByZWZpeF9sIiwic3RyaW5nX2wiLCJkcm9wIiwidGFrZSIsIlN0cmluZ2V4dCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9zdHJpbmdleHQvc3RyaW5nZXh0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFsQixRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFB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QUFBO0FBQUE7QUFBQTtBQUFBLEtBREE7QUFBQSw2RUFBc0I7QUFBQTtBQUFBLEdBQ3NCO0FBQUEsWUFBQUcsWUFBQXBFLEdBQUFxRTtBQUFBQTtBQUFBQSxLQUFBQyxXQUd4RDtBQUFBLEtBQUFDLFdBQ0E7QUFBQSxJQUNBLHdCQUE0QjtBQUFBLElBRTFCO0FBQUE7QUFBQTtBQUFBLFVBQUFsRSxJQUFBO0FBQUE7QUFBQSxpQkFFZ0I7QUFBQSxPQUFUO0FBQUEsUUFBeUI7QUFBQSxpQkFBcEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUVMO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFDRztBQUFBLEdBQUk7QUFBQSxZQUFBbUUsS0FBQXhFLEdBQUFDO0FBQUFBLFFBQUFxRCxJQUdoQjtBQUFBLElBQ0Esd0JBRUssOENBQXNCO0FBQUE7QUFBQSxZQUFBbUIsS0FBQXpFLEdBQUFDO0FBQUFBLElBRzNCO0FBQUE7QUFBQSxjQUVLLHNDQUFnQjtBQUFBO0FBQUE7QUFBQSxJQUFBeUU7QUFBQUEsTUEzUkk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEckQzQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBTdHJpbmdcblxubGV0IHN0cmluZ19hZnRlciBzIG4gPSBTdHJpbmcuc3ViIHMgbiAoU3RyaW5nLmxlbmd0aCBzIC0gbilcblxubGV0IHF1b3RlIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlICgyICogbGVuKSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICdbJyB8ICddJyB8ICcqJyB8ICcuJyB8ICdcXFxcJyB8ICc/JyB8ICcrJyB8ICdeJyB8ICckJyBhcyBjIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJztcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgIHwgYyAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgZG9uZTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG5cbigqIE5vdCB0YWlsIHJlY3Vyc2l2ZSBmb3IgXCJwZXJmb3JtYW5jZVwiLCBwbGVhc2UgY2hvb3NlIGxvdyB2YWx1ZXMgZm9yXG4gICBbbWF4XS4gVGhlIGlkZWEgaXMgdGhhdCBtYXggaXMgYWx3YXlzIHNtYWxsIGJlY2F1c2UgaXQncyBoYXJkXG4gICBjb2RlICopXG5sZXQgc3BsaXRfY2hhcl9ib3VuZGVkIHN0ciB+b24gfm1heCA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiBbXVxuICBlbHNlIGlmIG1heCA9IDEgdGhlbiBbc3RyXVxuICBlbHNlXG4gICAgbGV0IHJlYyBsb29wIG9mZnNldCB0b2tlbnMgPVxuICAgICAgaWYgdG9rZW5zID0gbWF4IC0gMVxuICAgICAgdGhlbiBbc3ViIHN0ciBvZmZzZXQgKGxlbmd0aCBzdHIgLSBvZmZzZXQpXVxuICAgICAgZWxzZVxuICAgICAgICB0cnlcbiAgICAgICAgICBsZXQgaW5kZXggPSBpbmRleF9mcm9tIHN0ciBvZmZzZXQgb24gaW5cbiAgICAgICAgICBpZiBpbmRleCA9IG9mZnNldCB0aGVuXG4gICAgICAgICAgICBcIlwiOjoobG9vcCAob2Zmc2V0ICsgMSkgKHRva2VucyArIDEpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IFN0cmluZy5zdWIgc3RyIG9mZnNldCAoaW5kZXggLSBvZmZzZXQpIGluXG4gICAgICAgICAgICB0b2tlbjo6KGxvb3AgKGluZGV4ICsgMSkgKHRva2VucyArIDEpKVxuICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiBbc3ViIHN0ciBvZmZzZXQgKGxlbmd0aCBzdHIgLSBvZmZzZXQpXVxuICAgIGluIGxvb3AgMCAwXG5cbmxldCBzcGxpdF9jaGFyX3VuYm91bmRlZCBzdHIgfm9uID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgcmVjIGxvb3AgYWNjIG9mZnNldCA9XG4gICAgICB0cnkgYmVnaW5cbiAgICAgICAgbGV0IGluZGV4ID0gcmluZGV4X2Zyb20gc3RyIG9mZnNldCBvbiBpblxuICAgICAgICBpZiBpbmRleCA9IG9mZnNldCB0aGVuXG4gICAgICAgICAgbG9vcCAoXCJcIjo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHRva2VuID0gc3ViIHN0ciAoaW5kZXggKyAxKSAob2Zmc2V0IC0gaW5kZXgpIGluXG4gICAgICAgICAgbG9vcCAodG9rZW46OmFjYykgKGluZGV4IC0gMSlcbiAgICAgIGVuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT4gKHN1YiBzdHIgMCAob2Zmc2V0ICsgMSkpOjphY2NcbiAgICBpbiBsb29wIFtdIChsZW5ndGggc3RyIC0gMSlcblxubGV0IG9mX2NoYXIgPSBTdHJpbmcubWFrZSAxXG5cbmxldCBmdWxsX3NwbGl0IHN0ciB+b24gPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCBzZXAgPSBvZl9jaGFyIG9uIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyBvZmZzZXQgPVxuICAgICAgdHJ5IGJlZ2luXG4gICAgICAgIGxldCBpbmRleCA9IHJpbmRleF9mcm9tIHN0ciBvZmZzZXQgb24gaW5cbiAgICAgICAgaWYgaW5kZXggPSBvZmZzZXQgdGhlblxuICAgICAgICAgIGxvb3AgKHNlcDo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHRva2VuID0gc3ViIHN0ciAoaW5kZXggKyAxKSAob2Zmc2V0IC0gaW5kZXgpIGluXG4gICAgICAgICAgbG9vcCAoc2VwOjp0b2tlbjo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgZW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgICB0aGVuIChzdWIgc3RyIDAgKG9mZnNldCArIDEpKTo6YWNjXG4gICAgICAgIGVsc2UgYWNjXG4gICAgaW4gbG9vcCBbXSAobGVuZ3RoIHN0ciAtIDEpXG5cbigqIGNvcHlpbmcgY29yZSdzIGNvbnZlbnRpb24gZm9yIFN0cmluZy5zcGxpdCBidXQgd2l0aCBhbiBvcHRpb25hbCBtYXhcbiAgIGFyZ3VtZW50ICopXG5sZXQgc3BsaXQgP21heCBzIH5vbiA9XG4gIG1hdGNoIG1heCB3aXRoXG4gIHwgTm9uZSAtPiBzcGxpdF9jaGFyX3VuYm91bmRlZCBzIH5vblxuICB8IFNvbWUgbWF4IC0+ICAgICAgICAgICAgICAgICAoKiBhc3NlcnQgKG1heCA8IDEwMCk7ICopXG4gICAgc3BsaXRfY2hhcl9ib3VuZGVkIHMgfm9uIH5tYXhcblxubGV0IHJpbmRleF9mcm9tX29uIHMgfm9mZnNldCB+b24gPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmRcbiAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBvbiBzLltpXSB0aGVuIGlcbiAgICBlbHNlIGxvb3AgKGkgLSAxKVxuICBpbiBsb29wIG9mZnNldFxuXG5sZXQgdHJpbV9sZWZ0X3N1YiBzIH5wb3MgfmxlbiB+Y2hhcnMgPVxuICBsZXQgc3RhcnRfcG9zID1cbiAgICBsZXQgZmluYWwgPSBwb3MgKyBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbGFzdF9jaGFyIGkgPVxuICAgICAgaWYgaSA9IGZpbmFsIHRoZW4gbGFzdF9jaGFyXG4gICAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBjaGFycyBzLltpXSB0aGVuIGxvb3AgKGkgKyAxKSAoaSArIDEpXG4gICAgICBlbHNlIGxhc3RfY2hhclxuICAgIGluIGxvb3AgcG9zIHBvc1xuICBpblxuICBsZXQgbmV3X2xlbiA9IGxlbiAtIChzdGFydF9wb3MgLSBwb3MpIGluXG4gIFN0cmluZy5zdWIgcyBzdGFydF9wb3MgbmV3X2xlblxuXG5sZXQgc3BsaXRfdHJpbV9sZWZ0IHN0ciB+b24gfnRyaW0gPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByZWMgbG9vcCBhY2Mgb2Zmc2V0ID1cbiAgICAgIHRyeSBiZWdpblxuICAgICAgICBsZXQgaW5kZXggPSByaW5kZXhfZnJvbV9vbiBzdHIgfm9mZnNldCB+b24gaW5cbiAgICAgICAgaWYgaW5kZXggPSBvZmZzZXQgdGhlblxuICAgICAgICAgIGxvb3AgKFwiXCI6OmFjYykgKGluZGV4IC0gMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCB0b2tlbiA9IHRyaW1fbGVmdF9zdWIgc3RyIH5wb3M6KGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH5sZW46KG9mZnNldCAtIGluZGV4KSB+Y2hhcnM6dHJpbSBpblxuICAgICAgICAgIGxvb3AgKHRva2VuOjphY2MpIChpbmRleCAtIDEpXG4gICAgICBlbmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICh0cmltX2xlZnRfc3ViIHN0ciB+cG9zOjAgfmxlbjoob2Zmc2V0ICsgMSkgfmNoYXJzOnRyaW0pOjphY2NcbiAgICBpbiBsb29wIFtdIChsZW5ndGggc3RyIC0gMSlcblxuZXhjZXB0aW9uIEZvdW5kX2ludCBvZiBpbnRcblxubGV0IGZpcnN0X2NoYXJfbmUgcyBjID1cbiAgU3RyaW5nLmxlbmd0aCBzID4gMCAmJiBzLlswXSA8PiBjXG5cbmxldCB0cmltX2xlZnQgcyA9XG4gIGlmIGZpcnN0X2NoYXJfbmUgcyAnICcgdGhlbiBzXG4gIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgdHJ5XG4gICAgICBmb3IgaT0wIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaWYgcy5baV0gPD4gJyAnIHRoZW4gcmFpc2UgKEZvdW5kX2ludCBpKVxuICAgICAgZG9uZTtcbiAgICAgIFwiXCJcbiAgICB3aXRoIEZvdW5kX2ludCBub25fc3BhY2UgLT5cbiAgICAgIHN1YiBzIG5vbl9zcGFjZSAobGVuIC0gbm9uX3NwYWNlKVxuXG5sZXQgc3Vic3RyX2VxID8oc3RhcnQ9MCkgcyB+cGF0dGVybiA9XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHBhdHRlcm4gLSAxIGRvXG4gICAgICBpZiBzLltpICsgc3RhcnRdIDw+IHBhdHRlcm4uW2ldIHRoZW4gcmFpc2UgRXhpdFxuICAgIGRvbmU7XG4gICAgdHJ1ZVxuICB3aXRoIF8gLT4gZmFsc2VcblxubGV0IGZpbmRfZnJvbSA/KHN0YXJ0PTApIHN0ciB+cGF0dGVybiA9XG4gIHRyeVxuICAgIGZvciBpID0gc3RhcnQgdG8gKFN0cmluZy5sZW5ndGggc3RyKSAtIChTdHJpbmcubGVuZ3RoIHBhdHRlcm4pIGRvXG4gICAgICBpZiBzdWJzdHJfZXEgfnN0YXJ0Omkgc3RyIH5wYXR0ZXJuIHRoZW5cbiAgICAgICAgcmFpc2UgKEZvdW5kX2ludCBpKVxuICAgIGRvbmU7XG4gICAgTm9uZVxuICB3aXRoXG4gIHwgRm91bmRfaW50IGkgLT4gU29tZSBpXG4gIHwgIF8gLT4gTm9uZVxuXG5sZXQgZmluZF9taW4gbCB+ZiA9XG4gIGxldCByZWMgbG9vcCB4IGZ4ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFNvbWUgKHgsIGZ4KVxuICAgIHwgeCc6OnhzIC0+XG4gICAgICBsZXQgZngnID0gZiB4JyBpblxuICAgICAgaWYgZngnIDwgZnggdGhlbiBsb29wIHgnIGZ4JyB4c1xuICAgICAgZWxzZSBsb29wIHggZnggeHNcbiAgaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHg6OnhzIC0+IGxvb3AgeCAoZiB4KSB4c1xuXG5sZXQgcmVwbGFjZV9hbGwgc3RyIH5wYXR0ZXJuIH53aXRoXyA9XG4gIGxldCAoc2xlbiwgcGxlbikgPSBTdHJpbmcuKGxlbmd0aCBzdHIsIGxlbmd0aCBwYXR0ZXJuKSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBzbGVuIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBtYXRjaCBmaW5kX2Zyb20gfnN0YXJ0Omkgc3RyIH5wYXR0ZXJuIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzdHIgaSAoc2xlbiAtIGkpO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICAgIHwgU29tZSBqIC0+XG4gICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgc3RyIGkgKGogLSBpKTtcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiB3aXRoXztcbiAgICAgIGxvb3AgKGogKyBwbGVuKVxuICBpbiBsb29wIDBcblxuZXhjZXB0aW9uIEZvdW5kX3JlcGxhY2Ugb2YgaW50ICogc3RyaW5nICogc3RyaW5nXG5cbmxldCByZXBsYWNlX2FsbF9hc3NvYyBzdHIgdGJsID1cbiAgbGV0IHNsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBzbGVuIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID49IHNsZW4gdGhlbiBCdWZmZXIuY29udGVudHMgYnVmXG4gICAgZWxzZVxuICAgICAgbGV0IHIgPVxuICAgICAgICB0cnlcbiAgICAgICAgICBsZXQgZm91bmQgPSByZWYgZmFsc2UgaW5cbiAgICAgICAgICBsZXQgZSA9XG4gICAgICAgICAgICBmaW5kX21pbiB0YmwgfmY6KGZ1biAocGF0dGVybiwgd2l0aF8pIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGZpbmRfZnJvbSB+c3RhcnQ6aSBzdHIgfnBhdHRlcm4gd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgICAtPiBtYXhfaW50XG4gICAgICAgICAgICAgIHwgU29tZSBqIHdoZW4gaiA9IGkgLT4gcmFpc2UgKEZvdW5kX3JlcGxhY2UgKGosIHBhdHRlcm4sIHdpdGhfKSlcbiAgICAgICAgICAgICAgfCBTb21lIGogLT4gZm91bmQgOj0gdHJ1ZTsgailcbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIGUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lICgocGF0dGVybiwgd2l0aF8pLCBqKSB3aGVuICFmb3VuZCAtPiBTb21lIChqLCBwYXR0ZXJuLCB3aXRoXylcbiAgICAgICAgICB8IFNvbWUgXyAtPiBOb25lXG4gICAgICAgIHdpdGggRm91bmRfcmVwbGFjZSAoaiwgcGF0dGVybiwgd2l0aF8pIC0+IFNvbWUgKGosIHBhdHRlcm4sIHdpdGhfKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzdHIgaSAoc2xlbiAtIGkpO1xuICAgICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gICAgICB8IFNvbWUgKGosIHBhdHRlcm4sIHdpdGhfKSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgc3RyIGkgKGogLSBpKTtcbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHdpdGhfO1xuICAgICAgICBsb29wIChqICsgU3RyaW5nLmxlbmd0aCBwYXR0ZXJuKVxuICBpbiBsb29wIDBcblxubGV0IGl0ZXJpIGYgbCA9XG4gIGxldCByZWMgbG9vcCBpID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+ICgpXG4gICAgfCB4Ojp4cyAtPiAoZiBpIHgpOyBsb29wIChzdWNjIGkpIHhzXG4gIGluIGxvb3AgMCBsXG5cbmxldCBvZl9saXN0IHhzID1cbiAgbGV0IGwgPSBMaXN0Lmxlbmd0aCB4cyBpblxuICBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGl0ZXJpIChmdW4gaSBjIC0+IEJ5dGVzLnNldCBzIGkgYykgeHM7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgdG9fbGlzdCBzID1cbiAgbGV0IHJlYyBsb29wIGFjYyBpID1cbiAgICBpZiBpID0gLTEgdGhlbiBhY2NcbiAgICBlbHNlXG4gICAgICBsb29wIChzLltpXSA6OiBhY2MpIChwcmVkIGkpXG4gIGluIGxvb3AgW10gKFN0cmluZy5sZW5ndGggcyAtIDEpXG5cbmxldCBvZl9hcnJheSBhID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBCeXRlcy5zZXQgYnl0ZXMgaSBhLihpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ5dGVzXG5cbmxldCB0b19hcnJheSBzID0gQXJyYXkuaW5pdCAoU3RyaW5nLmxlbmd0aCBzKSAoU3RyaW5nLmdldCBzKVxuXG4oKiByaXBwZWQgb2ZmIGZyb20gb25lIG9mIGRidWVuemxpJ3MgbGlicyAqKVxubGV0IGN1dCBzIH5vbiA9XG4gIGxldCBzZXBfbWF4ID0gbGVuZ3RoIG9uIC0gMSBpblxuICBpZiBzZXBfbWF4IDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nZXh0LmN1dDogZW1wdHkgc2VwYXJhdG9yXCIgZWxzZVxuICAgIGxldCBzX21heCA9IGxlbmd0aCBzIC0gMSBpblxuICAgIGlmIHNfbWF4IDwgMCB0aGVuIE5vbmUgZWxzZVxuICAgICAgbGV0IGsgPSByZWYgMCBpblxuICAgICAgbGV0IGkgPSByZWYgMCBpblxuICAgICAgKCogV2UgcnVuIGZyb20gdGhlIHN0YXJ0IG9mIFtzXSB0byBlbmQgd2l0aCBbaV0gdHJ5aW5nIHRvIG1hdGNoIHRoZVxuICAgICAgICAgZmlyc3QgY2hhcmFjdGVyIG9mIFtvbl0gaW4gW3NdLiBJZiB0aGlzIG1hdGNoZXMsIHdlIHZlcmlmeSB0aGF0XG4gICAgICAgICB0aGUgd2hvbGUgW29uXSBpcyBtYXRjaGVkIHVzaW5nIFtrXS4gSWYgaXQgZG9lc24ndCBtYXRjaCB3ZVxuICAgICAgICAgY29udGludWUgdG8gbG9vayBmb3IgW29uXSB3aXRoIFtpXS4gSWYgaXQgbWF0Y2hlcyB3ZSBleGl0IHRoZVxuICAgICAgICAgbG9vcCBhbmQgZXh0cmFjdCBhIHN1YnN0cmluZyBmcm9tIHRoZSBzdGFydCBvZiBbc10gdG8gdGhlXG4gICAgICAgICBwb3NpdGlvbiBiZWZvcmUgdGhlIFtvbl0gd2UgZm91bmQgYW5kIGFub3RoZXIgZnJvbSB0aGUgcG9zaXRpb25cbiAgICAgICAgIGFmdGVyIHRoZSBbb25dIHdlIGZvdW5kIHRvIGVuZCBvZiBzdHJpbmcuIElmIFtpXSBpcyBzdWNoIHRoYXQgbm9cbiAgICAgICAgIHNlcGFyYXRvciBjYW4gYmUgZm91bmQgd2UgZXhpdCB0aGUgbG9vcCBhbmQgcmV0dXJuIHRoZSBubyBtYXRjaFxuICAgICAgICAgY2FzZS4gKilcbiAgICAgIHRyeVxuICAgICAgICB3aGlsZSAoIWkgKyBzZXBfbWF4IDw9IHNfbWF4KSBkb1xuICAgICAgICAgICgqIENoZWNrIHJlbWFpbmluZyBbb25dIGNoYXJzIG1hdGNoLCBhY2Nlc3MgdG8gdW5zYWZlIHMgKCFpICsgIWspIGlzXG4gICAgICAgICAgICAgZ3VhcmFudGVlZCBieSBsb29wIGludmFyaWFudC4gKilcbiAgICAgICAgICBpZiB1bnNhZmVfZ2V0IHMgIWkgPD4gdW5zYWZlX2dldCBvbiAwIHRoZW4gaW5jciBpIGVsc2UgYmVnaW5cbiAgICAgICAgICAgIGsgOj0gMTtcbiAgICAgICAgICAgIHdoaWxlICghayA8PSBzZXBfbWF4ICYmIHVuc2FmZV9nZXQgcyAoIWkgKyAhaykgPSB1bnNhZmVfZ2V0IG9uICFrKVxuICAgICAgICAgICAgZG8gaW5jciBrIGRvbmU7XG4gICAgICAgICAgICBpZiAhayA8PSBzZXBfbWF4IHRoZW4gKCogbm8gbWF0Y2ggKikgaW5jciBpIGVsc2UgcmFpc2UgRXhpdFxuICAgICAgICAgIGVuZFxuICAgICAgICBkb25lO1xuICAgICAgICBOb25lICgqIG5vIG1hdGNoIGluIHRoZSB3aG9sZSBzdHJpbmcuICopXG4gICAgICB3aXRoXG4gICAgICB8IEV4aXQgLT4gKCogaSBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZXBhcmF0b3IgKilcbiAgICAgICAgbGV0IGxlZnRfZW5kID0gIWkgLSAxIGluXG4gICAgICAgIGxldCByaWdodF9zdGFydCA9ICFpICsgc2VwX21heCArIDEgaW5cbiAgICAgICAgU29tZSAoc3ViIHMgMCAobGVmdF9lbmQgKyAxKSxcbiAgICAgICAgICAgICAgc3ViIHMgcmlnaHRfc3RhcnQgKHNfbWF4IC0gcmlnaHRfc3RhcnQgKyAxKSlcblxubGV0IHJjdXQgcyB+b24gPVxuICBsZXQgc2VwX21heCA9IGxlbmd0aCBvbiAtIDEgaW5cbiAgaWYgc2VwX21heCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZ2V4dC5yY3V0OiBlbXB0eSBzZXBhcmF0b3JcIiBlbHNlXG4gICAgbGV0IHNfbWF4ID0gbGVuZ3RoIHMgLSAxIGluXG4gICAgaWYgc19tYXggPCAwIHRoZW4gTm9uZSBlbHNlXG4gICAgICBsZXQgayA9IHJlZiAwIGluXG4gICAgICBsZXQgaSA9IHJlZiBzX21heCBpblxuICAgICAgKCogV2UgcnVuIGZyb20gdGhlIGVuZCBvZiBbc10gdG8gdGhlIGJlZ2lubmluZyB3aXRoIFtpXSB0cnlpbmcgdG9cbiAgICAgICAgIG1hdGNoIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBbb25dIGluIFtzXS4gSWYgdGhpcyBtYXRjaGVzLCB3ZVxuICAgICAgICAgdmVyaWZ5IHRoYXQgdGhlIHdob2xlIFtvbl0gaXMgbWF0Y2hlZCB1c2luZyBba10gKHdlIGRvIHRoYXRcbiAgICAgICAgIGJhY2t3YXJkcykuICBJZiBpdCBkb2Vzbid0IG1hdGNoIHdlIGNvbnRpbnVlIHRvIGxvb2sgZm9yIFtvbl1cbiAgICAgICAgIHdpdGggW2ldLiAgSWYgaXQgbWF0Y2hlcyB3ZSBleGl0IHRoZSBsb29wIGFuZCBleHRyYWN0IGFcbiAgICAgICAgIHN1YnN0cmluZyBmcm9tIHRoZSBzdGFydCBvZiBbc10gdG8gdGhlIHBvc2l0aW9uIGJlZm9yZSB0aGVcbiAgICAgICAgIFtvbl0gd2UgZm91bmQgYW5kIGFub3RoZXIgZnJvbSB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIFtvbl0gd2VcbiAgICAgICAgIGZvdW5kIHRvIGVuZCBvZiBzdHJpbmcuICBJZiBbaV0gaXMgc3VjaCB0aGF0IG5vIHNlcGFyYXRvciBjYW5cbiAgICAgICAgIGJlIGZvdW5kIHdlIGV4aXQgdGhlIGxvb3AgYW5kIHJldHVybiB0aGUgbm8gbWF0Y2ggY2FzZS4gKilcbiAgICAgIHRyeVxuICAgICAgICB3aGlsZSAoIWkgPj0gc2VwX21heCkgZG9cbiAgICAgICAgICBpZiB1bnNhZmVfZ2V0IHMgIWkgPD4gdW5zYWZlX2dldCBvbiBzZXBfbWF4IHRoZW4gZGVjciBpIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICgqIENoZWNrIHJlbWFpbmluZyBbb25dIGNoYXJzIG1hdGNoLCBhY2Nlc3MgdG8gdW5zYWZlX2dldFxuICAgICAgICAgICAgICAgcyAoc2VwX3N0YXJ0ICsgIWspIGlzIGd1YXJhbnRlZWQgYnkgbG9vcCBpbnZhcmlhbnQuICopXG4gICAgICAgICAgICBsZXQgc2VwX3N0YXJ0ID0gIWkgLSBzZXBfbWF4IGluXG4gICAgICAgICAgICBrIDo9IHNlcF9tYXggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCFrID49IDAgJiYgdW5zYWZlX2dldCBzIChzZXBfc3RhcnQgKyAhaykgPSB1bnNhZmVfZ2V0IG9uICFrKVxuICAgICAgICAgICAgZG8gZGVjciBrIGRvbmU7XG4gICAgICAgICAgICBpZiAhayA+PSAwIHRoZW4gKCogbm8gbWF0Y2ggKikgZGVjciBpIGVsc2UgcmFpc2UgRXhpdFxuICAgICAgICAgIGVuZFxuICAgICAgICBkb25lO1xuICAgICAgICBOb25lICgqIG5vIG1hdGNoIGluIHRoZSB3aG9sZSBzdHJpbmcuICopXG4gICAgICB3aXRoXG4gICAgICB8IEV4aXQgLT4gKCogaSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBzZXBhcmF0b3IgKilcbiAgICAgICAgbGV0IGxlZnRfZW5kID0gIWkgLSBzZXBfbWF4IC0gMSBpblxuICAgICAgICBsZXQgcmlnaHRfc3RhcnQgPSAhaSArIDEgaW5cbiAgICAgICAgU29tZSAoc3ViIHMgMCAobGVmdF9lbmQgKyAxKSxcbiAgICAgICAgICAgICAgc3ViIHMgcmlnaHRfc3RhcnQgKHNfbWF4IC0gcmlnaHRfc3RhcnQgKyAxKSlcblxubGV0IGNob3BfcHJlZml4IHMgfnByZWZpeCA9XG4gIGxldCBwcmVmaXhfbCA9IFN0cmluZy5sZW5ndGggcHJlZml4IGluXG4gIGxldCBzdHJpbmdfbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBwcmVmaXhfbCA+IHN0cmluZ19sIHRoZW4gTm9uZVxuICBlbHNlXG4gICAgdHJ5XG4gICAgICBmb3IgaSA9IDAgdG8gcHJlZml4X2wgLSAxIGRvXG4gICAgICAgIGlmIHMuW2ldIDw+IHByZWZpeC5baV0gdGhlbiByYWlzZSBFeGl0O1xuICAgICAgZG9uZTtcbiAgICAgIFNvbWUgKFN0cmluZy5zdWIgcyBwcmVmaXhfbCAoc3RyaW5nX2wgLSBwcmVmaXhfbCkpXG4gICAgd2l0aCBfIC0+IE5vbmVcblxubGV0IGRyb3AgcyBuID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbiA+PSBsXG4gIHRoZW4gXCJcIlxuICBlbHNlIFN0cmluZy5zdWIgcyBuIChsIC0gbilcblxubGV0IHRha2UgcyBuID1cbiAgaWYgbiA+PSBTdHJpbmcubGVuZ3RoIHNcbiAgdGhlbiBzXG4gIGVsc2UgU3RyaW5nLnN1YiBzIDAgblxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
