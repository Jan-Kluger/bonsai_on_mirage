// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Angstrom__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom = [0];
   runtime.caml_register_global(0, Angstrom, "Angstrom__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__More
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom_More = [0];
   runtime.caml_register_global(0, Angstrom_More, "Angstrom__More");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Exported_state
//# unitInfo: Requires: Stdlib, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    cst$0 = " > ",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    _a_ = [1, "incomplete input"];
   function state_to_option(x){
    switch(x[0]){
      case 0:
       return 0;
      case 1:
       var v = x[2]; return [0, v];
      default: return 0;
    }
   }
   function fail_to_string(marks, err){
    var
     _b_ = caml_call2(Stdlib[28], cst, err),
     _c_ = caml_call2(Stdlib_String[7], cst$0, marks);
    return caml_call2(Stdlib[28], _c_, _b_);
   }
   function state_to_result(x){
    switch(x[0]){
      case 0:
       return _a_;
      case 1:
       var v = x[2]; return [0, v];
      default:
       var err = x[3], marks = x[2]; return [1, fail_to_string(marks, err)];
    }
   }
   var
    Angstrom_Exported_state =
      [0, state_to_option, fail_to_string, state_to_result];
   runtime.caml_register_global
    (5, Angstrom_Exported_state, "Angstrom__Exported_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Input
//# unitInfo: Requires: Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_input_ml = "lib/input.ml",
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bigstringaf = global_data.Bigstringaf,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, cst_lib_input_ml, 60, 2],
    _b_ = [0, cst_lib_input_ml, 59, 2];
   function create(buffer, off, len, committed_bytes){
    return [0, committed_bytes, committed_bytes, off, len, buffer];
   }
   function length(t){return t[2] + t[4] | 0;}
   function client_committed_bytes(t){return t[2];}
   function parser_committed_bytes(t){return t[1];}
   function bytes_for_client_to_commit(t){return t[1] - t[2] | 0;}
   function parser_uncommitted_bytes(t){
    var _f_ = bytes_for_client_to_commit(t);
    return t[4] - _f_ | 0;
   }
   function invariant(t){
    var _c_ = length(t), _d_ = parser_uncommitted_bytes(t);
    if((t[1] + _d_ | 0) !== _c_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var _e_ = bytes_for_client_to_commit(t);
    if((t[1] - t[2] | 0) === _e_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function offset_in_buffer(t, pos){return (t[3] + pos | 0) - t[2] | 0;}
   function apply(t, pos, len, f){
    var off = offset_in_buffer(t, pos);
    return caml_call3(f, t[5], off, len);
   }
   function unsafe_get_char(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_ba_get_1(t[5], off);
   }
   function unsafe_get_int16_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[30], t[5], off);
   }
   function unsafe_get_int32_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[36], t[5], off);
   }
   function unsafe_get_int64_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[40], t[5], off);
   }
   function unsafe_get_int16_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[31], t[5], off);
   }
   function unsafe_get_int32_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[37], t[5], off);
   }
   function unsafe_get_int64_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[41], t[5], off);
   }
   function count_while(t, pos, f){
    var
     buffer = t[5],
     off = offset_in_buffer(t, pos),
     i = [0, off],
     limit = t[3] + t[4] | 0;
    for(;;){
     if(i[1] < limit && caml_call1(f, caml_ba_get_1(buffer, i[1]))){i[1]++; continue;}
     return i[1] - off | 0;
    }
   }
   function commit(t, pos){t[1] = pos; return 0;}
   var
    Angstrom_Input =
      [0,
       create,
       length,
       client_committed_bytes,
       parser_committed_bytes,
       parser_uncommitted_bytes,
       bytes_for_client_to_commit,
       unsafe_get_char,
       unsafe_get_int16_le,
       unsafe_get_int32_le,
       unsafe_get_int64_le,
       unsafe_get_int16_be,
       unsafe_get_int32_be,
       unsafe_get_int64_be,
       count_while,
       apply,
       commit,
       invariant];
   runtime.caml_register_global(4, Angstrom_Input, "Angstrom__Input");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Parser
//# unitInfo: Requires: Angstrom__Exported_state, Angstrom__Input, Bigstringaf, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    State = [0];
   function fail_k(input, pos, param, marks, msg){
    return [3, pos - caml_call1(Angstrom_Input[3], input) | 0, marks, msg];
   }
   function succeed_k(input, pos, param, v){
    return [2, pos - caml_call1(Angstrom_Input[3], input) | 0, v];
   }
   function to_exported_state(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var match = param$0[1], continue$0 = match[2], committed = match[1];
        return [0,
                [0,
                 committed,
                 function(bs, off, len, more){
                  return to_exported_state
                          (caml_call4(continue$0, bs, off, len, more));
                 }]];
       case 1:
        var x = param$0[1], _c_ = runtime.caml_obj_tag(x);
        a:
        if(250 === _c_)
         var param$1 = x[1];
        else{
         if(246 !== _c_ && 244 !== _c_){var param$1 = x; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], x);
        }
        param$0 = param$1;
        break;
       case 2:
        var x$0 = param$0[2], i = param$0[1]; return [1, i, x$0];
       default:
        var s = param$0[3], sl = param$0[2], i$0 = param$0[1];
        return [2, i$0, sl, s];
     }
   }
   function parse(p){
    var input = caml_call4(Angstrom_Input[1], Bigstringaf[2], 0, 0, 0);
    return to_exported_state(caml_call5(p[1], input, 0, 1, fail_k, succeed_k));
   }
   function parse_bigstring(p, input){
    var
     _a_ = caml_call1(Bigstringaf[6], input),
     input$0 = caml_call4(Angstrom_Input[1], input, 0, _a_, 0),
     _b_ =
       to_exported_state(caml_call5(p[1], input$0, 0, 0, fail_k, succeed_k));
    return caml_call1(Angstrom_Exported_state[3], _b_);
   }
   function return$0(v){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4(succ, input, pos, more, v);
            }];
   }
   function fail(msg){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call5(fail, input, pos, more, 0, msg);
            }];
   }
   function symbol_bind(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call5
                      (caml_call1(f, v)[1], input, pos, more, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol_map(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call4(succ, input, pos, more, caml_call1(f, v));
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol(f, m){return symbol_map(m, f);}
   function symbol$0(f, m){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, f){
              function succ1(input1, pos1, more1, m){
               return caml_call4(succ, input1, pos1, more1, caml_call1(f, m));
              }
              return caml_call5(m[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(f[1], input, pos, more, fail, succ0);
            }];
   }
   function lift(f, m){return symbol_map(m, f);}
   function lift2(f, m1, m2){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               return caml_call4
                       (succ, input2, pos2, more2, caml_call2(f, m1, m2));
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift3(f, m1, m2, m3){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                return caml_call4
                        (succ, input3, pos3, more3, caml_call3(f, m1, m2, m3));
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift4(f, m1, m2, m3, m4){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                function succ4(input4, pos4, more4, m4){
                 return caml_call4
                         (succ, input4, pos4, more4, caml_call4(f, m1, m2, m3, m4));
                }
                return caml_call5(m4[1], input3, pos3, more3, fail, succ4);
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function symbol$1(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, param){
              return caml_call5(b[1], input, pos, more, fail, succ);
             }
             return caml_call5(a[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol$2(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, x){
              function succ1(input1, pos1, more1, param){
               return caml_call4(succ, input1, pos1, more1, x);
              }
              return caml_call5(b[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(a[1], input, pos, more, fail, succ0);
            }];
   }
   var
    Monad =
      [0,
       return$0,
       fail,
       symbol_bind,
       symbol_map,
       symbol,
       symbol$0,
       lift,
       lift2,
       lift3,
       lift4,
       symbol$1,
       symbol$2];
   function symbol$3(p, mark){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos, more, marks, msg){
              return caml_call5(fail, input, pos, more, [0, mark, marks], msg);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   function symbol$4(p, q){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos$0, more$0, marks, msg){
              return pos < caml_call1(Angstrom_Input[4], input)
                      ? caml_call5(fail, input, pos$0, more, marks, msg)
                      : caml_call5(q[1], input, pos, more$0, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   var
    Choice = [0, symbol$3, symbol$4],
    return$1 = Monad[1],
    fail$0 = Monad[2],
    symbol_bind$0 = Monad[3];
   function symbol_map$0(m, f){
    return caml_call2
            (symbol_bind$0,
             m,
             function(x){return caml_call1(return$1, caml_call1(f, x));});
   }
   function symbol$5(f, m){return symbol_map$0(m, f);}
   function symbol$6(f, m){
    return caml_call2
            (symbol_bind$0, f, function(f){return symbol_map$0(m, f);});
   }
   function lift2$0(f, m1, m2){return symbol$6(symbol_map$0(m1, f), m2);}
   function lift3$0(f, m1, m2, m3){
    return symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3);
   }
   function lift4$0(f, m1, m2, m3, m4){
    return symbol$6(symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3), m4);
   }
   function symbol$7(a, b){
    return caml_call2(symbol_bind$0, a, function(param){return b;});
   }
   function symbol$8(a, b){
    return caml_call2
            (symbol_bind$0,
             a,
             function(x){return symbol_map$0(b, function(param){return x;});});
   }
   var
    Monad_use_for_debugging =
      [0,
       return$1,
       fail$0,
       symbol_bind$0,
       symbol_map$0,
       symbol$5,
       symbol$6,
       symbol_map$0,
       lift2$0,
       lift3$0,
       lift4$0,
       symbol$7,
       symbol$8],
    Angstrom_Parser =
      [0,
       State,
       fail_k,
       succeed_k,
       to_exported_state,
       parse,
       parse_bigstring,
       Monad,
       Choice,
       Monad_use_for_debugging];
   runtime.caml_register_global(4, Angstrom_Parser, "Angstrom__Parser");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Buffering
//# unitInfo: Requires: Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_buffering_ml = "lib/buffering.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Bigstringaf = global_data.Bigstringaf,
    _a_ = [0, cst_lib_buffering_ml, 8, 2],
    _b_ = [0, cst_lib_buffering_ml, 7, 2],
    _c_ = [0, cst_lib_buffering_ml, 47, 2],
    _d_ = [0, cst_lib_buffering_ml, 46, 2],
    _e_ = [0, cst_lib_buffering_ml, 54, 2],
    _f_ = [0, cst_lib_buffering_ml, 53, 2],
    _g_ = [0, cst_lib_buffering_ml, 64, 2],
    _h_ = [0, cst_lib_buffering_ml, 79, 2];
   function of_bigstring(off, len, buf){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((len - off | 0) <= caml_call1(Bigstringaf[6], buf))
     return [0, buf, off, len];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function create(len){
    return of_bigstring(0, 0, caml_call1(Bigstringaf[1], len));
   }
   function writable_space(t){
    var _m_ = t[3];
    return caml_call1(Bigstringaf[6], t[1]) - _m_ | 0;
   }
   function ensure(t, to_copy){
    var
     _k_ = t[2] + t[3] | 0,
     _l_ = (caml_call1(Bigstringaf[6], t[1]) - _k_ | 0) < to_copy ? 1 : 0;
    if(! _l_) return _l_;
    if(to_copy <= writable_space(t)){
     caml_call5(Bigstringaf[44], t[1], t[2], t[1], 0, t[3]);
     t[2] = 0;
     return;
    }
    var
     old_len = caml_call1(Bigstringaf[6], t[1]),
     new_len = [0, old_len],
     space = writable_space(t);
    for(;;){
     if(((space + new_len[1] | 0) - old_len | 0) >= to_copy){
      var new_buf = caml_call1(Bigstringaf[1], new_len[1]);
      caml_call5(Bigstringaf[44], t[1], t[2], new_buf, 0, t[3]);
      t[1] = new_buf;
      t[2] = 0;
      return;
     }
     new_len[1] = (3 * new_len[1] | 0) / 2 | 0;
    }
   }
   function write_pos(t){return t[2] + t[3] | 0;}
   function feed_string(t, off, len, str){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if((len - off | 0) > caml_ml_string_length(str))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    ensure(t, len);
    var _j_ = write_pos(t);
    caml_call5(Bigstringaf[45], str, off, t[1], _j_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_bigstring(t, off, len, b){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    if((len - off | 0) > caml_call1(Bigstringaf[6], b))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    ensure(t, len);
    var _i_ = write_pos(t);
    caml_call5(Bigstringaf[44], b, off, t[1], _i_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_input(t, param){
    if(608227697 <= param[1]){
     var b = param[2];
     return feed_bigstring(t, 0, caml_call1(Bigstringaf[6], b), b);
    }
    var s = param[2];
    return feed_string(t, 0, caml_ml_string_length(s), s);
   }
   function shift(t, n){
    if(n > t[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    t[2] = t[2] + n | 0;
    t[3] = t[3] - n | 0;
    return 0;
   }
   function for_reading(param){
    var buf = param[1], off = param[2], len = param[3];
    return caml_call3(Bigstringaf[5], buf, off, len);
   }
   function unconsumed(opt, param){
    var
     shift = opt ? opt[1] : 0,
     buf = param[1],
     off = param[2],
     len = param[3];
    if(shift <= len) return [0, buf, off + shift | 0, len - shift | 0];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function of_unconsumed(param){
    var len = param[3], off = param[2], buf = param[1];
    return [0, buf, off, len];
   }
   var
    Angstrom_Buffering =
      [0,
       create,
       of_bigstring,
       feed_string,
       feed_bigstring,
       feed_input,
       shift,
       for_reading,
       unconsumed,
       of_unconsumed];
   runtime.caml_register_global(10, Angstrom_Buffering, "Angstrom__Buffering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom
//# unitInfo: Requires: Angstrom__Buffering, Angstrom__Exported_state, Angstrom__Input, Angstrom__Parser, Bigstringaf, CamlinternalLazy, Stdlib, Stdlib__Char, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_count_while1$1 = "count_while1",
    cst_not_enough_input$1 = "not enough input",
    cst_satisfy = "satisfy: ",
    cst_satisfy_C = "satisfy: %C",
    caml_int32_float_of_bits = runtime.caml_int32_float_of_bits,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\r\n",
    Stdlib = global_data.Stdlib,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom_Buffering = global_data.Angstrom__Buffering,
    Angstrom_Parser = global_data.Angstrom__Parser,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    Stdlib_Sys = global_data.Stdlib__Sys,
    parse = Angstrom_Parser[5],
    parse_bigstring = Angstrom_Parser[6],
    state_to_option = Angstrom_Exported_state[1],
    fail_to_string = Angstrom_Exported_state[2],
    state_to_result = Angstrom_Exported_state[3],
    _a_ = Angstrom_Parser[7],
    return$0 = _a_[1],
    fail = _a_[2],
    symbol_bind = _a_[3],
    symbol_map = _a_[4],
    symbol = _a_[5],
    symbol$0 = _a_[6],
    lift = _a_[7],
    lift2 = _a_[8],
    lift3 = _a_[9],
    lift4 = _a_[10],
    symbol$1 = _a_[11],
    symbol$2 = _a_[12],
    include = Angstrom_Parser[8],
    symbol$3 = include[1],
    symbol$4 = include[2],
    cst_parse_invalid_argument_ini =
      "parse: invalid argument, initial_buffer_size < 1",
    _b_ = [1, "incomplete input"],
    cst_prompt_input_shrunk = "prompt: input shrunk!",
    cst_not_enough_input = cst_not_enough_input$1,
    cst_not_enough_input$0 = cst_not_enough_input$1;
   function from_unbuffered_state(f, buffering, param){
    switch(param[0]){
      case 0:
       var p = param[1]; return [0, caml_call1(f, p)];
      case 1:
       var
        v = param[2],
        consumed = param[1],
        unconsumed =
          caml_call2(Angstrom_Buffering[8], [0, consumed], buffering);
       return [1, unconsumed, v];
      default:
       var
        msg = param[3],
        marks = param[2],
        consumed$0 = param[1],
        unconsumed$0 =
          caml_call2(Angstrom_Buffering[8], [0, consumed$0], buffering);
       return [2, unconsumed$0, marks, msg];
    }
   }
   function parse$0(opt, p){
    var initial_buffer_size = opt ? opt[1] : 4096;
    if(initial_buffer_size < 1)
     caml_call1(Stdlib[2], cst_parse_invalid_argument_ini);
    var buffering = caml_call1(Angstrom_Buffering[1], initial_buffer_size);
    function f(p, input){
     caml_call2(Angstrom_Buffering[6], buffering, p[1]);
     var
      more =
        typeof input === "number"
         ? 0
         : (caml_call2(Angstrom_Buffering[5], buffering, input), 1),
      for_reading = caml_call1(Angstrom_Buffering[7], buffering),
      _M_ = caml_call1(Bigstringaf[6], for_reading);
     return from_unbuffered_state
             (f, buffering, caml_call4(p[2], for_reading, 0, _M_, more));
    }
    return from_unbuffered_state(f, buffering, caml_call1(parse, p));
   }
   function feed(state, input){
    switch(state[0]){
      case 0:
       var k = state[1]; return caml_call1(k, input);
      case 1:
       var v = state[2], unconsumed = state[1];
       if(typeof input === "number") return state;
       var buffering = caml_call1(Angstrom_Buffering[9], unconsumed);
       caml_call2(Angstrom_Buffering[5], buffering, input);
       return [1, caml_call2(Angstrom_Buffering[8], 0, buffering), v];
      default:
       var msg = state[3], marks = state[2], unconsumed$0 = state[1];
       if(typeof input === "number") return state;
       var buffering$0 = caml_call1(Angstrom_Buffering[9], unconsumed$0);
       caml_call2(Angstrom_Buffering[5], buffering$0, input);
       return [2,
               caml_call2(Angstrom_Buffering[8], 0, buffering$0),
               marks,
               msg];
    }
   }
   function state_to_option$0(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var v = param[2]; return [0, v];
      default: return 0;
    }
   }
   function state_to_result$0(param){
    switch(param[0]){
      case 0:
       return _b_;
      case 1:
       var v = param[2]; return [0, v];
      default:
       var msg = param[3], marks = param[2];
       return [1, caml_call2(fail_to_string, marks, msg)];
    }
   }
   function state_to_unconsumed(param){
    if(0 === param[0]) return 0;
    var unconsumed = param[1];
    return [0, unconsumed];
   }
   function prompt(input, pos, fail, succ){
    var
     parser_uncommitted_bytes = caml_call1(Angstrom_Input[5], input),
     parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
    function continue$0(input, off, len, more){
     if(len < parser_uncommitted_bytes)
      caml_call1(Stdlib[2], cst_prompt_input_shrunk);
     var
      input$0 =
        caml_call4(Angstrom_Input[1], input, off, len, parser_committed_bytes);
     return len === parser_uncommitted_bytes
             ? more
               ? prompt(input$0, pos, fail, succ)
               : caml_call3(fail, input$0, pos, 0)
             : caml_call3(succ, input$0, pos, more);
    }
    return [0, [0, caml_call1(Angstrom_Input[6], input), continue$0]];
   }
   var
    demand_input =
      [0,
       function(input, pos, more, fail, succ){
        if(! more)
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input$0);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail$0(input, pos, more){
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input);
        }
        return prompt(input, pos, fail$0, succ$0);
       }];
   function ensure_suspended(n, input, pos, more, fail, succ){
    var go = [];
    caml_update_dummy
     (go,
      [0,
       function(input, pos, more, fail, succ){
        return (pos + n | 0) <= caml_call1(Angstrom_Input[2], input)
                ? caml_call4(succ, input, pos, more, 0)
                : caml_call5
                  (caml_call2(symbol$1, demand_input, go)[1],
                   input,
                   pos,
                   more,
                   fail,
                   succ);
       }]);
    return caml_call5
            (caml_call2(symbol$1, demand_input, go)[1],
             input,
             pos,
             more,
             fail,
             succ);
   }
   function unsafe_apply(len, f){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4
                     (succ,
                      input,
                      pos + len | 0,
                      more,
                      caml_call4(Angstrom_Input[15], input, pos, len, f));
            }];
   }
   function ensure(n, p){
    return [0,
            function(input, pos, more, fail, succ){
             if((pos + n | 0) <= caml_call1(Angstrom_Input[2], input))
              return caml_call5(p[1], input, pos, more, fail, succ);
             function succ$0(input, pos, more, param){
              return caml_call5(p[1], input, pos, more, fail, succ);
             }
             return ensure_suspended(n, input, pos, more, fail, succ$0);
            }];
   }
   var
    at_end_of_input =
      [0,
       function(input, pos, more, param, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4(succ, input, pos, more, 0);
        if(! more) return caml_call4(succ, input, pos, more, 1);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail(input, pos, more){
         return caml_call4(succ, input, pos, more, 1);
        }
        return prompt(input, pos, fail, succ$0);
       }],
    cst_end_of_input = "end_of_input",
    end_of_input =
      caml_call2
       (symbol_bind,
        at_end_of_input,
        function(param){
         return param
                 ? caml_call1(return$0, 0)
                 : caml_call1(fail, cst_end_of_input);
        }),
    cst_advance = "advance";
   function advance(n){
    if(0 > n) return caml_call1(fail, cst_advance);
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call4(succ, input, pos + n | 0, more, 0);
        }];
    return ensure(n, p);
   }
   var
    pos =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4(succ, input, pos, more, pos);
       }],
    available =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call1(Angstrom_Input[2], input) - pos | 0);
       }],
    commit =
      [0,
       function(input, pos, more, fail, succ){
        caml_call2(Angstrom_Input[16], input, pos);
        return caml_call4(succ, input, pos, more, 0);
       }];
   function unsafe_lookahead(p){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, param, more, v){
              return caml_call4(succ, input, pos, more, v);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   var
    peek_char =
      [0,
       function(input, pos, more, fail, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        if(0 === more) return caml_call4(succ, input, pos, more, 0);
        function succ$0(input, pos, more){
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        }
        function fail$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        return prompt(input, pos, fail$0, succ$0);
       }],
    peek_char_fail = [];
   caml_update_dummy
    (peek_char_fail,
     [0,
      function(input, pos, more, fail, succ){
       if(pos < caml_call1(Angstrom_Input[2], input))
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       function succ$0(input, pos, more, param){
        return caml_call5(peek_char_fail[1], input, pos, more, fail, succ);
       }
       return ensure_suspended(1, input, pos, more, fail, succ$0);
      }]);
   var
    _c_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _d_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _e_ = [0, [11, "char ", [1, 0]], "char %C"],
    _f_ = [0, [11, "not char ", [1, 0]], "not char %C"];
   function satisfy(f){
    return [0,
            function(input, pos, more, fail, succ){
             if(pos >= caml_call1(Angstrom_Input[2], input)){
              var
               succ$0 =
                 function(input, pos, more, param){
                  var c = caml_call2(Angstrom_Input[7], input, pos);
                  if(caml_call1(f, c))
                   return caml_call4(succ, input, pos + 1 | 0, more, c);
                  var _L_ = caml_call4(fail, input, pos, more, 0);
                  return caml_call3(Stdlib_Printf[10], _L_, _d_, c);
                 };
              return ensure_suspended(1, input, pos, more, fail, succ$0);
             }
             var c = caml_call2(Angstrom_Input[7], input, pos);
             if(caml_call1(f, c))
              return caml_call4(succ, input, pos + 1 | 0, more, c);
             var _K_ = caml_call4(fail, input, pos, more, 0);
             return caml_call3(Stdlib_Printf[10], _K_, _c_, c);
            }];
   }
   function char$0(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[7], input, pos) === c
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _e_, c));
        }];
    return ensure(1, p);
   }
   function not_char(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c$0 = caml_call2(Angstrom_Input[7], input, pos);
         return c !== c$0
                 ? caml_call4(succ, input, pos + 1 | 0, more, c$0)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _f_, c));
        }];
    return ensure(1, p);
   }
   var
    p =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos + 1 | 0,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       }],
    any_char = ensure(1, p),
    _g_ = [0, [11, "int8 ", [4, 0, 0, 0, 0]], "int8 %d"];
   function int8(i){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c = caml_call2(Angstrom_Input[7], input, pos);
         return c === (i & 255)
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _g_, i));
        }];
    return ensure(1, p);
   }
   var
    p$0 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c);
       }],
    any_uint8 = ensure(1, p$0),
    s = Stdlib_Sys[10] - 8 | 0,
    p$1 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c << s >> s);
       }],
    any_int8 = ensure(1, p$1),
    cst_skip = "skip",
    cst_count_while1 = cst_count_while1$1,
    cst_count_while1$0 = cst_count_while1$1,
    _h_ = [1, "string"],
    cst_take_n_0 = "take: n < 0",
    cst_take_bigstring_n_0 = "take_bigstring: n < 0",
    cst_no_more_choices = "no more choices",
    cst_Angstrom_fix_direct_not_se = "Angstrom.fix_direct not set";
   function skip(f){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call1(f, caml_call2(Angstrom_Input[7], input, pos))
                 ? caml_call4(succ, input, pos + 1 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_skip);
        }];
    return ensure(1, p);
   }
   function count_while(init, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos + init | 0, f),
              input_len = caml_call1(Angstrom_Input[2], input),
              init$0 = init + len | 0;
             if((pos + init$0 | 0) >= input_len && 0 !== more){
              var
               succ$0 =
                 function(input, pos, more){
                  return count_while(init$0, f, with_buffer)[1].call
                          (null, input, pos, more, fail, succ);
                 },
               fail$0 =
                 function(input, pos, more){
                  return caml_call4
                          (succ,
                           input,
                           pos + init$0 | 0,
                           more,
                           caml_call4
                            (Angstrom_Input[15], input, pos, init$0, with_buffer));
                 };
              return prompt(input, pos, fail$0, succ$0);
             }
             return caml_call4
                     (succ,
                      input,
                      pos + init$0 | 0,
                      more,
                      caml_call4
                       (Angstrom_Input[15], input, pos, init$0, with_buffer));
            }];
   }
   function count_while1(f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos, f),
              input_len = caml_call1(Angstrom_Input[2], input);
             if(1 <= len){
              if((pos + len | 0) >= input_len && 0 !== more){
               var
                succ$0 =
                  function(input, pos, more){
                   return count_while(len, f, with_buffer)[1].call
                           (null, input, pos, more, fail, succ);
                  },
                fail$0 =
                  function(input, pos, more){
                   return caml_call4
                           (succ,
                            input,
                            pos + len | 0,
                            more,
                            caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
                  };
               return prompt(input, pos, fail$0, succ$0);
              }
              return caml_call4
                      (succ,
                       input,
                       pos + len | 0,
                       more,
                       caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
             }
             if(pos >= input_len && 0 !== more){
              var
               succ$1 =
                 function(input, pos, more){
                  return count_while1(f, with_buffer)[1].call
                          (null, input, pos, more, fail, succ);
                 },
               fail$1 =
                 function(input, pos, more){
                  return caml_call5
                          (fail, input, pos, more, 0, cst_count_while1$0);
                 };
              return prompt(input, pos, fail$1, succ$1);
             }
             return caml_call5(fail, input, pos, more, 0, cst_count_while1);
            }];
   }
   function string(f, s){
    var len = caml_ml_string_length(s);
    function f$0(buffer, off, len){
     var i = [0, 0];
     for(;;){
      if(i[1] < len){
       var
        _I_ = caml_call1(f, runtime.caml_string_unsafe_get(s, i[1])),
        _J_ = caml_call1(f, runtime.caml_ba_get_1(buffer, off + i[1] | 0));
       if(caml_call2(Stdlib_Char[6], _J_, _I_)){i[1]++; continue;}
      }
      return len === i[1]
              ? [0, caml_call3(Bigstringaf[7], buffer, off, len)]
              : _h_;
     }
    }
    return ensure
            (len,
             [0,
              function(input, pos, more, fail, succ){
               var
                match = caml_call4(Angstrom_Input[15], input, pos, len, f$0);
               if(0 === match[0]){
                var x = match[1];
                return caml_call4(succ, input, pos + len | 0, more, x);
               }
               var e = match[1];
               return caml_call5(fail, input, pos, more, 0, e);
              }]);
   }
   function string$0(s){return string(function(x){return x;}, s);}
   function string_ci(s){return string(Stdlib_Char[3], s);}
   function skip_while(f){
    return count_while(0, f, function(_H_, _G_, param){return 0;});
   }
   function take(n){
    if(0 > n) return caml_call1(fail, cst_take_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[7]));
   }
   function take_bigstring(n){
    if(0 > n) return caml_call1(fail, cst_take_bigstring_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[4]));
   }
   function take_bigstring_while(f){return count_while(0, f, Bigstringaf[4]);}
   function take_bigstring_while1(f){return count_while1(f, Bigstringaf[4]);}
   function take_bigstring_till(f){
    return take_bigstring_while(function(c){return 1 - caml_call1(f, c);});
   }
   function peek_string(n){return unsafe_lookahead(take(n));}
   function take_while(f){return count_while(0, f, Bigstringaf[7]);}
   function take_while1(f){return count_while1(f, Bigstringaf[7]);}
   function take_till(f){
    return take_while(function(c){return 1 - caml_call1(f, c);});
   }
   function choice(opt, ps){
    var
     failure_msg = opt ? opt[1] : cst_no_more_choices,
     _F_ = caml_call1(fail, failure_msg);
    return caml_call3(Stdlib_List[27], symbol$4, ps, _F_);
   }
   var
    notset =
      [0,
       function(buf, pos, more, fail, succ){
        return caml_call1(Stdlib[2], cst_Angstrom_fix_direct_not_se);
       }];
   function fix_direct(f){
    var p = [], r = [];
    caml_update_dummy(p, [0, notset]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        return caml_call5(p[1][1], buf, pos, more, fail, succ);
       }]);
    p[1] = caml_call1(f, r);
    return r;
   }
   function fix_lazy(max_steps, f){
    var steps = [0, max_steps], p = [], r = [];
    caml_update_dummy(p, [246, function(_E_){return caml_call1(f, r);}]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        steps[1]--;
        if(0 > steps[1]){
         steps[1] = max_steps;
         return [1,
                 [246,
                  function(_B_){
                   var _C_ = caml_obj_tag(p);
                   a:
                   if(250 === _C_)
                    var _D_ = p[1];
                   else{
                    if(246 !== _C_ && 244 !== _C_){var _D_ = p; break a;}
                    var _D_ = caml_call1(CamlinternalLazy[2], p);
                   }
                   return caml_call5(_D_[1], buf, pos, more, fail, succ);
                  }]];
        }
        var _z_ = caml_obj_tag(p);
        a:
        if(250 === _z_)
         var _A_ = p[1];
        else{
         if(246 !== _z_ && 244 !== _z_){var _A_ = p; break a;}
         var _A_ = caml_call1(CamlinternalLazy[2], p);
        }
        return caml_call5(_A_[1], buf, pos, more, fail, succ);
       }]);
    return r;
   }
   var
    _i_ = Stdlib_Sys[5],
    cst_LE_int64 = "LE.int64",
    cst_LE_int32 = "LE.int32",
    cst_LE_int16 = "LE.int16",
    cst_BE_int64 = "BE.int64",
    cst_BE_int32 = "BE.int32",
    cst_BE_int16 = "BE.int16",
    cst_consumed_parser_committed = "consumed: parser committed",
    cst_count_n_0 = "count: n < 0",
    cst_end_of_line = "end_of_line",
    fix =
      typeof _i_ === "number"
       ? _i_ ? fix_direct : fix_direct
       : function(f){return fix_lazy(20, f);};
   function option(x, p){
    return caml_call2(symbol$4, p, caml_call1(return$0, x));
   }
   function cons(x, xs){return [0, x, xs];}
   function list(ps){
    if(! ps) return caml_call1(return$0, 0);
    var ps$0 = ps[2], p = ps[1];
    return caml_call3(lift2, cons, p, list(ps$0));
   }
   function count(n, p){
    if(0 > n) return caml_call1(fail, cst_count_n_0);
    function loop(n){
     return 0 === n
             ? caml_call1(return$0, 0)
             : caml_call3(lift2, cons, p, loop(n - 1 | 0));
    }
    return loop(n);
   }
   function many(p){
    return fix
            (function(m){
              var _y_ = caml_call1(return$0, 0);
              return caml_call2(symbol$4, caml_call3(lift2, cons, p, m), _y_);
             });
   }
   function many1(p){return caml_call3(lift2, cons, p, many(p));}
   function many_till(p, t){
    return fix
            (function(m){
              var _x_ = caml_call3(lift2, cons, p, m);
              return caml_call2
                      (symbol$4,
                       caml_call2(symbol$1, t, caml_call1(return$0, 0)),
                       _x_);
             });
   }
   function sep_by1(s, p){
    return fix
            (function(m){
              var _w_ = caml_call1(return$0, 0);
              return caml_call3
                      (lift2,
                       cons,
                       p,
                       caml_call2(symbol$4, caml_call2(symbol$1, s, m), _w_));
             });
   }
   function sep_by(s, p){
    var _u_ = caml_call1(return$0, 0), _v_ = caml_call1(return$0, 0);
    return caml_call2
            (symbol$4,
             caml_call3
              (lift2,
               cons,
               p,
               caml_call2
                (symbol$4, caml_call2(symbol$1, s, sep_by1(s, p)), _v_)),
             _u_);
   }
   function skip_many(p){
    return fix
            (function(m){
              var _t_ = caml_call1(return$0, 0);
              return caml_call2
                      (symbol_bind,
                       caml_call2
                        (symbol$4,
                         caml_call2(symbol_map, p, function(param){return 1;}),
                         _t_),
                       function(param){return param ? m : caml_call1(return$0, 0);});
             });
   }
   function skip_many1(p){return caml_call2(symbol$1, p, skip_many(p));}
   var
    _j_ = caml_call1(return$0, 0),
    _k_ = caml_call2(symbol$1, string$0(cst), _j_),
    _l_ = caml_call1(return$0, 0),
    end_of_line =
      caml_call2
       (symbol$3,
        caml_call2(symbol$4, caml_call2(symbol$1, char$0(10), _l_), _k_),
        cst_end_of_line);
   function scan(state, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              state$0 = [0, state],
              parser =
                caml_call2
                 (symbol_map,
                  count_while
                   (0,
                    function(c){
                     var match = caml_call2(f, state$0[1], c);
                     if(! match) return 0;
                     var state = match[1];
                     state$0[1] = state;
                     return 1;
                    },
                    with_buffer),
                  function(x){return [0, x, state$0[1]];});
             return caml_call5(parser[1], input, pos, more, fail, succ);
            }];
   }
   function scan$0(state, f){return scan(state, f, Bigstringaf[7]);}
   function scan_state(state, f){
    return caml_call2
            (symbol_map,
             scan(state, f, function(_s_, _r_, param){return 0;}),
             function(param){var state = param[2]; return state;});
   }
   function scan_string(state, f){
    return caml_call2
            (symbol_map, scan$0(state, f), function(_q_){return _q_[1];});
   }
   function consume_with(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             var
              parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
             function succ$0(input, pos$0, more, param){
              if
               (parser_committed_bytes
                !== caml_call1(Angstrom_Input[4], input))
               return caml_call5
                       (fail, input, pos$0, more, 0, cst_consumed_parser_committed);
              var
               len = pos$0 - pos | 0,
               consumed = caml_call4(Angstrom_Input[15], input, pos, len, f);
              return caml_call4(succ, input, pos$0, more, consumed);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function consumed(p){return consume_with(p, Bigstringaf[7]);}
   function consumed_bigstring(p){return consume_with(p, Bigstringaf[4]);}
   function both(a, b){
    return caml_call3(lift2, function(a, b){return [0, a, b];}, a, b);
   }
   function map(t, f){return caml_call2(symbol_map, t, f);}
   function bind(t, f){return caml_call2(symbol_bind, t, f);}
   function map2(a, b, f){return caml_call3(lift2, f, a, b);}
   function map3(a, b, c, f){return caml_call4(lift3, f, a, b, c);}
   function map4(a, b, c, d, f){return caml_call5(lift4, f, a, b, c, d);}
   var
    Let_syntax = [0, return$0, map, bind, both, map2, map3, map4],
    Let_syntax$0 = [0, return$0, symbol_map, symbol_bind, Let_syntax];
   function int16(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[11], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int16);
        }];
    return ensure(2, p);
   }
   function int32(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _p_ = caml_call2(Angstrom_Input[12], input, pos);
         return caml_call2(Stdlib_Int32[17], _p_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int32);
        }];
    return ensure(4, p);
   }
   function int64(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _o_ = caml_call2(Angstrom_Input[13], input, pos);
         return caml_call2(Stdlib_Int64[17], _o_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[31], bs, off);
          })),
    any_int16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[33], bs, off);
          })),
    any_int32 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[37], bs, off);
          })),
    any_int64 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[41], bs, off);
          })),
    any_float =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[37], bs, off));
          })),
    any_double =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[41], bs, off));
          }));
   function int16$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[8], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int16);
        }];
    return ensure(2, p);
   }
   function int32$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _n_ = caml_call2(Angstrom_Input[9], input, pos);
         return caml_call2(Stdlib_Int32[17], _n_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int32);
        }];
    return ensure(4, p);
   }
   function int64$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _m_ = caml_call2(Angstrom_Input[10], input, pos);
         return caml_call2(Stdlib_Int64[17], _m_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[30], bs, off);
          })),
    any_int16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[32], bs, off);
          })),
    any_int32$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[36], bs, off);
          })),
    any_int64$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[40], bs, off);
          })),
    any_float$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[36], bs, off));
          })),
    any_double$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[40], bs, off));
          }));
   function take$0(n, f){
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, f));
   }
   function peek(n, f){return unsafe_lookahead(take$0(n, f));}
   function take_while$0(check, f){return count_while(0, check, f);}
   function take_while1$0(check, f){return count_while1(check, f);}
   function take_till$0(check, f){
    return take_while$0(function(c){return 1 - caml_call1(check, c);}, f);
   }
   var Consume = [0];
   function parse_bigstring$0(consume, p, bs){
    var p$0 = consume ? caml_call2(symbol$2, p, end_of_input) : p;
    return caml_call2(parse_bigstring, p$0, bs);
   }
   function parse_string(consume, p, s){
    var len = caml_ml_string_length(s), bs = caml_call1(Bigstringaf[1], len);
    caml_call5(Bigstringaf[45], s, 0, bs, 0, len);
    return parse_bigstring$0(consume, p, bs);
   }
   var
    Angstrom =
      [0,
       peek_char,
       peek_char_fail,
       peek_string,
       char$0,
       not_char,
       any_char,
       satisfy,
       string$0,
       string_ci,
       skip,
       skip_while,
       take,
       take_while,
       take_while1,
       take_till,
       consumed,
       take_bigstring,
       take_bigstring_while,
       take_bigstring_while1,
       take_bigstring_till,
       consumed_bigstring,
       advance,
       end_of_line,
       at_end_of_input,
       end_of_input,
       scan$0,
       scan_state,
       scan_string,
       int8,
       any_uint8,
       any_int8,
       [0,
        int16,
        int32,
        int64,
        any_int16,
        any_int32,
        any_int64,
        any_uint16,
        any_float,
        any_double],
       [0,
        int16$0,
        int32$0,
        int64$0,
        any_int16$0,
        any_int32$0,
        any_int64$0,
        any_uint16$0,
        any_float$0,
        any_double$0],
       option,
       both,
       list,
       count,
       many,
       many1,
       many_till,
       sep_by,
       sep_by1,
       skip_many,
       skip_many1,
       fix,
       fix_lazy,
       symbol$4,
       choice,
       symbol$3,
       commit,
       return$0,
       fail,
       symbol_bind,
       bind,
       symbol_map,
       symbol$0,
       symbol,
       symbol$1,
       symbol$2,
       lift,
       lift2,
       lift3,
       lift4,
       map,
       map2,
       map3,
       map4,
       Let_syntax$0,
       symbol_map,
       symbol_bind,
       both,
       [0, take$0, take_while$0, take_while1$0, take_till$0, peek],
       Consume,
       parse_bigstring$0,
       parse_string,
       [0,
        parse$0,
        feed,
        state_to_option$0,
        state_to_result$0,
        state_to_unconsumed],
       [0, parse, state_to_option, state_to_result],
       pos,
       available];
   runtime.caml_register_global(43, Angstrom, "Angstrom");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5nc3Ryb20uY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJBbmdzdHJvbSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJBbmdzdHJvbV9Nb3JlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxnQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwyIiwiZiIsImEwIiwiYTEiLCJnbG9iYWxfZGF0YSIsImNzdCIsIlN0ZGxpYiIsIlN0ZGxpYl9TdHJpbmciLCJzdGF0ZV90b19vcHRpb24iLCJ4IiwidiIsImZhaWxfdG9fc3RyaW5nIiwibWFya3MiLCJlcnIiLCJzdGF0ZV90b19yZXN1bHQiLCJBbmdzdHJvbV9FeHBvcnRlZF9zdGF0ZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9hbmdzdHJvbS9leHBvcnRlZF9zdGF0ZS5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQTtBQUFBLFlBQUFDLGdCQUFBQztBQUFBQSxJQ1V3QjtBQUFBO0FBQUEsT0FHTjtBQUFBO0FBQUEsV0FBQUMsSUFITSxNQUNOO0FBQUEsZUFDQTtBQUFBO0FBQUEsR0FDSTtBQUFBLFlBQUFDLGVBQUFDLE9BQUFDO0FBQUFBO0FBQUFBLEtBQUEsTUFHUTtBQUFBLFdBQTVCO0FBQUEsSUFBeUIsdUNBQWE7QUFBQTtBQUFBLFlBQUFDLGdCQUFBTDtBQUFBQSxJQUVoQjtBQUFBO0FBQUEsT0FFRztBQUFBO0FBQUEsV0FBQUMsSUFGSCxNQUNHO0FBQUE7QUFBQSxXQUFBRyxNQURILE1BQUFELFFBQUEsTUFHUyxzQ0FBMEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBRztBQUFBQSxNRHJCM0QiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsInR5cGUgJ2Egc3RhdGUgPVxuICB8IFBhcnRpYWwgb2YgJ2EgcGFydGlhbFxuICB8IERvbmUgICAgb2YgaW50ICogJ2FcbiAgfCBGYWlsICAgIG9mIGludCAqIHN0cmluZyBsaXN0ICogc3RyaW5nXG5cbmFuZCAnYSBwYXJ0aWFsID1cbiAgeyBjb21taXR0ZWQgOiBpbnRcbiAgOyBjb250aW51ZSAgOiBCaWdzdHJpbmdhZi50IC0+IG9mZjppbnQgLT4gbGVuOmludCAtPiBNb3JlLnQgLT4gJ2Egc3RhdGUgfVxuXG5cbmxldCBzdGF0ZV90b19vcHRpb24geCA9IG1hdGNoIHggd2l0aFxuICB8IERvbmUoXywgdikgLT4gU29tZSB2XG4gIHwgRmFpbCBfICAgICAtPiBOb25lXG4gIHwgUGFydGlhbCBfICAtPiBOb25lXG5cbmxldCBmYWlsX3RvX3N0cmluZyBtYXJrcyBlcnIgPVxuICBTdHJpbmcuY29uY2F0IFwiID4gXCIgbWFya3MgXiBcIjogXCIgXiBlcnJcblxubGV0IHN0YXRlX3RvX3Jlc3VsdCB4ID0gbWF0Y2ggeCB3aXRoXG4gIHwgRG9uZShfLCB2KSAgICAgICAgICAtPiBPayB2XG4gIHwgUGFydGlhbCBfICAgICAgICAgICAtPiBFcnJvciBcImluY29tcGxldGUgaW5wdXRcIlxuICB8IEZhaWwoXywgbWFya3MsIGVycikgLT4gRXJyb3IgKGZhaWxfdG9fc3RyaW5nIG1hcmtzIGVycilcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo4MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJhbmdzdHJvbS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2xpYl9pbnB1dF9tbCIsImNhbWxfYmFfZ2V0XzEiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCaWdzdHJpbmdhZiIsIkFzc2VydF9mYWlsdXJlIiwiY3JlYXRlIiwiYnVmZmVyIiwib2ZmIiwibGVuIiwiY29tbWl0dGVkX2J5dGVzIiwibGVuZ3RoIiwidCIsImNsaWVudF9jb21taXR0ZWRfYnl0ZXMiLCJwYXJzZXJfY29tbWl0dGVkX2J5dGVzIiwiYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQiLCJwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMiLCJpbnZhcmlhbnQiLCJvZmZzZXRfaW5fYnVmZmVyIiwicG9zIiwiYXBwbHkiLCJ1bnNhZmVfZ2V0X2NoYXIiLCJ1bnNhZmVfZ2V0X2ludDE2X2xlIiwidW5zYWZlX2dldF9pbnQzMl9sZSIsInVuc2FmZV9nZXRfaW50NjRfbGUiLCJ1bnNhZmVfZ2V0X2ludDE2X2JlIiwidW5zYWZlX2dldF9pbnQzMl9iZSIsInVuc2FmZV9nZXRfaW50NjRfYmUiLCJjb3VudF93aGlsZSIsImkiLCJsaW1pdCIsImNvbW1pdCIsIkFuZ3N0cm9tX0lucHV0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FuZ3N0cm9tL2lucHV0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxPQUFBQyxRQUFBQyxLQUFBQyxLQUFBQztBQUFBQSxJQzBDRTtBQUFBLEdBSVU7QUFBQSxZQUFBQyxPQUFBQyxHQUVtQix1QkFBZ0M7QUFBQSxZQUFBQyx1QkFBQUQsR0FDaEMsWUFBd0I7QUFBQSxZQUFBRSx1QkFBQUYsR0FDeEIsWUFBd0I7QUFBQSxZQUFBRywyQkFBQUgsR0FFbkIsdUJBQzZCO0FBQUEsWUFBQUkseUJBQUFKO0FBQUFBLFFBQUEsTUFFeEI7QUFBQSxJQUE0QjtBQUFBO0FBQUEsWUFBQUssVUFBQUw7QUFBQUEsUUFBQSxNQUdILGlCQUE3QjtBQUFBLElBQUg7QUFBQTtBQUFBLGNBQ2dDO0FBQUEsSUFBaEM7QUFBQTtBQUFBLEdBQThEO0FBQUEsWUFBQU0saUJBQUFOLEdBQUFPLEtBSTlGLG1DQUFzQztBQUFBLFlBQUFDLE1BQUFSLEdBQUFPLEtBQUFWLEtBQUFaO0FBQUFBLFFBQUFXLE1BRzVCO0FBQUEsSUFDVixvQ0FBb0I7QUFBQTtBQUFBLFlBQUFhLGdCQUFBVCxHQUFBTztBQUFBQSxRQUFBWCxNQUdWO0FBQUEsSUFDViwrQkFBbUM7QUFBQTtBQUFBLFlBQUFjLG9CQUFBVixHQUFBTztBQUFBQSxRQUFBWCxNQUd6QjtBQUFBLElBQ1YsNkNBQTRDO0FBQUE7QUFBQSxZQUFBZSxvQkFBQVgsR0FBQU87QUFBQUEsUUFBQVgsTUFHbEM7QUFBQSxJQUNWLDZDQUE0QztBQUFBO0FBQUEsWUFBQWdCLG9CQUFBWixHQUFBTztBQUFBQSxRQUFBWCxNQUdsQztBQUFBLElBQ1YsNkNBQTRDO0FBQUE7QUFBQSxZQUFBaUIsb0JBQUFiLEdBQUFPO0FBQUFBLFFBQUFYLE1BR2xDO0FBQUEsSUFDViw2Q0FBNEM7QUFBQTtBQUFBLFlBQUFrQixvQkFBQWQsR0FBQU87QUFBQUEsUUFBQVgsTUFHbEM7QUFBQSxJQUNWLDZDQUE0QztBQUFBO0FBQUEsWUFBQW1CLG9CQUFBZixHQUFBTztBQUFBQSxRQUFBWCxNQUdsQztBQUFBLElBQ1YsNkNBQTRDO0FBQUE7QUFBQSxZQUFBb0IsWUFBQWhCLEdBQUFPLEtBQUF0QjtBQUFBQTtBQUFBQSxLQUFBVSxTQUc1QztBQUFBLEtBQUFDLE1BQ2E7QUFBQSxLQUFBcUIsSUFDYjtBQUFBLEtBQUFDLFFBQ0E7QUFBQSxJQUNBO0FBQUEsd0JBQW9CLGNBQUUsOEJBQ3BCO0FBQUEsS0FFRjtBQUFBO0FBQUEsR0FBUTtBQUFBLFlBQUFDLE9BQUFuQixHQUFBTyxLQUlSLHFCQUErQjtBQUFBO0FBQUEsSUFBQWE7QUFBQUEsTUQ3R2pDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbnR5cGUgdCA9XG4gIHsgbXV0YWJsZSBwYXJzZXJfY29tbWl0dGVkX2J5dGVzIDogaW50XG4gIDsgY2xpZW50X2NvbW1pdHRlZF9ieXRlcyAgICAgICAgIDogaW50XG4gIDsgb2ZmICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50XG4gIDsgbGVuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50XG4gIDsgYnVmZmVyICAgICAgICAgICAgICAgICAgICAgICAgIDogQmlnc3RyaW5nYWYudFxuICB9XG5cbmxldCBjcmVhdGUgYnVmZmVyIH5vZmYgfmxlbiB+Y29tbWl0dGVkX2J5dGVzID1cbiAgeyBwYXJzZXJfY29tbWl0dGVkX2J5dGVzID0gY29tbWl0dGVkX2J5dGVzXG4gIDsgY2xpZW50X2NvbW1pdHRlZF9ieXRlcyA9IGNvbW1pdHRlZF9ieXRlc1xuICA7IG9mZlxuICA7IGxlblxuICA7IGJ1ZmZlciB9XG5cbmxldCBsZW5ndGggICAgICAgICAgICAgICAgIHQgPSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXMgKyB0LmxlblxubGV0IGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgdCA9IHQuY2xpZW50X2NvbW1pdHRlZF9ieXRlc1xubGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCA9IHQucGFyc2VyX2NvbW1pdHRlZF9ieXRlc1xuXG5sZXQgY29tbWl0dGVkX2J5dGVzX2Rpc2NyZXBhbmN5IHQgPSB0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgLSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXNcbmxldCBieXRlc19mb3JfY2xpZW50X3RvX2NvbW1pdCAgdCA9IGNvbW1pdHRlZF9ieXRlc19kaXNjcmVwYW5jeSB0XG5cbmxldCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdCA9IHQubGVuIC0gYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgdFxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBhc3NlcnQgKHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCArIHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0ID0gbGVuZ3RoIHQpO1xuICBhc3NlcnQgKHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCAtIGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgICB0ID0gYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgdCk7XG47O1xuXG5sZXQgb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyA9XG4gIHQub2ZmICsgcG9zIC0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzXG5cbmxldCBhcHBseSB0IHBvcyBsZW4gfmYgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBmIHQuYnVmZmVyIH5vZmYgfmxlblxuXG5sZXQgdW5zYWZlX2dldF9jaGFyIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldCB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MTZfbGUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2xlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQzMl9sZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfbGUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDY0X2xlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9sZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MTZfYmUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2JlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQzMl9iZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDY0X2JlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSB0LmJ1ZmZlciBvZmZcblxubGV0IGNvdW50X3doaWxlIHQgcG9zIH5mID1cbiAgbGV0IGJ1ZmZlciA9IHQuYnVmZmVyIGluXG4gIGxldCBvZmYgICAgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIGxldCBpICAgICAgPSByZWYgb2ZmIGluXG4gIGxldCBsaW1pdCAgPSB0Lm9mZiArIHQubGVuIGluXG4gIHdoaWxlICFpIDwgbGltaXQgJiYgZiAoQmlnc3RyaW5nYWYudW5zYWZlX2dldCBidWZmZXIgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gICFpIC0gb2ZmXG47O1xuXG5sZXQgY29tbWl0IHQgcG9zID1cbiAgdC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIDwtIHBvc1xuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxOTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5nc3Ryb20uY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIkNhbWxpbnRlcm5hbExhenkiLCJBbmdzdHJvbV9JbnB1dCIsIkJpZ3N0cmluZ2FmIiwiQW5nc3Ryb21fRXhwb3J0ZWRfc3RhdGUiLCJTdGF0ZSIsImZhaWxfayIsImlucHV0IiwicG9zIiwicGFyYW0iLCJtYXJrcyIsIm1zZyIsInN1Y2NlZWRfayIsInYiLCJ0b19leHBvcnRlZF9zdGF0ZSIsIm1hdGNoIiwiY29udGludWUiLCJjb21taXR0ZWQiLCJicyIsIm9mZiIsImxlbiIsIm1vcmUiLCJ4IiwiaSIsInMiLCJzbCIsInBhcnNlIiwicCIsInBhcnNlX2JpZ3N0cmluZyIsInJldHVybiIsImZhaWwiLCJzdWNjIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwic3ltYm9sIiwibSIsInN1Y2MwIiwiaW5wdXQwIiwicG9zMCIsIm1vcmUwIiwic3VjYzEiLCJpbnB1dDEiLCJwb3MxIiwibW9yZTEiLCJsaWZ0IiwibGlmdDIiLCJtMSIsIm0yIiwic3VjYzIiLCJpbnB1dDIiLCJwb3MyIiwibW9yZTIiLCJsaWZ0MyIsIm0zIiwic3VjYzMiLCJpbnB1dDMiLCJwb3MzIiwibW9yZTMiLCJsaWZ0NCIsIm00Iiwic3VjYzQiLCJpbnB1dDQiLCJwb3M0IiwibW9yZTQiLCJhIiwiYiIsIk1vbmFkIiwibWFyayIsInEiLCJDaG9pY2UiLCJNb25hZF91c2VfZm9yX2RlYnVnZ2luZyIsIkFuZ3N0cm9tX1BhcnNlciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9hbmdzdHJvbS9wYXJzZXIubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLFlBQUFDLE9BQUFDLE9BQUFDLEtBQUFDLE9BQUFDLE9BQUFDO0FBQUFBLElDcUJtQixzRUFBa0M7QUFBQSxHQUFhO0FBQUEsWUFBQUMsVUFBQUwsT0FBQUMs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QSxJQUNQO0FBQUEsd0NBQUE3QyxHQUFlLHlCQUFPO0FBQUE7QUFBQSxZQUFBdUQsUUFBQXZELEdBQUF3RCxJQUFBQyxJQUR0QixPQUlrQixTQUpsQix3QkFJeUI7QUFBQSxZQUFBSyxRQUFBOUQsR0FBQXdELElBQUFDLElBQUFNO0FBQUFBLElBSnpCLE9BS3lCLFNBQWYsU0FMViw2QkFLZ0M7QUFBQTtBQUFBLFlBQUFLLFFBQUFwRSxHQUFBd0QsSUFBQUMsSUFBQU0sSUFBQU07QUFBQUEsSUFMaEMsT0FNZ0MsU0FBdEIsa0JBTlYsa0NBTXVDO0FBQUE7QUFBQSxZQUFBekIsU0FBQThCLEdBQUFDO0FBQUFBLElBRXZDLDZDQUFBeEQsT0FBZSxTQUFDO0FBQUE7QUFBQSxZQUFBeUIsU0FBQThCLEdBQUFDO0FBQUFBLElBQ2hCO0FBQUE7QUFBQTtBQUFBLHNCQUFBM0MsR0FBZSxnQ0FBQWIsT0FBZSxTQUFDO0FBQUE7QUFBQTtBQUFBLElBQUE2RDtBQUFBQSxNRDNLakQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IFBhcnRpYWwgb2YgJ2EgcGFydGlhbFxuICAgIHwgTGF6eSAgICBvZiAnYSB0IExhenkudFxuICAgIHwgRG9uZSAgICBvZiBpbnQgKiAnYVxuICAgIHwgRmFpbCAgICBvZiBpbnQgKiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuXG4gIGFuZCAnYSBwYXJ0aWFsID1cbiAgICB7IGNvbW1pdHRlZCA6IGludFxuICAgIDsgY29udGludWUgIDogQmlnc3RyaW5nYWYudCAtPiBvZmY6aW50IC0+IGxlbjppbnQgLT4gTW9yZS50IC0+ICdhIHQgfVxuXG5lbmRcbnR5cGUgJ2Egd2l0aF9zdGF0ZSA9IElucHV0LnQgLT4gIGludCAtPiBNb3JlLnQgLT4gJ2FcblxudHlwZSAnYSBmYWlsdXJlID0gKHN0cmluZyBsaXN0IC0+IHN0cmluZyAtPiAnYSBTdGF0ZS50KSB3aXRoX3N0YXRlXG50eXBlICgnYSwgJ3IpIHN1Y2Nlc3MgPSAoJ2EgLT4gJ3IgU3RhdGUudCkgd2l0aF9zdGF0ZVxuXG50eXBlICdhIHQgPVxuICB7IHJ1biA6ICdyLiAoJ3IgZmFpbHVyZSAtPiAoJ2EsICdyKSBzdWNjZXNzIC0+ICdyIFN0YXRlLnQpIHdpdGhfc3RhdGUgfVxuXG5sZXQgZmFpbF9rICAgIGlucHV0IHBvcyBfIG1hcmtzIG1zZyA9XG4gIFN0YXRlLkZhaWwocG9zIC0gSW5wdXQuY2xpZW50X2NvbW1pdHRlZF9ieXRlcyBpbnB1dCwgbWFya3MsIG1zZylcbmxldCBzdWNjZWVkX2sgaW5wdXQgcG9zIF8gICAgICAgdiAgID1cbiAgU3RhdGUuRG9uZShwb3MgLSBJbnB1dC5jbGllbnRfY29tbWl0dGVkX2J5dGVzIGlucHV0LCB2KVxuXG5sZXQgcmVjIHRvX2V4cG9ydGVkX3N0YXRlID0gZnVuY3Rpb25cbiAgfCBTdGF0ZS5QYXJ0aWFsIHtjb21taXR0ZWQ7Y29udGludWV9IC0+XG4gICAgIEV4cG9ydGVkX3N0YXRlLlBhcnRpYWxcbiAgICAgICB7IGNvbW1pdHRlZFxuICAgICAgIDsgY29udGludWUgPVxuICAgICAgICAgICBmdW4gYnMgfm9mZiB+bGVuIG1vcmUgLT5cbiAgICAgICAgICAgdG9fZXhwb3J0ZWRfc3RhdGUgKGNvbnRpbnVlIGJzIH5vZmYgfmxlbiBtb3JlKX1cbiAgfCBTdGF0ZS5Eb25lIChpLHgpIC0+IEV4cG9ydGVkX3N0YXRlLkRvbmUgKGkseClcbiAgfCBTdGF0ZS5GYWlsIChpLCBzbCwgcykgLT4gRXhwb3J0ZWRfc3RhdGUuRmFpbCAoaSwgc2wsIHMpXG4gIHwgU3RhdGUuTGF6eSB4IC0+IHRvX2V4cG9ydGVkX3N0YXRlIChMYXp5LmZvcmNlIHgpXG5cbmxldCBwYXJzZSBwID1cbiAgbGV0IGlucHV0ID0gSW5wdXQuY3JlYXRlIEJpZ3N0cmluZ2FmLmVtcHR5IH5jb21taXR0ZWRfYnl0ZXM6MCB+b2ZmOjAgfmxlbjowIGluXG4gIHRvX2V4cG9ydGVkX3N0YXRlIChwLnJ1biBpbnB1dCAwIEluY29tcGxldGUgZmFpbF9rIHN1Y2NlZWRfaylcblxubGV0IHBhcnNlX2JpZ3N0cmluZyBwIGlucHV0ID1cbiAgbGV0IGlucHV0ID0gSW5wdXQuY3JlYXRlIGlucHV0IH5jb21taXR0ZWRfYnl0ZXM6MCB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIGlucHV0KSBpblxuICBFeHBvcnRlZF9zdGF0ZS5zdGF0ZV90b19yZXN1bHQgKHRvX2V4cG9ydGVkX3N0YXRlIChwLnJ1biBpbnB1dCAwIENvbXBsZXRlIGZhaWxfayBzdWNjZWVkX2spKVxuXG5tb2R1bGUgTW9uYWQgPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiB2ID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIHZcbiAgICB9XG5cbiAgbGV0IGZhaWwgbXNnID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIF9zdWNjIC0+XG4gICAgICBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIG1zZ1xuICAgIH1cblxuICBsZXQgKD4+PSkgcCBmID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyB2ID0gKGYgdikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKD4+fCkgcCBmID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyB2ID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyAoZiB2KSBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKDwkPikgZiBtID1cbiAgICBtID4+fCBmXG5cbiAgbGV0ICg8Kj4pIGYgbSA9XG4gICAgKCogZiA+Pj0gZnVuIGYgLT4gbSA+PnwgZiAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MwIGlucHV0MCBwb3MwIG1vcmUwIGYgPVxuICAgICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgbSA9IHN1Y2MgaW5wdXQxIHBvczEgbW9yZTEgKGYgbSkgaW5cbiAgICAgICAgbS5ydW4gaW5wdXQwIHBvczAgbW9yZTAgZmFpbCBzdWNjMVxuICAgICAgaW5cbiAgICAgIGYucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzAgfVxuXG4gIGxldCBsaWZ0IGYgbSA9XG4gICAgZiA8JD4gbVxuXG4gIGxldCBsaWZ0MiBmIG0xIG0yID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtMSA9XG4gICAgICAgIGxldCBzdWNjMiBpbnB1dDIgcG9zMiBtb3JlMiBtMiA9IHN1Y2MgaW5wdXQyIHBvczIgbW9yZTIgKGYgbTEgbTIpIGluXG4gICAgICAgIG0yLnJ1biBpbnB1dDEgcG9zMSBtb3JlMSBmYWlsIHN1Y2MyXG4gICAgICBpblxuICAgICAgbTEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzEgfVxuXG4gIGxldCBsaWZ0MyBmIG0xIG0yIG0zID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtMSA9XG4gICAgICAgIGxldCBzdWNjMiBpbnB1dDIgcG9zMiBtb3JlMiBtMiA9XG4gICAgICAgICAgbGV0IHN1Y2MzIGlucHV0MyBwb3MzIG1vcmUzIG0zID1cbiAgICAgICAgICAgIHN1Y2MgaW5wdXQzIHBvczMgbW9yZTMgKGYgbTEgbTIgbTMpIGluXG4gICAgICAgICAgbTMucnVuIGlucHV0MiBwb3MyIG1vcmUyIGZhaWwgc3VjYzMgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0IGxpZnQ0IGYgbTEgbTIgbTMgbTQgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0xID1cbiAgICAgICAgbGV0IHN1Y2MyIGlucHV0MiBwb3MyIG1vcmUyIG0yID1cbiAgICAgICAgICBsZXQgc3VjYzMgaW5wdXQzIHBvczMgbW9yZTMgbTMgPVxuICAgICAgICAgICAgbGV0IHN1Y2M0IGlucHV0NCBwb3M0IG1vcmU0IG00ID1cbiAgICAgICAgICAgICAgc3VjYyBpbnB1dDQgcG9zNCBtb3JlNCAoZiBtMSBtMiBtMyBtNCkgaW5cbiAgICAgICAgICAgIG00LnJ1biBpbnB1dDMgcG9zMyBtb3JlMyBmYWlsIHN1Y2M0IGluXG4gICAgICAgICAgbTMucnVuIGlucHV0MiBwb3MyIG1vcmUyIGZhaWwgc3VjYzMgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0ICggKj4pIGEgYiA9XG4gICAgKCogYSA+Pj0gZnVuIF8gLT4gYiAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIF8gPSBiLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIGEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYydcbiAgICB9XG5cbiAgbGV0ICg8KiApIGEgYiA9XG4gICAgKCogYSA+Pj0gZnVuIHggLT4gYiA+PnwgZnVuIF8gLT4geCAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MwIGlucHV0MCBwb3MwIG1vcmUwIHggPVxuICAgICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgXyA9IHN1Y2MgaW5wdXQxIHBvczEgbW9yZTEgeCBpblxuICAgICAgICBiLnJ1biBpbnB1dDAgcG9zMCBtb3JlMCBmYWlsIHN1Y2MxXG4gICAgICBpblxuICAgICAgYS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMCB9XG5lbmRcblxubW9kdWxlIENob2ljZSA9IHN0cnVjdFxuICBsZXQgKDw/PikgcCBtYXJrID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyBtYXJrcyBtc2cgPVxuICAgICAgICBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIChtYXJrOjptYXJrcykgbXNnIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsJyBzdWNjXG4gICAgfVxuXG4gIGxldCAoPHw+KSBwIHEgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnIG1hcmtzIG1zZyA9XG4gICAgICAgICgqIFRoZSBvbmx5IHR3byBjb25zdHJ1Y3RvcnMgdGhhdCBpbnRyb2R1Y2UgbmV3IGZhaWx1cmUgY29udGludWF0aW9ucyBhcmVcbiAgICAgICAgICogWzw/Pl0gYW5kIFs8fD5dLiBJZiB0aGUgaW5pdGlhbCBpbnB1dCBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICAgICAgICAgKiBvZiB0aGUgY29tbWl0dGVkIGlucHV0LCB0aGVuIGNhbGxpbmcgdGhlIGZhaWx1cmUgY29udGludWF0aW9uIHdpbGxcbiAgICAgICAgICogaGF2ZSB0aGUgZWZmZWN0IG9mIHVud2luZGluZyBhbGwgY2hvaWNlcyBhbmQgY29sbGVjdGluZyBtYXJrcyBhbG9uZ1xuICAgICAgICAgKiB0aGUgd2F5LiAqKVxuICAgICAgICBpZiBwb3MgPCBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIGlucHV0JyB0aGVuXG4gICAgICAgICAgZmFpbCBpbnB1dCcgcG9zJyBtb3JlIG1hcmtzIG1zZ1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcS5ydW4gaW5wdXQnIHBvcyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwnIHN1Y2NcbiAgICB9XG5lbmRcblxubW9kdWxlIE1vbmFkX3VzZV9mb3JfZGVidWdnaW5nID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSBNb25hZC5yZXR1cm5cbiAgbGV0IGZhaWwgICA9IE1vbmFkLmZhaWxcbiAgbGV0ICg+Pj0pICA9IE1vbmFkLig+Pj0pXG5cbiAgbGV0ICg+PnwpIG0gZiA9IG0gPj49IGZ1biB4IC0+IHJldHVybiAoZiB4KVxuXG4gIGxldCAoPCQ+KSBmIG0gPSBtID4+fCBmXG4gIGxldCAoPCo+KSBmIG0gPSBmID4+PSBmdW4gZiAtPiBtID4+fCBmXG5cbiAgbGV0IGxpZnQgID0gKD4+fClcbiAgbGV0IGxpZnQyIGYgbTEgbTIgICAgICAgPSBmIDwkPiBtMSA8Kj4gbTJcbiAgbGV0IGxpZnQzIGYgbTEgbTIgbTMgICAgPSBmIDwkPiBtMSA8Kj4gbTIgPCo+IG0zXG4gIGxldCBsaWZ0NCBmIG0xIG0yIG0zIG00ID0gZiA8JD4gbTEgPCo+IG0yIDwqPiBtMyA8Kj4gbTRcblxuICBsZXQgKCAqPikgYSBiID0gYSA+Pj0gZnVuIF8gLT4gYlxuICBsZXQgKDwqICkgYSBiID0gYSA+Pj0gZnVuIHggLT4gYiA+PnwgZnVuIF8gLT4geFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfbGliX2J1ZmZlcmluZ19tbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwzIiwiYTEiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIkFzc2VydF9mYWlsdXJlIiwiQmlnc3RyaW5nYWYiLCJvZl9iaWdzdHJpbmciLCJvZmYiLCJsZW4iLCJidWYiLCJjcmVhdGUiLCJ3cml0YWJsZV9zcGFjZSIsInQiLCJlbnN1cmUiLCJ0b19jb3B5Iiwib2xkX2xlbiIsIm5ld19sZW4iLCJzcGFjZSIsIm5ld19idWYiLCJ3cml0ZV9wb3MiLCJmZWVkX3N0cmluZyIsInN0ciIsImZlZWRfYmlnc3RyaW5nIiwiYiIsImZlZWRfaW5wdXQiLCJwYXJhbSIsInMiLCJzaGlmdCIsIm4iLCJmb3JfcmVhZGluZyIsInVuY29uc3VtZWQiLCJvcHQiLCJvZl91bmNvbnN1bWVkIiwiQW5nc3Ryb21fQnVmZmVyaW5nIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FuZ3N0cm9tL2J1ZmZlcmluZy5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFMLEdBQUFDLElBQUFFLElBQUFDLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLGFBQUFDLEtBQUFDLEtBQUFDO0FBQUFBLElDTUU7QUFBQTtBQUFBLElBQ1E7QUFBQSxLQUNSO0FBQUEsSUFEOEI7QUFBQSxHQUNiO0FBQUEsWUFBQUMsT0FBQUY7QUFBQUEsSUFHVSxPQUF3QixtQkFBeEIsZ0NBQXdCO0FBQUE7QUFBQSxZQUFBRyxlQUFBQztBQUFBQSxRQUFBLE1BR25EO0FBQUEscURBQXdCO0FBQUEsR0FBUTtBQUFBLFlBQUFDLE9BQUFELEdBQUFFO0FBQUFBO0FBQUFBLEtBQUEsTUFHaEM7QUFBQTtBQUFBLElBbUJtQjtBQUFBLElBQ2Q7QUFBQSxLQWpCTDtBQUFBLEtBQXdFO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBQUMsVUFJMUQ7QUFBQSxLQUFBQyxVQUNkO0FBQUEsS0FBQUMsUUFDWTtBQUFBLElBQ1o7QUFBQTtBQUFBLFVBQUFDLFVBR2M7QUFBQSxNQUNkO0FBQUEsTUFBMEU7QUFBQSxNQUUxRTtBQUFBO0FBQUE7QUFBQSxLQUxFO0FBQUE7QUFBQSxHQVdtQjtBQUFBLFlBQUFDLFVBQUFQLEdBR3JCLHVCQUFhO0FBQUEsWUFBQVEsWUFBQVIsR0FBQUwsS0FBQUMsS0FBQWE7QUFBQUEsSUFHYjtBQUFBO0FBQUEsSUFDQTtBQUFBO0FBQUEsSUFDQTtBQUFBLGNBQ29FO0FBQUEsSUFBcEU7QUFBQSxJQUFzRjtBQUFBO0FBQUEsR0FDbEU7QUFBQSxZQUFBQyxlQUFBVixHQUFBTCxLQUFBQyxLQUFBZTtBQUFBQSxJQUdwQjtBQUFBO0FBQUEsSUFDUTtBQUFBLEtBQW9CO0FBQUEsSUFDNUI7QUFBQSxjQUNzRDtBQUFBLElBQXREO0FBQUEsSUFBd0U7QUFBQTtBQUFBLEdBQ3BEO0FBQUEsWUFBQUMsV0FBQVosR0FBQWE7QUFBQUEsSUFFUDtBQUFBLFNBQUFGLElBQUE7QUFBQSxLQUVrQyxPQUFzQixxQkFBdEIsaUNBQXdCO0FBQUE7QUFBQSxRQUFBRyxJQUYxRDtBQUFBLElBQ0sscURBQ3FEO0FBQUE7QUFBQSxZQUFBQyxNQUFBZixHQUFBZ0I7QUFBQUEsSUFHdkU7QUFBQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUE7QUFBQSxHQUFrQjtBQUFBLFlBQUFDLFlBQUFKO0FBQUFBLFFBQUFoQixNQUVKLFVBQUFGLE1BQUEsVUFBQUMsTUFBQTtBQUFBLElBQ2QsZ0RBQTZCO0FBQUE7QUFBQSxZQUFBc0IsV0FBQUMsS0FBQU47QUFBQUE7QUFBQUEsS0FBQUUsUUFTaEI7QUFBQSxLQUFBbEIsTUFBQTtBQUFBLEtBQUFGLE1BQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsSUFDYixpQkFDQTtBQUFBLElBREE7QUFBQSxHQUN3RDtBQUFBLFlBQUF3QixjQUFBUDtBQUFBQSxRQUFBakIsTUFFeEMsVUFBQUQsTUFBQSxVQUFBRSxNQUFBO0FBQUEsSUFDaEI7QUFBQSxHQUFpQjtBQUFBO0FBQUEsSUFBQXdCO0FBQUFBLE1EbEZuQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwidHlwZSB0ID1cbiAgeyBtdXRhYmxlIGJ1ZiA6IEJpZ3N0cmluZ2FmLnRcbiAgOyBtdXRhYmxlIG9mZiA6IGludFxuICA7IG11dGFibGUgbGVuIDogaW50IH1cblxubGV0IG9mX2JpZ3N0cmluZyB+b2ZmIH5sZW4gYnVmID1cbiAgYXNzZXJ0IChvZmYgPj0gMCk7XG4gIGFzc2VydCAoQmlnc3RyaW5nYWYubGVuZ3RoIGJ1ZiA+PSBsZW4gLSBvZmYpO1xuICB7IGJ1Zjsgb2ZmOyBsZW4gfVxuXG5sZXQgY3JlYXRlIGxlbiA9XG4gIG9mX2JpZ3N0cmluZyB+b2ZmOjAgfmxlbjowIChCaWdzdHJpbmdhZi5jcmVhdGUgbGVuKVxuXG5sZXQgd3JpdGFibGVfc3BhY2UgdCA9XG4gIEJpZ3N0cmluZ2FmLmxlbmd0aCB0LmJ1ZiAtIHQubGVuXG5cbmxldCB0cmFpbGluZ19zcGFjZSB0ID1cbiAgQmlnc3RyaW5nYWYubGVuZ3RoIHQuYnVmIC0gKHQub2ZmICsgdC5sZW4pXG5cbmxldCBjb21wcmVzcyB0ID1cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXQgdC5idWYgfnNyY19vZmY6dC5vZmYgdC5idWYgfmRzdF9vZmY6MCB+bGVuOnQubGVuO1xuICB0Lm9mZiA8LSAwXG5cbmxldCBncm93IHQgdG9fY29weSA9XG4gIGxldCBvbGRfbGVuID0gQmlnc3RyaW5nYWYubGVuZ3RoIHQuYnVmIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgbGV0IHNwYWNlID0gd3JpdGFibGVfc3BhY2UgdCBpblxuICB3aGlsZSBzcGFjZSArICFuZXdfbGVuIC0gb2xkX2xlbiA8IHRvX2NvcHkgZG9cbiAgICBuZXdfbGVuIDo9ICgzICogIW5ld19sZW4pIC8gMlxuICBkb25lO1xuICBsZXQgbmV3X2J1ZiA9IEJpZ3N0cmluZ2FmLmNyZWF0ZSAhbmV3X2xlbiBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdCB0LmJ1ZiB+c3JjX29mZjp0Lm9mZiBuZXdfYnVmIH5kc3Rfb2ZmOjAgfmxlbjp0LmxlbjtcbiAgdC5idWYgPC0gbmV3X2J1ZjtcbiAgdC5vZmYgPC0gMFxuXG5sZXQgZW5zdXJlIHQgdG9fY29weSA9XG4gIGlmIHRyYWlsaW5nX3NwYWNlIHQgPCB0b19jb3B5IHRoZW5cbiAgICBpZiB3cml0YWJsZV9zcGFjZSB0ID49IHRvX2NvcHlcbiAgICB0aGVuIGNvbXByZXNzIHRcbiAgICBlbHNlIGdyb3cgdCB0b19jb3B5XG5cbmxldCB3cml0ZV9wb3MgdCA9XG4gIHQub2ZmICsgdC5sZW5cblxubGV0IGZlZWRfc3RyaW5nIHQgfm9mZiB+bGVuIHN0ciA9XG4gIGFzc2VydCAob2ZmID49IDApO1xuICBhc3NlcnQgKFN0cmluZy5sZW5ndGggc3RyID49IGxlbiAtIG9mZik7XG4gIGVuc3VyZSB0IGxlbjtcbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXRfZnJvbV9zdHJpbmcgc3RyIH5zcmNfb2ZmOm9mZiB0LmJ1ZiB+ZHN0X29mZjood3JpdGVfcG9zIHQpIH5sZW47XG4gIHQubGVuIDwtIHQubGVuICsgbGVuXG5cbmxldCBmZWVkX2JpZ3N0cmluZyB0IH5vZmYgfmxlbiBiID1cbiAgYXNzZXJ0IChvZmYgPj0gMCk7XG4gIGFzc2VydCAoQmlnc3RyaW5nYWYubGVuZ3RoIGIgPj0gbGVuIC0gb2ZmKTtcbiAgZW5zdXJlIHQgbGVuO1xuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdCBiIH5zcmNfb2ZmOm9mZiB0LmJ1ZiB+ZHN0X29mZjood3JpdGVfcG9zIHQpIH5sZW47XG4gIHQubGVuIDwtIHQubGVuICsgbGVuXG5cbmxldCBmZWVkX2lucHV0IHQgPSBmdW5jdGlvblxuICB8IGBTdHJpbmcgICAgcyAtPiBmZWVkX3N0cmluZyAgICB0IH5vZmY6MCB+bGVuOihTdHJpbmcgICAgIC5sZW5ndGggcykgc1xuICB8IGBCaWdzdHJpbmcgYiAtPiBmZWVkX2JpZ3N0cmluZyB0IH5vZmY6MCB+bGVuOihCaWdzdHJpbmdhZi5sZW5ndGggYikgYlxuXG5sZXQgc2hpZnQgdCBuID1cbiAgYXNzZXJ0ICh0LmxlbiA+PSBuKTtcbiAgdC5vZmYgPC0gdC5vZmYgKyBuO1xuICB0LmxlbiA8LSB0LmxlbiAtIG5cblxubGV0IGZvcl9yZWFkaW5nIHsgYnVmOyBvZmY7IGxlbiB9ID1cbiAgQmlnc3RyaW5nYWYuc3ViIH5vZmYgfmxlbiBidWZcblxubW9kdWxlIFVuY29uc3VtZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGJ1ZiA6IEJpZ3N0cmluZ2FmLnRcbiAgICA7IG9mZiA6IGludFxuICAgIDsgbGVuIDogaW50IH1cbmVuZFxuXG5sZXQgdW5jb25zdW1lZCA/KHNoaWZ0PTApIHsgYnVmOyBvZmY7IGxlbiB9ID1cbiAgYXNzZXJ0IChsZW4gPj0gc2hpZnQpO1xuICB7IFVuY29uc3VtZWQuYnVmOyBvZmYgPSBvZmYgKyBzaGlmdDsgbGVuID0gbGVuIC0gc2hpZnQgfVxuXG5sZXQgb2ZfdW5jb25zdW1lZCB7IFVuY29uc3VtZWQuYnVmOyBvZmY7IGxlbiB9ID1cbiAgeyBidWY7IG9mZjsgbGVuIH1cblxudHlwZSB1bmNvbnN1bWVkID0gVW5jb25zdW1lZC50ID1cbiAgeyBidWYgOiBCaWdzdHJpbmdhZi50XG4gIDsgb2ZmIDogaW50XG4gIDsgbGVuIDogaW50IH1cbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo2NDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5nc3Ryb20uY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9jb3VudF93aGlsZTEiLCJjc3Rfbm90X2Vub3VnaF9pbnB1dCIsImNzdF9zYXRpc2Z5IiwiY3N0X3NhdGlzZnlfQyIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfb2JqX3RhZyIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiY3N0IiwiU3RkbGliIiwiQW5nc3Ryb21fSW5wdXQiLCJCaWdzdHJpbmdhZiIsIlN0ZGxpYl9JbnQ2NCIsIlN0ZGxpYl9JbnQzMiIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYl9DaGFyIiwiU3RkbGliX1ByaW50ZiIsIkFuZ3N0cm9tX0J1ZmZlcmluZyIsIkFuZ3N0cm9tX1BhcnNlciIsIkFuZ3N0cm9tX0V4cG9ydGVkX3N0YXRlIiwiU3RkbGliX1N5cyIsInBhcnNlIiwicGFyc2VfYmlnc3RyaW5nIiwic3RhdGVfdG9fb3B0aW9uIiwiZmFpbF90b19zdHJpbmciLCJzdGF0ZV90b19yZXN1bHQiLCJyZXR1cm4iLCJmYWlsIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwic3ltYm9sIiwibGlmdCIsImxpZnQyIiwibGlmdDMiLCJsaWZ0NCIsImluY2x1ZGUiLCJjc3RfcGFyc2VfaW52YWxpZF9hcmd1bWVudF9pbmkiLCJjc3RfcHJvbXB0X2lucHV0X3NocnVuayIsImZyb21fdW5idWZmZXJlZF9zdGF0ZSIsImJ1ZmZlcmluZyIsInBhcmFtIiwicCIsInYiLCJjb25zdW1lZCIsInVuY29uc3VtZWQiLCJtc2ciLCJtYXJrcyIsIm9wdCIsImluaXRpYWxfYnVmZmVyX3NpemUiLCJpbnB1dCIsIm1vcmUiLCJmb3JfcmVhZGluZyIsImZlZWQiLCJzdGF0ZSIsImsiLCJzdGF0ZV90b191bmNvbnN1bWVkIiwicHJvbXB0IiwicG9zIiwic3VjYyIsInBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyIsInBhcnNlcl9jb21taXR0ZWRfYnl0ZXMiLCJjb250aW51ZSIsIm9mZiIsImxlbiIsImRlbWFuZF9pbnB1dCIsImVuc3VyZV9zdXNwZW5kZWQiLCJuIiwiZ28iLCJ1bnNhZmVfYXBwbHkiLCJlbnN1cmUiLCJhdF9lbmRfb2ZfaW5wdXQiLCJjc3RfZW5kX29mX2lucHV0IiwiZW5kX29mX2lucHV0IiwiY3N0X2FkdmFuY2UiLCJhZHZhbmNlIiwiYXZhaWxhYmxlIiwiY29tbWl0IiwidW5zYWZlX2xvb2thaGVhZCIsInBlZWtfY2hhciIsInBlZWtfY2hhcl9mYWlsIiwic2F0aXNmeSIsImMiLCJjaGFyIiwibm90X2NoYXIiLCJhbnlfY2hhciIsImludDgiLCJpIiwiYW55X3VpbnQ4IiwicyIsImFueV9pbnQ4IiwiY3N0X3NraXAiLCJjc3RfdGFrZV9uXzAiLCJjc3RfdGFrZV9iaWdzdHJpbmdfbl8wIiwiY3N0X25vX21vcmVfY2hvaWNlcyIsImNzdF9BbmdzdHJvbV9maXhfZGlyZWN0X25vdF9zZSIsInNraXAiLCJjb3VudF93aGlsZSIsImluaXQiLCJ3aXRoX2J1ZmZlciIsImlucHV0X2xlbiIsImNvdW50X3doaWxlMSIsInN0cmluZyIsImJ1ZmZlciIsIm1hdGNoIiwieCIsImUiLCJzdHJpbmdfY2kiLCJza2lwX3doaWxlIiwidGFrZSIsInRha2VfYmlnc3RyaW5nIiwidGFrZV9iaWdzdHJpbmdfd2hpbGUiLCJ0YWtlX2JpZ3N0cmluZ193aGlsZTEiLCJ0YWtlX2JpZ3N0cmluZ190aWxsIiwicGVla19zdHJpbmciLCJ0YWtlX3doaWxlIiwidGFrZV93aGlsZTEiLCJ0YWtlX3RpbGwiLCJjaG9pY2UiLCJwcyIsImZhaWx1cmVfbXNnIiwibm90c2V0IiwiYnVmIiwiZml4X2RpcmVjdCIsInIiLCJmaXhfbGF6eSIsIm1heF9zdGVwcyIsInN0ZXBzIiwiY3N0X0xFX2ludDY0IiwiY3N0X0xFX2ludDMyIiwiY3N0X0xFX2ludDE2IiwiY3N0X0JFX2ludDY0IiwiY3N0X0JFX2ludDMyIiwiY3N0X0JFX2ludDE2IiwiY3N0X2NvbnN1bWVkX3BhcnNlcl9jb21taXR0ZWQiLCJjc3RfY291bnRfbl8wIiwiY3N0X2VuZF9vZl9saW5lIiwiZml4Iiwib3B0aW9uIiwiY29ucyIsInhzIiwibGlzdCIsImNvdW50IiwibG9vcCIsIm1hbnkiLCJtIiwibWFueTEiLCJtYW55X3RpbGwiLCJ0Iiwic2VwX2J5MSIsInNlcF9ieSIsInNraXBfbWFueSIsInNraXBfbWFueTEiLCJlbmRfb2ZfbGluZSIsInNjYW4iLCJwYXJzZXIiLCJzY2FuX3N0YXRlIiwic2Nhbl9zdHJpbmciLCJjb25zdW1lX3dpdGgiLCJjb25zdW1lZF9iaWdzdHJpbmciLCJib3RoIiwiYSIsImIiLCJtYXAiLCJiaW5kIiwibWFwMiIsIm1hcDMiLCJtYXA0IiwiZCIsIkxldF9zeW50YXgiLCJpbnQxNiIsImludDMyIiwiaW50NjQiLCJhbnlfdWludDE2IiwiYnMiLCJhbnlfaW50MTYiLCJhbnlfaW50MzIiLCJhbnlfaW50NjQiLCJhbnlfZmxvYXQiLCJhbnlfZG91YmxlIiwicGVlayIsImNoZWNrIiwiQ29uc3VtZSIsImNvbnN1bWUiLCJwYXJzZV9zdHJpbmciLCJBbmdzdHJvbSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9hbmdzdHJvbS9hbmdzdHJvbS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtB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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEcnNCckgiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNiBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxubW9kdWxlIEJpZ2FycmF5ID0gc3RydWN0XG4gICgqIERvIG5vdCBhY2Nlc3MgQmlnYXJyYXkgb3BlcmF0aW9ucyBkaXJlY3RseS4gSWYgYW55dGhpbmcncyBuZWVkZWQsIHJlZmVyIHRvXG4gICAqIHRoZSBpbnRlcm5hbCBCaWdzdHJpbmcgbW9kdWxlLiAqKVxuZW5kXG5cbnR5cGUgYmlnc3RyaW5nID0gQmlnc3RyaW5nYWYudFxuXG5cbm1vZHVsZSBVbmJ1ZmZlcmVkID0gc3RydWN0XG4gIGluY2x1ZGUgUGFyc2VyXG5cbiAgaW5jbHVkZSBFeHBvcnRlZF9zdGF0ZVxuXG4gIHR5cGUgbW9yZSA9IE1vcmUudCA9XG4gICAgfCBDb21wbGV0ZVxuICAgIHwgSW5jb21wbGV0ZVxuZW5kXG5cbmluY2x1ZGUgVW5idWZmZXJlZFxuaW5jbHVkZSBQYXJzZXIuTW9uYWRcbmluY2x1ZGUgUGFyc2VyLkNob2ljZVxuXG5tb2R1bGUgQnVmZmVyZWQgPSBzdHJ1Y3RcbiAgdHlwZSB1bmNvbnN1bWVkID0gQnVmZmVyaW5nLnVuY29uc3VtZWQgPVxuICAgIHsgYnVmIDogYmlnc3RyaW5nXG4gICAgOyBvZmYgOiBpbnRcbiAgICA7IGxlbiA6IGludCB9XG5cbiAgdHlwZSBpbnB1dCA9XG4gICAgWyBgQmlnc3RyaW5nIG9mIGJpZ3N0cmluZ1xuICAgIHwgYFN0cmluZyAgICBvZiBzdHJpbmcgXVxuXG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgUGFydGlhbCBvZiAoWyBpbnB1dCB8IGBFb2YgXSAtPiAnYSBzdGF0ZSlcbiAgICB8IERvbmUgICAgb2YgdW5jb25zdW1lZCAqICdhXG4gICAgfCBGYWlsICAgIG9mIHVuY29uc3VtZWQgKiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuXG4gIGxldCBmcm9tX3VuYnVmZmVyZWRfc3RhdGUgfmYgYnVmZmVyaW5nID0gZnVuY3Rpb25cbiAgICB8IFVuYnVmZmVyZWQuUGFydGlhbCBwICAgICAgICAgLT4gUGFydGlhbCAoZiBwKVxuICAgIHwgVW5idWZmZXJlZC5Eb25lKGNvbnN1bWVkLCB2KSAtPlxuICAgICAgbGV0IHVuY29uc3VtZWQgPSBCdWZmZXJpbmcudW5jb25zdW1lZCB+c2hpZnQ6Y29uc3VtZWQgYnVmZmVyaW5nIGluXG4gICAgICBEb25lKHVuY29uc3VtZWQsIHYpXG4gICAgfCBVbmJ1ZmZlcmVkLkZhaWwoY29uc3VtZWQsIG1hcmtzLCBtc2cpIC0+XG4gICAgICBsZXQgdW5jb25zdW1lZCA9IEJ1ZmZlcmluZy51bmNvbnN1bWVkIH5zaGlmdDpjb25zdW1lZCBidWZmZXJpbmcgaW5cbiAgICAgIEZhaWwodW5jb25zdW1lZCwgbWFya3MsIG1zZylcblxuICBsZXQgcGFyc2UgPyhpbml0aWFsX2J1ZmZlcl9zaXplPTB4MTAwMCkgcCA9XG4gICAgaWYgaW5pdGlhbF9idWZmZXJfc2l6ZSA8IDEgdGhlblxuICAgICAgZmFpbHdpdGggXCJwYXJzZTogaW52YWxpZCBhcmd1bWVudCwgaW5pdGlhbF9idWZmZXJfc2l6ZSA8IDFcIjtcbiAgICBsZXQgYnVmZmVyaW5nID0gQnVmZmVyaW5nLmNyZWF0ZSBpbml0aWFsX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IHJlYyBmIHAgaW5wdXQgPVxuICAgICAgQnVmZmVyaW5nLnNoaWZ0IGJ1ZmZlcmluZyBwLmNvbW1pdHRlZDtcbiAgICAgIGxldCBtb3JlIDogTW9yZS50ID1cbiAgICAgICAgbWF0Y2ggaW5wdXQgd2l0aFxuICAgICAgICB8IGBFb2YgICAgICAgICAgICAtPiBDb21wbGV0ZVxuICAgICAgICB8ICNpbnB1dCBhcyBpbnB1dCAtPlxuICAgICAgICAgIEJ1ZmZlcmluZy5mZWVkX2lucHV0IGJ1ZmZlcmluZyBpbnB1dDtcbiAgICAgICAgICBJbmNvbXBsZXRlXG4gICAgICBpblxuICAgICAgbGV0IGZvcl9yZWFkaW5nID0gQnVmZmVyaW5nLmZvcl9yZWFkaW5nIGJ1ZmZlcmluZyBpblxuICAgICAgcC5jb250aW51ZSBmb3JfcmVhZGluZyB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIGZvcl9yZWFkaW5nKSBtb3JlXG4gICAgICB8PiBmcm9tX3VuYnVmZmVyZWRfc3RhdGUgYnVmZmVyaW5nIH5mXG4gICAgaW5cbiAgICBVbmJ1ZmZlcmVkLnBhcnNlIHBcbiAgICB8PiBmcm9tX3VuYnVmZmVyZWRfc3RhdGUgYnVmZmVyaW5nIH5mXG5cbiAgbGV0IGZlZWQgc3RhdGUgaW5wdXQgPVxuICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICB8IFBhcnRpYWwgayAtPiBrIGlucHV0XG4gICAgfCBGYWlsKHVuY29uc3VtZWQsIG1hcmtzLCBtc2cpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBpbnB1dCB3aXRoXG4gICAgICB8IGBFb2YgICAtPiBzdGF0ZVxuICAgICAgfCAjaW5wdXQgYXMgaW5wdXQgLT5cbiAgICAgICAgbGV0IGJ1ZmZlcmluZyA9IEJ1ZmZlcmluZy5vZl91bmNvbnN1bWVkIHVuY29uc3VtZWQgaW5cbiAgICAgICAgQnVmZmVyaW5nLmZlZWRfaW5wdXQgYnVmZmVyaW5nIGlucHV0O1xuICAgICAgICBGYWlsKEJ1ZmZlcmluZy51bmNvbnN1bWVkIGJ1ZmZlcmluZywgbWFya3MsIG1zZylcbiAgICAgIGVuZFxuICAgIHwgRG9uZSh1bmNvbnN1bWVkLCB2KSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggaW5wdXQgd2l0aFxuICAgICAgfCBgRW9mICAgLT4gc3RhdGVcbiAgICAgIHwgI2lucHV0IGFzIGlucHV0IC0+XG4gICAgICAgIGxldCBidWZmZXJpbmcgPSBCdWZmZXJpbmcub2ZfdW5jb25zdW1lZCB1bmNvbnN1bWVkIGluXG4gICAgICAgIEJ1ZmZlcmluZy5mZWVkX2lucHV0IGJ1ZmZlcmluZyBpbnB1dDtcbiAgICAgICAgRG9uZShCdWZmZXJpbmcudW5jb25zdW1lZCBidWZmZXJpbmcsIHYpXG4gICAgICBlbmRcblxuICBsZXQgc3RhdGVfdG9fb3B0aW9uID0gZnVuY3Rpb25cbiAgICB8IERvbmUoXywgdikgLT4gU29tZSB2XG4gICAgfCBQYXJ0aWFsIF8gIC0+IE5vbmVcbiAgICB8IEZhaWwgXyAgICAgLT4gTm9uZVxuXG4gIGxldCBzdGF0ZV90b19yZXN1bHQgPSBmdW5jdGlvblxuICAgIHwgUGFydGlhbCBfICAgICAgICAgICAtPiBFcnJvciBcImluY29tcGxldGUgaW5wdXRcIlxuICAgIHwgRG9uZShfLCB2KSAgICAgICAgICAtPiBPayB2XG4gICAgfCBGYWlsKF8sIG1hcmtzLCBtc2cpIC0+IEVycm9yIChVbmJ1ZmZlcmVkLmZhaWxfdG9fc3RyaW5nIG1hcmtzIG1zZylcblxuICBsZXQgc3RhdGVfdG9fdW5jb25zdW1lZCA9IGZ1bmN0aW9uXG4gICAgfCBEb25lKHVuY29uc3VtZWQsIF8pXG4gICAgfCBGYWlsKHVuY29uc3VtZWQsIF8sIF8pIC0+IFNvbWUgdW5jb25zdW1lZFxuICAgIHwgUGFydGlhbCBfICAgICAgICAgICAgICAtPiBOb25lXG5cbmVuZFxuXG4oKiogQkVHSU46IGdldHRpbmcgaW5wdXQgKilcblxubGV0IHJlYyBwcm9tcHQgaW5wdXQgcG9zIGZhaWwgc3VjYyA9XG4gICgqIFtwcm9tcHRdIHNob3VsZCBvbmx5IGNhbGwgW3N1Y2NdIGlmIGl0IGhhcyByZWNlaXZlZCBtb3JlIGlucHV0LiBJZiB0aGVyZVxuICAgKiBpcyBubyBjaGFuY2UgdGhhdCB0aGUgaW5wdXQgd2lsbCBncm93LCBpLmUuLCBbbW9yZSA9IENvbXBsZXRlXSwgdGhlblxuICAgKiBbcHJvbXB0XSBzaG91bGQgY2FsbCBbZmFpbF0uIE90aGVyd2lzZSAoaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGlucHV0XG4gICAqIGhhc24ndCBncm93biBidXQgW21vcmUgPSBJbmNvbXBsZXRlXSBqdXN0IHByb21wdCBhZ2Fpbi4gKilcbiAgbGV0IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyA9IElucHV0LnBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyBpbnB1dCBpblxuICBsZXQgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyAgID0gSW5wdXQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyAgIGlucHV0IGluXG4gICgqIFRoZSBjb250aW51YXRpb24gc2hvdWxkIG5vdCBob2xkIGFueSByZWZlcmVuY2VzIHRvIGlucHV0IGFib3ZlLiAqKVxuICBsZXQgY29udGludWUgaW5wdXQgfm9mZiB+bGVuIG1vcmUgPVxuICAgIGlmIGxlbiA8IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0aGVuXG4gICAgICBmYWlsd2l0aCBcInByb21wdDogaW5wdXQgc2hydW5rIVwiO1xuICAgIGxldCBpbnB1dCA9IElucHV0LmNyZWF0ZSBpbnB1dCB+b2ZmIH5sZW4gfmNvbW1pdHRlZF9ieXRlczpwYXJzZXJfY29tbWl0dGVkX2J5dGVzIGluXG4gICAgaWYgbGVuID0gcGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIHRoZW5cbiAgICAgIG1hdGNoIChtb3JlIDogTW9yZS50KSB3aXRoXG4gICAgICB8IENvbXBsZXRlICAgLT4gZmFpbCBpbnB1dCBwb3MgTW9yZS5Db21wbGV0ZVxuICAgICAgfCBJbmNvbXBsZXRlIC0+IHByb21wdCBpbnB1dCBwb3MgZmFpbCBzdWNjXG4gICAgZWxzZVxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZVxuICBpblxuICBTdGF0ZS5QYXJ0aWFsIHsgY29tbWl0dGVkID0gSW5wdXQuYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgaW5wdXQ7IGNvbnRpbnVlIH1cblxubGV0IGRlbWFuZF9pbnB1dCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIG1hdGNoIChtb3JlIDogTW9yZS50KSB3aXRoXG4gICAgfCBDb21wbGV0ZSAgIC0+IGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJub3QgZW5vdWdoIGlucHV0XCJcbiAgICB8IEluY29tcGxldGUgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgKClcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9IGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10gXCJub3QgZW5vdWdoIGlucHV0XCIgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgZW5zdXJlX3N1c3BlbmRlZCBuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyA9XG4gIGxldCByZWMgZ28gPVxuICAgIHsgcnVuID0gZnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwnIHN1Y2MnIC0+XG4gICAgICBpZiBwb3MnICsgbiA8PSBJbnB1dC5sZW5ndGggaW5wdXQnIHRoZW5cbiAgICAgICAgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKClcbiAgICAgIGVsc2VcbiAgICAgICAgKGRlbWFuZF9pbnB1dCAqPiBnbykucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwnIHN1Y2MnXG4gICAgfVxuICBpblxuICAoZGVtYW5kX2lucHV0ICo+IGdvKS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjXG5cbmxldCB1bnNhZmVfYXBwbHkgbGVuIH5mID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgIHN1Y2MgaW5wdXQgKHBvcyArIGxlbikgbW9yZSAoSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGxlbiB+ZilcbiAgfVxuXG5sZXQgdW5zYWZlX2FwcGx5X29wdCBsZW4gfmYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBtYXRjaCBJbnB1dC5hcHBseSBpbnB1dCBwb3MgbGVuIH5mIHdpdGhcbiAgICB8IEVycm9yIGUgLT4gZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBlXG4gICAgfCBPayAgICB4IC0+IHN1Y2MgaW5wdXQgKHBvcyArIGxlbikgbW9yZSB4XG4gIH1cblxubGV0IGVuc3VyZSBuIHAgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgKyBuIDw9IElucHV0Lmxlbmd0aCBpbnB1dFxuICAgIHRoZW4gcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnICgpID0gcC5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBlbnN1cmVfc3VzcGVuZGVkIG4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbigqKiBFTkQ6IGdldHRpbmcgaW5wdXQgKilcblxubGV0IGF0X2VuZF9vZl9pbnB1dCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF8gc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dCB0aGVuXG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIGZhbHNlXG4gICAgZWxzZSBtYXRjaCBtb3JlIHdpdGhcbiAgICB8IENvbXBsZXRlIC0+IHN1Y2MgaW5wdXQgcG9zIG1vcmUgdHJ1ZVxuICAgIHwgSW5jb21wbGV0ZSAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyBmYWxzZVxuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyB0cnVlIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxubGV0IGVuZF9vZl9pbnB1dCA9XG4gIGF0X2VuZF9vZl9pbnB1dFxuICA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgIC0+IHJldHVybiAoKVxuICAgIHwgZmFsc2UgLT4gZmFpbCBcImVuZF9vZl9pbnB1dFwiXG5cbmxldCBhZHZhbmNlIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJhZHZhbmNlXCJcbiAgZWxzZVxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT4gc3VjYyBpbnB1dCAocG9zICsgbikgbW9yZSAoKSB9XG4gICAgaW5cbiAgICBlbnN1cmUgbiBwXG5cbmxldCBwb3MgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+IHN1Y2MgaW5wdXQgcG9zIG1vcmUgcG9zIH1cblxubGV0IGF2YWlsYWJsZSA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBzdWNjIGlucHV0IHBvcyBtb3JlIChJbnB1dC5sZW5ndGggaW5wdXQgLSBwb3MpXG4gIH1cblxubGV0IGNvbW1pdCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBJbnB1dC5jb21taXQgaW5wdXQgcG9zO1xuICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgKCkgfVxuXG4oKiBEbyBub3QgdXNlIHRoaXMgaWYgW3BdIGNvbnRhaW5zIGEgW2NvbW1pdF0uICopXG5sZXQgdW5zYWZlX2xvb2thaGVhZCBwID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IHN1Y2MnIGlucHV0JyBfIG1vcmUnIHYgPSBzdWNjIGlucHV0JyBwb3MgbW9yZScgdiBpblxuICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG5sZXQgcGVla19jaGFyID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dCB0aGVuXG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIChTb21lIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKSlcbiAgICBlbHNlIGlmIG1vcmUgPSBDb21wbGV0ZSB0aGVuXG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIE5vbmVcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIChTb21lIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQnIHBvcycpKVxuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyBOb25lIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxuKCogVGhpcyBwYXJzZXIgaXMgdG9vIGltcG9ydGFudCB0byBub3QgYmUgb3B0aW1pemVkLiBEbyBhIGN1c3RvbSBqb2IuICopXG5sZXQgcmVjIHBlZWtfY2hhcl9mYWlsID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgaWYgcG9zIDwgSW5wdXQubGVuZ3RoIGlucHV0XG4gICAgdGhlbiBzdWNjIGlucHV0IHBvcyBtb3JlIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKVxuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKSA9XG4gICAgICAgIHBlZWtfY2hhcl9mYWlsLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIGVuc3VyZV9zdXNwZW5kZWQgMSBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnIH1cblxubGV0IHNhdGlzZnkgZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dCB0aGVuXG4gICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIGlmIGYgY1xuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGNcbiAgICAgIGVsc2UgUHJpbnRmLmtzcHJpbnRmIChmYWlsIGlucHV0IHBvcyBtb3JlIFtdKSBcInNhdGlzZnk6ICVDXCIgY1xuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKSA9XG4gICAgICAgIGxldCBjID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0JyBwb3MnIGluXG4gICAgICAgIGlmIGYgY1xuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQnIChwb3MnICsgMSkgbW9yZScgY1xuICAgICAgICBlbHNlIFByaW50Zi5rc3ByaW50ZiAoZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyBbXSkgXCJzYXRpc2Z5OiAlQ1wiIGNcbiAgICAgIGluXG4gICAgICBlbnN1cmVfc3VzcGVuZGVkIDEgaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbmxldCBjaGFyIGMgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBpZiBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zID0gY1xuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGNcbiAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSAoUHJpbnRmLnNwcmludGYgXCJjaGFyICVDXCIgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBub3RfY2hhciBjID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGMnID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyBpblxuICAgICAgaWYgYyA8PiBjJ1xuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGMnXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gKFByaW50Zi5zcHJpbnRmIFwibm90IGNoYXIgJUNcIiBjKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGFueV9jaGFyID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICAgIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MpICB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGludDggaSA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKSBpblxuICAgICAgaWYgYyA9IGkgbGFuZCAweGZmXG4gICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgY1xuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIChQcmludGYuc3ByaW50ZiBcImludDggJWRcIiBpKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGFueV91aW50OCA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKENoYXIuY29kZSBjKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGFueV9pbnQ4ID1cbiAgKCogaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbCNWYXJpYWJsZVNpZ25FeHRlbmRSaXNreSAqKVxuICBsZXQgcyA9IFN5cy5pbnRfc2l6ZSAtIDggaW5cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyBpblxuICAgICAgc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSAoKENoYXIuY29kZSBjIGxzbCBzKSBhc3IgcykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBza2lwIGYgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBpZiBmIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKVxuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlICgpXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJza2lwXCIgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCByZWMgY291bnRfd2hpbGUgfmluaXQgfmYgfndpdGhfYnVmZmVyID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IGxlbiAgICAgICAgID0gSW5wdXQuY291bnRfd2hpbGUgaW5wdXQgKHBvcyArIGluaXQpIH5mIGluXG4gICAgbGV0IGlucHV0X2xlbiAgID0gSW5wdXQubGVuZ3RoIGlucHV0IGluXG4gICAgbGV0IGluaXQnICAgICAgID0gaW5pdCArIGxlbiBpblxuICAgICgqIENoZWNrIGlmIHRoZSBsb29wIHRlcm1pbmF0ZWQgYmVjYXVzZSBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGlucHV0XG4gICAgICogYnVmZmVyLiBJZiBzbywgdGhlbiBwcm9tcHQgZm9yIGFkZGl0aW9uYWwgaW5wdXQgYW5kIGNvbnRpbnVlLiAqKVxuICAgIGlmIHBvcyArIGluaXQnIDwgaW5wdXRfbGVuIHx8IG1vcmUgPSBDb21wbGV0ZVxuICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgaW5pdCcpIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBpbml0JyB+Zjp3aXRoX2J1ZmZlcilcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAoY291bnRfd2hpbGUgfmluaXQ6aW5pdCcgfmYgfndpdGhfYnVmZmVyKS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICBzdWNjIGlucHV0JyAocG9zJyArIGluaXQnKSBtb3JlJyAoSW5wdXQuYXBwbHkgaW5wdXQnIHBvcycgaW5pdCcgfmY6d2l0aF9idWZmZXIpXG4gICAgICBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCByZWMgY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBsZW4gICAgICAgICA9IElucHV0LmNvdW50X3doaWxlIGlucHV0IHBvcyB+ZiBpblxuICAgIGxldCBpbnB1dF9sZW4gICA9IElucHV0Lmxlbmd0aCBpbnB1dCBpblxuICAgICgqIENoZWNrIGlmIHRoZSBsb29wIHRlcm1pbmF0ZWQgYmVjYXVzZSBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGlucHV0XG4gICAgICogYnVmZmVyLiBJZiBzbywgdGhlbiBwcm9tcHQgZm9yIGFkZGl0aW9uYWwgaW5wdXQgYW5kIGNvbnRpbnVlLiAqKVxuICAgIGlmIGxlbiA8IDFcbiAgICB0aGVuXG4gICAgICBpZiBwb3MgPCBpbnB1dF9sZW4gfHwgbW9yZSA9IENvbXBsZXRlXG4gICAgICB0aGVuIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJjb3VudF93aGlsZTFcIlxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAgIChjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyKS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjXG4gICAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgICAgZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyBbXSBcImNvdW50X3doaWxlMVwiXG4gICAgICAgIGluXG4gICAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgICBlbHNlIGlmIHBvcyArIGxlbiA8IGlucHV0X2xlbiB8fCBtb3JlID0gQ29tcGxldGVcbiAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGxlbikgbW9yZSAoSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGxlbiB+Zjp3aXRoX2J1ZmZlcilcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAoY291bnRfd2hpbGUgfmluaXQ6bGVuIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgKHBvcycgKyBsZW4pIG1vcmUnIChJbnB1dC5hcHBseSBpbnB1dCcgcG9zJyBsZW4gfmY6d2l0aF9idWZmZXIpXG4gICAgICBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCBzdHJpbmdfIGYgcyA9XG4gICgqIFhYWChzZWxpb3BvdSk6IEluZWZmaWNpZW50LiBDb3VsZCBjaGVjayBwcmVmaXggZXF1YWxpdHkgdG8gc2hvcnQtY2lyY3VpdFxuICAgKiB0aGUgaW8uICopXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgZW5zdXJlICBsZW4gKHVuc2FmZV9hcHBseV9vcHQgbGVuIH5mOihmdW4gYnVmZmVyIH5vZmYgfmxlbiAtPlxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICB3aGlsZSAhaSA8IGxlbiAmJiBDaGFyLmVxdWFsIChmIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IGJ1ZmZlciAob2ZmICsgIWkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmIChTdHJpbmcudW5zYWZlX2dldCBzICFpKSlcbiAgICBkb1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICBpZiBsZW4gPSAhaVxuICAgIHRoZW4gT2sgKEJpZ3N0cmluZ2FmLnN1YnN0cmluZyBidWZmZXIgfm9mZiB+bGVuKVxuICAgIGVsc2UgRXJyb3IgXCJzdHJpbmdcIikpXG5cbmxldCBzdHJpbmcgcyAgICA9IHN0cmluZ18gKGZ1biB4IC0+IHgpIHNcbmxldCBzdHJpbmdfY2kgcyA9IHN0cmluZ18gQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgc2tpcF93aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6KGZ1biBfIH5vZmY6XyB+bGVuOl8gLT4gKCkpXG5cbmxldCB0YWtlIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJ0YWtlOiBuIDwgMFwiXG4gIGVsc2VcbiAgICBsZXQgbiA9IG1heCBuIDAgaW5cbiAgICBlbnN1cmUgbiAodW5zYWZlX2FwcGx5IG4gfmY6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nKVxuXG5sZXQgdGFrZV9iaWdzdHJpbmcgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gZmFpbCBcInRha2VfYmlnc3RyaW5nOiBuIDwgMFwiXG4gIGVsc2VcbiAgICBsZXQgbiA9IG1heCBuIDAgaW5cbiAgICBlbnN1cmUgbiAodW5zYWZlX2FwcGx5IG4gfmY6Qmlnc3RyaW5nYWYuY29weSlcblxubGV0IHRha2VfYmlnc3RyaW5nX3doaWxlIGYgPVxuICBjb3VudF93aGlsZSB+aW5pdDowIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5jb3B5XG5cbmxldCB0YWtlX2JpZ3N0cmluZ193aGlsZTEgZiA9XG4gIGNvdW50X3doaWxlMSB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuY29weVxuXG5sZXQgdGFrZV9iaWdzdHJpbmdfdGlsbCBmID1cbiAgdGFrZV9iaWdzdHJpbmdfd2hpbGUgKGZ1biBjIC0+IG5vdCAoZiBjKSlcblxubGV0IHBlZWtfc3RyaW5nIG4gPVxuICB1bnNhZmVfbG9va2FoZWFkICh0YWtlIG4pXG5cbmxldCB0YWtlX3doaWxlIGYgPVxuICBjb3VudF93aGlsZSB+aW5pdDowIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5zdWJzdHJpbmdcblxubGV0IHRha2Vfd2hpbGUxIGYgPVxuICBjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLnN1YnN0cmluZ1xuXG5sZXQgdGFrZV90aWxsIGYgPVxuICB0YWtlX3doaWxlIChmdW4gYyAtPiBub3QgKGYgYykpXG5cbmxldCBjaG9pY2UgPyhmYWlsdXJlX21zZz1cIm5vIG1vcmUgY2hvaWNlc1wiKSBwcyA9XG4gIExpc3QuZm9sZF9yaWdodCAoPHw+KSBwcyAoZmFpbCBmYWlsdXJlX21zZylcblxubGV0IG5vdHNldCA9IHsgcnVuID0gZnVuIF9idWYgX3BvcyBfbW9yZSBfZmFpbCBfc3VjYyAtPiBmYWlsd2l0aCBcIkFuZ3N0cm9tLmZpeF9kaXJlY3Qgbm90IHNldFwiIH1cblxubGV0IGZpeF9kaXJlY3QgZiA9XG4gIGxldCByZWMgcCA9IHJlZiBub3RzZXRcbiAgYW5kIHIgPSB7IHJ1biA9IGZ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgKCFwKS5ydW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYyB9XG4gIGluXG4gIHAgOj0gZiByO1xuICByXG5cbmxldCBmaXhfbGF6eSB+bWF4X3N0ZXBzIGYgPVxuICBsZXQgc3RlcHMgPSByZWYgbWF4X3N0ZXBzIGluXG4gIGxldCByZWMgcCA9IGxhenkgKGYgcilcbiAgYW5kIHIgPSB7IHJ1biA9IGZ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgZGVjciBzdGVwcztcbiAgICBpZiAhc3RlcHMgPCAwXG4gICAgdGhlbiAoXG4gICAgICBzdGVwcyA6PSBtYXhfc3RlcHM7XG4gICAgICBTdGF0ZS5MYXp5IChsYXp5ICgoTGF6eS5mb3JjZSBwKS5ydW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYykpKVxuICAgIGVsc2VcbiAgICAgIChMYXp5LmZvcmNlIHApLnJ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjXG4gICAgICAgICAgfVxuICBpblxuICByXG5cbmxldCBmaXggPSBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBOYXRpdmUgLT4gZml4X2RpcmVjdFxuICB8IEJ5dGVjb2RlIC0+IGZpeF9kaXJlY3RcbiAgfCBPdGhlciBfIC0+IGZ1biBmIC0+IGZpeF9sYXp5IH5tYXhfc3RlcHM6MjAgZlxuXG5sZXQgb3B0aW9uIHggcCA9XG4gIHAgPHw+IHJldHVybiB4XG5cbmxldCBjb25zIHggeHMgPSB4IDo6IHhzXG5cbmxldCByZWMgbGlzdCBwcyA9XG4gIG1hdGNoIHBzIHdpdGhcbiAgfCBbXSAgICAtPiByZXR1cm4gW11cbiAgfCBwOjpwcyAtPiBsaWZ0MiBjb25zIHAgKGxpc3QgcHMpXG5cbmxldCBjb3VudCBuIHAgPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJjb3VudDogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgMCAtPiByZXR1cm4gW11cbiAgICAgIHwgbiAtPiBsaWZ0MiBjb25zIHAgKGxvb3AgKG4gLSAxKSlcbiAgICBpblxuICAgIGxvb3AgblxuXG5sZXQgbWFueSBwID1cbiAgZml4IChmdW4gbSAtPlxuICAgIChsaWZ0MiBjb25zIHAgbSkgPHw+IHJldHVybiBbXSlcblxubGV0IG1hbnkxIHAgPVxuICBsaWZ0MiBjb25zIHAgKG1hbnkgcClcblxubGV0IG1hbnlfdGlsbCBwIHQgPVxuICBmaXggKGZ1biBtIC0+XG4gICAgKHQgKj4gcmV0dXJuIFtdKSA8fD4gKGxpZnQyIGNvbnMgcCBtKSlcblxubGV0IHNlcF9ieTEgcyBwID1cbiAgZml4IChmdW4gbSAtPlxuICAgIGxpZnQyIGNvbnMgcCAoKHMgKj4gbSkgPHw+IHJldHVybiBbXSkpXG5cbmxldCBzZXBfYnkgcyBwID1cbiAgKGxpZnQyIGNvbnMgcCAoKHMgKj4gc2VwX2J5MSBzIHApIDx8PiByZXR1cm4gW10pKSA8fD4gcmV0dXJuIFtdXG5cbmxldCBza2lwX21hbnkgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICAgICgocCA+PnwgZnVuIF8gLT4gdHJ1ZSkgPHw+IHJldHVybiBmYWxzZSkgPj49IGZ1bmN0aW9uXG4gICAgICB8IHRydWUgLT4gbVxuICAgICAgfCBmYWxzZSAtPiByZXR1cm4gKClcbiAgICApXG5cbmxldCBza2lwX21hbnkxIHAgPVxuICBwICo+IHNraXBfbWFueSBwXG5cbmxldCBlbmRfb2ZfbGluZSA9XG4gIChjaGFyICdcXG4nICo+IHJldHVybiAoKSkgPHw+IChzdHJpbmcgXCJcXHJcXG5cIiAqPiByZXR1cm4gKCkpIDw/PiBcImVuZF9vZl9saW5lXCJcblxubGV0IHNjYW5fIHN0YXRlIGYgfndpdGhfYnVmZmVyID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IHN0YXRlID0gcmVmIHN0YXRlIGluXG4gICAgbGV0IHBhcnNlciA9XG4gICAgICBjb3VudF93aGlsZSB+aW5pdDowIH5mOihmdW4gYyAtPlxuICAgICAgICBtYXRjaCBmICFzdGF0ZSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICAgIHwgU29tZSBzdGF0ZScgLT4gc3RhdGUgOj0gc3RhdGUnOyB0cnVlKVxuICAgICAgfndpdGhfYnVmZmVyXG4gICAgICA+PnwgZnVuIHggLT4geCwgIXN0YXRlXG4gICAgaW5cbiAgICBwYXJzZXIucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyB9XG5cbmxldCBzY2FuIHN0YXRlIGYgPVxuICBzY2FuXyBzdGF0ZSBmIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5zdWJzdHJpbmdcblxubGV0IHNjYW5fc3RhdGUgc3RhdGUgZiA9XG4gIHNjYW5fIHN0YXRlIGYgfndpdGhfYnVmZmVyOihmdW4gXyB+b2ZmOl8gfmxlbjpfIC0+ICgpKVxuICA+PnwgZnVuICgoKSwgc3RhdGUpIC0+IHN0YXRlXG5cbmxldCBzY2FuX3N0cmluZyBzdGF0ZSBmID1cbiAgc2NhbiBzdGF0ZSBmID4+fCBmc3RcblxubGV0IGNvbnN1bWVfd2l0aCBwIGYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgc3RhcnQgPSBwb3MgaW5cbiAgICBsZXQgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA9IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgaW5wdXQgIGluXG4gICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIF8gPVxuICAgICAgaWYgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA8PiBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIGlucHV0J1xuICAgICAgdGhlbiBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIFtdIFwiY29uc3VtZWQ6IHBhcnNlciBjb21taXR0ZWRcIlxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsZW4gPSBwb3MnIC0gc3RhcnQgaW5cbiAgICAgICAgbGV0IGNvbnN1bWVkID0gSW5wdXQuYXBwbHkgaW5wdXQnIHN0YXJ0IGxlbiB+ZiBpblxuICAgICAgICBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIGNvbnN1bWVkKVxuICAgIGluXG4gICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICB9XG5cbmxldCBjb25zdW1lZCAgICAgICAgICAgcCA9IGNvbnN1bWVfd2l0aCBwIEJpZ3N0cmluZ2FmLnN1YnN0cmluZ1xubGV0IGNvbnN1bWVkX2JpZ3N0cmluZyBwID0gY29uc3VtZV93aXRoIHAgQmlnc3RyaW5nYWYuY29weVxuXG5sZXQgYm90aCBhIGIgPSBsaWZ0MiAoZnVuIGEgYiAtPiBhLCBiKSBhIGJcbmxldCBtYXAgdCB+ZiA9IHQgPj58IGZcbmxldCBiaW5kIHQgfmYgPSB0ID4+PSBmXG5sZXQgbWFwMiBhIGIgfmYgPSBsaWZ0MiBmIGEgYlxubGV0IG1hcDMgYSBiIGMgfmYgPSBsaWZ0MyBmIGEgYiBjXG5sZXQgbWFwNCBhIGIgYyBkIH5mID0gbGlmdDQgZiBhIGIgYyBkXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cbiAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGxldCAoID4+PSApID0gKCA+Pj0gKVxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgPSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgYm90aCA9IGJvdGhcbiAgICBsZXQgbWFwMiA9IG1hcDJcbiAgICBsZXQgbWFwMyA9IG1hcDNcbiAgICBsZXQgbWFwNCA9IG1hcDRcbiAgZW5kXG5lbmRcblxubGV0ICggbGV0KyApID0gKCA+PnwgKVxubGV0ICggbGV0KiApID0gKCA+Pj0gKVxubGV0ICggYW5kKyApID0gYm90aFxuXG5tb2R1bGUgQkUgPSBzdHJ1Y3RcbiAgKCogWFhYKHNlbGlvcG91KTogVGhlIHBhdHRlcm4gaW4gYm90aCB0aGlzIG1vZHVsZSBhbmQgW0xFXSBhcmUgYSBjb21wcm9taXNlXG4gICAqIGJldHdlZW4gZWZmaWNpZW5jeSBhbmQgY29kZSByZXVzZS4gQnkgaW5saW5pbmcgW2Vuc3VyZV0geW91IGNhbiByZWNvdmVyXG4gICAqIGFib3V0IDIgbmFub3NlY29uZHMgb24gYXZlcmFnZS4gVGhhdCBtYXkgYWRkIHVwIGluIGNlcnRhaW4gYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIHBhdHRlcm4gZG9lcyBub3QgYWxsb2NhdGUgaW4gdGhlIGZhc3QgKHN1Y2Nlc3MpIHBhdGguXG4gICAqICopXG4gIGxldCBpbnQxNiBuID1cbiAgICBsZXQgYnl0ZXMgPSAyIGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIElucHV0LnVuc2FmZV9nZXRfaW50MTZfYmUgaW5wdXQgcG9zID0gKG4gbGFuZCAweGZmZmYpXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiQkUuaW50MTZcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQzMiBuID1cbiAgICBsZXQgYnl0ZXMgPSA0IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDMyLmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDMyX2JlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkJFLmludDMyXCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50NjQgbiA9XG4gICAgbGV0IGJ5dGVzID0gOCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQ2NC5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQ2NF9iZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJCRS5pbnQ2NFwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGFueV91aW50MTYgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfYmUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDE2ICA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9zaWduX2V4dGVuZGVkX2JlICBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MzIgID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQ2NCA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfZmxvYXQgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDMyLmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgYnMgb2ZmKSkpXG5cbiAgbGV0IGFueV9kb3VibGUgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDY0LmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfYmUgYnMgb2ZmKSkpXG5lbmRcblxubW9kdWxlIExFID0gc3RydWN0XG4gIGxldCBpbnQxNiBuID1cbiAgICBsZXQgYnl0ZXMgPSAyIGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIElucHV0LnVuc2FmZV9nZXRfaW50MTZfbGUgaW5wdXQgcG9zID0gKG4gbGFuZCAweGZmZmYpXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiTEUuaW50MTZcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQzMiBuID1cbiAgICBsZXQgYnl0ZXMgPSA0IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDMyLmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDMyX2xlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkxFLmludDMyXCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50NjQgbiA9XG4gICAgbGV0IGJ5dGVzID0gOCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQ2NC5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQ2NF9sZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJMRS5pbnQ2NFwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cblxuICBsZXQgYW55X3VpbnQxNiA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9sZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MTYgID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X3NpZ25fZXh0ZW5kZWRfbGUgIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQzMiAgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfbGUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDY0ID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2xlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9mbG9hdCA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50MzIuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9sZSBicyBvZmYpKSlcblxuICBsZXQgYW55X2RvdWJsZSA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50NjQuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9sZSBicyBvZmYpKSlcbmVuZFxuXG5tb2R1bGUgVW5zYWZlID0gc3RydWN0XG4gIGxldCB0YWtlIG4gZiA9XG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mKVxuXG4gIGxldCBwZWVrIG4gZiA9XG4gICAgdW5zYWZlX2xvb2thaGVhZCAodGFrZSBuIGYpXG5cbiAgbGV0IHRha2Vfd2hpbGUgY2hlY2sgZiA9XG4gICAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZjpjaGVjayB+d2l0aF9idWZmZXI6ZlxuXG4gIGxldCB0YWtlX3doaWxlMSBjaGVjayBmID1cbiAgICBjb3VudF93aGlsZTEgfmY6Y2hlY2sgfndpdGhfYnVmZmVyOmZcblxuICBsZXQgdGFrZV90aWxsIGNoZWNrIGYgPVxuICAgIHRha2Vfd2hpbGUgKGZ1biBjIC0+IG5vdCAoY2hlY2sgYykpIGZcbmVuZFxuXG5tb2R1bGUgQ29uc3VtZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgUHJlZml4XG4gICAgfCBBbGxcbmVuZFxuXG5sZXQgcGFyc2VfYmlnc3RyaW5nIH5jb25zdW1lIHAgYnMgPVxuICBsZXQgcCA9XG4gICAgbWF0Y2ggKGNvbnN1bWUgOiBDb25zdW1lLnQpIHdpdGhcbiAgICB8IFByZWZpeCAtPiBwXG4gICAgfCBBbGwgLT4gcCA8KiBlbmRfb2ZfaW5wdXRcbiAgaW5cbiAgVW5idWZmZXJlZC5wYXJzZV9iaWdzdHJpbmcgcCBic1xuXG5sZXQgcGFyc2Vfc3RyaW5nIH5jb25zdW1lIHAgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGJzICA9IEJpZ3N0cmluZ2FmLmNyZWF0ZSBsZW4gaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXRfZnJvbV9zdHJpbmcgcyB+c3JjX29mZjowIGJzIH5kc3Rfb2ZmOjAgfmxlbjtcbiAgcGFyc2VfYmlnc3RyaW5nIH5jb25zdW1lIHAgYnNcbiJdLCJpZ25vcmVMaXN0IjpbMF19fV19
