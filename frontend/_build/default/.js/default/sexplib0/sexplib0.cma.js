// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Sexplib0__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[10], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     a = xs;
     b = ys;
    }
   }
   function equal(a, b){return 0 === compare(a, b) ? 1 : 0;}
   var
    Not_found_s = [248, "Sexplib0__Sexp.Not_found_s", caml_fresh_oo_id(0)],
    Of_sexp_error = [248, "Sexplib0__Sexp.Of_sexp_error", caml_fresh_oo_id(0)],
    default_indent = [0, 1],
    cst_n = "\\n",
    _a_ = [0, 0, 0],
    _b_ = [0, [15, [17, 2, 0]], "%a@?"];
   function must_escape(str){
    var len = caml_ml_string_length(str), _t_ = 0 === len ? 1 : 0;
    if(_t_) return _t_;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix);
     a:
     {
      b:
      {
       if(92 <= match){
        var switcher = match - 93 | 0;
        if(33 < switcher >>> 0){if(0 <= switcher) break a; break b;}
        if(31 === switcher){
         var _u_ = 0 < ix ? 1 : 0;
         if(_u_){
          var
           next = ix - 1 | 0,
           _v_ = caml_string_get(str, next),
           _w_ = caml_call2(Stdlib_Char[6], _v_, 35);
          if(! _w_){ix = next; continue;}
          var _x_ = _w_;
         }
         else
          var _x_ = _u_;
         return _x_;
        }
       }
       else
        if(42 <= match){
         if(59 === match) break b;
        }
        else{
         if(33 > match) break a;
         switch(match - 33 | 0){
           case 2:
            var _z_ = 0 < ix ? 1 : 0;
            if(_z_){
             var
              next$0 = ix - 1 | 0,
              _A_ = caml_string_get(str, next$0),
              _B_ = caml_call2(Stdlib_Char[6], _A_, 124);
             if(! _B_){ix = next$0; continue;}
             var _C_ = _B_;
            }
            else
             var _C_ = _z_;
            return _C_;
           case 1:
           case 7:
           case 8:
            break b;
         }
        }
       var _y_ = 0 < ix ? 1 : 0;
       if(! _y_) return _y_;
       var ix$0 = ix - 1 | 0;
       ix = ix$0;
       continue;
      }
      return 1;
     }
     return 1;
    }
   }
   function escaped(s){
    var n = [0, 0], _j_ = caml_ml_string_length(s) - 1 | 0, _i_ = 0;
    if(_j_ >= 0){
     var i$0 = _i_;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _q_ = match - 34 | 0;
          if(58 < _q_ >>> 0){
           if(93 <= _q_) break c;
          }
          else if(56 < _q_ - 1 >>> 0) break b;
          var _r_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _r_ = 4;
        break a;
       }
       var _r_ = 2;
      }
      n[1] = n[1] + _r_ | 0;
      var _s_ = i$0 + 1 | 0;
      if(_j_ === i$0) break;
      i$0 = _s_;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _l_ = caml_ml_string_length(s) - 1 | 0, _k_ = 0;
    if(_l_ >= 0){
     var i = _k_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        var _n_ = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _n_);
        n[1]++;
        var
         _o_ = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _o_);
        n[1]++;
        var _p_ = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _p_);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _m_ = i + 1 | 0;
      if(_l_ === i) break;
      i = _m_;
     }
    }
    return caml_call1(Stdlib_BytesLabels[44], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[44], res);
   }
   function index_of_newline(str, start){
    return caml_call3(Stdlib_StringLabels[33], str, start, 10);
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       _f_ = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var _f_ = 1;
     if(_f_){
      var _g_ = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, _g_);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[16], str, index$0, end_pos$0 - index$0 | 0),
       _h_ = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, _h_);
      if(! next_newline){
       caml_call2(Stdlib_Format[13], ppf, cst$1);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var newline_index = next_newline[1];
      caml_call2(Stdlib_Format[13], ppf, cst);
      caml_call2(Stdlib_Format[35], ppf, 0);
      caml_call2(Stdlib_Format[13], ppf, cst_n);
      var index$1 = newline_index + 1 | 0;
      index$0 = index$1;
     }
    }
    else{
     var match$0 = param[1];
     if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
     var t = match$0[2], h = match$0[1];
     caml_call2(Stdlib_Format[1], ppf, indent);
     caml_call2(Stdlib_Format[13], ppf, cst$2);
     pp_hum_indent(indent, ppf, h);
     var param$0 = t;
     for(;;){
      if(! param$0){
       caml_call2(Stdlib_Format[13], ppf, cst$4);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[28], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      param$0 = t$0;
     }
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(! param$0){caml_call2(Stdlib_Format[13], ppf, cst$8); return 0;}
     var
      t$0 = param$0[2],
      h$0 = param$0[1],
      may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0);
     may_need_space$1 = may_need_space$2;
     param$0 = t$0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[26], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(_a_, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    var
     indent = opt ? opt[1] : default_indent[1],
     ppf = caml_call1(Stdlib_Format[116], buf);
    return caml_call4
            (Stdlib_Format[139],
             ppf,
             _b_,
             function(_d_, _e_){return pp_hum_indent(indent, _d_, _e_);},
             sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(Stdlib_Buffer[12], buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0);
      may_need_space$1 = may_need_space$2;
      param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(add_char, buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0);
      may_need_space$1 = may_need_space$2;
      param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], _c_ = index_of_newline(str, 0) ? 0 : 1;
     if(_c_) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return fname !== ""
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(25, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment",
    type_name_tag = "sexp_grammar.type_name",
    assoc_tag = "sexp_grammar.assoc",
    assoc_key_tag = "sexp_grammar.assoc.key",
    assoc_value_tag = "sexp_grammar.assoc.value",
    completion_suggested = "sexp_grammar.completion-suggested";
   function coerce(t){return t;}
   function tag(param, key, value){return [5, [0, key, value, param]];}
   var
    Sexplib0_Sexp_grammar =
      [0,
       coerce,
       tag,
       doc_comment_tag,
       type_name_tag,
       assoc_tag,
       assoc_key_tag,
       assoc_value_tag,
       completion_suggested];
   runtime.caml_register_global
    (6, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function sexp_grammar_with_tags(grammar, tags){
    return caml_call3
            (Stdlib_ListLabels[27],
             function(param, grammar){
              var value = param[2], key = param[1];
              return [5, [0, key, value, grammar]];
             },
             tags,
             grammar);
   }
   function sexp_grammar_with_tag_list(x, tags){
    return caml_call3
            (Stdlib_ListLabels[27],
             function(param, grammar){
              var value = param[2], key = param[1];
              return [0, [0, key, value, grammar]];
             },
             tags,
             x);
   }
   function ref_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       0,
       4,
       4,
       1,
       2,
       3,
       2,
       2,
       2,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (5, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) === x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1],
    _a_ = [1, 0],
    _b_ = [0, cst_some],
    _c_ = [1, 0],
    _d_ = [0, cst_none],
    _e_ = [0, "<opaque>"],
    _f_ = [0, "<fun>"];
   function list_map(f, l){
    var _aM_ = caml_call2(Stdlib_ListLabels[22], f, l);
    return caml_call1(Stdlib_ListLabels[10], _aM_);
   }
   function sexp_of_unit(param){return _a_;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var _aK_ = runtime.caml_obj_tag(lv);
    a:
    if(250 === _aK_)
     var _aL_ = lv[1];
    else{
     if(246 !== _aK_ && 244 !== _aK_){var _aL_ = lv; break a;}
     var _aL_ = caml_call1(CamlinternalLazy[2], lv);
    }
    return caml_call1(sexp_of_a, _aL_);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? _c_ : _d_;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, _b_, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], _aJ_ = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), _aJ_]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _aH_ = [0, caml_call1(sexp_of_c, c), 0],
     _aI_ = [0, caml_call1(sexp_of_b, b), _aH_];
    return [1, [0, caml_call1(sexp_of_a, a), _aI_]];
   }
   function sexp_of_list(sexp_of_a, lst){
    var _aG_ = caml_call2(Stdlib_ListLabels[22], sexp_of_a, lst);
    return [1, caml_call1(Stdlib_ListLabels[10], _aG_)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], _aD_ = ar.length - 2 | 0;
    if(_aD_ >= 0){
     var i = _aD_;
     for(;;){
      var _aE_ = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[1 + i]), _aE_];
      var _aF_ = i - 1 | 0;
      if(0 === i) break;
      i = _aF_;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var _aC_ = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), _aC_]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return _e_;}
   function sexp_of_fun(param){return _f_;}
   function equal(_aB_, _aA_){return _aB_ === _aA_ ? 1 : 0;}
   var
    hash = Stdlib_Obj[22][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][3], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    var printexc = opt ? opt[1] : 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[22][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[18], the_exn_table)[1];}
   var For_unit_tests_only = [0, size], _g_ = [0, 2];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var _az_ = sexp_of_exn(e);
    return caml_call2(Sexplib0_Sexp[13], 0, _az_);
   }
   caml_call1
    (Stdlib_Printexc[9],
     function(exn){
      var match = find_auto(1, exn);
      if(! match) return 0;
      var sexp = match[1];
      return [0, caml_call2(Sexplib0_Sexp[13], _g_, sexp)];
     });
   var _h_ = [0, 2];
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return caml_call2(Sexplib0_Sexp[13], _h_, sexp);
   }
   var
    Of_sexp_error = Sexplib0_Sexp[6],
    record_check_extra_fields = [0, 1],
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values";
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(1 === sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var _ay_ = sexp[1];
    a:
    if(_ay_ !== "False"){
     if(_ay_ !== "True"){
      if(_ay_ === "false") break a;
      if(_ay_ !== "true")
       return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
     }
     return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _ax_ = caml_int_of_string(str); return _ax_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _aw_ = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, _aw_), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _av_ = caml_float_of_string(str); return _av_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _au_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_float_of_sexp, _au_), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _at_ = caml_int_of_string(str); return _at_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _as_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int32_of_sexp, _as_), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _ar_ = runtime.caml_int64_of_string(str); return _ar_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _aq_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int64_of_sexp, _aq_), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var _ap_ = caml_int_of_string(str); return _ap_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _ao_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, _ao_), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var _an_ = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], _an_);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var _ai_ = sexp[1];
      if(_ai_ !== cst_None && _ai_ !== cst_none)
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var _aj_ = sexp[1];
     a:
     if(_aj_){
      var _ak_ = _aj_[1];
      if(0 === _ak_[0]){
       var _al_ = _ak_[1];
       if(_al_ !== cst_Some && _al_ !== cst_some) break a;
       var _am_ = _aj_[2];
       if(_am_ && ! _am_[2]){
        var el$0 = _am_[1];
        return [0, caml_call1(a_of_sexp, el$0)];
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var _ad_ = sexp[1];
     if(_ad_ !== cst_None && _ad_ !== cst_none)
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var _ae_ = sexp[1];
     if(_ae_){
      var _af_ = _ae_[1];
      a:
      {
       if(_ae_[2]){
        b:
        if(0 === _af_[0]){
         var _ag_ = _af_[1];
         if(_ag_ !== cst_Some && _ag_ !== cst_some) break b;
         var _ah_ = _ae_[2];
         if(! _ah_[2]){var el = _ah_[1]; break a;}
        }
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
       }
       var el = _af_;
      }
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var _ab_ = sexp[1];
    if(_ab_){
     var _ac_ = _ab_[2];
     if(_ac_ && ! _ac_[2]){
      var
       b_sexp = _ac_[1],
       a_sexp = _ab_[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var ___ = sexp[1];
    if(___){
     var _$_ = ___[2];
     if(_$_){
      var _aa_ = _$_[2];
      if(_aa_ && ! _aa_[2]){
       var
        c_sexp = _aa_[1],
        b_sexp = _$_[1],
        a_sexp = ___[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     rev_lst = caml_call2(Stdlib_ListLabels[22], a_of_sexp, lst);
    return caml_call1(Stdlib_ListLabels[10], rev_lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_make_vect(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], _Z_ = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[1 + i] = _Z_;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(1 === param[0]){
      var _V_ = param[1];
      if(_V_){
       var _W_ = _V_[2];
       if(_W_ && ! _W_[2]){
        var
         v_sexp = _W_[1],
         k_sexp = _V_[1],
         _X_ = caml_call1(val_of_sexp, v_sexp),
         _Y_ = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, _Y_, _X_);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[18], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    sexp_grammar_with_tags = Sexplib0_Sexp_conv_grammar[1],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv_grammar[2],
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[18],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[19],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[20],
    _i_ =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], _i_, name, file, line, chr)];
   }
   var
    _j_ = [0, "Sys.Break"],
    _k_ = [0, cst_src_sexp_conv_ml, 398, 15],
    _l_ = [0, "Stack.Empty"],
    _m_ = [0, cst_src_sexp_conv_ml, 394, 15],
    _n_ = [0, "Scanf.Scan_failure"],
    _o_ = [0, cst_src_sexp_conv_ml, 390, 15],
    _p_ = [0, "Queue.Empty"],
    _q_ = [0, cst_src_sexp_conv_ml, 386, 15],
    _r_ = [0, "Parsing.Parse_error"],
    _s_ = [0, cst_src_sexp_conv_ml, 382, 15],
    _t_ = [0, "Lazy.Undefined"],
    _u_ = [0, cst_src_sexp_conv_ml, 378, 15],
    _v_ = [0, "Arg.Bad"],
    _w_ = [0, cst_src_sexp_conv_ml, 374, 15],
    _x_ = [0, "Arg.Help"],
    _y_ = [0, cst_src_sexp_conv_ml, 370, 15],
    _z_ = [0, "Sys_error"],
    _A_ = [0, cst_src_sexp_conv_ml, 366, 15],
    _B_ = [0, "Not_found_s"],
    _C_ = [0, cst_src_sexp_conv_ml, 362, 15],
    cst_Match_failure = "Match_failure",
    _D_ = [0, cst_src_sexp_conv_ml, 358, 15],
    _E_ = [0, "Invalid_argument"],
    _F_ = [0, cst_src_sexp_conv_ml, 354, 15],
    _G_ = [0, "Not_found"],
    _H_ = [0, cst_src_sexp_conv_ml, 350, 15],
    _I_ = [0, "Failure"],
    _J_ = [0, cst_src_sexp_conv_ml, 346, 15],
    _K_ = [0, "End_of_file"],
    _L_ = [0, cst_src_sexp_conv_ml, 342, 15],
    _M_ = [0, "Exit"],
    _N_ = [0, cst_src_sexp_conv_ml, 338, 15],
    cst_Assert_failure = cst_Assert_failure$0,
    _O_ = [0, cst_src_sexp_conv_ml, 334, 15],
    _P_ = [0, 0],
    _Q_ = [0, 0];
   caml_call2
    (Stdlib_ListLabels[18],
     function(param){
      var handler = param[2], extension_constructor = param[1];
      return add(_Q_, _P_, extension_constructor, handler);
     },
     [0,
      [0,
       Stdlib[5],
       function(param){
        if(param[1] !== Stdlib[5])
         throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
        var arg = param[2];
        return get_flc_error(cst_Assert_failure, arg);
       }],
      [0,
       [0,
        Stdlib[3],
        function(param){
         if(param === Stdlib[3]) return _M_;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
        }],
       [0,
        [0,
         Stdlib[12],
         function(param){
          if(param === Stdlib[12]) return _K_;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
         }],
        [0,
         [0,
          Stdlib[7],
          function(param){
           if(param[1] !== Stdlib[7])
            throw caml_maybe_attach_backtrace([0, Assert_failure, _J_], 1);
           var arg = param[2];
           return [1, [0, _I_, [0, [0, arg], 0]]];
          }],
         [0,
          [0,
           Stdlib[8],
           function(param){
            if(param === Stdlib[8]) return _G_;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
           }],
          [0,
           [0,
            Stdlib[6],
            function(param){
             if(param[1] !== Stdlib[6])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
             var arg = param[2];
             return [1, [0, _E_, [0, [0, arg], 0]]];
            }],
           [0,
            [0,
             Stdlib[4],
             function(param){
              if(param[1] !== Stdlib[4])
               throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
              var arg = param[2];
              return get_flc_error(cst_Match_failure, arg);
             }],
            [0,
             [0,
              Sexplib0_Sexp[5],
              function(param){
               if(param[1] !== Sexplib0_Sexp[5])
                throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
               var arg = param[2];
               return [1, [0, _B_, [0, arg, 0]]];
              }],
             [0,
              [0,
               Stdlib[11],
               function(param){
                if(param[1] !== Stdlib[11])
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _A_], 1);
                var arg = param[2];
                return [1, [0, _z_, [0, [0, arg], 0]]];
               }],
              [0,
               [0,
                Stdlib_Arg[7],
                function(param){
                 if(param[1] !== Stdlib_Arg[7])
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _y_], 1);
                 var arg = param[2];
                 return [1, [0, _x_, [0, [0, arg], 0]]];
                }],
               [0,
                [0,
                 Stdlib_Arg[8],
                 function(param){
                  if(param[1] !== Stdlib_Arg[8])
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _w_], 1);
                  var arg = param[2];
                  return [1, [0, _v_, [0, [0, arg], 0]]];
                 }],
                [0,
                 [0,
                  Stdlib_Lazy[1],
                  function(param){
                   if(param === Stdlib_Lazy[1]) return _t_;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _u_], 1);
                  }],
                 [0,
                  [0,
                   Stdlib_Parsing[10],
                   function(param){
                    if(param === Stdlib_Parsing[10]) return _r_;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _s_], 1);
                   }],
                  [0,
                   [0,
                    Stdlib_Queue[1],
                    function(param){
                     if(param === Stdlib_Queue[1]) return _p_;
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _q_], 1);
                    }],
                   [0,
                    [0,
                     Stdlib_Scanf[2],
                     function(param){
                      if(param[1] !== Stdlib_Scanf[2])
                       throw caml_maybe_attach_backtrace
                              ([0, Assert_failure, _o_], 1);
                      var arg = param[2];
                      return [1, [0, _n_, [0, [0, arg], 0]]];
                     }],
                    [0,
                     [0,
                      Stdlib_Stack[1],
                      function(param){
                       if(param === Stdlib_Stack[1]) return _l_;
                       throw caml_maybe_attach_backtrace
                              ([0, Assert_failure, _m_], 1);
                      }],
                     [0,
                      [0,
                       Stdlib_Sys[44],
                       function(param){
                        if(param === Stdlib_Sys[44]) return _j_;
                        throw caml_maybe_attach_backtrace
                               ([0, Assert_failure, _k_], 1);
                       }],
                      0]]]]]]]]]]]]]]]]]);
   var
    _R_ = [0, "Sexplib.Conv.Of_sexp_error"],
    _S_ = [0, cst_src_sexp_conv_ml, 410, 15],
    _T_ = [0, 0],
    _U_ = [0, 1];
   caml_call2
    (Stdlib_ListLabels[18],
     function(param){
      var handler = param[2], extension_constructor = param[1];
      return add(_U_, _T_, extension_constructor, handler);
     },
     [0,
      [0,
       Of_sexp_error,
       function(param){
        if(param[1] !== Of_sexp_error)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _S_], 1);
        var sexp = param[3], exc = param[2];
        return [1, [0, _R_, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
       }],
      0]);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    _a_ =
      [0,
       [2,
        0,
        [11, "_of_sexp: tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]]],
       "%s_of_sexp: tuple of size %d expected"],
    cst_of_sexp_this_constructor_d =
      "_of_sexp: this constructor does not take arguments",
    _b_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: sum tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: sum tag %S has incorrect number of arguments"],
    cst_of_sexp_this_constructor_r =
      "_of_sexp: this constructor requires arguments",
    cst_of_sexp_expected_a_variant =
      "_of_sexp: expected a variant type, saw a nested list",
    cst_of_sexp_expected_a_variant$0 =
      "_of_sexp: expected a variant type, saw an empty list",
    cst_of_sexp_unexpected_variant =
      "_of_sexp: unexpected variant constructor",
    cst_of_sexp_record_conversion_ =
      "_of_sexp: record conversion: a [sexp.bool] field was given a payload.",
    cst_of_sexp_record_conversion_$0 =
      "_of_sexp: record conversion: only pairs expected, their first element must be an atom",
    _c_ =
      [0,
       [2, 0, [11, "_of_sexp: ", [2, 0, [11, ": ", [2, 0, 0]]]]],
       "%s_of_sexp: %s: %s"],
    cst_duplicate_fields = "duplicate fields",
    cst_extra_fields = "extra fields",
    _d_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: the following record elements were undefined: ",
         [2, 0, 0]]],
       "%s_of_sexp: the following record elements were undefined: %s"],
    cst_of_sexp_list_instead_of_at =
      "_of_sexp: list instead of atom for record expected",
    cst_of_sexp_cannot_convert_val =
      "_of_sexp: cannot convert values of types resulting from polymorphic record fields";
   function tuple_of_size_n_expected(loc, n, sexp){
    var _t_ = caml_call3(Stdlib_Printf[4], _a_, loc, n);
    return caml_call2(Sexplib0_Sexp_conv[27], _t_, sexp);
   }
   function stag_no_args(loc, sexp){
    var _s_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_d);
    return caml_call2(Sexplib0_Sexp_conv[27], _s_, sexp);
   }
   function stag_incorrect_n_args(loc, tag, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _b_, loc, tag);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function stag_takes_args(loc, sexp){
    var _r_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_r);
    return caml_call2(Sexplib0_Sexp_conv[27], _r_, sexp);
   }
   function nested_list_invalid_sum(loc, sexp){
    var _q_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _q_, sexp);
   }
   function empty_list_invalid_sum(loc, sexp){
    var _p_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _p_, sexp);
   }
   function unexpected_stag(loc, sexp){
    var _o_ = caml_call2(Stdlib[28], loc, cst_of_sexp_unexpected_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _o_, sexp);
   }
   function record_sexp_bool_with_payload(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_only_pairs_expected(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_superfluous_fields(what, loc, rev_fld_names, sexp){
    var
     _n_ = caml_call1(Stdlib_ListLabels[10], rev_fld_names),
     fld_names_str = caml_call2(Stdlib_StringLabels[7], cst, _n_),
     msg = caml_call4(Stdlib_Printf[4], _c_, loc, what, fld_names_str);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_duplicate_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_duplicate_fields, loc, rev_fld_names, sexp);
   }
   function record_extra_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_extra_fields, loc, rev_fld_names, sexp);
   }
   function record_get_undefined_loop(fields, param){
    var fields$0 = fields, param$0 = param;
    for(;;){
     if(! param$0){
      var _m_ = caml_call1(Stdlib_ListLabels[10], fields$0);
      return caml_call2(Stdlib_StringLabels[7], cst$0, _m_);
     }
     var _l_ = param$0[1];
     if(_l_[1]){
      var rest = param$0[2], field = _l_[2], fields$1 = [0, field, fields$0];
      fields$0 = fields$1;
      param$0 = rest;
     }
     else{var rest$0 = param$0[2]; param$0 = rest$0;}
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$0 = record_get_undefined_loop(0, lst),
     msg = caml_call3(Stdlib_Printf[4], _d_, loc, undefined$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_list_instead_atom(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_list_instead_of_at);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_poly_field_value(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_cannot_convert_val);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   var
    No_variant_match =
      [248,
       "Sexplib0__Sexp_conv_error.No_variant_match",
       runtime.caml_fresh_oo_id(0)],
    cst_of_sexp_no_matching_varian = "_of_sexp: no matching variant found",
    cst_of_sexp_polymorphic_varian =
      "_of_sexp: polymorphic variant does not take arguments",
    _e_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: polymorphic variant tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments"],
    cst_of_sexp_polymorphic_varian$0 =
      "_of_sexp: polymorphic variant tag takes an argument",
    cst_of_sexp_a_nested_list_is_a =
      "_of_sexp: a nested list is an invalid polymorphic variant",
    cst_of_sexp_the_empty_list_is_ =
      "_of_sexp: the empty list is an invalid polymorphic variant",
    cst_of_sexp_trying_to_convert_ =
      "_of_sexp: trying to convert an empty type";
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(loc, sexp){
    var _k_ = caml_call2(Stdlib[28], loc, cst_of_sexp_no_matching_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _k_, sexp);
   }
   function ptag_no_args(loc, sexp){
    var _j_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _j_, sexp);
   }
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _e_, loc, cnstr);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function ptag_takes_args(loc, sexp){
    var _i_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _i_, sexp);
   }
   function nested_list_invalid_poly_var(loc, sexp){
    var _h_ = caml_call2(Stdlib[28], loc, cst_of_sexp_a_nested_list_is_a);
    return caml_call2(Sexplib0_Sexp_conv[27], _h_, sexp);
   }
   function empty_list_invalid_poly_var(loc, sexp){
    var _g_ = caml_call2(Stdlib[28], loc, cst_of_sexp_the_empty_list_is_);
    return caml_call2(Sexplib0_Sexp_conv[27], _g_, sexp);
   }
   function empty_type(loc, sexp){
    var _f_ = caml_call2(Stdlib[28], loc, cst_of_sexp_trying_to_convert_);
    return caml_call2(Sexplib0_Sexp_conv[27], _f_, sexp);
   }
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (30, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_record
//# unitInfo: Requires: Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__ArrayLabels, Stdlib__ListLabels, Stdlib__Option, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    absent = [0, ""],
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    Kind = [0];
   function combine(a, b){
    a:
    if(typeof a !== "number"){
     b:
     {
      c:
      {
       d:
       {
        e:
        switch(a[0]){
          case 0:
           var a$0 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var b$0 = b[1]; return [0, caml_call2(Stdlib[37], a$0, b$0)];
              case 1:
               break d;
              default: var t$0 = a; break e;
            }
           break b;
          case 1:
           var a$1 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 1:
               var b$1 = b[1]; return [1, caml_call2(Stdlib[37], a$1, b$1)];
              default: var t = a; break c;
            }
           break b;
          case 2:
           var a$2 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var t$0 = b; break e;
              case 1:
               break d;
              default:
               var b$2 = b[1]; return [2, caml_call2(Stdlib[37], a$2, b$2)];
            }
           break b;
          default: break a;
        }
        return t$0;
       }
       var t = b;
      }
      return t;
     }
     return b;
    }
    return a;
   }
   var
    Malformed =
      [248,
       "Sexplib0__Sexp_conv_record.Malformed",
       runtime.caml_fresh_oo_id(0)],
    _a_ = [1, 0],
    _b_ = [3, 0],
    dummy = 0;
   function parse_value_malformed(malformed, fields, state, pos){
    try{
     parse_values(fields[4], state, pos + 1 | 0);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_values(fields, state, pos){
    if(! fields) return 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1],
     sexp$5 = state[1 + pos];
    a:
    {
     b:
     {
      if(typeof kind !== "number"){
       var default$0 = kind[1];
       if(0 === sexp$5[0])
        var _G_ = caml_call1(default$0, 0);
       else{
        var _H_ = sexp$5[1];
        if(! _H_) break b;
        var _I_ = _H_[2];
        if(! _I_) break b;
        if(_I_[2]) break b;
        var sexp$4 = _I_[1], _G_ = caml_call1(conv, sexp$4);
       }
       var value = _G_;
       break a;
      }
      switch(kind){
        case 0:
         if(0 === sexp$5[0]){var value = caml_call1(conv, _a_); break a;}
         var _s_ = sexp$5[1];
         if(_s_){
          var _t_ = _s_[2];
          if(_t_ && ! _t_[2]){
           var sexp = _t_[1], value = caml_call1(conv, sexp);
           break a;
          }
         }
         break;
        case 1:
         if(0 === sexp$5[0]){
          var
           value =
             parse_value_malformed([2, [0, name, 0]], fields, state, pos);
          break a;
         }
         var _w_ = sexp$5[1];
         if(_w_){
          var _x_ = _w_[2];
          if(_x_ && ! _x_[2]){
           var sexp$0 = _x_[1], value = caml_call1(conv, sexp$0);
           break a;
          }
         }
         break;
        case 2:
         if(0 === sexp$5[0]){var value = [0]; break a;}
         var _y_ = sexp$5[1];
         if(_y_){
          var _z_ = _y_[2];
          if(_z_ && ! _z_[2]){
           var
            sexp$1 = _z_[1],
            value = caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$1);
           break a;
          }
         }
         break;
        case 3:
         if(0 === sexp$5[0]){var value = 0; break a;}
         var _A_ = sexp$5[1];
         c:
         {
          if(_A_ && ! _A_[2]){var _B_ = 1; break c;}
          var _B_ = parse_value_malformed(0, fields, state, pos);
         }
         var value = _B_;
         break a;
        case 4:
         if(0 === sexp$5[0]){var value = 0; break a;}
         var _C_ = sexp$5[1];
         if(_C_){
          var _D_ = _C_[2];
          if(_D_ && ! _D_[2]){
           var
            sexp$2 = _D_[1],
            value = caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$2);
           break a;
          }
         }
         break;
        default:
         if(0 === sexp$5[0]){var value = 0; break a;}
         var _E_ = sexp$5[1];
         if(_E_){
          var _F_ = _E_[2];
          if(_F_ && ! _F_[2]){
           var sexp$3 = _F_[1], value = [0, caml_call1(conv, sexp$3)];
           break a;
          }
         }
      }
     }
     var _u_ = sexp$5[1];
     b:
     {
      if(_u_ && _u_[2]){
       var _v_ = parse_value_malformed([3, [0, sexp$5]], fields, state, pos);
       break b;
      }
      var _v_ = parse_value_malformed(_b_, fields, state, pos);
     }
     var value = _v_;
    }
    return [0, value, parse_values(rest, state, pos + 1 | 0)];
   }
   function parse_spine_malformed
   (malformed, index, extra, seen, state, len, sexps){
    try{
     parse_spine_slow(index, extra, seen, state, len, sexps);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_spine_slow(index, extra, seen, state, len, sexps){
    var sexps$0 = sexps;
    for(;;){
     if(! sexps$0) return;
     var field = sexps$0[1];
     if(1 === field[0]){
      var _n_ = field[1];
      if(_n_){
       var match = _n_[1];
       if(0 === match[0]){
        var
         sexps$2 = sexps$0[2],
         name = match[1],
         i = caml_call1(index, name),
         _o_ = seen <= i ? 1 : 0,
         _p_ = _o_ ? i < len ? 1 : 0 : _o_;
        if(_p_){
         var pos = i - seen | 0;
         if(0 !== state[1 + pos][0])
          return parse_spine_malformed
                  ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
         state[1 + pos] = field;
         sexps$0 = sexps$2;
         continue;
        }
        var _q_ = 0 <= i ? 1 : 0, _r_ = _q_ ? i < seen ? 1 : 0 : _q_;
        if(_r_)
         return parse_spine_malformed
                 ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        if(! extra)
         return parse_spine_malformed
                 ([0, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        sexps$0 = sexps$2;
        continue;
       }
      }
     }
     var sexps$1 = sexps$0[2];
     return parse_spine_malformed
             ([3, [0, field]], index, extra, seen, state, len, sexps$1);
    }
   }
   function parse_record_slow(fields, index, extra, seen, sexps){
    var t = fields, unseen = 0;
    for(;;){
     if(! t){
      var
       state = runtime.caml_make_vect(unseen, absent),
       len = seen + unseen | 0;
      parse_spine_slow(index, extra, seen, state, len, sexps);
      return parse_values(fields, state, 0);
     }
     var rest = t[4], acc = unseen + 1 | 0;
     t = rest;
     unseen = acc;
    }
   }
   function parse_spine_fast(fields, index, extra, seen, sexps){
    if(! fields)
     return sexps ? parse_record_slow(fields, index, extra, seen, sexps) : 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1];
    if(sexps){
     var _f_ = sexps[1];
     if(0 !== _f_[0]){
      var _g_ = _f_[1];
      if(_g_){
       var match = _g_[1];
       if(0 === match[0]){
        var others = sexps[2], args = _g_[2], atom = match[1];
        if(caml_call2(Stdlib_StringLabels[9], atom, name)){
         if(typeof kind === "number")
          switch(kind){
            case 0:
             if(args && ! args[2]){
              var
               sexp = args[1],
               _h_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp), _h_];
             }
             break;
            case 1:
             if(args && ! args[2]){
              var
               sexp$0 = args[1],
               _i_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp$0), _i_];
             }
             break;
            case 2:
             if(args && ! args[2]){
              var
               sexp$1 = args[1],
               _j_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$1),
                      _j_];
             }
             break;
            case 3:
             if(! args)
              return [0,
                      1,
                      parse_spine_fast(rest, index, extra, seen + 1 | 0, others)];
             break;
            case 4:
             if(args && ! args[2]){
              var
               sexp$2 = args[1],
               _k_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$2),
                      _k_];
             }
             break;
            default:
             if(args && ! args[2]){
              var
               sexp$3 = args[1],
               _l_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, [0, caml_call1(conv, sexp$3)], _l_];
             }
          }
         else if(args && ! args[2]){
          var
           sexp$4 = args[1],
           _m_ = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
          return [0, caml_call1(conv, sexp$4), _m_];
         }
         return parse_record_slow(fields, index, extra, seen, sexps);
        }
       }
      }
     }
    }
    return parse_record_slow(fields, index, extra, seen, sexps);
   }
   function record_of_sexps
   (caller,
    context$0,
    fields,
    index_of_field,
    allow_extra_fields,
    create,
    sexps){
    var
     allow_extra_fields$0 =
       allow_extra_fields || 1 - Sexplib0_Sexp_conv[26][1];
    try{
     var
      value =
        parse_spine_fast
         (fields, index_of_field, allow_extra_fields$0, 0, sexps);
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var malformed = exn[2];
     if(typeof malformed === "number")
      return caml_call2(Sexplib0_Sexp_conv_error[9], caller, context$0);
     switch(malformed[0]){
       case 0:
        var
         names = malformed[1],
         _c_ = caml_call1(Stdlib_ListLabels[10], names);
        return caml_call3
                (Sexplib0_Sexp_conv_error[13], caller, _c_, context$0);
       case 1:
        var
         names$0 = malformed[1],
         _d_ = caml_call1(Stdlib_ListLabels[10], names$0);
        return caml_call3
                (Sexplib0_Sexp_conv_error[12], caller, _d_, context$0);
       case 2:
        var
         names$1 = malformed[1],
         _e_ =
           caml_call2
            (Stdlib_ListLabels[20],
             function(name){return [0, 1, name];},
             names$1);
        return caml_call1
                (caml_call2(Sexplib0_Sexp_conv_error[15], caller, context$0),
                 _e_);
       default:
        var
         maybe_context = malformed[1],
         context = caml_call2(Stdlib_Option[3], maybe_context, context$0);
        return caml_call2(Sexplib0_Sexp_conv_error[10], caller, context);
     }
    }
    return caml_call1(create, value);
   }
   function record_of_sexp
   (caller, fields, index_of_field, allow_extra_fields, create, sexp){
    if(0 === sexp[0])
     return caml_call2(Sexplib0_Sexp_conv_error[16], caller, sexp);
    var sexps = sexp[1];
    return record_of_sexps
            (caller,
             sexp,
             fields,
             index_of_field,
             allow_extra_fields,
             create,
             sexps);
   }
   var
    Sexplib0_Sexp_conv_record =
      [0, Kind, [0], record_of_sexp, record_of_sexps];
   runtime.caml_register_global
    (10, Sexplib0_Sexp_conv_record, "Sexplib0__Sexp_conv_record");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InNleHBsaWIwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJTZXhwbGliMCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InNleHBsaWIwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1N0cmluZ0xhYmVscyIsIlN0ZGxpYl9Gb3JtYXQiLCJTdGRsaWJfTGlzdExhYmVscyIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWJfQnl0ZXNMYWJlbHMiLCJTdGRsaWJfQ2hhciIsIlN0ZGxpYl9CeXRlcyIsInNleHBfb2ZfdCIsInQiLCJ0X29mX3NleHAiLCJjb21wYXJlIiwiYSIsImIiLCJ5cyIsInkiLCJ4cyIsIngiLCJyZXMiLCJlcXVhbCIsIk5vdF9mb3VuZF9zIiwiT2Zfc2V4cF9lcnJvciIsImRlZmF1bHRfaW5kZW50IiwiY3N0X24iLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4IiwibWF0Y2giLCJzd2l0Y2hlciIsIm5leHQiLCJlc2NhcGVkIiwicyIsIm4iLCJpIiwiYyIsImVzY19zdHIiLCJlc3RyIiwiZWxlbiIsImluZGV4X29mX25ld2xpbmUiLCJzdGFydCIsIm1hY2hfbWF5YmVfZXNjX3N0ciIsInBwX2h1bV9pbmRlbnQiLCJpbmRlbnQiLCJwcGYiLCJwYXJhbSIsImluZGV4IiwibmV4dF9uZXdsaW5lIiwiZW5kX3BvcyIsIm5leHRfbGluZSIsIm5ld2xpbmVfaW5kZXgiLCJoIiwicHBfbWFjaF9pbnRlcm5hbCIsIm1heV9uZWVkX3NwYWNlIiwibmV3X21heV9uZWVkX3NwYWNlIiwicHBfaHVtIiwic2V4cCIsInBwX21hY2giLCJzaXplX2xvb3AiLCJhY2MiLCJ2IiwibHN0Iiwic2l6ZSIsInRvX2J1ZmZlcl9odW0iLCJidWYiLCJvcHQiLCJ0b19idWZmZXJfbWFjaCIsImxvb3AiLCJ0b19idWZmZXJfZ2VuIiwiYWRkX2NoYXIiLCJhZGRfc3RyaW5nIiwiYnVmZmVyIiwidG9fc3RyaW5nX2h1bSIsInRvX3N0cmluZ19tYWNoIiwib2ZfZmxvYXRfc3R5bGUiLCJvZl9pbnRfc3R5bGUiLCJtZXNzYWdlIiwibmFtZSIsImZpZWxkcyIsImNvbnZfZmllbGRzIiwicmVzdCIsImZzZXhwIiwiZm5hbWUiLCJTZXhwbGliMF9TZXhwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3NleHBsaWIwL3NleHAubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7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QSxRQUFBdUMsTUFGVDtBQUFBLElBQ1Y7QUFBQSxJQUF3Qix3Q0FDTDtBQUFBO0FBQUEsT0FBQVUsaUJEelV6QixpQkFBQUMsZUFBQTtBQUFBLFlBQUFDLFFBQUFDLE1BQUFDO0FBQUFBLGFBQUFDLFlBQUFsQztBQUFBQSxLQ3lWd0IsWUFDWjtBQUFBO0FBQUEsTUFBQW1DLE9BRFk7QUFBQSxNQUFBcEQsUUFBQTtBQUFBLE1BQUFxRCxRQUFBO0FBQUEsTUFBQUMsUUFBQTtBQUFBLEtBR2xCO0FBQUEsd0RBRXNDO0FBQUEsMEJBRHBCLGtCQUNxQztBQUFBO0FBQUEsSUFFeEMsK0NBQWtCO0FBQUEsR0FBQztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTURoV3hDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJbQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbigqIGJsaXRfc3RyaW5nIGRvZXNuJ3QgZXhpc3QgaW4gW1N0ZExhYmVscy5CeXRlc10uLi4gICopXG5sZXQgYnl0ZXNfYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICBCeXRlcy5ibGl0X3N0cmluZyBzcmMgc3JjX3BvcyBkc3QgZHN0X3BvcyBsZW5cbjs7XG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIEZvcm1hdFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcblxubGV0IHNleHBfb2ZfdCB0ID0gdFxubGV0IHRfb2Zfc2V4cCB0ID0gdFxuXG5sZXQgcmVjIGNvbXBhcmVfbGlzdCBhIGIgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICBsZXQgcmVzID0gY29tcGFyZSB4IHkgaW5cbiAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCB4cyB5c1xuXG5hbmQgY29tcGFyZSBhIGIgPVxuICBpZiBhID09IGJcbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgQXRvbSBhLCBBdG9tIGIgLT4gU3RyaW5nLmNvbXBhcmUgYSBiXG4gICAgfCBBdG9tIF8sIF8gLT4gLTFcbiAgICB8IF8sIEF0b20gXyAtPiAxXG4gICAgfCBMaXN0IGEsIExpc3QgYiAtPiBjb21wYXJlX2xpc3QgYSBiKVxuOztcblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5leGNlcHRpb24gTm90X2ZvdW5kX3Mgb2YgdFxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3Igb2YgZXhuICogdFxuXG5tb2R1bGUgUHJpbnRpbmcgPSBzdHJ1Y3RcbiAgKCogRGVmYXVsdCBpbmRlbnRhdGlvbiBsZXZlbCBmb3IgaHVtYW4tcmVhZGFibGUgY29udmVyc2lvbnMgKilcblxuICBsZXQgZGVmYXVsdF9pbmRlbnQgPSByZWYgMVxuXG4gICgqIEVzY2FwaW5nIG9mIHN0cmluZ3MgdXNlZCBhcyBhdG9tcyBpbiBTLWV4cHJlc3Npb25zICopXG5cbiAgbGV0IG11c3RfZXNjYXBlIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGVuID0gMFxuICAgIHx8XG4gICAgbGV0IHJlYyBsb29wIHN0ciBpeCA9XG4gICAgICBtYXRjaCBzdHIuW2l4XSB3aXRoXG4gICAgICB8ICdcIicgfCAnKCcgfCAnKScgfCAnOycgfCAnXFxcXCcgLT4gdHJ1ZVxuICAgICAgfCAnfCcgLT5cbiAgICAgICAgaXggPiAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBuZXh0ID0gaXggLSAxIGluXG4gICAgICAgIENoYXIuZXF1YWwgc3RyLltuZXh0XSAnIycgfHwgbG9vcCBzdHIgbmV4dFxuICAgICAgfCAnIycgLT5cbiAgICAgICAgaXggPiAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBuZXh0ID0gaXggLSAxIGluXG4gICAgICAgIENoYXIuZXF1YWwgc3RyLltuZXh0XSAnfCcgfHwgbG9vcCBzdHIgbmV4dFxuICAgICAgfCAnXFwwMDAnIC4uICdcXDAzMicgfCAnXFwxMjcnIC4uICdcXDI1NScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGl4ID4gMCAmJiBsb29wIHN0ciAoaXggLSAxKVxuICAgIGluXG4gICAgbG9vcCBzdHIgKGxlbiAtIDEpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZWQgcyA9XG4gICAgbGV0IG4gPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBuXG4gICAgICA6PSAhblxuICAgICAgICAgK1xuICAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICAgIHwgXyAtPiA0XG4gICAgZG9uZTtcbiAgICBpZiAhbiA9IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHMnID0gQnl0ZXMuY3JlYXRlICFuIGluXG4gICAgICBuIDo9IDA7XG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICAobWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgICAgIHwgJyAnIC4uICd+JyBhcyBjIC0+IEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgICAgfCBjIC0+XG4gICAgICAgICAgIGxldCBhID0gQ2hhci5jb2RlIGMgaW5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgLyAxMDApKSk7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgLyAxMCBtb2QgMTApKSk7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgbW9kIDEwKSkpKTtcbiAgICAgICAgaW5jciBuXG4gICAgICBkb25lO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzJylcbiAgOztcblxuICBsZXQgZXNjX3N0ciBzdHIgPVxuICAgIGxldCBlc3RyID0gZXNjYXBlZCBzdHIgaW5cbiAgICBsZXQgZWxlbiA9IFN0cmluZy5sZW5ndGggZXN0ciBpblxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgKGVsZW4gKyAyKSBpblxuICAgIGJ5dGVzX2JsaXRfc3RyaW5nIH5zcmM6ZXN0ciB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOjEgfmxlbjplbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIDAgJ1wiJztcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyAoZWxlbiArIDEpICdcIic7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgOztcblxuICBsZXQgaW5kZXhfb2ZfbmV3bGluZSBzdHIgc3RhcnQgPSBTdHJpbmcuaW5kZXhfZnJvbV9vcHQgc3RyIHN0YXJ0ICdcXG4nXG5cbiAgbGV0IGdldF9zdWJzdHJpbmcgc3RyIGluZGV4IGVuZF9wb3Nfb3B0ID1cbiAgICBsZXQgZW5kX3BvcyA9XG4gICAgICBtYXRjaCBlbmRfcG9zX29wdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBzdHJcbiAgICAgIHwgU29tZSBlbmRfcG9zIC0+IGVuZF9wb3NcbiAgICBpblxuICAgIFN0cmluZy5zdWIgc3RyIH5wb3M6aW5kZXggfmxlbjooZW5kX3BvcyAtIGluZGV4KVxuICA7O1xuXG4gIGxldCBpc19vbmVfbGluZSBzdHIgPVxuICAgIG1hdGNoIGluZGV4X29mX25ld2xpbmUgc3RyIDAgd2l0aFxuICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIGluZGV4IC0+IGluZGV4ICsgMSA9IFN0cmluZy5sZW5ndGggc3RyXG4gIDs7XG5cbiAgbGV0IHBwX2h1bV9tYXliZV9lc2Nfc3RyIHBwZiBzdHIgPVxuICAgIGlmIG5vdCAobXVzdF9lc2NhcGUgc3RyKVxuICAgIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiBzdHJcbiAgICBlbHNlIGlmIGlzX29uZV9saW5lIHN0clxuICAgIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiAoZXNjX3N0ciBzdHIpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgaW5kZXggPVxuICAgICAgICBsZXQgbmV4dF9uZXdsaW5lID0gaW5kZXhfb2ZfbmV3bGluZSBzdHIgaW5kZXggaW5cbiAgICAgICAgbGV0IG5leHRfbGluZSA9IGdldF9zdWJzdHJpbmcgc3RyIGluZGV4IG5leHRfbmV3bGluZSBpblxuICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIChlc2NhcGVkIG5leHRfbGluZSk7XG4gICAgICAgIG1hdGNoIG5leHRfbmV3bGluZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgbmV3bGluZV9pbmRleCAtPlxuICAgICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFxcXCI7XG4gICAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKCk7XG4gICAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXFxuXCI7XG4gICAgICAgICAgbG9vcCAobmV3bGluZV9pbmRleCArIDEpXG4gICAgICBpblxuICAgICAgcHBfb3Blbl9ib3ggcHBmIDA7XG4gICAgICAoKiB0aGUgbGVhZGluZyBzcGFjZSBpcyB0byBsaW5lIHVwIHRoZSBsaW5lcyAqKVxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIiBcXFwiXCI7XG4gICAgICBsb29wIDA7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcIlwiO1xuICAgICAgcHBfY2xvc2VfYm94IHBwZiAoKSlcbiAgOztcblxuICBsZXQgbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciA9IGlmIG11c3RfZXNjYXBlIHN0ciB0aGVuIGVzY19zdHIgc3RyIGVsc2Ugc3RyXG5cbiAgKCogT3V0cHV0IG9mIFMtZXhwcmVzc2lvbnMgdG8gZm9ybWF0dGVycyAqKVxuXG4gIGxldCByZWMgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IHBwX2h1bV9tYXliZV9lc2Nfc3RyIHBwZiBzdHJcbiAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgIHBwX29wZW5fYm94IHBwZiBpbmRlbnQ7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKFwiO1xuICAgICAgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmIGg7XG4gICAgICBwcF9odW1fcmVzdCBpbmRlbnQgcHBmIHRcbiAgICB8IExpc3QgW10gLT4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIigpXCJcblxuICBhbmQgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBoIDo6IHQgLT5cbiAgICAgIHBwX3ByaW50X3NwYWNlIHBwZiAoKTtcbiAgICAgIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiBoO1xuICAgICAgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiB0XG4gICAgfCBbXSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIilcIjtcbiAgICAgIHBwX2Nsb3NlX2JveCBwcGYgKClcbiAgOztcblxuICBsZXQgcmVjIHBwX21hY2hfaW50ZXJuYWwgbWF5X25lZWRfc3BhY2UgcHBmID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+XG4gICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIiBcIjtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgc3RyJztcbiAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIihcIjtcbiAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IHBwX21hY2hfaW50ZXJuYWwgZmFsc2UgcHBmIGggaW5cbiAgICAgIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgdDtcbiAgICAgIGZhbHNlXG4gICAgfCBMaXN0IFtdIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKClcIjtcbiAgICAgIGZhbHNlXG5cbiAgYW5kIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgPSBmdW5jdGlvblxuICAgIHwgaCA6OiB0IC0+XG4gICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBwcF9tYWNoX2ludGVybmFsIG1heV9uZWVkX3NwYWNlIHBwZiBoIGluXG4gICAgICBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmIHRcbiAgICB8IFtdIC0+IHBwX3ByaW50X3N0cmluZyBwcGYgXCIpXCJcbiAgOztcblxuICBsZXQgcHBfaHVtIHBwZiBzZXhwID0gcHBfaHVtX2luZGVudCAhZGVmYXVsdF9pbmRlbnQgcHBmIHNleHBcbiAgbGV0IHBwX21hY2ggcHBmIHNleHAgPSBpZ25vcmUgKHBwX21hY2hfaW50ZXJuYWwgZmFsc2UgcHBmIHNleHApXG4gIGxldCBwcCA9IHBwX21hY2hcblxuICAoKiBTZXhwIHNpemUgKilcblxuICBsZXQgcmVjIHNpemVfbG9vcCAoKHYsIGMpIGFzIGFjYykgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gdiArIDEsIGMgKyBTdHJpbmcubGVuZ3RoIHN0clxuICAgIHwgTGlzdCBsc3QgLT4gTGlzdC5mb2xkX2xlZnQgbHN0IH5pbml0OmFjYyB+ZjpzaXplX2xvb3BcbiAgOztcblxuICBsZXQgc2l6ZSBzZXhwID0gc2l6ZV9sb29wICgwLCAwKSBzZXhwXG5cbiAgKCogQnVmZmVyIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IHRvX2J1ZmZlcl9odW0gfmJ1ZiA/KGluZGVudCA9ICFkZWZhdWx0X2luZGVudCkgc2V4cCA9XG4gICAgbGV0IHBwZiA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICAgIEZvcm1hdC5mcHJpbnRmIHBwZiBcIiVhQD9cIiAocHBfaHVtX2luZGVudCBpbmRlbnQpIHNleHBcbiAgOztcblxuICBsZXQgdG9fYnVmZmVyX21hY2ggfmJ1ZiBzZXhwID1cbiAgICBsZXQgcmVjIGxvb3AgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBBdG9tIHN0ciAtPlxuICAgICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgJyAnO1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgc3RyJztcbiAgICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgZmFsc2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdDtcbiAgICAgICAgZmFsc2VcbiAgICAgIHwgTGlzdCBbXSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIoKVwiO1xuICAgICAgICBmYWxzZVxuICAgIGFuZCBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBtYXlfbmVlZF9zcGFjZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0XG4gICAgICB8IFtdIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJyknXG4gICAgaW5cbiAgICBpZ25vcmUgKGxvb3AgZmFsc2Ugc2V4cClcbiAgOztcblxuICBsZXQgdG9fYnVmZmVyID0gdG9fYnVmZmVyX21hY2hcblxuICBsZXQgdG9fYnVmZmVyX2dlbiB+YnVmIH5hZGRfY2hhciB+YWRkX3N0cmluZyBzZXhwID1cbiAgICBsZXQgcmVjIGxvb3AgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBBdG9tIHN0ciAtPlxuICAgICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIGFkZF9jaGFyIGJ1ZiAnICc7XG4gICAgICAgIGFkZF9zdHJpbmcgYnVmIHN0cic7XG4gICAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICAgIGFkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgZmFsc2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdDtcbiAgICAgICAgZmFsc2VcbiAgICAgIHwgTGlzdCBbXSAtPlxuICAgICAgICBhZGRfc3RyaW5nIGJ1ZiBcIigpXCI7XG4gICAgICAgIGZhbHNlXG4gICAgYW5kIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIG1heV9uZWVkX3NwYWNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHRcbiAgICAgIHwgW10gLT4gYWRkX2NoYXIgYnVmICcpJ1xuICAgIGluXG4gICAgaWdub3JlIChsb29wIGZhbHNlIHNleHApXG4gIDs7XG5cbiAgKCogVGhlIG1heGltdW0gc2l6ZSBvZiBhIHRoaW5nIG9uIHRoZSBtaW5vciBoZWFwIGlzIDI1NiB3b3Jkcy5cbiAgICAgUHJldmlvdXNseSwgdGhpcyBzaXplIG9mIHRoZSByZXR1cm5lZCBidWZmZXIgaGVyZSB3YXMgNDA5NiBieXRlcywgd2hpY2hcbiAgICAgY2F1c2VkIHRoZSBCdWZmZXIgdG8gYmUgYWxsb2NhdGVkIG9uIHRoZSAqbWFqb3IqIGhlYXAgZXZlcnkgdGltZS5cblxuICAgICBBY2NvcmRpbmcgdG8gYSBzaW1wbGUgYmVuY2htYXJrIGJ5IFJvbiwgd2UgY2FuIGltcHJvdmUgcGVyZm9ybWFuY2UgZm9yXG4gICAgIHNtYWxsIHMtZXhwcmVzc2lvbnMgYnkgYSBmYWN0b3Igb2YgfjQgaWYgd2Ugb25seSBhbGxvY2F0ZSAxMDI0IGJ5dGVzXG4gICAgICgxMjggd29yZHMgKyBzb21lIHNtYWxsIG92ZXJoZWFkKSB3b3J0aCBvZiBidWZmZXIgaW5pdGlhbGx5LiAgQW5kIG9uZVxuICAgICBjYW4gYXJndWUgdGhhdCBpZiBpdCdzIGZyZWUgdG8gYWxsb2NhdGUgc3RyaW5ncyBzbWFsbGVyIHRoYW4gMjU2IHdvcmRzLFxuICAgICBsYXJnZSBzLWV4cHJlc3Npb25zIHJlcXVpcmluZyBsYXJnZXIgZXhwZW5zaXZlIGJ1ZmZlcnMgd29uJ3Qgbm90aWNlXG4gICAgIHRoZSBleHRyYSB0d28gZG91YmxpbmdzIGZyb20gMTAyNCBieXRlcyB0byAyMDQ4IGFuZCA0MDk2LiBBbmQgZXNwZWNpYWxseVxuICAgICBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgYXBwbGljYXRpb25zIHRvIGFsd2F5cyBwYXNzIGluIGEgbGFyZ2VyIGJ1ZmZlciB0b1xuICAgICB1c2UuICopXG4gIGxldCBidWZmZXIgKCkgPSBCdWZmZXIuY3JlYXRlIDEwMjRcblxuICAoKiBTdHJpbmcgY29udmVyc2lvbnMgKilcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/aW5kZW50ID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyXG4gICAgICB3aGVuIG1hdGNoIGluZGV4X29mX25ld2xpbmUgc3RyIDAgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICB8IFNvbWUgXyAtPiBmYWxzZSAtPiBtYWNoX21heWJlX2VzY19zdHIgc3RyXG4gICAgfCBzZXhwIC0+XG4gICAgICBsZXQgYnVmID0gYnVmZmVyICgpIGluXG4gICAgICB0b19idWZmZXJfaHVtID9pbmRlbnQgc2V4cCB+YnVmO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfbWFjaCA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiBtYWNoX21heWJlX2VzY19zdHIgc3RyXG4gICAgfCBzZXhwIC0+XG4gICAgICBsZXQgYnVmID0gYnVmZmVyICgpIGluXG4gICAgICB0b19idWZmZXJfbWFjaCBzZXhwIH5idWY7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ19tYWNoXG5lbmRcblxuaW5jbHVkZSBQcmludGluZ1xuXG5sZXQgb2ZfZmxvYXRfc3R5bGUgOiBbIGBVbmRlcnNjb3JlcyB8IGBOb191bmRlcnNjb3JlcyBdIHJlZiA9IHJlZiBgTm9fdW5kZXJzY29yZXNcbmxldCBvZl9pbnRfc3R5bGUgOiBbIGBVbmRlcnNjb3JlcyB8IGBOb191bmRlcnNjb3JlcyBdIHJlZiA9IHJlZiBgTm9fdW5kZXJzY29yZXNcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmludGluZ1xuZW5kXG5cbmxldCBtZXNzYWdlIG5hbWUgZmllbGRzID1cbiAgbGV0IHJlYyBjb252X2ZpZWxkcyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgKGZuYW1lLCBmc2V4cCkgOjogcmVzdCAtPlxuICAgICAgKG1hdGNoIGZuYW1lIHdpdGhcbiAgICAgICB8IFwiXCIgLT4gZnNleHAgOjogY29udl9maWVsZHMgcmVzdFxuICAgICAgIHwgXyAtPiBMaXN0IFsgQXRvbSBmbmFtZTsgZnNleHAgXSA6OiBjb252X2ZpZWxkcyByZXN0KVxuICBpblxuICBMaXN0IChBdG9tIG5hbWUgOjogY29udl9maWVsZHMgZmllbGRzKVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1NTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImRvY19jb21tZW50X3RhZyIsInR5cGVfbmFtZV90YWciLCJhc3NvY190YWciLCJhc3NvY19rZXlfdGFnIiwiYXNzb2NfdmFsdWVfdGFnIiwiY29tcGxldGlvbl9zdWdnZXN0ZWQiLCJjb2VyY2UiLCJ0IiwidGFnIiwicGFyYW0iLCJrZXkiLCJ2YWx1ZSIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9zZXhwbGliMC9zZXhwX2dyYW1tYXIubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxZQUFBQyxPQUFBQyxHQ29MMkQsU0FBQztBQUFBLFlBQUFDLElBQUFDLE9BQUFDLEtBQUFDLE9BRzFELG1DQUE0QztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUR2TDlDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiogUmVwcmVzZW50YXRpb24gb2YgUy1leHByZXNzaW9uIGdyYW1tYXJzICopXG5cbigqKiBUaGlzIG1vZHVsZSBkZWZpbmVzIGEgcmVwcmVzZW50YXRpb24gZm9yIHMtZXhwcmVzc2lvbiBncmFtbWFycy4gVXNpbmcgcHB4X3NleHBfY29udlxuICAgIGFuZCBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gcHJvZHVjZXMgYSBncmFtbWFyIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBkZXJpdmVkXG4gICAgW29mX3NleHBdIGZvciBhIGdpdmVuIHR5cGUuXG5cbiAgICBBcyB3aXRoIG90aGVyIGRlcml2ZWQgZGVmaW5pdGlvbnMsIHBvbHltb3JwaGljIHR5cGVzIGRlcml2ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYVxuICAgIGdyYW1tYXIgZm9yIGVhY2ggdHlwZSBhcmd1bWVudCBhbmQgcHJvZHVjZXMgYSBncmFtbWFyIGZvciB0aGUgbW9ub21vcnBoaXplZCB0eXBlLlxuXG4gICAgTW9ub21vcnBoaWMgdHlwZXMgZGVyaXZlIGEgZ3JhbW1hciBkaXJlY3RseS4gVG8gYXZvaWQgdG9wLWxldmVsIHNpZGUgZWZmZWN0cyxcbiAgICBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gd3JhcHMgZ3JhbW1hcnMgaW4gdGhlIFtMYXp5XSBjb25zdHJ1Y3RvciBhcyBuZWVkZWQuXG5cbiAgICBUaGlzIHR5cGUgbWF5IGNoYW5nZSBvdmVyIHRpbWUgYXMgb3VyIG5lZWRzIGZvciBleHByZXNzaXZlIGdyYW1tYXJzIGNoYW5nZS4gV2Ugd2lsbFxuICAgIGF0dGVtcHQgdG8gbWFrZSBjaGFuZ2VzIGJhY2t3YXJkLWNvbXBhdGlibGUsIG9yIGF0IGxlYXN0IHByb3ZpZGUgYSByZWFzb25hYmxlIHVwZ3JhZGVcbiAgICBwYXRoLiAqKVxuXG5bQEBAd2FybmluZyBcIi0zMFwiXSAoKiBhbGxvdyBkdXBsaWNhdGUgZmllbGQgbmFtZXMgKilcblxuKCoqIEdyYW1tYXIgb2YgYSBzZXhwLiAqKVxudHlwZSBncmFtbWFyID1cbiAgfCBBbnkgb2Ygc3RyaW5nICgqKiBhY2NlcHRzIGFueSBzZXhwOyBzdHJpbmcgaXMgYSB0eXBlIG5hbWUgZm9yIGh1bWFuIHJlYWRhYmlsaXR5ICopXG4gIHwgQm9vbCAoKiogYWNjZXB0cyB0aGUgYXRvbXMgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLCBtb2R1bG8gY2FwaXRhbGl6YXRpb24gKilcbiAgfCBDaGFyICgqKiBhY2NlcHRzIGFueSBzaW5nbGUtY2hhcmFjdGVyIGF0b20gKilcbiAgfCBJbnRlZ2VyICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGludGVnZXIgc3ludGF4LCByZWdhcmRsZXNzIG9mIGJpdCB3aWR0aCAqKVxuICB8IEZsb2F0ICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGZsb2F0IHN5bnRheCAqKVxuICB8IFN0cmluZyAoKiogYWNjZXB0cyBhbnkgYXRvbSAqKVxuICB8IE9wdGlvbiBvZiBncmFtbWFyICgqKiBhY2NlcHRzIGFuIG9wdGlvbiwgYm90aCBbTm9uZV0gdnMgW1NvbWUgX10gYW5kIFsoKV0gdnMgWyhfKV0uICopXG4gIHwgTGlzdCBvZiBsaXN0X2dyYW1tYXIgKCoqIGFjY2VwdHMgYSBsaXN0ICopXG4gIHwgVmFyaWFudCBvZiB2YXJpYW50ICgqKiBhY2NlcHRzIGNsYXVzZXMga2V5ZWQgYnkgYSBsZWFkaW5nIG9yIHNvbGUgYXRvbSAqKVxuICB8IFVuaW9uIG9mIGdyYW1tYXIgbGlzdCAoKiogYWNjZXB0cyBhIHNleHAgaWYgYW55IG9mIHRoZSBsaXN0ZWQgZ3JhbW1hcnMgYWNjZXB0cyBpdCAqKVxuICB8IFRhZ2dlZCBvZiBncmFtbWFyIHdpdGhfdGFnXG4gICgqKiBhbm5vdGF0ZXMgYSBncmFtbWFyIHdpdGggYSBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIgKilcbiAgfCBUeXZhciBvZiBzdHJpbmdcbiAgKCoqIE5hbWUgb2YgYSB0eXBlIHZhcmlhYmxlLCBlLmcuIFtUeXZhciBcImFcIl0gZm9yIFsnYV0uIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBib2R5IG9mXG4gICAgICB0aGUgaW5uZXJtb3N0IGVuY2xvc2luZyBbZGVmbl0gZGVmaW5lcyBhIGNvcnJlc3BvbmRpbmcgdHlwZSB2YXJpYWJsZS4gKilcbiAgfCBUeWNvbiBvZiBzdHJpbmcgKiBncmFtbWFyIGxpc3QgKiBkZWZuIGxpc3RcbiAgKCoqIFR5cGUgY29uc3RydWN0b3IgYXBwbGllZCB0byBhcmd1bWVudHMsIGFuZCBpdHMgZGVmaW5pdGlvbi5cblxuICAgICAgRm9yIGV4YW1wbGUsIHdyaXRpbmcgW1R5Y29uIChcInRyZWVcIiwgWyBJbnRlZ2VyIF0sIGRlZm5zKV0gcmVwcmVzZW50cyBbaW50IHRyZWVdLCBmb3JcbiAgICAgIHdoYXRldmVyIFt0cmVlXSBpcyBkZWZpbmVkIGFzIGluIFtkZWZuc10uIFRoZSBmb2xsb3dpbmcgZGVmaW5lcyBbdHJlZV0gYXMgYSBiaW5hcnlcbiAgICAgIHRyZWUgd2l0aCB0aGUgcGFyYW1ldGVyIHR5cGUgc3RvcmVkIGF0IHRoZSBsZWF2ZXMuXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBkZWZucyA9XG4gICAgICAgICAgWyB7IHR5Y29uID0gXCJ0cmVlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFJlY3Vyc2l2ZSAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICA7IHsgbmFtZSA9IFwiTGVhZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChSZWN1cnNpdmUgKFwibGVhZlwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDsgeyB0eWNvbiA9IFwibm9kZVwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9IExpc3QgKE1hbnkgKFJlY3Vyc2l2ZSBcInRyZWVcIiwgW1R5dmFyIFwiYVwiXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJsZWFmXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gW1R5dmFyIFwiYVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgOztcbiAgICAgIF19XG5cbiAgICAgIFRvIGlsbHVzdHJhdGUgdGhlIG1lYW5pbmcgb2YgW1R5Y29uXSB3aXRoIHJlc3BlY3QgdG8gW2RlZm5zXSwgYW5kIHRvIGRlbW9uc3RyYXRlIG9uZVxuICAgICAgd2F5IHRvIGFjY2VzcyB0aGVtLCBpdCBpcyBlcXVpdmFsZW50IHRvIGV4cGFuZCB0aGUgZGVmaW5pdGlvbiBvZiBcInRyZWVcIiBvbmUgbGV2ZWxcbiAgICAgIGFuZCBtb3ZlIHRoZSBbZGVmbnNdIHRvIGVuY2xvc2VkIHJlY3Vyc2l2ZSByZWZlcmVuY2VzOlxuXG4gICAgICB7W1xuICAgICAgICBUeWNvbiAoXCJ0cmVlXCIsIFsgSW50ZWdlciBdLCBkZWZucylcbiAgICAgICAgLS0+XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyB7IG5hbWUgPSBcIk5vZGVcIlxuICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcIm5vZGVcIiwgW1R5dmFyIFwiYVwiXSwgZGVmbnMpLCBFbXB0eSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJMZWFmXCJcbiAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0sIGRlZm5zKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgXX1cblxuICAgICAgVGhpcyB0cmFuc2Zvcm1hdGlvbiBleHBvc2VzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBncmFtbWFyIHdpdGggcmVjdXJzaXZlIHJlZmVyZW5jZXMsXG4gICAgICB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBtZWFuaW5nIG9mIHJlY3Vyc2l2ZWx5LWRlZmluZWQgZWxlbWVudHMuICopXG4gIHwgUmVjdXJzaXZlIG9mIHN0cmluZyAqIGdyYW1tYXIgbGlzdFxuICAoKiogVHlwZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRvIGFyZ3VtZW50cy4gVXNlZCB0byBkZW5vdGUgcmVjdXJzaXZlIHR5cGUgcmVmZXJlbmNlcy5cbiAgICAgIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHVzZWQgaW5zaWRlIHRoZSBbZGVmbl1zIG9mIGEgW1R5Y29uXSBncmFtbWFyLCB0byByZWZlciB0byBhXG4gICAgICB0eXBlIGNvbnN0cnVjdG9yIGluIHRoZSBuZWFyZXN0IGVuY2xvc2luZyBbZGVmbl0gbGlzdC4gKilcbiAgfCBMYXp5IG9mIGdyYW1tYXIgbGF6eV90XG4gICgqKiBMYXppbHkgY29tcHV0ZWQgZ3JhbW1hci4gVXNlIFtMYXp5XSB0byBhdm9pZCB0b3AtbGV2ZWwgc2lkZSBlZmZlY3RzLiBUbyBkZWZpbmVcbiAgICAgIHJlY3Vyc2l2ZSBncmFtbWFycywgdXNlIFtSZWN1cnNpdmVdIGluc3RlYWQuICopXG5cbigqKiBHcmFtbWFyIG9mIGEgbGlzdCBvZiBzZXhwcy4gKilcbmFuZCBsaXN0X2dyYW1tYXIgPVxuICB8IEVtcHR5ICgqKiBhY2NlcHRzIGFuIGVtcHR5IGxpc3Qgb2Ygc2V4cHMgKilcbiAgfCBDb25zIG9mIGdyYW1tYXIgKiBsaXN0X2dyYW1tYXJcbiAgKCoqIGFjY2VwdHMgYSBub24tZW1wdHkgbGlzdCB3aXRoIGhlYWQgYW5kIHRhaWwgbWF0Y2hpbmcgdGhlIGdpdmVuIGdyYW1tYXJzICopXG4gIHwgTWFueSBvZiBncmFtbWFyICgqKiBhY2NlcHRzIHplcm8gb3IgbW9yZSBzZXhwcywgZWFjaCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hciAqKVxuICB8IEZpZWxkcyBvZiByZWNvcmQgKCoqIGFjY2VwdHMgc2V4cHMgcmVwcmVzZW50aW5nIGZpZWxkcyBvZiBhIHJlY29yZCAqKVxuXG4oKiogQ2FzZSBzZW5zaXRpdml0eSBvcHRpb25zIGZvciBuYW1lcyBvZiB2YXJpYW50IGNvbnN0cnVjdG9ycy4gKilcbmFuZCBjYXNlX3NlbnNpdGl2aXR5ID1cbiAgfCBDYXNlX2luc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUuIFVzZWQgZm9yIGN1c3RvbSBwYXJzZXJzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLiBVc2VkIGZvciBwb2x5bW9ycGhpYyB2YXJpYW50cy4gKilcbiAgfCBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUgZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGNhc2Ugc2Vuc2l0aXZlIGFmdGVyd2FyZC5cbiAgICAgIFVzZWQgZm9yIHJlZ3VsYXIgdmFyaWFudHMuICopXG5cbigqKiBHcmFtbWFyIG9mIHZhcmlhbnRzLiBBY2NlcHRzIGFueSBzZXhwIG1hdGNoaW5nIG9uZSBvZiB0aGUgY2xhdXNlcy4gKilcbmFuZCB2YXJpYW50ID1cbiAgeyBjYXNlX3NlbnNpdGl2aXR5IDogY2FzZV9zZW5zaXRpdml0eVxuICA7IGNsYXVzZXMgOiBjbGF1c2Ugd2l0aF90YWdfbGlzdCBsaXN0XG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UuIEFjY2VwdHMgc2V4cHMgYmFzZWQgb24gdGhlIFtjbGF1c2Vfa2luZF0uICopXG5hbmQgY2xhdXNlID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgY2xhdXNlX2tpbmQgOiBjbGF1c2Vfa2luZFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgc2luZ2xlIHZhcmlhbnQgY2xhdXNlJ3MgY29udGVudHMuIFtBdG9tX2NsYXVzZV0gYWNjZXB0cyBhbiBhdG9tIG1hdGNoaW5nXG4gICAgdGhlIGNsYXVzZSdzIG5hbWUuIFtMaXN0X2NsYXVzZV0gYWNjZXB0cyBhIGxpc3Qgd2hvc2UgaGVhZCBpcyBhbiBhdG9tIG1hdGNoaW5nIHRoZVxuICAgIGNsYXVzZSdzIG5hbWUgYW5kIHdob3NlIHRhaWwgbWF0Y2hlcyBbYXJnc10uIFRoZSBjbGF1c2UncyBuYW1lIGlzIG1hdGNoZWQgbW9kdWxvIHRoZVxuICAgIHZhcmlhbnQncyBbbmFtZV9raW5kXS4gKilcbmFuZCBjbGF1c2Vfa2luZCA9XG4gIHwgQXRvbV9jbGF1c2VcbiAgfCBMaXN0X2NsYXVzZSBvZiB7IGFyZ3MgOiBsaXN0X2dyYW1tYXIgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZC4gQWNjZXB0cyBhbnkgbGlzdCBvZiBzZXhwcyBzcGVjaWZ5aW5nIGVhY2ggb2YgdGhlIGZpZWxkcyxcbiAgICByZWdhcmRsZXNzIG9mIG9yZGVyLiBJZiBbYWxsb3dfZXh0cmFfZmllbGRzXSBpcyBzcGVjaWZpZWQsIGlnbm9yZXMgc2V4cHMgd2l0aCBuYW1lc1xuICAgIG5vdCBmb3VuZCBpbiBbZmllbGRzXS4gKilcbmFuZCByZWNvcmQgPVxuICB7IGFsbG93X2V4dHJhX2ZpZWxkcyA6IGJvb2xcbiAgOyBmaWVsZHMgOiBmaWVsZCB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZCBmaWVsZC4gQSBmaWVsZCBtdXN0IHNob3cgdXAgZXhhY3RseSBvbmNlIGluIGEgcmVjb3JkIGlmXG4gICAgW3JlcXVpcmVkXSwgb3IgYXQgbW9zdCBvbmNlIG90aGVyd2lzZS4gQWNjZXB0cyBhIGxpc3QgaGVhZGVkIGJ5IFtuYW1lXSBhcyBhbiBhdG9tLFxuICAgIGZvbGxvd2VkIGJ5IHNleHBzIG1hdGNoaW5nIFthcmdzXS4gKilcbmFuZCBmaWVsZCA9XG4gIHsgbmFtZSA6IHN0cmluZ1xuICA7IHJlcXVpcmVkIDogYm9vbFxuICA7IGFyZ3MgOiBsaXN0X2dyYW1tYXJcbiAgfVxuXG4oKiogR3JhbW1hciB0YWdnZWQgd2l0aCBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIuICopXG5hbmQgJ2Egd2l0aF90YWcgPVxuICB7IGtleSA6IHN0cmluZ1xuICA7IHZhbHVlIDogU2V4cC50XG4gIDsgZ3JhbW1hciA6ICdhXG4gIH1cblxuYW5kICdhIHdpdGhfdGFnX2xpc3QgPVxuICB8IFRhZyBvZiAnYSB3aXRoX3RhZ19saXN0IHdpdGhfdGFnXG4gIHwgTm9fdGFnIG9mICdhXG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjdXJzaXZlIHR5cGUgZGVmaW5pdGlvbi4gTmFtZXMgdGhlIFt0eWNvbl0gYmVpbmcgZGVmaW5lZCwgYW5kIHRoZVxuICAgIFt0eXZhcnNdIGl0IHRha2VzIGFzIHBhcmFtZXRlcnMuIFNwZWNpZmllcyB0aGUgW2dyYW1tYXJdIG9mIHRoZSBbdHljb25dLiBUaGUgZ3JhbW1hclxuICAgIG1heSByZWZlciB0byBhbnkgb2YgdGhlIFt0eXZhcnNdLCBhbmQgdG8gYW55IG9mIHRoZSBbdHljb25dcyBmcm9tIHRoZSBzYW1lIHNldCBvZlxuICAgIFtSZWN1cnNpdmVdIGRlZmluaXRpb25zLiAqKVxuYW5kIGRlZm4gPVxuICB7IHR5Y29uIDogc3RyaW5nXG4gIDsgdHl2YXJzIDogc3RyaW5nIGxpc3RcbiAgOyBncmFtbWFyIDogZ3JhbW1hclxuICB9XG5cbigqKiBUb3AtbGV2ZWwgZ3JhbW1hciB0eXBlLiBIYXMgYSBwaGFudG9tIHR5cGUgcGFyYW1ldGVyIHRvIGFzc29jaWF0ZSBlYWNoIGdyYW1tYXIgd2l0aFxuICAgIHRoZSB0eXBlIGl0cyBzZXhwcyByZXByZXNlbnQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGFwcGx5IGdyYW1tYXJzIHRvIHRoZSB3cm9uZ1xuICAgIHR5cGUsIHdoaWxlIGdyYW1tYXJzIGNhbiBzdGlsbCBiZSBlYXNpbHkgY29lcmNlZCB0byBhIG5ldyB0eXBlIGlmIG5lZWRlZC4gKilcbnR5cGUgXyB0ID0geyB1bnR5cGVkIDogZ3JhbW1hciB9IFtAQHVuYm94ZWRdXG5cbmxldCBjb2VyY2UgKHR5cGUgYSBiKSAoeyB1bnR5cGVkID0gXyB9IGFzIHQgOiBhIHQpIDogYiB0ID0gdFxuXG5sZXQgdGFnICh0eXBlIGEpICh7IHVudHlwZWQgPSBncmFtbWFyIH0gOiBhIHQpIH5rZXkgfnZhbHVlIDogYSB0ID1cbiAgeyB1bnR5cGVkID0gVGFnZ2VkIHsga2V5OyB2YWx1ZTsgZ3JhbW1hciB9IH1cbjs7XG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpcyB1c2VkIGZvciBhbGwgdGFncyBnZW5lcmF0ZWQgZnJvbSBkb2MgY29tbWVudHMuICopXG5sZXQgZG9jX2NvbW1lbnRfdGFnID0gXCJzZXhwX2dyYW1tYXIuZG9jX2NvbW1lbnRcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgY2FuIGJlIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHlwZSBuYW1lIHdpdGggYSBncmFtbWFyLiAqKVxubGV0IHR5cGVfbmFtZV90YWcgPSBcInNleHBfZ3JhbW1hci50eXBlX25hbWVcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIHJlcHJlc2VudHMgYSBrZXkvdmFsdWUgYXNzb2NpYXRpb24uIFRoZSB0YWcnc1xuICAgIHZhbHVlIGlzIGlnbm9yZWQuICopXG5sZXQgYXNzb2NfdGFnID0gXCJzZXhwX2dyYW1tYXIuYXNzb2NcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIGlzIGEga2V5IGluIGEga2V5L3ZhbHVlIGFzc29jaWF0aW9uLiBUaGUgdGFnJ3NcbiAgICB2YWx1ZSBpcyBpZ25vcmVkLiAqKVxubGV0IGFzc29jX2tleV90YWcgPSBcInNleHBfZ3JhbW1hci5hc3NvYy5rZXlcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIGlzIGEgdmFsdWUgaW4gYSBrZXkvdmFsdWUgYXNzb2NpYXRpb24uIFRoZVxuICAgIHRhZydzIHZhbHVlIGlzIGlnbm9yZWQuICopXG5sZXQgYXNzb2NfdmFsdWVfdGFnID0gXCJzZXhwX2dyYW1tYXIuYXNzb2MudmFsdWVcIlxuXG4oKiogV2hlbiB0aGUga2V5IGlzIHNldCB0byBbQXRvbSBcImZhbHNlXCJdIGZvciBhIHZhcmlhbnQgY2xhdXNlLCB0aGF0IGNsYXVzZSBzaG91bGQgbm90IGJlXG4gICAgc3VnZ2VzdGVkIGluIGF1dG8tY29tcGxldGlvbiBiYXNlZCBvbiB0aGUgc2V4cCBncmFtbWFyLiAqKVxubGV0IGNvbXBsZXRpb25fc3VnZ2VzdGVkID0gXCJzZXhwX2dyYW1tYXIuY29tcGxldGlvbi1zdWdnZXN0ZWRcIlxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjU4MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDMiLCJhMSIsImEyIiwiZ2xvYmFsX2RhdGEiLCJ1bml0X3NleHBfZ3JhbW1hciIsInNleHBfdF9zZXhwX2dyYW1tYXIiLCJlbXB0eV9zZXhwX2dyYW1tYXIiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJTdGRsaWJfTGlzdExhYmVscyIsInNleHBfZ3JhbW1hcl93aXRoX3RhZ3MiLCJncmFtbWFyIiwidGFncyIsInBhcmFtIiwidmFsdWUiLCJrZXkiLCJzZXhwX2dyYW1tYXJfd2l0aF90YWdfbGlzdCIsIngiLCJyZWZfc2V4cF9ncmFtbWFyIiwibGF6eV90X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9zZXhwX2dyYW1tYXIiLCJsaXN0X3NleHBfZ3JhbW1hciIsImFycmF5X3NleHBfZ3JhbW1hciIsIlNleHBsaWIwX1NleHBfY29udl9ncmFtbWFyIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3NleHBsaWIwL3NleHBfY29udl9ncmFtbWFyLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLHVCQUFBQyxTQUFBQztBQUFBQSxJQ0dFO0FBQUE7QUFBQSxzQkFBQUMsT0FBQUY7QUFBQUEsa0JBQUFHLFFBQXNDLFVBQUFDLE1BQUE7QUFBQSxjQUNwQztBQUFBLGFBQTRDO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsMkJBQUFDLEdBQUFMO0FBQUFBLElBSTlDO0FBQUE7QUFBQSxzQkFBQUMsT0FBQUY7QUFBQUEsa0JBQUFHLFFBQWdDLFVBQUFDLE1BQUE7QUFBQSxjQUM5QjtBQUFBLGFBQXlDO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUcsaUJBQUFQO0FBQUFBLElBY2Qsb0RBQTJCO0FBQUE7QUFBQSxZQUFBUSxvQkFBQVI7QUFBQUEsSUFDeEIsb0RBQTJCO0FBQUE7QUFBQSxZQUFBUyxvQkFBQVAsT0FHM0Qsa0JBQTRCO0FBQUEsWUFBQVEsa0JBQUFSLE9BSTVCLHVCQUFpQztBQUFBLFlBQUFTLG1CQUFBVCxPQUlqQyx1QkFBaUM7QUFBQTtBQUFBLElBQUFVO0FBQUFBLE1EbkNuQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBTdGRMYWJlbHNcblxubGV0IHNleHBfZ3JhbW1hcl93aXRoX3RhZ3MgZ3JhbW1hciB+dGFncyA9XG4gIExpc3QuZm9sZF9yaWdodCB0YWdzIH5pbml0OmdyYW1tYXIgfmY6KGZ1biAoa2V5LCB2YWx1ZSkgZ3JhbW1hciAtPlxuICAgIFNleHBfZ3JhbW1hci5UYWdnZWQgeyBrZXk7IHZhbHVlOyBncmFtbWFyIH0pXG47O1xuXG5sZXQgc2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QgeCB+dGFncyA9XG4gIExpc3QuZm9sZF9yaWdodCB0YWdzIH5pbml0OnggfmY6KGZ1biAoa2V5LCB2YWx1ZSkgZ3JhbW1hciAtPlxuICAgIFNleHBfZ3JhbW1hci5UYWcgeyBrZXk7IHZhbHVlOyBncmFtbWFyIH0pXG47O1xuXG5sZXQgdW5pdF9zZXhwX2dyYW1tYXIgOiB1bml0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gTGlzdCBFbXB0eSB9XG5sZXQgYm9vbF9zZXhwX2dyYW1tYXIgOiBib29sIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQm9vbCB9XG5sZXQgc3RyaW5nX3NleHBfZ3JhbW1hciA6IHN0cmluZyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgYnl0ZXNfc2V4cF9ncmFtbWFyIDogYnl0ZXMgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBTdHJpbmcgfVxubGV0IGNoYXJfc2V4cF9ncmFtbWFyIDogY2hhciBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IENoYXIgfVxubGV0IGludF9zZXhwX2dyYW1tYXIgOiBpbnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBmbG9hdF9zZXhwX2dyYW1tYXIgOiBmbG9hdCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEZsb2F0IH1cbmxldCBpbnQzMl9zZXhwX2dyYW1tYXIgOiBpbnQzMiBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgbmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IHNleHBfdF9zZXhwX2dyYW1tYXIgOiBTZXhwLnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJTZXhwLnRcIiB9XG5sZXQgcmVmX3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5sZXQgbGF6eV90X3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5cbmxldCBvcHRpb25fc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBvcHRpb24gU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBPcHRpb24gdW50eXBlZCB9XG47O1xuXG5sZXQgbGlzdF9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGxpc3QgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBhcnJheV9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGFycmF5IFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gTGlzdCAoTWFueSB1bnR5cGVkKSB9XG47O1xuXG5sZXQgZW1wdHlfc2V4cF9ncmFtbWFyIDogXyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbmxldCBvcGFxdWVfc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG5sZXQgZnVuX3NleHBfZ3JhbW1hciA9IGVtcHR5X3NleHBfZ3JhbW1hclxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjY2NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0Fzc2VydF9mYWlsdXJlIiwiY3N0X05vbmUiLCJjc3RfU29tZSIsImNzdF9ub25lIiwiY3N0X29wdGlvbl9vZl9zZXhwX29ubHlfbm9uZV9jIiwiY3N0X3NvbWUiLCJjc3Rfc3JjX3NleHBfY29udl9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsImNhbWxfZm9ybWF0X2Zsb2F0IiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw1IiwiYTMiLCJhNCIsImdsb2JhbF9kYXRhIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWIiLCJTZXhwbGliMF9TZXhwIiwiU3RkbGliX0FyZyIsIlN0ZGxpYl9MYXp5IiwiU3RkbGliX1BhcnNpbmciLCJTdGRsaWJfUXVldWUiLCJTdGRsaWJfU2NhbmYiLCJTdGRsaWJfU3RhY2siLCJTdGRsaWJfU3lzIiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYl9Nb3JlTGFiZWxzIiwiU3RkbGliX0xpc3RMYWJlbHMiLCJTdGRsaWJfQnl0ZXNMYWJlbHMiLCJTdGRsaWJfUHJpbnRleGMiLCJTdGRsaWJfT2JqIiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYl9OYXRpdmVpbnQiLCJTdGRsaWJfSW50NjQiLCJTdGRsaWJfSW50MzIiLCJTdGRsaWJfU3RyaW5nTGFiZWxzIiwiU3RkbGliX0VwaGVtZXJvbiIsIlNleHBsaWIwX1NleHBfY29udl9ncmFtbWFyIiwiZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQiLCJ4IiwieSIsInJlYWRfb2xkX29wdGlvbl9mb3JtYXQiLCJ3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCIsImxpc3RfbWFwIiwibCIsInNleHBfb2ZfdW5pdCIsInBhcmFtIiwic2V4cF9vZl9ib29sIiwiYiIsInNleHBfb2Zfc3RyaW5nIiwic3RyIiwic2V4cF9vZl9ieXRlcyIsImJ5dGVzIiwic2V4cF9vZl9jaGFyIiwiYyIsInNleHBfb2ZfaW50IiwibiIsInNleHBfb2ZfZmxvYXQiLCJzZXhwX29mX2ludDMyIiwic2V4cF9vZl9pbnQ2NCIsInNleHBfb2ZfbmF0aXZlaW50Iiwic2V4cF9vZl9yZWYiLCJzZXhwX29mX2EiLCJyZiIsInNleHBfb2ZfbGF6eV90IiwibHYiLCJzZXhwX29mX29wdGlvbiIsInNleHBfb2ZfcGFpciIsInNleHBfb2ZfYiIsImEiLCJzZXhwX29mX3RyaXBsZSIsInNleHBfb2ZfYyIsInNleHBfb2ZfbGlzdCIsImxzdCIsInNleHBfb2ZfYXJyYXkiLCJhciIsImxzdF9yZWYiLCJpIiwic2V4cF9vZl9oYXNodGJsIiwic2V4cF9vZl9rZXkiLCJzZXhwX29mX3ZhbCIsImh0YmwiLCJjb2xsIiwiayIsInYiLCJhY2MiLCJzZXhwX29mX29wYXF1ZSIsInNleHBfb2ZfZnVuIiwiZXF1YWwiLCJoYXNoIiwiRXhuX3RhYmxlIiwidGhlX2V4bl90YWJsZSIsImFkZCIsIm9wdCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsInNleHBfb2ZfZXhuIiwicHJpbnRleGMiLCJmaW5kX2F1dG8iLCJmb3JfcHJpbnRleGMiLCJleG4iLCJtYXRjaCIsInNpemUiLCJGb3JfdW5pdF90ZXN0c19vbmx5Iiwic2V4cF9vZl9leG5fb3B0Iiwic2V4cCIsImV4bl90b19zdHJpbmciLCJlIiwicHJpbnRleGNfcHJlZmVyX3NleHAiLCJPZl9zZXhwX2Vycm9yIiwicmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyIsImNzdF91bml0X29mX3NleHBfZW1wdHlfbGlzdF9uZSIsImNzdF9ib29sX29mX3NleHBfdW5rbm93bl9zdHJpbiIsImNzdF9ib29sX29mX3NleHBfYXRvbV9uZWVkZWQiLCJjc3Rfc3RyaW5nX29mX3NleHBfYXRvbV9uZWVkZWQiLCJjc3RfYnl0ZXNfb2Zfc2V4cF9hdG9tX25lZWRlZCIsImNzdF9jaGFyX29mX3NleHBfYXRvbV9zdHJpbmdfbSIsImNzdF9jaGFyX29mX3NleHBfYXRvbV9uZWVkZWQiLCJjc3RfaW50X29mX3NleHAiLCJjc3RfaW50X29mX3NleHBfYXRvbV9uZWVkZWQiLCJjc3RfZmxvYXRfb2Zfc2V4cCIsImNzdF9mbG9hdF9vZl9zZXhwX2F0b21fbmVlZGVkIiwiY3N0X2ludDMyX29mX3NleHAiLCJjc3RfaW50MzJfb2Zfc2V4cF9hdG9tX25lZWRlZCIsImNzdF9pbnQ2NF9vZl9zZXhwIiwiY3N0X2ludDY0X29mX3NleHBfYXRvbV9uZWVkZWQiLCJjc3RfbmF0aXZlaW50X29mX3NleHAiLCJjc3RfbmF0aXZlaW50X29mX3NleHBfYXRvbV9uZWUiLCJjc3Rfb3B0aW9uX29mX3NleHBfbGlzdF9tdXN0X3IiLCJjc3Rfb3B0aW9uX29mX3NleHBfbGlzdF9tdXN0X2IiLCJjc3RfcGFpcl9vZl9zZXhwX2xpc3RfbmVlZGVkIiwiY3N0X3BhaXJfb2Zfc2V4cF9saXN0X211c3RfY29uIiwiY3N0X3RyaXBsZV9vZl9zZXhwX2xpc3RfbmVlZGVkIiwiY3N0X3RyaXBsZV9vZl9zZXhwX2xpc3RfbXVzdF9jIiwiY3N0X2xpc3Rfb2Zfc2V4cF9saXN0X25lZWRlZCIsImNzdF9hcnJheV9vZl9zZXhwX2xpc3RfbmVlZGVkIiwiY3N0X2hhc2h0Ymxfb2Zfc2V4cF9saXN0X25lZWRlIiwiY3N0X2hhc2h0Ymxfb2Zfc2V4cF90dXBsZV9saXN0IiwiY3N0X29wYXF1ZV9vZl9zZXhwX2Nhbm5vdF9jb252IiwiY3N0X2Z1bl9vZl9zZXhwX2Nhbm5vdF9jb252ZXJ0Iiwib2Zfc2V4cF9lcnJvcl9leG4iLCJleGMiLCJvZl9zZXhwX2Vycm9yIiwid2hhdCIsInVuaXRfb2Zfc2V4cCIsImJvb2xfb2Zfc2V4cCIsInN0cmluZ19vZl9zZXhwIiwiYnl0ZXNfb2Zfc2V4cCIsImNoYXJfb2Zfc2V4cCIsImludF9vZl9zZXhwIiwiZmxvYXRfb2Zfc2V4cCIsImludDMyX29mX3NleHAiLCJpbnQ2NF9vZl9zZXhwIiwibmF0aXZlaW50X29mX3NleHAiLCJyZWZfb2Zfc2V4cCIsImFfb2Zfc2V4cCIsImxhenlfdF9vZl9zZXhwIiwib3B0aW9uX29mX3NleHAiLCJlbCIsInBhaXJfb2Zfc2V4cCIsImJfb2Zfc2V4cCIsImJfc2V4cCIsImFfc2V4cCIsInRyaXBsZV9vZl9zZXhwIiwiY19vZl9zZXhwIiwiY19zZXhwIiwibGlzdF9vZl9zZXhwIiwicmV2X2xzdCIsImFycmF5X29mX3NleHAiLCJ0IiwiaCIsImxlbiIsInJlcyIsImhhc2h0Ymxfb2Zfc2V4cCIsImtleV9vZl9zZXhwIiwidmFsX29mX3NleHAiLCJhY3QiLCJ2X3NleHAiLCJrX3NleHAiLCJvcGFxdWVfb2Zfc2V4cCIsImZ1bl9vZl9zZXhwIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFncyIsInNleHBfZ3JhbW1hcl93aXRoX3RhZ19saXN0IiwidW5pdF9zZXhwX2dyYW1tYXIiLCJib29sX3NleHBfZ3JhbW1hciIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJjaGFyX3NleHBfZ3JhbW1hciIsImludF9zZXhwX2dyYW1tYXIiLCJmbG9hdF9zZXhwX2dyYW1tYXIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIiwic2V4cF90X3NleHBfZ3JhbW1hciIsInJlZl9zZXhwX2dyYW1tYXIiLCJsYXp5X3Rfc2V4cF9ncmFtbWFyIiwib3B0aW9uX3NleHBfZ3JhbW1hciIsImxpc3Rfc2V4cF9ncmFtbWFyIiwiYXJyYXlfc2V4cF9ncmFtbWFyIiwib3BhcXVlX3NleHBfZ3JhbW1hciIsImZ1bl9zZXhwX2dyYW1tYXIiLCJnZXRfZmxjX2Vycm9yIiwibmFtZSIsImNociIsImxpbmUiLCJmaWxlIiwiY3N0X01hdGNoX2ZhaWx1cmUiLCJoYW5kbGVyIiwiYXJnIiwiU2V4cGxpYjBfU2V4cF9jb252Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8u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QUNWO0FBQUE7QUFBQSxzQkFBWTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdDQUFBQTtBQUFBQSx3QkFFbkIsNkJBQ2U7QUFBQSx3QkFDUjtBQUFBO0FBQUEsdUJBQVk7QUFBQTtBQUFBO0FBQUEsVUFDdEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUlIO0FBQUE7QUFBQSxjQUFBQTtBQUFBQSxVQUFBZ0ssVUFDSyxVQUFBaEgsd0JBQUE7QUFBQSxNQUNELG9EQUErRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUFoRDtBQUFBQSxRQUU3RTtBQUFBLFNBR087QUFBQSxZQUFBMEQsT0FIUCxVQUFBb0MsTUFBQTtBQUFBLFFBRTRDLHlEQUFlO0FBQUEsT0FDeEM7QUFBQTtBQUFBO0FBQUEsSUFBQW9FO0FBQUFBLE1BQ3RCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQxWkwiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFV0aWxpdHkgTW9kdWxlIGZvciBTLWV4cHJlc3Npb24gQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gTW9yZUxhYmVsc1xub3BlbiBQcmludGZcbm9wZW4gU2V4cFxuXG4oKiBDb252ZXJzaW9uIG9mIE9DYW1sLXZhbHVlcyB0byBTLWV4cHJlc3Npb25zICopXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbigqICclLjE3ZycgaXMgZ3VhcmFudGVlZCB0byBiZSByb3VuZC10cmlwcGFibGUuXG5cbiAgICclLjE1Zycgd2lsbCBiZSByb3VuZC10cmlwcGFibGUgYW5kIG5vdCBoYXZlIG5vaXNlIGF0IHRoZSBsYXN0IGRpZ2l0IG9yIHR3byBmb3IgYSBmbG9hdFxuICAgd2hpY2ggd2FzIGNvbnZlcnRlZCBmcm9tIGEgZGVjaW1hbCAoc3RyaW5nKSB3aXRoIDw9IDE1IHNpZ25pZmljYW50IGRpZ2l0cy4gIFNvIGl0J3NcbiAgIHdvcnRoIHRyeWluZyBmaXJzdCB0byBhdm9pZCB0aGluZ3MgbGlrZSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiLlxuXG4gICBTZWUgY29tbWVudCBhYm92ZSBbdG9fc3RyaW5nX3JvdW5kX3RyaXBwYWJsZV0gaW4geyFDb3JlLkZsb2F0fSBmb3JcbiAgIGRldGFpbGVkIGV4cGxhbmF0aW9uIGFuZCBleGFtcGxlcy4gKilcbmxldCBkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCA9XG4gIHJlZiAoZnVuIHggLT5cbiAgICBsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVHXCIgeCBpblxuICAgIGlmIGZsb2F0X29mX3N0cmluZyB5ID0geCB0aGVuIHkgZWxzZSBmb3JtYXRfZmxvYXQgXCIlLjE3R1wiIHgpXG47O1xuXG5sZXQgcmVhZF9vbGRfb3B0aW9uX2Zvcm1hdCA9IHJlZiB0cnVlXG5sZXQgd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IGxpc3RfbWFwIGYgbCA9IExpc3QucmV2IChMaXN0LnJldl9tYXAgbCB+ZilcbmxldCBzZXhwX29mX3VuaXQgKCkgPSBMaXN0IFtdXG5sZXQgc2V4cF9vZl9ib29sIGIgPSBBdG9tIChzdHJpbmdfb2ZfYm9vbCBiKVxubGV0IHNleHBfb2Zfc3RyaW5nIHN0ciA9IEF0b20gc3RyXG5sZXQgc2V4cF9vZl9ieXRlcyBieXRlcyA9IEF0b20gKEJ5dGVzLnRvX3N0cmluZyBieXRlcylcbmxldCBzZXhwX29mX2NoYXIgYyA9IEF0b20gKFN0cmluZy5tYWtlIDEgYylcbmxldCBzZXhwX29mX2ludCBuID0gQXRvbSAoc3RyaW5nX29mX2ludCBuKVxubGV0IHNleHBfb2ZfZmxvYXQgbiA9IEF0b20gKCFkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCBuKVxubGV0IHNleHBfb2ZfaW50MzIgbiA9IEF0b20gKEludDMyLnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfaW50NjQgbiA9IEF0b20gKEludDY0LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfbmF0aXZlaW50IG4gPSBBdG9tIChOYXRpdmVpbnQudG9fc3RyaW5nIG4pXG5sZXQgc2V4cF9vZl9yZWYgc2V4cF9vZl9fYSByZiA9IHNleHBfb2ZfX2EgIXJmXG5sZXQgc2V4cF9vZl9sYXp5X3Qgc2V4cF9vZl9fYSBsdiA9IHNleHBfb2ZfX2EgKExhenkuZm9yY2UgbHYpXG5cbmxldCBzZXhwX29mX29wdGlvbiBzZXhwX29mX19hID0gZnVuY3Rpb25cbiAgfCBTb21lIHggd2hlbiAhd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgLT4gTGlzdCBbIHNleHBfb2ZfX2EgeCBdXG4gIHwgU29tZSB4IC0+IExpc3QgWyBBdG9tIFwic29tZVwiOyBzZXhwX29mX19hIHggXVxuICB8IE5vbmUgd2hlbiAhd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgLT4gTGlzdCBbXVxuICB8IE5vbmUgLT4gQXRvbSBcIm5vbmVcIlxuOztcblxubGV0IHNleHBfb2ZfcGFpciBzZXhwX29mX19hIHNleHBfb2ZfX2IgKGEsIGIpID0gTGlzdCBbIHNleHBfb2ZfX2EgYTsgc2V4cF9vZl9fYiBiIF1cblxubGV0IHNleHBfb2ZfdHJpcGxlIHNleHBfb2ZfX2Egc2V4cF9vZl9fYiBzZXhwX29mX19jIChhLCBiLCBjKSA9XG4gIExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYjsgc2V4cF9vZl9fYyBjIF1cbjs7XG5cbigqIExpc3QucmV2IChMaXN0LnJldl9tYXAgLi4uKSBpcyB0YWlsIHJlY3Vyc2l2ZSwgdGhlIE9DYW1sIHN0YW5kYXJkXG4gICBsaWJyYXJ5IExpc3QubWFwIGlzIE5PVC4gKilcbmxldCBzZXhwX29mX2xpc3Qgc2V4cF9vZl9fYSBsc3QgPSBMaXN0IChMaXN0LnJldiAoTGlzdC5yZXZfbWFwIGxzdCB+ZjpzZXhwX29mX19hKSlcblxubGV0IHNleHBfb2ZfYXJyYXkgc2V4cF9vZl9fYSBhciA9XG4gIGxldCBsc3RfcmVmID0gcmVmIFtdIGluXG4gIGZvciBpID0gQXJyYXkubGVuZ3RoIGFyIC0gMSBkb3dudG8gMCBkb1xuICAgIGxzdF9yZWYgOj0gc2V4cF9vZl9fYSBhci4oaSkgOjogIWxzdF9yZWZcbiAgZG9uZTtcbiAgTGlzdCAhbHN0X3JlZlxuOztcblxubGV0IHNleHBfb2ZfaGFzaHRibCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbCBodGJsID1cbiAgbGV0IGNvbGwgfmtleTprIH5kYXRhOnYgYWNjID0gTGlzdCBbIHNleHBfb2Zfa2V5IGs7IHNleHBfb2ZfdmFsIHYgXSA6OiBhY2MgaW5cbiAgTGlzdCAoSGFzaHRibC5mb2xkIGh0YmwgfmluaXQ6W10gfmY6Y29sbClcbjs7XG5cbmxldCBzZXhwX29mX29wYXF1ZSBfID0gQXRvbSBcIjxvcGFxdWU+XCJcbmxldCBzZXhwX29mX2Z1biBfID0gQXRvbSBcIjxmdW4+XCJcblxuKCogRXhjZXB0aW9uIGNvbnZlcnRlciByZWdpc3RyYXRpb24gYW5kIGxvb2t1cCAqKVxuXG5tb2R1bGUgRXhuX2NvbnZlcnRlciA9IHN0cnVjdFxuICAoKiBUaGVzZSBleGNlcHRpb24gcmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCBjb250ZXh0LXN3aXRjaGVzXG4gICAgIGNhbm5vdCBoYXBwZW4gdW5sZXNzIHRoZXJlIGlzIGFuIGFsbG9jYXRpb24uICBJdCBpcyByZWFzb25hYmxlIHRvIGV4cGVjdFxuICAgICB0aGF0IHRoaXMgd2lsbCByZW1haW4gdHJ1ZSBmb3IgdGhlIGZvcmVzZWVhYmxlIGZ1dHVyZS4gIFRoYXQgd2F5IHdlXG4gICAgIGF2b2lkIHVzaW5nIG11dGV4ZXMgYW5kIHRodXMgYSBkZXBlbmRlbmN5IG9uIHRoZSB0aHJlYWRzIGxpYnJhcnkuICopXG5cbiAgKCogRmFzdCBhbmQgYXV0b21hdGljIGV4Y2VwdGlvbiByZWdpc3RyYXRpb24gKilcblxuICBtb2R1bGUgUmVnaXN0cmF0aW9uID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgc2V4cF9vZl9leG4gOiBleG4gLT4gU2V4cC50XG4gICAgICA7ICgqIElmIFtwcmludGV4YyA9IHRydWVdIHRoZW4gdGhpcyBzZXhwIGNvbnZlcnRlciBpcyB1c2VkIGZvciBQcmludGV4Yy50b19zdHJpbmcgKilcbiAgICAgICAgcHJpbnRleGMgOiBib29sXG4gICAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBFeG5fdGFibGUgPSBFcGhlbWVyb24uSzEuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBleHRlbnNpb25fY29uc3RydWN0b3JcblxuICAgICAgbGV0IGVxdWFsID0gKCA9PSApXG4gICAgICBsZXQgaGFzaCA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWRcbiAgICBlbmQpXG5cbiAgbGV0IHRoZV9leG5fdGFibGUgOiBSZWdpc3RyYXRpb24udCBFeG5fdGFibGUudCA9IEV4bl90YWJsZS5jcmVhdGUgMTdcblxuICAoKiBFcGhlbWVyb25zIGFyZSB1c2VkIHNvIHRoYXQgW3NleHBfb2ZfZXhuXSBjbG9zdXJlIGRvbid0IGtlZXAgdGhlXG4gICAgIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBsaXZlLiAqKVxuICBsZXQgYWRkID8ocHJpbnRleGMgPSB0cnVlKSA/ZmluYWxpc2U6XyBleHRlbnNpb25fY29uc3RydWN0b3Igc2V4cF9vZl9leG4gPVxuICAgIEV4bl90YWJsZS5hZGQgdGhlX2V4bl90YWJsZSBleHRlbnNpb25fY29uc3RydWN0b3IgeyBzZXhwX29mX2V4bjsgcHJpbnRleGMgfVxuICA7O1xuXG4gIGxldCBmaW5kX2F1dG8gfmZvcl9wcmludGV4YyBleG4gPVxuICAgIGxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCBleG4gaW5cbiAgICBtYXRjaCBFeG5fdGFibGUuZmluZF9vcHQgdGhlX2V4bl90YWJsZSBleHRlbnNpb25fY29uc3RydWN0b3Igd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHsgc2V4cF9vZl9leG47IHByaW50ZXhjIH0gLT5cbiAgICAgIChtYXRjaCBmb3JfcHJpbnRleGMsIHByaW50ZXhjIHdpdGhcbiAgICAgICB8IGZhbHNlLCBfIHwgXywgdHJ1ZSAtPiBTb21lIChzZXhwX29mX2V4biBleG4pXG4gICAgICAgfCB0cnVlLCBmYWxzZSAtPiBOb25lKVxuICA7O1xuXG4gIG1vZHVsZSBGb3JfdW5pdF90ZXN0c19vbmx5ID0gc3RydWN0XG4gICAgbGV0IHNpemUgKCkgPSAoRXhuX3RhYmxlLnN0YXRzX2FsaXZlIHRoZV9leG5fdGFibGUpLm51bV9iaW5kaW5nc1xuICBlbmRcbmVuZFxuXG5sZXQgc2V4cF9vZl9leG5fb3B0X2Zvcl9wcmludGV4YyBleG4gPSBFeG5fY29udmVydGVyLmZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjOnRydWUgZXhuXG5sZXQgc2V4cF9vZl9leG5fb3B0IGV4biA9IEV4bl9jb252ZXJ0ZXIuZmluZF9hdXRvIH5mb3JfcHJpbnRleGM6ZmFsc2UgZXhuXG5cbmxldCBzZXhwX29mX2V4biBleG4gPVxuICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgZXhuIHdpdGhcbiAgfCBOb25lIC0+IExpc3QgWyBBdG9tIChQcmludGV4Yy50b19zdHJpbmcgZXhuKSBdXG4gIHwgU29tZSBzZXhwIC0+IHNleHBcbjs7XG5cbmxldCBleG5fdG9fc3RyaW5nIGUgPSBTZXhwLnRvX3N0cmluZ19odW0gKHNleHBfb2ZfZXhuIGUpXG5cbigqIHtbZXhjZXB0aW9uIEJsYWggW0BAZGVyaXZpbmcgc2V4cF1dfSBnZW5lcmF0ZXMgYSBjYWxsIHRvIHRoZSBmdW5jdGlvblxuICAgW0V4bl9jb252ZXJ0ZXIuYWRkXSBkZWZpbmVkIGluIHRoaXMgZmlsZS4gIFNvIHdlIGFyZSBndWFyYW50ZWQgdGhhdCBhcyBzb29uIGFzIHdlXG4gICBtYXJrIGFuIGV4Y2VwdGlvbiBhcyBzZXhwYWJsZSwgdGhpcyBtb2R1bGUgd2lsbCBiZSBsaW5rZWQgaW4gYW5kIHRoaXMgcHJpbnRlciB3aWxsIGJlXG4gICByZWdpc3RlcmVkLCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuICopXG5sZXQgKCkgPVxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW4gZXhuIC0+XG4gICAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0X2Zvcl9wcmludGV4YyBleG4gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHNleHAgLT4gU29tZSAoU2V4cC50b19zdHJpbmdfaHVtIH5pbmRlbnQ6MiBzZXhwKSlcbjs7XG5cbmxldCBwcmludGV4Y19wcmVmZXJfc2V4cCBleG4gPVxuICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgZXhuIHdpdGhcbiAgfCBOb25lIC0+IFByaW50ZXhjLnRvX3N0cmluZyBleG5cbiAgfCBTb21lIHNleHAgLT4gU2V4cC50b19zdHJpbmdfaHVtIH5pbmRlbnQ6MiBzZXhwXG47O1xuXG4oKiBDb252ZXJzaW9uIG9mIFMtZXhwcmVzc2lvbnMgdG8gT0NhbWwtdmFsdWVzICopXG5cbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yID0gU2V4cC5PZl9zZXhwX2Vycm9yXG5cbmxldCByZWNvcmRfY2hlY2tfZXh0cmFfZmllbGRzID0gcmVmIHRydWVcbmxldCBvZl9zZXhwX2Vycm9yX2V4biBleGMgc2V4cCA9IHJhaXNlIChPZl9zZXhwX2Vycm9yIChleGMsIHNleHApKVxubGV0IG9mX3NleHBfZXJyb3Igd2hhdCBzZXhwID0gcmFpc2UgKE9mX3NleHBfZXJyb3IgKEZhaWx1cmUgd2hhdCwgc2V4cCkpXG5cbmxldCB1bml0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgW10gLT4gKClcbiAgfCBBdG9tIF8gfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcInVuaXRfb2Zfc2V4cDogZW1wdHkgbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYm9vbF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIChcInRydWVcIiB8IFwiVHJ1ZVwiKSAtPiB0cnVlXG4gIHwgQXRvbSAoXCJmYWxzZVwiIHwgXCJGYWxzZVwiKSAtPiBmYWxzZVxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiYm9vbF9vZl9zZXhwOiB1bmtub3duIHN0cmluZ1wiIHNleHBcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImJvb2xfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgc3RyaW5nX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+IHN0clxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwic3RyaW5nX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGJ5dGVzX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+IEJ5dGVzLm9mX3N0cmluZyBzdHJcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImJ5dGVzX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGNoYXJfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICBpZiBTdHJpbmcubGVuZ3RoIHN0ciA8PiAxXG4gICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiY2hhcl9vZl9zZXhwOiBhdG9tIHN0cmluZyBtdXN0IGNvbnRhaW4gb25lIGNoYXJhY3RlciBvbmx5XCIgc2V4cDtcbiAgICBzdHIuWzBdXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJjaGFyX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgaW50X29mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGZsb2F0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBmbG9hdF9vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJmbG9hdF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiZmxvYXRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50MzJfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IEludDMyLm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludDMyX29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnQzMl9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnQ2NF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgSW50NjQub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50NjRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludDY0X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IG5hdGl2ZWludF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgTmF0aXZlaW50Lm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcIm5hdGl2ZWludF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwibmF0aXZlaW50X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHJlZl9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9IHJlZiAoYV9fb2Zfc2V4cCBzZXhwKVxubGV0IGxhenlfdF9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9IExhenkuZnJvbV92YWwgKGFfX29mX3NleHAgc2V4cClcblxubGV0IG9wdGlvbl9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIGlmICFyZWFkX29sZF9vcHRpb25fZm9ybWF0XG4gIHRoZW4gKFxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgTGlzdCBbXSB8IEF0b20gKFwibm9uZVwiIHwgXCJOb25lXCIpIC0+IE5vbmVcbiAgICB8IExpc3QgWyBlbCBdIHwgTGlzdCBbIEF0b20gKFwic29tZVwiIHwgXCJTb21lXCIpOyBlbCBdIC0+IFNvbWUgKGFfX29mX3NleHAgZWwpXG4gICAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBsaXN0IG11c3QgcmVwcmVzZW50IG9wdGlvbmFsIHZhbHVlXCIgc2V4cFxuICAgIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogb25seSBub25lIGNhbiBiZSBhdG9tXCIgc2V4cClcbiAgZWxzZSAoXG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBBdG9tIChcIm5vbmVcIiB8IFwiTm9uZVwiKSAtPiBOb25lXG4gICAgfCBMaXN0IFsgQXRvbSAoXCJzb21lXCIgfCBcIlNvbWVcIik7IGVsIF0gLT4gU29tZSAoYV9fb2Zfc2V4cCBlbClcbiAgICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IG9ubHkgbm9uZSBjYW4gYmUgYXRvbVwiIHNleHBcbiAgICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IGxpc3QgbXVzdCBiZSAoc29tZSBlbClcIiBzZXhwKVxuOztcblxubGV0IHBhaXJfb2Zfc2V4cCBhX19vZl9zZXhwIGJfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgWyBhX3NleHA7IGJfc2V4cCBdIC0+XG4gICAgbGV0IGEgPSBhX19vZl9zZXhwIGFfc2V4cCBpblxuICAgIGxldCBiID0gYl9fb2Zfc2V4cCBiX3NleHAgaW5cbiAgICBhLCBiXG4gIHwgTGlzdCBfIC0+XG4gICAgb2Zfc2V4cF9lcnJvciBcInBhaXJfb2Zfc2V4cDogbGlzdCBtdXN0IGNvbnRhaW4gZXhhY3RseSB0d28gZWxlbWVudHMgb25seVwiIHNleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcInBhaXJfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgdHJpcGxlX29mX3NleHAgYV9fb2Zfc2V4cCBiX19vZl9zZXhwIGNfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgWyBhX3NleHA7IGJfc2V4cDsgY19zZXhwIF0gLT5cbiAgICBsZXQgYSA9IGFfX29mX3NleHAgYV9zZXhwIGluXG4gICAgbGV0IGIgPSBiX19vZl9zZXhwIGJfc2V4cCBpblxuICAgIGxldCBjID0gY19fb2Zfc2V4cCBjX3NleHAgaW5cbiAgICBhLCBiLCBjXG4gIHwgTGlzdCBfIC0+XG4gICAgb2Zfc2V4cF9lcnJvciBcInRyaXBsZV9vZl9zZXhwOiBsaXN0IG11c3QgY29udGFpbiBleGFjdGx5IHRocmVlIGVsZW1lbnRzIG9ubHlcIiBzZXhwXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJ0cmlwbGVfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgbGlzdF9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgbHN0IC0+XG4gICAgbGV0IHJldl9sc3QgPSBMaXN0LnJldl9tYXAgbHN0IH5mOmFfX29mX3NleHAgaW5cbiAgICBMaXN0LnJldiByZXZfbHN0XG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJsaXN0X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGFycmF5X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbXSAtPiBbfHxdXG4gIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCB0ICsgMSBpblxuICAgIGxldCByZXMgPSBBcnJheS5tYWtlIGxlbiAoYV9fb2Zfc2V4cCBoKSBpblxuICAgIGxldCByZWMgbG9vcCBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmVzXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICByZXMuKGkpIDwtIGFfX29mX3NleHAgaDtcbiAgICAgICAgbG9vcCAoaSArIDEpIHRcbiAgICBpblxuICAgIGxvb3AgMSB0XG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJhcnJheV9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBoYXNodGJsX29mX3NleHAga2V5X29mX3NleHAgdmFsX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgbHN0IC0+XG4gICAgbGV0IGh0YmwgPSBIYXNodGJsLmNyZWF0ZSAwIGluXG4gICAgbGV0IGFjdCA9IGZ1bmN0aW9uXG4gICAgICB8IExpc3QgWyBrX3NleHA7IHZfc2V4cCBdIC0+XG4gICAgICAgIEhhc2h0YmwuYWRkIGh0YmwgfmtleTooa2V5X29mX3NleHAga19zZXhwKSB+ZGF0YToodmFsX29mX3NleHAgdl9zZXhwKVxuICAgICAgfCBMaXN0IF8gfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImhhc2h0Ymxfb2Zfc2V4cDogdHVwbGUgbGlzdCBuZWVkZWRcIiBzZXhwXG4gICAgaW5cbiAgICBMaXN0Lml0ZXIgbHN0IH5mOmFjdDtcbiAgICBodGJsXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJoYXNodGJsX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IG9wYXF1ZV9vZl9zZXhwIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIFwib3BhcXVlX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IG9wYXF1ZSB2YWx1ZXNcIiBzZXhwXG47O1xuXG5sZXQgZnVuX29mX3NleHAgc2V4cCA9IG9mX3NleHBfZXJyb3IgXCJmdW5fb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgZnVuY3Rpb24gdmFsdWVzXCIgc2V4cFxuXG4oKiBTZXhwIEdyYW1tYXJzICopXG5cbmluY2x1ZGUgU2V4cF9jb252X2dyYW1tYXJcblxuKCogUmVnaXN0ZXJpbmcgZGVmYXVsdCBleGNlcHRpb24gcHJpbnRlcnMgKilcblxubGV0IGdldF9mbGNfZXJyb3IgbmFtZSAoZmlsZSwgbGluZSwgY2hyKSA9IEF0b20gKHNwcmludGYgXCIlcyAlczolZDolZFwiIG5hbWUgZmlsZSBsaW5lIGNocilcblxubGV0ICgpID1cbiAgTGlzdC5pdGVyXG4gICAgfmY6KGZ1biAoZXh0ZW5zaW9uX2NvbnN0cnVjdG9yLCBoYW5kbGVyKSAtPlxuICAgICAgRXhuX2NvbnZlcnRlci5hZGQgfnByaW50ZXhjOmZhbHNlIH5maW5hbGlzZTpmYWxzZSBleHRlbnNpb25fY29uc3RydWN0b3IgaGFuZGxlcilcbiAgICBbICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXNzZXJ0X2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXNzZXJ0X2ZhaWx1cmUgYXJnIC0+IGdldF9mbGNfZXJyb3IgXCJBc3NlcnRfZmFpbHVyZVwiIGFyZ1xuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRXhpdF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBFeGl0IC0+IEF0b20gXCJFeGl0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEVuZF9vZl9maWxlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEVuZF9vZl9maWxlIC0+IEF0b20gXCJFbmRfb2ZfZmlsZVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBGYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEZhaWx1cmUgYXJnIC0+IExpc3QgWyBBdG9tIFwiRmFpbHVyZVwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBOb3RfZm91bmRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTm90X2ZvdW5kIC0+IEF0b20gXCJOb3RfZm91bmRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgSW52YWxpZF9hcmd1bWVudF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBJbnZhbGlkX2FyZ3VtZW50IGFyZyAtPiBMaXN0IFsgQXRvbSBcIkludmFsaWRfYXJndW1lbnRcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWF0Y2hfZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBNYXRjaF9mYWlsdXJlIGFyZyAtPiBnZXRfZmxjX2Vycm9yIFwiTWF0Y2hfZmFpbHVyZVwiIGFyZ1xuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTm90X2ZvdW5kX3NdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTm90X2ZvdW5kX3MgYXJnIC0+IExpc3QgWyBBdG9tIFwiTm90X2ZvdW5kX3NcIjsgYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN5c19lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTeXNfZXJyb3IgYXJnIC0+IExpc3QgWyBBdG9tIFwiU3lzX2Vycm9yXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFyZy5IZWxwXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFyZy5IZWxwIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkFyZy5IZWxwXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFyZy5CYWRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXJnLkJhZCBhcmcgLT4gTGlzdCBbIEF0b20gXCJBcmcuQmFkXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIExhenkuVW5kZWZpbmVkXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IExhenkuVW5kZWZpbmVkIC0+IEF0b20gXCJMYXp5LlVuZGVmaW5lZFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBQYXJzaW5nLlBhcnNlX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFBhcnNpbmcuUGFyc2VfZXJyb3IgLT4gQXRvbSBcIlBhcnNpbmcuUGFyc2VfZXJyb3JcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgUXVldWUuRW1wdHldXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgUXVldWUuRW1wdHkgLT4gQXRvbSBcIlF1ZXVlLkVtcHR5XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNjYW5mLlNjYW5fZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTY2FuZi5TY2FuX2ZhaWx1cmUgYXJnIC0+IExpc3QgWyBBdG9tIFwiU2NhbmYuU2Nhbl9mYWlsdXJlXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN0YWNrLkVtcHR5XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN0YWNrLkVtcHR5IC0+IEF0b20gXCJTdGFjay5FbXB0eVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTeXMuQnJlYWtdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3lzLkJyZWFrIC0+IEF0b20gXCJTeXMuQnJlYWtcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICBdXG47O1xuXG5sZXQgKCkgPVxuICBMaXN0Lml0ZXJcbiAgICB+ZjooZnVuIChleHRlbnNpb25fY29uc3RydWN0b3IsIGhhbmRsZXIpIC0+XG4gICAgICBFeG5fY29udmVydGVyLmFkZCB+cHJpbnRleGM6dHJ1ZSB+ZmluYWxpc2U6ZmFsc2UgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGhhbmRsZXIpXG4gICAgWyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE9mX3NleHBfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgT2Zfc2V4cF9lcnJvciAoZXhjLCBzZXhwKSAtPlxuICAgICAgICAgIExpc3QgWyBBdG9tIFwiU2V4cGxpYi5Db252Lk9mX3NleHBfZXJyb3JcIjsgc2V4cF9vZl9leG4gZXhjOyBzZXhwIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgXVxuOztcblxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNDk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InNleHBsaWIwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfaGFzX2luY29ycmVjdF9udW1iZXJfb2ZfYXIiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfTGlzdExhYmVscyIsIlN0ZGxpYl9TdHJpbmdMYWJlbHMiLCJTdGRsaWIiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJTdGRsaWJfUHJpbnRmIiwiT2Zfc2V4cF9lcnJvciIsImNzdF9vZl9zZXhwX3RoaXNfY29uc3RydWN0b3JfZCIsImNzdF9vZl9zZXhwX3RoaXNfY29uc3RydWN0b3JfciIsImNzdF9vZl9zZXhwX2V4cGVjdGVkX2FfdmFyaWFudCIsImNzdF9vZl9zZXhwX3VuZXhwZWN0ZWRfdmFyaWFudCIsImNzdF9vZl9zZXhwX3JlY29yZF9jb252ZXJzaW9uXyIsImNzdF9kdXBsaWNhdGVfZmllbGRzIiwiY3N0X2V4dHJhX2ZpZWxkcyIsImNzdF9vZl9zZXhwX2xpc3RfaW5zdGVhZF9vZl9hdCIsImNzdF9vZl9zZXhwX2Nhbm5vdF9jb252ZXJ0X3ZhbCIsInR1cGxlX29mX3NpemVfbl9leHBlY3RlZCIsImxvYyIsIm4iLCJzZXhwIiwic3RhZ19ub19hcmdzIiwic3RhZ19pbmNvcnJlY3Rfbl9hcmdzIiwidGFnIiwibXNnIiwic3RhZ190YWtlc19hcmdzIiwibmVzdGVkX2xpc3RfaW52YWxpZF9zdW0iLCJlbXB0eV9saXN0X2ludmFsaWRfc3VtIiwidW5leHBlY3RlZF9zdGFnIiwicmVjb3JkX3NleHBfYm9vbF93aXRoX3BheWxvYWQiLCJyZWNvcmRfb25seV9wYWlyc19leHBlY3RlZCIsInJlY29yZF9zdXBlcmZsdW91c19maWVsZHMiLCJ3aGF0IiwicmV2X2ZsZF9uYW1lcyIsImZsZF9uYW1lc19zdHIiLCJyZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyIsInJlY29yZF9leHRyYV9maWVsZHMiLCJyZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIiwiZmllbGRzIiwicGFyYW0iLCJyZXN0IiwiZmllbGQiLCJyZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIiwibHN0IiwidW5kZWZpbmVkIiwicmVjb3JkX2xpc3RfaW5zdGVhZF9hdG9tIiwicmVjb3JkX3BvbHlfZmllbGRfdmFsdWUiLCJOb192YXJpYW50X21hdGNoIiwiY3N0X29mX3NleHBfbm9fbWF0Y2hpbmdfdmFyaWFuIiwiY3N0X29mX3NleHBfcG9seW1vcnBoaWNfdmFyaWFuIiwiY3N0X29mX3NleHBfYV9uZXN0ZWRfbGlzdF9pc19hIiwiY3N0X29mX3NleHBfdGhlX2VtcHR5X2xpc3RfaXNfIiwiY3N0X29mX3NleHBfdHJ5aW5nX3RvX2NvbnZlcnRfIiwibm9fdmFyaWFudF9tYXRjaCIsIm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmQiLCJwdGFnX25vX2FyZ3MiLCJwdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJjbnN0ciIsInB0YWdfdGFrZXNfYXJncyIsIm5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV90eXBlIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3NleHBsaWIwL3NleHBfY29udl9lcnJvci5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBWixRQUFBO0FBQUEsSUFBQUEsTUFBQTtBQUFBLElBQUFhLG9CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEs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QSxHQUFzQjtBQUFBLFlBQUFlLDBCQUFBcEMsS0FBQUU7QUFBQUEsUUFBQSxNQUdoQztBQUFBLElBQTZDLG9EQUFLO0FBQUE7QUFBQSxZQUFBbUMsYUFBQXJDLEtBQUFFO0FBQUFBLFFBQUEsTUFJbEQ7QUFBQSxJQUErRCxvREFBSztBQUFBO0FBQUEsWUFBQW9DLHNCQUFBdEMsS0FBQXVDLE9BQUFyQztBQUFBQSxRQUFBSSxNQUtoRjtBQUFBLElBS0Ysb0RBQXNCO0FBQUE7QUFBQSxZQUFBa0MsZ0JBQUF4QyxLQUFBRTtBQUFBQSxRQUFBLE1BSVI7QUFBQSxJQUE2RCxvREFBSztBQUFBO0FBQUEsWUFBQXVDLDZCQUFBekMsS0FBQUU7QUFBQUEsUUFBQSxNQUlsRTtBQUFBLElBQW1FLG9EQUFLO0FBQUE7QUFBQSxZQUFBd0MsNEJBQUExQyxLQUFBRTtBQUFBQSxRQUFBLE1BSXhFO0FBQUEsSUFBb0Usb0RBQUs7QUFBQTtBQUFBLFlBQUF5QyxXQUFBM0MsS0FBQUU7QUFBQUEsUUFBQSxNQUl6RTtBQUFBLElBQW1ELG9EQUFLO0FBQUE7QUFBQTtBQUFBLElBQUEwQztBQUFBQSxNRDFJeEUiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIENvbnZfZXJyb3I6IE1vZHVsZSBmb3IgSGFuZGxpbmcgRXJyb3JzIGR1cmluZyBBdXRvbWF0ZWQgUy1leHByZXNzaW9uXG4gICBDb252ZXJzaW9ucyAqKVxuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBQcmludGZcbm9wZW4gU2V4cF9jb252XG5cbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yID0gT2Zfc2V4cF9lcnJvclxuXG4oKiBFcnJvcnMgY29uY2VybmluZyB0dXBsZXMgKilcblxubGV0IHR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBsb2MgbiBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAoc3ByaW50ZiBcIiVzX29mX3NleHA6IHR1cGxlIG9mIHNpemUgJWQgZXhwZWN0ZWRcIiBsb2Mgbikgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgc3VtIHR5cGVzICopXG5cbmxldCBzdGFnX25vX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGlzIGNvbnN0cnVjdG9yIGRvZXMgbm90IHRha2UgYXJndW1lbnRzXCIpIHNleHBcbjs7XG5cbmxldCBzdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIHRhZyBzZXhwID1cbiAgbGV0IG1zZyA9IHNwcmludGYgXCIlc19vZl9zZXhwOiBzdW0gdGFnICVTIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1wiIGxvYyB0YWcgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHN0YWdfdGFrZXNfYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRoaXMgY29uc3RydWN0b3IgcmVxdWlyZXMgYXJndW1lbnRzXCIpIHNleHBcbjs7XG5cbmxldCBuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IGV4cGVjdGVkIGEgdmFyaWFudCB0eXBlLCBzYXcgYSBuZXN0ZWQgbGlzdFwiKSBzZXhwXG47O1xuXG5sZXQgZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IGV4cGVjdGVkIGEgdmFyaWFudCB0eXBlLCBzYXcgYW4gZW1wdHkgbGlzdFwiKSBzZXhwXG47O1xuXG5sZXQgdW5leHBlY3RlZF9zdGFnIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdW5leHBlY3RlZCB2YXJpYW50IGNvbnN0cnVjdG9yXCIpIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHJlY29yZHMgKilcblxubGV0IHJlY29yZF9zZXhwX2Jvb2xfd2l0aF9wYXlsb2FkIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgbG9jIF4gXCJfb2Zfc2V4cDogcmVjb3JkIGNvbnZlcnNpb246IGEgW3NleHAuYm9vbF0gZmllbGQgd2FzIGdpdmVuIGEgcGF5bG9hZC5cIlxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQgbG9jIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBsb2NcbiAgICBeIFwiX29mX3NleHA6IHJlY29yZCBjb252ZXJzaW9uOiBvbmx5IHBhaXJzIGV4cGVjdGVkLCB0aGVpciBmaXJzdCBlbGVtZW50IG11c3QgYmUgYW4gXFxcbiAgICAgICBhdG9tXCJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9zdXBlcmZsdW91c19maWVsZHMgfndoYXQgfmxvYyByZXZfZmxkX25hbWVzIHNleHAgPVxuICBsZXQgZmxkX25hbWVzX3N0ciA9IFN0cmluZy5jb25jYXQgKExpc3QucmV2IHJldl9mbGRfbmFtZXMpIH5zZXA6XCIgXCIgaW5cbiAgbGV0IG1zZyA9IHNwcmludGYgXCIlc19vZl9zZXhwOiAlczogJXNcIiBsb2Mgd2hhdCBmbGRfbmFtZXNfc3RyIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyBsb2MgcmV2X2ZsZF9uYW1lcyBzZXhwID1cbiAgcmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyB+d2hhdDpcImR1cGxpY2F0ZSBmaWVsZHNcIiB+bG9jIHJldl9mbGRfbmFtZXMgc2V4cFxuOztcblxubGV0IHJlY29yZF9leHRyYV9maWVsZHMgbG9jIHJldl9mbGRfbmFtZXMgc2V4cCA9XG4gIHJlY29yZF9zdXBlcmZsdW91c19maWVsZHMgfndoYXQ6XCJleHRyYSBmaWVsZHNcIiB+bG9jIHJldl9mbGRfbmFtZXMgc2V4cFxuOztcblxubGV0IHJlYyByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIGZpZWxkcyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gU3RyaW5nLmNvbmNhdCAoTGlzdC5yZXYgZmllbGRzKSB+c2VwOlwiIFwiXG4gIHwgKHRydWUsIGZpZWxkKSA6OiByZXN0IC0+IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgKGZpZWxkIDo6IGZpZWxkcykgcmVzdFxuICB8IF8gOjogcmVzdCAtPiByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIGZpZWxkcyByZXN0XG47O1xuXG5sZXQgcmVjb3JkX3VuZGVmaW5lZF9lbGVtZW50cyBsb2Mgc2V4cCBsc3QgPVxuICBsZXQgdW5kZWZpbmVkID0gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBbXSBsc3QgaW5cbiAgbGV0IG1zZyA9XG4gICAgc3ByaW50ZiBcIiVzX29mX3NleHA6IHRoZSBmb2xsb3dpbmcgcmVjb3JkIGVsZW1lbnRzIHdlcmUgdW5kZWZpbmVkOiAlc1wiIGxvYyB1bmRlZmluZWRcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9saXN0X2luc3RlYWRfYXRvbSBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPSBsb2MgXiBcIl9vZl9zZXhwOiBsaXN0IGluc3RlYWQgb2YgYXRvbSBmb3IgcmVjb3JkIGV4cGVjdGVkXCIgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9wb2x5X2ZpZWxkX3ZhbHVlIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgbG9jXG4gICAgXiBcIl9vZl9zZXhwOiBjYW5ub3QgY29udmVydCB2YWx1ZXMgb2YgdHlwZXMgcmVzdWx0aW5nIGZyb20gcG9seW1vcnBoaWMgcmVjb3JkIGZpZWxkc1wiXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHBvbHltb3JwaGljIHZhcmlhbnRzICopXG5cbmV4Y2VwdGlvbiBOb192YXJpYW50X21hdGNoXG5cbmxldCBub192YXJpYW50X21hdGNoICgpID0gcmFpc2UgTm9fdmFyaWFudF9tYXRjaFxuXG5sZXQgbm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZCBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IG5vIG1hdGNoaW5nIHZhcmlhbnQgZm91bmRcIikgc2V4cFxuOztcblxubGV0IHB0YWdfbm9fYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHBvbHltb3JwaGljIHZhcmlhbnQgZG9lcyBub3QgdGFrZSBhcmd1bWVudHNcIikgc2V4cFxuOztcblxubGV0IHB0YWdfaW5jb3JyZWN0X25fYXJncyBsb2MgY25zdHIgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIHNwcmludGZcbiAgICAgIFwiJXNfb2Zfc2V4cDogcG9seW1vcnBoaWMgdmFyaWFudCB0YWcgJVMgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXCJcbiAgICAgIGxvY1xuICAgICAgY25zdHJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHB0YWdfdGFrZXNfYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHBvbHltb3JwaGljIHZhcmlhbnQgdGFnIHRha2VzIGFuIGFyZ3VtZW50XCIpIHNleHBcbjs7XG5cbmxldCBuZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogYSBuZXN0ZWQgbGlzdCBpcyBhbiBpbnZhbGlkIHBvbHltb3JwaGljIHZhcmlhbnRcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhciBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRoZSBlbXB0eSBsaXN0IGlzIGFuIGludmFsaWQgcG9seW1vcnBoaWMgdmFyaWFudFwiKSBzZXhwXG47O1xuXG5sZXQgZW1wdHlfdHlwZSBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRyeWluZyB0byBjb252ZXJ0IGFuIGVtcHR5IHR5cGVcIikgc2V4cFxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InNleHBsaWIwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiYWJzZW50IiwiU2V4cGxpYjBfU2V4cF9jb252IiwiU3RkbGliX1N0cmluZ0xhYmVscyIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiU3RkbGliX09wdGlvbiIsIlN0ZGxpYiIsIktpbmQiLCJjb21iaW5lIiwiYSIsImIiLCJ0IiwiTWFsZm9ybWVkIiwiZHVtbXkiLCJwYXJzZV92YWx1ZV9tYWxmb3JtZWQiLCJtYWxmb3JtZWQiLCJmaWVsZHMiLCJzdGF0ZSIsInBvcyIsImV4biIsIm90aGVyIiwicGFyc2VfdmFsdWVzIiwicmVzdCIsImNvbnYiLCJraW5kIiwibmFtZSIsInNleHAiLCJkZWZhdWx0IiwidmFsdWUiLCJwYXJzZV9zcGluZV9tYWxmb3JtZWQiLCJpbmRleCIsImV4dHJhIiwic2VlbiIsImxlbiIsInNleHBzIiwicGFyc2Vfc3BpbmVfc2xvdyIsImZpZWxkIiwibWF0Y2giLCJpIiwicGFyc2VfcmVjb3JkX3Nsb3ciLCJ1bnNlZW4iLCJhY2MiLCJwYXJzZV9zcGluZV9mYXN0Iiwib3RoZXJzIiwiYXJncyIsImF0b20iLCJyZWNvcmRfb2Zfc2V4cHMiLCJjYWxsZXIiLCJjb250ZXh0IiwiaW5kZXhfb2ZfZmllbGQiLCJhbGxvd19leHRyYV9maWVsZHMiLCJjcmVhdGUiLCJuYW1lcyIsIm1heWJlX2NvbnRleHQiLCJyZWNvcmRfb2Zfc2V4cCIsIlNleHBsaWIwX1NleHBfY29udl9yZWNvcmQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvc2V4cGxpYjAvc2V4cF9jb252X3JlY29yZC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLFlBQUFDLFFBQUFDLEdBQUFDO0FBQUFBO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFDaURJO0FBQUE7QUFBQSxlQUFBRCxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFBQUMsTUFBQSxNQUsrQiw0Q0FBTztBQUFBO0FBQUE7QUFBQSwyQkFBQUMsTUFMdEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUFBRixNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFBQUMsTUFBQSxNQU15Qiw0Q0FBTztBQUFBLDJCQUFBQyxJQU5oQztBQUFBO0FBQUE7QUFBQTtBQUFBLGVBQUFGLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1C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MU4zRTtBQUFBO0FBQUEsV0FLRTtBQUFBO0FBQUEsc0JBQUEzQixNQUErQixvQkFBVTtBQUFBO0FBQUEsUUFDdEMsT0FBd0M7QUFBQSxpQkFBeEM7QUFBQSxxQkFvTnNFO0FBQUE7QUFBQTtBQUFBLFNBQUE0QixnQkExTjNFO0FBQUEsU0FBQUwsVUFRZ0I7QUFBQSxRQUNkLGdFQWlOeUU7QUFBQTtBQUFBO0FBQUEsSUFEbEUsZ0NBQ2tFO0FBQUE7QUFBQSxZQUFBTTtBQUFBQSxJQUFBUCxRQUFBL0IsUUFBQWlDLGdCQUFBQyxvQkFBQUMsUUFBQXpCO0FBQUFBLElBSTdFO0FBQUEsS0FDdUIsNkRBU2Q7QUFBQSxRQUFBUSxRQVZUO0FBQUEsSUFHRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQU9PO0FBQUE7QUFBQTtBQUFBLElBQUFxQjtBQUFBQSxNQXRRUDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEakNKIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBTdGRMYWJlbHNcbm9wZW4hIFNleHBfY29udlxub3BlbiEgU2V4cF9jb252X2Vycm9yXG5cbm1vZHVsZSBLaW5kID0gc3RydWN0XG4gIHR5cGUgKF8sIF8pIHQgPVxuICAgIHwgRGVmYXVsdCA6ICh1bml0IC0+ICdhKSAtPiAoJ2EsIFNleHAudCAtPiAnYSkgdFxuICAgIHwgT21pdF9uaWwgOiAoJ2EsIFNleHAudCAtPiAnYSkgdFxuICAgIHwgUmVxdWlyZWQgOiAoJ2EsIFNleHAudCAtPiAnYSkgdFxuICAgIHwgU2V4cF9hcnJheSA6ICgnYSBhcnJheSwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBTZXhwX2Jvb2wgOiAoYm9vbCwgdW5pdCkgdFxuICAgIHwgU2V4cF9saXN0IDogKCdhIGxpc3QsIFNleHAudCAtPiAnYSkgdFxuICAgIHwgU2V4cF9vcHRpb24gOiAoJ2Egb3B0aW9uLCBTZXhwLnQgLT4gJ2EpIHRcbmVuZFxuXG5tb2R1bGUgRmllbGRzID0gc3RydWN0XG4gIHR5cGUgXyB0ID1cbiAgICB8IEVtcHR5IDogdW5pdCB0XG4gICAgfCBGaWVsZCA6XG4gICAgICAgIHsgbmFtZSA6IHN0cmluZ1xuICAgICAgICA7IGtpbmQgOiAoJ2EsICdjb252KSBLaW5kLnRcbiAgICAgICAgOyBjb252IDogJ2NvbnZcbiAgICAgICAgOyByZXN0IDogJ2IgdFxuICAgICAgICB9XG4gICAgICAgIC0+ICgnYSAqICdiKSB0XG5cbiAgbGV0IGxlbmd0aCA9XG4gICAgbGV0IHJlYyBsZW5ndGhfbG9vcCA6IHR5cGUgYS4gYSB0IC0+IGludCAtPiBpbnQgPVxuICAgICAgZnVuIHQgYWNjIC0+XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEZpZWxkIHsgcmVzdDsgXyB9IC0+IGxlbmd0aF9sb29wIHJlc3QgKGFjYyArIDEpXG4gICAgICAgIHwgRW1wdHkgLT4gYWNjXG4gICAgaW5cbiAgICBmdW4gdCAtPiBsZW5ndGhfbG9vcCB0IDBcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFsZm9ybWVkID0gc3RydWN0XG4gICgqIFJlcHJlc2VudHMgZXJyb3JzIHRoYXQgY2FuIG9jY3VyIGR1ZSB0byBtYWxmb3JtZWQgcmVjb3JkIHNleHBzLiBBY2N1bXVsYXRlZCBhcyBhXG4gICAgIHZhbHVlIHNvIHdlIGNhbiByZXBvcnQgbXVsdGlwbGUgbmFtZXMgYXQgb25jZSBmb3IgZXh0cmEgZmllbGRzLCBkdXBsaWNhdGUgZmllbGRzLCBvclxuICAgICBtaXNzaW5nIGZpZWxkcy4gKilcbiAgdHlwZSB0ID1cbiAgICB8IEJvb2xfcGF5bG9hZFxuICAgIHwgRXh0cmFzIG9mIHN0cmluZyBsaXN0XG4gICAgfCBEdXBzIG9mIHN0cmluZyBsaXN0XG4gICAgfCBNaXNzaW5nIG9mIHN0cmluZyBsaXN0XG4gICAgfCBOb25fcGFpciBvZiBTZXhwLnQgb3B0aW9uXG5cbiAgbGV0IGNvbWJpbmUgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICAoKiBjaG9vc2UgdGhlIGZpcnN0IGJvb2wtcGF5bG9hZCBvciBub24tcGFpciBlcnJvciB0aGF0IG9jY3VycyAqKVxuICAgIHwgKChCb29sX3BheWxvYWQgfCBOb25fcGFpciBfKSBhcyB0KSwgXyAtPiB0XG4gICAgfCBfLCAoKEJvb2xfcGF5bG9hZCB8IE5vbl9wYWlyIF8pIGFzIHQpIC0+IHRcbiAgICAoKiBjb21iaW5lIGxpc3RzIG9mIHNpbWlsYXIgZXJyb3JzICopXG4gICAgfCBFeHRyYXMgYSwgRXh0cmFzIGIgLT4gRXh0cmFzIChhIEAgYilcbiAgICB8IER1cHMgYSwgRHVwcyBiIC0+IER1cHMgKGEgQCBiKVxuICAgIHwgTWlzc2luZyBhLCBNaXNzaW5nIGIgLT4gTWlzc2luZyAoYSBAIGIpXG4gICAgKCogb3RoZXJ3aXNlLCBkdXBzID4gZXh0cmFzID4gbWlzc2luZyAqKVxuICAgIHwgKER1cHMgXyBhcyB0KSwgXyB8IF8sIChEdXBzIF8gYXMgdCkgLT4gdFxuICAgIHwgKEV4dHJhcyBfIGFzIHQpLCBfIHwgXywgKEV4dHJhcyBfIGFzIHQpIC0+IHRcbiAgOztcblxuICBsZXQgcmFpc2UgdCB+Y2FsbGVyIH5jb250ZXh0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEJvb2xfcGF5bG9hZCAtPiByZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCBjYWxsZXIgY29udGV4dFxuICAgIHwgRXh0cmFzIG5hbWVzIC0+IHJlY29yZF9leHRyYV9maWVsZHMgY2FsbGVyIChMaXN0LnJldiBuYW1lcykgY29udGV4dFxuICAgIHwgRHVwcyBuYW1lcyAtPiByZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyBjYWxsZXIgKExpc3QucmV2IG5hbWVzKSBjb250ZXh0XG4gICAgfCBNaXNzaW5nIG5hbWVzIC0+XG4gICAgICBMaXN0Lm1hcCBuYW1lcyB+ZjooZnVuIG5hbWUgLT4gdHJ1ZSwgbmFtZSlcbiAgICAgIHw+IHJlY29yZF91bmRlZmluZWRfZWxlbWVudHMgY2FsbGVyIGNvbnRleHRcbiAgICB8IE5vbl9wYWlyIG1heWJlX2NvbnRleHQgLT5cbiAgICAgIGxldCBjb250ZXh0ID0gT3B0aW9uLnZhbHVlIG1heWJlX2NvbnRleHQgfmRlZmF1bHQ6Y29udGV4dCBpblxuICAgICAgcmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQgY2FsbGVyIGNvbnRleHRcbiAgOztcbmVuZFxuXG5leGNlcHRpb24gTWFsZm9ybWVkIG9mIE1hbGZvcm1lZC50XG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAoKiBTdG9yZXMgc2V4cHMgY29ycmVzcG9uZGluZyB0byByZWNvcmQgZmllbGRzLCBpbiB0aGUgb3JkZXIgdGhlIGZpZWxkcyB3ZXJlIGRlY2xhcmVkLlxuICAgICBFeGNsdWRlcyBmaWVsZHMgYWxyZWFkeSBwYXJzZWQgaW4gdGhlIGZhc3QgcGF0aC5cblxuICAgICBMaXN0IHNleHBzIHJlcHJlc2VudCBhIGZpZWxkIHRoYXQgaXMgcHJlc2VudCwgc3VjaCBhcyAoeCAxKSBmb3IgYSBmaWVsZCBuYW1lZCBcInhcIi5cbiAgICAgQXRvbSBzZXhwcyByZXByZXNlbnQgYSBmaWVsZCB0aGF0IGlzIGFic2VudCwgb3IgYXQgbGVhc3Qgbm90IHlldCBzZWVuLiAqKVxuICB0eXBlIHQgPSB7IHN0YXRlIDogU2V4cC50IGFycmF5IH0gW0BAdW5ib3hlZF1cblxuICBsZXQgdW5zYWZlX2dldCB0IHBvcyA9IEFycmF5LnVuc2FmZV9nZXQgdC5zdGF0ZSBwb3NcbiAgbGV0IHVuc2FmZV9zZXQgdCBwb3Mgc2V4cCA9IEFycmF5LnVuc2FmZV9zZXQgdC5zdGF0ZSBwb3Mgc2V4cFxuICBsZXQgYWJzZW50ID0gU2V4cC5BdG9tIFwiXCJcbiAgbGV0IGNyZWF0ZSBsZW4gPSB7IHN0YXRlID0gQXJyYXkubWFrZSBsZW4gYWJzZW50IH1cbmVuZFxuXG4oKiBQYXJzaW5nIGZpZWxkIHZhbHVlcyBmcm9tIHN0YXRlLiAqKVxuXG5sZXQgcmVjIHBhcnNlX3ZhbHVlX21hbGZvcm1lZFxuICA6IHR5cGUgYSBiLiBNYWxmb3JtZWQudCAtPiBmaWVsZHM6KGEgKiBiKSBGaWVsZHMudCAtPiBzdGF0ZTpTdGF0ZS50IC0+IHBvczppbnQgLT4gYVxuICA9XG4gIGZ1biBtYWxmb3JtZWQgfmZpZWxkcyB+c3RhdGUgfnBvcyAtPlxuICBsZXQgKEZpZWxkIGZpZWxkKSA9IGZpZWxkcyBpblxuICBsZXQgbWFsZm9ybWVkID1cbiAgICBtYXRjaCBwYXJzZV92YWx1ZXMgfmZpZWxkczpmaWVsZC5yZXN0IH5zdGF0ZSB+cG9zOihwb3MgKyAxKSB3aXRoXG4gICAgfCAoXyA6IGIpIC0+IG1hbGZvcm1lZFxuICAgIHwgZXhjZXB0aW9uIE1hbGZvcm1lZCBvdGhlciAtPiBNYWxmb3JtZWQuY29tYmluZSBtYWxmb3JtZWQgb3RoZXJcbiAgaW5cbiAgcmFpc2UgKE1hbGZvcm1lZCBtYWxmb3JtZWQpXG5cbmFuZCBwYXJzZV92YWx1ZSA6IHR5cGUgYSBiLiBmaWVsZHM6KGEgKiBiKSBGaWVsZHMudCAtPiBzdGF0ZTpTdGF0ZS50IC0+IHBvczppbnQgLT4gYSAqIGIgPVxuICBmdW4gfmZpZWxkcyB+c3RhdGUgfnBvcyAtPlxuICBsZXQgKEZpZWxkIHsgbmFtZTsga2luZDsgY29udjsgcmVzdCB9KSA9IGZpZWxkcyBpblxuICBsZXQgdmFsdWUgOiBhID1cbiAgICBtYXRjaCBraW5kLCBTdGF0ZS51bnNhZmVfZ2V0IHN0YXRlIHBvcyB3aXRoXG4gICAgKCogd2VsbC1mb3JtZWQgKilcbiAgICB8IFJlcXVpcmVkLCBMaXN0IFsgXzsgc2V4cCBdIC0+IGNvbnYgc2V4cFxuICAgIHwgRGVmYXVsdCBfLCBMaXN0IFsgXzsgc2V4cCBdIC0+IGNvbnYgc2V4cFxuICAgIHwgT21pdF9uaWwsIExpc3QgWyBfOyBzZXhwIF0gLT4gY29udiBzZXhwXG4gICAgfCBTZXhwX29wdGlvbiwgTGlzdCBbIF87IHNleHAgXSAtPiBTb21lIChjb252IHNleHApXG4gICAgfCBTZXhwX2xpc3QsIExpc3QgWyBfOyBzZXhwIF0gLT4gbGlzdF9vZl9zZXhwIGNvbnYgc2V4cFxuICAgIHwgU2V4cF9hcnJheSwgTGlzdCBbIF87IHNleHAgXSAtPiBhcnJheV9vZl9zZXhwIGNvbnYgc2V4cFxuICAgIHwgU2V4cF9ib29sLCBMaXN0IFsgXyBdIC0+IHRydWVcbiAgICAoKiBpbGwtZm9ybWVkICopXG4gICAgfCAoIChSZXF1aXJlZCB8IERlZmF1bHQgXyB8IE9taXRfbmlsIHwgU2V4cF9vcHRpb24gfCBTZXhwX2xpc3QgfCBTZXhwX2FycmF5KVxuICAgICAgLCAoTGlzdCAoXyA6OiBfIDo6IF8gOjogXykgYXMgc2V4cCkgKSAtPlxuICAgICAgcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChOb25fcGFpciAoU29tZSBzZXhwKSkgfmZpZWxkcyB+c3RhdGUgfnBvc1xuICAgIHwgKCAoUmVxdWlyZWQgfCBEZWZhdWx0IF8gfCBPbWl0X25pbCB8IFNleHBfb3B0aW9uIHwgU2V4cF9saXN0IHwgU2V4cF9hcnJheSlcbiAgICAgICwgTGlzdCAoW10gfCBbIF8gXSkgKSAtPiBwYXJzZV92YWx1ZV9tYWxmb3JtZWQgKE5vbl9wYWlyIE5vbmUpIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICB8IFNleHBfYm9vbCwgTGlzdCAoW10gfCBfIDo6IF8gOjogXykgLT5cbiAgICAgIHBhcnNlX3ZhbHVlX21hbGZvcm1lZCBCb29sX3BheWxvYWQgfmZpZWxkcyB+c3RhdGUgfnBvc1xuICAgICgqIGFic2VudCAqKVxuICAgIHwgUmVxdWlyZWQsIEF0b20gXyAtPiBwYXJzZV92YWx1ZV9tYWxmb3JtZWQgKE1pc3NpbmcgWyBuYW1lIF0pIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICB8IERlZmF1bHQgZGVmYXVsdCwgQXRvbSBfIC0+IGRlZmF1bHQgKClcbiAgICB8IE9taXRfbmlsLCBBdG9tIF8gLT4gY29udiAoTGlzdCBbXSlcbiAgICB8IFNleHBfb3B0aW9uLCBBdG9tIF8gLT4gTm9uZVxuICAgIHwgU2V4cF9saXN0LCBBdG9tIF8gLT4gW11cbiAgICB8IFNleHBfYXJyYXksIEF0b20gXyAtPiBbfHxdXG4gICAgfCBTZXhwX2Jvb2wsIEF0b20gXyAtPiBmYWxzZVxuICBpblxuICB2YWx1ZSwgcGFyc2VfdmFsdWVzIH5maWVsZHM6cmVzdCB+c3RhdGUgfnBvczoocG9zICsgMSlcblxuYW5kIHBhcnNlX3ZhbHVlcyA6IHR5cGUgYS4gZmllbGRzOmEgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGEgPVxuICBmdW4gfmZpZWxkcyB+c3RhdGUgfnBvcyAtPlxuICBtYXRjaCBmaWVsZHMgd2l0aFxuICB8IEZpZWxkIF8gLT4gcGFyc2VfdmFsdWUgfmZpZWxkcyB+c3RhdGUgfnBvc1xuICB8IEVtcHR5IC0+ICgpXG47O1xuXG4oKiBQb3B1bGF0aW5nIHN0YXRlLiBIYW5kbGVzIHNsb3cgcGF0aCBjYXNlcyB3aGVyZSB0aGVyZSBtYXkgYmUgcmVvcmRlcmVkLCBkdXBsaWNhdGVkLFxuICAgbWlzc2luZywgb3IgZXh0cmEgZmllbGRzLiAqKVxuXG5sZXQgcmVjIHBhcnNlX3NwaW5lX21hbGZvcm1lZCBtYWxmb3JtZWQgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcyA9XG4gIGxldCBtYWxmb3JtZWQgPVxuICAgIG1hdGNoIHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcyB3aXRoXG4gICAgfCAoKSAtPiBtYWxmb3JtZWRcbiAgICB8IGV4Y2VwdGlvbiBNYWxmb3JtZWQgb3RoZXIgLT4gTWFsZm9ybWVkLmNvbWJpbmUgbWFsZm9ybWVkIG90aGVyXG4gIGluXG4gIHJhaXNlIChNYWxmb3JtZWQgbWFsZm9ybWVkKVxuXG5hbmQgcGFyc2Vfc3BpbmVfc2xvdyB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzID1cbiAgbWF0Y2ggKHNleHBzIDogU2V4cC50IGxpc3QpIHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8IChMaXN0IChBdG9tIG5hbWUgOjogXykgYXMgZmllbGQpIDo6IHNleHBzIC0+XG4gICAgbGV0IGkgPSBpbmRleCBuYW1lIGluXG4gICAgKG1hdGNoIHNlZW4gPD0gaSAmJiBpIDwgbGVuIHdpdGhcbiAgICAgfCB0cnVlIC0+XG4gICAgICAgKCogdmFsaWQgZmllbGQgZm9yIHNsb3ctcGF0aCBwYXJzaW5nICopXG4gICAgICAgbGV0IHBvcyA9IGkgLSBzZWVuIGluXG4gICAgICAgKG1hdGNoIFN0YXRlLnVuc2FmZV9nZXQgc3RhdGUgcG9zIHdpdGhcbiAgICAgICAgfCBBdG9tIF8gLT5cbiAgICAgICAgICAoKiBmaWVsZCBub3Qgc2VlbiB5ZXQgKilcbiAgICAgICAgICBTdGF0ZS51bnNhZmVfc2V0IHN0YXRlIHBvcyBmaWVsZDtcbiAgICAgICAgICBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbiAgICAgICAgfCBMaXN0IF8gLT5cbiAgICAgICAgICAoKiBmaWVsZCBhbHJlYWR5IHNlZW4gKilcbiAgICAgICAgICBwYXJzZV9zcGluZV9tYWxmb3JtZWQgKER1cHMgWyBuYW1lIF0pIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMpXG4gICAgIHwgZmFsc2UgLT5cbiAgICAgICAobWF0Y2ggMCA8PSBpICYmIGkgPCBzZWVuIHdpdGhcbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgKCogZmllbGQgc2VlbiBpbiBmYXN0IHBhdGggKilcbiAgICAgICAgICBwYXJzZV9zcGluZV9tYWxmb3JtZWQgKER1cHMgWyBuYW1lIF0pIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICgqIGV4dHJhIGZpZWxkICopXG4gICAgICAgICAgKG1hdGNoIGV4dHJhIHdpdGhcbiAgICAgICAgICAgfCB0cnVlIC0+IHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwc1xuICAgICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChFeHRyYXMgWyBuYW1lIF0pIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMpKSlcbiAgfCBzZXhwIDo6IHNleHBzIC0+XG4gICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChOb25fcGFpciAoU29tZSBzZXhwKSkgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwc1xuOztcblxuKCogU2xvdyBwYXRoIGZvciByZWNvcmQgcGFyc2luZy4gVXNlcyBzdGF0ZSB0byBzdG9yZSBmaWVsZHMgYXMgdGhleSBhcmUgZGlzY292ZXJlZC4gKilcblxubGV0IHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcyA9XG4gIGxldCB1bnNlZW4gPSBGaWVsZHMubGVuZ3RoIGZpZWxkcyBpblxuICBsZXQgc3RhdGUgPSBTdGF0ZS5jcmVhdGUgdW5zZWVuIGluXG4gIGxldCBsZW4gPSBzZWVuICsgdW5zZWVuIGluXG4gICgqIHBvcHVsYXRlIHN0YXRlICopXG4gIHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcztcbiAgKCogcGFyc2UgdmFsdWVzIGZyb20gc3RhdGUgKilcbiAgcGFyc2VfdmFsdWVzIH5maWVsZHMgfnN0YXRlIH5wb3M6MFxuOztcblxuKCogRmFzdCBwYXRoIGZvciByZWNvcmQgcGFyc2luZy4gRGlyZWN0bHkgcGFyc2VzIGFuZCByZXR1cm5zIGZpZWxkcyBpbiB0aGUgb3JkZXIgdGhleSBhcmVcbiAgIGRlY2xhcmVkLiBGYWxscyBiYWNrIG9uIHNsb3cgcGF0aCBpZiBhbnkgZmllbGRzIGFyZSBhYnNlbnQsIHJlb3JkZXJlZCwgb3IgbWFsZm9ybWVkLiAqKVxuXG5sZXQgcmVjIHBhcnNlX2ZpZWxkX2Zhc3RcbiAgOiB0eXBlIGEgYi5cbiAgICBmaWVsZHM6KGEgKiBiKSBGaWVsZHMudFxuICAgIC0+IGluZGV4OihzdHJpbmcgLT4gaW50KVxuICAgIC0+IGV4dHJhOmJvb2xcbiAgICAtPiBzZWVuOmludFxuICAgIC0+IFNleHAudCBsaXN0XG4gICAgLT4gYSAqIGJcbiAgPVxuICBmdW4gfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzIC0+XG4gIGxldCAoRmllbGQgeyBuYW1lOyBraW5kOyBjb252OyByZXN0IH0pID0gZmllbGRzIGluXG4gIG1hdGNoIHNleHBzIHdpdGhcbiAgfCBMaXN0IChBdG9tIGF0b20gOjogYXJncykgOjogb3RoZXJzIHdoZW4gU3RyaW5nLmVxdWFsIGF0b20gbmFtZSAtPlxuICAgIChtYXRjaCBraW5kLCBhcmdzIHdpdGhcbiAgICAgfCBSZXF1aXJlZCwgWyBzZXhwIF0gLT5cbiAgICAgICBjb252IHNleHAsIHBhcnNlX3NwaW5lX2Zhc3QgfmZpZWxkczpyZXN0IH5pbmRleCB+ZXh0cmEgfnNlZW46KHNlZW4gKyAxKSBvdGhlcnNcbiAgICAgfCBEZWZhdWx0IF8sIFsgc2V4cCBdIC0+XG4gICAgICAgY29udiBzZXhwLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgIHwgT21pdF9uaWwsIFsgc2V4cCBdIC0+XG4gICAgICAgY29udiBzZXhwLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgIHwgU2V4cF9vcHRpb24sIFsgc2V4cCBdIC0+XG4gICAgICAgKCBTb21lIChjb252IHNleHApXG4gICAgICAgLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzIClcbiAgICAgfCBTZXhwX2xpc3QsIFsgc2V4cCBdIC0+XG4gICAgICAgKCBsaXN0X29mX3NleHAgY29udiBzZXhwXG4gICAgICAgLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzIClcbiAgICAgfCBTZXhwX2FycmF5LCBbIHNleHAgXSAtPlxuICAgICAgICggYXJyYXlfb2Zfc2V4cCBjb252IHNleHBcbiAgICAgICAsIHBhcnNlX3NwaW5lX2Zhc3QgfmZpZWxkczpyZXN0IH5pbmRleCB+ZXh0cmEgfnNlZW46KHNlZW4gKyAxKSBvdGhlcnMgKVxuICAgICB8IFNleHBfYm9vbCwgW10gLT5cbiAgICAgICB0cnVlLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgICgqIG1hbGZvcm1lZCBmaWVsZCBvZiBzb21lIGtpbmQsIGRpc3BhdGNoIHRvIHNsb3cgcGF0aCAqKVxuICAgICB8IF8sIF8gLT4gcGFyc2VfcmVjb3JkX3Nsb3cgfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzKVxuICAoKiBtYWxmb3JtZWQgb3Igb3V0LW9mLW9yZGVyIGZpZWxkLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgfCBfIC0+IHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwc1xuXG5hbmQgcGFyc2Vfc3BpbmVfZmFzdFxuICA6IHR5cGUgYS5cbiAgICBmaWVsZHM6YSBGaWVsZHMudFxuICAgIC0+IGluZGV4OihzdHJpbmcgLT4gaW50KVxuICAgIC0+IGV4dHJhOmJvb2xcbiAgICAtPiBzZWVuOmludFxuICAgIC0+IFNleHAudCBsaXN0XG4gICAgLT4gYVxuICA9XG4gIGZ1biB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMgLT5cbiAgbWF0Y2ggZmllbGRzIHdpdGhcbiAgfCBGaWVsZCBfIC0+IHBhcnNlX2ZpZWxkX2Zhc3QgfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzXG4gIHwgRW1wdHkgLT5cbiAgICAobWF0Y2ggc2V4cHMgd2l0aFxuICAgICB8IFtdIC0+ICgpXG4gICAgIHwgXyA6OiBfIC0+XG4gICAgICAgKCogZXh0cmEgc2V4cHMsIGRpc3BhdGNoIHRvIHNsb3cgcGF0aCAqKVxuICAgICAgIHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcylcbjs7XG5cbmxldCBwYXJzZV9yZWNvcmRfZmFzdCB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgc2V4cHMgPVxuICBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbjowIHNleHBzXG47O1xuXG4oKiBFbnRyeSBwb2ludHMuICopXG5cbmxldCByZWNvcmRfb2Zfc2V4cHNcbiAgICAgIH5jYWxsZXJcbiAgICAgIH5jb250ZXh0XG4gICAgICB+ZmllbGRzXG4gICAgICB+aW5kZXhfb2ZfZmllbGRcbiAgICAgIH5hbGxvd19leHRyYV9maWVsZHNcbiAgICAgIH5jcmVhdGVcbiAgICAgIHNleHBzXG4gID1cbiAgbGV0IGFsbG93X2V4dHJhX2ZpZWxkcyA9XG4gICAgYWxsb3dfZXh0cmFfZmllbGRzIHx8IG5vdCAhU2V4cF9jb252LnJlY29yZF9jaGVja19leHRyYV9maWVsZHNcbiAgaW5cbiAgbWF0Y2hcbiAgICBwYXJzZV9yZWNvcmRfZmFzdCB+ZmllbGRzIH5pbmRleDppbmRleF9vZl9maWVsZCB+ZXh0cmE6YWxsb3dfZXh0cmFfZmllbGRzIHNleHBzXG4gIHdpdGhcbiAgfCB2YWx1ZSAtPiBjcmVhdGUgdmFsdWVcbiAgfCBleGNlcHRpb24gTWFsZm9ybWVkIG1hbGZvcm1lZCAtPiBNYWxmb3JtZWQucmFpc2UgbWFsZm9ybWVkIH5jYWxsZXIgfmNvbnRleHRcbjs7XG5cbmxldCByZWNvcmRfb2Zfc2V4cCB+Y2FsbGVyIH5maWVsZHMgfmluZGV4X29mX2ZpZWxkIH5hbGxvd19leHRyYV9maWVsZHMgfmNyZWF0ZSBzZXhwID1cbiAgbWF0Y2ggKHNleHAgOiBTZXhwLnQpIHdpdGhcbiAgfCBBdG9tIF8gYXMgY29udGV4dCAtPiByZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20gY2FsbGVyIGNvbnRleHRcbiAgfCBMaXN0IHNleHBzIGFzIGNvbnRleHQgLT5cbiAgICByZWNvcmRfb2Zfc2V4cHNcbiAgICAgIH5jYWxsZXJcbiAgICAgIH5jb250ZXh0XG4gICAgICB+ZmllbGRzXG4gICAgICB+aW5kZXhfb2ZfZmllbGRcbiAgICAgIH5hbGxvd19leHRyYV9maWVsZHNcbiAgICAgIH5jcmVhdGVcbiAgICAgIHNleHBzXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIlNleHBsaWIwX1NleHBhYmxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxvQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIlNleHBsaWIwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxXQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
