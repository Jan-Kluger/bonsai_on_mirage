// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Base64__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64 = [0];
   runtime.caml_register_global(0, Base64, "Base64__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64__Unsafe
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64_Unsafe = [0];
   runtime.caml_register_global(0, Base64_Unsafe, "Base64__Unsafe");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Invalid_bounds = "Invalid bounds",
    cst_Malformed_input = "Malformed input",
    cst_Too_much_input = "Too much input",
    cst_Wrong_padding = "Wrong padding",
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get16 = runtime.caml_string_get16,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_Length_of_alphabet_must_be = "Length of alphabet must be 64",
    cst_Alphabet_can_not_contain_p =
      "Alphabet can not contain padding character";
   function symbol(x, y){
    if(y < 1) throw caml_maybe_attach_backtrace(Stdlib[13], 1);
    return 0 < x ? 1 + runtime.caml_div(x - 1 | 0, y) | 0 : 0;
   }
   function unsafe_set_uint8(t, off, v){
    runtime.caml_bytes_unsafe_set(t, off, caml_call1(Stdlib_Char[1], v));
   }
   function make_alphabet(alphabet){
    if(64 !== caml_ml_string_length(alphabet))
     caml_call1(Stdlib[1], cst_Length_of_alphabet_must_be);
    if(caml_call2(Stdlib_String[15], alphabet, 61))
     caml_call1(Stdlib[1], cst_Alphabet_can_not_contain_p);
    var
     emap =
       caml_call2
        (Stdlib_Array[1],
         caml_ml_string_length(alphabet),
         function(i){return runtime.caml_string_get(alphabet, i);}),
     dmap = runtime.caml_make_vect(256, -1);
    caml_call2
     (Stdlib_String[31],
      function(idx, chr){
       caml_check_bound(dmap, chr)[1 + chr] = idx;
       return 0;
      },
      alphabet);
    return [0, emap, dmap];
   }
   function length_alphabet(param){
    var emap = param[1];
    return emap.length - 1;
   }
   function alphabet(param){
    var emap = param[1];
    return caml_call2
            (Stdlib_String[2],
             emap.length - 1,
             function(i){
              var _y_ = caml_check_bound(emap, i)[1 + i];
              return caml_call1(Stdlib_Char[1], _y_);
             });
   }
   var
    default_alphabet =
      make_alphabet
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
    uri_safe_alphabet =
      make_alphabet
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),
    _e_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    _f_ = [0, [11, cst_Wrong_padding, 0], cst_Wrong_padding],
    _g_ = [0, [11, cst_Malformed_input, 0], cst_Malformed_input],
    _h_ = [0, [11, cst_Too_much_input, 0], cst_Too_much_input],
    _c_ = [0, "src/base64.ml", 157, 15],
    _b_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    cst_Base64_Out_of_bounds = "Base64.Out_of_bounds",
    cst_Base64_Too_much_input = "Base64.Too_much_input",
    unsafe_set_be_uint16 =
      Stdlib_Sys[11]
       ? function(t, off, v){caml_bytes_set16(t, off, v);}
       : function
        (t, off, v){
         caml_bytes_set16(t, off, runtime.caml_bswap16(v));
        },
    Out_of_bounds = [248, cst_Base64_Out_of_bounds, caml_fresh_oo_id(0)],
    Too_much_input = [248, cst_Base64_Too_much_input, caml_fresh_oo_id(0)];
   function get_uint8(t, off){
    var
     _w_ = off < 0 ? 1 : 0,
     _x_ = _w_ || (caml_ml_string_length(t) <= off ? 1 : 0);
    if(_x_) throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
    return caml_string_unsafe_get(t, off);
   }
   var padding = 61;
   function error_msgf(fmt){
    return caml_call2
            (Stdlib_Format[149],
             function(err){return [1, [0, 3854881, err]];},
             fmt);
   }
   function _a_(pad, param, opt, len, input){
    var emap = param[1], off = opt ? opt[1] : 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_ml_string_length(input) - off | 0;
    if
     (0 <= len$1
      && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
     var
      n = symbol(len$1, 3) * 4 | 0,
      res = caml_create_bytes(n),
      emit =
        function(b1, b2, b3, i){
         var i$0 = (b1 << 4 | b2 >>> 4 | 0) & 63, i$1 = (b1 >>> 2 | 0) & 63;
         unsafe_set_be_uint16(res, i, emap[1 + i$1] << 8 | emap[1 + i$0]);
         var i$2 = b3 & 63, i$3 = (b2 << 2 | b3 >>> 6 | 0) & 63;
         return unsafe_set_be_uint16
                 (res, i + 2 | 0, emap[1 + i$3] << 8 | emap[1 + i$2]);
        };
     a:
     b:
     {
      c:
      {
       var j = 0, i = 0;
       for(;;){
        if(i === len$1) break b;
        if(i === (len$1 - 1 | 0)) break c;
        if(i === (len$1 - 2 | 0)) break;
        var
         off$3 = (off + i | 0) + 2 | 0,
         off$4 = (off + i | 0) + 1 | 0,
         off$5 = off + i | 0;
        emit
         (caml_string_unsafe_get(input, off$5),
          caml_string_unsafe_get(input, off$4),
          caml_string_unsafe_get(input, off$3),
          j);
        var i$0 = i + 3 | 0, j$0 = j + 4 | 0;
        j = j$0;
        i = i$0;
       }
       var off$1 = (off + i | 0) + 1 | 0, off$2 = off + i | 0;
       emit
        (caml_string_unsafe_get(input, off$2),
         caml_string_unsafe_get(input, off$1),
         0,
         j);
       break a;
      }
      var off$0 = off + i | 0;
      emit(caml_string_unsafe_get(input, off$0), 0, 0, j);
      break a;
     }
     var pad_to_write = (3 - (len$1 % 3 | 0) | 0) % 3 | 0;
     if(! pad)
      return [0,
              [0, caml_call1(Stdlib_Bytes[44], res), 0, n - pad_to_write | 0]];
     var i$1 = pad_to_write;
     for(;;){
      if(0 === i$1) return [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n]];
      unsafe_set_uint8(res, n - i$1 | 0, padding);
      var i$2 = i$1 - 1 | 0;
      i$1 = i$2;
     }
    }
    return error_msgf(_b_);
   }
   function encode(_v_, opt, off, len, input){
    var
     pad = _v_ ? _v_[1] : 1,
     alphabet = opt ? opt[1] : default_alphabet,
     err = _a_(pad, alphabet, off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[16], res, off$0, len$0)];
   }
   function encode_string(pad, alphabet, input){
    var match = encode(pad, alphabet, 0, 0, input);
    if(0 !== match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var res = match[1];
    return res;
   }
   function encode_sub(_u_, opt, off, len, input){
    var pad = _u_ ? _u_[1] : 1, alphabet = opt ? opt[1] : default_alphabet;
    return _a_(pad, alphabet, off, len, input);
   }
   function encode_exn(pad, alphabet, off, len, input){
    var match = encode(pad, alphabet, off, len, input);
    if(0 === match[0]){var v = match[1]; return v;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   function _d_(_i_, param, opt, len, input){
    var
     invalid_pad_overflow = _i_ ? _i_[1] : 1,
     dmap = param[2],
     off = opt ? opt[1] : 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_ml_string_length(input) - off | 0;
    if
     (0 <= len$1
      && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
     var
      n = symbol(len$1, 4) * 4 | 0,
      n$0 = symbol(n, 4) * 3 | 0,
      res = caml_create_bytes(n$0),
      get_uint8_or_padding =
        invalid_pad_overflow
         ? function
          (t, i){
           if(len$1 <= i) throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
           return get_uint8(t, off + i | 0);
          }
         : function
          (t, i){
           try{
            var _s_ = i < len$1 ? get_uint8(t, off + i | 0) : padding;
            return _s_;
           }
           catch(_t_){
            var _r_ = caml_wrap_exception(_t_);
            if(_r_ === Out_of_bounds) return padding;
            throw caml_maybe_attach_backtrace(_r_, 0);
           }
          },
      dmap$0 =
        function(i){
         var x = dmap[1 + i];
         if(x === -1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         return x;
        },
      only_padding =
        function(pad, idx){
         var pad$0 = [0, pad + 3 | 0], idx$0 = [0, idx];
         for(;;){
          if((idx$0[1] + 4 | 0) >= len$1) break;
          var
           _p_ =
             15677 !== caml_string_get16(input, off + idx$0[1] | 0) ? 1 : 0,
           _q_ =
             _p_
             ||
              (15677
                !== caml_string_get16(input, (off + idx$0[1] | 0) + 2 | 0)
                ? 1
                : 0);
          if(_q_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          idx$0[1] = idx$0[1] + 4 | 0;
          pad$0[1] = pad$0[1] + 3 | 0;
         }
         for(;;){
          if(idx$0[1] >= len$1) return pad$0[1];
          var off$0 = off + idx$0[1] | 0;
          if(caml_string_unsafe_get(input, off$0) !== 61)
           throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          idx$0[1]++;
         }
        };
     try{
      a:
      {
       b:
       {
        var off$1 = 0, i = 0;
        for(;;){
         if(i === n){var pad$4 = 0; break a;}
         var x$0 = get_uint8_or_padding(input, i + 3 | 0);
         c:
         try{var pad$3 = 0, _m_ = dmap$0(x$0), pad = pad$3, d = _m_;}
         catch(exn$0){
          var exn = caml_wrap_exception(exn$0);
          if(exn === Stdlib[8] && x$0 === 61){var pad = 1, d = 0; break c;}
          throw caml_maybe_attach_backtrace(exn, 0);
         }
         var x$1 = get_uint8_or_padding(input, i + 2 | 0);
         c:
         try{var _l_ = dmap$0(x$1), pad$0 = pad, c = _l_;}
         catch(exn){
          var exn$0 = caml_wrap_exception(exn);
          if(exn$0 === Stdlib[8] && x$1 === 61 && 1 === pad){var pad$0 = 2, c = 0; break c;}
          throw caml_maybe_attach_backtrace(exn$0, 0);
         }
         var x$2 = get_uint8_or_padding(input, i + 1 | 0);
         c:
         try{var _k_ = dmap$0(x$2), pad$1 = pad$0, b = _k_;}
         catch(exn){
          var exn$1 = caml_wrap_exception(exn);
          if(exn$1 === Stdlib[8] && x$2 === 61 && 2 === pad$0){var pad$1 = 3, b = 0; break c;}
          throw caml_maybe_attach_backtrace(exn$1, 0);
         }
         var x$3 = get_uint8_or_padding(input, i);
         c:
         try{var _j_ = dmap$0(x$3), pad$2 = pad$1, a = _j_;}
         catch(exn){
          var exn$2 = caml_wrap_exception(exn);
          if(exn$2 === Stdlib[8] && x$3 === 61 && 3 === pad$1){var pad$2 = 4, a = 0; break c;}
          throw caml_maybe_attach_backtrace(exn$2, 0);
         }
         var x = a << 18 | b << 12 | c << 6 | d, v = x >>> 8 | 0;
         c:
         if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 1 | 0)){
          if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 2 | 0)){unsafe_set_be_uint16(res, off$1, v); break c;}
          unsafe_set_uint8(res, off$1, v >>> 8 | 0);
          break c;
         }
         var v$0 = x & 255, off$0 = off$1 + 2 | 0;
         c:
         if(0 <= off$0 && caml_ml_bytes_length(res) > off$0){unsafe_set_uint8(res, off$0, v$0); break c;}
         if((i + 4 | 0) === n) break b;
         if(0 !== pad$2) break;
         var i$0 = i + 4 | 0, j = off$1 + 3 | 0;
         off$1 = j;
         i = i$0;
        }
        if(4 === pad$2){var pad$4 = only_padding(3, i + 4 | 0); break a;}
        if(1 === invalid_pad_overflow)
         throw caml_maybe_attach_backtrace(Too_much_input, 1);
        var pad$4 = only_padding(pad$2, i + 4 | 0);
        break a;
       }
       var pad$4 = 0 === pad$2 ? 0 : 4 === pad$2 ? 3 : pad$2;
      }
     }
     catch(_o_){
      var _n_ = caml_wrap_exception(_o_);
      if(_n_ === Out_of_bounds) return error_msgf(_f_);
      if(_n_ === Stdlib[8]) return error_msgf(_g_);
      if(_n_ === Too_much_input) return error_msgf(_h_);
      throw caml_maybe_attach_backtrace(_n_, 0);
     }
     return 0 === pad$4
             ? [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n$0]]
             : [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n$0 - pad$4 | 0]];
    }
    return error_msgf(_e_);
   }
   function decode(pad, opt, off, len, input){
    var
     alphabet = opt ? opt[1] : default_alphabet,
     err = _d_(pad, alphabet, off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[16], res, off$0, len$0)];
   }
   function decode_sub(pad, opt, off, len, input){
    var alphabet = opt ? opt[1] : default_alphabet;
    return _d_(pad, alphabet, off, len, input);
   }
   function decode_exn(pad, alphabet, off, len, input){
    var match = decode(pad, alphabet, off, len, input);
    if(0 === match[0]){var res = match[1]; return res;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   var
    Base64 =
      [0,
       default_alphabet,
       uri_safe_alphabet,
       make_alphabet,
       length_alphabet,
       alphabet,
       decode_exn,
       decode_sub,
       decode,
       encode,
       encode_string,
       encode_sub,
       encode_exn];
   runtime.caml_register_global(20, Base64, "Base64");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZTY0LmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlNjQuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2U2NCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsU0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2U2NC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZTY0X1Vuc2FmZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZ0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlNjQuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9JbnZhbGlkX2JvdW5kcyIsImNzdF9NYWxmb3JtZWRfaW5wdXQiLCJjc3RfVG9vX211Y2hfaW5wdXQiLCJjc3RfV3JvbmdfcGFkZGluZyIsImNhbWxfYnl0ZXNfc2V0MTYiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX0J5dGVzIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX0NoYXIiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfU3lzIiwiY3N0X0xlbmd0aF9vZl9hbHBoYWJldF9tdXN0X2JlIiwiY3N0X0FscGhhYmV0X2Nhbl9ub3RfY29udGFpbl9wIiwic3ltYm9sIiwieCIsInkiLCJ1bnNhZmVfc2V0X3VpbnQ4IiwidCIsIm9mZiIsInYiLCJtYWtlX2FscGhhYmV0IiwiYWxwaGFiZXQiLCJlbWFwIiwiaSIsImRtYXAiLCJpZHgiLCJjaHIiLCJsZW5ndGhfYWxwaGFiZXQiLCJwYXJhbSIsImRlZmF1bHRfYWxwaGFiZXQiLCJ1cmlfc2FmZV9hbHBoYWJldCIsImNzdF9CYXNlNjRfT3V0X29mX2JvdW5kcyIsImNzdF9CYXNlNjRfVG9vX211Y2hfaW5wdXQiLCJ1bnNhZmVfc2V0X2JlX3VpbnQxNiIsIk91dF9vZl9ib3VuZHMiLCJUb29fbXVjaF9pbnB1dCIsImdldF91aW50OCIsInBhZGRpbmciLCJlcnJvcl9tc2dmIiwiZm10IiwiZXJyIiwicGFkIiwib3B0IiwibGVuIiwiaW5wdXQiLCJuIiwicmVzIiwiZW1pdCIsImIxIiwiYjIiLCJiMyIsImoiLCJwYWRfdG9fd3JpdGUiLCJlbmNvZGUiLCJtYXRjaCIsImVuY29kZV9zdHJpbmciLCJlbmNvZGVfc3ViIiwiZW5jb2RlX2V4biIsImludmFsaWRfcGFkX292ZXJmbG93IiwiZ2V0X3VpbnQ4X29yX3BhZGRpbmciLCJvbmx5X3BhZGRpbmciLCJkIiwiZXhuIiwiYyIsImIiLCJhIiwiZGVjb2RlIiwiZGVjb2RlX3N1YiIsImRlY29kZV9leG4iLCJCYXNlNjQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZTY0L2Jhc2U2NC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0FBQUM7QUFBQUEsSUMwQkUsVUFBYztBQUFBLElBQ2QsbUJBQWMsc0NBQXdCO0FBQUE7QUFBQSxZQUFBQyxpQkFBQUMsR0FBQUMsS0FBQUM7QUFBQUEsSUFLMEIsc0NBQVo7QUFBQSxHQUFZO0FBQUEsWUFBQUMsY0FBQUM7QUFBQUEsSUFlaEU7QUFBQSxLQUNLO0FBQUEsSUFDRjtBQUFBLEtBQ0U7QUFBQTtB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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEcEV0RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCpcbiAqIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IENpdHJpeCBTeXN0ZW1zIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMCBUaG9tYXMgR2F6YWduYWlyZSA8dGhvbWFzQGdhemFnbmFpcmUuY29tPlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgQW5pbCBNYWRoYXZhcGVkZHkgPGFuaWxAcmVjb2lsLm9yZz5cbiAqIENvcHlyaWdodCAoYykgMjAxNiBEYXZpZCBLYWxvcGVyIE1lcsWhaW5qYWtcbiAqIENvcHlyaWdodCAoYykgMjAxOCBSb21haW4gQ2FsYXNjaWJldHRhIDxyb21haW4uY2FsYXNjaWJldHRhQGdtYWlsLmNvbT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqKVxuXG50eXBlIGFscGhhYmV0ID0geyBlbWFwIDogaW50IGFycmF5OyBkbWFwIDogaW50IGFycmF5IH1cblxudHlwZSBzdWIgPSBzdHJpbmcgKiBpbnQgKiBpbnRcblxubGV0ICggLy8gKSB4IHkgPVxuICBpZiB5IDwgMSB0aGVuIHJhaXNlIERpdmlzaW9uX2J5X3plcm8gO1xuICBpZiB4ID4gMCB0aGVuIDEgKyAoKHggLSAxKSAvIHkpIGVsc2UgMFxuICBbQEBpbmxpbmVdXG5cbmxldCB1bnNhZmVfZ2V0X3VpbnQ4IHQgb2ZmID0gQ2hhci5jb2RlIChTdHJpbmcudW5zYWZlX2dldCB0IG9mZilcblxubGV0IHVuc2FmZV9zZXRfdWludDggdCBvZmYgdiA9IEJ5dGVzLnVuc2FmZV9zZXQgdCBvZmYgKENoYXIuY2hyIHYpXG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNiA9IFVuc2FmZS51bnNhZmVfc2V0X3VpbnQxNlxuXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQxNiA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9zdHJpbmdfZ2V0MTZ1XCJcbiAgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIiBbQEBub2FsbG9jXVxuXG5sZXQgbm9uZSA9IC0xXG5cbigqIFdlIG1vc3RseSB3YW50IHRvIGhhdmUgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIFtkbWFwXSAoZS5nLiBbaW50IG9wdGlvblxuICAgYXJyYXldKS4gU28gd2UgY29uc2lkZXIgdGhlIFtub25lXSB2YWx1ZSBhcyBbLTFdLiAqKVxuXG5sZXQgbWFrZV9hbHBoYWJldCBhbHBoYWJldCA9XG4gIGlmIFN0cmluZy5sZW5ndGggYWxwaGFiZXQgPD4gNjRcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkxlbmd0aCBvZiBhbHBoYWJldCBtdXN0IGJlIDY0XCIgO1xuICBpZiBTdHJpbmcuY29udGFpbnMgYWxwaGFiZXQgJz0nXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBbHBoYWJldCBjYW4gbm90IGNvbnRhaW4gcGFkZGluZyBjaGFyYWN0ZXJcIiA7XG4gIGxldCBlbWFwID1cbiAgICBBcnJheS5pbml0IChTdHJpbmcubGVuZ3RoIGFscGhhYmV0KSAoZnVuIGkgLT4gQ2hhci5jb2RlIGFscGhhYmV0LltpXSkgaW5cbiAgbGV0IGRtYXAgPSBBcnJheS5tYWtlIDI1NiBub25lIGluXG4gIFN0cmluZy5pdGVyaSAoZnVuIGlkeCBjaHIgLT4gZG1hcC4oQ2hhci5jb2RlIGNocikgPC0gaWR4KSBhbHBoYWJldCA7XG4gIHsgZW1hcDsgZG1hcCB9XG5cbmxldCBsZW5ndGhfYWxwaGFiZXQgeyBlbWFwOyBfIH0gPSBBcnJheS5sZW5ndGggZW1hcFxuXG5sZXQgYWxwaGFiZXQgeyBlbWFwOyBfIH0gPVxuICBTdHJpbmcuaW5pdCAoQXJyYXkubGVuZ3RoIGVtYXApIChmdW4gaSAtPiBDaGFyLmNociBlbWFwLihpKSlcblxubGV0IGRlZmF1bHRfYWxwaGFiZXQgPVxuICBtYWtlX2FscGhhYmV0XG4gICAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCJcblxubGV0IHVyaV9zYWZlX2FscGhhYmV0ID1cbiAgbWFrZV9hbHBoYWJldFxuICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiXG5cbmxldCB1bnNhZmVfc2V0X2JlX3VpbnQxNiA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gZnVuIHQgb2ZmIHYgLT4gdW5zYWZlX3NldF91aW50MTYgdCBvZmYgdlxuICBlbHNlIGZ1biB0IG9mZiB2IC0+IHVuc2FmZV9zZXRfdWludDE2IHQgb2ZmIChzd2FwMTYgdilcblxuKCogV2UgbWFrZSB0aGlzIGV4Y2VwdGlvbiB0byBlbnN1cmUgdG8ga2VlcCBhIGNvbnRyb2wgYWJvdXQgd2hpY2ggZXhjZXB0aW9uIHdlXG4gICBjYW4gcmFpc2UgYW5kIGF2b2lkIGFwcGVhcmFuY2Ugb2YgdW5rbm93biBleGNlcHRpb25zIGxpa2UgYW4gZXgtbmloaWxvXG4gICBtYWdpYyByYWJiaXQgKG9yIG1hZ2ljIG1vbmV5PykuICopXG5leGNlcHRpb24gT3V0X29mX2JvdW5kc1xuXG5leGNlcHRpb24gVG9vX211Y2hfaW5wdXRcblxubGV0IGdldF91aW50OCB0IG9mZiA9XG4gIGlmIG9mZiA8IDAgfHwgb2ZmID49IFN0cmluZy5sZW5ndGggdCB0aGVuIHJhaXNlIE91dF9vZl9ib3VuZHMgO1xuICB1bnNhZmVfZ2V0X3VpbnQ4IHQgb2ZmXG5cbmxldCBwYWRkaW5nID0gaW50X29mX2NoYXIgJz0nXG5cbmxldCBlcnJvcl9tc2dmIGZtdCA9IEZvcm1hdC5rc3ByaW50ZiAoZnVuIGVyciAtPiBFcnJvciAoYE1zZyBlcnIpKSBmbXRcblxubGV0IGVuY29kZV9zdWIgcGFkIHsgZW1hcDsgXyB9ID8ob2ZmID0gMCkgP2xlbiBpbnB1dCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoIFNvbWUgbGVuIC0+IGxlbiB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBpbnB1dCAtIG9mZiBpblxuXG4gIGlmIGxlbiA8IDAgfHwgb2ZmIDwgMCB8fCBvZmYgPiBTdHJpbmcubGVuZ3RoIGlucHV0IC0gbGVuXG4gIHRoZW4gZXJyb3JfbXNnZiBcIkludmFsaWQgYm91bmRzXCJcbiAgZWxzZVxuICAgIGxldCBuID0gbGVuIGluXG4gICAgbGV0IG4nID0gbiAvLyAzICogNCBpblxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbicgaW5cblxuICAgIGxldCBlbWFwIGkgPSBBcnJheS51bnNhZmVfZ2V0IGVtYXAgaSBpblxuXG4gICAgbGV0IGVtaXQgYjEgYjIgYjMgaSA9XG4gICAgICB1bnNhZmVfc2V0X2JlX3VpbnQxNiByZXMgaVxuICAgICAgICAoKGVtYXAgKChiMSBsc3IgMikgbGFuZCAweDNmKSBsc2wgOClcbiAgICAgICAgbG9yIGVtYXAgKChiMSBsc2wgNCkgbG9yIChiMiBsc3IgNCkgbGFuZCAweDNmKSkgO1xuICAgICAgdW5zYWZlX3NldF9iZV91aW50MTYgcmVzIChpICsgMilcbiAgICAgICAgKChlbWFwICgoYjIgbHNsIDIpIGxvciAoYjMgbHNyIDYpIGxhbmQgMHgzZikgbHNsIDgpXG4gICAgICAgIGxvciBlbWFwIChiMyBsYW5kIDB4M2YpKSBpblxuXG4gICAgbGV0IHJlYyBlbmMgaiBpID1cbiAgICAgIGlmIGkgPSBuXG4gICAgICB0aGVuICgpXG4gICAgICBlbHNlIGlmIGkgPSBuIC0gMVxuICAgICAgdGhlbiBlbWl0ICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpKSkgMCAwIGpcbiAgICAgIGVsc2UgaWYgaSA9IG4gLSAyXG4gICAgICB0aGVuXG4gICAgICAgIGVtaXRcbiAgICAgICAgICAodW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgaSkpXG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkgKyAxKSlcbiAgICAgICAgICAwIGpcbiAgICAgIGVsc2UgKFxuICAgICAgICBlbWl0XG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkpKVxuICAgICAgICAgICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpICsgMSkpXG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkgKyAyKSlcbiAgICAgICAgICBqIDtcbiAgICAgICAgZW5jIChqICsgNCkgKGkgKyAzKSkgaW5cblxuICAgIGxldCByZWMgdW5zYWZlX2ZpeCA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gKClcbiAgICAgIHwgaSAtPlxuICAgICAgICAgIHVuc2FmZV9zZXRfdWludDggcmVzIChuJyAtIGkpIHBhZGRpbmcgO1xuICAgICAgICAgIHVuc2FmZV9maXggKGkgLSAxKSBpblxuXG4gICAgZW5jIDAgMCA7XG5cbiAgICBsZXQgcGFkX3RvX3dyaXRlID0gKDMgLSAobiBtb2QgMykpIG1vZCAzIGluXG5cbiAgICBpZiBwYWRcbiAgICB0aGVuIChcbiAgICAgIHVuc2FmZV9maXggcGFkX3RvX3dyaXRlIDtcbiAgICAgIE9rIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlcywgMCwgbicpKVxuICAgIGVsc2UgT2sgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzLCAwLCBuJyAtIHBhZF90b193cml0ZSlcblxuKCogW3BhZCA9IGZhbHNlXSwgd2UgZG9uJ3Qgd2FudCB0byB3cml0ZSB0aGVtLiAqKVxuXG5sZXQgZW5jb2RlID8ocGFkID0gdHJ1ZSkgPyhhbHBoYWJldCA9IGRlZmF1bHRfYWxwaGFiZXQpID9vZmYgP2xlbiBpbnB1dCA9XG4gIG1hdGNoIGVuY29kZV9zdWIgcGFkIGFscGhhYmV0ID9vZmYgP2xlbiBpbnB1dCB3aXRoXG4gIHwgT2sgKHJlcywgb2ZmLCBsZW4pIC0+IE9rIChTdHJpbmcuc3ViIHJlcyBvZmYgbGVuKVxuICB8IEVycm9yIF8gYXMgZXJyIC0+IGVyclxuXG5sZXQgZW5jb2RlX3N0cmluZyA/cGFkID9hbHBoYWJldCBpbnB1dCA9XG4gIG1hdGNoIGVuY29kZSA/cGFkID9hbHBoYWJldCBpbnB1dCB3aXRoXG4gIHwgT2sgcmVzIC0+IHJlc1xuICB8IEVycm9yIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBlbmNvZGVfc3ViID8ocGFkID0gdHJ1ZSkgPyhhbHBoYWJldCA9IGRlZmF1bHRfYWxwaGFiZXQpID9vZmYgP2xlbiBpbnB1dCA9XG4gIGVuY29kZV9zdWIgcGFkIGFscGhhYmV0ID9vZmYgP2xlbiBpbnB1dFxuXG5sZXQgZW5jb2RlX2V4biA/cGFkID9hbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgPVxuICBtYXRjaCBlbmNvZGUgP3BhZCA/YWxwaGFiZXQgP29mZiA/bGVuIGlucHV0IHdpdGhcbiAgfCBPayB2IC0+IHZcbiAgfCBFcnJvciAoYE1zZyBlcnIpIC0+IGludmFsaWRfYXJnIGVyclxuXG5sZXQgZGVjb2RlX3N1YiA/KHBhZCA9IHRydWUpIHsgZG1hcDsgXyB9ID8ob2ZmID0gMCkgP2xlbiBpbnB1dCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoIFNvbWUgbGVuIC0+IGxlbiB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBpbnB1dCAtIG9mZiBpblxuXG4gIGlmIGxlbiA8IDAgfHwgb2ZmIDwgMCB8fCBvZmYgPiBTdHJpbmcubGVuZ3RoIGlucHV0IC0gbGVuXG4gIHRoZW4gZXJyb3JfbXNnZiBcIkludmFsaWQgYm91bmRzXCJcbiAgZWxzZVxuICAgIGxldCBuID0gbGVuIC8vIDQgKiA0IGluXG4gICAgbGV0IG4nID0gbiAvLyA0ICogMyBpblxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbicgaW5cbiAgICBsZXQgaW52YWxpZF9wYWRfb3ZlcmZsb3cgPSBwYWQgaW5cblxuICAgIGxldCBnZXRfdWludDhfb3JfcGFkZGluZyA9XG4gICAgICBpZiBwYWRcbiAgICAgIHRoZW4gKGZ1biB0IGkgLT5cbiAgICAgICAgaWYgaSA+PSBsZW4gdGhlbiByYWlzZSBPdXRfb2ZfYm91bmRzIDtcbiAgICAgICAgZ2V0X3VpbnQ4IHQgKG9mZiArIGkpKVxuICAgICAgZWxzZVxuICAgICAgICBmdW4gdCBpIC0+XG4gICAgICAgIHRyeSBpZiBpIDwgbGVuIHRoZW4gZ2V0X3VpbnQ4IHQgKG9mZiArIGkpIGVsc2UgcGFkZGluZ1xuICAgICAgICB3aXRoIE91dF9vZl9ib3VuZHMgLT4gcGFkZGluZyBpblxuXG4gICAgbGV0IHNldF9iZV91aW50MTYgdCBvZmYgdiA9XG4gICAgICAoKiBjYW4gbm90IHdyaXRlIDIgYnl0ZXMuICopXG4gICAgICBpZiBvZmYgPCAwIHx8IG9mZiArIDEgPiBCeXRlcy5sZW5ndGggdFxuICAgICAgdGhlbiAoKSAoKiBjYW4gbm90IHdyaXRlIDEgYnl0ZSBidXQgY2FuIHdyaXRlIDEgYnl0ZSAqKVxuICAgICAgZWxzZSBpZiBvZmYgPCAwIHx8IG9mZiArIDIgPiBCeXRlcy5sZW5ndGggdFxuICAgICAgdGhlbiB1bnNhZmVfc2V0X3VpbnQ4IHQgb2ZmICh2IGxzciA4KSAoKiBjYW4gd3JpdGUgMiBieXRlcy4gKilcbiAgICAgIGVsc2UgdW5zYWZlX3NldF9iZV91aW50MTYgdCBvZmYgdiBpblxuXG4gICAgbGV0IHNldF91aW50OCB0IG9mZiB2ID1cbiAgICAgIGlmIG9mZiA8IDAgfHwgb2ZmID49IEJ5dGVzLmxlbmd0aCB0IHRoZW4gKCkgZWxzZSB1bnNhZmVfc2V0X3VpbnQ4IHQgb2ZmIHZcbiAgICBpblxuXG4gICAgbGV0IGVtaXQgYSBiIGMgZCBqID1cbiAgICAgIGxldCB4ID0gKGEgbHNsIDE4KSBsb3IgKGIgbHNsIDEyKSBsb3IgKGMgbHNsIDYpIGxvciBkIGluXG4gICAgICBzZXRfYmVfdWludDE2IHJlcyBqICh4IGxzciA4KSA7XG4gICAgICBzZXRfdWludDggcmVzIChqICsgMikgKHggbGFuZCAweGZmKSBpblxuXG4gICAgbGV0IGRtYXAgaSA9XG4gICAgICBsZXQgeCA9IEFycmF5LnVuc2FmZV9nZXQgZG1hcCBpIGluXG4gICAgICBpZiB4ID0gbm9uZSB0aGVuIHJhaXNlIE5vdF9mb3VuZCA7XG4gICAgICB4IGluXG5cbiAgICBsZXQgb25seV9wYWRkaW5nIHBhZCBpZHggPVxuICAgICAgKCogYmVjYXVzZSB3ZSByb3VuZCBsZW5ndGggb2YgW3Jlc10gdG8gdGhlIHVwcGVyIGJvdW5kIG9mIGhvdyBtYW55XG4gICAgICAgICBjaGFyYWN0ZXJzIHdlIHNob3VsZCBoYXZlIGZyb20gW2lucHV0XSwgd2UgZ290IGF0IHRoaXMgc3RhZ2Ugb25seSBwYWRkaW5nXG4gICAgICAgICBjaGFyYWN0ZXJzIGFuZCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtLCBzbyBmb3IgZWFjaCBbPT09PV0sIHdlIGRlbGV0ZSAzXG4gICAgICAgICBieXRlcy4gKilcbiAgICAgIGxldCBwYWQgPSByZWYgKHBhZCArIDMpIGluXG4gICAgICBsZXQgaWR4ID0gcmVmIGlkeCBpblxuXG4gICAgICB3aGlsZSAhaWR4ICsgNCA8IGxlbiBkb1xuICAgICAgICAoKiB1c2UgW3Vuc2FmZV9nZXRfdWludDE2XSBpbnN0ZWFkIFt1bnNhZmVfZ2V0X3VpbnQzMl0gdG8gYXZvaWQgYWxsb2NhdGlvblxuICAgICAgICAgICBvZiBbaW50MzJdLiBPZiBjb3Vyc2UsIFszZDNkM2QzZF0gaXMgWz09PT1dLiAqKVxuICAgICAgICBpZiB1bnNhZmVfZ2V0X3VpbnQxNiBpbnB1dCAob2ZmICsgIWlkeCkgPD4gMHgzZDNkXG4gICAgICAgICAgIHx8IHVuc2FmZV9nZXRfdWludDE2IGlucHV0IChvZmYgKyAhaWR4ICsgMikgPD4gMHgzZDNkXG4gICAgICAgIHRoZW4gcmFpc2UgTm90X2ZvdW5kIDtcblxuICAgICAgICAoKiBXZSBnb3Qgc29tZXRoaW5nIGJhZCwgc2hvdWxkIGJlIGEgdmFsaWQgY2hhcmFjdGVyIGFjY29yZGluZyB0b1xuICAgICAgICAgICBbYWxwaGFiZXRdIGJ1dCBvdXRzaWRlIHRoZSBzY29wZS4gKilcbiAgICAgICAgaWR4IDo9ICFpZHggKyA0IDtcbiAgICAgICAgcGFkIDo9ICFwYWQgKyAzXG4gICAgICBkb25lIDtcbiAgICAgIHdoaWxlICFpZHggPCBsZW4gZG9cbiAgICAgICAgaWYgdW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgIWlkeCkgPD4gcGFkZGluZyB0aGVuIHJhaXNlIE5vdF9mb3VuZCA7XG5cbiAgICAgICAgaW5jciBpZHhcbiAgICAgIGRvbmUgO1xuICAgICAgIXBhZCBpblxuXG4gICAgbGV0IHJlYyBkZWMgaiBpID1cbiAgICAgIGlmIGkgPSBuXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGQsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCAoaSArIDMpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIDApIHdpdGggTm90X2ZvdW5kIHdoZW4geCA9IHBhZGRpbmcgLT4gKDAsIDEpIGluXG4gICAgICAgICgqIFtOb3RfZm91bmRdIGlmZiBbeCDiiIkgYWxwaGFiZXQgYW5kIHggPD4gJz0nXSBjYW4gbGVhay4gKilcbiAgICAgICAgbGV0IGMsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCAoaSArIDIpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIHBhZClcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCB3aGVuIHggPSBwYWRkaW5nICYmIHBhZCA9IDEgLT4gKDAsIDIpIGluXG4gICAgICAgICgqIFtOb3RfZm91bmRdIGlmZiBbeCDiiIkgYWxwaGFiZXQgYW5kIHggPD4gJz0nXSBjYW4gbGVhay4gKilcbiAgICAgICAgbGV0IGIsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCAoaSArIDEpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIHBhZClcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCB3aGVuIHggPSBwYWRkaW5nICYmIHBhZCA9IDIgLT4gKDAsIDMpIGluXG4gICAgICAgICgqIFtOb3RfZm91bmRdIGlmZiBbeCDiiIkgYWxwaGFiZXQgYW5kIHggPD4gJz0nXSBjYW4gbGVhay4gKilcbiAgICAgICAgbGV0IGEsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCBpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIHBhZClcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCB3aGVuIHggPSBwYWRkaW5nICYmIHBhZCA9IDMgLT4gKDAsIDQpIGluXG5cbiAgICAgICAgKCogW05vdF9mb3VuZF0gaWZmIFt4IOKIiSBhbHBoYWJldCBhbmQgeCA8PiAnPSddIGNhbiBsZWFrLiAqKVxuICAgICAgICBlbWl0IGEgYiBjIGQgaiA7XG5cbiAgICAgICAgaWYgaSArIDQgPSBuICgqIGVuZCBvZiBpbnB1dCBpbiBhbnl3YXkgKilcbiAgICAgICAgdGhlblxuICAgICAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICAgICAgfCAwIC0+IDBcbiAgICAgICAgICB8IDQgLT5cbiAgICAgICAgICAgICAgKCogYXNzZXJ0IChpbnZhbGlkX3BhZF9vdmVyZmxvdyA9IGZhbHNlKSA7ICopXG4gICAgICAgICAgICAgIDNcbiAgICAgICAgICAoKiBbZ2V0X3VpbnQ4XSBsaWVzIGFuZCBpZiB3ZSBnZXQgWzRdLCB0aGF0IG1lYW4gd2UgZ290IG9uZSBvciBtb3JlIChhdFxuICAgICAgICAgICAgIG1vc3QgNCkgcGFkZGluZyBjaGFyYWN0ZXIuIEluIHRoaXMgc2l0dWF0aW9uLCBiZWNhdXNlIHdlIHJvdW5kIGxlbmd0aFxuICAgICAgICAgICAgIG9mIFtyZXNdIChzZWUgW24gLy8gNF0pLCB3ZSBuZWVkIHRvIGRlbGV0ZSAzIGJ5dGVzLiAqKVxuICAgICAgICAgIHwgcGFkIC0+IHBhZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggcGFkIHdpdGhcbiAgICAgICAgICB8IDAgLT4gZGVjIChqICsgMykgKGkgKyA0KVxuICAgICAgICAgIHwgNCAtPlxuICAgICAgICAgICAgICAoKiBhc3NlcnQgKGludmFsaWRfcGFkX292ZXJmbG93ID0gZmFsc2UpIDsgKilcbiAgICAgICAgICAgICAgb25seV9wYWRkaW5nIDMgKGkgKyA0KVxuICAgICAgICAgICgqIFNhbWUgc2l0dWF0aW9uIHRoYW4gYWJvdmUgYnV0IHdlIHNob3VsZCBnZXQgb25seSBtb3JlIHBhZGRpbmdcbiAgICAgICAgICAgICBjaGFyYWN0ZXJzIHRoZW4uICopXG4gICAgICAgICAgfCBwYWQgLT5cbiAgICAgICAgICAgICAgaWYgaW52YWxpZF9wYWRfb3ZlcmZsb3cgPSB0cnVlIHRoZW4gcmFpc2UgVG9vX211Y2hfaW5wdXQgO1xuICAgICAgICAgICAgICBvbmx5X3BhZGRpbmcgcGFkIChpICsgNCkgaW5cblxuICAgIG1hdGNoIGRlYyAwIDAgd2l0aFxuICAgIHwgMCAtPiBPayAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXMsIDAsIG4nKVxuICAgIHwgcGFkIC0+IE9rIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlcywgMCwgbicgLSBwYWQpXG4gICAgfCBleGNlcHRpb24gT3V0X29mX2JvdW5kcyAtPlxuICAgICAgICBlcnJvcl9tc2dmIFwiV3JvbmcgcGFkZGluZ1wiXG4gICAgICAgICgqIGFwcGVhciBvbmx5IHdoZW4gW3BhZCA9IHRydWVdIGFuZCB3aGVuIGxlbmd0aCBvZiBpbnB1dCBpcyBub3QgYSBtdWx0aXBsZSBvZiA0LiAqKVxuICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgICAoKiBhcHBlYXIgd2hlbiBvbmUgY2hhcmFjdGVyIG9mIFtpbnB1dF0g4oiJIFthbHBoYWJldF0gYW5kIHRoaXMgY2hhcmFjdGVyIDw+ICc9JyAqKVxuICAgICAgICBlcnJvcl9tc2dmIFwiTWFsZm9ybWVkIGlucHV0XCJcbiAgICB8IGV4Y2VwdGlvbiBUb29fbXVjaF9pbnB1dCAtPiBlcnJvcl9tc2dmIFwiVG9vIG11Y2ggaW5wdXRcIlxuXG5sZXQgZGVjb2RlID9wYWQgPyhhbHBoYWJldCA9IGRlZmF1bHRfYWxwaGFiZXQpID9vZmYgP2xlbiBpbnB1dCA9XG4gIG1hdGNoIGRlY29kZV9zdWIgP3BhZCBhbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgd2l0aFxuICB8IE9rIChyZXMsIG9mZiwgbGVuKSAtPiBPayAoU3RyaW5nLnN1YiByZXMgb2ZmIGxlbilcbiAgfCBFcnJvciBfIGFzIGVyciAtPiBlcnJcblxubGV0IGRlY29kZV9zdWIgP3BhZCA/KGFscGhhYmV0ID0gZGVmYXVsdF9hbHBoYWJldCkgP29mZiA/bGVuIGlucHV0ID1cbiAgZGVjb2RlX3N1YiA/cGFkIGFscGhhYmV0ID9vZmYgP2xlbiBpbnB1dFxuXG5sZXQgZGVjb2RlX2V4biA/cGFkID9hbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgPVxuICBtYXRjaCBkZWNvZGUgP3BhZCA/YWxwaGFiZXQgP29mZiA/bGVuIGlucHV0IHdpdGhcbiAgfCBPayByZXMgLT4gcmVzXG4gIHwgRXJyb3IgKGBNc2cgZXJyKSAtPiBpbnZhbGlkX2FyZyBlcnJcbiJdLCJpZ25vcmVMaXN0IjpbMF19fV19
