// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Persistent_connection_kernel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Persistent_connection_kernel = [0];
   runtime.caml_register_global
    (0, Persistent_connection_kernel, "Persistent_connection_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel__Persistent_connection_kernel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern =
      "Persistent_connection_kernel__Persistent_connection_kernel_intf",
    cst_persistent_connection_kern = "persistent_connection_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern);
   caml_call1
    (Expect_test_collector[6][1],
     "persistent_connection_kernel/src/persistent_connection_kernel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[5],
     cst_persistent_connection_kern,
     "persistent_connection_kernel_intf.ml");
   caml_call1(Ppx_inline_test_lib[6], cst_persistent_connection_kern);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var Persistent_connection_kernel_P = [0];
   runtime.caml_register_global
    (11, Persistent_connection_kernel_P, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel
//# unitInfo: Requires: Async_kernel, Async_kernel__Deferred, Async_kernel__Deferred_or_error, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Time_source, Base__Exn, Base__Field, Base__Random, Bus, Core, Core__Error, Core__Fn, Core__Option, Core__Or_error, Core__Sexp, Core__Time_ns, Expect_test_collector, Persistent_connection_kernel__Persistent_connection_kernel_intf, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern = "Persistent_connection_kernel",
    cst_persistent_connection_kern$0 = "persistent_connection_kernel",
    cst_persistent_connection_kern =
      "persistent_connection_kernel/src/persistent_connection_kernel.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _a_ = [0, "<Conn.t>"],
    dummy_src_pos_that_shows_up_in =
      [0, cst_persistent_connection_kern, 8, 272, 315],
    Bus = global_data.Bus,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel = global_data.Async_kernel,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Random = global_data.Base__Random,
    Core = global_data.Core,
    Core_Fn = global_data.Core__Fn,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred_or_error =
      global_data.Async_kernel__Deferred_or_error,
    Core_Error = global_data.Core__Error,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern$0);
   caml_call1(Expect_test_collector[6][1], cst_persistent_connection_kern);
   caml_call2
    (Ppx_inline_test_lib[5],
     cst_persistent_connection_kern$0,
     "persistent_connection_kernel.ml");
   caml_call1(Ppx_inline_test_lib[6], cst_persistent_connection_kern$0);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var
    _b_ = [0, "Attempting_to_connect"],
    _c_ = [0, "Disconnected"],
    _d_ = [0, "Obtained_address"],
    _e_ = [0, "Failed_to_connect"],
    _f_ = [0, "Connected"],
    _g_ = [0, "on_event"],
    _h_ = [0, "server_name"],
    _i_ = [0, "sexp_of_address"],
    _j_ = [0, "address_equal"],
    _k_ = [0, "don't_reconnect"],
    _l_ = [0, "close_finished"],
    _m_ = [0, "close_started"],
    _n_ = [0, "event_bus"],
    _o_ = [0, "event_handler"],
    _p_ = [0, "next_connect_result"],
    _q_ = [0, "Close_started"],
    _r_ = [0, "Ok"],
    _s_ = [0, "conn"],
    _t_ = [0, "retry_delay"],
    _u_ = [0, "connect"],
    _v_ = [0, "get_address"],
    _w_ = [0, 0],
    _x_ = [0, -289386606, 0],
    _y_ = [0, -289386606, 0],
    _z_ = [0, -289386606, 0],
    _A_ = [0, -289386606, 0],
    _B_ = [0, 990972795, 0],
    _C_ = [0, cst_persistent_connection_kern, 196, 7038, 7119],
    cst_Persistent_connection_clos = "Persistent connection closed",
    Persistent_connection_kernel =
      [0,
       function(Conn){
        var close = Conn[1], is_closed = Conn[2], close_finished = Conn[3];
        function sexp_of_t(param){return _a_;}
        function sexp_of_t$0(of_address_001, param){
         if(typeof param === "number") return 0 === param ? _b_ : _c_;
         switch(param[0]){
           case 0:
            var
             arg0_002 = param[1],
             res0_003 = caml_call1(of_address_001, arg0_002);
            return [1, [0, _d_, [0, res0_003, 0]]];
           case 1:
            var
             arg0_004 = param[1],
             res0_005 = caml_call1(Core_Error[6], arg0_004);
            return [1, [0, _e_, [0, res0_005, 0]]];
           default:
            var
             arg0_006 = param[1],
             res0_007 = caml_call1(Sexplib0_Sexp_conv[23], arg0_006);
            return [1, [0, _f_, [0, res0_007, 0]]];
         }
        }
        function log_level(param){
         if(typeof param !== "number" && 1 === param[0]) return 106380200;
         return 815031438;
        }
        function handle_event(t, event){
         if(typeof event === "number")
          var _aF_ = 0 === event ? 0 : 1;
         else
          switch(event[0]){
            case 0:
             var _aF_ = _w_; break;
            case 1:
             var e = event[1], _aF_ = [1, e]; break;
            default: var conn = event[1], _aF_ = [2, conn];
          }
         caml_call2(Bus[12], t[7], _aF_);
         var on_event = t[6][2];
         return caml_call1(on_event, event);
        }
        function abort_reconnecting_with_no_act(t){
         caml_call2(Async_kernel_Ivar[14], t[8], 0);
         caml_call2(Async_kernel_Ivar[14], t[9], 0);
         return caml_call2(Async_kernel_Ivar[14], t[4], -400989606);
        }
        function current_connection(t){
         var
          _aE_ = caml_call1(Async_kernel_Ivar[18], t[4]),
          match = caml_call1(Async_kernel_Deferred[5], _aE_);
         if(match){
          var match$0 = match[1];
          if(typeof match$0 !== "number"){
           var conn = match$0[2];
           return [0, conn];
          }
         }
         return 0;
        }
        function close_finished$0(t){
         return caml_call1(Async_kernel_Ivar[18], t[9]);
        }
        function is_closed$0(t){
         return caml_call1(Async_kernel_Ivar[17], t[8]);
        }
        var
         _D_ =
           caml_call1(Sexplib0_Sexp_conv[7], cst_Persistent_connection_clos),
         connected_or_failed_to_connect = caml_call1(Core_Or_error[40], _D_);
        function sexp_of_t$1(param){
         var
          conn_023 = param[4],
          next_connect_result_026 = param[5],
          don_t_reconnect_036 = param[10],
          close_finished_034 = param[9],
          close_started_032 = param[8],
          event_bus_030 = param[7],
          event_handler_028 = param[6],
          arg_041 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_aD_){return 0;}),
          bnds_016 = [0, [1, [0, _i_, [0, arg_041, 0]]], 0],
          arg_039 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_aC_){return 0;}),
          bnds_016$0 = [0, [1, [0, _j_, [0, arg_039, 0]]], bnds_016],
          arg_037 =
            caml_call2(Async_kernel_Ivar[9], Core[534], don_t_reconnect_036),
          bnds_016$1 = [0, [1, [0, _k_, [0, arg_037, 0]]], bnds_016$0],
          arg_035 =
            caml_call2(Async_kernel_Ivar[9], Core[534], close_finished_034),
          bnds_016$2 = [0, [1, [0, _l_, [0, arg_035, 0]]], bnds_016$1],
          arg_033 =
            caml_call2(Async_kernel_Ivar[9], Core[534], close_started_032),
          bnds_016$3 = [0, [1, [0, _m_, [0, arg_033, 0]]], bnds_016$2],
          arg_031 =
            caml_call3
             (Bus[2],
              function(param){
               return caml_call1
                       (Sexplib0_Sexp_conv[24], function(_aB_){return 0;});
              },
              Core[207],
              event_bus_030),
          bnds_016$4 = [0, [1, [0, _n_, [0, arg_031, 0]]], bnds_016$3],
          server_name_011 = event_handler_028[1],
          arg_014 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_aA_){return 0;}),
          bnds_010 = [0, [1, [0, _g_, [0, arg_014, 0]]], 0],
          arg_012 = caml_call1(Core[484], server_name_011),
          bnds_010$0 = [0, [1, [0, _h_, [0, arg_012, 0]]], bnds_010],
          arg_029 = [1, bnds_010$0],
          bnds_016$5 = [0, [1, [0, _o_, [0, arg_029, 0]]], bnds_016$4],
          _aw_ = caml_call1(Core_Or_error[13], sexp_of_t),
          arg_027 =
            caml_call2(Async_kernel_Ivar[9], _aw_, next_connect_result_026),
          bnds_016$6 = [0, [1, [0, _p_, [0, arg_027, 0]]], bnds_016$5],
          arg_024 =
            caml_call2
             (Async_kernel_Ivar[9],
              function(param){
               return typeof param === "number"
                       ? _q_
                       : [1, [0, _r_, [0, _a_, 0]]];
              },
              conn_023),
          bnds_016$7 = [0, [1, [0, _s_, [0, arg_024, 0]]], bnds_016$6],
          arg_022 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_az_){return 0;}),
          bnds_016$8 = [0, [1, [0, _t_, [0, arg_022, 0]]], bnds_016$7],
          arg_020 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ay_){return 0;}),
          bnds_016$9 = [0, [1, [0, _u_, [0, arg_020, 0]]], bnds_016$8],
          arg_018 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ax_){return 0;}),
          bnds_016$10 = [0, [1, [0, _v_, [0, arg_018, 0]]], bnds_016$9];
         return [1, bnds_016$10];
        }
        function close_when_current_connection_(t){
         return caml_call2(Async_kernel_Ivar[15], t[10], 0);
        }
        function close_finished$1(param){return close_finished$0(param);}
        function is_closed$1(param){return is_closed$0(param);}
        function event_bus(param){return caml_call1(Bus[6], param[7]);}
        function close$0(t){
         if(caml_call1(Async_kernel_Ivar[17], t[8]))
          return close_finished$0(t);
         caml_call2(Async_kernel_Ivar[14], t[8], 0);
         var _at_ = caml_call1(Async_kernel_Ivar[18], t[4]);
         return caml_call2
                 (Async_kernel[20],
                  _at_,
                  function(conn_opt){
                   function _au_(param){
                    return caml_call2(Async_kernel_Ivar[14], t[9], 0);
                   }
                   if(typeof conn_opt === "number")
                    var _av_ = Async_kernel_Deferred[18];
                   else
                    var conn = conn_opt[2], _av_ = caml_call1(close, conn);
                   return caml_call2(Async_kernel[21], _av_, _au_);
                  });
        }
        function server_name(t){return t[6][1];}
        function current_connection$0(param){return current_connection(param);
        }
        function connected_or_failed_to_connect$0(t){
         if(is_closed$0(t))
          return caml_call1(Async_kernel[19], connected_or_failed_to_connect);
         var match = current_connection(t);
         if(match){
          var x = match[1];
          if(! caml_call1(is_closed, x))
           return caml_call1(Async_kernel[19], [0, x]);
         }
         var
          _ao_ = caml_call1(Async_kernel_Ivar[18], t[5]),
          _ap_ =
            [0,
             caml_call2(Async_kernel[4], _ao_, function(_as_){return _as_;}),
             0],
          _aq_ = caml_call1(Async_kernel_Ivar[18], t[8]),
          _ar_ =
            [0,
             caml_call2
              (Async_kernel[4],
               _aq_,
               function(param){return connected_or_failed_to_connect;}),
             _ap_];
         return caml_call1(Async_kernel_Deferred[29], _ar_);
        }
        function connected(t){
         function loop(param){
          var
           d = caml_call1(Async_kernel_Ivar[18], t[4]),
           match = caml_call1(Async_kernel_Deferred[5], d);
          if(! match)
           return caml_call2
                   (Async_kernel[20],
                    d,
                    function(param){
                     if(typeof param === "number")
                      return caml_call1(Async_kernel_Deferred[19], 0);
                     var conn = param[2];
                     return caml_call1(Async_kernel[19], conn);
                    });
          var match$0 = match[1];
          if(typeof match$0 === "number")
           return caml_call1(Async_kernel_Deferred[19], 0);
          var conn = match$0[2];
          if(! caml_call1(is_closed, conn))
           return caml_call1(Async_kernel[19], conn);
          var _an_ = caml_call1(close_finished, conn);
          return caml_call2(Async_kernel[20], _an_, loop);
         }
         return loop(0);
        }
        function create
        (server_name,
         on_event$0,
         retry_delay$0,
         random_state$1,
         time_source$0,
         connect,
         address,
         get_address){
         var
          on_event =
            on_event$0
             ? on_event$0[1]
             : function(param){return Async_kernel_Deferred[18];},
          random_state =
            random_state$1
             ? random_state$1[1]
             : [0, 389604849, Base_Random[18][1]],
          time_source =
            time_source$0
             ? time_source$0[1]
             : caml_call1(Async_kernel_Time_source[10], 0),
          event_handler = [0, server_name, on_event],
          _E_ = Core[542] ? 0.1 : 10.,
          _F_ = caml_call1(Core_Time_ns[1][81], _E_),
          default_retry_delay = caml_call1(Core_Fn[1], _F_),
          non_randomized_delay =
            caml_call2(Core_Option[35], retry_delay$0, default_retry_delay);
         if(typeof random_state === "number")
          var retry_delay_span = non_randomized_delay;
         else
          var
           random_state$0 = random_state[2],
           retry_delay_span =
             function(param){
              var
               span = caml_call1(non_randomized_delay, 0),
               span$0 = caml_call1(Core_Time_ns[1][88], span),
               distance =
                 caml_call2(Base_Random[18][10], random_state$0, span$0 * 0.3),
               wait =
                 caml_call1(Base_Random[18][16], random_state$0)
                  ? span$0 + distance
                  : span$0 - distance;
              return caml_call1(Core_Time_ns[1][81], wait);
             };
         function retry_delay(param){
          var _am_ = caml_call1(retry_delay_span, 0);
          return caml_call2(Async_kernel_Time_source[29], time_source, _am_);
         }
         var
          _G_ = address[2],
          _H_ = address[1],
          _I_ = caml_call1(Async_kernel_Ivar[12], 0),
          _J_ = caml_call1(Async_kernel_Ivar[12], 0),
          _K_ = caml_call1(Async_kernel_Ivar[12], 0);
         function _L_(_al_){return 0;}
         var
          _M_ = 1,
          _N_ = 0,
          _O_ = Core[542] ? dummy_src_pos_that_shows_up_in : _C_,
          _P_ = caml_call5(Bus[7], 0, _O_, _N_, _M_, _L_),
          _Q_ = caml_call1(Async_kernel_Ivar[12], 0),
          t =
            [0,
             get_address,
             connect,
             retry_delay,
             caml_call1(Async_kernel_Ivar[12], 0),
             _Q_,
             event_handler,
             _P_,
             _K_,
             _J_,
             _I_,
             _H_,
             _G_],
          _R_ =
            caml_call2
             (Async_kernel_Deferred[31],
              0,
              function(param){
               var _S_ = handle_event(t, 0);
               return caml_call2
                       (Async_kernel[22][2],
                        _S_,
                        function(param){
                         var previous_address = [0, 0], previous_error = [0, 0];
                         function connect(param){
                          var _ai_ = caml_call1(t[1], 0);
                          return caml_call2
                                  (Async_kernel[20],
                                   _ai_,
                                   function(param){
                                    if(0 !== param[0]){
                                     var e = param[1];
                                     return caml_call1(Async_kernel[19], [1, e]);
                                    }
                                    var addr = param[1], match = previous_address[1];
                                    if(match)
                                     var
                                      previous_address$0 = match[1],
                                      same_as_previous_address =
                                        caml_call2(t[11], addr, previous_address$0);
                                    else
                                     var same_as_previous_address = 0;
                                    previous_address[1] = [0, addr];
                                    function _aj_(param){return caml_call1(t[2], addr);}
                                    var
                                     _ak_ =
                                       same_as_previous_address
                                        ? Async_kernel_Deferred[18]
                                        : handle_event(t, [0, addr]);
                                    return caml_call2(Async_kernel[20], _ak_, _aj_);
                                   });
                         }
                         function loop(param){
                          if(caml_call1(Async_kernel_Ivar[17], t[8])){
                           caml_call2(Async_kernel_Ivar[14], t[4], -400989606);
                           return caml_call1(Async_kernel[19], -400989606);
                          }
                          if(caml_call1(Async_kernel_Ivar[17], t[10]))
                           return caml_call1(Async_kernel[19], -818917400);
                          var
                           ready_to_retry_connecting = caml_call1(t[3], 0),
                           ___ =
                             caml_call6
                              (Async_kernel_Deferred_or_error[39],
                               [0, Core[542]],
                               0,
                               0,
                               0,
                               0,
                               connect);
                          return caml_call2
                                  (Async_kernel[22][2],
                                   ___,
                                   function(connect_result){
                                    caml_call2(Async_kernel_Ivar[14], t[5], connect_result);
                                    t[5] = caml_call1(Async_kernel_Ivar[12], 0);
                                    if(0 === connect_result[0]){
                                     var conn = connect_result[1];
                                     caml_call2(Async_kernel_Ivar[14], t[4], [0, 17724, conn]);
                                     return caml_call1
                                             (Async_kernel[19],
                                              [0, 17724, [0, conn, ready_to_retry_connecting]]);
                                    }
                                    var err = connect_result[1], match = previous_error[1];
                                    if(match)
                                     var
                                      previous_err = match[1],
                                      to_sexp =
                                        function(e){
                                         var
                                          _ag_ = caml_call1(Core_Error[26], e),
                                          _ah_ = caml_call1(Async_kernel_Monitor[13], _ag_);
                                         return caml_call1(Base_Exn[1], _ah_);
                                        },
                                      _$_ = to_sexp(previous_err),
                                      _aa_ = to_sexp(err),
                                      same_as_previous_error =
                                        caml_call2(Core_Sexp[36], _aa_, _$_);
                                    else
                                     var same_as_previous_error = 0;
                                    previous_error[1] = [0, err];
                                    function _ab_(param){
                                     var
                                      _ad_ = [0, caml_call1(Async_kernel_Ivar[18], t[10]), 0],
                                      _ae_ =
                                        [0,
                                         ready_to_retry_connecting,
                                         [0, caml_call1(Async_kernel_Ivar[18], t[8]), _ad_]],
                                      _af_ = caml_call1(Async_kernel_Deferred[23], _ae_);
                                     return caml_call2
                                             (Async_kernel[20], _af_, function(param){return loop(0);});
                                    }
                                    var
                                     _ac_ =
                                       same_as_previous_error
                                        ? Async_kernel_Deferred[18]
                                        : handle_event(t, [1, err]);
                                    return caml_call2(Async_kernel[20], _ac_, _ab_);
                                   });
                         }
                         var _T_ = loop(0);
                         return caml_call2
                                 (Async_kernel[22][2],
                                  _T_,
                                  function(param){
                                   if(typeof param === "number")
                                    return -400989606 <= param
                                            ? caml_call1(Async_kernel[19], _x_)
                                            : (abort_reconnecting_with_no_act
                                               (t),
                                              caml_call1(Async_kernel[19], _y_));
                                   var
                                    match = param[2],
                                    ready_to_retry_connecting = match[2],
                                    conn = match[1],
                                    _U_ = handle_event(t, [2, conn]);
                                   return caml_call2
                                           (Async_kernel[22][2],
                                            _U_,
                                            function(param){
                                             var _V_ = caml_call1(close_finished, conn);
                                             return caml_call2
                                                     (Async_kernel[22][2],
                                                      _V_,
                                                      function(param){
                                                       t[4] = caml_call1(Async_kernel_Ivar[12], 0);
                                                       var _W_ = handle_event(t, 1);
                                                       return caml_call2
                                                               (Async_kernel[22][2],
                                                                _W_,
                                                                function(param){
                                                                 var
                                                                  _X_ = [0, caml_call1(Async_kernel_Ivar[18], t[10]), 0],
                                                                  _Y_ =
                                                                    [0,
                                                                     ready_to_retry_connecting,
                                                                     [0, caml_call1(Async_kernel_Ivar[18], t[8]), _X_]],
                                                                  _Z_ = caml_call1(Async_kernel_Deferred[23], _Y_);
                                                                 return caml_call2
                                                                         (Async_kernel[22][3],
                                                                          _Z_,
                                                                          function(param){
                                                                           return caml_call1(Async_kernel_Ivar[17], t[8])
                                                                                   ? (caml_call2(Async_kernel_Ivar[14], t[4], -400989606), _z_)
                                                                                   : caml_call1
                                                                                      (Async_kernel_Ivar[17], t[10])
                                                                                     ? (abort_reconnecting_with_no_act(t), _A_)
                                                                                     : _B_;
                                                                          });
                                                                });
                                                      });
                                            });
                                  });
                        });
              });
         caml_call1(Async_kernel[6], _R_);
         return t;
        }
        return [0,
                sexp_of_t$1,
                [0, sexp_of_t$0, log_level],
                create,
                connected,
                event_bus,
                connected_or_failed_to_connect$0,
                current_connection$0,
                server_name,
                close$0,
                is_closed$1,
                close_finished$1,
                close_when_current_connection_];
       }];
   runtime.caml_register_global
    (76, Persistent_connection_kernel, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbC5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiUGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsK0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfUGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm4iLCJjc3RfcGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm4iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiUGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbF9QIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FzeW5jX2tlcm5lbC9wZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsL3BlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWxfaW50Zi5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxHQ0lBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FvSUc7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxpQ0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEeElIIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiogQW4gYWN0aXZlbHkgbWFpbnRhaW5lZCBjb25uZWN0aW9uIHRvIHNvbWUgc2VydmljZSB0aGF0IGVhZ2VybHkgYW5kIHJlcGVhdGVkbHkgYXR0ZW1wdHNcbiAgICB0byByZWNvbm5lY3Qgd2hlbmV2ZXIgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBpcyBsb3N0LCB1bnRpbCBhIG5ldyBvbmUgY2FuIGJlXG4gICAgZXN0YWJsaXNoZWQuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEFzeW5jX2tlcm5lbFxuXG4oKiogVGhlIGFkZHJlc3Mgb2YgYSBzZXJ2aWNlIHRvIHdoaWNoIG9uZSBjYW4gY29ubmVjdC4gRS5nLiBbSG9zdF9hbmRfcG9ydC50XSBpcyBhXG4gICAgcmVhc29uYWJsZSBjaG9pY2Ugd2hlbiBtYWtpbmcgYSBUQ1AgY29ubmVjdGlvbi5cbiopXG5tb2R1bGUgdHlwZSBBZGRyZXNzID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBlcXVhbCwgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDbG9zYWJsZSA9IHNpZ1xuICAoKiogYSBjb25uZWN0aW9uIHR5cGUgKilcbiAgdHlwZSB0XG5cbiAgKCoqIFtjbG9zZSB0XSBjbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSByZXR1cm5lZCBkZWZlcnJlZCBiZWNvbWVzIGRldGVybWluZWQgb25jZSBhbnlcbiAgICAgIHJlc291cmNlcyBuZWVkZWQgdG8gbWFpbnRhaW4gdGhlIGNvbm5lY3Rpb24gaGF2ZSBiZWVuIHJlbGVhc2VkLiAqKVxuICB2YWwgY2xvc2UgOiB0IC0+IHVuaXQgRGVmZXJyZWQudFxuXG4gICgqKiBbaXNfY2xvc2VkIHRdIHJldHVybnMgdHJ1ZSBpZiBbY2xvc2VdIGhhcyBldmVyIGJlZW4gY2FsbGVkIChldmVuIGlmIHRoZSByZXR1cm5lZFxuICAgICAgZGVmZXJyZWQgaGFzIG5vdCB5ZXQgYmVlbiBmdWxmaWxsZWQpLlxuXG4gICAgICBOb3RlIHRoYXQgc29tZSBtb2R1bGVzIGltcGxlbWVudGluZyBbQ2xvc2FibGVdIG1heSBjYWxsIGNsb3NlIGludGVybmFsbHkgdXBvblxuICAgICAgbm90aWNpbmcgdGhhdCB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJ5IHRoZSBvdGhlciBzaWRlLiBUaGUgaW50ZXJmYWNlIG9mIHN1Y2ggYVxuICAgICAgbW9kdWxlIG91Z2h0IHRvIHNheSB0aGF0IHRoaXMgaXMgdGhlIGNhc2UuICopXG4gIHZhbCBpc19jbG9zZWQgOiB0IC0+IGJvb2xcblxuICAoKiogW2Nsb3NlX2ZpbmlzaGVkIHRdIGJlY29tZXMgZGV0ZXJtaW5lZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0XG4gICAgICBjYWxsIHRvIFtjbG9zZV0uIFtjbG9zZV9maW5pc2hlZF0gZGlmZmVycyBmcm9tIFtjbG9zZV0gaW4gdGhhdCBpdCBkb2VzIG5vdCBoYXZlIHRoZVxuICAgICAgc2lkZSBlZmZlY3Qgb2YgaW5pdGlhdGluZyBhIGNsb3NlLiAqKVxuICB2YWwgY2xvc2VfZmluaXNoZWQgOiB0IC0+IHVuaXQgRGVmZXJyZWQudFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgKCoqIEEgY29ubmVjdGlvbiwgcGVyaGFwcyBlbWJlbGxpc2hlZCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdXBvbiBjb25uZWN0aW9uLiAqKVxuICB0eXBlIGNvbm5cblxuICBtb2R1bGUgRXZlbnQgOiBzaWdcbiAgICB0eXBlICdhZGRyZXNzIHQgPVxuICAgICAgfCBBdHRlbXB0aW5nX3RvX2Nvbm5lY3RcbiAgICAgIHwgT2J0YWluZWRfYWRkcmVzcyBvZiAnYWRkcmVzc1xuICAgICAgfCBGYWlsZWRfdG9fY29ubmVjdCBvZiBFcnJvci50XG4gICAgICB8IENvbm5lY3RlZCBvZiBjb25uXG4gICAgICB8IERpc2Nvbm5lY3RlZFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgbG9nX2xldmVsIDogXyB0IC0+IFsgYEluZm8gfCBgRGVidWcgfCBgRXJyb3IgXVxuICBlbmRcblxuICAoKiogW2NyZWF0ZSB+c2VydmVyX25hbWUgfm9uX2V2ZW50IH5yZXRyeV9kZWxheSBnZXRfYWRkcmVzc10gcmV0dXJucyBhIHBlcnNpc3RlbnRcbiAgICAgIGNvbm5lY3Rpb24gdG8gYSBzZXJ2ZXIgd2hvc2UgaG9zdCBhbmQgcG9ydCBhcmUgb2J0YWluZWQgdmlhIFtnZXRfYWRkcmVzc10gZXZlcnkgdGltZVxuICAgICAgd2UgdHJ5IHRvIGNvbm5lY3QuIEZvciBleGFtcGxlLCBbZ2V0X2FkZHJlc3NdIG1pZ2h0IGxvb2sgdXAgYSBzZXJ2ZXIncyBob3N0IGFuZCBwb3J0XG4gICAgICBpbiBjYXRhbG9nIGF0IGEgcGFydGljdWxhciBwYXRoIHRvIHdoaWNoIG11bHRpcGxlIHJlZHVuZGFudCBjb3BpZXMgb2YgYSBzZXJ2aWNlIGFyZVxuICAgICAgcHVibGlzaGluZyB0aGVpciBsb2NhdGlvbi4gSWYgb25lIGNvcHkgZGllcywgd2UgZ2V0IHRoZSBhZGRyZXNzIG9mIHRoZSBhbm90aGVyIG9uZVxuICAgICAgd2hlbiBsb29raW5nIHVwIHRoZSBhZGRyZXNzIGFmdGVyd2FyZHMuXG5cbiAgICAgIEFsbCBjb25uZWN0aW9uIGV2ZW50cyAoc2VlIHRoZSB0eXBlIGFib3ZlKSBhcmUgcGFzc2VkIHRvIHRoZSBbb25fZXZlbnRdIGNhbGxiYWNrLCBpZlxuICAgICAgZ2l2ZW4uIFdoZW4gdGhpcyBjYWxsYmFjayBiZWNvbWVzIGRldGVybWluZWQsIHdlIG1vdmUgb24gdG8gdGhlIG5leHQgc3RlcCBpbiBvdXJcbiAgICAgIGNvbm5lY3Rpb24gYXR0ZW1wdCAoZS5nLiB3ZSB3b24ndCBhY3R1YWxseSBhdHRlbXB0IHRvIGNvbm5lY3QgdW50aWwgW29uX2V2ZW50XG4gICAgICBBdHRlbXB0aW5nX3RvX2Nvbm5lY3RdIGlzIGZpbmlzaGVkKS4gTm90ZSB0aGF0IFtvbl9ldmVudCBEaXNjb25uZWN0ZWRdIHdpbGwgb25seSBiZVxuICAgICAgY2FsbGVkIG9uY2UgW29uX2V2ZW50IChDb25uZWN0ZWQgY29ubildIGZpbmlzaGVzIGV2ZW4gaWYgdGhlIGNvbm5lY3Rpb24gZ29lcyBkb3duXG4gICAgICBkdXJpbmcgdGhhdCBjYWxsYmFjay5cblxuICAgICAgW2BGYWlsZWRfdG9fY29ubmVjdCBlcnJvcl0gYW5kIFtgT2J0YWluZWRfYWRkcmVzcyBhZGRyXSBldmVudHMgYXJlIG9ubHkgcmVwb3J0ZWQgaWZcbiAgICAgIHRoZXkgYXJlIGRpc3RpbmN0IGZyb20gdGhlIG1vc3QgcmVjZW50IGV2ZW50IG9mIHRoZSBzYW1lIHR5cGUgdGhhdCBoYXMgdGFrZW4gcGxhY2VcbiAgICAgIHNpbmNlIHRoZSBtb3N0IHJlY2VudCBbYEF0dGVtcHRpbmdfdG9fY29ubmVjdF0gZXZlbnQuXG5cbiAgICAgIENvbm5lY3Rpb24gaXMgYnkgZGVmYXVsdCByZXRyaWVkIGFmdGVyIFtUaW1lLlNwYW4ucmFuZG9taXplXG4gICAgICB+cGVyY2VudDooUGVyY2VudC5vZl9tdWx0IDAuMykgKHJldHJ5X2RlbGF5ICgpKV0uIFRoZSBkZWZhdWx0IGZvciBbcmV0cnlfZGVsYXldIGlzXG4gICAgICBbY29uc3QgKHNlYyAxMC4pXS4gTm90ZSB0aGF0IHdoYXQgdGhpcyByZXRyeSBkZWxheSBhY3R1YWxseSB0aHJvdHRsZXMgaXMgdGhlIGRlbGF5XG4gICAgICBiZXR3ZWVuIHR3byBjb25uZWN0aW9uIGF0dGVtcHRzLCBzbyB3aGVuIGEgbG9uZy1saXZlZCBjb25uZWN0aW9uIGRpZXMsIGNvbm5lY3Rpb24gaXNcbiAgICAgIHVzdWFsbHkgaW1tZWRpYXRlbHkgcmV0cmllZCwgYW5kIGlmIHRoYXQgZmFpbGVkLCB3YWl0IGZvciBhbm90aGVyIHJldHJ5IGRlbGF5IGFuZFxuICAgICAgcmV0cnkuXG5cbiAgICAgIFRoZSBbcmFuZG9tX3N0YXRlXSBhbmQgW3RpbWVfc291cmNlXSBhcmd1bWVudHMgYXJlIHRoZXJlIHRvIG1ha2UgcGVyc2lzdGVudFxuICAgICAgY29ubmVjdGlvbiBjb2RlIG1vcmUgZGV0ZXJtaW5pc3RpY2FsbHkgdGVzdGFibGUuIFRoZXkgZGVmYXVsdCB0b1xuICAgICAgW2BTdGF0ZSBSYW5kb20uU3RhdGUuZGVmYXVsdF0gYW5kIFtUaW1lX3NvdXJjZS53YWxsX2Nsb2NrICgpXSwgcmVzcGVjdGl2ZWx5LlxuICAgICAgSWYgcmFuZG9tX3N0YXRlIGlzIHNldCB0byBbYE5vbl9yYW5kb21dLCByZXRyeV9kZWxheSB3aWxsIGJlIHVzZWQgZGlyZWN0bHkuXG4gICopXG4gIHZhbCBjcmVhdGVcbiAgICA6ICBzZXJ2ZXJfbmFtZTpzdHJpbmdcbiAgICAtPiA/b25fZXZlbnQ6KCdhZGRyZXNzIEV2ZW50LnQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+ID9yZXRyeV9kZWxheToodW5pdCAtPiBUaW1lX25zLlNwYW4udClcbiAgICAtPiA/cmFuZG9tX3N0YXRlOlsgYE5vbl9yYW5kb20gfCBgU3RhdGUgb2YgUmFuZG9tLlN0YXRlLnQgXVxuICAgIC0+ID90aW1lX3NvdXJjZTpUaW1lX3NvdXJjZS50XG4gICAgLT4gY29ubmVjdDooJ2FkZHJlc3MgLT4gY29ubiBPcl9lcnJvci50IERlZmVycmVkLnQpXG4gICAgLT4gYWRkcmVzczoobW9kdWxlIEFkZHJlc3Mgd2l0aCB0eXBlIHQgPSAnYWRkcmVzcylcbiAgICAtPiAodW5pdCAtPiAnYWRkcmVzcyBPcl9lcnJvci50IERlZmVycmVkLnQpXG4gICAgLT4gdFxuXG4gICgqKiBbY29ubmVjdGVkXSByZXR1cm5zIHRoZSBmaXJzdCBhdmFpbGFibGUgY29ubmVjdGlvbiBmcm9tIHRoZSB0aW1lIGl0IGlzIGNhbGxlZC4gV2hlblxuICAgICAgY3VycmVudGx5IGNvbm5lY3RlZCwgdGhlIHJldHVybmVkIGRlZmVycmVkIGlzIGFscmVhZHkgZGV0ZXJtaW5lZC4gSWYgW2Nsb3NlZF0gaGFzXG4gICAgICBiZWVuIGNhbGxlZCwgdGhlbiB0aGUgcmV0dXJuZWQgZGVmZXJyZWQgaXMgbmV2ZXIgZGV0ZXJtaW5lZC4gKilcbiAgdmFsIGNvbm5lY3RlZCA6IHQgLT4gY29ubiBEZWZlcnJlZC50XG5cbiAgKCoqIFtldmVudF0gcmV0dXJucyBhIGJ1cyB3aGljaCBpcyB3cml0dGVuIHRvIHdoZW5ldmVyIGFuIGV2ZW50IGhhcHBlbnMuXG4gICAgICBTaW5jZSB0aGUgWydhZGRyZXNzXSB1c2VkIGluIGNyZWF0ZSBpcyBub3QgZXhwb3NlZCBhcyBhIHBhcmFtZXRlciBvZiB0aGVcbiAgICAgIFt0XSB0eXBlLCB3ZSByZXBsYWNlIGl0IHdpdGggKCkuICopXG4gIHZhbCBldmVudF9idXMgOiB0IC0+ICh1bml0IEV2ZW50LnQgLT4gdW5pdCkgQnVzLlJlYWRfb25seS50XG5cbiAgKCoqIFtjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3RdIGlzIGltbWVkaWF0ZWx5IGRldGVybWluZWQgYXMgW09rIF9dIGlmIFt0XSBpc1xuICAgICAgYWxyZWFkeSBjb25uZWN0ZWQuIE90aGVyd2lzZSBpdCBiZWNvbWVzIGRldGVybWluZWQgdGhlIG5leHQgdGltZSBbdF0gYmVjb21lc1xuICAgICAgY29ubmVjdGVkIG9yIGZhaWxzIHRvIGNvbm5lY3Qgb3Igd2hlbiBbdF0gaXMgY2xvc2VkLiAqKVxuICB2YWwgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0IDogdCAtPiBjb25uIE9yX2Vycm9yLnQgRGVmZXJyZWQudFxuXG4gICgqKiBUaGUgY3VycmVudCBjb25uZWN0aW9uLCBpZiBhbnkuICopXG4gIHZhbCBjdXJyZW50X2Nvbm5lY3Rpb24gOiB0IC0+IGNvbm4gb3B0aW9uXG5cbiAgdmFsIHNlcnZlcl9uYW1lIDogdCAtPiBzdHJpbmdcblxuICAoKiogW2Nsb3NlIHRdIGNsb3NlcyB0aGUgY3VycmVudCBjb25uZWN0aW9uIGFuZCBzdG9wcyBpdCBmcm9tIHRyeWluZyB0byByZWNvbm5lY3QuIEFmdGVyXG4gICAgICB0aGUgZGVmZXJyZWQgaXQgcmV0dXJucyBiZWNvbWVzIGRldGVybWluZWQsIHRoZSBsYXN0IGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkIGFuZFxuICAgICAgbm8gb3RoZXJzIHdpbGwgYmUgYXR0ZW1wdGVkLlxuXG4gICAgICBOb3RlOiBubyBbY2xvc2VdIGNhbGxzIGFyZSBldmVyIGdlbmVyYXRlZCBpbnRlcm5hbGx5IGluIHJlc3BvbnNlIHRvIHRoZSBjb25uZWN0aW9uXG4gICAgICBiZWluZyBjbG9zZWQgYnkgdGhlIG90aGVyIHNpZGUuXG4gICopXG4gIGluY2x1ZGUgQ2xvc2FibGUgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICgqKiBbY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25faXNfY2xvc2VkIHRdIGNhdXNlcyB0aGUgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIG5vdFxuICAgICAgcmVjb25uZWN0IGlmIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gY2xvc2VzIG9yIGlmIGl0IGlzIG5vdCBjdXJyZW50bHkgY29ubmVjdGVkLiBJdFxuICAgICAgZG9lcyBub3QgY2xvc2UgYW55IGFjdGl2ZSBjb25uZWN0aW9uLiAqKVxuICB2YWwgY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25faXNfY2xvc2VkIDogdCAtPiB1bml0XG5lbmRcblxubW9kdWxlIHR5cGUgUGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbCA9IHNpZ1xuICBtb2R1bGUgdHlwZSBBZGRyZXNzID0gQWRkcmVzc1xuICBtb2R1bGUgdHlwZSBDbG9zYWJsZSA9IENsb3NhYmxlXG4gIG1vZHVsZSB0eXBlIFMgPSBTXG5cbiAgbW9kdWxlIE1ha2UgKENvbm4gOiBDbG9zYWJsZSkgOiBTIHdpdGggdHlwZSBjb25uID0gQ29ubi50XG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo2OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfUGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm4iLCJjc3RfcGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm4iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNSIsImEzIiwiYTQiLCJjYW1sX2NhbGw2IiwiYTUiLCJnbG9iYWxfZGF0YSIsImR1bW15X3NyY19wb3NfdGhhdF9zaG93c191cF9pbiIsIkJ1cyIsIkFzeW5jX2tlcm5lbF9JdmFyIiwiQXN5bmNfa2VybmVsIiwiQXN5bmNfa2VybmVsX0RlZmVycmVkIiwiQXN5bmNfa2VybmVsX1RpbWVfc291cmNlIiwiQ29yZV9UaW1lX25zIiwiQmFzZV9SYW5kb20iLCJDb3JlIiwiQ29yZV9GbiIsIkNvcmVfT3B0aW9uIiwiQXN5bmNfa2VybmVsX0RlZmVycmVkX29yX2Vycm9yIiwiQ29yZV9FcnJvciIsIkFzeW5jX2tlcm5lbF9Nb25pdG9yIiwiQmFzZV9FeG4iLCJDb3JlX1NleHAiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJDb3JlX09yX2Vycm9yIiwiUHB4X21vZHVsZV90aW1lcl9ydW50aW1lIiwiUHB4X2JlbmNoX2xpYl9CZW5jaG1hcmtfYWNjdW11IiwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yIiwiUHB4X2lubGluZV90ZXN0X2xpYiIsImNzdF9QZXJzaXN0ZW50X2Nvbm5lY3Rpb25fY2xvcyIsIlBlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWwiLCJDb25uIiwiY2xvc2UiLCJpc19jbG9zZWQiLCJjbG9zZV9maW5pc2hlZCIsInNleHBfb2ZfdCIsInBhcmFtIiwib2ZfYWRkcmVzc18wMDEiLCJhcmcwXzAwMiIsInJlczBfMDAzIiwiYXJnMF8wMDQiLCJyZXMwXzAwNSIsImFyZzBfMDA2IiwicmVzMF8wMDciLCJsb2dfbGV2ZWwiLCJoYW5kbGVfZXZlbnQiLCJ0IiwiZXZlbnQiLCJlIiwiY29ubiIsIm9uX2V2ZW50IiwiYWJvcnRfcmVjb25uZWN0aW5nX3dpdGhfbm9fYWN0IiwiY3VycmVudF9jb25uZWN0aW9uIiwibWF0Y2giLCJjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3QiLCJjb25uXzAyMyIsIm5leHRfY29ubmVjdF9yZXN1bHRfMDI2IiwiZG9uX3RfcmVjb25uZWN0XzAzNiIsImNsb3NlX2ZpbmlzaGVkXzAzNCIsImNsb3NlX3N0YXJ0ZWRfMDMyIiwiZXZlbnRfYnVzXzAzMCIsImV2ZW50X2hhbmRsZXJfMDI4IiwiYXJnXzA0MSIsImJuZHNfMDE2IiwiYXJnXzAzOSIsImFyZ18wMzciLCJhcmdfMDM1IiwiYXJnXzAzMyIsImFyZ18wMzEiLCJzZXJ2ZXJfbmFtZV8wMTEiLCJhcmdfMDE0IiwiYm5kc18wMTAiLCJhcmdfMDEyIiwiYXJnXzAyOSIsImFyZ18wMjciLCJhcmdfMDI0IiwiYXJnXzAyMiIsImFyZ18wMjAiLCJhcmdfMDE4IiwiY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25fIiwiZXZlbnRfYnVzIiwiY29ubl9vcHQiLCJzZXJ2ZXJfbmFtZSIsIngiLCJjb25uZWN0ZWQiLCJsb29wIiwiZCIsImNyZWF0ZSIsInJldHJ5X2RlbGF5IiwicmFuZG9tX3N0YXRlIiwidGltZV9zb3VyY2UiLCJjb25uZWN0IiwiYWRkcmVzcyIsImdldF9hZGRyZXNzIiwiZXZlbnRfaGFuZGxlciIsImRlZmF1bHRfcmV0cnlfZGVsYXkiLCJub25fcmFuZG9taXplZF9kZWxheSIsInJldHJ5X2RlbGF5X3NwYW4iLCJzcGFuIiwiZGlzdGFuY2UiLCJ3YWl0IiwicHJldmlvdXNfYWRkcmVzcyIsInByZXZpb3VzX2Vycm9yIiwiYWRkciIsInNhbWVfYXNfcHJldmlvdXNfYWRkcmVzcyIsInJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmciLCJjb25uZWN0X3Jlc3VsdCIsImVyciIsInByZXZpb3VzX2VyciIsInRvX3NleHAiLCJzYW1lX2FzX3ByZXZpb3VzX2Vycm9yIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FzeW5jX2tlcm5lbC9wZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsL3BlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWwubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxtQ0FBQTtBQUFBLElBQUFBO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVQsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxHQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQW1YRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxnQkFBQUM7QUFBQUEsWUFBQUMsUURuWEgsU0FBQUMsWUFBQSxTQUFBQyxpQkFBQTtBQUFBLGlCQUFBQyxVQUFBQyxPQ2FxQyxXQUFlO0FBQUEsaUJBQUFELFlBQUFFLGdCQUFBRDtBQUFBQSxTQU1oRCw0REFNb0I7QUFBQSxTQU5wQjtBQUFBO0FBQUE7QUFBQSxhQUFBRSxXQUFBO0FBQUEsYUFBQUMsV0FFRTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUFDLFdBRkY7QUFBQSxhQUFBQyxXQUdFO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQUMsV0FIRjtBQUFBLGFBQUFDLFdBSUU7QUFBQTtBQUFBO0FBQUEsUUFFa0I7QUFBQSxpQkFBQUMsVUFBQVI7QUFBQUEsU0FZSixnREFFVztBQUFBLFNBRG9EO0FBQUEsUUFDOUM7QUFBQSxpQkFBQVMsYUFBQUMsR0FBQUM7QUFBQUEsU0E0Qi9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx3QkFHdUM7QUFBQTtBQUFBLGlCQUFBQyxJQUh2QyxpQkFLNEI7QUFBQSx5QkFBQUMsT0FMNUIsaUJBTXVCO0FBQUE7QUFBQSxTQU52QjtBQUFBLGFBQUFDLFdBekJTO0FBQUEsU0FBMEMsa0NBaUNqQjtBQUFBO0FBQUEsaUJBQUFDLCtCQUFBTDtBQUFBQSxTQStFbEM7QUFBQSxTQUNBO0FBQUEsU0FBNkIsMERBQ0U7QUFBQTtBQUFBLGlCQUFBTSxtQkFBQU47QUFBQUE7QUFBQUEsVUFBQSxPQW1JWDtBQUFBLFVBQUFPLFFBQWQ7QUFBQSxTQUFnQztBQUFBLGNBQUFBLFVBQUE7QUFBQTtBQUFBLGVBQUFKLE9BQUE7QUFBQSxXQUVqQjtBQUFBO0FBQUE7QUFBQSxTQURXO0FBQUEsUUFDRjtBQUFBLGlCQUFBZixpQkFBQVk7QUFBQUEsU0FHVCw4Q0FBMEI7QUFBQTtBQUFBLGlCQUFBYixZQUFBYTtBQUFBQSxTQUMvQiw4Q0FBNEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQWtCakI7QUFBQSxTQUFBUSxpQ0FBM0I7QUFBQSxpQkFBQW5CLFlBQUFDO0FBQUFBO0FBQUFBLFVBQUFtQixXQXZRRjtBQUFBLFVBQUFDLDBCQUFBO0FBQUEsVUFBQUMsc0JBQUE7QUFBQSxVQUFBQyxxQkFBQTtBQUFBLFVBQUFDLG9CQUFBO0FBQUEsVUFBQUMsZ0JBQUE7QUFBQSxVQUFBQyxvQkFBQTtBQUFBLFVBQUFDO0FBQUFBLFlBWXNCLGtERDVEMUI7QUFBQSxVQUFBQyxXQzREUTtBQUFBLFVBQUFDO0FBQUFBLFlBRGdCLGtERDNEeEI7QUFBQSxVQUFBRCxhQzJEUTtBQUFBLFVBQUFFO0FBQUFBLFlBREE7QUFBQSxVQUFBRixhQUFBO0FBQUEsVUFBQUc7QUFBQUEsWUFEQTtBQUFBLFVBQUFILGFBQUE7QUFBQSxVQUFBSTtBQUFBQSxZQURBO0FBQUEsVUFBQUosYUFBQTtBQUFBLFVBQUFLO0FBQUFBLFlBREE7QUFBQTtBQUFBLHVCQUFBaEM7QUFBQUEsZUFBYTtBQUFBLCtERHZEckIsV0N1RHlDO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBQTJCLGFBQWpDO0FBQUEsVUFBQU0sa0JBekJGO0FBQUEsVUFBQUM7QUFBQUEsWUFFZSxrRERoQ3JCO0FBQUEsVUFBQUMsV0NnQ1U7QUFBQSxVQUFBQyxVQURBO0FBQUEsVUFBQUQsYUFBQTtBQUFBLFVBQUFFLFVBREo7QUFBQSxVQUFBVixhQXdCRTtBQUFBLGlCQUQ4QjtBQUFBLFVBQUFXO0FBQUFBLFlBQXRCO0FBQUEsVUFBQVgsYUFBQTtBQUFBLFVBQUFZO0FBQUFBLFlBREE7QUFBQTtBQUFBLHVCQUFBdkM7QUFBQUEsZUFBTztBQUFBO0FBQUEsbURBQXlDO0FBQUE7QUFBQTtBQUFBLFVBQUEyQixhQUFoRDtBQUFBLFVBQUFhO0FBQUFBLFlBRE0sa0REbkR0QjtBQUFBLFVBQUFiLGFDbURRO0FBQUEsVUFBQWM7QUFBQUEsWUFEVSxrRERsRGxCO0FBQUEsVUFBQWQsYUNrRFE7QUFBQSxVQUFBZTtBQUFBQSxZQURjLGtERGpEdEI7QUFBQSxVQUFBZixjQ2lEUTtBQUFBLFNBREo7QUFBQSxRQStSc0Q7QUFBQSxpQkFBQWdCLCtCQUFBakM7QUFBQUEsU0FOcEQsa0RBUzRDO0FBQUE7QUFBQSxpQkFBQVosaUJBQUFFLE9BR3JCLDhCQUFxQjtBQUFBLGlCQUFBSCxZQUFBRyxPQUMxQix5QkFBZ0I7QUFBQSxpQkFBQTRDLFVBQUE1QyxPQUNoQixtQ0FBeUI7QUFBQSxpQkFBQUosUUFBQWM7QUFBQUEsU0EvQ3hDO0FBQUEsVUFHRCwwQkE2Q3dCO0FBQUEsU0EzQ3hCO0FBQUEsb0JBQ0E7QUFBQSxTQUFnQjtBQUFBO0FBQUE7QUFBQSwyQkFBQW1DO0FBQUFBLDRCQUFBLEtBQUE3QztBQUFBQSxvQkFLRixpREFBNkI7QUFBQTtBQUFBLG1CQUgzQztBQUFBLCtCQUNxQjtBQUFBO0FBQUEsd0JBQUFhLE9BRHJCLG9CQUVlO0FBQUEsbUJBRmYsK0NBRzJDO0FBQUEsb0JBcUNuQjtBQUFBO0FBQUEsaUJBQUFpQyxZQUFBcEMsR0F4UlIsZUF5Um9CO0FBQUEsaUJBQUFNLHFCQUFBaEIsT0FDWCxnQ0FBeUI7QUFBQTtBQUFBLGlCQUFBa0IsaUNBQUFSO0FBQUFBLFNBL0JqRDtBQUFBLFVBQ0UsbUVBK0J1RTtBQUFBLGFBQUFPLFFBN0JwRTtBQUFBLFNBQW9CO0FBQUEsY0FBQThCLElBQUE7QUFBQSxVQUNSO0FBQUEsV0FBc0IsMkNBNEJrQztBQUFBO0FBQUE7QUFBQSxpQkF2QjdEO0FBQUE7QUFBQSxZQUFQO0FBQUEsOEREcFVkO0FBQUE7QUFBQSxpQkNrVXFCO0FBQUE7QUFBQSxZQUFQO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0JBQUEvQyxPQUNFLHNDQUFnRDtBQUFBO0FBQUEsU0FBQyxrREF3QmlCO0FBQUE7QUFBQSxpQkFBQWdELFVBQUF0QztBQUFBQSxrQkFBQXVDLEtBQUFqRDtBQUFBQTtBQUFBQSxXQUFBa0QsSUEvRWxFO0FBQUEsV0FBQWpDLFFBQ0Y7QUFBQSxVQUFlO0FBQUEsV0FFbkI7QUFBQTtBQUFBO0FBQUEsNkJBQUFqQjtBQUFBQSxxQkFDSTtBQUFBLHNCQUNrQiwrQ0FDTTtBQUFBLHlCQUFBYSxPQUZ4QjtBQUFBLHFCQUVZLHlDQUFZO0FBQUEsc0JBT1o7QUFBQSxjQUFBSSxVQVpHO0FBQUE7QUFBQSxXQU1JLCtDQU1QO0FBQUEsY0FBQUosT0FaRztBQUFBLFVBUWhCO0FBQUEsV0FJRSx5Q0FBVztBQUFBLHFCQURkO0FBQUEsVUFBd0IsK0NBQ1Y7QUFBQTtBQUFBLFNBRXBCLGNBaUVrQztBQUFBO0FBQUEsaUJBQUFzQztBQUFBQSxTQUFBTDtBQUFBQSxTQUFBaEM7QUFBQUEsU0FBQXNDO0FBQUFBLFNBQUFDO0FBQUFBLFNBQUFDO0FBQUFBLFNBQUFDO0FBQUFBLFNBQUFDO0FBQUFBLFNBQUFDO0FBQUFBO0FBQUFBLFVBQUEzQztBQUFBQSxZQTVMOUI7QUFBQTtBQUFBLHdCQUFBZCxPQUVzQixpQ0FBYTtBQUFBLFVBQUFxRDtBQUFBQSxZQUZuQztBQUFBO0FBQUE7QUFBQSxVQUFBQztBQUFBQSxZQUFBO0FBQUE7QUFBQSxlQUtnQjtBQUFBLFVBQUFJLGdCQUtwQjtBQUFBLGdCQUNBO0FBQUEsZ0JBQ1c7QUFBQSxVQUFBQyxzQkFBVDtBQUFBLFVBQUFDO0FBQUFBLFlBRXlCO0FBQUEsU0FDM0I7QUFBQSxjQUFBQyxtQkFFbUI7QUFBQTtBQUFBO0FBQUEsV0FBQVIsaUJBRm5CO0FBQUEsV0FBQVE7QUFBQUEsYUFJSSxTQUFBN0Q7QUFBQUE7QUFBQUEsZUFBQThELE9BQ2E7QUFBQSxlQUFBQSxTQUNBO0FBQUEsZUFBQUM7QUFBQUEsaUJBQ0k7QUFBQSxlQUFBQztBQUFBQSxpQkFFVjtBQUFBO0FBQUE7QUFBQSxjQUlMLDRDQUF3QjtBQUFBO0FBQUEsa0JBQUFaLFlBQUFwRDtBQUFBQSxjQUFBLE9BRXFCO0FBQUEsVUFBcUI7QUFBQTtBQUFBO0FBQUEsZ0JBZ0JsRDtBQUFBO0FBQUE7QUFBQSxnQkFERDtBQUFBLGdCQUREO0FBQUEsNEJENU0xQjtBQUFBO0FBQUEsZ0JDNE13QztBQUFBO0FBQUE7QUFBQSxnQkFWNUI7QUFBQSxnQkFPb0I7QUFBQSxVQUFBVTtBQUFBQSxZQUVmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQVdSO0FBQUE7QUFBQTtBQUFBLHVCQUFBVjtBQUFBQSxtQkFBQSxNQUNhO0FBQUEsZUFBb0M7QUFBQTtBQUFBO0FBQUEsaUNBQUFBO0FBQUFBLDZCQUFBaUUsbUJBekhwRCxRQUFBQyxpQkFDQTtBQUFBLGtDQUFBWCxRQUFBdkQ7QUFBQUEsOEJBQUEsT0FFRTtBQUFBLDBCQUFnQjtBQUFBO0FBQUE7QUFBQSw0Q0FBQUE7QUFBQUEsb0NBQ1o7QUFBQSx5Q0FBQVksSUFBQTtBQUFBLHFDQUNTLDJDQVdpQjtBQUFBO0FBQUEsd0NBQUF1RCxPQVoxQixVQUFBbEQsUUFHRjtBQUFBO0FBQUE7QUFBQSxzQ0FBQWdELHFCQUFBO0FBQUEsc0NBQUFHO0FBQUFBLHdDQUc2QjtBQUFBO0FBQUEseUNBQUFBLDJCQURqQjtBQUFBLG9DQUdaO0FBQUEsa0RBQUFwRSxPQUljLDZCQUFjO0FBQUE7QUFBQTtBQUFBLHVDQUg1QjtBQUFBO0FBQUEsMENBRU07QUFBQSxvQ0FGTiwrQ0FHNEI7QUFBQTtBQUFBO0FBQUEsa0NBQUFpRCxLQUFBakQ7QUFBQUEsMEJBTzNCO0FBQUEsMkJBRUQ7QUFBQSwyQkFBK0IsK0NBNkJQO0FBQUE7QUFBQSwwQkEzQmxCO0FBQUEsMkJBQ0gsK0NBMEJxQjtBQUFBO0FBQUEsMkJBQUFxRSw0QkF4QlE7QUFBQTtBQUFBLDZCQVZsQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMEJBV3NDO0FBQUE7QUFBQTtBQUFBLDRDQUFBQztBQUFBQSxvQ0FDcEM7QUFBQSxvQ0FDeUI7QUFBQSxvQ0FDekI7QUFBQSx5Q0FBQXpELE9BQUE7QUFBQSxxQ0FFRTtBQUFBLHFDQUEyQjtBQUFBO0FBQUEsK0ZBa0JOO0FBQUE7QUFBQSx3Q0FBQTBELE1BcEJ2QixtQkFBQXRELFFBS0U7QUFBQTtBQUFBO0FBQUEsc0NBQUF1RCxlQUFBO0FBQUEsc0NBQUFDO0FBQUFBLHdDQWpETixTQUFBN0Q7QUFBQUE7QUFBQUEsMENBQUEsT0FBbUQ7QUFBQSxpREFBckI7QUFBQSx5Q0FBc0M7QUFBQTtBQUFBLDRDQUM1QztBQUFBLDZDQUFiO0FBQUEsc0NBQUE4RDtBQUFBQSx3Q0FBWTtBQUFBO0FBQUEseUNBQUFBLHlCQWtETDtBQUFBLG9DQUdaO0FBQUEsa0RBQUExRTtBQUFBQTtBQUFBQSxzQ0FBQSxPQVFJO0FBQUE7QUFBQSx3Q0FEQTtBQUFBO0FBQUE7QUFBQSw2Q0FGSjtBQUFBLHFDQUlHO0FBQUEsK0VBQUFBLE9BQ1csY0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLHVDQVRyQjtBQUFBO0FBQUEsMENBRU07QUFBQSxvQ0FGTiwrQ0FTcUI7QUFBQSxxQ0FBQztBQUFBO0FBQUEsbUNBRTVCO0FBQUEseUJBa0U4QztBQUFBO0FBQUE7QUFBQSwyQ0FBQUE7QUFBQUEsbUNBQTVDO0FBQUE7QUFBQSw4Q0FDb0I7QUFBQSwrQ0FFbEI7QUFBQTtBQUFBLDhDQUE4QyxrQ0F5Qi9CO0FBQUE7QUFBQSxvQ0FBQWlCLFFBNUJqQjtBQUFBLG9DQUFBb0QsNEJBQUE7QUFBQSxvQ0FBQXhELE9BQUE7QUFBQSwwQ0FNZ0I7QUFBQSxtQ0FBK0I7QUFBQTtBQUFBO0FBQUEscURBQUFiO0FBQUFBLGlEQUFBLE1BQy9CO0FBQUEsNkNBQXdCO0FBQUE7QUFBQTtBQUFBLCtEQUFBQTtBQUFBQSx1REFDNUI7QUFBQSxpRUFDSTtBQUFBLHVEQUEyQjtBQUFBO0FBQUE7QUFBQSx5RUFBQUE7QUFBQUE7QUFBQUEsa0VBQUEsTUFRbkM7QUFBQTtBQUFBLG9FQURBO0FBQUE7QUFBQTtBQUFBLHdFQUZKO0FBQUEsaUVBSUc7QUFBQTtBQUFBO0FBQUEsbUZBQUFBO0FBQUFBLDJFQUVGO0FBQUEsc0ZBRUQ7QUFBQSxxRkFFTTtBQUFBO0FBQUEsd0ZBRU47QUFBQSwwRkFFYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0EvQm5CO0FBQUEsU0ErQm9CO0FBQUEsUUE2SEw7QUFBQSxRQTFEMkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBNEQ3RDtBQUFBO0FBQUE7QUFBQSxFRG5YSCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQ29yZVxub3BlbiEgQXN5bmNfa2VybmVsXG5vcGVuISBBc3luY19rZXJuZWxfcmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZVxuaW5jbHVkZSBQZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsX2ludGZcblxuKCogVGhpcyBwb3NpdGlvbiBzaG93cyB1cCBpbiB0ZXN0cyBpbiBhIHdheSB0aGF0IGlzIGRpZmZpY3VsdCB0byBzdXBwcmVzcywgc28gd2UgZGVmaW5lIGl0XG4gICBoZXJlIGluIGEgcGxhY2UgdGhhdCBpcyB1bmxpa2VseSB0byBjaGFuZ2UgdmVyeSBvZnRlbiAqKVxubGV0IGR1bW15X3NyY19wb3NfdGhhdF9zaG93c191cF9pbl90ZXN0cyA9IFslaGVyZV1cblxubW9kdWxlIE1ha2UgKENvbm4gOiBDbG9zYWJsZSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIENvbm4gPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIENvbm5cblxuICAgIGxldCBzZXhwX29mX3QgKF8gOiB0KSA6IFNleHAudCA9IEF0b20gXCI8Q29ubi50PlwiXG4gIGVuZFxuXG4gIHR5cGUgY29ubiA9IENvbm4udFxuXG4gIG1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICAgIHR5cGUgJ2FkZHJlc3MgdCA9XG4gICAgICB8IEF0dGVtcHRpbmdfdG9fY29ubmVjdFxuICAgICAgfCBPYnRhaW5lZF9hZGRyZXNzIG9mICdhZGRyZXNzXG4gICAgICB8IEZhaWxlZF90b19jb25uZWN0IG9mIEVycm9yLnRcbiAgICAgIHwgQ29ubmVjdGVkIG9mIChjb25uW0BzZXhwLm9wYXF1ZV0pXG4gICAgICB8IERpc2Nvbm5lY3RlZFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB0eXBlICdhZGRyZXNzIGV2ZW50ID0gJ2FkZHJlc3MgdFxuXG4gICAgbW9kdWxlIEhhbmRsZXIgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2FkZHJlc3MgdCA9XG4gICAgICAgIHsgc2VydmVyX25hbWUgOiBzdHJpbmdcbiAgICAgICAgOyBvbl9ldmVudCA6ICdhZGRyZXNzIGV2ZW50IC0+IHVuaXQgRGVmZXJyZWQudFxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgbGV0IGxvZ19sZXZlbCA9IGZ1bmN0aW9uXG4gICAgICB8IEF0dGVtcHRpbmdfdG9fY29ubmVjdCB8IENvbm5lY3RlZCBfIHwgRGlzY29ubmVjdGVkIHwgT2J0YWluZWRfYWRkcmVzcyBfIC0+IGBJbmZvXG4gICAgICB8IEZhaWxlZF90b19jb25uZWN0IF8gLT4gYEVycm9yXG4gICAgOztcblxuICAgIGxldCBoYW5kbGUgdCB7IEhhbmRsZXIuc2VydmVyX25hbWUgPSBfOyBvbl9ldmVudCB9ID0gb25fZXZlbnQgdFxuICBlbmRcblxuICAoKiBBIHBlcnNpc3RlbnQgY29ubmVjdGlvbiB0aGF0IGlzIHBvbHltb3JwaGljIGluIHRoZSBhZGRyZXNzIHR5cGUuICBXZSBoaWRlIGF3YXkgdGhpc1xuICAgICB0eXBlIGxhdGVyIHNpbmNlIGl0IG9ubHkgYXBwZWFycyBpbiB0aGUgdHlwZSBvZiBbY3JlYXRlXS4gKilcbiAgbW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgICB0eXBlICdhZGRyZXNzIHQgPVxuICAgICAgeyBnZXRfYWRkcmVzcyA6IHVuaXQgLT4gJ2FkZHJlc3MgT3JfZXJyb3IudCBEZWZlcnJlZC50XG4gICAgICA7IGNvbm5lY3QgOiAnYWRkcmVzcyAtPiBDb25uLnQgT3JfZXJyb3IudCBEZWZlcnJlZC50XG4gICAgICA7IHJldHJ5X2RlbGF5IDogdW5pdCAtPiB1bml0IERlZmVycmVkLnRcbiAgICAgIDsgbXV0YWJsZSBjb25uIDogWyBgT2sgb2YgQ29ubi50IHwgYENsb3NlX3N0YXJ0ZWQgXSBJdmFyLnRcbiAgICAgIDsgbXV0YWJsZSBuZXh0X2Nvbm5lY3RfcmVzdWx0IDogQ29ubi50IE9yX2Vycm9yLnQgSXZhci50XG4gICAgICA7IGV2ZW50X2hhbmRsZXIgOiAnYWRkcmVzcyBFdmVudC5IYW5kbGVyLnRcbiAgICAgIDsgZXZlbnRfYnVzIDogKHVuaXQgRXZlbnQudCAtPiB1bml0LCByZWFkX3dyaXRlKSBCdXMudFxuICAgICAgOyBjbG9zZV9zdGFydGVkIDogdW5pdCBJdmFyLnRcbiAgICAgIDsgY2xvc2VfZmluaXNoZWQgOiB1bml0IEl2YXIudFxuICAgICAgOyBkb24ndF9yZWNvbm5lY3QgOiB1bml0IEl2YXIudFxuICAgICAgOyBhZGRyZXNzX2VxdWFsIDogJ2FkZHJlc3MgLT4gJ2FkZHJlc3MgLT4gYm9vbFxuICAgICAgOyBzZXhwX29mX2FkZHJlc3MgOiAnYWRkcmVzcyAtPiBTZXhwLnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgICBsZXQgc2VydmVyX25hbWUgdCA9IHQuZXZlbnRfaGFuZGxlci5zZXJ2ZXJfbmFtZVxuXG4gICAgbGV0IGhhbmRsZV9ldmVudCAodHlwZSBhZGRyZXNzKSB0IChldmVudCA6IGFkZHJlc3MgRXZlbnQudCkgPVxuICAgICAgQnVzLndyaXRlXG4gICAgICAgIHQuZXZlbnRfYnVzXG4gICAgICAgIChtYXRjaCBldmVudCB3aXRoXG4gICAgICAgICB8IE9idGFpbmVkX2FkZHJlc3MgKF8gOiBhZGRyZXNzKSAtPiBPYnRhaW5lZF9hZGRyZXNzICgpXG4gICAgICAgICB8IEF0dGVtcHRpbmdfdG9fY29ubmVjdCAtPiBBdHRlbXB0aW5nX3RvX2Nvbm5lY3RcbiAgICAgICAgIHwgRmFpbGVkX3RvX2Nvbm5lY3QgZSAtPiBGYWlsZWRfdG9fY29ubmVjdCBlXG4gICAgICAgICB8IENvbm5lY3RlZCBjb25uIC0+IENvbm5lY3RlZCBjb25uXG4gICAgICAgICB8IERpc2Nvbm5lY3RlZCAtPiBEaXNjb25uZWN0ZWQpO1xuICAgICAgRXZlbnQuaGFuZGxlIGV2ZW50IHQuZXZlbnRfaGFuZGxlclxuICAgIDs7XG5cbiAgICAoKiBUaGlzIGZ1bmN0aW9uIGZvY3VzZXMgaW4gb24gdGhlIHRoZSBlcnJvciBpdHNlbGYsIGRpc2NhcmRpbmcgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2hcbiAgICAgICBtb25pdG9yIGNhdWdodCB0aGUgZXJyb3IsIGlmIGFueS5cblxuICAgICAgIElmIHdlIGRvbid0IGRvIHRoaXMsIHdlIHNvbWV0aW1lcyBlbmQgdXAgd2l0aCBub2lzeSBsb2dzIHdoaWNoIHJlcG9ydCB0aGUgc2FtZSBlcnJvclxuICAgICAgIGFnYWluIGFuZCBhZ2FpbiwgZGlmZmVyaW5nIG9ubHkgYXMgdG8gd2hhdCBtb25pdG9yIGNhdWdodCB0aGVtLiAqKVxuICAgIGxldCBzYW1lX2Vycm9yIGUxIGUyID1cbiAgICAgIGxldCB0b19zZXhwIGUgPSBFeG4uc2V4cF9vZl90IChNb25pdG9yLmV4dHJhY3RfZXhuIChFcnJvci50b19leG4gZSkpIGluXG4gICAgICBTZXhwLmVxdWFsICh0b19zZXhwIGUxKSAodG9fc2V4cCBlMilcbiAgICA7O1xuXG4gICAgKCogQ29udGludWUgdHJ5aW5nIHRvIGNvbm5lY3QgdW50aWwgd2UgYXJlIGFibGUgdG8gZG8gc28sIGluIHdoaWNoIGNhc2Ugd2UgcmV0dXJuIGJvdGhcbiAgICAgICB0aGUgbmV3IGNvbm5lY3Rpb24gYW5kIGEgZGVmZXJyZWQgdGhhdCB3aWxsIGJlY29tZSBkZXRlcm1pbmVkIG9uY2Ugd2UgYXJlIHJlYWR5IGZvclxuICAgICAgIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0LiAqKVxuICAgIGxldCB0cnlfY29ubmVjdGluZ191bnRpbF9zdWNjZXNzZnVsIHQgPVxuICAgICAgKCogV2UgdGFrZSBjYXJlIG5vdCB0byBzcGFtIGxvZ3Mgd2l0aCB0aGUgc2FtZSBtZXNzYWdlIG92ZXIgYW5kIG92ZXIgYnkgY29tcGFyaW5nXG4gICAgICAgICBlYWNoIGxvZyBtZXNzYWdlIHRoZSB0aGUgcHJldmlvdXMgb25lIG9mIHRoZSBzYW1lIHR5cGUuICopXG4gICAgICBsZXQgcHJldmlvdXNfYWRkcmVzcyA9IHJlZiBOb25lIGluXG4gICAgICBsZXQgcHJldmlvdXNfZXJyb3IgPSByZWYgTm9uZSBpblxuICAgICAgbGV0IGNvbm5lY3QgKCkgPVxuICAgICAgICB0LmdldF9hZGRyZXNzICgpXG4gICAgICAgID4+PSBmdW5jdGlvblxuICAgICAgICB8IEVycm9yIGUgLT4gcmV0dXJuIChFcnJvciBlKVxuICAgICAgICB8IE9rIGFkZHIgLT5cbiAgICAgICAgICBsZXQgc2FtZV9hc19wcmV2aW91c19hZGRyZXNzID1cbiAgICAgICAgICAgIG1hdGNoICFwcmV2aW91c19hZGRyZXNzIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgICAgICAgfCBTb21lIHByZXZpb3VzX2FkZHJlc3MgLT4gdC5hZGRyZXNzX2VxdWFsIGFkZHIgcHJldmlvdXNfYWRkcmVzc1xuICAgICAgICAgIGluXG4gICAgICAgICAgcHJldmlvdXNfYWRkcmVzcyA6PSBTb21lIGFkZHI7XG4gICAgICAgICAgKGlmIHNhbWVfYXNfcHJldmlvdXNfYWRkcmVzc1xuICAgICAgICAgICB0aGVuIERlZmVycmVkLnVuaXRcbiAgICAgICAgICAgZWxzZSBoYW5kbGVfZXZlbnQgdCAoT2J0YWluZWRfYWRkcmVzcyBhZGRyKSlcbiAgICAgICAgICA+Pj0gZnVuICgpIC0+IHQuY29ubmVjdCBhZGRyXG4gICAgICBpblxuICAgICAgbGV0IGNvbm5lY3QgKCkgPVxuICAgICAgICAoKiBDYXRjaCBleGNlcHRpb25zIHJhaXNlZCBieSB0aGUgdXNlci1wcm92aWRlZCBbdC5nZXRfYWRkcmVzc10gb3IgW3QuY29ubmVjdF0gKilcbiAgICAgICAgRGVmZXJyZWQuT3JfZXJyb3IudHJ5X3dpdGhfam9pbiB+ZXh0cmFjdF9leG46YW1fcnVubmluZ190ZXN0IGNvbm5lY3RcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gYENsb3NlX3N0YXJ0ZWQ7XG4gICAgICAgICAgcmV0dXJuIGBDbG9zZV9zdGFydGVkKVxuICAgICAgICBlbHNlIGlmIEl2YXIuaXNfZnVsbCB0LmRvbid0X3JlY29ubmVjdFxuICAgICAgICB0aGVuIHJldHVybiBgRG9uJ3RfcmVjb25uZWN0XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nID0gdC5yZXRyeV9kZWxheSAoKSBpblxuICAgICAgICAgIGxldCViaW5kIGNvbm5lY3RfcmVzdWx0ID0gY29ubmVjdCAoKSBpblxuICAgICAgICAgIEl2YXIuZmlsbCB0Lm5leHRfY29ubmVjdF9yZXN1bHQgY29ubmVjdF9yZXN1bHQ7XG4gICAgICAgICAgdC5uZXh0X2Nvbm5lY3RfcmVzdWx0IDwtIEl2YXIuY3JlYXRlICgpO1xuICAgICAgICAgIG1hdGNoIGNvbm5lY3RfcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIGNvbm4gLT5cbiAgICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gKGBPayBjb25uKTtcbiAgICAgICAgICAgIHJldHVybiAoYE9rIChjb25uLCByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nKSlcbiAgICAgICAgICB8IEVycm9yIGVyciAtPlxuICAgICAgICAgICAgbGV0IHNhbWVfYXNfcHJldmlvdXNfZXJyb3IgPVxuICAgICAgICAgICAgICBtYXRjaCAhcHJldmlvdXNfZXJyb3Igd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgICAgICAgICAgfCBTb21lIHByZXZpb3VzX2VyciAtPiBzYW1lX2Vycm9yIGVyciBwcmV2aW91c19lcnJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBwcmV2aW91c19lcnJvciA6PSBTb21lIGVycjtcbiAgICAgICAgICAgIChpZiBzYW1lX2FzX3ByZXZpb3VzX2Vycm9yXG4gICAgICAgICAgICAgdGhlbiBEZWZlcnJlZC51bml0XG4gICAgICAgICAgICAgZWxzZSBoYW5kbGVfZXZlbnQgdCAoRmFpbGVkX3RvX2Nvbm5lY3QgZXJyKSlcbiAgICAgICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICAgIERlZmVycmVkLmFueVxuICAgICAgICAgICAgICBbIHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmdcbiAgICAgICAgICAgICAgOyBJdmFyLnJlYWQgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgICAgICAgIDsgSXZhci5yZWFkIHQuZG9uJ3RfcmVjb25uZWN0XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgID4+PSBmdW4gKCkgLT4gbG9vcCAoKSlcbiAgICAgIGluXG4gICAgICBsb29wICgpXG4gICAgOztcblxuICAgIGxldCBhYm9ydF9yZWNvbm5lY3Rpbmdfd2l0aF9ub19hY3RpdmVfY29ubmVjdGlvbiB0ID1cbiAgICAgIEl2YXIuZmlsbCB0LmNsb3NlX3N0YXJ0ZWQgKCk7XG4gICAgICBJdmFyLmZpbGwgdC5jbG9zZV9maW5pc2hlZCAoKTtcbiAgICAgIEl2YXIuZmlsbCB0LmNvbm4gYENsb3NlX3N0YXJ0ZWRcbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZVxuICAgICAgICAgICh0eXBlIGFkZHJlc3MpXG4gICAgICAgICAgfnNlcnZlcl9uYW1lXG4gICAgICAgICAgPyhvbl9ldmVudCA9IGZ1biBfIC0+IERlZmVycmVkLnVuaXQpXG4gICAgICAgICAgP3JldHJ5X2RlbGF5XG4gICAgICAgICAgPyhyYW5kb21fc3RhdGUgPSBgU3RhdGUgUmFuZG9tLlN0YXRlLmRlZmF1bHQpXG4gICAgICAgICAgPyh0aW1lX3NvdXJjZSA9IFRpbWVfc291cmNlLndhbGxfY2xvY2sgKCkpXG4gICAgICAgICAgfmNvbm5lY3RcbiAgICAgICAgICB+YWRkcmVzczoobW9kdWxlIEFkZHJlc3MgOiBBZGRyZXNzIHdpdGggdHlwZSB0ID0gYWRkcmVzcylcbiAgICAgICAgICBnZXRfYWRkcmVzc1xuICAgICAgPVxuICAgICAgbGV0IGV2ZW50X2hhbmRsZXIgPSB7IEV2ZW50LkhhbmRsZXIuc2VydmVyX25hbWU7IG9uX2V2ZW50IH0gaW5cbiAgICAgIGxldCBkZWZhdWx0X3JldHJ5X2RlbGF5ID1cbiAgICAgICAgRm4uY29uc3QgKFRpbWVfbnMuU3Bhbi5vZl9zZWMgKGlmIGFtX3J1bm5pbmdfdGVzdCB0aGVuIDAuMSBlbHNlIDEwLikpXG4gICAgICBpblxuICAgICAgbGV0IG5vbl9yYW5kb21pemVkX2RlbGF5ID0gT3B0aW9uLnZhbHVlIHJldHJ5X2RlbGF5IH5kZWZhdWx0OmRlZmF1bHRfcmV0cnlfZGVsYXkgaW5cbiAgICAgIGxldCByZXRyeV9kZWxheV9zcGFuID1cbiAgICAgICAgbWF0Y2ggcmFuZG9tX3N0YXRlIHdpdGhcbiAgICAgICAgfCBgTm9uX3JhbmRvbSAtPiBub25fcmFuZG9taXplZF9kZWxheVxuICAgICAgICB8IGBTdGF0ZSByYW5kb21fc3RhdGUgLT5cbiAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgIGxldCBzcGFuID0gbm9uX3JhbmRvbWl6ZWRfZGVsYXkgKCkgaW5cbiAgICAgICAgICAgIGxldCBzcGFuID0gVGltZV9ucy5TcGFuLnRvX3NlYyBzcGFuIGluXG4gICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBSYW5kb20uU3RhdGUuZmxvYXQgcmFuZG9tX3N0YXRlIChzcGFuICouIDAuMykgaW5cbiAgICAgICAgICAgIGxldCB3YWl0ID1cbiAgICAgICAgICAgICAgaWYgUmFuZG9tLlN0YXRlLmJvb2wgcmFuZG9tX3N0YXRlXG4gICAgICAgICAgICAgIHRoZW4gc3BhbiArLiBkaXN0YW5jZVxuICAgICAgICAgICAgICBlbHNlIHNwYW4gLS4gZGlzdGFuY2VcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBUaW1lX25zLlNwYW4ub2Zfc2VjIHdhaXRcbiAgICAgIGluXG4gICAgICBsZXQgcmV0cnlfZGVsYXkgKCkgPSBUaW1lX3NvdXJjZS5hZnRlciB0aW1lX3NvdXJjZSAocmV0cnlfZGVsYXlfc3BhbiAoKSkgaW5cbiAgICAgIGxldCB0ID1cbiAgICAgICAgeyBldmVudF9oYW5kbGVyXG4gICAgICAgIDsgZXZlbnRfYnVzID1cbiAgICAgICAgICAgIEJ1cy5jcmVhdGVfZXhuXG4gICAgICAgICAgICAgIChpZiBhbV9ydW5uaW5nX3Rlc3QgdGhlbiBkdW1teV9zcmNfcG9zX3RoYXRfc2hvd3NfdXBfaW5fdGVzdHMgZWxzZSBbJWhlcmVdKVxuICAgICAgICAgICAgICBBcml0eTFcbiAgICAgICAgICAgICAgfm9uX3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZTpBbGxvd19hbmRfc2VuZF9sYXN0X3ZhbHVlXG4gICAgICAgICAgICAgIH5vbl9jYWxsYmFja19yYWlzZTppZ25vcmVcbiAgICAgICAgOyBnZXRfYWRkcmVzc1xuICAgICAgICA7IGNvbm5lY3RcbiAgICAgICAgOyBuZXh0X2Nvbm5lY3RfcmVzdWx0ID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgOyByZXRyeV9kZWxheVxuICAgICAgICA7IGNvbm4gPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGNsb3NlX3N0YXJ0ZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGNsb3NlX2ZpbmlzaGVkID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgOyBkb24ndF9yZWNvbm5lY3QgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGFkZHJlc3NfZXF1YWwgPSBBZGRyZXNzLmVxdWFsXG4gICAgICAgIDsgc2V4cF9vZl9hZGRyZXNzID0gQWRkcmVzcy5zZXhwX29mX3RcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgICgqIHRoaXMgbG9vcCBmaW5pc2hlcyBvbmNlIFtjbG9zZSB0XSBoYXMgYmVlbiBjYWxsZWQsIGluIHdoaWNoIGNhc2UgaXQgbWFrZXMgc3VyZSB0b1xuICAgICAgICAgbGVhdmUgW3QuY29ubl0gZmlsbGVkIHdpdGggW2BDbG9zZV9zdGFydGVkXS4gKilcbiAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICBAQCBEZWZlcnJlZC5yZXBlYXRfdW50aWxfZmluaXNoZWQgKCkgKGZ1biAoKSAtPlxuICAgICAgICBsZXQlYmluZCAoKSA9IGhhbmRsZV9ldmVudCB0IEF0dGVtcHRpbmdfdG9fY29ubmVjdCBpblxuICAgICAgICBtYXRjaCViaW5kIHRyeV9jb25uZWN0aW5nX3VudGlsX3N1Y2Nlc3NmdWwgdCB3aXRoXG4gICAgICAgIHwgYENsb3NlX3N0YXJ0ZWQgLT4gcmV0dXJuIChgRmluaXNoZWQgKCkpXG4gICAgICAgIHwgYERvbid0X3JlY29ubmVjdCAtPlxuICAgICAgICAgIGFib3J0X3JlY29ubmVjdGluZ193aXRoX25vX2FjdGl2ZV9jb25uZWN0aW9uIHQ7XG4gICAgICAgICAgcmV0dXJuIChgRmluaXNoZWQgKCkpXG4gICAgICAgIHwgYE9rIChjb25uLCByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nKSAtPlxuICAgICAgICAgIGxldCViaW5kICgpID0gaGFuZGxlX2V2ZW50IHQgKENvbm5lY3RlZCBjb25uKSBpblxuICAgICAgICAgIGxldCViaW5kICgpID0gQ29ubi5jbG9zZV9maW5pc2hlZCBjb25uIGluXG4gICAgICAgICAgdC5jb25uIDwtIEl2YXIuY3JlYXRlICgpO1xuICAgICAgICAgIGxldCViaW5kICgpID0gaGFuZGxlX2V2ZW50IHQgRGlzY29ubmVjdGVkIGluXG4gICAgICAgICAgKCogd2FpdHMgdW50aWwgW3JldHJ5X2RlbGF5ICgpXSB0aW1lIGhhcyBwYXNzZWQgc2luY2UgdGhlIHRpbWUganVzdCBiZWZvcmUgd2UgbGFzdFxuICAgICAgICAgICAgIHRyaWVkIHRvIGNvbm5lY3QgcmF0aGVyIHRoYW4gdGhlIHRpbWUgd2Ugbm90aWNlZCBiZWluZyBkaXNjb25uZWN0ZWQsIHNvIHRoYXQgaWZcbiAgICAgICAgICAgICBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbiBkaWVzLCB3ZSB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IGltbWVkaWF0ZWx5LiAqKVxuICAgICAgICAgIGxldCVtYXAgKCkgPVxuICAgICAgICAgICAgRGVmZXJyZWQuYW55XG4gICAgICAgICAgICAgIFsgcmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZ1xuICAgICAgICAgICAgICA7IEl2YXIucmVhZCB0LmNsb3NlX3N0YXJ0ZWRcbiAgICAgICAgICAgICAgOyBJdmFyLnJlYWQgdC5kb24ndF9yZWNvbm5lY3RcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIGluXG4gICAgICAgICAgaWYgSXZhci5pc19mdWxsIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgSXZhci5maWxsIHQuY29ubiBgQ2xvc2Vfc3RhcnRlZDtcbiAgICAgICAgICAgIGBGaW5pc2hlZCAoKSlcbiAgICAgICAgICBlbHNlIGlmIEl2YXIuaXNfZnVsbCB0LmRvbid0X3JlY29ubmVjdFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgYWJvcnRfcmVjb25uZWN0aW5nX3dpdGhfbm9fYWN0aXZlX2Nvbm5lY3Rpb24gdDtcbiAgICAgICAgICAgIGBGaW5pc2hlZCAoKSlcbiAgICAgICAgICBlbHNlIGBSZXBlYXQgKCkpO1xuICAgICAgdFxuICAgIDs7XG5cbiAgICBsZXQgY29ubmVjdGVkIHQgPVxuICAgICAgKCogVGFrZSBjYXJlIG5vdCB0byByZXR1cm4gYSBjb25uZWN0aW9uIHRoYXQgaXMga25vd24gdG8gYmUgY2xvc2VkIGF0IHRoZSB0aW1lXG4gICAgICAgICBbY29ubmVjdGVkXSB3YXMgY2FsbGVkLiAgVGhpcyBjb3VsZCBoYXBwZW4gaW4gY2xpZW50IGNvZGUgdGhhdCBiZWhhdmVzIGxpa2VcbiAgICAgICAgIHtbXG4gICAgICAgICAgIFBlcnNpc3RlbnRfY29ubmVjdGlvbi5ScGMuY29ubmVjdGVkIHRcbiAgICAgICAgICAgPj49IGZ1biBjMSAtPlxuICAgICAgICAgICAuLi5cbiAgICAgICAgICAgICBScGMuQ29ubmVjdGlvbi5jbG9zZV9maW5pc2hlZCBjMVxuICAgICAgICAgICAoKiBhdCB0aGlzIHBvaW50IHdlIGFyZSBpbiBhIHJhY2Ugd2l0aCB0aGUgc2FtZSBjYWxsIGluc2lkZVxuICAgICAgICAgICAgICBwZXJzaXN0ZW50X2NsaWVudC5tbCAqKVxuICAgICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgIFBlcnNpc3RlbnRfY29ubmVjdGlvbi5ScGMuY29ubmVjdGVkIHRcbiAgICAgICAgICAgKCogZGVwZW5kaW5nIG9uIGhvdyB0aGUgcmFjZSB0dXJucyBvdXQsIHdlIGRvbid0IHdhbnQgdG8gZ2V0IGEgY2xvc2VkIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgaGVyZSAqKVxuICAgICAgICAgICA+Pj0gZnVuIGMyIC0+XG4gICAgICAgICAgIC4uLlxuICAgICAgICAgXX1cbiAgICAgICAgIFRoaXMgZG9lc24ndCByZW1vdmUgdGhlIHJhY2UgY29uZGl0aW9uLCBidXQgaXQgbWFrZXMgaXQgbGVzcyBsaWtlbHkgdG8gaGFwcGVuLlxuICAgICAgKilcbiAgICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICAgIGxldCBkID0gSXZhci5yZWFkIHQuY29ubiBpblxuICAgICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBkXG4gICAgICAgICAgPj49IChmdW5jdGlvblxuICAgICAgICAgICAgfCBgQ2xvc2Vfc3RhcnRlZCAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgICAgICAgICAgfCBgT2sgY29ubiAtPiByZXR1cm4gY29ubilcbiAgICAgICAgfCBTb21lIGBDbG9zZV9zdGFydGVkIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgICAgIHwgU29tZSAoYE9rIGNvbm4pIC0+XG4gICAgICAgICAgaWYgQ29ubi5pc19jbG9zZWQgY29ublxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICgqIGdpdmUgdGhlIHJlY29ubmVjdGlvbiBsb29wIGEgY2hhbmNlIHRvIG92ZXJ3cml0ZSB0aGUgaXZhciAqKVxuICAgICAgICAgICAgQ29ubi5jbG9zZV9maW5pc2hlZCBjb25uID4+PSBsb29wXG4gICAgICAgICAgZWxzZSByZXR1cm4gY29ublxuICAgICAgaW5cbiAgICAgIGxvb3AgKClcbiAgICA7O1xuXG4gICAgbGV0IGN1cnJlbnRfY29ubmVjdGlvbiB0ID1cbiAgICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKEl2YXIucmVhZCB0LmNvbm4pIHdpdGhcbiAgICAgIHwgTm9uZSB8IFNvbWUgYENsb3NlX3N0YXJ0ZWQgLT4gTm9uZVxuICAgICAgfCBTb21lIChgT2sgY29ubikgLT4gU29tZSBjb25uXG4gICAgOztcblxuICAgIGxldCBjbG9zZV9maW5pc2hlZCB0ID0gSXZhci5yZWFkIHQuY2xvc2VfZmluaXNoZWRcbiAgICBsZXQgaXNfY2xvc2VkIHQgPSBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG5cbiAgICBsZXQgY2xvc2UgdCA9XG4gICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG4gICAgICB0aGVuXG4gICAgICAgICgqIEFub3RoZXIgY2FsbCB0byBjbG9zZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzLiAgV2FpdCBmb3IgaXQgdG8gZmluaXNoLiAqKVxuICAgICAgICBjbG9zZV9maW5pc2hlZCB0XG4gICAgICBlbHNlIChcbiAgICAgICAgSXZhci5maWxsIHQuY2xvc2Vfc3RhcnRlZCAoKTtcbiAgICAgICAgSXZhci5yZWFkIHQuY29ublxuICAgICAgICA+Pj0gZnVuIGNvbm5fb3B0IC0+XG4gICAgICAgIChtYXRjaCBjb25uX29wdCB3aXRoXG4gICAgICAgICB8IGBDbG9zZV9zdGFydGVkIC0+IERlZmVycmVkLnVuaXRcbiAgICAgICAgIHwgYE9rIGNvbm4gLT4gQ29ubi5jbG9zZSBjb25uKVxuICAgICAgICA+PnwgZnVuICgpIC0+IEl2YXIuZmlsbCB0LmNsb3NlX2ZpbmlzaGVkICgpKVxuICAgIDs7XG5cbiAgICBsZXQgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0X2Nvbm5lY3Rpb25fY2xvc2VkID1cbiAgICAgIE9yX2Vycm9yLmVycm9yX3MgWyVtZXNzYWdlIFwiUGVyc2lzdGVudCBjb25uZWN0aW9uIGNsb3NlZFwiXVxuICAgIDs7XG5cbiAgICBsZXQgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0IHQgPVxuICAgICAgaWYgaXNfY2xvc2VkIHRcbiAgICAgIHRoZW4gcmV0dXJuIGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdF9jb25uZWN0aW9uX2Nsb3NlZFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGN1cnJlbnRfY29ubmVjdGlvbiB0IHdpdGhcbiAgICAgICAgfCBTb21lIHggd2hlbiBub3QgKENvbm4uaXNfY2xvc2VkIHgpIC0+IHJldHVybiAoT2sgeClcbiAgICAgICAgfCBTb21lIChfIDogQ29ubi50KSB8IE5vbmUgLT5cbiAgICAgICAgICBEZWZlcnJlZC5jaG9vc2VcbiAgICAgICAgICAgIFsgY2hvaWNlIChJdmFyLnJlYWQgdC5jbG9zZV9zdGFydGVkKSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0X2Nvbm5lY3Rpb25fY2xvc2VkKVxuICAgICAgICAgICAgOyBjaG9pY2UgKEl2YXIucmVhZCB0Lm5leHRfY29ubmVjdF9yZXN1bHQpIEZuLmlkXG4gICAgICAgICAgICBdKVxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25faXNfY2xvc2VkIHQgPVxuICAgICAgSXZhci5maWxsX2lmX2VtcHR5IHQuZG9uJ3RfcmVjb25uZWN0ICgpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID0gVCA6ICdhZGRyZXNzIFBvbHkudCAtPiB0IFtAQHVuYm94ZWRdXG5cbiAgbGV0IHNleHBfb2ZfdCAoVCB0KSA9IFBvbHkuc2V4cF9vZl90IHQuc2V4cF9vZl9hZGRyZXNzIHRcblxuICBsZXQgY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25faXNfY2xvc2VkIChUIHQpID1cbiAgICBQb2x5LmNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCB0XG4gIDs7XG5cbiAgbGV0IGNsb3NlX2ZpbmlzaGVkIChUIHQpID0gUG9seS5jbG9zZV9maW5pc2hlZCB0XG4gIGxldCBpc19jbG9zZWQgKFQgdCkgPSBQb2x5LmlzX2Nsb3NlZCB0XG4gIGxldCBldmVudF9idXMgKFQgdCkgPSBCdXMucmVhZF9vbmx5IHQuZXZlbnRfYnVzXG4gIGxldCBjbG9zZSAoVCB0KSA9IFBvbHkuY2xvc2UgdFxuICBsZXQgc2VydmVyX25hbWUgKFQgdCkgPSBQb2x5LnNlcnZlcl9uYW1lIHRcbiAgbGV0IGN1cnJlbnRfY29ubmVjdGlvbiAoVCB0KSA9IFBvbHkuY3VycmVudF9jb25uZWN0aW9uIHRcbiAgbGV0IGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCAoVCB0KSA9IFBvbHkuY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0IHRcbiAgbGV0IGNvbm5lY3RlZCAoVCB0KSA9IFBvbHkuY29ubmVjdGVkIHRcblxuICBsZXQgY3JlYXRlXG4gICAgICAgIH5zZXJ2ZXJfbmFtZVxuICAgICAgICA/b25fZXZlbnRcbiAgICAgICAgP3JldHJ5X2RlbGF5XG4gICAgICAgID9yYW5kb21fc3RhdGVcbiAgICAgICAgP3RpbWVfc291cmNlXG4gICAgICAgIH5jb25uZWN0XG4gICAgICAgIH5hZGRyZXNzXG4gICAgICAgIGdldF9hZGRyZXNzXG4gICAgPVxuICAgIFRcbiAgICAgIChQb2x5LmNyZWF0ZVxuICAgICAgICAgfnNlcnZlcl9uYW1lXG4gICAgICAgICA/b25fZXZlbnRcbiAgICAgICAgID9yZXRyeV9kZWxheVxuICAgICAgICAgP3JhbmRvbV9zdGF0ZVxuICAgICAgICAgP3RpbWVfc291cmNlXG4gICAgICAgICB+Y29ubmVjdFxuICAgICAgICAgfmFkZHJlc3NcbiAgICAgICAgIGdldF9hZGRyZXNzKVxuICA7O1xuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
