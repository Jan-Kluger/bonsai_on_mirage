// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Ppx_inline_test_lib
//# unitInfo: Requires: Base, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib$0 = "Ppx_inline_test_lib",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    initial = [0, 0, [0, "disabled", 0]],
    cst = cst$13,
    am_running_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error";
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    a:
    {
     switch(t1){
       case 0:
        if(! t2) return 0; break;
       case 1: break;
       default: break a;
     }
     if(2 !== t2) return 1;
    }
    return 2;
   }
   function combine_all(ts){
    return caml_call3(Stdlib_List[26], combine, 0, ts);
   }
   var
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0],
    action = [0, -950194894],
    dummy = 0,
    _E_ = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    _F_ = [0, [12, 32, [2, 0, 0]], " %s"],
    _z_ =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    _A_ =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    _B_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _C_ =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    _D_ =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    _G_ = [0, [11, cst$12, [10, 0]], ".\n%!"],
    _H_ =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    _J_ = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    _K_ = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    _I_ =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    _x_ =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    _y_ = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    _r_ = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    _s_ = [0, [2, 0, [10, 0]], cst_s],
    _t_ = [0, 1],
    _u_ =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    _v_ =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    _w_ =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    _q_ = [0, [2, 0, [10, 0]], cst_s],
    _p_ = [0, [2, 0, [10, 0]], cst_s],
    _o_ = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib = cst_Ppx_inline_test_lib$0,
    cst_inline_tests_log = cst_inline_tests_log$0,
    _P_ =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    _O_ =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    _h_ =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    _g_ =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    _f_ = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    _e_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    _a_ = [0, [2, 0, 0], cst_s$0],
    _b_ = [0, [2, 0, 0], cst_s$0],
    cst_inline_test_runner = cst_inline_test_runner$0,
    _N_ =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Prefix_to_prepend_to_filep =
      " Prefix to prepend to filepaths in test output",
    cst_diff_path_prefix = "-diff-path-prefix",
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    _n_ = [0, 187165616, 545942154],
    _L_ = [0, 187165616, -863538453];
   try{
    caml_sys_getenv("FORCE_DROP_INLINE_TEST");
    var _R_ = 1, force_drop = _R_;
   }
   catch(_bn_){
    var _c_ = caml_wrap_exception(_bn_);
    if(_c_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_c_, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var _d_ = caml_call2(Stdlib_Hashtbl[1], 0, 23), current = [0, cst];
   function found_test(param){
    var
     _bl_ = current[1] !== cst$13 ? 1 : 0,
     _bm_ = _bl_ ? 1 - caml_call2(Stdlib_Hashtbl[9], _d_, current[1]) : _bl_;
    return _bm_ ? caml_call3(Stdlib_Hashtbl[5], _d_, current[1], 0) : _bm_;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return p === current[1] ? 1 : 0;
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var
     t = current$0[1],
     _bk_ = caml_call2(Stdlib_List[20], function(m){return m[2];}, t);
    return caml_call1(Stdlib_List[14], _bk_);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    diff_path_prefix = [0, 0];
   function displayed_descr(descr, filename, line, start_pos, end_pos){
    var _bi_ = caml_obj_tag(descr);
    a:
    if(250 === _bi_)
     var descr$0 = descr[1];
    else{
     if(246 !== _bi_ && 244 !== _bi_){var descr$0 = descr; break a;}
     var descr$0 = caml_call1(CamlinternalLazy[2], descr);
    }
    var
     _bj_ =
       descr$0 === cst$13 ? cst$0 : caml_call2(Stdlib[28], cst$1, descr$0);
    return caml_call6
            (Stdlib_Printf[4], _e_, filename, line, start_pos, end_pos, _bj_);
   }
   if(Base[86][1]){
    var _i_ = caml_sys_argv(0), match = caml_call1(Stdlib_Array[10], _i_);
    a:
    if(match){
     var _j_ = match[2];
     if(_j_){
      var name = match[1];
      if(_j_[1] === cst_inline_test_runner$0){
       var match$0 = _j_[2];
       if(match$0){
        var
         rest = match$0[2],
         lib = match$0[1],
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, initial],
         name_filter = [0, 0],
         msg$1 =
           caml_call4
            (Stdlib_Printf[4], _N_, name, cst_inline_test_runner, lib),
         f =
           function(anon){
            caml_call3(Stdlib_Printf[3], _O_, name, anon);
            return caml_call1(Stdlib[99], 1);
           },
         l =
           caml_call2
            (Stdlib_Arg[11],
             0,
             [0,
              [0,
               cst_list_test_names,
               [0,
                function(param){
                 list_test_names[1] = 1;
                 verbose[1] = 1;
                 return 0;
                }],
               cst_Do_not_run_tests_but_show_],
              [0,
               [0,
                cst_list_partitions,
                [0, function(param){list_partitions[1] = 1; return 0;}],
                cst_Lists_all_the_partitions_t],
               [0,
                [0,
                 cst_partition,
                 [4, function(i){partition[1] = [0, i]; return 0;}],
                 cst_Only_run_the_tests_in_the_],
                [0,
                 [0,
                  cst_verbose,
                  [2, verbose],
                  cst_Show_the_tests_as_they_run],
                 [0,
                  [0,
                   cst_stop_on_error,
                   [2, stop_on_error],
                   cst_Run_tests_only_up_to_the_f],
                  [0,
                   [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
                   [0,
                    [0,
                     cst_show_counts,
                     [2, show_counts],
                     cst_Show_the_number_of_tests_r],
                    [0,
                     [0,
                      cst_log,
                      [0,
                       function(param){
                        try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                        catch(_bh_){}
                        log[1] = [0, caml_call1(Stdlib[60], cst_inline_tests_log)];
                        return 0;
                       }],
                      cst_Log_the_tests_run_in_inlin],
                     [0,
                      [0,
                       cst_drop_tag,
                       [4,
                        function(tag){
                         var t = tag_predicate[1], _bf_ = [0, tag, t[2]];
                         tag_predicate[1] =
                          [0,
                           caml_call2
                            (Stdlib_List[44],
                             function(_bg_){return tag !== _bg_ ? 1 : 0;},
                             t[1]),
                           _bf_];
                         return 0;
                        }],
                       cst_tag_Only_run_tests_not_tag],
                      [0,
                       [0,
                        cst_require_tag,
                        [4,
                         function(tag){
                          var
                           t = tag_predicate[1],
                           _bd_ =
                             caml_call2
                              (Stdlib_List[44],
                               function(_be_){return tag !== _be_ ? 1 : 0;},
                               t[2]);
                          tag_predicate[1] = [0, [0, tag, t[1]], _bd_];
                          return 0;
                         }],
                        cst_tag_Only_run_tests_tagged_],
                       [0,
                        [0,
                         cst_matching,
                         [4,
                          function(s){
                           name_filter[1] = [0, s, name_filter[1]];
                           return 0;
                          }],
                         cst_substring_Only_run_tests_w],
                        [0,
                         [0,
                          cst_only_test,
                          [4,
                           function(str){
                            try{
                             var
                              _a8_ =
                                [0,
                                 caml_call3
                                  (Stdlib_Scanf[5],
                                   str,
                                   _h_,
                                   function(file, line, start_pos, end_pos){return [0, file, [0, line]];
                                   })],
                              match = _a8_;
                            }
                            catch(_ba_){
                             try{
                              var
                               _a7_ =
                                 [0,
                                  caml_call3
                                   (Stdlib_Scanf[5],
                                    str,
                                    _g_,
                                    function(file, line){return [0, file, [0, line]];})],
                               match = _a7_;
                             }
                             catch(_bb_){
                              try{
                               var
                                _a6_ =
                                  [0,
                                   caml_call3
                                    (Stdlib_Scanf[5],
                                     str,
                                     _f_,
                                     function(file){return [0, file, 0];})],
                                match = _a6_;
                              }
                              catch(_bc_){var match = 0;}
                             }
                            }
                            if(match)
                             var
                              match$0 = match[1],
                              index = match$0[2],
                              file = match$0[1],
                              index$0 = index,
                              filename = file;
                            else if(caml_call2(Stdlib_String[15], str, 58)){
                             var
                              i = caml_call2(Stdlib_String[36], str, 58),
                              filename$0 = caml_call3(Stdlib_String[16], str, 0, i),
                              index_string =
                                caml_call3
                                 (Stdlib_String[16],
                                  str,
                                  i + 1 | 0,
                                  (caml_ml_string_length(str) - i | 0) - 1 | 0);
                             try{
                              var
                               _a__ = runtime.caml_int_of_string(index_string),
                               index$1 = _a__;
                             }
                             catch(_a$_){
                              var _a9_ = caml_wrap_exception(_a$_);
                              if(_a9_[1] !== Stdlib[7])
                               throw caml_maybe_attach_backtrace(_a9_, 0);
                              caml_call2(Stdlib_Printf[3], _P_, str);
                              var index$1 = caml_call1(Stdlib[99], 1);
                             }
                             var index$0 = [0, index$1], filename = filename$0;
                            }
                            else
                             var index$0 = 0, filename = str;
                            tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
                            return 0;
                           }],
                          cst_location_Run_only_the_test],
                         [0,
                          [0,
                           cst_no_color,
                           [3, use_color],
                           cst_Summarize_tests_without_us],
                          [0,
                           [0,
                            cst_in_place,
                            [2, in_place],
                            cst_Update_expect_tests_in_pla],
                           [0,
                            [0,
                             cst_diff_cmd,
                             [4, function(s){diff_command[1] = [0, s]; return 0;}],
                             cst_Diff_command_for_tests_tha],
                            [0,
                             [0,
                              cst_source_tree_root,
                              [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
                              cst_Path_to_the_root_of_the_so],
                             [0,
                              [0,
                               cst_diff_path_prefix,
                               [4, function(s){diff_path_prefix[1] = [0, s]; return 0;}],
                               cst_Prefix_to_prepend_to_filep],
                              0]]]]]]]]]]]]]]]]]),
         argv = caml_call1(Stdlib_Array[11], [0, name, rest]);
        try{caml_call5(Stdlib_Arg[3], 0, argv, l, f, msg$1);}
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] === Stdlib_Arg[8]){
          var msg = exn[2];
          caml_call2(Stdlib_Printf[3], _a_, msg);
          caml_call1(Stdlib[99], 1);
         }
         else{
          if(exn[1] !== Stdlib_Arg[7])
           throw caml_maybe_attach_backtrace(exn, 0);
          var msg$0 = exn[2];
          caml_call2(Stdlib_Printf[2], _b_, msg$0);
          caml_call1(Stdlib[99], 0);
         }
        }
        var
         _Q_ = list_partitions[1] ? -260537174 : [0, 1025081494, partition[1]],
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], _Q_]];
        action[1] = v;
        break a;
       }
      }
     }
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1;
   a:
   {
    try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
    catch(_a4_){
     var _k_ = caml_wrap_exception(_a4_);
     if(_k_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_k_, 0);
     b:
     {
      try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
      catch(_a5_){
       var _l_ = caml_wrap_exception(_a5_);
       if(_l_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_l_, 0);
       var _m_ = 0;
       break b;
      }
      var _M_ = val !== "inline-test" ? 0 : 1, _m_ = _M_;
     }
     var am_running = _m_;
     break a;
    }
    var am_running = 1;
   }
   var testing = am_test_runner ? _n_ : am_running ? _L_ : 822171972;
   function wall_time_clock_ns(param){return caml_call1(Time_now[1], 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         _a2_ = caml_call2(Stdlib[28], cst$2, cst_time_without_resetting_ran),
         _a3_ = caml_call2(Stdlib[28], cst_Ppx_inline_test_lib, _a2_);
        return caml_call2(Base_String[83][2], 0, _a3_);
       }];
   function time_without_resetting_random_(f){
    var before_ns = wall_time_clock_ns(0);
    try{var _a1_ = [0, caml_call1(f, 0)], res = _a1_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, caml_call1(Stdlib_Printexc[6], 0)]];
    }
    var
     _aZ_ = wall_time_clock_ns(0),
     _a0_ = caml_call2(Base_Int63[43], _aZ_, before_ns);
    time_sec[1] = caml_call1(Base_Int63[3], _a0_) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(_aY_){
        return caml_call1(Stdlib_Random[19][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(_aX_){
        return caml_call1(Base_Random[18][2], [0, 111, 222, 333]);
       }];
   function string_of_module_descr(param){
    var
     t = current$0[1],
     _aS_ = caml_call2(Stdlib_List[20], function(m){return m[1];}, t),
     _aT_ =
       caml_call2
        (Stdlib_List[20],
         function(s){
          var
           _aU_ = caml_call1(Stdlib_String[29], s),
           _aV_ = caml_call2(Stdlib[28], _aU_, cst$3),
           _aW_ = caml_call2(Stdlib[28], cst_T_MODULE_at, _aV_);
          return caml_call2(Stdlib[28], cst_in_TES, _aW_);
         },
         _aS_);
    return caml_call2(Stdlib_String[7], cst$4, _aT_);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = caml_call1(Stdlib_List[10], delayed_errors[1]);
    if(! delayed_errors$0) return;
    var _aR_ = caml_call2(Stdlib_String[1], 70, 61);
    caml_call2(Stdlib_Printf[3], _o_, _aR_);
    return caml_call2
            (Stdlib_List[18],
             function(message){
              return caml_call2(Stdlib_Printf[3], _p_, message);
             },
             delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    return caml_call2
            (Stdlib_Printf[10],
             function(s){
              if(verbose[1])
               delayed_errors[1] = [0, s, delayed_errors[1]];
              else
               caml_call2(Stdlib_Printf[3], _q_, s);
              var _aQ_ = stop_on_error[1];
              return _aQ_
                      ? (print_delayed_errors(0), caml_call1(Stdlib[99], 2))
                      : _aQ_;
             },
             fmt);
   }
   function add_hooks(C, f, param){
    caml_call1(C[1], 0);
    return caml_call1(f, 0);
   }
   function hum_backtrace(backtrace){
    var
     _aK_ = caml_call1(Base_String[101], backtrace),
     _aL_ =
       caml_call2
        (Base_List[138],
         _aK_,
         function(str){
          var _aO_ = caml_obj_tag(where_to_cut_backtrace);
          a:
          if(250 === _aO_)
           var _aP_ = where_to_cut_backtrace[1];
          else{
           if(246 !== _aO_ && 244 !== _aO_){
            var _aP_ = where_to_cut_backtrace;
            break a;
           }
           var _aP_ = caml_call1(CamlinternalLazy[2], where_to_cut_backtrace);
          }
          return 1 - caml_call2(Base_String[83][5], _aP_, str);
         }),
     _aM_ =
       caml_call2
        (Base_List[52],
         _aL_,
         function(str){
          var _aN_ = caml_call2(Base[212], str, cst$5);
          return caml_call2(Base[212], cst$6, _aN_);
         });
    return caml_call2(Base_String[67], 0, _aM_);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _ap_ = match[2],
     what_to_do = _ap_[2],
     match$0 = _ap_[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1];
    function f$0(_aJ_){return add_hooks(config, f, _aJ_);}
    var
     descr$0 =
       [246,
        function(_aI_){
         return displayed_descr
                 (descr, def_filename, def_line_number, start_pos, end_pos);
        }],
     _aq_ = current_tags(0),
     complete_tags = caml_call2(Stdlib[37], tags, _aq_),
     _ar_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_ar_){
     var
      _as_ =
        only_test_location
         ? caml_call2
           (Stdlib_List[34],
            function(param){
             var
              used = param[3],
              line_number_opt = param[2],
              filename = param[1],
              position_start =
                caml_ml_string_length(def_filename)
                - caml_ml_string_length(filename)
                | 0,
              _aD_ = 0 <= position_start ? 1 : 0;
             if(_aD_){
              var
               end_of_def_filename =
                 caml_call3
                  (Stdlib_String[16],
                   def_filename,
                   position_start,
                   caml_ml_string_length(filename)),
               _aE_ = end_of_def_filename === filename ? 1 : 0;
              if(_aE_){
               var
                _aF_ = 0 === position_start ? 1 : 0,
                _aG_ =
                  _aF_
                  ||
                   (47
                     ===
                      runtime.caml_string_get
                       (def_filename, position_start - 1 | 0)
                     ? 1
                     : 0);
               if(_aG_)
                if(line_number_opt)
                 var
                  line_number = line_number_opt[1],
                  _aH_ = caml_equal(def_line_number, line_number);
                else
                 var _aH_ = 1;
               else
                var _aH_ = _aG_;
              }
              else
               var _aH_ = _aE_;
              var found = _aH_;
             }
             else
              var found = _aD_;
             if(found) used[1] = 1;
             return found;
            },
            only_test_location)
         : 1;
     if(_as_){
      var
       _ak_ =
         caml_call2
          (Stdlib_List[34],
           function(req){
            return 1 - caml_call2(Stdlib_List[37], req, complete_tags);
           },
           which_tags[1]),
       _at_ =
         _ak_
         ||
          caml_call2
           (Stdlib_List[34],
            function(dropped){
             return caml_call2(Stdlib_List[37], dropped, complete_tags);
            },
            which_tags[2]),
       _au_ = 1 - _at_;
      if(_au_){
       var _av_ = caml_obj_tag(descr$0);
       a:
       if(250 === _av_)
        var descr$1 = descr$0[1];
       else{
        if(246 !== _av_ && 244 !== _av_){var descr$1 = descr$0; break a;}
        var descr$1 = caml_call1(CamlinternalLazy[2], descr$0);
       }
       var
        _aw_ =
          name_filter
           ? caml_call2
             (Stdlib_List[34],
              function(substring){
               return caml_call2(Base_String[89], descr$1, substring);
              },
              name_filter)
           : 1,
        should_run = _aw_;
      }
      else
       var should_run = _au_;
     }
     else
      var should_run = _as_;
    }
    else
     var should_run = _ar_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _ax_ = is_current(partition);
     if(_ax_){
      var _ay_ = caml_obj_tag(descr$0);
      a:
      if(250 === _ay_)
       var descr$2 = descr$0[1];
      else{
       if(246 !== _ay_ && 244 !== _ay_){var descr$2 = descr$0; break a;}
       var descr$2 = caml_call1(CamlinternalLazy[2], descr$0);
      }
      tests_ran[1]++;
      var match$1 = log[1];
      if(match$1){
       var ch = match$1[1], _az_ = string_of_module_descr(0);
       caml_call4(Stdlib_Printf[1], ch, _r_, descr$2, _az_);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _s_, descr$2);
      if(list_test_names[1])
       var result$0 = _t_;
      else{
       var
        caml_random_state = caml_call1(Stdlib_Random[20], 0),
        base_random_state = caml_call1(Base_Random[18][4], Base_Random[18][1]),
        _al_ = caml_obj_tag(saved_caml_random_state);
       a:
       if(250 === _al_)
        var _am_ = saved_caml_random_state[1];
       else{
        if(246 !== _al_ && 244 !== _al_){
         var _am_ = saved_caml_random_state;
         break a;
        }
        var _am_ = caml_call1(CamlinternalLazy[2], saved_caml_random_state);
       }
       caml_call1(Stdlib_Random[21], _am_);
       var _an_ = caml_obj_tag(saved_base_random_state);
       a:
       if(250 === _an_)
        var _ao_ = saved_base_random_state[1];
       else{
        if(246 !== _an_ && 244 !== _an_){
         var _ao_ = saved_base_random_state;
         break a;
        }
        var _ao_ = caml_call1(CamlinternalLazy[2], saved_base_random_state);
       }
       caml_call1(Base_Random[19], _ao_);
       var result = time_without_resetting_random_(f$0);
       caml_call1(Stdlib_Random[21], caml_random_state);
       caml_call1(Base_Random[19], base_random_state);
       var result$0 = caml_call2(Stdlib_Result[8], bool_of_f, result);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _u_, time_sec[1]);
      if(0 !== result$0[0]){
       var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
       tests_failed[1]++;
       var
        backtrace$0 = hum_backtrace(backtrace),
        exn_str = caml_call1(Sexplib0_Sexp_conv[70], exn),
        sep = caml_call2(Stdlib_String[15], exn_str, 10) ? cst$7 : cst$8,
        _aB_ = string_of_module_descr(0);
       return caml_call5
               (eprintf_or_delay(_w_),
                descr$2,
                sep,
                exn_str,
                backtrace$0,
                _aB_);
      }
      if(result$0[1]) return 0;
      tests_failed[1]++;
      var _aA_ = string_of_module_descr(0);
      return caml_call2(eprintf_or_delay(_v_), descr$2, _aA_);
     }
     var _aC_ = _ax_;
    }
    else
     var _aC_ = should_run;
    return _aC_;
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     _aj_ = which_tests[1] === static_lib ? 1 : 0;
    if(! _aj_) return _aj_;
    a:
    {
     if(typeof what_to_do !== "number" && ! what_to_do[2]){var requires_partition = 0; break a;}
     var requires_partition = 1;
    }
    if(partition === cst$13 && requires_partition)
     return caml_call1(Stdlib[2], cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     _ah_ = lib === static_lib ? 1 : 0,
     _ai_ = _ah_ ? (dynamic_lib[1] = 0, 0) : _ah_;
    return _ai_;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _$_ = match[2],
     what_to_do = _$_[2],
     match$0 = _$_[1],
     which_tags = match$0[4],
     libname = match$0[1];
    function f$0(_ag_){return add_hooks(config, f, _ag_);}
    var
     _aa_ = current_tags(0),
     partial_tags = caml_call2(Stdlib[37], tags, _aa_),
     _ab_ = caml_equal([0, libname], dynamic_lib[1]),
     should_run =
       _ab_
        ? 1
         -
          caml_call2
           (Stdlib_List[34],
            function(dropped){
             return caml_call2(Stdlib_List[37], dropped, partial_tags);
            },
            which_tags[2])
        : _ab_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _ac_ = is_current(partition);
     if(_ac_){
      test_modules_ran[1]++;
      var
       descr$0 =
         displayed_descr
          (descr, def_filename, def_line_number, start_pos, end_pos),
       prev = current$0[1];
      current$0[1] = [0, [0, descr$0, tags], prev];
      try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
      catch(e$0){
       var e = caml_wrap_exception(e$0);
       current$0[1] = prev;
       throw caml_maybe_attach_backtrace(e, 0);
      }
      if(0 === x[0]) return 0;
      var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
      test_modules_failed[1]++;
      var
       backtrace$0 = hum_backtrace(backtrace),
       exn_str = caml_call1(Sexplib0_Sexp_conv[70], exn),
       sep = caml_call2(Stdlib_String[15], exn_str, 10) ? cst$9 : cst$10,
       _ad_ = string_of_module_descr(0),
       _ae_ = caml_call1(Stdlib_String[29], descr$0);
      return caml_call5
              (eprintf_or_delay(caml_call2(Stdlib[98], _y_, _x_)),
               _ae_,
               sep,
               exn_str,
               backtrace$0,
               _ad_);
     }
     var _af_ = _ac_;
    }
    else
     var _af_ = should_run;
    return _af_;
   }
   function summarize(param){
    var match = get(0);
    if(typeof match !== "number"){
     var _X_ = match[2], which_tests = _X_[1];
     if(typeof _X_[2] === "number"){
      var
       _U_ =
         caml_call3
          (Stdlib_Hashtbl[14],
           function(k, param, acc){return [0, k, acc];},
           _d_,
           0),
       _V_ = caml_call2(Stdlib_List[59], Stdlib_String[10], _U_),
       _Y_ = caml_call1(Stdlib_Printf[2], _B_);
      caml_call2(Stdlib_List[18], _Y_, _V_);
      return 0;
     }
     var match$0 = log[1];
     if(match$0){var ch = match$0[1]; caml_call1(Stdlib[76], ch);}
     print_delayed_errors(0);
     var count = tests_failed[1], count_test_modules = test_modules_failed[1];
     if(0 === count && 0 === count_test_modules){
      if(show_counts[1])
       caml_call3(Stdlib_Printf[3], _C_, tests_ran[1], test_modules_ran[1]);
      var
       unused_tests =
         caml_call2
          (Stdlib_List[44],
           function(param){var used = param[3]; return 1 - used[1];},
           which_tests[2]),
       errors = unused_tests ? [0, unused_tests] : 0;
      if(errors){
       var tests = errors[1];
       caml_call1(Stdlib_Printf[3], _D_);
       caml_call2
        (Stdlib_List[18],
         function(param){
          var line_number_opt = param[2], filename = param[1];
          if(! line_number_opt)
           return caml_call2(Stdlib_Printf[3], _F_, filename);
          var line_number = line_number_opt[1];
          return caml_call3(Stdlib_Printf[3], _E_, filename, line_number);
         },
         tests);
       caml_call1(Stdlib_Printf[3], _G_);
       return 2;
      }
      if(0 === tests_ran[1] && strict[1]){
       caml_call1(Stdlib_Printf[3], _H_);
       return 2;
      }
      return 0;
     }
     if(0 === count_test_modules)
      var _Z_ = cst$11;
     else
      var
       ___ = caml_call2(Stdlib[98], _K_, _J_),
       _Z_ = caml_call2(Stdlib_Printf[4], ___, count_test_modules);
     caml_call4(Stdlib_Printf[3], _I_, count, tests_ran[1], _Z_);
     return 1;
    }
    a:
    {
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var _W_ = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if(caml_call1(Stdlib_Filename[13], _W_) === "inline_tests_runner.exe"){caml_call1(Stdlib_Printf[3], _z_); break a;}
     }
     caml_call1(Stdlib_Printf[3], _A_);
    }
    return 2;
   }
   var
    use_color$0 = use_color[1],
    in_place$0 = in_place[1],
    diff_command$0 = diff_command[1],
    diff_path_prefix$0 = diff_path_prefix[1],
    source_tree_root$0 = source_tree_root[1],
    evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var _S_ = caml_call1(Stdlib_List[10], evaluators[1]);
    switch
     (combine_all
       (caml_call2
         (Stdlib_List[20], function(f){return caml_call1(f, 0);}, _S_))){
      case 0:
       var _T_ = 0; break;
      case 1:
       var _T_ = 2; break;
      default: var _T_ = 1;
    }
    return caml_call1(Stdlib[99], _T_);
   }
   var
    Ppx_inline_test_lib =
      [0,
       am_running,
       am_running_env_var,
       testing,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       use_color$0,
       in_place$0,
       diff_command$0,
       diff_path_prefix$0,
       source_tree_root$0,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (124, Ppx_inline_test_lib, cst_Ppx_inline_test_lib$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHB4X2lubGluZV90ZXN0X2xpYi5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHB4X2lubGluZV90ZXN0X2xpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X2xpbmUiLCJjc3RfRmlsZSIsImNzdF90aHJldyIsImNzdF9zIiwiY3N0X1BweF9pbmxpbmVfdGVzdF9saWIiLCJjc3RfVEVTIiwiY3N0X1RFU1RJTkdfRlJBTUVXT1JLIiwiY3N0X1RfTU9EVUxFX2F0IiwiY3N0X1RfTU9EVUxFUyIsImNzdF9pbmxpbmVfdGVzdF9ydW5uZXIiLCJjc3RfaW5saW5lX3Rlc3RzX2xvZyIsImNzdF9wcHhfaW5saW5lX3Rlc3RfZXJyb3JfdGhlXyIsImNhbWxfZXF1YWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX29ial90YWciLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9zeXNfZ2V0ZW52IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJjYW1sX2NhbGw2IiwiYTUiLCJnbG9iYWxfZGF0YSIsImluaXRpYWwiLCJhbV9ydW5uaW5nX2Vudl92YXIiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYiIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWJfRmlsZW5hbWUiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJTdGRsaWJfU3RyaW5nIiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYl9SZXN1bHQiLCJCYXNlIiwiQmFzZV9TdHJpbmciLCJCYXNlX0xpc3QiLCJTdGRsaWJfUmFuZG9tIiwiQmFzZV9SYW5kb20iLCJTdGRsaWJfUHJpbnRleGMiLCJCYXNlX0ludDYzIiwiVGltZV9ub3ciLCJTdGRsaWJfU2NhbmYiLCJTdGRsaWJfSGFzaHRibCIsIlN0ZGxpYl9BcmciLCJTdGRsaWJfQXJyYXkiLCJjc3Rfc3VjY2VzcyIsImNzdF9mYWlsdXJlIiwiY3N0X2Vycm9yIiwidG9fc3RyaW5nIiwicGFyYW0iLCJjb21iaW5lIiwidDEiLCJ0MiIsImNvbWJpbmVfYWxsIiwidHMiLCJ0ZXN0X21vZHVsZXNfcmFuIiwidGVzdF9tb2R1bGVzX2ZhaWxlZCIsInRlc3RzX3JhbiIsInRlc3RzX2ZhaWxlZCIsImR5bmFtaWNfbGliIiwiYWN0aW9uIiwiZHVtbXkiLCJjc3RfcHB4X2lubGluZV90ZXN0X2Nhbm5vdF91c2UiLCJjc3RfaW5fVEVTIiwiY3N0X3RpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuIiwiY3N0X1ByZWZpeF90b19wcmVwZW5kX3RvX2ZpbGVwIiwiY3N0X2RpZmZfcGF0aF9wcmVmaXgiLCJjc3RfUGF0aF90b190aGVfcm9vdF9vZl90aGVfc28iLCJjc3Rfc291cmNlX3RyZWVfcm9vdCIsImNzdF9EaWZmX2NvbW1hbmRfZm9yX3Rlc3RzX3RoYSIsImNzdF9kaWZmX2NtZCIsImNzdF9VcGRhdGVfZXhwZWN0X3Rlc3RzX2luX3BsYSIsImNzdF9pbl9wbGFjZSIsImNzdF9TdW1tYXJpemVfdGVzdHNfd2l0aG91dF91cyIsImNzdF9ub19jb2xvciIsImNzdF9sb2NhdGlvbl9SdW5fb25seV90aGVfdGVzdCIsImNzdF9vbmx5X3Rlc3QiLCJjc3Rfc3Vic3RyaW5nX09ubHlfcnVuX3Rlc3RzX3ciLCJjc3RfbWF0Y2hpbmciLCJjc3RfdGFnX09ubHlfcnVuX3Rlc3RzX3RhZ2dlZF8iLCJjc3RfcmVxdWlyZV90YWciLCJjc3RfdGFnX09ubHlfcnVuX3Rlc3RzX25vdF90YWciLCJjc3RfZHJvcF90YWciLCJjc3RfTG9nX3RoZV90ZXN0c19ydW5faW5faW5saW4iLCJjc3RfbG9nIiwiY3N0X1Nob3dfdGhlX251bWJlcl9vZl90ZXN0c19yIiwiY3N0X3Nob3dfY291bnRzIiwiY3N0X0VuZF93aXRoX2FuX2Vycm9yX2lmX25vX3RlIiwiY3N0X3N0cmljdCIsImNzdF9SdW5fdGVzdHNfb25seV91cF90b190aGVfZiIsImNzdF9zdG9wX29uX2Vycm9yIiwiY3N0X1Nob3dfdGhlX3Rlc3RzX2FzX3RoZXlfcnVuIiwiY3N0X3ZlcmJvc2UiLCJjc3RfT25seV9ydW5fdGhlX3Rlc3RzX2luX3RoZV8iLCJjc3RfcGFydGl0aW9uIiwiY3N0X0xpc3RzX2FsbF90aGVfcGFydGl0aW9uc190IiwiY3N0X2xpc3RfcGFydGl0aW9ucyIsImNzdF9Eb19ub3RfcnVuX3Rlc3RzX2J1dF9zaG93XyIsImNzdF9saXN0X3Rlc3RfbmFtZXMiLCJmb3JjZV9kcm9wIiwiZ2V0IiwiY3VycmVudCIsImZvdW5kX3Rlc3QiLCJpc19jdXJyZW50IiwicCIsImN1cnJlbnRfdGFncyIsInQiLCJtIiwidmVyYm9zZSIsInN0cmljdCIsInNob3dfY291bnRzIiwibGlzdF90ZXN0X25hbWVzIiwiZGVsYXllZF9lcnJvcnMiLCJzdG9wX29uX2Vycm9yIiwibG9nIiwidGltZV9zZWMiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsInNvdXJjZV90cmVlX3Jvb3QiLCJkaWZmX3BhdGhfcHJlZml4IiwiZGlzcGxheWVkX2Rlc2NyIiwiZGVzY3IiLCJmaWxlbmFtZSIsImxpbmUiLCJzdGFydF9wb3MiLCJlbmRfcG9zIiwibWF0Y2giLCJuYW1lIiwicmVzdCIsImxpYiIsInRlc3RzIiwibGlzdF9wYXJ0aXRpb25zIiwicGFydGl0aW9uIiwidGFnX3ByZWRpY2F0ZSIsIm5hbWVfZmlsdGVyIiwibXNnIiwiYW5vbiIsImwiLCJpIiwidGFnIiwicyIsInN0ciIsImZpbGUiLCJpbmRleCIsImluZGV4X3N0cmluZyIsImFyZ3YiLCJleG4iLCJ2IiwiYW1fdGVzdF9ydW5uZXIiLCJ2YWwiLCJhbV9ydW5uaW5nIiwidGVzdGluZyIsIndhbGxfdGltZV9jbG9ja19ucyIsIndoZXJlX3RvX2N1dF9iYWNrdHJhY2UiLCJ0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV8iLCJiZWZvcmVfbnMiLCJyZXMiLCJzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSIsInNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlIiwic3RyaW5nX29mX21vZHVsZV9kZXNjciIsInByaW50X2RlbGF5ZWRfZXJyb3JzIiwibWVzc2FnZSIsImVwcmludGZfb3JfZGVsYXkiLCJmbXQiLCJhZGRfaG9va3MiLCJDIiwiaHVtX2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInRlc3RfaW5uZXIiLCJjb25maWciLCJ0YWdzIiwiZGVmX2ZpbGVuYW1lIiwiZGVmX2xpbmVfbnVtYmVyIiwiYm9vbF9vZl9mIiwid2hhdF90b19kbyIsIndoaWNoX3RhZ3MiLCJvbmx5X3Rlc3RfbG9jYXRpb24iLCJsaWJuYW1lIiwiY29tcGxldGVfdGFncyIsInVzZWQiLCJsaW5lX251bWJlcl9vcHQiLCJwb3NpdGlvbl9zdGFydCIsImVuZF9vZl9kZWZfZmlsZW5hbWUiLCJsaW5lX251bWJlciIsImZvdW5kIiwicmVxIiwiZHJvcHBlZCIsInN1YnN0cmluZyIsInNob3VsZF9ydW4iLCJjaCIsInJlc3VsdCIsImNhbWxfcmFuZG9tX3N0YXRlIiwiYmFzZV9yYW5kb21fc3RhdGUiLCJleG5fc3RyIiwic2VwIiwic2V0X2xpYl9hbmRfcGFydGl0aW9uIiwic3RhdGljX2xpYiIsIndoaWNoX3Rlc3RzIiwicmVxdWlyZXNfcGFydGl0aW9uIiwidW5zZXRfbGliIiwidGVzdCIsImIiLCJ0ZXN0X3VuaXQiLCJ0ZXN0X21vZHVsZSIsInBhcnRpYWxfdGFncyIsInByZXYiLCJ4IiwiZSIsInN1bW1hcml6ZSIsImsiLCJhY2MiLCJjb3VudCIsImNvdW50X3Rlc3RfbW9kdWxlcyIsInVudXNlZF90ZXN0cyIsImVycm9ycyIsImV2YWx1YXRvcnMiLCJhZGRfZXZhbHVhdG9yIiwiZXhpdCIsIlBweF9pbmxpbmVfdGVzdF9saWIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcHB4X2lubGluZV90ZXN0L3J1bnRpbWUtbGliL3BweF9pbmxpbmVfdGVzdF9saWIubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBSixTQUFBO0FBQUEsSUFBQUssNEJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFWLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBakMsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQWtDLFVBQUE7QUFBQSxJQUFBbEMsTUFBQTtBQUFBLElBQUFtQyxxQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUNZa0I7QUFBQTtBQUFBLE9BQ0Q7QUFBQTtBQUFBLE9BQ0E7QUFBQSxlQUNGO0FBQUE7QUFBQSxHQUFPO0FBQUEsWUFBQUMsUUFBQUMsSUFBQUM7QUFBQUE7QUFBQUE7QUFBQUEsS0FJbEI7QUFBQTtBQUFBLGlCQUNzQjtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBRHRCLGFBRzZCO0FBQUE7QUFBQSxJQURKO0FBQUEsR0FDVztBQUFBLFlBQUFDLFlBQUFDO0FBQUFBLElBR2pCLGtEQUFpQztBQUFBO0FBQUE7QUFBQSxJQUFBQyxtQkR6QnhEO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFqRSxrQkFBQTtBQUFBLElBQUFrRSxhQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBdEUsMEJBQUE7QUFBQSxJQUFBTSx1QkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBRCx5QkFBQTtBQUFB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O0FBQUEsSUFrdkJjLGtDQUNwQjtBQUFBO0FBQUE7QUFBQSxJQUFBaU47QUFBQUEsTUE3Wlk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEL1ZyQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIFRlc3RfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBTdWNjZXNzXG4gICAgfCBGYWlsdXJlXG4gICAgfCBFcnJvclxuXG4gIGxldCB0b19leGl0X2NvZGUgPSBmdW5jdGlvblxuICAgIHwgU3VjY2VzcyAtPiAwXG4gICAgfCBGYWlsdXJlIC0+IDJcbiAgICB8IEVycm9yIC0+IDFcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFN1Y2Nlc3MgLT4gXCJzdWNjZXNzXCJcbiAgICB8IEZhaWx1cmUgLT4gXCJmYWlsdXJlXCJcbiAgICB8IEVycm9yIC0+IFwiZXJyb3JcIlxuICA7O1xuXG4gIGxldCBjb21iaW5lIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgU3VjY2VzcywgU3VjY2VzcyAtPiBTdWNjZXNzXG4gICAgfCBFcnJvciwgXyB8IF8sIEVycm9yIC0+IEVycm9yXG4gICAgfCBGYWlsdXJlLCBfIHwgXywgRmFpbHVyZSAtPiBGYWlsdXJlXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfYWxsIHRzID0gTGlzdC5mb2xkX2xlZnQgY29tYmluZSBTdWNjZXNzIHRzXG5lbmRcblxubGV0IHBhcnNlX2FyZ3YgYXJndiBsIGYgbXNnID1cbiAgdHJ5IEFyZy5wYXJzZV9hcmd2IGFyZ3YgbCBmIG1zZyB3aXRoXG4gIHwgQXJnLkJhZCBtc2cgLT5cbiAgICBQcmludGYuZXByaW50ZiBcIiVzXCIgbXNnO1xuICAgIGV4aXQgMVxuICB8IEFyZy5IZWxwIG1zZyAtPlxuICAgIFByaW50Zi5wcmludGYgXCIlc1wiIG1zZztcbiAgICBleGl0IDBcbjs7XG5cbnR5cGUgZGVzY3IgPSBzdHJpbmdcblxubGV0IHRlc3RfbW9kdWxlc19yYW4gPSByZWYgMFxubGV0IHRlc3RfbW9kdWxlc19mYWlsZWQgPSByZWYgMFxubGV0IHRlc3RzX3JhbiA9IHJlZiAwXG5sZXQgdGVzdHNfZmFpbGVkID0gcmVmIDBcbmxldCBkeW5hbWljX2xpYiA6IHN0cmluZyBvcHRpb24gcmVmID0gcmVmIE5vbmVcblxudHlwZSBmaWxlbmFtZSA9IHN0cmluZ1xudHlwZSBsaW5lX251bWJlciA9IGludFxudHlwZSBzdGFydF9wb3MgPSBpbnRcbnR5cGUgZW5kX3BvcyA9IGludFxudHlwZSBjb25maWcgPSAobW9kdWxlIElubGluZV90ZXN0X2NvbmZpZy5TKVxuXG50eXBlICdhIHRlc3RfZnVuY3Rpb25fYXJncyA9XG4gIGNvbmZpZzpjb25maWdcbiAgLT4gZGVzY3I6ZGVzY3IgTGF6eS50XG4gIC0+IHRhZ3M6c3RyaW5nIGxpc3RcbiAgLT4gZmlsZW5hbWU6ZmlsZW5hbWVcbiAgLT4gbGluZV9udW1iZXI6bGluZV9udW1iZXJcbiAgLT4gc3RhcnRfcG9zOnN0YXJ0X3Bvc1xuICAtPiBlbmRfcG9zOmVuZF9wb3NcbiAgLT4gJ2FcblxubW9kdWxlIFRhZ19wcmVkaWNhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHJlcXVpcmVkX3RhZ3MgOiBzdHJpbmcgbGlzdFxuICAgIDsgZHJvcHBlZF90YWdzIDogc3RyaW5nIGxpc3RcbiAgICB9XG5cbiAgbGV0IGluaXRpYWwgPSB7IHJlcXVpcmVkX3RhZ3MgPSBbXTsgZHJvcHBlZF90YWdzID0gWyBcImRpc2FibGVkXCIgXSB9XG5cbiAgbGV0IGRyb3AgdCB0YWcgPVxuICAgIHsgZHJvcHBlZF90YWdzID0gdGFnIDo6IHQuZHJvcHBlZF90YWdzXG4gICAgOyByZXF1aXJlZF90YWdzID0gTGlzdC5maWx0ZXIgKCggPD4gKSB0YWcpIHQucmVxdWlyZWRfdGFnc1xuICAgIH1cbiAgOztcblxuICBsZXQgcmVxdWlyZSB0IHRhZyA9XG4gICAgeyBkcm9wcGVkX3RhZ3MgPSBMaXN0LmZpbHRlciAoKCA8PiApIHRhZykgdC5kcm9wcGVkX3RhZ3NcbiAgICA7IHJlcXVpcmVkX3RhZ3MgPSB0YWcgOjogdC5yZXF1aXJlZF90YWdzXG4gICAgfVxuICA7O1xuXG4gIGxldCBlbnRpcmVfbW9kdWxlX2Rpc2FibGVkIHQgfnBhcnRpYWxfdGFnczp0YWdzID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuIGRyb3BwZWQgLT4gTGlzdC5tZW0gZHJvcHBlZCB0YWdzKSB0LmRyb3BwZWRfdGFnc1xuICA7O1xuXG4gIGxldCBkaXNhYmxlZCB0IH5jb21wbGV0ZV90YWdzOnRhZ3MgPVxuICAgIExpc3QuZXhpc3RzIChmdW4gcmVxIC0+IG5vdCAoTGlzdC5tZW0gcmVxIHRhZ3MpKSB0LnJlcXVpcmVkX3RhZ3NcbiAgICB8fCBMaXN0LmV4aXN0cyAoZnVuIGRyb3BwZWQgLT4gTGlzdC5tZW0gZHJvcHBlZCB0YWdzKSB0LmRyb3BwZWRfdGFnc1xuICA7O1xuZW5kXG5cbnR5cGUgd2hpY2hfdGVzdHMgPVxuICB7IGxpYm5hbWUgOiBzdHJpbmdcbiAgOyBvbmx5X3Rlc3RfbG9jYXRpb24gOiAoZmlsZW5hbWUgKiBsaW5lX251bWJlciBvcHRpb24gKiBib29sIHJlZikgbGlzdFxuICA7IG5hbWVfZmlsdGVyIDogc3RyaW5nIGxpc3RcbiAgOyB3aGljaF90YWdzIDogVGFnX3ByZWRpY2F0ZS50XG4gIH1cblxudHlwZSB0ZXN0X21vZGUgPVxuICB7IHdoaWNoX3Rlc3RzIDogd2hpY2hfdGVzdHNcbiAgOyB3aGF0X3RvX2RvIDogWyBgUnVuX3BhcnRpdGlvbiBvZiBzdHJpbmcgb3B0aW9uIHwgYExpc3RfcGFydGl0aW9ucyBdXG4gIH1cblxubW9kdWxlIEFjdGlvbiA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIFsgYElnbm9yZVxuICAgIHwgYFRlc3RfbW9kZSBvZiB0ZXN0X21vZGVcbiAgICBdXG5cbiAgdmFsIGdldCA6IHVuaXQgLT4gdFxuICB2YWwgc2V0IDogdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBJZ25vcmVcbiAgICB8IGBUZXN0X21vZGUgb2YgdGVzdF9tb2RlXG4gICAgXVxuXG4gIGxldCBhY3Rpb24gOiB0IHJlZiA9IHJlZiBgSWdub3JlXG5cbiAgbGV0IGZvcmNlX2Ryb3AgPVxuICAgIHRyeVxuICAgICAgaWdub3JlIChTeXMuZ2V0ZW52IFwiRk9SQ0VfRFJPUF9JTkxJTkVfVEVTVFwiIDogc3RyaW5nKTtcbiAgICAgIHRydWVcbiAgICB3aXRoXG4gICAgfCBOb3RfZm91bmQgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgZ2V0ICgpID1cbiAgICAoKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGNvbXBpbGluZyB0byBqYXZhc2NyaXB0LlxuICAgICAgIEpzX29mX29jYW1sIGNhbiBzdGF0aWNhbGx5IGV2YWx1YXRlIFtTeXMuZ2V0ZW52IFwiRk9SQ0VfRFJPUF9JTkxJTkVfVEVTVFwiXVxuICAgICAgIGFuZCBpbmxpbmUgdGhlIHJlc3VsdCAoW2BJZ25vcmVdKSB3aGVuZXZlciBbZ2V0ICgpXSBpcyBjYWxsZWQuXG4gICAgICAgVW5pdCB0ZXN0cyBjYW4gdGhlbiBiZSB0cmVhdGVkIGFzIGRlYWRjb2RlIHNpbmNlIHRoZSBhcmd1bWVudCBbZl0gb2YgdGhlIFt0ZXN0XVxuICAgICAgIGZ1bmN0aW9uIGJlbG93IGlzIG5ldmVyIHVzZWQuICopXG4gICAgaWYgZm9yY2VfZHJvcCB0aGVuIGBJZ25vcmUgZWxzZSAhYWN0aW9uXG4gIDs7XG5cbiAgbGV0IHNldCB2ID0gYWN0aW9uIDo9IHZcbmVuZFxuXG5tb2R1bGUgUGFydGl0aW9uIDogc2lnXG4gIHZhbCBmb3VuZF90ZXN0IDogdW5pdCAtPiB1bml0XG4gIHZhbCBzZXRfY3VycmVudCA6IHN0cmluZyAtPiB1bml0XG4gIHZhbCBpc19jdXJyZW50IDogc3RyaW5nIG9wdGlvbiAtPiBib29sXG4gIHZhbCBhbGwgOiB1bml0IC0+IHN0cmluZyBsaXN0XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGFsbCA9IEhhc2h0YmwuY3JlYXRlIDIzXG4gIGxldCBjdXJyZW50ID0gcmVmIFwiXCJcbiAgbGV0IHNldF9jdXJyZW50IHggPSBjdXJyZW50IDo9IHhcblxuICBsZXQgZm91bmRfdGVzdCAoKSA9XG4gICAgaWYgIWN1cnJlbnQgPD4gXCJcIiAmJiBub3QgKEhhc2h0YmwubWVtIGFsbCAhY3VycmVudCkgdGhlbiBIYXNodGJsLmFkZCBhbGwgIWN1cnJlbnQgKClcbiAgOztcblxuICBsZXQgaXNfY3VycmVudCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IHRydWVcbiAgICB8IFNvbWUgcCAtPiBwID0gIWN1cnJlbnRcbiAgOztcblxuICBsZXQgYWxsICgpID0gTGlzdC5zb3J0IFN0cmluZy5jb21wYXJlIChIYXNodGJsLmZvbGQgKGZ1biBrICgpIGFjYyAtPiBrIDo6IGFjYykgYWxsIFtdKVxuZW5kXG5cbm1vZHVsZSBNb2R1bGVfY29udGV4dCA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgb25lX21vZHVsZSA9XG4gICAgICB7IGRlc2NyIDogc3RyaW5nXG4gICAgICA7IHRhZ3MgOiBzdHJpbmcgbGlzdFxuICAgICAgfVxuXG4gICAgdHlwZSB0ID0gb25lX21vZHVsZSBsaXN0XG5cbiAgICBsZXQgZGVzY3IgdCA9IExpc3QubWFwIChmdW4gbSAtPiBtLmRlc2NyKSB0XG4gICAgbGV0IHRhZ3MgdCA9IExpc3QuY29uY2F0IChMaXN0Lm1hcCAoZnVuIG0gLT4gbS50YWdzKSB0KVxuICBlbmRcblxuICBsZXQgY3VycmVudCA6IFQudCByZWYgPSByZWYgW11cblxuICBsZXQgd2l0aF8gfmRlc2NyIH50YWdzIGYgPVxuICAgIGxldCBwcmV2ID0gIWN1cnJlbnQgaW5cbiAgICBjdXJyZW50IDo9IHsgVC5kZXNjcjsgdGFncyB9IDo6IHByZXY7XG4gICAgdHJ5XG4gICAgICBsZXQgeCA9IGYgKCkgaW5cbiAgICAgIGN1cnJlbnQgOj0gcHJldjtcbiAgICAgIHhcbiAgICB3aXRoXG4gICAgfCBlIC0+XG4gICAgICBjdXJyZW50IDo9IHByZXY7XG4gICAgICByYWlzZSBlXG4gIDs7XG5cbiAgbGV0IGN1cnJlbnRfZGVzY3IgKCkgPSBULmRlc2NyICFjdXJyZW50XG4gIGxldCBjdXJyZW50X3RhZ3MgKCkgPSBULnRhZ3MgIWN1cnJlbnRcbmVuZFxuXG5sZXQgdmVyYm9zZSA9IHJlZiBmYWxzZVxubGV0IHN0cmljdCA9IHJlZiBmYWxzZVxubGV0IHNob3dfY291bnRzID0gcmVmIGZhbHNlXG5sZXQgbGlzdF90ZXN0X25hbWVzID0gcmVmIGZhbHNlXG5sZXQgZGVsYXllZF9lcnJvcnMgPSByZWYgW11cbmxldCBzdG9wX29uX2Vycm9yID0gcmVmIGZhbHNlXG5sZXQgbG9nID0gcmVmIE5vbmVcbmxldCB0aW1lX3NlYyA9IHJlZiAwLlxubGV0IHVzZV9jb2xvciA9IHJlZiB0cnVlXG5sZXQgaW5fcGxhY2UgPSByZWYgZmFsc2VcbmxldCBkaWZmX2NvbW1hbmQgPSByZWYgTm9uZVxubGV0IHNvdXJjZV90cmVlX3Jvb3QgPSByZWYgTm9uZVxubGV0IGRpZmZfcGF0aF9wcmVmaXggPSByZWYgTm9uZVxuXG5sZXQgZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGZpbGVuYW1lIGxpbmUgc3RhcnRfcG9zIGVuZF9wb3MgPVxuICBsZXQgKGxhenkgZGVzY3IpID0gZGVzY3IgaW5cbiAgUHJpbnRmLnNwcmludGZcbiAgICBcIkZpbGUgJVMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQlc1wiXG4gICAgZmlsZW5hbWVcbiAgICBsaW5lXG4gICAgc3RhcnRfcG9zXG4gICAgZW5kX3Bvc1xuICAgIChpZiBkZXNjciA9IFwiXCIgdGhlbiBcIlwiIGVsc2UgXCI6IFwiIF4gZGVzY3IpXG47O1xuXG5sZXQgcGFyc2VfZGVzY3Igc3RyID1cbiAgdHJ5XG4gICAgU29tZVxuICAgICAgKFNjYW5mLnNzY2FuZlxuICAgICAgICAgc3RyXG4gICAgICAgICBcIiBGaWxlICVTICwgbGluZSAlZCAsIGNoYXJhY3RlcnMgJWQgLSAlZCAlIVwiXG4gICAgICAgICAoZnVuIGZpbGUgbGluZSBfc3RhcnRfcG9zIF9lbmRfcG9zIC0+IGZpbGUsIFNvbWUgbGluZSkpXG4gIHdpdGhcbiAgfCBfIC0+XG4gICAgKHRyeVxuICAgICAgIFNvbWUgKFNjYW5mLnNzY2FuZiBzdHIgXCIgRmlsZSAlUyAsIGxpbmUgJWQgJSFcIiAoZnVuIGZpbGUgbGluZSAtPiBmaWxlLCBTb21lIGxpbmUpKVxuICAgICB3aXRoXG4gICAgIHwgXyAtPlxuICAgICAgICh0cnkgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICUhXCIgKGZ1biBmaWxlIC0+IGZpbGUsIE5vbmUpKSB3aXRoXG4gICAgICAgIHwgXyAtPiBOb25lKSlcbjs7XG5cbmxldCAoKSA9XG4gIGlmIEJhc2UuRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMuYW1fdGVzdGluZ1xuICB0aGVuIChcbiAgICBtYXRjaCBBcnJheS50b19saXN0IFN5cy5hcmd2IHdpdGhcbiAgICB8IG5hbWUgOjogXCJpbmxpbmUtdGVzdC1ydW5uZXJcIiA6OiBsaWIgOjogcmVzdCAtPlxuICAgICAgKCogd2hlbiB3ZSBzZWUgdGhpcyBhcmd1bWVudCwgd2Ugc3dpdGNoIHRvIHRlc3QgbW9kZSAqKVxuICAgICAgbGV0IHRlc3RzID0gcmVmIFtdIGluXG4gICAgICBsZXQgbGlzdF9wYXJ0aXRpb25zID0gcmVmIGZhbHNlIGluXG4gICAgICBsZXQgcGFydGl0aW9uID0gcmVmIE5vbmUgaW5cbiAgICAgIGxldCB0YWdfcHJlZGljYXRlID0gcmVmIFRhZ19wcmVkaWNhdGUuaW5pdGlhbCBpblxuICAgICAgbGV0IG5hbWVfZmlsdGVyID0gcmVmIFtdIGluXG4gICAgICBwYXJzZV9hcmd2XG4gICAgICAgIChBcnJheS5vZl9saXN0IChuYW1lIDo6IHJlc3QpKVxuICAgICAgICAoQXJnLmFsaWduXG4gICAgICAgICAgIFsgKCBcIi1saXN0LXRlc3QtbmFtZXNcIlxuICAgICAgICAgICAgICwgQXJnLlVuaXRcbiAgICAgICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgICBsaXN0X3Rlc3RfbmFtZXMgOj0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmVyYm9zZSA6PSB0cnVlKVxuICAgICAgICAgICAgICwgXCIgRG8gbm90IHJ1biB0ZXN0cyBidXQgc2hvdyB3aGF0IHdvdWxkIGhhdmUgYmVlbiBydW5cIiApXG4gICAgICAgICAgIDsgKCBcIi1saXN0LXBhcnRpdGlvbnNcIlxuICAgICAgICAgICAgICwgQXJnLlVuaXQgKGZ1biAoKSAtPiBsaXN0X3BhcnRpdGlvbnMgOj0gdHJ1ZSlcbiAgICAgICAgICAgICAsIFwiIExpc3RzIGFsbCB0aGUgcGFydGl0aW9ucyB0aGF0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHRlc3Qgb3IgdGVzdF9tb2R1bGVcIiApXG4gICAgICAgICAgIDsgKCBcIi1wYXJ0aXRpb25cIlxuICAgICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIGkgLT4gcGFydGl0aW9uIDo9IFNvbWUgaSlcbiAgICAgICAgICAgICAsIFwiIE9ubHkgcnVuIHRoZSB0ZXN0cyBpbiB0aGUgZ2l2ZW4gcGFydGl0aW9uXCIgKVxuICAgICAgICAgICA7IFwiLXZlcmJvc2VcIiwgQXJnLlNldCB2ZXJib3NlLCBcIiBTaG93IHRoZSB0ZXN0cyBhcyB0aGV5IHJ1blwiXG4gICAgICAgICAgIDsgKCBcIi1zdG9wLW9uLWVycm9yXCJcbiAgICAgICAgICAgICAsIEFyZy5TZXQgc3RvcF9vbl9lcnJvclxuICAgICAgICAgICAgICwgXCIgUnVuIHRlc3RzIG9ubHkgdXAgdG8gdGhlIGZpcnN0IGVycm9yIChkb2Vzbid0IHdvcmsgZm9yIGV4cGVjdCB0ZXN0cylcIiApXG4gICAgICAgICAgIDsgXCItc3RyaWN0XCIsIEFyZy5TZXQgc3RyaWN0LCBcIiBFbmQgd2l0aCBhbiBlcnJvciBpZiBubyB0ZXN0cyB3ZXJlIHJ1blwiXG4gICAgICAgICAgIDsgXCItc2hvdy1jb3VudHNcIiwgQXJnLlNldCBzaG93X2NvdW50cywgXCIgU2hvdyB0aGUgbnVtYmVyIG9mIHRlc3RzIHJhblwiXG4gICAgICAgICAgIDsgKCBcIi1sb2dcIlxuICAgICAgICAgICAgICwgQXJnLlVuaXRcbiAgICAgICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgICAodHJ5IFN5cy5yZW1vdmUgXCJpbmxpbmVfdGVzdHMubG9nXCIgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgfCBfIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nIDo9IFNvbWUgKG9wZW5fb3V0IFwiaW5saW5lX3Rlc3RzLmxvZ1wiKSlcbiAgICAgICAgICAgICAsIFwiIExvZyB0aGUgdGVzdHMgcnVuIGluIGlubGluZV90ZXN0cy5sb2dcIiApXG4gICAgICAgICAgIDsgKCBcIi1kcm9wLXRhZ1wiXG4gICAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gcyAtPiB0YWdfcHJlZGljYXRlIDo9IFRhZ19wcmVkaWNhdGUuZHJvcCAhdGFnX3ByZWRpY2F0ZSBzKVxuICAgICAgICAgICAgICwgXCJ0YWcgT25seSBydW4gdGVzdHMgbm90IHRhZ2dlZCB3aXRoIFt0YWddIChvdmVycmlkZXMgcHJldmlvdXMgXFxcbiAgICAgICAgICAgICAgICAtcmVxdWlyZS10YWcpXCIgKVxuICAgICAgICAgICA7ICggXCItcmVxdWlyZS10YWdcIlxuICAgICAgICAgICAgICwgQXJnLlN0cmluZ1xuICAgICAgICAgICAgICAgICAoZnVuIHMgLT4gdGFnX3ByZWRpY2F0ZSA6PSBUYWdfcHJlZGljYXRlLnJlcXVpcmUgIXRhZ19wcmVkaWNhdGUgcylcbiAgICAgICAgICAgICAsIFwidGFnIE9ubHkgcnVuIHRlc3RzIHRhZ2dlZCB3aXRoIFt0YWddIChvdmVycmlkZXMgcHJldmlvdXMgLWRyb3AtdGFnKVwiIClcbiAgICAgICAgICAgOyAoIFwiLW1hdGNoaW5nXCJcbiAgICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IG5hbWVfZmlsdGVyIDo9IHMgOjogIW5hbWVfZmlsdGVyKVxuICAgICAgICAgICAgICwgXCJzdWJzdHJpbmcgT25seSBydW4gdGVzdHMgd2hvc2UgbmFtZXMgY29udGFpbiB0aGUgZ2l2ZW4gc3Vic3RyaW5nXCIgKVxuICAgICAgICAgICA7ICggXCItb25seS10ZXN0XCJcbiAgICAgICAgICAgICAsIEFyZy5TdHJpbmdcbiAgICAgICAgICAgICAgICAgKGZ1biBzIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSwgaW5kZXggPVxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIHBhcnNlX2Rlc2NyIHMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSAoZmlsZSwgaW5kZXgpIC0+IGZpbGUsIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgcyAnOidcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc6JyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBTdHJpbmcuc3ViIHMgMCBpIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleF9zdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZy5zdWIgcyAoaSArIDEpIChTdHJpbmcubGVuZ3RoIHMgLSBpIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgaW50X29mX3N0cmluZyBpbmRleF9zdHJpbmcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFyZ3VtZW50ICVzIGRvZXNuJ3QgZml0IHRoZSBmb3JtYXQgZmlsZW5hbWVbOmxpbmVfbnVtYmVyXVxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlIVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUsIFNvbWUgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHMsIE5vbmVcbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgdGVzdHMgOj0gKGZpbGVuYW1lLCBpbmRleCwgcmVmIGZhbHNlKSA6OiAhdGVzdHMpXG4gICAgICAgICAgICAgLCBcImxvY2F0aW9uIFJ1biBvbmx5IHRoZSB0ZXN0cyBzcGVjaWZpZWQgYnkgYWxsIHRoZSAtb25seS10ZXN0IG9wdGlvbnMuXFxuXFxcbiAgICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgICAgIExvY2F0aW9ucyBjYW4gYmUgb25lIG9mIHRoZXNlIGZvcm1zOlxcblxcXG4gICAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIGZpbGUubWxcXG5cXFxuICAgICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgLSBmaWxlLm1sOmxpbmVfbnVtYmVyXFxuXFxcbiAgICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgICAgIC0gRmlsZSBcXFwiZmlsZS5tbFxcXCJcXG5cXFxuICAgICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIiwgbGluZSAyM1xcblxcXG4gICAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzLCBjaGFyYWN0ZXJzIDItM1wiIClcbiAgICAgICAgICAgOyBcIi1uby1jb2xvclwiLCBBcmcuQ2xlYXIgdXNlX2NvbG9yLCBcIiBTdW1tYXJpemUgdGVzdHMgd2l0aG91dCB1c2luZyBjb2xvclwiXG4gICAgICAgICAgIDsgXCItaW4tcGxhY2VcIiwgQXJnLlNldCBpbl9wbGFjZSwgXCIgVXBkYXRlIGV4cGVjdCB0ZXN0cyBpbiBwbGFjZVwiXG4gICAgICAgICAgIDsgKCBcIi1kaWZmLWNtZFwiXG4gICAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gcyAtPiBkaWZmX2NvbW1hbmQgOj0gU29tZSBzKVxuICAgICAgICAgICAgICwgXCIgRGlmZiBjb21tYW5kIGZvciB0ZXN0cyB0aGF0IHJlcXVpcmUgZGlmZmluZyAodXNlIC0gdG8gZGlzYWJsZSBkaWZmaW5nKVwiIClcbiAgICAgICAgICAgOyAoIFwiLXNvdXJjZS10cmVlLXJvb3RcIlxuICAgICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIHMgLT4gc291cmNlX3RyZWVfcm9vdCA6PSBTb21lIHMpXG4gICAgICAgICAgICAgLCBcIiBQYXRoIHRvIHRoZSByb290IG9mIHRoZSBzb3VyY2UgdHJlZVwiIClcbiAgICAgICAgICAgOyAoIFwiLWRpZmYtcGF0aC1wcmVmaXhcIlxuICAgICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIHMgLT4gZGlmZl9wYXRoX3ByZWZpeCA6PSBTb21lIHMpXG4gICAgICAgICAgICAgLCBcIiBQcmVmaXggdG8gcHJlcGVuZCB0byBmaWxlcGF0aHMgaW4gdGVzdCBvdXRwdXRcIiApXG4gICAgICAgICAgIF0pXG4gICAgICAgIChmdW4gYW5vbiAtPlxuICAgICAgICAgICBQcmludGYuZXByaW50ZiBcIiVzOiB1bmV4cGVjdGVkIGFub255bW91cyBhcmd1bWVudCAlc1xcbiUhXCIgbmFtZSBhbm9uO1xuICAgICAgICAgICBleGl0IDEpXG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcIiVzICVzICVzIFthcmdzXVwiIG5hbWUgXCJpbmxpbmUtdGVzdC1ydW5uZXJcIiBsaWIpO1xuICAgICAgQWN0aW9uLnNldFxuICAgICAgICAoYFRlc3RfbW9kZVxuICAgICAgICAgICB7IHdoaWNoX3Rlc3RzID1cbiAgICAgICAgICAgICAgIHsgbGlibmFtZSA9IGxpYlxuICAgICAgICAgICAgICAgOyBvbmx5X3Rlc3RfbG9jYXRpb24gPSAhdGVzdHNcbiAgICAgICAgICAgICAgIDsgd2hpY2hfdGFncyA9ICF0YWdfcHJlZGljYXRlXG4gICAgICAgICAgICAgICA7IG5hbWVfZmlsdGVyID0gIW5hbWVfZmlsdGVyXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIDsgd2hhdF90b19kbyA9XG4gICAgICAgICAgICAgICAoaWYgIWxpc3RfcGFydGl0aW9ucyB0aGVuIGBMaXN0X3BhcnRpdGlvbnMgZWxzZSBgUnVuX3BhcnRpdGlvbiAhcGFydGl0aW9uKVxuICAgICAgICAgICB9KVxuICAgIHwgXyAtPiAoKSlcbjs7XG5cbmxldCBhbV90ZXN0X3J1bm5lciA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBUZXN0X21vZGUgXyAtPiB0cnVlXG4gIHwgYElnbm9yZSAtPiBmYWxzZVxuOztcblxubGV0IGFtX3J1bm5pbmdfZW52X3ZhciA9XG4gICgqIGZvciBhcHByb3hpbWF0ZSBjb21wYXRpYmlsaXR5LCBnaXZlbiB0aGF0IHRoZSB2YXJpYWJsZSBpcyBub3QgZXhhY3RseSBlcXVpdmFsZW50XG4gICAgIHRvIHdoYXQgUFBYX0lOTElORV9URVNUX0xJQl9BTV9SVU5OSU5HX0lOTElORV9URVNUIHVzZWQgdG8gYmUgKilcbiAgXCJURVNUSU5HX0ZSQU1FV09SS1wiXG47O1xuXG4oKiBUaGlzIHZhbHVlIGlzIGRlcHJlY2F0ZWQgaW4gcHJpbmNpcGxlLCBpbiBmYXZvciBvZiBDb3JlLmFtX3J1bm5pbmdfdGVzdCwgc29cbiAgIHdlJ3JlIGdvaW5nIHRvIGxpdmUgd2l0aCB0aGUgdWdseSBwYXR0ZXJuIG1hdGNoLiAqKVxubGV0IGFtX3J1bm5pbmcgPVxuICBtYXRjaCBTeXMuZ2V0ZW52IFwiUFBYX0lOTElORV9URVNUX0xJQl9BTV9SVU5OSU5HX0lOTElORV9URVNUXCIgd2l0aFxuICB8IChfIDogc3RyaW5nKSAtPlxuICAgIHRydWUgKCogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwZW9wbGUgc2V0dGluZyB0aGlzIHZhcmlhYmxlIGRpcmVjdGx5ICopXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgIChtYXRjaCBTeXMuZ2V0ZW52IGFtX3J1bm5pbmdfZW52X3ZhciB3aXRoXG4gICAgIHwgXCJpbmxpbmUtdGVzdFwiIC0+IHRydWVcbiAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGZhbHNlXG4gICAgIHwgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCB0ZXN0aW5nID1cbiAgaWYgYW1fdGVzdF9ydW5uZXJcbiAgdGhlbiBgVGVzdGluZyBgQW1fdGVzdF9ydW5uZXJcbiAgZWxzZSBpZiBhbV9ydW5uaW5nXG4gIHRoZW4gYFRlc3RpbmcgYEFtX2NoaWxkX29mX3Rlc3RfcnVubmVyXG4gIGVsc2UgYE5vdF90ZXN0aW5nXG47O1xuXG5sZXQgd2FsbF90aW1lX2Nsb2NrX25zICgpID0gVGltZV9ub3cubmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaCAoKVxuXG5sZXQgd2hlcmVfdG9fY3V0X2JhY2t0cmFjZSA9XG4gIGxhenlcbiAgICAoQmFzZS5TdHJpbmcuU2VhcmNoX3BhdHRlcm4uY3JlYXRlXG4gICAgICAgKF9fTU9EVUxFX18gXiBcIi5cIiBeIFwidGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNcIikpXG47O1xuXG5sZXQgdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBiZWZvcmVfbnMgPSB3YWxsX3RpbWVfY2xvY2tfbnMgKCkgaW5cbiAgbGV0IHJlcyA9XG4gICAgKCogVG8gYXZvaWQgbm9pc2UgaW4gYmFja3RyYWNlcywgd2UgZG8gdHdvIHRoaW5ncy5cblxuICAgICAgIFdlIHVzZSBbd2hlcmVfdG9fY3V0X2JhY2t0cmFjZV0gYWJvdmUgdG8gcmVtb3ZlIHRoZSBzdGFjayBmcmFtZXMgZm9yIHRoZSBjdXJyZW50XG4gICAgICAgZnVuY3Rpb24gYW5kIGFueSBmdW5jdGlvbiBpdCBnZXRzIGlubGluZWQgaW50bywgYXMgaXQncyBub3Qgb2YgYW55IGludGVyZXN0IHRvIHRoZVxuICAgICAgIHVzZXIsIHNpbmNlIGl0J3Mgbm90IHRhbGtpbmcgYWJvdXQgdGhlaXIgdGVzdCBidXQgaW5zdGVhZCB0YWxraW5nIGFib3V0IHRoZVxuICAgICAgIHBweF9pbmxpbmVfdGVzdCBtYWNoaW5lcnkuXG5cbiAgICAgICBXZSBhbHNvIGF2b2lkIGluc2VydGluZyBhbnkgY29kZSBiZXR3ZWVuIHRoZSBbZl0gdGhhdCBjb21lcyBmcm9tIHRoZSB1c2VyJ3MgZmlsZVxuICAgICAgIGFuZCBncmFiYmluZyB0aGUgYmFja3RyYWNlIGZyb20gaXRzIGV4Y2VwdGlvbnMgKG5vIHdyYXBwaW5nIG9mIFtmXSB3aXRoIGhpZ2ggb3JkZXJcbiAgICAgICBmdW5jdGlvbnMgbGlrZSBFeG4ucHJvdGVjdCwgb3IgKGZ1biAoKSAtPiBmICgpOyB0cnVlKSkuICopXG4gICAgdHJ5IE9rIChmICgpKSB3aXRoXG4gICAgfCBleG4gLT4gRXJyb3IgKGV4biwgUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKSlcbiAgaW5cbiAgdGltZV9zZWMgOj0gQmFzZS5JbnQ2My4od2FsbF90aW1lX2Nsb2NrX25zICgpIC0gYmVmb3JlX25zIHw+IHRvX2Zsb2F0KSAvLiAxZTk7XG4gIHJlc1xuOztcblxubGV0IHNhdmVkX2NhbWxfcmFuZG9tX3N0YXRlID0gbGF6eSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDEwMDsgMjAwOyAzMDAgfF0pXG5sZXQgc2F2ZWRfYmFzZV9yYW5kb21fc3RhdGUgPSBsYXp5IChCYXNlLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDExMTsgMjIyOyAzMzMgfF0pXG5cbmxldCB0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBjYW1sX3JhbmRvbV9zdGF0ZSA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gIGxldCBiYXNlX3JhbmRvbV9zdGF0ZSA9IEJhc2UuUmFuZG9tLlN0YXRlLmNvcHkgQmFzZS5SYW5kb20uU3RhdGUuZGVmYXVsdCBpblxuICBTdGRsaWIuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSk7XG4gIEJhc2UuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSk7XG4gIGxldCByZXN1bHQgPSB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmIGluXG4gIFN0ZGxpYi5SYW5kb20uc2V0X3N0YXRlIGNhbWxfcmFuZG9tX3N0YXRlO1xuICBCYXNlLlJhbmRvbS5zZXRfc3RhdGUgYmFzZV9yYW5kb21fc3RhdGU7XG4gIHJlc3VsdFxuOztcblxubGV0IHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkgPVxuICBTdHJpbmcuY29uY2F0XG4gICAgXCJcIlxuICAgIChMaXN0Lm1hcFxuICAgICAgIChmdW4gcyAtPiBcIiAgaW4gVEVTXCIgXiBcIlRfTU9EVUxFIGF0IFwiIF4gU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBzIF4gXCJcXG5cIilcbiAgICAgICAoTW9kdWxlX2NvbnRleHQuY3VycmVudF9kZXNjciAoKSkpXG47O1xuXG5sZXQgcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBsID1cbiAgTGlzdC5leGlzdHNcbiAgICAoZnVuIChmaWxlbmFtZSwgbGluZV9udW1iZXJfb3B0LCB1c2VkKSAtPlxuICAgICAgIGxldCBwb3NpdGlvbl9zdGFydCA9IFN0cmluZy5sZW5ndGggZGVmX2ZpbGVuYW1lIC0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgICAgIGxldCBmb3VuZCA9XG4gICAgICAgICBwb3NpdGlvbl9zdGFydCA+PSAwXG4gICAgICAgICAmJlxuICAgICAgICAgbGV0IGVuZF9vZl9kZWZfZmlsZW5hbWUgPVxuICAgICAgICAgICBTdHJpbmcuc3ViIGRlZl9maWxlbmFtZSBwb3NpdGlvbl9zdGFydCAoU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSlcbiAgICAgICAgIGluXG4gICAgICAgICBlbmRfb2ZfZGVmX2ZpbGVuYW1lID0gZmlsZW5hbWVcbiAgICAgICAgICYmIChwb3NpdGlvbl9zdGFydCA9IDAgfHwgZGVmX2ZpbGVuYW1lLltwb3NpdGlvbl9zdGFydCAtIDFdID0gJy8nKVxuICAgICAgICAgJiZcbiAgICAgICAgIG1hdGNoIGxpbmVfbnVtYmVyX29wdCB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IGRlZl9saW5lX251bWJlciA9IGxpbmVfbnVtYmVyXG4gICAgICAgaW5cbiAgICAgICBpZiBmb3VuZCB0aGVuIHVzZWQgOj0gdHJ1ZTtcbiAgICAgICBmb3VuZClcbiAgICBsXG47O1xuXG5sZXQgbmFtZV9maWx0ZXJfbWF0Y2ggfm5hbWVfZmlsdGVyIGRlc2NyID1cbiAgbWF0Y2ggbmFtZV9maWx0ZXIgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBfIDo6IF8gLT5cbiAgICBMaXN0LmV4aXN0cyAoZnVuIHN1YnN0cmluZyAtPiBCYXNlLlN0cmluZy5pc19zdWJzdHJpbmcgfnN1YnN0cmluZyBkZXNjcikgbmFtZV9maWx0ZXJcbjs7XG5cbmxldCBwcmludF9kZWxheWVkX2Vycm9ycyAoKSA9XG4gIG1hdGNoIExpc3QucmV2ICFkZWxheWVkX2Vycm9ycyB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCBfIDo6IF8gYXMgZGVsYXllZF9lcnJvcnMgLT5cbiAgICBQcmludGYuZXByaW50ZiBcIlxcbiVzXFxuJSFcIiAoU3RyaW5nLm1ha2UgNzAgJz0nKTtcbiAgICBMaXN0Lml0ZXIgKGZ1biBtZXNzYWdlIC0+IFByaW50Zi5lcHJpbnRmIFwiJXMlIVwiIG1lc3NhZ2UpIGRlbGF5ZWRfZXJyb3JzXG47O1xuXG5sZXQgZXByaW50Zl9vcl9kZWxheSBmbXQgPVxuICBQcmludGYua3NwcmludGZcbiAgICAoZnVuIHMgLT5cbiAgICAgICBpZiAhdmVyYm9zZSB0aGVuIGRlbGF5ZWRfZXJyb3JzIDo9IHMgOjogIWRlbGF5ZWRfZXJyb3JzIGVsc2UgUHJpbnRmLmVwcmludGYgXCIlcyUhXCIgcztcbiAgICAgICBpZiAhc3RvcF9vbl9lcnJvclxuICAgICAgIHRoZW4gKFxuICAgICAgICAgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCk7XG4gICAgICAgICBleGl0IDIpKVxuICAgIGZtdFxuOztcblxubGV0IGFkZF9ob29rcyAoKG1vZHVsZSBDKSA6IGNvbmZpZykgZiAoKSA9XG4gIEMucHJlX3Rlc3RfaG9vayAoKTtcbiAgZiAoKVxuOztcblxubGV0IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlID1cbiAgbGV0IG9wZW4gQmFzZSBpblxuICBiYWNrdHJhY2VcbiAgfD4gU3RyaW5nLnNwbGl0X2xpbmVzXG4gIHw+IExpc3QudGFrZV93aGlsZSB+ZjooZnVuIHN0ciAtPlxuICAgIG5vdCAoU3RyaW5nLlNlYXJjaF9wYXR0ZXJuLm1hdGNoZXMgKGZvcmNlIHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UpIHN0cikpXG4gIHw+IExpc3QubWFwIH5mOihmdW4gc3RyIC0+IFwiICBcIiBeIHN0ciBeIFwiXFxuXCIpXG4gIHw+IFN0cmluZy5jb25jYXRcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X2lubmVyXG4gICAgICAgICAgICAgICAgICAgICB+Y29uZmlnXG4gICAgICAgICAgICAgICAgICAgICB+ZGVzY3JcbiAgICAgICAgICAgICAgICAgICAgIH50YWdzXG4gICAgICAgICAgICAgICAgICAgICB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lXG4gICAgICAgICAgICAgICAgICAgICB+bGluZV9udW1iZXI6ZGVmX2xpbmVfbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICAgICB+ZW5kX3Bvc1xuICAgICAgICAgICAgICAgICAgICAgZlxuICAgICAgICAgICAgICAgICAgICAgYm9vbF9vZl9mXG4gID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGVcbiAgICAgIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbjsgd2hpY2hfdGFnczsgbmFtZV9maWx0ZXIgfVxuICAgICAgOyB3aGF0X3RvX2RvXG4gICAgICB9IC0+XG4gICAgbGV0IGYgPSBhZGRfaG9va3MgY29uZmlnIGYgaW5cbiAgICBsZXQgZGVzY3IgPVxuICAgICAgbGF6eSAoZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgc3RhcnRfcG9zIGVuZF9wb3MpXG4gICAgaW5cbiAgICBsZXQgY29tcGxldGVfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICYmIChtYXRjaCBvbmx5X3Rlc3RfbG9jYXRpb24gd2l0aFxuICAgICAgICB8IFtdIC0+IHRydWVcbiAgICAgICAgfCBfIDo6IF8gLT4gcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBvbmx5X3Rlc3RfbG9jYXRpb24pXG4gICAgICAmJiAobm90IChUYWdfcHJlZGljYXRlLmRpc2FibGVkIHdoaWNoX3RhZ3MgfmNvbXBsZXRlX3RhZ3MpKVxuICAgICAgJiYgbmFtZV9maWx0ZXJfbWF0Y2ggfm5hbWVfZmlsdGVyIChMYXp5LmZvcmNlIGRlc2NyKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1blxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgLT4gUGFydGl0aW9uLmZvdW5kX3Rlc3QgKClcbiAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gcGFydGl0aW9uIC0+XG4gICAgICAgIGlmIFBhcnRpdGlvbi5pc19jdXJyZW50IHBhcnRpdGlvblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgZGVzY3IgPSBMYXp5LmZvcmNlIGRlc2NyIGluXG4gICAgICAgICAgaW5jciB0ZXN0c19yYW47XG4gICAgICAgICAgKG1hdGNoICFsb2cgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgfCBTb21lIGNoIC0+IFByaW50Zi5mcHJpbnRmIGNoIFwiJXNcXG4lc1wiIGRlc2NyIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSk7XG4gICAgICAgICAgaWYgIXZlcmJvc2UgdGhlbiBQcmludGYucHJpbnRmIFwiJXMlIVwiIGRlc2NyO1xuICAgICAgICAgIGxldCByZXN1bHQgPVxuICAgICAgICAgICAgaWYgIWxpc3RfdGVzdF9uYW1lc1xuICAgICAgICAgICAgdGhlbiBPayB0cnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgqIFNlZSBbdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNdIGZvciB3aHkgd2UgdXNlIFtib29sX29mX2ZdXG4gICAgICAgICAgICAgICAgIHJhdGhlciBoYXZlIHRoZSBjYWxsZXIgd3JhcCBbZl0gdG8gYWRqdXN0IGl0cyByZXR1cm4gdmFsdWUuICopXG4gICAgICAgICAgICAgIFJlc3VsdC5tYXAgYm9vbF9vZl9mICh0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZilcbiAgICAgICAgICBpblxuICAgICAgICAgICgqIElmICFsaXN0X3Rlc3RfbmFtZXMsIHRoaXMgaXMgaXMgYSBoYXJtbGVzcyB6ZXJvLiAqKVxuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gUHJpbnRmLnByaW50ZiBcIiAoJS4zZiBzZWMpXFxuJSFcIiAhdGltZV9zZWM7XG4gICAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIHRydWUgLT4gKClcbiAgICAgICAgICB8IE9rIGZhbHNlIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgXCIlcyBpcyBmYWxzZS5cXG4lc1xcbiUhXCIgZGVzY3IgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXlcbiAgICAgICAgICAgICAgXCIlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCJcbiAgICAgICAgICAgICAgZGVzY3JcbiAgICAgICAgICAgICAgc2VwXG4gICAgICAgICAgICAgIGV4bl9zdHJcbiAgICAgICAgICAgICAgYmFja3RyYWNlXG4gICAgICAgICAgICAgIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSkpXG47O1xuXG5sZXQgc2V0X2xpYl9hbmRfcGFydGl0aW9uIHN0YXRpY19saWIgcGFydGl0aW9uID1cbiAgbWF0Y2ggIWR5bmFtaWNfbGliIHdpdGhcbiAgfCBTb21lIF8gLT5cbiAgICAoKiBwb3NzaWJsZSBpZiB0aGUgaW50ZXJmYWNlIGlzIHVzZWQgZXhwbGljaXRseSBvciBpZiB3ZSBoYXBwZW4gdG8gZHlubGluayBzb21ldGhpbmdcbiAgICAgICB0aGF0IGNvbnRhaW4gdGVzdHMgKilcbiAgICAoKVxuICB8IE5vbmUgLT5cbiAgICBkeW5hbWljX2xpYiA6PSBTb21lIHN0YXRpY19saWI7XG4gICAgKG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICAgICB8IGBJZ25vcmUgLT4gKClcbiAgICAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHM7IHdoYXRfdG9fZG8gfSAtPlxuICAgICAgIGlmIHdoaWNoX3Rlc3RzLmxpYm5hbWUgPSBzdGF0aWNfbGliXG4gICAgICAgdGhlbiAoXG4gICAgICAgICBsZXQgcmVxdWlyZXNfcGFydGl0aW9uID1cbiAgICAgICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICAgICAgIHwgYExpc3RfcGFydGl0aW9ucyB8IGBSdW5fcGFydGl0aW9uIChTb21lIF8pIC0+IHRydWVcbiAgICAgICAgICAgfCBgUnVuX3BhcnRpdGlvbiBOb25lIC0+IGZhbHNlXG4gICAgICAgICBpblxuICAgICAgICAgaWYgcGFydGl0aW9uID0gXCJcIiAmJiByZXF1aXJlc19wYXJ0aXRpb25cbiAgICAgICAgIHRoZW5cbiAgICAgICAgICAgZmFpbHdpdGhcbiAgICAgICAgICAgICBcInBweF9pbmxpbmVfdGVzdDogY2Fubm90IHVzZSAtbGlzdC1wYXJ0aXRpb24gb3IgLXBhcnRpdGlvbiB3aXRob3V0IFxcXG4gICAgICAgICAgICAgIHNwZWNpZnlpbmcgYSBwYXJ0aXRpb24gYXQgcHJlcHJvY2Vzc2luZyB0aW1lXCJcbiAgICAgICAgIGVsc2UgUGFydGl0aW9uLnNldF9jdXJyZW50IHBhcnRpdGlvbikpXG47O1xuXG5sZXQgdW5zZXRfbGliIHN0YXRpY19saWIgPVxuICBtYXRjaCAhZHluYW1pY19saWIgd2l0aFxuICB8IE5vbmUgLT5cbiAgICAoKiBub3QgZ2l2aW5nIGFuIGVycm9yLCBiZWNhdXNlIHdoZW4gc29tZSBhbm5veWluZyBwZW9wbGUgcHV0IHBhX291bml0IGluIHRoZWlyIGxpc3RcbiAgICAgICBvZiBwcmVwcm9jZXNzb3JzLCBwYV9vdW5pdCBpcyBzZXQgdXAgdHdpY2UgYW5kIHdlIGhhdmUgdHdvIGNhbGxzIHRvIHVuc2V0X2xpYiBhdFxuICAgICAgIHRoZSBlbmQgb2YgdGhlIGZpbGUsIGFuZCB0aGUgc2Vjb25kIG9uZSBjb21lcyBpbiB0aGlzIGJyYW5jaCAqKVxuICAgICgpXG4gIHwgU29tZSBsaWIgLT4gaWYgbGliID0gc3RhdGljX2xpYiB0aGVuIGR5bmFtaWNfbGliIDo9IE5vbmVcbjs7XG5cbmxldCB0ZXN0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiAoZnVuIGIgLT5cbiAgICBiKVxuOztcblxubGV0IHRlc3RfdW5pdCB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgKGZ1biAoKSAtPlxuICAgIHRydWUpXG47O1xuXG5sZXRbQGlubGluZSBuZXZlcl0gdGVzdF9tb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgIH5jb25maWdcbiAgICAgICAgICAgICAgICAgICAgIH5kZXNjclxuICAgICAgICAgICAgICAgICAgICAgfnRhZ3NcbiAgICAgICAgICAgICAgICAgICAgIH5maWxlbmFtZTpkZWZfZmlsZW5hbWVcbiAgICAgICAgICAgICAgICAgICAgIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgICAgICAgICAgICAgICAgICAgIH5zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgICAgIH5lbmRfcG9zXG4gICAgICAgICAgICAgICAgICAgICBmXG4gID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGVcbiAgICAgIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbiA9IF87IG5hbWVfZmlsdGVyID0gXzsgd2hpY2hfdGFncyB9XG4gICAgICA7IHdoYXRfdG9fZG9cbiAgICAgIH0gLT5cbiAgICBsZXQgZiA9IGFkZF9ob29rcyBjb25maWcgZiBpblxuICAgIGxldCBkZXNjciAoKSA9IGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zIGluXG4gICAgbGV0IHBhcnRpYWxfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICgqIElmLCBubyBtYXR0ZXIgd2hhdCB0YWdzIGEgdGVzdCBkZWZpbmVzLCB3ZSBjZXJ0YWlubHkgd2lsbCBkcm9wIGFsbCB0ZXN0cyB3aXRoaW5cbiAgICAgICAgIHRoaXMgbW9kdWxlLCB0aGVuIGRvbid0IHJ1biB0aGUgbW9kdWxlIGF0IGFsbC4gVGhpcyBtZWFucyBwZW9wbGUgY2FuIHdyaXRlXG4gICAgICAgICB0aGluZ3MgbGlrZSB0aGUgZm9sbG93aW5nIHdpdGhvdXQgYnJlYWtpbmcgdGhlIDMyLWJpdCBidWlsZDpcbiAgICAgICAgIGxldCV0ZXN0X21vZHVsZSBbQHRhZ3MgXCI2NC1iaXRzLW9ubHlcIl0gPSAobW9kdWxlIHN0cnVjdFxuICAgICAgICAgbGV0IGkgPSBJbnQ2NC50b19pbnRfZXhuIC4uLi5cbiAgICAgICAgIGVuZClcbiAgICAgICAgIFdlIGRvbid0IHNob3J0Y3V0IGJhc2VkIG9uIHBvc2l0aW9uLCBhcyB3ZSBjYW4ndCB0ZWxsIHdoYXQgcG9zaXRpb25zIHRoZVxuICAgICAgICAgaW5uZXIgdGVzdHMgd2lsbCBoYXZlLiAqKVxuICAgICAgJiYgbm90IChUYWdfcHJlZGljYXRlLmVudGlyZV9tb2R1bGVfZGlzYWJsZWQgd2hpY2hfdGFncyB+cGFydGlhbF90YWdzKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1blxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgLT4gUGFydGl0aW9uLmZvdW5kX3Rlc3QgKClcbiAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gcGFydGl0aW9uIC0+XG4gICAgICAgIGlmIFBhcnRpdGlvbi5pc19jdXJyZW50IHBhcnRpdGlvblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19yYW47XG4gICAgICAgICAgbGV0IGRlc2NyID0gZGVzY3IgKCkgaW5cbiAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgTW9kdWxlX2NvbnRleHQud2l0aF8gfmRlc2NyIH50YWdzIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgKCogV2UgZG8gbm90IHJlc2V0IHJhbmRvbSBzdGF0ZXMgdXBvbiBlbnRlcmluZyBbbGV0JXRlc3RfbW9kdWxlXS5cblxuICAgICAgICAgICAgICAgICBDb246IENvZGUgaW4gdGVzdCBtb2R1bGVzIGNhbiBhY2NpZGVudGFsbHkgZGVwZW5kIG9uIHRvcC1sZXZlbCByYW5kb21cbiAgICAgICAgICAgICAgICAgc3RhdGUgZWZmZWN0cy5cblxuICAgICAgICAgICAgICAgICBQcm9zOiAoMSkgV2UgZG9uJ3QgcmVzZXQgdG8gdGhlIHNhbWUgc2VlZCBvbiBlbnRlcmluZyBhIFtsZXQldGVzdF9tb2R1bGVdXG4gICAgICAgICAgICAgICAgIGFuZCB0aGVuIGEgW2xldCV0ZXN0XSBpbnNpZGUgdGhhdCBtb2R1bGUsIHdoaWNoIGNvdWxkIGxlYWQgdG9cbiAgICAgICAgICAgICAgICAgYWNjaWRlbnRhbGx5IHJhbmRvbWx5IGdlbmVyYXRpbmcgdGhlIHNhbWUgdmFsdWVzIGluIHNvbWUgdGVzdC4gKDIpIE1vdmluZ1xuICAgICAgICAgICAgICAgICBjb2RlIGludG8gYW5kIG91dCBvZiBbbGV0JXRlc3RfbW9kdWxlXSBkb2VzIG5vdCBjaGFuZ2UgaXRzIHJhbmRvbSBzZWVkLlxuICAgICAgICAgICAgICAqKVxuICAgICAgICAgICAgICB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmKVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19mYWlsZWQ7XG4gICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgaW5cbiAgICAgICAgICAgIGxldCBleG5fc3RyID0gU2V4cGxpYjAuU2V4cF9jb252LnByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biBpblxuICAgICAgICAgICAgbGV0IHNlcCA9IGlmIFN0cmluZy5jb250YWlucyBleG5fc3RyICdcXG4nIHRoZW4gXCJcXG5cIiBlbHNlIFwiIFwiIGluXG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5XG4gICAgICAgICAgICAgIChcIlRFU1wiIF5eIFwiVF9NT0RVTEUgYXQgJXMgdGhyZXclcyVzLlxcbiVzJXNcXG4lIVwiKVxuICAgICAgICAgICAgICAoU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBkZXNjcilcbiAgICAgICAgICAgICAgc2VwXG4gICAgICAgICAgICAgIGV4bl9zdHJcbiAgICAgICAgICAgICAgYmFja3RyYWNlXG4gICAgICAgICAgICAgIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSkpXG47O1xuXG5sZXQgc3VtbWFyaXplICgpID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPlxuICAgIGlmIFN5cy5hcmd2IDw+IFt8fF0gJiYgRmlsZW5hbWUuYmFzZW5hbWUgU3lzLmFyZ3YuKDApID0gXCJpbmxpbmVfdGVzdHNfcnVubmVyLmV4ZVwiXG4gICAgdGhlblxuICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgXCJpbmxpbmVfdGVzdHNfcnVubmVyLmV4ZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcnVuIGJ5IGhhbmQsIHlvdSBcXG5cXFxuICAgICAgICAgc2hvdWxkIHJ1biB0aGUgaW5saW5lX3Rlc3RzX3J1bm5lciBzY3JpcHQgaW5zdGVhZC5cXG5cXFxuICAgICAgICAgJSFcIlxuICAgIGVsc2VcbiAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgIFwiWW91IGFyZSBkb2luZyBzb21ldGhpbmcgdW5leHBlY3RlZCB3aXRoIHRoZSB0ZXN0cy4gTm8gdGVzdHMgaGF2ZSBcXG5cXFxuICAgICAgICAgYmVlbiBydW4uIFlvdSBzaG91bGQgdXNlIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCB0byBydW4gXFxuXFxcbiAgICAgICAgIHRlc3RzLlxcblxcXG4gICAgICAgICAlIVwiO1xuICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzID0gXzsgd2hhdF90b19kbyA9IGBMaXN0X3BhcnRpdGlvbnMgfSAtPlxuICAgIExpc3QuaXRlciAoUHJpbnRmLnByaW50ZiBcIiVzXFxuXCIpIChQYXJ0aXRpb24uYWxsICgpKTtcbiAgICBUZXN0X3Jlc3VsdC5TdWNjZXNzXG4gIHwgYFRlc3RfbW9kZSB7IHdoYXRfdG9fZG8gPSBgUnVuX3BhcnRpdGlvbiBfOyB3aGljaF90ZXN0cyB9IC0+XG4gICAgKG1hdGNoICFsb2cgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGNoIC0+IGNsb3NlX291dCBjaCk7XG4gICAgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCk7XG4gICAgKG1hdGNoICF0ZXN0c19mYWlsZWQsICF0ZXN0X21vZHVsZXNfZmFpbGVkIHdpdGhcbiAgICAgfCAwLCAwIC0+XG4gICAgICAgaWYgIXNob3dfY291bnRzXG4gICAgICAgdGhlblxuICAgICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgICAgXCIlZCB0ZXN0cyByYW4sICVkIHRlc3RfbW9kdWxlcyByYW5cXG4lIVwiXG4gICAgICAgICAgICF0ZXN0c19yYW5cbiAgICAgICAgICAgIXRlc3RfbW9kdWxlc19yYW47XG4gICAgICAgbGV0IGVycm9ycyA9XG4gICAgICAgICBsZXQgdW51c2VkX3Rlc3RzID1cbiAgICAgICAgICAgTGlzdC5maWx0ZXIgKGZ1biAoXywgXywgdXNlZCkgLT4gbm90ICF1c2VkKSB3aGljaF90ZXN0cy5vbmx5X3Rlc3RfbG9jYXRpb25cbiAgICAgICAgIGluXG4gICAgICAgICBtYXRjaCB1bnVzZWRfdGVzdHMgd2l0aFxuICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgICB8IF8gOjogXyAtPiBTb21lIHVudXNlZF90ZXN0c1xuICAgICAgIGluXG4gICAgICAgKG1hdGNoIGVycm9ycyB3aXRoXG4gICAgICAgIHwgU29tZSB0ZXN0cyAtPlxuICAgICAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgICAgICBcInBweF9pbmxpbmVfdGVzdCBlcnJvcjogdGhlIGZvbGxvd2luZyAtb25seS10ZXN0IGZsYWdzIG1hdGNoZWQgbm90aGluZzpcIjtcbiAgICAgICAgICBMaXN0Lml0ZXJcbiAgICAgICAgICAgIChmdW4gKGZpbGVuYW1lLCBsaW5lX251bWJlcl9vcHQsIF8pIC0+XG4gICAgICAgICAgICAgICBtYXRjaCBsaW5lX251bWJlcl9vcHQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzXCIgZmlsZW5hbWVcbiAgICAgICAgICAgICAgIHwgU29tZSBsaW5lX251bWJlciAtPiBQcmludGYuZXByaW50ZiBcIiAlczolZFwiIGZpbGVuYW1lIGxpbmVfbnVtYmVyKVxuICAgICAgICAgICAgdGVzdHM7XG4gICAgICAgICAgUHJpbnRmLmVwcmludGYgXCIuXFxuJSFcIjtcbiAgICAgICAgICBUZXN0X3Jlc3VsdC5FcnJvclxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBpZiAhdGVzdHNfcmFuID0gMCAmJiAhc3RyaWN0XG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBQcmludGYuZXByaW50ZiBcInBweF9pbmxpbmVfdGVzdCBlcnJvcjogbm8gdGVzdHMgaGF2ZSBiZWVuIHJ1bi5cXG4lIVwiO1xuICAgICAgICAgICAgVGVzdF9yZXN1bHQuRXJyb3IpXG4gICAgICAgICAgZWxzZSBUZXN0X3Jlc3VsdC5TdWNjZXNzKVxuICAgICB8IGNvdW50LCBjb3VudF90ZXN0X21vZHVsZXMgLT5cbiAgICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICAgXCJGQUlMRUQgJWQgLyAlZCB0ZXN0cyVzXFxuJSFcIlxuICAgICAgICAgY291bnRcbiAgICAgICAgICF0ZXN0c19yYW5cbiAgICAgICAgIChpZiBjb3VudF90ZXN0X21vZHVsZXMgPSAwXG4gICAgICAgICAgdGhlbiBcIlwiXG4gICAgICAgICAgZWxzZSBQcmludGYuc3ByaW50ZiAoXCIsICVkIFRFU1wiIF5eIFwiVF9NT0RVTEVTXCIpIGNvdW50X3Rlc3RfbW9kdWxlcyk7XG4gICAgICAgVGVzdF9yZXN1bHQuRmFpbHVyZSlcbjs7XG5cbmxldCB1c2VfY29sb3IgPSAhdXNlX2NvbG9yXG5sZXQgaW5fcGxhY2UgPSAhaW5fcGxhY2VcbmxldCBkaWZmX2NvbW1hbmQgPSAhZGlmZl9jb21tYW5kXG5sZXQgZGlmZl9wYXRoX3ByZWZpeCA9ICFkaWZmX3BhdGhfcHJlZml4XG5sZXQgc291cmNlX3RyZWVfcm9vdCA9ICFzb3VyY2VfdHJlZV9yb290XG5sZXQgZXZhbHVhdG9ycyA9IHJlZiBbIHN1bW1hcml6ZSBdXG5sZXQgYWRkX2V2YWx1YXRvciB+ZiA9IGV2YWx1YXRvcnMgOj0gZiA6OiAhZXZhbHVhdG9yc1xuXG5sZXQgZXhpdCAoKSA9XG4gIExpc3QubWFwIChmdW4gZiAtPiBmICgpKSAoTGlzdC5yZXYgIWV2YWx1YXRvcnMpXG4gIHw+IFRlc3RfcmVzdWx0LmNvbWJpbmVfYWxsXG4gIHw+IFRlc3RfcmVzdWx0LnRvX2V4aXRfY29kZVxuICB8PiBleGl0XG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
