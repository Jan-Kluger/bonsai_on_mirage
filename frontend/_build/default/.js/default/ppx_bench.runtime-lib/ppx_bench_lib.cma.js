// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Ppx_bench_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_bench_lib = [0];
   runtime.caml_register_global(0, Ppx_bench_lib, "Ppx_bench_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_bench_lib__Export
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_bench_lib_Export = [0];
   runtime.caml_register_global
    (0, Ppx_bench_lib_Export, "Ppx_bench_lib__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_bench_lib__Benchmark_accumulator
//# unitInfo: Requires: Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ".",
    null$0 = "<unknown>",
    cst$0 = "",
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    r = [0, 0],
    libname_ref = [0, null$0];
   function set(str){libname_ref[1] = str; return 0;}
   function unset(param){libname_ref[1] = null$0; return 0;}
   var t = [0, 0];
   function pop_exn(param){t[1] = caml_call1(Stdlib_List[7], t[1]); return 0;}
   function compare(t1, t2){return runtime.caml_int_compare(t1[1], t2[1]);}
   function get_module_name_opt(t){
    var str = t[3], len = runtime.caml_ml_string_length(str), i = 0;
    for(;;){
     if((i + 4 | 0) > len) return 0;
     if(caml_call3(Stdlib_String[16], str, i, 4) === ".ml.")
      return [0,
              caml_call3
               (Stdlib_String[16], str, i + 4 | 0, (len - i | 0) - 4 | 0)];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function with_test_spec(t, test_spec){
    return [0,
            t[1],
            t[2],
            t[3],
            t[4],
            t[5],
            t[6],
            t[7],
            t[8],
            test_spec,
            t[10]];
   }
   try{var _d_ = caml_sys_getenv("BENCHMARKS_RUNNER"), v = _d_;}
   catch(_s_){
    var _a_ = caml_wrap_exception(_s_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var v = cst$0;
   }
   var
    add_environment_var = v === "TRUE" ? 1 : 0,
    libs_to_entries = caml_call2(Stdlib_Hashtbl[1], 0, 10);
   function lookup_rev_lib(libname){
    try{
     var _q_ = caml_call2(Stdlib_Hashtbl[6], libs_to_entries, libname);
     return _q_;
    }
    catch(_r_){
     var _p_ = caml_wrap_exception(_r_);
     if(_p_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_p_, 0);
    }
   }
   function lookup_lib(libname){
    var _o_ = lookup_rev_lib(libname);
    return caml_call1(Stdlib_List[10], _o_);
   }
   try{caml_sys_getenv("FORCE_DROP_BENCH"); var _c_ = 1, force_drop = _c_;}
   catch(_n_){
    var _b_ = caml_wrap_exception(_n_);
    if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
    var force_drop = 0;
   }
   function get_mode(param){return force_drop ? -950194894 : 984731018;}
   function add_bench
   (name, code, filename, type_conv_path, line, startpos, endpos, test_spec){
    if(984731018 > get_mode(0)) return 0;
    var libname = libname_ref[1], ms = t[1];
    if(ms)
     var
      _k_ = caml_call1(Stdlib_List[10], ms),
      _l_ = [0, caml_call2(Stdlib_String[7], cst, _k_)];
    else
     var _l_ = 0;
    r[1]++;
    var
     entry =
       [0,
        r[1],
        code,
        type_conv_path,
        name,
        filename,
        line,
        startpos,
        endpos,
        test_spec,
        _l_],
     _m_ = [0, entry, lookup_rev_lib(libname)];
    return caml_call3(Stdlib_Hashtbl[5], libs_to_entries, libname, _m_);
   }
   function add_bench_module(name, _i_, _h_, _g_, _f_, _e_, param, f){
    if(984731018 > get_mode(0)) return 0;
    t[1] = [0, name, t[1]];
    try{caml_call1(f, 0); var _j_ = pop_exn(0); return _j_;}
    catch(ex$0){
     var ex = caml_wrap_exception(ex$0);
     pop_exn(0);
     throw caml_maybe_attach_backtrace(ex, 0);
    }
   }
   var
    Ppx_bench_lib_Benchmark_accumu =
      [0,
       [0, set, unset],
       [0, with_test_spec, compare, get_module_name_opt],
       add_environment_var,
       lookup_lib,
       add_bench,
       add_bench_module];
   runtime.caml_register_global
    (11,
     Ppx_bench_lib_Benchmark_accumu,
     "Ppx_bench_lib__Benchmark_accumulator");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHB4X2JlbmNoX2xpYi5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHB4X2JlbmNoX2xpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiUHB4X2JlbmNoX2xpYiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZ0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfYmVuY2hfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0V4cG9ydCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsdUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfYmVuY2hfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3N5c19nZXRlbnYiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiY3N0IiwibnVsbCIsIlN0ZGxpYl9IYXNodGJsIiwiU3RkbGliX0xpc3QiLCJTdGRsaWIiLCJTdGRsaWJfU3RyaW5nIiwiciIsImxpYm5hbWVfcmVmIiwic2V0Iiwic3RyIiwidW5zZXQiLCJwYXJhbSIsInQiLCJwb3BfZXhuIiwiY29tcGFyZSIsInQxIiwidDIiLCJnZXRfbW9kdWxlX25hbWVfb3B0IiwibGVuIiwiaSIsIndpdGhfdGVzdF9zcGVjIiwidGVzdF9zcGVjIiwidiIsImFkZF9lbnZpcm9ubWVudF92YXIiLCJsaWJzX3RvX2VudHJpZXMiLCJsb29rdXBfcmV2X2xpYiIsImxpYm5hbWUiLCJsb29rdXBfbGliIiwiZm9yY2VfZHJvcCIsImdldF9tb2RlIiwiYWRkX2JlbmNoIiwibmFtZSIsImNvZGUiLCJmaWxlbmFtZSIsInR5cGVfY29udl9wYXRoIiwibGluZSIsInN0YXJ0cG9zIiwiZW5kcG9zIiwibXMiLCJlbnRyeSIsImFkZF9iZW5jaF9tb2R1bGUiLCJleCIsIlBweF9iZW5jaF9saWJfQmVuY2htYXJrX2FjY3VtdSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9wcHhfYmVuY2gvcnVudGltZS1saWIvYmVuY2htYXJrX2FjY3VtdWxhdG9yLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUQsUUFBQTtBQUFBLElBQUFFLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLElBQUE7QUFBQSxJQUFBQyxjQ0VFO0FBQUEsWUFBQUMsSUFBQUMsS0FVYywrQkFBa0I7QUFBQSxZQUFBQyxNQUFBQyxPQUNqQixrQ0FBbUI7QUFBQSxPQUFBQyxJQVhsQztBQUFBLFlBQUFDLFFBQUFGLE9Ba0JzQix5Q0FBVTtBQUFBLFlBQUFHLFFBQUFDLElBQUFDLElBbUNaLDZDQUFpQztBQUFBLFlBQUFDLG9CQUFBTDtBQUFBQSxRQUFBSCxNQUtuRCxNQUFBUyxNQUNBLG9DQUFBQyxJQVNBO0FBQUE7QUFBQSxLQVBFLHNCQUtLO0FBQUEsS0FIQTtBQUFBLE1BQ087QUFBQTtBQUFBLDBFQUFzQztBQUFBLFNBQUFBLE1BQzNDO0FBQUE7QUFBQTtBQUFBLEdBR0g7QUFBQSxZQUFBQyxlQUFBUixHQUFBUztBQUFBQSxJQUd5QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBb0I7QUFBQSxHQXZFckQsY0ErRU0sc0NBQUFDLElBQUE7QUFBQTtBQUFBLGNEakZSO0FBQUE7QUFBQSxRQUFBQSxJQ2tGbUI7QUFBQTtBQUFBO0FBQUEsSUFBQUMsc0JBRWpCO0FBQUEsSUFBQUMsa0JBTXVEO0FBQUEsWUFBQUMsZUFBQUM7QUFBQUEsSUFHdkQ7QUFBQSxlQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUQ3Rk47QUFBQSwyQkM4RmlCO0FBQUEsS0Q5RmpCO0FBQUE7QUFBQSxHQzhGbUI7QUFBQSxZQUFBQyxXQUFBRDtBQUFBQSxRQUFBLE1BR2dCO0FBQUEsSUFBeUI7QUFBQTtBQUFBLEdBUGMsSUFhOUQsK0NBQ1IsR0FBQUUsYUFBQTtBQUFBO0FBQUEsY0R4R0o7QUFBQTtBQUFBLFFBQUFBLGFDMEdpQjtBQUFBO0FBQUEsWUFBQUMsU0FBQWxCLE9BR0MsMENBQXdDO0FBQUEsWUFBQW1CO0FBQUFBLElBQUFDLE1BQUFDLE1BQUFDLFVBQUFDLGdCQUFBQyxNQUFBQyxVQUFBQyxRQUFBaEI7QUFBQUEsSUFZbEQsNEJBQ087QUFBQSxRQUFBSyxVQTVHQSxnQkFBQVksS0FTWDtBQUFBO0FBQUE7QUFBQSxZQUVnQztBQUFBLFlBQWMsSUFBakM7QUFBQTtBQUFBLGVBREw7QUFBQSxJQXJCUjtBQUFBO0FBQUEsS0FBQUM7QUFBQUEsT0E0SDRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVdrQjtBQUFBLElBQXVCLG1FQUFDO0FBQUE7QUFBQSxZQUFBQyxpQkFBQVQsTUFBQSx5QkFBQXBCLE9BQUFsQjtBQUFBQSxJQWFsRSw0QkFDTztBQUFBLElBcklBO0FBQUEsSUF3SXlCLElBRWpDLDRCQUNBO0FBQUEsVUFBQWdEO0FBQUFBLFNBQUFBLEtEOUpQO0FBQUEsS0NpS087QUFBQSxLQUFxQztBQUFBO0FBQUEsR0FDNUI7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BeEUwRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDFGMUUiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsImxldCB1bmlxdWVfaWQgPVxuICBsZXQgciA9IHJlZiAwIGluXG4gIGZ1biAoKSAtPlxuICAgIGluY3IgcjtcbiAgICAhclxuOztcblxuKCogVXNlZCB0byB0cmFjayB0aGUgY3VycmVudCBsaWJuYW1lIGluIHN1Y2ggYSB3YXkgdGhhdCBmb3IgZnVuY3RvciBhcHBsaWNhdGlvbnMsIGl0IGlzXG4gICB0aGUgY2FsbGluZyBsaWJyYXJpZXMgbmFtZSB0aGF0IGdldHMgcmVnaXN0ZXJlZC4gKilcbm1vZHVsZSBDdXJyZW50X2xpYm5hbWUgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIjx1bmtub3duPlwiXG4gIGxldCBsaWJuYW1lX3JlZiA9IHJlZiBudWxsXG4gIGxldCBzZXQgc3RyID0gbGlibmFtZV9yZWYgOj0gc3RyXG4gIGxldCB1bnNldCAoKSA9IGxpYm5hbWVfcmVmIDo9IG51bGxcbiAgbGV0IGdldCAoKSA9ICFsaWJuYW1lX3JlZlxuZW5kXG5cbm1vZHVsZSBDdXJyZW50X2JlbmNoX21vZHVsZV9zdGFjayA9IHN0cnVjdFxuICBsZXQgdCA9IHJlZiBbXVxuICBsZXQgcHVzaCBzID0gdCA6PSBzIDo6ICF0XG4gIGxldCBwb3BfZXhuICgpID0gdCA6PSBMaXN0LnRsICF0XG5cbiAgbGV0IHRvX25hbWUgKCkgPVxuICAgIG1hdGNoICF0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IG1zIC0+IFNvbWUgKFN0cmluZy5jb25jYXQgXCIuXCIgKExpc3QucmV2IG1zKSlcbiAgOztcbmVuZFxuXG4oKiBUaGlzIGlzIHRoZSBtYWluIGRhdGEgc3RydWN0dXJlIG9mIHRoaXMgbW9kdWxlLiBBbiBbRW50cnkudF0gcmVwcmVzZW50cyBhIGJlbmNobWFya1xuICAgYWxvbmcgd2l0aCBzb21lIG1ldGFkYXRhIGFib3V0IGlzIHBvc2l0aW9uLCBhcmd1bWVudHMgZXRjLiAqKVxubW9kdWxlIEVudHJ5ID0gc3RydWN0XG4gIHR5cGUgKCdwYXJhbSwgJ2EpIHBhcmFtZXRlcmlzZWRfc3BlYyA9XG4gICAgeyBhcmdfbmFtZSA6IHN0cmluZ1xuICAgIDsgcGFyYW1zIDogKHN0cmluZyAqICdwYXJhbSkgbGlzdFxuICAgIDsgdGh1bmsgOiAncGFyYW0gLT4gdW5pdCAtPiAnYVxuICAgIH1cblxuICB0eXBlIHRlc3Rfc3BlYyA9XG4gICAgfCBSZWd1bGFyX3RodW5rIDogKFsgYGluaXQgXSAtPiB1bml0IC0+ICdhKSAtPiB0ZXN0X3NwZWNcbiAgICB8IFBhcmFtZXRlcmlzZWRfdGh1bmsgOiAoJ3BhcmFtLCAnYSkgcGFyYW1ldGVyaXNlZF9zcGVjIC0+IHRlc3Rfc3BlY1xuXG4gIHR5cGUgdCA9XG4gICAgeyB1bmlxdWVfaWQgOiBpbnRcbiAgICA7IGNvZGUgOiBzdHJpbmdcbiAgICA7IHR5cGVfY29udl9wYXRoIDogc3RyaW5nXG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgOyBmaWxlbmFtZSA6IHN0cmluZ1xuICAgIDsgbGluZSA6IGludFxuICAgIDsgc3RhcnRwb3MgOiBpbnRcbiAgICA7IGVuZHBvcyA6IGludFxuICAgIDsgdGVzdF9zcGVjIDogdGVzdF9zcGVjXG4gICAgOyBiZW5jaF9tb2R1bGVfbmFtZSA6IHN0cmluZyBvcHRpb25cbiAgICB9XG5cbiAgbGV0IGNvbXBhcmUgdDEgdDIgPSBjb21wYXJlIHQxLnVuaXF1ZV9pZCB0Mi51bmlxdWVfaWRcblxuICAoKiBFeHRyYWN0cyBtb2R1bGUgbmFtZSBmcm9tIFtcImZpbGVuYW1lLm1sLk1vZHVsZVwiXSwgd2hpY2ggaXMgdGhlIGZvcm1hdCBvZiBbZXh0X25hbWVdXG4gICAgIGFzIHNldCBieSBbdHlwZWNvbnZdLiAqKVxuICBsZXQgZ2V0X21vZHVsZV9uYW1lX29wdCB0ID1cbiAgICBsZXQgc3RyID0gdC50eXBlX2NvbnZfcGF0aCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgKyA0IDw9IGxlblxuICAgICAgdGhlblxuICAgICAgICBpZiBTdHJpbmcuc3ViIHN0ciBpIDQgPSBcIi5tbC5cIlxuICAgICAgICB0aGVuIFNvbWUgKFN0cmluZy5zdWIgc3RyIChpICsgNCkgKGxlbiAtIGkgLSA0KSlcbiAgICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgTm9uZVxuICAgIGluXG4gICAgbG9vcCAwXG4gIDs7XG5cbiAgbGV0IHdpdGhfdGVzdF9zcGVjIHQgdGVzdF9zcGVjID0geyB0IHdpdGggdGVzdF9zcGVjIH1cbmVuZFxuXG4oKiBJbnNwZWN0IHN5c3RlbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gZGVjaWRlIGlmIGJlbmNobWFya3MgYXJlIGJlaW5nIHJ1bi4gVGhpcyBpc1xuICAgY2FsbGVkIGJ5IHRoZSBjb2RlIGdlbmVyYXRlZCBieSB0aGUgW3BhX2JlbmNoXSBzeW50YXggdG8gZGVjaWRlIGlmIHRoZSBnbG9iYWwgaGFzaHRhYmxlXG4gICBzaG91bGQgYmUgcG9wdWxhdGVkLiAqKVxubGV0IGFkZF9lbnZpcm9ubWVudF92YXIgPVxuICBsZXQgdiA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJCRU5DSE1BUktTX1JVTk5FUlwiIHdpdGhcbiAgICB8IE5vdF9mb3VuZCAtPiBcIlwiXG4gIGluXG4gIHYgPSBcIlRSVUVcIlxuOztcblxuKCogVGhpcyBoYXNodGFibGUgY29udGFpbnMgYWxsIHRoZSBiZW5jaG1hcmtzIGZyb20gYWxsIHRoZSBvZiBsaWJyYXJpZXMgdGhhdCBoYXZlIGJlZW5cbiAgIGxvYWRlZC4gQXQgdGhlIHRpbWUgdGhlIGJlbmNobWFya3MgYXJlIHJlZ2lzdGVyaW5nIHRoZW1zZWx2ZXMgd2l0aCBbcHB4X2JlbmNoX2xpYl0gd2VcbiAgIGRvbid0IHlldCBrbm93IHdoaWNoIGxpYnJhcmllcyB3aWxsIG5lZWQgdG8gYmUgcnVuLiAgKilcbmxldCBsaWJzX3RvX2VudHJpZXMgOiAoc3RyaW5nLCBFbnRyeS50IGxpc3QpIEhhc2h0YmwudCA9IEhhc2h0YmwuY3JlYXRlIDEwXG5cbmxldCBsb29rdXBfcmV2X2xpYiB+bGlibmFtZSA9XG4gIHRyeSBIYXNodGJsLmZpbmQgbGlic190b19lbnRyaWVzIGxpYm5hbWUgd2l0aFxuICB8IE5vdF9mb3VuZCAtPiBbXVxuOztcblxubGV0IGxvb2t1cF9saWIgfmxpYm5hbWUgPSBMaXN0LnJldiAobG9va3VwX3Jldl9saWIgfmxpYm5hbWUpXG5cbmxldCBmb3JjZV9kcm9wID1cbiAgKCogVXNlZnVsIGZvciBqc19vZl9vY2FtbCB0byBwZXJmb3JtIGRlYWRjb2RlIGVsaW1pbmF0aW9uLlxuICAgICBzZWUgcHB4L3BweF9pbmxpbmVfdGVzdC9ydW50aW1lLWxpYi9ydW50aW1lLm1sIFtBY3Rpb24uZ2V0XSBmb3IgbW9yZSBkZXRhaWxzICopXG4gIHRyeVxuICAgIGlnbm9yZSAoU3lzLmdldGVudiBcIkZPUkNFX0RST1BfQkVOQ0hcIiA6IHN0cmluZyk7XG4gICAgdHJ1ZVxuICB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X21vZGUgKCkgPSBpZiBmb3JjZV9kcm9wIHRoZW4gYElnbm9yZSBlbHNlIGBDb2xsZWN0XG5cbmxldFtAaW5saW5lIG5ldmVyXSBhZGRfYmVuY2hcbiAgICAgICAgICAgICAgICAgICAgIH5uYW1lXG4gICAgICAgICAgICAgICAgICAgICB+Y29kZVxuICAgICAgICAgICAgICAgICAgICAgfmZpbGVuYW1lXG4gICAgICAgICAgICAgICAgICAgICB+dHlwZV9jb252X3BhdGhcbiAgICAgICAgICAgICAgICAgICAgIH5saW5lXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRwb3NcbiAgICAgICAgICAgICAgICAgICAgIH5lbmRwb3NcbiAgICAgICAgICAgICAgICAgICAgIHRlc3Rfc3BlY1xuICA9XG4gIG1hdGNoIGdldF9tb2RlICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYENvbGxlY3QgLT5cbiAgICBsZXQgbGlibmFtZSA9IEN1cnJlbnRfbGlibmFtZS5nZXQgKCkgaW5cbiAgICBsZXQgZW50cnkgPVxuICAgICAgeyBFbnRyeS5jb2RlXG4gICAgICA7IHVuaXF1ZV9pZCA9IHVuaXF1ZV9pZCAoKVxuICAgICAgOyB0eXBlX2NvbnZfcGF0aFxuICAgICAgOyBiZW5jaF9tb2R1bGVfbmFtZSA9IEN1cnJlbnRfYmVuY2hfbW9kdWxlX3N0YWNrLnRvX25hbWUgKClcbiAgICAgIDsgbmFtZVxuICAgICAgOyBmaWxlbmFtZVxuICAgICAgOyBsaW5lXG4gICAgICA7IHN0YXJ0cG9zXG4gICAgICA7IGVuZHBvc1xuICAgICAgOyB0ZXN0X3NwZWNcbiAgICAgIH1cbiAgICBpblxuICAgIEhhc2h0YmwuYWRkIGxpYnNfdG9fZW50cmllcyBsaWJuYW1lIChlbnRyeSA6OiBsb29rdXBfcmV2X2xpYiB+bGlibmFtZSlcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSBhZGRfYmVuY2hfbW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICB+bmFtZVxuICAgICAgICAgICAgICAgICAgICAgfmNvZGU6X1xuICAgICAgICAgICAgICAgICAgICAgfnR5cGVfY29udl9wYXRoOl9cbiAgICAgICAgICAgICAgICAgICAgIH5maWxlbmFtZTpfXG4gICAgICAgICAgICAgICAgICAgICB+bGluZTpfXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRwb3M6X1xuICAgICAgICAgICAgICAgICAgICAgfmVuZHBvczpfXG4gICAgICAgICAgICAgICAgICAgICBmXG4gID1cbiAgbWF0Y2ggZ2V0X21vZGUgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT4gKClcbiAgfCBgQ29sbGVjdCAtPlxuICAgICgqIFJ1bm5pbmcgZiByZWdpc3RlcnMgdGhlIGJlbmNobWFya3MgdXNpbmcgQkVOQ0ggKilcbiAgICBDdXJyZW50X2JlbmNoX21vZHVsZV9zdGFjay5wdXNoIG5hbWU7XG4gICAgKHRyeVxuICAgICAgIGYgKCk7XG4gICAgICAgQ3VycmVudF9iZW5jaF9tb2R1bGVfc3RhY2sucG9wX2V4biAoKVxuICAgICB3aXRoXG4gICAgIHwgZXggLT5cbiAgICAgICBDdXJyZW50X2JlbmNoX21vZHVsZV9zdGFjay5wb3BfZXhuICgpO1xuICAgICAgIHJhaXNlIGV4KVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fV19
