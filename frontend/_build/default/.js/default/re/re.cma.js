// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Re__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Re = [0], Re$0 = [0, Re];
   runtime.caml_register_global(0, Re$0, "Re__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Fmt
//# unitInfo: Requires: Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_S = "%S",
    cst_3 = "<3>",
    cst = "@ ";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    pp_print_string = Stdlib_Format[13],
    pp_print_int = Stdlib_Format[19],
    pp_print_space = Stdlib_Format[28],
    pp_print_list = Stdlib_Format[132],
    fprintf = Stdlib_Format[139],
    _a_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12, 40, [2, 0, [17, [0, cst, 1, 0], [15, [12, 41, [17, 0, 0]]]]]]],
       "@[<3>(%s@ %a)@]"],
    _b_ = [0, [3, 0, 0], cst_S],
    _c_ = [0, [15, 0], "%a"],
    cst_None = "<None>",
    _d_ = [0, [17, [0, cst, 1, 0], [4, 0, 0, 0, 0]], "@ %d"],
    _e_ = [0, [12, 34, [2, 0, [12, 34, 0]]], '"%s"'],
    _h_ = [0, [0, 0], "%c"];
   function array(pp_sep, f, fmt, arr){
    return caml_call4
            (pp_print_list, pp_sep, f, fmt, caml_call1(Stdlib_Array[10], arr));
   }
   function sexp(fmt, s, pp, x){
    return caml_call5(fprintf, fmt, _a_, s, pp, x);
   }
   function bytes(fmt, t){
    var _k_ = caml_call1(Stdlib_Bytes[6], t);
    return caml_call3(Stdlib_Format[139], fmt, _b_, _k_);
   }
   function pair(pp1, pp2, fmt, param){
    var v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp2, fmt, v2);
   }
   function triple(pp1, pp2, pp3, fmt, param){
    var v3 = param[3], v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    caml_call2(pp2, fmt, v2);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp3, fmt, v3);
   }
   function opt(f, fmt, x){
    if(! x) return caml_call2(pp_print_string, fmt, cst_None);
    var x$0 = x[1];
    return caml_call4(fprintf, fmt, _c_, f, x$0);
   }
   function optint(fmt, param){
    if(! param) return 0;
    var i = param[1];
    return caml_call3(fprintf, fmt, _d_, i);
   }
   function pp_elem(fmt, s){
    return caml_call3(Stdlib_Format[139], fmt, _e_, s);
   }
   function char$0(fmt, c){
    return caml_call3(Stdlib_Format[139], fmt, _h_, c);
   }
   var
    bool = Stdlib_Format[25],
    _f_ = [0, [12, 59, [17, [0, cst, 1, 0], 0]], ";@ "],
    _g_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12,
         91,
         [17,
          [0, cst, 1, 0],
          [15, [17, [0, cst, 1, 0], [12, 93, [17, 0, 0]]]]]]],
       "@[<3>[@ %a@ ]@]"],
    _i_ = [0, [3, 0, 0], cst_S];
   function pp_str_list(fmt){
    var
     _j_ =
       caml_call2
        (pp_print_list,
         [0, function(fmt, param){return caml_call2(fprintf, fmt, _f_);}],
         pp_elem);
    return caml_call3(Stdlib_Format[139], fmt, _g_, _j_);
   }
   function lit(s, fmt, param){return caml_call2(pp_print_string, fmt, s);}
   function to_to_string(pp, x){
    var
     b = caml_call1(Stdlib_Buffer[1], 16),
     fmt = caml_call1(Stdlib_Format[116], b);
    caml_call2(pp, fmt, x);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function quoted_string(fmt, s){
    return caml_call3(Stdlib_Format[139], fmt, _i_, s);
   }
   var
    Re_Fmt =
      [0,
       pp_str_list,
       sexp,
       pp_print_string,
       optint,
       opt,
       char$0,
       bool,
       pp_print_int,
       pair,
       triple,
       pp_print_list,
       bytes,
       array,
       lit,
       to_to_string,
       quoted_string];
   runtime.caml_register_global(14, Re_Fmt, "Re__Fmt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Bit_vector
//# unitInfo: Requires: Re__Fmt, Stdlib, Stdlib__Bytes, Stdlib__Char, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    cst_Bit_vector_set = "Bit_vector.set",
    cst_Bit_vector_get = "Bit_vector.get",
    cst_len = "len",
    cst_bits = "bits",
    _a_ = [0, [15, [17, 4, [15, [17, 4, 0]]]], "%a@.%a@."];
   function length(t){return t[1];}
   function set(v, n, b){
    var _d_ = n < 0 ? 1 : 0, _e_ = _d_ || (v[1] <= n ? 1 : 0);
    if(_e_) caml_call1(Stdlib[1], cst_Bit_vector_set);
    var
     i = n >>> 3 | 0,
     s = v[2],
     c = caml_bytes_unsafe_get(s, i),
     mask = 1 << (n & 7),
     x = b ? c | mask : c & caml_call1(Stdlib[21], mask),
     s$0 = v[2];
    runtime.caml_bytes_unsafe_set(s$0, i, caml_call1(Stdlib_Char[1], x));
    return 0;
   }
   function get(v, n){
    var _b_ = n < 0 ? 1 : 0, _c_ = _b_ || (v[1] <= n ? 1 : 0);
    if(_c_) caml_call1(Stdlib[1], cst_Bit_vector_get);
    var i = n >>> 3 | 0, s = v[2];
    return 0 < (caml_bytes_unsafe_get(s, i) & 1 << (n & 7)) ? 1 : 0;
   }
   function reset_zero(t){
    return caml_call4
            (Stdlib_Bytes[10], t[2], 0, runtime.caml_ml_bytes_length(t[2]), 0);
   }
   function create_zero(len){
    var
     r = len & 7,
     q = len >>> 3 | 0,
     len$0 = 0 === r ? q : q + 1 | 0,
     bits = caml_call2(Stdlib_Bytes[1], len$0, 0);
    return [0, len, bits];
   }
   function pp(fmt, param){
    var bits = param[2], len = param[1];
    function len$0(fmt, param){
     return caml_call4(Re_Fmt[2], fmt, cst_len, Re_Fmt[8], len);
    }
    function bits$0(fmt, param){
     return caml_call4(Re_Fmt[2], fmt, cst_bits, Re_Fmt[12], bits);
    }
    return caml_call6(Stdlib_Format[139], fmt, _a_, len$0, 0, bits$0, 0);
   }
   var Re_Bit_vector = [0, length, set, create_zero, get, reset_zero, pp];
   runtime.caml_register_global(10, Re_Bit_vector, "Re__Bit_vector");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Category
//# unitInfo: Requires: Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function to_int(x){return x;}
   var pp = Stdlib_Format[19];
   function intersect(x, y){return 0 !== (x & y) ? 1 : 0;}
   function symbol(x, y){return x | y;}
   var letter = 2, not_letter = 4;
   function from_char(param){
    a:
    {
     if(170 <= param)
      if(187 <= param){
       var _a_ = param - 192 | 0;
       if(54 < _a_ >>> 0){if(56 <= _a_) break a;} else if(23 !== _a_) break a;
      }
      else{
       var _b_ = param - 171 | 0;
       if(14 < _b_ >>> 0 || 10 === _b_) break a;
      }
     else if(65 <= param){
      var _c_ = param - 91 | 0;
      if(5 < _c_ >>> 0){if(32 > _c_) break a;} else if(4 === _c_) break a;
     }
     else
      if(48 <= param){
       if(58 > param) break a;
      }
      else if(10 === param) return 12;
     return not_letter;
    }
    return letter;
   }
   var
    Re_Category =
      [0,
       symbol,
       from_char,
       -1,
       1,
       letter,
       not_letter,
       8,
       16,
       32,
       to_int,
       equal,
       compare,
       intersect,
       pp];
   runtime.caml_register_global(1, Re_Category, "Re__Category");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Import
//# unitInfo: Requires: Stdlib, Stdlib__Hashtbl, Stdlib__Int, Stdlib__Option
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    symbol$0 = [0, 874682015, 0];
   global_data.Stdlib__Hashtbl;
   var
    Stdlib = global_data.Stdlib,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Option = global_data.Stdlib__Option,
    equal = runtime.caml_equal,
    compare = runtime.caml_compare,
    Poly = [0, equal, compare];
   function equal$0(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var Phys_equal = [0, equal$0], symbol = Stdlib_Int[8];
   function symbol$1(x, y){
    return caml_call2(symbol, caml_call2(Stdlib_Int[9], x, y), -1);
   }
   function symbol$2(x, y){
    return caml_call2(symbol, caml_call2(Stdlib_Int[9], x, y), 1);
   }
   var
    min = Stdlib_Int[10],
    max = Stdlib_Int[11],
    compare$0 = Stdlib_Int[9],
    none = Stdlib_Option[1],
    some = Stdlib_Option[2],
    value = Stdlib_Option[3],
    get = Stdlib_Option[4],
    bind = Stdlib_Option[5],
    join = Stdlib_Option[6],
    map = Stdlib_Option[7],
    fold = Stdlib_Option[8],
    iter = Stdlib_Option[9],
    is_none = Stdlib_Option[10],
    is_some = Stdlib_Option[11],
    equal$1 = Stdlib_Option[12],
    compare$1 = Stdlib_Option[13],
    to_result = Stdlib_Option[14],
    to_list = Stdlib_Option[15],
    to_seq = Stdlib_Option[16];
   function some$0(x){return x;}
   var
    cst_Option_Unboxed_value_exn_c = "Option.Unboxed.value_exn called on None";
   function is_none$0(t){return t === -1 ? 1 : 0;}
   function is_some$0(t){return 1 - (t === -1 ? 1 : 0);}
   function value_exn(t){
    if(t === -1) caml_call1(Stdlib[1], cst_Option_Unboxed_value_exn_c);
    return t;
   }
   function to_option(t){return t === -1 ? 0 : [0, value_exn(t)];}
   function iter$0(t, f){return t === -1 ? 0 : caml_call1(f, value_exn(t));}
   var
    Unboxed =
      [0, -1, some$0, is_none$0, is_some$0, value_exn, to_option, iter$0],
    Option =
      [0,
       none,
       some,
       value,
       get,
       bind,
       join,
       map,
       fold,
       iter,
       is_none,
       is_some,
       equal$1,
       compare$1,
       to_result,
       to_list,
       to_seq,
       Unboxed],
    zero = Stdlib_Int[1],
    one = Stdlib_Int[2],
    minus_one = Stdlib_Int[3],
    abs = Stdlib_Int[4],
    max_int = Stdlib_Int[5],
    min_int = Stdlib_Int[6],
    lognot = Stdlib_Int[7],
    equal$2 = Stdlib_Int[8],
    compare$2 = Stdlib_Int[9],
    min$0 = Stdlib_Int[10],
    max$0 = Stdlib_Int[11],
    to_string = Stdlib_Int[12],
    seeded_hash = Stdlib_Int[13],
    hash = Stdlib_Int[14],
    Int =
      [0,
       zero,
       one,
       minus_one,
       abs,
       max_int,
       min_int,
       lognot,
       equal$2,
       compare$2,
       min$0,
       max$0,
       to_string,
       seeded_hash,
       hash],
    Re_Import =
      [0,
       Poly,
       Phys_equal,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       min,
       max,
       compare$0,
       Option,
       Int];
   runtime.caml_register_global(6, Re_Import, "Re__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Cset
//# unitInfo: Requires: Re__Fmt, Re__Import, Stdlib, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__Map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cany = [0, [0, 0, 255], 0],
    cst = ", ",
    cst$0 = "\t ",
    Re_Import = global_data.Re__Import,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Char = global_data.Stdlib__Char,
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Map = global_data.Stdlib__Map,
    equal_c = Re_Import[11][8];
   function to_int(x){return x;}
   function of_int(x){return x;}
   function to_char(t){return caml_call1(Stdlib_Char[1], t);}
   function of_char(c){return c;}
   function compare_pair(_Q_, param){
    var
     y = param[2],
     x = param[1],
     y$0 = _Q_[2],
     x$0 = _Q_[1],
     x$1 = caml_call2(Re_Import[11][9], x$0, x);
    return 0 === x$1 ? caml_call2(Re_Import[11][9], y$0, y) : x$1;
   }
   function equal_pair(_O_, param){
    var
     y = param[2],
     x = param[1],
     y$0 = _O_[2],
     x$0 = _O_[1],
     _P_ = caml_call2(Re_Import[11][8], x$0, x);
    return _P_ ? caml_call2(Re_Import[11][8], y$0, y) : _P_;
   }
   var
    equal = caml_call1(Stdlib_ListLabels[16], equal_pair),
    compare = caml_call1(Stdlib_ListLabels[17], compare_pair);
   function union(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return l$1;
     var
      r = l$1[2],
      _N_ = l$1[1],
      c2 = _N_[2],
      c1 = _N_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(caml_call2(Re_Import[5], c2$0 + 1 | 0, c1))
      return [0, [0, c1$0, c2$0], union(r$0, l$1)];
     if(caml_call2(Re_Import[5], c2 + 1 | 0, c1$0))
      return [0, [0, c1, c2], union(l$2, r)];
     if(caml_call2(Re_Import[5], c2$0, c2)){
      var l$3 = [0, [0, caml_call2(Re_Import[7], c1$0, c1), c2], r];
      l$2 = r$0;
      l$1 = l$3;
     }
     else{
      var l$4 = [0, [0, caml_call2(Re_Import[7], c1$0, c1), c2$0], r$0];
      l$2 = l$4;
      l$1 = r;
     }
    }
   }
   function inter(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return 0;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _K_ = l$1[1],
      c2 = _K_[2],
      c1 = _K_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(caml_call2(Re_Import[5], c2$0, c1))
      l$2 = r$0;
     else{
      if(! caml_call2(Re_Import[5], c2, c1$0)){
       if(caml_call2(Re_Import[5], c2$0, c2)){
        var _L_ = inter(r$0, l$1);
        return [0, [0, caml_call2(Re_Import[8], c1$0, c1), c2$0], _L_];
       }
       var _M_ = inter(l$2, r);
       return [0, [0, caml_call2(Re_Import[8], c1$0, c1), c2], _M_];
      }
      l$1 = r;
     }
    }
   }
   function diff(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _J_ = l$1[1],
      c2 = _J_[2],
      c1 = _J_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(caml_call2(Re_Import[5], c2$0, c1))
      return [0, [0, c1$0, c2$0], diff(r$0, l$1)];
     if(caml_call2(Re_Import[5], c2, c1$0))
      l$1 = r;
     else{
      var
       r$1 =
         caml_call2(Re_Import[5], c2, c2$0)
          ? [0, [0, c2 + 1 | 0, c2$0], r$0]
          : r$0;
      if(caml_call2(Re_Import[5], c1$0, c1))
       return [0, [0, c1$0, c1 - 1 | 0], diff(r$1, r)];
      l$2 = r$1;
      l$1 = r;
     }
    }
   }
   function single(c){return [0, [0, c, c], 0];}
   function add(c, l){return union(single(c), l);}
   function offset(o, l){
    if(! l) return 0;
    var r = l[2], match = l[1], c2 = match[2], c1 = match[1];
    return [0, [0, c1 + o | 0, c2 + o | 0], offset(o, r)];
   }
   var
    empty = 0,
    union_all = caml_call2(Stdlib_ListLabels[26], union, empty),
    intersect_all = caml_call2(Stdlib_ListLabels[26], inter, cany),
    _a_ = [0, [4, 0, 0, 0, 0], "%d"],
    _b_ = [0, [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]], "%d-%d"];
   function mem(c, s){
    var s$0 = s;
    for(;;){
     if(! s$0) return 0;
     var rem = s$0[2], match = s$0[1], c2 = match[2], c1 = match[1];
     if(c <= c2) return c1 <= c ? 1 : 0;
     s$0 = rem;
    }
   }
   function hash_rec(param){
    if(! param) return 0;
    var r = param[2], match = param[1], j = match[2], i = match[1];
    return (i + (13 * j | 0) | 0) + (257 * hash_rec(r) | 0) | 0;
   }
   function hash(l){return hash_rec(l) & 1073741823;}
   function print_one(ch, param){
    var c2 = param[2], c1 = param[1];
    return caml_call2(Re_Import[11][8], c1, c2)
            ? caml_call3(Stdlib_Format[139], ch, _a_, c1)
            : caml_call4(Stdlib_Format[139], ch, _b_, c1, c2);
   }
   var
    _c_ = [0, caml_call1(Re_Fmt[14], cst)],
    pp = caml_call2(Re_Fmt[11], _c_, print_one);
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var xs = t$0[2], match = t$0[1], y = match[2], x = match[1];
     caml_call2(f, x, y);
     t$0 = xs;
    }
   }
   function one_char(param){
    if(param && ! param[2]){
     var match = param[1], j = match[2], i = match[1];
     if(caml_call2(Re_Import[11][8], i, j)) return [0, i];
    }
    return 0;
   }
   function compare$0(_I_, param){
    var
     v = param[2],
     j = param[1],
     u = _I_[2],
     i = _I_[1],
     c = caml_call2(Re_Import[11][9], i, j);
    return 0 === c ? caml_call2(compare, u, v) : c;
   }
   var
    CSetMap = caml_call1(Stdlib_Map[1], [0, compare$0]),
    _d_ = [0, "lib/cset.ml", 171, 9],
    cst_Re_cset_pick = "Re_cset.pick";
   function fold_right(t, init, f){
    return caml_call3
            (Stdlib_ListLabels[27],
             function(param, acc){
              var y = param[2], x = param[1];
              return caml_call3(f, x, y, acc);
             },
             t,
             init);
   }
   function csingle(c){return single(c);}
   function is_empty(param){return param ? 0 : 1;}
   function prepend(s, x, l){
    var s$0 = s;
    for(;;){
     if(! s$0) return l;
     if(! l) return 0;
     var _D_ = l[1], _E_ = _D_[1];
     if(_E_ && ! _E_[2]){
      var
       x$0 = _D_[2],
       _F_ = _E_[1],
       d = _F_[2],
       d$0 = _F_[1],
       r = s$0[2],
       match = s$0[1],
       c = match[2],
       c$0 = match[1];
      if(caml_call2(Re_Import[5], c, d$0)){s$0 = r; continue;}
      var r$0 = l[2];
      if(c$0 > d$0)
       return caml_call2(Re_Import[6], c$0, d)
               ? [0, [0, [0, [0, d$0, d], 0], x$0], prepend(s$0, x, r$0)]
               : [0,
                 [0, [0, [0, d$0, c$0 - 1 | 0], 0], x$0],
                 prepend(s$0, x, [0, [0, [0, [0, c$0, d], 0], x$0], r$0])];
      if(caml_call2(Re_Import[5], c, d)){
       var _G_ = prepend(r, x, [0, [0, [0, [0, c + 1 | 0, d], 0], x$0], r$0]);
       return [0,
               [0, [0, [0, d$0, c], 0], caml_call2(Stdlib[37], x, x$0)],
               _G_];
      }
      var _H_ = prepend(s$0, x, r$0);
      return [0,
              [0, [0, [0, d$0, d], 0], caml_call2(Stdlib[37], x, x$0)],
              _H_];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
   }
   function pick(param){
    if(! param) return caml_call1(Stdlib[1], cst_Re_cset_pick);
    var x = param[1][1];
    return x;
   }
   function cseq(c$0, c){
    return runtime.caml_lessequal(c$0, c)
            ? [0, [0, c$0, c], 0]
            : [0, [0, c, c$0], 0];
   }
   var
    _e_ = [0, cseq(216, 222), 0],
    _f_ = [0, cseq(192, 214), _e_],
    upper = caml_call1(union_all, [0, cseq(65, 90), _f_]),
    clower = offset(32, upper),
    cdigit = cseq(48, 57),
    ascii = cseq(0, 127);
   function cadd(c, s){return add(c, s);}
   var
    space = add(32, cseq(9, 13)),
    _g_ = [0, cseq(65, 70), 0],
    xdigit = caml_call1(union_all, [0, cdigit, [0, cseq(97, 102), _g_]]),
    _h_ = union(clower, upper),
    calpha =
      caml_call3
       (Stdlib_ListLabels[27],
        cadd,
        [0, 170, [0, 181, [0, 186, [0, 223, [0, 255, 0]]]]],
        _h_),
    calnum = union(calpha, cdigit);
   function case_insens(s){
    var _C_ = [0, offset(-32, inter(s, clower)), 0];
    return caml_call1
            (union_all, [0, s, [0, offset(32, inter(s, upper)), _C_]]);
   }
   var
    cword = add(95, calnum),
    notnl = diff(cany, single(10)),
    nl = single(10);
   function set(str){
    var
     s = [0, empty],
     _z_ = runtime.caml_ml_string_length(str) - 1 | 0,
     _y_ = 0;
    if(_z_ >= 0){
     var i = _y_;
     for(;;){
      var _A_ = s[1], c = runtime.caml_string_get(str, i);
      s[1] = union(single(c), _A_);
      var _B_ = i + 1 | 0;
      if(_z_ === i) break;
      i = _B_;
     }
    }
    return s[1];
   }
   var
    blank = set(cst$0),
    _i_ = [0, cseq(248, 255), 0],
    _j_ = [0, cseq(223, 246), _i_],
    _k_ = [0, single(181), _j_],
    lower = caml_call1(union_all, [0, cseq(97, 122), _k_]),
    _l_ = [0, single(186), 0],
    alpha =
      caml_call1(union_all, [0, lower, [0, upper, [0, single(170), _l_]]]),
    alnum = caml_call1(union_all, [0, alpha, [0, cdigit, 0]]),
    wordc = caml_call1(union_all, [0, alnum, [0, single(95), 0]]),
    _m_ = [0, cseq(127, 159), 0],
    cntrl = caml_call1(union_all, [0, cseq(0, 31), _m_]),
    _n_ = [0, cseq(160, 255), 0],
    graph = caml_call1(union_all, [0, cseq(33, 126), _n_]),
    _o_ = [0, cseq(160, 255), 0],
    print = caml_call1(union_all, [0, cseq(32, 126), _o_]),
    _p_ = [0, single(247), 0],
    _q_ = [0, single(215), _p_],
    _r_ = [0, cseq(187, 191), _q_],
    _s_ = [0, cseq(182, 185), _r_],
    _t_ = [0, cseq(171, 180), _s_],
    _u_ = [0, cseq(160, 169), _t_],
    _v_ = [0, cseq(123, 126), _u_],
    _w_ = [0, cseq(91, 96), _v_],
    _x_ = [0, cseq(58, 64), _w_],
    punct = caml_call1(union_all, [0, cseq(33, 47), _x_]),
    Re_Cset =
      [0,
       equal_c,
       to_int,
       of_int,
       to_char,
       of_char,
       -1,
       equal,
       iter,
       union,
       union_all,
       intersect_all,
       inter,
       diff,
       empty,
       single,
       add,
       mem,
       case_insens,
       cdigit,
       calpha,
       cword,
       notnl,
       ascii,
       nl,
       cseq,
       set,
       blank,
       space,
       xdigit,
       lower,
       upper,
       alpha,
       alnum,
       wordc,
       cntrl,
       graph,
       print,
       punct,
       pp,
       one_char,
       fold_right,
       hash,
       compare,
       CSetMap,
       cany,
       csingle,
       is_empty,
       prepend,
       pick,
       offset];
   runtime.caml_register_global(16, Re_Cset, "Re__Cset");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Hash_set
//# unitInfo: Requires: Re__Fmt, Re__Import, Stdlib__Array, Stdlib__Bytes, Stdlib__Format, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Fmt = global_data.Re__Fmt,
    Re_Import = global_data.Re__Import,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure;
   function length(t){return caml_ml_bytes_length(t) / 8 | 0;}
   function unsafe_get(t, i){
    return runtime.caml_int64_to_int32
            (caml_call2(Stdlib_Bytes[70], t, i * 8 | 0));
   }
   function unsafe_set(t, i, x){
    return caml_call3
            (Stdlib_Bytes[84], t, i * 8 | 0, runtime.caml_int64_of_int32(x));
   }
   function make_absent(len){
    return caml_call2(Stdlib_Bytes[1], len * 8 | 0, 255);
   }
   function init(t$0){
    if(caml_call1(Re_Import[10][10], t$0[1])){
     var
      t = runtime.caml_create_bytes(0),
      _v_ = length(t) - 1 | 0,
      _x_ = 0,
      x = -1,
      _u_ = 0;
     if(_v_ >= 0){
      var i = _u_;
      for(;;){
       unsafe_set(t, i, x);
       var _w_ = i + 1 | 0;
       if(_v_ === i) break;
       i = _w_;
      }
     }
     t$0[1] = caml_call1(Re_Import[10][2], [0, t, _x_]);
    }
    return caml_call1(Re_Import[10][4], t$0[1]);
   }
   var
    absent = -1,
    x = make_absent(1),
    _a_ = unsafe_get(x, 0),
    cst_size = "size",
    cst_table = "table",
    _c_ = [0, [15, [17, 4, [15, [17, 4, 0]]]], "%a@.%a@."],
    _d_ = [0, "lib/hash_set.ml", 60, 2];
   if(! caml_call2(Re_Import[3], _a_, absent))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
   function create(param){return [0, Re_Import[10][1]];}
   function index_of_offset(slots, index, i){
    var i$0 = index + i[1] | 0;
    return slots <= i$0 ? i$0 - slots | 0 : i$0;
   }
   function clear(t){
    var match = t[1];
    if(! match) return 0;
    var t$0 = match[1];
    t$0[2] = 0;
    var t$1 = t$0[1];
    return caml_call4
            (Stdlib_Bytes[10], t$1, 0, caml_ml_bytes_length(t$1), 255);
   }
   function _b_(t, x){
    var
     hash = caml_call1(Re_Import[11][14], x),
     slots = length(t[1]),
     index = hash & (slots - 1 | 0),
     inserting = [0, 1],
     i = [0, 0];
    for(;;){
     if(! inserting[1]){t[2] = t[2] + 1 | 0; return 0;}
     var idx = index_of_offset(slots, index, i), elem = unsafe_get(t[1], idx);
     if(caml_call2(Re_Import[3], elem, absent)){
      unsafe_set(t[1], idx, x);
      inserting[1] = 0;
     }
     else
      i[1]++;
    }
   }
   function add(t, x){
    var
     t$0 = init(t),
     slots = length(t$0[1]),
     _l_ = caml_call2(Re_Import[3], slots, 0);
    a:
    {
     if(_l_)
      var _m_ = _l_;
     else{
      var _n_ = caml_call2(Re_Import[6], t$0[2], 0);
      if(_n_){
       var
        _o_ = runtime.caml_div(slots, t$0[2]),
        _t_ = caml_call2(Re_Import[5], _o_, 2);
       break a;
      }
      var _m_ = _n_;
     }
     var _t_ = _m_;
    }
    if(_t_){
     var
      old_table = t$0[1],
      slots$0 = length(old_table),
      _p_ = caml_call2(Re_Import[3], slots$0, 0) ? 1 : slots$0 << 1,
      table = make_absent(_p_);
     t$0[1] = table;
     var _r_ = slots$0 - 1 | 0, _q_ = 0;
     if(_r_ >= 0){
      var i = _q_;
      for(;;){
       var elem = unsafe_get(old_table, i);
       if(elem !== -1) _b_(t$0, elem);
       var _s_ = i + 1 | 0;
       if(_r_ === i) break;
       i = _s_;
      }
     }
    }
    return _b_(t$0, x);
   }
   function is_empty(t){
    var t$0 = t[1];
    if(caml_call1(Re_Import[10][10], t$0)) return 1;
    var t$1 = caml_call1(Re_Import[10][4], t$0);
    return caml_call2(Re_Import[3], t$1[2], 0);
   }
   function mem(t, x){
    var t$0 = t[1];
    if(! caml_call1(Re_Import[10][10], t$0)){
     var _k_ = caml_call1(Re_Import[10][4], t$0)[2];
     if(! caml_call2(Re_Import[3], _k_, 0)){
      var
       t$1 = caml_call1(Re_Import[10][4], t$0),
       hash = caml_call1(Re_Import[11][14], x),
       slots = length(t$1[1]),
       index = hash & (slots - 1 | 0),
       i = [0, 0],
       found = [0, 0];
      for(;;){
       if(! found[1] && caml_call2(Re_Import[5], i[1], slots)){
        var
         idx = index_of_offset(slots, index, i),
         elem = unsafe_get(t$1[1], idx);
        if(caml_call2(Re_Import[11][8], elem, x))
         found[1] = 1;
        else if(caml_call2(Re_Import[11][8], elem, absent))
         i[1] = slots;
        else
         i[1]++;
        continue;
       }
       return found[1];
      }
     }
    }
    return 0;
   }
   function pp(fmt, t){
    var
     match = init(t),
     table = match[1],
     size = match[2],
     init$0 = [0, 0],
     _f_ = length(table) - 1 | 0,
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      var
       i$0 = unsafe_get(table, i),
       acc = init$0[1],
       _g_ = caml_call2(Re_Import[3], i$0, absent) ? acc : [0, i$0, acc];
      init$0[1] = _g_;
      var _h_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _h_;
     }
    }
    var
     _i_ = caml_call1(Stdlib_ListLabels[10], init$0[1]),
     table$0 = caml_call1(Stdlib_Array[11], _i_);
    function table$1(fmt, param){
     var _j_ = caml_call2(Re_Fmt[13], 0, Re_Fmt[8]);
     return caml_call4(Re_Fmt[2], fmt, cst_table, _j_, table$0);
    }
    function size$0(fmt, param){
     return caml_call4(Re_Fmt[2], fmt, cst_size, Re_Fmt[8], size);
    }
    return caml_call6(Stdlib_Format[139], fmt, _c_, table$1, 0, size$0, 0);
   }
   var Re_Hash_set = [0, create, is_empty, add, mem, clear, pp];
   runtime.caml_register_global(11, Re_Hash_set, "Re__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Mark_infos
//# unitInfo: Requires: Re__Import, Stdlib__Array, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Import = global_data.Re__Import,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function make(marks){
    var
     len =
       1
       +
        caml_call3
         (Stdlib_ListLabels[26],
          function(ma, param){
           var i = param[1];
           return caml_call2(Re_Import[8], ma, i);
          },
          -1,
          marks)
       | 0,
     t = runtime.caml_make_vect(len, -1);
    caml_call2
     (Stdlib_ListLabels[18],
      function(param){
       var v = param[2], i = param[1];
       caml_check_bound(t, i)[1 + i] = v;
       return 0;
      },
      marks);
    return t;
   }
   function test(t, i){
    if(t.length - 1 <= (2 * i | 0)) return 0;
    var _e_ = 2 * i | 0;
    return -1 !== caml_check_bound(t, _e_)[1 + _e_] ? 1 : 0;
   }
   function offset(t, i){
    var start_i = 2 * i | 0, stop_i = start_i + 1 | 0;
    if(t.length - 1 <= stop_i) return 0;
    var start = caml_check_bound(t, start_i)[1 + start_i];
    if(caml_call2(Re_Import[3], start, -1)) return 0;
    var stop = caml_check_bound(t, stop_i)[1 + stop_i];
    return [0, [0, start, stop]];
   }
   function iteri(t, f){
    var _b_ = ((t.length - 1) / 2 | 0) - 1 | 0, _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var idx = 2 * i | 0, start = caml_check_bound(t, idx)[1 + idx];
      if(-1 !== start){
       var _c_ = idx + 1 | 0, stop = caml_check_bound(t, _c_)[1 + _c_];
       caml_call3(f, i, start, stop);
      }
      var _d_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _d_;
     }
    }
    return 0;
   }
   var Re_Mark_infos = [0, make, offset, test, iteri];
   runtime.caml_register_global(2, Re_Mark_infos, "Re__Mark_infos");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pmark
//# unitInfo: Requires: Stdlib__Format, Stdlib__List, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var global_data = runtime.caml_get_global_data();
   global_data.Stdlib__List;
   var
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Set = global_data.Stdlib__Set;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare, r = [0, 0];
   function gen(param){r[1]++; return r[1];}
   var
    pp = Stdlib_Format[19],
    Set = caml_call1(Stdlib_Set[1], [0, compare]),
    empty = Set[1],
    add = Set[2],
    singleton = Set[3],
    remove = Set[4],
    union = Set[5],
    inter = Set[6],
    disjoint = Set[7],
    diff = Set[8],
    cardinal = Set[9],
    elements = Set[10],
    min_elt = Set[11],
    min_elt_opt = Set[12],
    max_elt = Set[13],
    max_elt_opt = Set[14],
    choose = Set[15],
    choose_opt = Set[16],
    find = Set[17],
    find_opt = Set[18],
    find_first = Set[19],
    find_first_opt = Set[20],
    find_last = Set[21],
    find_last_opt = Set[22],
    iter = Set[23],
    fold = Set[24],
    map = Set[25],
    filter = Set[26],
    filter_map = Set[27],
    partition = Set[28],
    split = Set[29],
    is_empty = Set[30],
    mem = Set[31],
    equal$0 = Set[32],
    compare$0 = Set[33],
    subset = Set[34],
    for_all = Set[35],
    exists = Set[36],
    to_list = Set[37],
    of_list = Set[38],
    to_seq_from = Set[39],
    to_seq = Set[40],
    to_rev_seq = Set[41],
    add_seq = Set[42],
    of_seq = Set[43],
    Re_Pmark =
      [0,
       equal,
       compare,
       gen,
       pp,
       [0,
        empty,
        add,
        singleton,
        remove,
        union,
        inter,
        disjoint,
        diff,
        cardinal,
        elements,
        min_elt,
        min_elt_opt,
        max_elt,
        max_elt_opt,
        choose,
        choose_opt,
        find,
        find_opt,
        find_first,
        find_first_opt,
        find_last,
        find_last_opt,
        iter,
        fold,
        map,
        filter,
        filter_map,
        partition,
        split,
        is_empty,
        mem,
        equal$0,
        compare$0,
        subset,
        for_all,
        exists,
        of_list,
        to_seq_from,
        to_seq,
        to_rev_seq,
        add_seq,
        of_seq,
        to_list]];
   runtime.caml_register_global(3, Re_Pmark, "Re__Pmark");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Automata
//# unitInfo: Requires: Re__Bit_vector, Re__Category, Re__Cset, Re__Fmt, Re__Hash_set, Re__Import, Re__Mark_infos, Re__Pmark, Stdlib, Stdlib__Format, Stdlib__Hashtbl, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _e_ = [1, 0],
    Re_Cset = global_data.Re__Cset,
    Re_Category = global_data.Re__Category,
    Re_Bit_vector = global_data.Re__Bit_vector,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Import = global_data.Re__Import,
    Stdlib_Format = global_data.Stdlib__Format,
    Re_Fmt = global_data.Re__Fmt,
    Re_Mark_infos = global_data.Re__Mark_infos,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Re_Pmark = global_data.Re__Pmark,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Re_Hash_set = global_data.Re__Hash_set;
   function hash_combine(h, accu){return (accu * 65599 | 0) + h | 0;}
   var equal = Re_Import[11][8];
   function create(param){return [0, 0];}
   var
    _b_ = Re_Hash_set[3],
    _c_ = Re_Hash_set[4],
    equal$0 = Re_Import[1][1],
    cst_long = "long",
    cst_first = "first",
    cst_short = "short",
    cst_Non_greedy = "Non_greedy",
    cst_Greedy = "Greedy";
   function pp(ch, k){
    var
     _N_ =
       -730718166 === k ? cst_long : 332064784 <= k ? cst_first : cst_short;
    return caml_call2(Stdlib_Format[13], ch, _N_);
   }
   function pp$0(fmt, param){
    return 620821490 <= param
            ? caml_call2(Stdlib_Format[13], fmt, cst_Non_greedy)
            : caml_call2(Stdlib_Format[13], fmt, cst_Greedy);
   }
   var
    Rep_kind = [0, pp$0],
    equal$1 = Re_Import[11][8],
    compare = Re_Import[11][9],
    pp$1 = Stdlib_Format[19];
   function prev(x){return x - 1 | 0;}
   function next(x){return x + 1 | 0;}
   function next2(x){return x + 2 | 0;}
   function group_count(x){return x / 2 | 0;}
   function to_int(x){return x;}
   var
    equal$2 = Re_Import[11][8],
    unknown = -1,
    cst_eps = "eps",
    cst_cst = "cst",
    cst_alt = "alt",
    cst_seq = "seq",
    cst_rep = "rep",
    cst_mark = "mark",
    cst_erase = "erase",
    cst_before = "before",
    cst_after = "after",
    cst_pmark = "pmark";
   function pp$2(ch, e){
    var match = e[2];
    if(typeof match === "number") return caml_call2(Re_Fmt[3], ch, cst_eps);
    switch(match[0]){
      case 0:
       var l = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_cst, Re_Cset[39], l);
      case 1:
       var l$0 = match[1], _J_ = caml_call2(Re_Fmt[11], 0, pp$2);
       return caml_call4(Re_Fmt[2], ch, cst_alt, _J_, l$0);
      case 2:
       var
        e$0 = match[3],
        e$1 = match[2],
        k = match[1],
        _K_ = caml_call3(Re_Fmt[10], pp, pp$2, pp$2);
       return caml_call4(Re_Fmt[2], ch, cst_seq, _K_, [0, k, e$1, e$0]);
      case 3:
       var
        e$2 = match[3],
        k$0 = match[2],
        _L_ = caml_call2(Re_Fmt[9], pp, pp$2);
       return caml_call4(Re_Fmt[2], ch, cst_rep, _L_, [0, k$0, e$2]);
      case 4:
       var i = match[1]; return caml_call4(Re_Fmt[2], ch, cst_mark, pp$1, i);
      case 5:
       var
        e$3 = match[2],
        b = match[1],
        _M_ = caml_call2(Re_Fmt[9], pp$1, pp$1);
       return caml_call4(Re_Fmt[2], ch, cst_erase, _M_, [0, b, e$3]);
      case 6:
       var c = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_before, Re_Category[14], c);
      case 7:
       var c$0 = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_after, Re_Category[14], c$0);
      default:
       var i$0 = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_pmark, Re_Pmark[4], i$0);
    }
   }
   var eps_expr = [0, 0, 0];
   function mk(ids, def){ids[1]++; return [0, ids[1], def];}
   function empty(ids){return mk(ids, _e_);}
   function cst(ids, s){
    return caml_call1(Re_Cset[47], s) ? mk(ids, _e_) : mk(ids, [0, s]);
   }
   function eps(ids){return mk(ids, 0);}
   function rep(ids, kind, sem, x){return mk(ids, [3, kind, sem, x]);}
   function mark(ids, m){return mk(ids, [4, m]);}
   function pmark(ids, i){return mk(ids, [8, i]);}
   function erase(ids, m$0, m){return mk(ids, [5, m$0, m]);}
   function before(ids, c){return mk(ids, [6, c]);}
   function after(ids, c){return mk(ids, [7, c]);}
   function alt(ids, l){
    if(! l) return mk(ids, _e_);
    if(l[2]) return mk(ids, [1, l]);
    var c = l[1];
    return c;
   }
   function seq(ids, kind, x, y){
    var _H_ = x[2], _I_ = y[2];
    if(typeof _H_ !== "number" && 1 === _H_[0] && ! _H_[1]) return x;
    if(typeof _I_ !== "number" && 1 === _I_[0] && ! _I_[1]) return y;
    if(typeof _H_ === "number") return y;
    if(typeof _I_ === "number" && caml_call2(equal$0, kind, 332064784))
     return x;
    return mk(ids, [2, kind, x, y]);
   }
   function is_eps(expr){return typeof expr[2] === "number" ? 1 : 0;}
   function rename(ids, x){
    var match = x[2];
    if(typeof match !== "number")
     switch(match[0]){
       case 1:
        var l = match[1];
        return mk
                (ids,
                 [1,
                  caml_call2
                   (Stdlib_ListLabels[20],
                    function(_G_){return rename(ids, _G_);},
                    l)]);
       case 2:
        var z = match[3], y = match[2], k = match[1], _F_ = rename(ids, z);
        return mk(ids, [2, k, rename(ids, y), _F_]);
       case 3:
        var y$0 = match[3], k$0 = match[2], g = match[1];
        return mk(ids, [3, g, k$0, rename(ids, y$0)]);
     }
    return mk(ids, x[2]);
   }
   function equal$3(param, t){
    var
     pmarks = param[2],
     marks = param[1],
     _C_ =
       caml_call3
        (Stdlib_ListLabels[16],
         function(_D_, param){
          var
           y = param[2],
           x = param[1],
           y$0 = _D_[2],
           x$0 = _D_[1],
           _E_ = caml_call2(equal$1, x$0, x);
          return _E_ ? caml_call2(equal$2, y$0, y) : _E_;
         },
         marks,
         t[1]);
    return _C_ ? caml_call2(Re_Pmark[5][32], pmarks, t[2]) : _C_;
   }
   var empty$0 = [0, 0, Re_Pmark[5][1]];
   function f(acc, param){
    var i = param[2], a = param[1];
    return hash_combine(a, hash_combine(i, acc));
   }
   function hash(m, accu){
    var
     init = hash_combine(caml_call1(Stdlib_Hashtbl[28], m[2]), accu),
     l = m[1];
    return caml_call3(Stdlib_ListLabels[26], f, init, l);
   }
   function marks_set_idx(idx, marks){
    if(! marks) return 0;
    var rem = marks[2], match = marks[1], idx$0 = match[2], a = match[1];
    return caml_call2(equal$2, idx$0, unknown)
            ? [0, [0, a, idx], marks_set_idx(idx, rem)]
            : marks;
   }
   function marks_set_idx$0(marks, idx){
    var _B_ = marks[2];
    return [0, marks_set_idx(idx, marks[1]), _B_];
   }
   var Status = [0];
   function equal_list(l1, l2){
    return caml_call3(Stdlib_ListLabels[16], equal$4, l1, l2);
   }
   function equal$4(x, y){
    switch(x[0]){
      case 0:
       var e1 = x[3], l1 = x[2];
       if(0 === y[0]){
        var e2 = y[3], l2 = y[2], _z_ = caml_call2(equal, e1[1], e2[1]);
        return _z_ ? equal_list(l1, l2) : _z_;
       }
       break;
      case 1:
       var e1$0 = x[2], marks1 = x[1];
       if(1 === y[0]){
        var
         e2$0 = y[2],
         marks2 = y[1],
         _A_ = caml_call2(equal, e1$0[1], e2$0[1]);
        return _A_ ? equal$3(marks1, marks2) : _A_;
       }
       break;
      default:
       var marks1$0 = x[1];
       if(2 === y[0]){
        var marks2$0 = y[1];
        return equal$3(marks1$0, marks2$0);
       }
    }
    return 0;
   }
   var letrec_function_context = [];
   function hash_list(l, init){
    return caml_call3
            (Stdlib_ListLabels[26], letrec_function_context[1], init, l);
   }
   function f$0(accu, x$1){
    switch(x$1[0]){
      case 0:
       var e = x$1[3], l = x$1[2], _x_ = hash_list(l, accu), x = e[1];
       return hash_combine(388635598, hash_combine(x, _x_));
      case 1:
       var
        e$0 = x$1[2],
        marks = x$1[1],
        _y_ = hash(marks, accu),
        x$0 = e$0[1];
       return hash_combine(726404471, hash_combine(x$0, _y_));
      default:
       var marks$0 = x$1[1];
       return hash_combine(471882453, hash(marks$0, accu));
    }
   }
   var _a_ = Re_Hash_set[5], _d_ = Re_Hash_set[1];
   runtime.caml_update_dummy(letrec_function_context, [0, f$0]);
   function tseq(kind, x, y, rem){
    a:
    if(x){
     var _v_ = x[1];
     if(1 === _v_[0] && typeof _v_[2][2] === "number" && ! x[2]){var marks = _v_[1], _w_ = [0, [1, marks, y], 0]; break a;}
     var _w_ = [0, [0, kind, x, y], 0];
    }
    else
     var _w_ = 0;
    return caml_call2(Stdlib[37], _w_, rem);
   }
   function first_match(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var match = param$0[1];
     if(2 === match[0]){var marks = match[1]; return [0, marks];}
     var r = param$0[2];
     param$0 = r;
    }
   }
   var
    remove_matches =
      caml_call1
       (Stdlib_ListLabels[44],
        function(param){return 2 === param[0] ? 0 : 1;});
   function set_idx(idx, xs){
    return caml_call2
            (Stdlib_ListLabels[20],
             function(param){
              switch(param[0]){
                case 0:
                 var x = param[3], l = param[2], kind = param[1];
                 return [0, kind, set_idx(idx, l), x];
                case 1:
                 var x$0 = param[2], marks = param[1];
                 return [1, marks_set_idx$0(marks, idx), x$0];
                default:
                 var marks$0 = param[1];
                 return [2, marks_set_idx$0(marks$0, idx)];
              }
             },
             xs);
   }
   function idx(t){return t[1];}
   var
    dummy = [0, unknown, Re_Category[3], 0, Re_Import[10][17][1], -1],
    initial = 0;
   function mk$0(idx, cat, desc){
    var
     _u_ =
       hash_list
        (desc,
         hash_combine(idx, hash_combine(caml_call1(Re_Category[10], cat), 0)))
       & 1073741823;
    return [0, idx, cat, desc, Re_Import[10][17][1], _u_];
   }
   function create$0(cat, expr){
    return mk$0(initial, cat, [0, [1, empty$0, expr], 0]);
   }
   function equal$5(param, t){
    var
     desc = param[3],
     category = param[2],
     idx = param[1],
     hash = param[5],
     _q_ = caml_call2(Re_Import[11][8], hash, t[5]);
    if(_q_){
     var _r_ = caml_call2(equal$2, idx, t[1]);
     if(_r_){
      var _s_ = caml_call2(Re_Category[11], category, t[2]);
      if(_s_) return equal_list(desc, t[3]);
      var _t_ = _s_;
     }
     else
      var _t_ = _r_;
    }
    else
     var _t_ = _q_;
    return _t_;
   }
   function status(s){
    var status = s[4];
    if(caml_call1(Re_Import[10][17][4], status))
     return caml_call1(Re_Import[10][17][5], status);
    var param = s[3];
    if(param){
     var match = param[1];
     if(2 === match[0])
      var
       m = match[1],
       _p_ = m[2],
       st = [0, caml_call1(Re_Mark_infos[1], m[1]), _p_];
     else
      var st = 1;
    }
    else
     var st = 0;
    s[4] = caml_call1(Re_Import[10][17][2], st);
    return st;
   }
   function hash$0(t){return t[5];}
   var
    Table = caml_call1(Stdlib_Hashtbl[26], [0, equal$5, hash$0]),
    _f_ = [0, "lib/automata.ml", 423, 14];
   function create$1(param){
    var _o_ = caml_call1(_d_, 0);
    return [0, caml_call1(Re_Bit_vector[3], 1), _o_];
   }
   function index_count(w){return caml_call1(Re_Bit_vector[1], w[1]);}
   function mark_used_indices(tbl){
    return caml_call1
            (Stdlib_ListLabels[18],
             function(e){
              if(0 === e[0]){
               var l = e[2];
               return caml_call1(mark_used_indices(tbl), l);
              }
              var marks = e[1];
              return caml_call2
                      (Stdlib_ListLabels[18],
                       function(param){
                        var i = param[2], _n_ = 0 <= i ? 1 : 0;
                        return _n_ ? caml_call3(Re_Bit_vector[2], tbl, i, 1) : _n_;
                       },
                       marks[1]);
             });
   }
   function loop(seen, l, y){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var x = l$0[1];
     switch(x[0]){
       case 0:
        var
         r = l$0[2],
         x$0 = x[3],
         l$1 = x[2],
         kind = x[1],
         l$2 = loop(seen, l$1, x$0),
         r$0 = loop(seen, r, y);
        return tseq(kind, l$2, x$0, r$0);
       case 1:
        if(typeof x[2][2] === "number"){
         var r$1 = l$0[2];
         if(! caml_call2(_c_, seen, y[1])){
          caml_call2(_b_, seen, y[1]);
          return [0, x, loop(seen, r$1, y)];
         }
         l$0 = r$1;
        }
        else{
         var r$2 = l$0[2], x$1 = x[2];
         if(! caml_call2(_c_, seen, x$1[1])){
          caml_call2(_b_, seen, x$1[1]);
          return [0, x, loop(seen, r$2, y)];
         }
         l$0 = r$2;
        }
        break;
       default: return [0, x, 0];
     }
    }
   }
   function delta_expr$0(counter, ctx, marks$2, x, rem){
    var c = ctx[1], match = x[2];
    if(typeof match === "number") return [0, [2, marks$2], rem];
    switch(match[0]){
      case 0:
       var s = match[1];
       return caml_call2(Re_Cset[17], c, s)
               ? [0, [1, marks$2, eps_expr], rem]
               : rem;
      case 1:
       var l = match[1];
       if(counter >= 50)
        return caml_trampoline_return(delta_alt$0, [0, ctx, marks$2, l, rem]);
       var counter$1 = counter + 1 | 0;
       return delta_alt$0(counter$1, ctx, marks$2, l, rem);
      case 2:
       var
        z = match[3],
        y = match[2],
        kind = match[1],
        y$0 = delta_expr(ctx, marks$2, y, 0);
       if(counter >= 50)
        return caml_trampoline_return
                (delta_seq$0, [0, ctx, kind, y$0, z, rem]);
       var counter$0 = counter + 1 | 0;
       return delta_seq$0(counter$0, ctx, kind, y$0, z, rem);
      case 3:
       var
        y$1 = match[3],
        kind$0 = match[2],
        rep_kind = match[1],
        y$2 = delta_expr(ctx, marks$2, y$1, 0),
        match$0 = first_match(y$2);
       if(match$0)
        var
         marks$3 = match$0[1],
         marks$4 = marks$3,
         y$3 = caml_call1(remove_matches, y$2);
       else
        var marks$4 = marks$2, y$3 = y$2;
       return 620821490 <= rep_kind
               ? [0, [2, marks$2], tseq(kind$0, y$3, x, rem)]
               : tseq(kind$0, y$3, x, [0, [2, marks$4], rem]);
      case 4:
       var
        i = match[1],
        _k_ = marks$2[2],
        marks$0 =
          [0,
           [0,
            [0, i, unknown],
            caml_call2(Stdlib_ListLabels[56], i, marks$2[1])],
           _k_];
       return [0, [2, marks$0], rem];
      case 5:
       var
        stop_inclusive = match[2],
        start_inclusive = match[1],
        _j_ = marks$2[2],
        marks =
          [0,
           caml_call2
            (Stdlib_ListLabels[44],
             function(param){
              var
               i = param[1],
               _m_ = caml_call2(Re_Import[5], i, start_inclusive);
              return _m_ ? _m_ : caml_call2(Re_Import[6], i, stop_inclusive);
             },
             marks$2[1]),
           _j_];
       return [0, [2, marks], rem];
      case 6:
       var cat = match[1];
       return caml_call2(Re_Category[13], ctx[3], cat)
               ? [0, [2, marks$2], rem]
               : rem;
      case 7:
       var cat$0 = match[1];
       return caml_call2(Re_Category[13], ctx[2], cat$0)
               ? [0, [2, marks$2], rem]
               : rem;
      default:
       var
        i$0 = match[1],
        _l_ = caml_call2(Re_Pmark[5][2], i$0, marks$2[2]),
        marks$1 = [0, marks$2[1], _l_];
       return [0, [2, marks$1], rem];
    }
   }
   function delta_expr(ctx, marks, x, rem){
    return caml_trampoline(delta_expr$0(0, ctx, marks, x, rem));
   }
   function delta_alt$0(counter, ctx, marks, l, rem){
    if(! l) return rem;
    var r = l[2], y = l[1], _i_ = delta_alt(ctx, marks, r, rem);
    if(counter >= 50)
     return caml_trampoline_return(delta_expr$0, [0, ctx, marks, y, _i_]);
    var counter$0 = counter + 1 | 0;
    return delta_expr$0(counter$0, ctx, marks, y, _i_);
   }
   function delta_alt(ctx, marks, l, rem){
    return caml_trampoline(delta_alt$0(0, ctx, marks, l, rem));
   }
   function delta_seq$0(counter, ctx, kind, y$1, z, rem){
    var match = first_match(y$1);
    if(! match) return tseq(kind, y$1, z, rem);
    var marks = match[1];
    if(-730718166 === kind){
     var _g_ = delta_expr(ctx, marks, z, rem);
     return tseq(kind, caml_call1(remove_matches, y$1), z, _g_);
    }
    if(332064784 > kind){
     var _h_ = tseq(kind, caml_call1(remove_matches, y$1), z, rem);
     if(counter >= 50)
      return caml_trampoline_return(delta_expr$0, [0, ctx, marks, z, _h_]);
     var counter$0 = counter + 1 | 0;
     return delta_expr$0(counter$0, ctx, marks, z, _h_);
    }
    var l = 0, param = y$1;
    for(;;){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     var x = param[1];
     if(2 === x[0]){
      var
       r$0 = param[2],
       y = caml_call1(remove_matches, r$0),
       y$0 = caml_call1(Stdlib_ListLabels[10], l);
      return tseq
              (kind, y$0, z, delta_expr(ctx, marks, z, tseq(kind, y, z, rem)));
     }
     var r = param[2], l$0 = [0, x, l];
     l = l$0;
     param = r;
    }
   }
   function delta_seq(ctx, kind, y, z, rem){
    return caml_trampoline(delta_seq$0(0, ctx, kind, y, z, rem));
   }
   function delta_desc(ctx, marks$0, l, rem){
    if(! l) return rem;
    var r = l[2], y$1 = l[1], rem$0 = delta_desc(ctx, marks$0, r, rem);
    switch(y$1[0]){
      case 0:
       var
        z = y$1[3],
        y = y$1[2],
        kind = y$1[1],
        y$0 = delta_desc(ctx, marks$0, y, 0);
       return delta_seq(ctx, kind, y$0, z, rem$0);
      case 1:
       var e = y$1[2], marks = y$1[1];
       return delta_expr(ctx, marks, e, rem$0);
      default: return [0, y$1, rem$0];
    }
   }
   function delta(tbl_ref, next_cat, char$0, st){
    var
     prev_cat = st[2],
     ctx = [0, char$0, prev_cat, next_cat],
     l = delta_desc(ctx, empty$0, st[3], 0),
     seen = tbl_ref[2];
    caml_call1(_a_, seen);
    var expr = loop(seen, l, eps_expr);
    caml_call1(Re_Bit_vector[5], tbl_ref[1]);
    caml_call1(mark_used_indices(tbl_ref[1]), expr);
    var
     len = caml_call1(Re_Bit_vector[1], tbl_ref[1]),
     tbl = tbl_ref[1],
     idx = 0;
    for(;;){
     if
      (!
       caml_call2(Re_Import[3], idx, len)
       && caml_call2(Re_Bit_vector[4], tbl, idx)){
      var idx$0 = idx + 1 | 0;
      idx = idx$0;
      continue;
     }
     if(caml_call2(Re_Import[3], idx, len))
      tbl_ref[1] = caml_call1(Re_Bit_vector[3], 2 * len | 0);
     var expr$0 = set_idx(idx, expr);
     return mk$0(idx, next_cat, expr$0);
    }
   }
   var
    Re_Automata =
      [0,
       [0, compare, 0, prev, next, next2, group_count],
       [0, pp],
       Rep_kind,
       is_eps,
       pp$2,
       [0, create],
       cst,
       empty,
       alt,
       seq,
       eps,
       rep,
       mark,
       pmark,
       erase,
       before,
       after,
       rename,
       [0, to_int],
       Status,
       [0, dummy, create$0, idx, status, Table],
       [0, create$1, index_count],
       delta];
   runtime.caml_register_global(42, Re_Automata, "Re__Automata");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Color_map
//# unitInfo: Requires: Re__Cset, Stdlib__Bytes, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Cset = global_data.Re__Cset,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function repr(t, color){
    return caml_string_get(t, caml_call1(Re_Cset[2], color));
   }
   var length = runtime.caml_ml_string_length, Repr = [0, repr, length];
   function get_char(t, c){
    return caml_string_get(t, caml_call1(Re_Cset[2], c));
   }
   function get(t, c){
    return caml_call1(Re_Cset[5], runtime.caml_string_unsafe_get(t, c));
   }
   function translate_colors(cm, cset){
    return caml_call3
            (Re_Cset[41],
             cset,
             Re_Cset[14],
             function(i, j, l){
              var
               start = get_char(cm, i),
               stop = get_char(cm, j),
               _d_ = caml_call2(Re_Cset[25], start, stop);
              return caml_call2(Re_Cset[9], _d_, l);
             });
   }
   var Table = [0, get_char, get, translate_colors];
   function make(param){return caml_call2(Stdlib_Bytes[1], 257, 0);}
   function flatten(cm){
    var
     c = caml_create_bytes(256),
     color_repr = caml_create_bytes(256),
     v = [0, 0];
    caml_bytes_set(c, 0, 0);
    caml_bytes_set(color_repr, 0, 0);
    var i = 1;
    for(;;){
     if(0 !== runtime.caml_bytes_get(cm, i)) v[1]++;
     caml_bytes_set(c, i, caml_call1(Stdlib_Char[1], v[1]));
     var _b_ = caml_call1(Stdlib_Char[1], i);
     caml_bytes_set(color_repr, v[1], _b_);
     var _c_ = i + 1 | 0;
     if(255 === i){
      var _a_ = caml_call3(Stdlib_Bytes[8], color_repr, 0, v[1] + 1 | 0);
      return [0, caml_call1(Stdlib_Bytes[44], c), _a_];
     }
     i = _c_;
    }
   }
   function split(t, set){
    return caml_call2
            (Re_Cset[8],
             set,
             function(i, j){
              caml_bytes_set(t, caml_call1(Re_Cset[2], i), 1);
              return caml_bytes_set(t, caml_call1(Re_Cset[2], j) + 1 | 0, 1);
             });
   }
   var Re_Color_map = [0, Repr, Table, make, flatten, split];
   runtime.caml_register_global(3, Re_Color_map, "Re__Color_map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Ast
//# unitInfo: Requires: Re__Automata, Re__Color_map, Re__Cset, Re__Fmt, Re__Import, Re__Pmark, Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__ListLabels, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Re_repn$1 = "Re.repn",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    s = "Sequence",
    cst = cst$1,
    cst$0 = cst$1,
    empty_alternative = [0, 0],
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Format = global_data.Stdlib__Format,
    Re_Pmark = global_data.Re__Pmark,
    Re_Automata = global_data.Re__Automata,
    Re_Cset = global_data.Re__Cset,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Import = global_data.Re__Import,
    Stdlib = global_data.Stdlib,
    Re_Color_map = global_data.Re__Color_map,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    cst_Alternative = "Alternative",
    cst_No_case = "No_case",
    cst_Case = "Case",
    cst_Beg_of_line = "Beg_of_line",
    cst_End_of_line = "End_of_line",
    cst_Beg_of_word = "Beg_of_word",
    cst_End_of_word = "End_of_word",
    cst_Not_bound = "Not_bound",
    cst_Beg_of_str = "Beg_of_str",
    cst_End_of_str = "End_of_str",
    cst_Last_end_of_line = "Last_end_of_line",
    cst_Start = "Start",
    cst_Stop = "Stop",
    _a_ = [0, [15, [17, [0, "@ ", 1, 0], [4, 0, 0, 0, [15, 0]]]], "%a@ %d%a"],
    cst_Repeat = "Repeat",
    cst_Named_group = "Named_group",
    cst_Group = "Group",
    cst_No_group = "No_group",
    cst_Nest = "Nest",
    cst_Pmark = "Pmark",
    cst_Sem = "Sem",
    cst_Sem_greedy = "Sem_greedy",
    cst_Set = "Set",
    cst_Intersection = "Intersection",
    cst_Complement = "Complement",
    cst_Difference = "Difference";
   function pp_ast(f, fmt, ast){
    function var$0(s, re){return caml_call4(Re_Fmt[2], fmt, s, f, re);}
    switch(ast[0]){
      case 0:
       var alt = ast[1], _ah_ = caml_call2(Re_Fmt[11], 0, f);
       return caml_call4(Re_Fmt[2], fmt, cst_Alternative, _ah_, alt);
      case 1:
       var c = ast[1]; return var$0(cst_No_case, c);
      default: var c$0 = ast[1]; return var$0(cst_Case, c$0);
    }
   }
   function pp_gen(pp_cset, fmt, t){
    function pp(_af_, _ag_){return pp_gen(pp_cset, _af_, _ag_);}
    function var$0(s, re){return caml_call4(Re_Fmt[2], fmt, s, pp, re);}
    if(typeof t === "number")
     switch(t){
       case 0:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_line);
       case 1:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_line);
       case 2:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_word);
       case 3:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_word);
       case 4:
        return caml_call2(Re_Fmt[3], fmt, cst_Not_bound);
       case 5:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_str);
       case 6:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_str);
       case 7:
        return caml_call2(Re_Fmt[3], fmt, cst_Last_end_of_line);
       case 8:
        return caml_call2(Re_Fmt[3], fmt, cst_Start);
       default: return caml_call2(Re_Fmt[3], fmt, cst_Stop);
     }
    switch(t[0]){
      case 0:
       var cset = t[1]; return caml_call2(pp_cset, fmt, cset);
      case 1:
       var a = t[1]; return pp_ast(pp, fmt, a);
      case 2:
       var rel = t[1], _aa_ = caml_call2(Re_Fmt[11], 0, pp);
       return caml_call4(Re_Fmt[2], fmt, s, _aa_, rel);
      case 3:
       var
        stop = t[3],
        start = t[2],
        re = t[1],
        pp$0 =
          function(fmt, param){
           return caml_call7
                   (Stdlib_Format[139],
                    fmt,
                    _a_,
                    pp,
                    re,
                    start,
                    Re_Fmt[4],
                    stop);
          };
       return caml_call4(Re_Fmt[2], fmt, cst_Repeat, pp$0, 0);
      case 4:
       var match = t[1];
       if(match){
        var
         c = t[2],
         n = match[1],
         _ab_ = caml_call2(Re_Fmt[9], Re_Fmt[3], pp);
        return caml_call4(Re_Fmt[2], fmt, cst_Named_group, _ab_, [0, n, c]);
       }
       var c$0 = t[2];
       return var$0(cst_Group, c$0);
      case 5:
       var c$1 = t[1]; return var$0(cst_No_group, c$1);
      case 6:
       var c$2 = t[1]; return var$0(cst_Nest, c$2);
      case 7:
       var r = t[2], m = t[1], _ac_ = caml_call2(Re_Fmt[9], Re_Pmark[4], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Pmark, _ac_, [0, m, r]);
      case 8:
       var
        a$0 = t[2],
        sem = t[1],
        _ad_ = caml_call2(Re_Fmt[9], Re_Automata[2][1], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Sem, _ad_, [0, sem, a$0]);
      default:
       var
        re$0 = t[2],
        k = t[1],
        _ae_ = caml_call2(Re_Fmt[9], Re_Automata[3][1], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Sem_greedy, _ae_, [0, k, re$0]);
    }
   }
   function pp_cset(fmt, cset){
    function seq(s, rel){
     var _$_ = caml_call2(Re_Fmt[11], 0, pp_cset);
     return caml_call4(Re_Fmt[2], fmt, s, _$_, rel);
    }
    switch(cset[0]){
      case 0:
       var s = cset[1];
       return caml_call4(Re_Fmt[2], fmt, cst_Set, Re_Cset[39], s);
      case 1:
       var c = cset[1]; return seq(cst_Intersection, c);
      case 2:
       var c$0 = cset[1]; return seq(cst_Complement, c$0);
      case 3:
       var
        b = cset[2],
        a = cset[1],
        ___ = caml_call2(Re_Fmt[9], pp_cset, pp_cset);
       return caml_call4(Re_Fmt[2], fmt, cst_Difference, ___, [0, a, b]);
      default: var s$0 = cset[1]; return pp_ast(pp_cset, fmt, s$0);
    }
   }
   function equal(cset, x1, x2){
    var x1$0 = x1, x2$0 = x2;
    for(;;){
     a:
     {
      if(typeof x1$0 === "number"){
       switch(x1$0){
         case 0:
          if(typeof x2$0 !== "number" || x2$0) break a; break;
         case 1:
          if(typeof x2$0 !== "number" || 1 !== x2$0) break a; break;
         case 2:
          if(typeof x2$0 !== "number" || 2 !== x2$0) break a; break;
         case 3:
          if(typeof x2$0 !== "number" || 3 !== x2$0) break a; break;
         case 4:
          if(typeof x2$0 !== "number" || 4 !== x2$0) break a; break;
         case 5:
          if(typeof x2$0 !== "number" || 5 !== x2$0) break a; break;
         case 6:
          if(typeof x2$0 !== "number" || 6 !== x2$0) break a; break;
         case 7:
          if(typeof x2$0 !== "number" || 7 !== x2$0) break a; break;
         case 8:
          if(typeof x2$0 !== "number" || 8 !== x2$0) break a; break;
         default: if(typeof x2$0 !== "number" || 9 > x2$0) break a;
       }
       return 1;
      }
      switch(x1$0[0]){
        case 0:
         if(typeof x2$0 !== "number" && 0 === x2$0[0]){
          var s2 = x2$0[1], s1 = x1$0[1];
          return caml_call2(cset, s1, s2);
         }
         break;
        case 1:
         if(typeof x2$0 !== "number" && 1 === x2$0[0]){
          var
           y = x2$0[1],
           x = x1$0[1],
           eq = function(_Y_, _Z_){return equal(cset, _Y_, _Z_);},
           b = y[1],
           a = x[1];
          return caml_call3(Stdlib_ListLabels[16], eq, a, b);
         }
         break;
        case 2:
         if(typeof x2$0 !== "number" && 2 === x2$0[0]){
          var l2 = x2$0[1], l1 = x1$0[1];
          return caml_call3
                  (Stdlib_ListLabels[16],
                   function(_W_, _X_){return equal(cset, _W_, _X_);},
                   l1,
                   l2);
         }
         break;
        case 3:
         if(typeof x2$0 !== "number" && 3 === x2$0[0]){
          var
           j2 = x2$0[3],
           i2 = x2$0[2],
           x2$1 = x2$0[1],
           j1 = x1$0[3],
           i1 = x1$0[2],
           x1$1 = x1$0[1],
           _Q_ = caml_call2(Re_Import[11][8], i1, i2);
          if(_Q_){
           var _R_ = caml_call3(Re_Import[10][12], Re_Import[11][8], j1, j2);
           if(_R_){x1$0 = x1$1; x2$0 = x2$1; continue;}
           var _S_ = _R_;
          }
          else
           var _S_ = _Q_;
          return _S_;
         }
         break;
        case 4:
         if(typeof x2$0 !== "number" && 4 === x2$0[0]) return 0; break;
        case 6:
         if(typeof x2$0 !== "number" && 6 === x2$0[0]){
          var x2$2 = x2$0[1], x1$2 = x1$0[1];
          x1$0 = x1$2;
          x2$0 = x2$2;
          continue;
         }
         break;
        case 7:
         if(typeof x2$0 !== "number" && 7 === x2$0[0]){
          var
           r2 = x2$0[2],
           m2 = x2$0[1],
           r1 = x1$0[2],
           m1 = x1$0[1],
           _T_ = caml_call2(Re_Pmark[1], m1, m2);
          if(! _T_) return _T_;
          x1$0 = r1;
          x2$0 = r2;
          continue;
         }
         break;
        case 8:
         if(typeof x2$0 !== "number" && 8 === x2$0[0]){
          var
           x2$3 = x2$0[2],
           sem = x2$0[1],
           x1$3 = x1$0[2],
           sem$0 = x1$0[1],
           _U_ = caml_call2(Re_Import[1][1], sem$0, sem);
          if(! _U_) return _U_;
          x1$0 = x1$3;
          x2$0 = x2$3;
          continue;
         }
         break;
        case 9:
         if(typeof x2$0 !== "number" && 9 === x2$0[0]){
          var
           x2$4 = x2$0[2],
           rep = x2$0[1],
           x1$4 = x1$0[2],
           rep$0 = x1$0[1],
           _V_ = caml_call2(Re_Import[1][1], rep$0, rep);
          if(! _V_) return _V_;
          x1$0 = x1$4;
          x2$0 = x2$4;
          continue;
         }
         break;
      }
     }
     return 0;
    }
   }
   function pp(_O_, _P_){return pp_gen(pp_cset, _O_, _P_);}
   function cset(cset){return [0, [0, cset]];}
   function handle_case_cset(ign_case, param){
    var ign_case$0 = ign_case, param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var s = param$0[1];
        return ign_case$0 ? caml_call1(Re_Cset[18], s) : s;
       case 1:
        var
         l = param$0[1],
         _E_ =
           caml_call2
            (Stdlib_ListLabels[20],
             function(_N_){return handle_case_cset(ign_case$0, _N_);},
             l);
        return caml_call1(Re_Cset[11], _E_);
       case 2:
        var
         l$0 = param$0[1],
         _F_ =
           caml_call2
            (Stdlib_ListLabels[20],
             function(_M_){return handle_case_cset(ign_case$0, _M_);},
             l$0),
         _G_ = caml_call1(Re_Cset[10], _F_);
        return caml_call1(caml_call1(Re_Cset[13], Re_Cset[45]), _G_);
       case 3:
        var
         r = param$0[2],
         r$0 = param$0[1],
         _H_ = handle_case_cset(ign_case$0, r),
         _I_ = caml_call2(Re_Cset[13], Re_Cset[45], _H_),
         _J_ = handle_case_cset(ign_case$0, r$0);
        return caml_call2(Re_Cset[12], _J_, _I_);
       default:
        var match = param$0[1];
        switch(match[0]){
          case 0:
           var
            l$1 = match[1],
            _K_ =
              caml_call2
               (Stdlib_ListLabels[20],
                function(_L_){return handle_case_cset(ign_case$0, _L_);},
                l$1);
           return caml_call1(Re_Cset[10], _K_);
          case 1:
           var a = match[1]; ign_case$0 = 1; param$0 = a; break;
          default: var a$0 = match[1]; ign_case$0 = 0; param$0 = a$0;
        }
     }
   }
   function handle_case(ign_case, r){
    var ign_case$0 = ign_case, r$0 = r;
    for(;;){
     if(typeof r$0 === "number") return r$0;
     switch(r$0[0]){
       case 0:
        var s = r$0[1]; return [0, handle_case_cset(ign_case$0, s)];
       case 1:
        var match = r$0[1];
        switch(match[0]){
          case 0:
           var
            l = match[1],
            l$0 =
              caml_call2
               (Stdlib_ListLabels[20],
                function(_D_){return handle_case(ign_case$0, _D_);},
                l);
           return [1, [0, l$0]];
          case 1:
           var r$1 = match[1]; ign_case$0 = 1; r$0 = r$1; break;
          default: var r$2 = match[1]; ign_case$0 = 0; r$0 = r$2;
        }
        break;
       case 2:
        var l$1 = r$0[1];
        return [2,
                caml_call2
                 (Stdlib_ListLabels[20],
                  function(_C_){return handle_case(ign_case$0, _C_);},
                  l$1)];
       case 3:
        var j = r$0[3], i = r$0[2], r$3 = r$0[1];
        return [3, handle_case(ign_case$0, r$3), i, j];
       case 4:
        var r$4 = r$0[2], n = r$0[1];
        return [4, n, handle_case(ign_case$0, r$4)];
       case 5:
        var r$5 = r$0[1]; return [5, handle_case(ign_case$0, r$5)];
       case 6:
        var r$6 = r$0[1]; return [6, handle_case(ign_case$0, r$6)];
       case 7:
        var r$7 = r$0[2], i$0 = r$0[1];
        return [7, i$0, handle_case(ign_case$0, r$7)];
       case 8:
        var r$8 = r$0[2], k = r$0[1];
        return [8, k, handle_case(ign_case$0, r$8)];
       default:
        var r$9 = r$0[2], k$0 = r$0[1];
        return [9, k$0, handle_case(ign_case$0, r$9)];
     }
    }
   }
   function seq(l){if(l && ! l[2]){var r = l[1]; return r;} return [2, l];}
   function char$0(c){return cset(caml_call1(Re_Cset[46], c));}
   var any = cset(Re_Cset[45]);
   function str(s){
    var l = [0, 0], _z_ = caml_ml_string_length(s) - 1 | 0;
    if(_z_ >= 0){
     var i = _z_;
     for(;;){
      var _A_ = l[1];
      l[1] = [0, char$0(runtime.caml_string_get(s, i)), _A_];
      var _B_ = i - 1 | 0;
      if(0 === i) break;
      i = _B_;
     }
    }
    return seq(l[1]);
   }
   function as_set_elems(elems){
    try{
     var
      e =
        caml_call2
         (Stdlib_ListLabels[20],
          function(param){
           if(typeof param !== "number" && 0 === param[0]){var e = param[1]; return e;}
           throw Stdlib[3];
          },
          elems);
    }
    catch(_y_){
     var _x_ = caml_wrap_exception(_y_);
     if(_x_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_x_, 0);
    }
    return [0, e];
   }
   var empty = [1, empty_alternative];
   function alt(elems){
    if(! elems) return empty;
    if(! elems[2]){var x = elems[1]; return x;}
    var match = as_set_elems(elems);
    if(! match) return [1, [0, elems]];
    var elems$0 = match[1];
    return [0, [4, [0, elems$0]]];
   }
   var
    epsilon = seq(0),
    cst_Re_repn = cst_Re_repn$1,
    cst_Re_repn$0 = cst_Re_repn$1,
    _b_ = [0, 1];
   function repn(r, i, j){
    if(caml_call2(Re_Import[5], i, 0)) caml_call1(Stdlib[1], cst_Re_repn);
    if(j){
     var j$0 = j[1];
     if(caml_call2(Re_Import[5], j$0, i))
      return caml_call1(Stdlib[1], cst_Re_repn$0);
     if(0 === j$0){
      if(0 === i) return epsilon;
     }
     else if(1 === j$0 && 1 === i) return r;
    }
    return [3, r, i, j];
   }
   function rep(r){return repn(r, 0, 0);}
   function rep1(r){return repn(r, 1, 0);}
   function opt(r){return repn(r, 0, _b_);}
   var bow = 2, eow = 3;
   function word(r){return seq([0, bow, [0, r, [0, eow, 0]]]);}
   var bos = 5, eos = 6;
   function whole_string(r){return seq([0, bos, [0, r, [0, eos, 0]]]);}
   var
    cst_Re_inter = "Re.inter",
    cst_Re_compl = "Re.compl",
    cst_Re_diff = "Re.diff";
   function make_set(f, t){
    if(typeof t !== "number" && 0 === t[0]){
     var x = t[1];
     return [0, [4, caml_call1(f[1], x)]];
    }
    return [1, caml_call1(f[1], t)];
   }
   function preserve_set(f, t){
    if(typeof t !== "number" && 0 === t[0]) return t;
    return caml_call1(f, t);
   }
   function _c_(t){return [8, -730718166, t];}
   function longest(_w_){return preserve_set(_c_, _w_);}
   function _d_(t){return [8, -1034406550, t];}
   function shortest(_v_){return preserve_set(_d_, _v_);}
   function _e_(t){return [8, 332064784, t];}
   function first(_u_){return preserve_set(_e_, _u_);}
   function _f_(t){return [9, -904640576, t];}
   function greedy(_t_){return preserve_set(_f_, _t_);}
   function _g_(t){return [9, 620821490, t];}
   function non_greedy(_s_){return preserve_set(_g_, _s_);}
   function group(name, r){return [4, name, r];}
   function _h_(t){return [5, t];}
   function no_group(_r_){return preserve_set(_h_, _r_);}
   function nest(r){return [6, r];}
   function set(str){return cset(caml_call1(Re_Cset[26], str));}
   function mark(r){
    var i = caml_call1(Re_Pmark[3], 0);
    return [0, i, [7, i, r]];
   }
   function as_set_or_error(name, elems){
    var match = as_set_elems(elems);
    if(! match) return caml_call1(Stdlib[1], name);
    var s = match[1];
    return s;
   }
   function inter(elems){
    return [0, [1, as_set_or_error(cst_Re_inter, elems)]];
   }
   function compl(elems){
    return [0, [2, as_set_or_error(cst_Re_compl, elems)]];
   }
   function diff(r$0, r){
    if
     (typeof r$0 !== "number"
      && 0 === r$0[0] && typeof r !== "number" && 0 === r[0]){
     var r$1 = r[1], r$2 = r$0[1];
     return [0, [3, r$2, r$1]];
    }
    return caml_call1(Stdlib[1], cst_Re_diff);
   }
   var f = [0, function(r){return [2, r];}];
   function case$0(t){return make_set(f, t);}
   var
    f$0 = [0, function(r){return [1, r];}],
    _i_ = [0, "lib/ast.ml", 301, 32];
   function no_case(t){return make_set(f$0, t);}
   function witness(t){
    function witness(t){
     var t$0 = t;
     for(;;){
      if(typeof t$0 === "number") return cst;
      switch(t$0[0]){
        case 0:
         var
          c = t$0[1],
          _m_ = caml_call1(Re_Cset[49], c),
          _n_ = caml_call1(Re_Cset[4], _m_);
         return caml_call2(Stdlib_String[1], 1, _n_);
        case 1:
         var match = t$0[1][1];
         if(! match)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
         var x = match[1];
         t$0 = x;
         continue;
        case 2:
         var
          xs = t$0[1],
          _o_ = caml_call2(Stdlib_ListLabels[20], witness, xs);
         return caml_call2(Stdlib_String[7], cst$0, _o_);
        case 3:
         var
          from = t$0[2],
          r = t$0[1],
          w = witness(r),
          b =
            caml_call1
             (Stdlib_Buffer[1],
              runtime.caml_mul(caml_ml_string_length(w), from)),
          _p_ = 1;
         if(from >= 1){
          var i = _p_;
          for(;;){
           caml_call2(Stdlib_Buffer[16], b, w);
           var _q_ = i + 1 | 0;
           if(from === i) break;
           i = _q_;
          }
         }
         return caml_call1(Stdlib_Buffer[2], b);
        case 5:
         var r$1 = t$0[1]; t$0 = r$1; continue;
        case 6:
         var r$0 = t$0[1]; break;
        default: var r$0 = t$0[2];
      }
      t$0 = r$0;
     }
    }
    return witness(handle_case(0, t));
   }
   function merge_sequences(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var x = param$0[1];
     if(typeof x !== "number")
      switch(x[0]){
        case 1:
         var match = x[1];
         if(0 === match[0]){
          var r$0 = param$0[2], l = match[1];
          param$0 = caml_call2(Stdlib[37], l, r$0);
          continue;
         }
         break;
        case 2:
         var match$0 = x[1];
         if(match$0){
          var
           r$1 = param$0[2],
           y = match$0[2],
           x$0 = match$0[1],
           r$2 = merge_sequences(r$1);
          a:
          if(r$2){
           var _k_ = r$2[1];
           if(typeof _k_ !== "number" && 2 === _k_[0]){
            var match$1 = _k_[1];
            if(! match$1) break a;
            var r$3 = r$2[2], y$0 = match$1[2], x$1 = match$1[1];
            if(! equal(Re_Cset[7], x$0, x$1)) break a;
            var _l_ = [0, seq(y$0), 0];
            return [0, [2, [0, x$0, [0, [1, [0, [0, seq(y), _l_]]], 0]]], r$3];
           }
          }
          return [0, [2, [0, x$0, y]], r$2];
         }
         break;
      }
     var r = param$0[2];
     return [0, x, merge_sequences(r)];
    }
   }
   function colorize(color_map, regexp){
    var lnl = [0, 0];
    function colorize(regexp){
     var regexp$0 = regexp;
     for(;;){
      if(typeof regexp$0 === "number")
       switch(regexp$0){
         case 7:
          lnl[1] = 1; return 0;
         case 0:
         case 1:
          return caml_call2(Re_Color_map[5], color_map, Re_Cset[24]);
         case 2:
         case 3:
         case 4:
          return caml_call2(Re_Color_map[5], color_map, Re_Cset[21]);
         default: return 0;
       }
      switch(regexp$0[0]){
        case 0:
         var s = regexp$0[1];
         return caml_call2(Re_Color_map[5], color_map, s);
        case 1:
         var l = regexp$0[1][1];
         return caml_call2(Stdlib_ListLabels[18], colorize, l);
        case 2:
         var l$0 = regexp$0[1];
         return caml_call2(Stdlib_ListLabels[18], colorize, l$0);
        case 3:
         var regexp$1 = regexp$0[1]; regexp$0 = regexp$1; continue;
        case 4:
        case 7:
         var regexp$2 = regexp$0[2]; break;
        case 5:
        case 6:
         var regexp$2 = regexp$0[1]; break;
        default: var regexp$3 = regexp$0[2]; regexp$0 = regexp$3; continue;
      }
      regexp$0 = regexp$2;
     }
    }
    colorize(regexp);
    return lnl[1];
   }
   function anchored(param){
    var param$0 = param;
    for(;;){
     a:
     {
      if(typeof param$0 !== "number"){
       switch(param$0[0]){
         case 1:
          var a = param$0[1];
          if(0 === a[0]){
           var als = a[1];
           return caml_call2(Stdlib_ListLabels[33], anchored, als);
          }
          var r = a[1];
          param$0 = r;
          continue;
         case 2:
          var l = param$0[1];
          return caml_call2(Stdlib_ListLabels[34], anchored, l);
         case 3:
          var
           i = param$0[2],
           r$0 = param$0[1],
           _j_ = caml_call2(Re_Import[6], i, 0);
          if(! _j_) return _j_;
          param$0 = r$0;
          continue;
         case 0:
          break a;
         case 5:
         case 6:
          var r$1 = param$0[1]; break;
         default: var r$1 = param$0[2];
       }
       param$0 = r$1;
       continue;
      }
      switch(param$0){case 5:case 8: return 1;
      }
     }
     return 0;
    }
   }
   function t_of_cset(x){return [0, x];}
   var
    Re_Ast =
      [0,
       pp,
       merge_sequences,
       handle_case,
       anchored,
       colorize,
       [0,
        empty,
        epsilon,
        str,
        no_case,
        case$0,
        diff,
        compl,
        repn,
        inter,
        char$0,
        any,
        set,
        mark,
        nest,
        no_group,
        whole_string,
        7,
        longest,
        greedy,
        non_greedy,
        9,
        4,
        group,
        word,
        first,
        bos,
        bow,
        eow,
        eos,
        0,
        8,
        1,
        opt,
        rep,
        rep1,
        alt,
        shortest,
        seq,
        pp,
        witness],
       cset,
       t_of_cset];
   runtime.caml_register_global(49, Re_Ast, "Re__Ast");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__View
//# unitInfo: Requires: Re__Ast, Re__Automata, Re__Cset, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Ast = global_data.Re__Ast,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Cset = global_data.Re__Cset,
    fold_right = Re_Cset[41];
   function first(t){return t[1];}
   function last(t){return t[2];}
   var Range = [0, first, last];
   function view(t){
    return caml_call3
            (fold_right,
             t,
             0,
             function(first, last, acc){
              var
               _b_ = caml_call1(Re_Cset[4], last),
               range = [0, caml_call1(Re_Cset[4], first), _b_];
              return [0, range, acc];
             });
   }
   function view_ast(f, t){
    switch(t[0]){
      case 0:
       var a = t[1]; return [2, caml_call2(Stdlib_ListLabels[20], f, a)];
      case 1:
       var a$0 = t[1]; return [10, caml_call1(f, a$0)];
      default: var a$1 = t[1]; return [9, caml_call1(f, a$1)];
    }
   }
   function view$0(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 2;
       case 3:
        return 3;
       case 4:
        return 4;
       case 5:
        return 5;
       case 6:
        return 6;
       case 7:
        return 7;
       case 8:
        return 8;
       default: return 9;
     }
    switch(param[0]){
      case 0:
       var cset = param[1];
       switch(cset[0]){
         case 0:
          var set = cset[1]; return [0, set];
         case 1:
          var sets = cset[1];
          return [11, caml_call2(Stdlib_ListLabels[20], Re_Ast[8], sets)];
         case 2:
          var sets$0 = cset[1];
          return [12, caml_call2(Stdlib_ListLabels[20], Re_Ast[8], sets$0)];
         case 3:
          var y = cset[2], x = cset[1], _a_ = caml_call1(Re_Ast[8], y);
          return [13, caml_call1(Re_Ast[8], x), _a_];
         default: var ast = cset[1]; return view_ast(Re_Ast[8], ast);
       }
      case 1:
       var s = param[1]; return view_ast(function(x){return x;}, s);
      case 2:
       var s$0 = param[1]; return [1, s$0];
      case 3:
       var y$0 = param[3], x$0 = param[2], t = param[1];
       return [3, t, x$0, y$0];
      case 4:
       var t$0 = param[2], name = param[1]; return [6, name, t$0];
      case 5:
       var a = param[1]; return [7, a];
      case 6:
       var t$1 = param[1]; return [8, t$1];
      case 7:
       var t$2 = param[2], pmark = param[1]; return [14, pmark, t$2];
      case 8:
       var a$0 = param[2], sem = param[1]; return [4, sem, a$0];
      default: var a$1 = param[2], sem$0 = param[1]; return [5, sem$0, a$1];
    }
   }
   var Re_View = [0, [0, Range, view], [0], [0], view$0];
   runtime.caml_register_global(3, Re_View, "Re__View");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Group
//# unitInfo: Requires: Re__Fmt, Re__Mark_infos, Stdlib, Stdlib__Array, Stdlib__Format, Stdlib__Option, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_offset = [0, -1, -1],
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Array = global_data.Stdlib__Array,
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_String = global_data.Stdlib__String,
    Re_Mark_infos = global_data.Re__Mark_infos,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    _a_ =
      [0,
       [18,
        [1, [0, 0, cst]],
        [12,
         40,
         [2,
          0,
          [11,
           " (",
           [4, 0, 0, 0, [12, 32, [4, 0, 0, 0, [11, "))", [17, 0, 0]]]]]]]]],
       "@[(%s (%d %d))@]"],
    cst_Group = "Group";
   function create(s, gcount, gpos, marks, pmarks){return [0, s, marks, pmarks, gpos, gcount];
   }
   function offset_opt(t, i){
    var _k_ = caml_call2(Re_Mark_infos[2], t[2], i);
    return caml_call1
            (caml_call1
              (Stdlib_Option[7],
               function(param){
                var
                 stop = param[2],
                 start = param[1],
                 _l_ = caml_check_bound(t[4], stop)[1 + stop];
                return [0, caml_check_bound(t[4], start)[1 + start], _l_];
               }),
             _k_);
   }
   function or_not_found(param){
    if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var s = param[1];
    return s;
   }
   function offset(t, i){return or_not_found(offset_opt(t, i));}
   function pmarks(t){return t[3];}
   function get(t, i){
    var _j_ = offset_opt(t, i);
    return or_not_found
            (caml_call1
              (caml_call1
                (Stdlib_Option[7],
                 function(param){
                  var p2 = param[2], p1 = param[1];
                  return caml_call3(Stdlib_String[16], t[1], p1, p2 - p1 | 0);
                 }),
               _j_));
   }
   function start_opt(subs, i){
    var _h_ = offset_opt(subs, i);
    return caml_call1
            (caml_call1(Stdlib_Option[7], function(_i_){return _i_[1];}), _h_);
   }
   function start(subs, i){return or_not_found(start_opt(subs, i));}
   function stop_opt(subs, i){
    var _f_ = offset_opt(subs, i);
    return caml_call1
            (caml_call1(Stdlib_Option[7], function(_g_){return _g_[2];}), _f_);
   }
   function stop(subs, i){return or_not_found(stop_opt(subs, i));}
   function test(t, i){return caml_call2(Re_Mark_infos[3], t[2], i);}
   function get_opt(t, i){return test(t, i) ? [0, get(t, i)] : 0;}
   function all_offset(t){
    var res = caml_make_vect(t[5], dummy_offset);
    caml_call2
     (Re_Mark_infos[4],
      t[2],
      function(i, start, stop){
       var
        p1 = caml_check_bound(t[4], start)[1 + start],
        p2 = caml_check_bound(t[4], stop)[1 + stop];
       caml_check_bound(res, i)[1 + i] = [0, p1, p2];
       return 0;
      });
    return res;
   }
   function all(t){
    var res = caml_make_vect(t[5], cst);
    caml_call2
     (Re_Mark_infos[4],
      t[2],
      function(i, start, stop){
       var
        p1 = caml_check_bound(t[4], start)[1 + start],
        p2 = caml_check_bound(t[4], stop)[1 + stop],
        _e_ = caml_call3(Stdlib_String[16], t[1], p1, p2 - p1 | 0);
       caml_check_bound(res, i)[1 + i] = _e_;
       return 0;
      });
    return res;
   }
   function pp(fmt, t){
    var
     offsets = all_offset(t),
     strs = all(t),
     _b_ =
       caml_call2
        (Stdlib_Array[1],
         strs.length - 1,
         function(i){
          var _d_ = caml_check_bound(offsets, i)[1 + i];
          return [0, caml_check_bound(strs, i)[1 + i], _d_];
         }),
     matches = caml_call1(Stdlib_Array[10], _b_);
    function pp_match(fmt, param){
     var match = param[2], stop = match[2], start = match[1], str = param[1];
     return caml_call5(Stdlib_Format[139], fmt, _a_, str, start, stop);
    }
    var _c_ = caml_call2(Re_Fmt[11], 0, pp_match);
    return caml_call4(Re_Fmt[2], fmt, cst_Group, _c_, matches);
   }
   function nb_groups(t){return t[5];}
   var
    Re_Group =
      [0,
       create,
       get,
       get_opt,
       offset,
       offset_opt,
       start,
       start_opt,
       stop,
       stop_opt,
       all,
       all_offset,
       test,
       pmarks,
       nb_groups,
       pp];
   runtime.caml_register_global(11, Re_Group, "Re__Group");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Compile
//# unitInfo: Requires: Re__Ast, Re__Automata, Re__Category, Re__Color_map, Re__Cset, Re__Group, Re__Import, Stdlib, Stdlib__Array, Stdlib__Char, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Re_exec_out_of_bounds$1 = "Re.exec: out of bounds",
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Re_Import = global_data.Re__Import,
    Re_Color_map = global_data.Re__Color_map,
    Re_Cset = global_data.Re__Cset,
    Stdlib_Char = global_data.Stdlib__Char,
    Re_Automata = global_data.Re__Automata,
    Re_Category = global_data.Re__Category,
    Re_Ast = global_data.Re__Ast,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib = global_data.Stdlib,
    Re_Group = global_data.Re__Group,
    Stdlib_Array = global_data.Stdlib__Array;
   function iter(n, f, v){
    var n$0 = n, v$0 = v;
    for(;;){
     if(caml_call2(Re_Import[11][8], n$0, 0)) return v$0;
     var v$1 = caml_call1(f, v$0), n$1 = n$0 - 1 | 0;
     n$0 = n$1;
     v$0 = v$1;
    }
   }
   function break_idx(t){return (t + 5 | 0) * -1 | 0;}
   function get_info(param){return param[1];}
   function follow_transition(param, color){
    return param[1 + (1 + caml_call1(Re_Cset[2], color) | 0)];
   }
   function set_transition(param, color, st){
    var _au_ = 1 + caml_call1(Re_Cset[2], color) | 0;
    caml_check_bound(param, _au_)[1 + _au_] = st;
   }
   var info = [0, -2, 0, Re_Automata[21][1]], unknown_state = [0, info];
   function pp_re(ch, re){return caml_call2(Re_Automata[5], ch, re[1]);}
   function group_count(re){return re[10];}
   function group_names(re){return re[9];}
   var
    empty = [0, [0]],
    _a_ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    cst_Re_exec_out_of_bounds = cst_Re_exec_out_of_bounds$1,
    cst_Re_exec_out_of_bounds$0 = cst_Re_exec_out_of_bounds$1;
   function set(t, idx, pos){t[1][1 + idx] = pos;}
   function category(re, color){
    if(caml_call2(Re_Cset[1], color, Re_Cset[6])) return Re_Category[4];
    if(caml_call2(Re_Cset[1], color, re[6])){
     var
      _ar_ = Re_Category[6],
      _as_ = caml_call2(Re_Category[1], Re_Category[8], Re_Category[7]);
     return caml_call2(Re_Category[1], _as_, _ar_);
    }
    var _at_ = caml_call2(Re_Color_map[1][1], re[4], color);
    return caml_call1(Re_Category[2], _at_);
   }
   function find_state(re, desc){
    try{
     var _ap_ = caml_call2(Re_Automata[21][5][7], re[8], desc);
     return _ap_;
    }
    catch(_aq_){
     var _am_ = caml_wrap_exception(_aq_);
     if(_am_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_am_, 0);
     var match = caml_call1(Re_Automata[21][4], desc);
     a:
     {
      if(typeof match === "number" && match){var break_state = 0; break a;}
      var break_state = 1;
     }
     var
      idx = caml_call1(Re_Automata[21][3], desc),
      _an_ = 0,
      _ao_ =
        break_state
         ? -5 - caml_call1(Re_Automata[19][1], idx) | 0
         : caml_call1(Re_Automata[19][1], idx),
      state = [0, _ao_, _an_, desc];
     if(break_state)
      var st$0 = [0, state];
     else{
      var ncol = re[5], st = caml_make_vect(ncol + 1 | 0, unknown_state);
      caml_check_bound(st, 0)[1] = state;
      var st$0 = st;
     }
     caml_call3(Re_Automata[21][5][5], re[8], desc, st$0);
     return st$0;
    }
   }
   function delta(re, positions, cat, color, st){
    var
     desc = caml_call4(Re_Automata[23], re[7], cat, color, st[3]),
     len = positions[1].length - 1,
     _ai_ = caml_call2(Re_Import[6], len, 0);
    if(_ai_)
     var
      _aj_ = caml_call1(Re_Automata[21][3], desc),
      _ak_ = caml_call1(Re_Automata[19][1], _aj_),
      _al_ = caml_call2(Re_Import[3], _ak_, len);
    else
     var _al_ = _ai_;
    if(_al_){
     var len$0 = positions[1].length - 1, pos = positions[1];
     positions[1] = caml_make_vect(2 * len$0 | 0, 0);
     caml_call5(Stdlib_Array[9], pos, 0, positions[1], 0, len$0);
    }
    return desc;
   }
   function validate(re, positions, s, pos, st){
    var
     _ah_ = caml_string_get(s, pos),
     color = caml_call2(Re_Color_map[2][2], re[3], _ah_),
     cat = category(re, color),
     desc = delta(re, positions, cat, color, get_info(st)),
     st$0 = find_state(re, desc);
    return set_transition(st, color, st$0);
   }
   function next(colors, st, s, pos){
    return follow_transition
            (st,
             caml_call2
              (Re_Color_map[2][2], colors, caml_string_unsafe_get(s, pos)));
   }
   function get_color(re, s, pos){
    if(caml_call2(Re_Import[5], pos, 0)) return Re_Cset[6];
    var slen = caml_ml_string_length(s);
    if(slen <= pos) return Re_Cset[6];
    if
     (caml_call2(Re_Import[3], pos, slen - 1 | 0)
      &&
       !
       caml_call2(Re_Cset[1], re[6], Re_Cset[6])
       && caml_call2(Stdlib_Char[6], caml_string_unsafe_get(s, pos), 10))
     return re[6];
    return caml_call2
            (Re_Color_map[2][2], re[3], caml_string_unsafe_get(s, pos));
   }
   function scan_str(re, positions, s, initial_state, last, pos$3, groups){
    if
     (caml_call2(Re_Import[3], last, caml_ml_string_length(s))
      &&
       !
       caml_call2(Re_Cset[1], re[6], Re_Cset[6])
       && caml_call2(Re_Import[6], last, pos$3)){
     var _ag_ = caml_string_get(s, last - 1 | 0);
     if(caml_call2(Stdlib_Char[6], _ag_, 10)){
      var
       last$0 = last - 1 | 0,
       st$3 = scan_str(re, positions, s, initial_state, last$0, pos$3, groups),
       x$0 = get_info(st$3)[1];
      if(x$0 <= -3) return st$3;
      for(;;){
       var
        st$1 = follow_transition(st$3, re[6]),
        info = get_info(st$1),
        t = info[1];
       if(0 <= t){
        if(groups){var t$0 = info[1]; set(positions, t$0, last$0);}
        return st$1;
       }
       var x = info[1];
       if(x <= -3){
        if(groups) set(positions, break_idx(info[1]), last$0);
        return st$1;
       }
       var
        color = re[6],
        cat = category(re, color),
        real_c = caml_call2(Re_Color_map[2][2], re[3], 10),
        desc = delta(re, positions, cat, real_c, get_info(st$3)),
        st$2 = find_state(re, desc);
       set_transition(st$3, color, st$2);
      }
     }
    }
    if(groups){
     var colors = re[3], pos = pos$3, st0 = initial_state, st = initial_state;
     for(;;){
      if(! caml_call2(Re_Import[5], pos, last)) return st;
      var st0$0 = next(colors, st, s, pos), idx = get_info(st0$0)[1];
      if(0 <= idx){
       set(positions, idx, pos);
       var pos$0 = pos + 1 | 0;
       pos = pos$0;
       st0 = st0$0;
       st = st0$0;
      }
      else{
       if(idx <= -3){set(positions, break_idx(idx), pos); return st0$0;}
       validate(re, positions, s, pos, st0);
       st = st0;
      }
     }
    }
    else{
     var
      colors$0 = re[3],
      pos$1 = pos$3,
      st0$1 = initial_state,
      st$0 = initial_state;
     for(;;){
      if(! caml_call2(Re_Import[5], pos$1, last)) return st$0;
      var st0$2 = next(colors$0, st$0, s, pos$1), idx$0 = get_info(st0$2)[1];
      if(0 <= idx$0){
       var pos$2 = pos$1 + 1 | 0;
       pos$1 = pos$2;
       st0$1 = st0$2;
       st$0 = st0$2;
      }
      else{
       if(idx$0 <= -3) return st0$2;
       validate(re, empty, s, pos$1, st0$1);
       st$0 = st0$1;
      }
     }
    }
   }
   function final_boundary_check
   (re, positions, last, slen, s, state_info, groups){
    var
     _ae_ =
       caml_call2(Re_Import[3], last, slen)
        ? Re_Category[4]
        : category(re, get_color(re, s, last)),
     final_cat = caml_call2(Re_Category[1], Re_Category[9], _ae_);
    try{
     var
      _ad_ = caml_call2(Stdlib_ListLabels[51], final_cat, state_info[2]),
      match = _ad_;
    }
    catch(_af_){
     var _ab_ = caml_wrap_exception(_af_);
     if(_ab_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ab_, 0);
     var
      st = delta(re, positions, final_cat, Re_Cset[6], state_info),
      _ac_ = caml_call1(Re_Automata[21][4], st),
      res = [0, caml_call1(Re_Automata[21][3], st), _ac_];
     state_info[2] = [0, [0, final_cat, res], state_info[2]];
     var match = res;
    }
    var res$0 = match[2], idx = match[1];
    a:
    if(groups && typeof res$0 !== "number"){
     set(positions, caml_call1(Re_Automata[19][1], idx), last);
     break a;
    }
    return res$0;
   }
   function make_match_str(re, positions, len, groups, partial, s, pos){
    var
     slen = caml_ml_string_length(s),
     last = caml_call2(Re_Import[3], len, -1) ? slen : pos + len | 0,
     _$_ =
       caml_call2(Re_Import[3], pos, 0)
        ? Re_Category[4]
        : category(re, get_color(re, s, pos - 1 | 0)),
     initial_cat = caml_call2(Re_Category[1], Re_Category[9], _$_);
    try{
     var
      ___ = caml_call2(Stdlib_ListLabels[51], initial_cat, re[2]),
      initial_state = ___;
    }
    catch(_aa_){
     var _Z_ = caml_wrap_exception(_aa_);
     if(_Z_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_Z_, 0);
     var
      st = find_state(re, caml_call2(Re_Automata[21][2], initial_cat, re[1]));
     re[2] = [0, [0, initial_cat, st], re[2]];
     var initial_state = st;
    }
    var
     st$0 = scan_str(re, positions, s, initial_state, last, pos, groups),
     state_info = get_info(st$0),
     x = state_info[1];
    a:
    if(x > -3){
     if(partial && ! groups) break a;
     if(partial && groups){
      var status = caml_call1(Re_Automata[21][4], state_info[3]);
      if(typeof status === "number" && status){
       var
        status$0 =
          final_boundary_check
           (re, positions, last, slen, s, state_info, groups);
       return typeof status$0 === "number" ? 1 : status$0;
      }
      return status;
     }
     return final_boundary_check
             (re, positions, last, slen, s, state_info, groups);
    }
    return caml_call1(Re_Automata[21][4], state_info[3]);
   }
   function match_str_no_bounds(groups, partial, re, s, pos, len){
    if(groups)
     var
      n = caml_call1(Re_Automata[22][2], re[7]) + 1 | 0,
      _Y_ = 10 < n ? caml_make_vect(n, 0) : _a_.slice(),
      positions = [0, _Y_];
    else
     var positions = empty;
    var match = make_match_str(re, positions, len, groups, partial, s, pos);
    if(typeof match !== "number"){
     var pmarks = match[2], marks = match[1];
     return [0,
             caml_call5(Re_Group[1], s, re[10], positions[1], marks, pmarks)];
    }
    if(! match) return 0;
    var
     no_match_starts_before =
       groups ? caml_check_bound(positions[1], 0)[1] : 0;
    return [1, no_match_starts_before];
   }
   function match_str_p(re, s, pos, len){
    var _V_ = caml_call2(Re_Import[5], pos, 0);
    if(_V_)
     var _W_ = _V_;
    else
     var
      _X_ = caml_call2(Re_Import[5], len, -1),
      _W_ =
        _X_
        || caml_call2(Re_Import[6], pos + len | 0, caml_ml_string_length(s));
    if(_W_) caml_call1(Stdlib[1], cst_Re_exec_out_of_bounds);
    return typeof make_match_str(re, empty, len, 0, 0, s, pos) === "number"
            ? 0
            : 1;
   }
   function match_str(groups, partial, re, s, pos, len){
    var _S_ = caml_call2(Re_Import[5], pos, 0);
    if(_S_)
     var _T_ = _S_;
    else
     var
      _U_ = caml_call2(Re_Import[5], len, -1),
      _T_ =
        _U_
        || caml_call2(Re_Import[6], pos + len | 0, caml_ml_string_length(s));
    if(_T_) caml_call1(Stdlib[1], cst_Re_exec_out_of_bounds$0);
    return match_str_no_bounds(groups, partial, re, s, pos, len);
   }
   function enforce_kind(ids, kind$0, kind, cr){
    if(typeof kind$0 === "number" && 332064784 === kind$0){
     if(typeof kind === "number" && 332064784 === kind) return cr;
     var _R_ = caml_call1(Re_Automata[11], ids);
     return caml_call4(Re_Automata[10], ids, kind, cr, _R_);
    }
    return cr;
   }
   function translate(ctx, ast){
    var ctx$0 = ctx, ast$0 = ast;
    for(;;){
     var
      colors = ctx$0[8],
      cache = ctx$0[7],
      names = ctx$0[6],
      pos = ctx$0[5],
      greedy = ctx$0[4],
      ign_group = ctx$0[3],
      kind = ctx$0[2],
      ids = ctx$0[1];
     if(typeof ast$0 === "number")
      switch(ast$0){
        case 0:
         var _k_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[17], ids, _k_), kind];
        case 1:
         var _l_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[16], ids, _l_), kind];
        case 2:
         var
          _m_ = caml_call2(Re_Automata[16], ids, Re_Category[5]),
          _n_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _o_ = caml_call2(Re_Automata[17], ids, _n_);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _o_, _m_),
                 kind];
        case 3:
         var
          _p_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _q_ = caml_call2(Re_Automata[16], ids, _p_),
          _r_ = caml_call2(Re_Automata[17], ids, Re_Category[5]);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _r_, _q_),
                 kind];
        case 4:
         var
          cat = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _s_ = caml_call2(Re_Automata[16], ids, cat),
          _t_ = caml_call2(Re_Automata[17], ids, cat),
          _u_ = [0, caml_call4(Re_Automata[10], ids, 332064784, _t_, _s_), 0],
          _v_ = caml_call2(Re_Automata[16], ids, Re_Category[5]),
          _w_ = caml_call2(Re_Automata[17], ids, Re_Category[5]),
          _x_ =
            [0, caml_call4(Re_Automata[10], ids, 332064784, _w_, _v_), _u_];
         return [0, caml_call2(Re_Automata[9], ids, _x_), kind];
        case 5:
         return [0, caml_call2(Re_Automata[17], ids, Re_Category[4]), kind];
        case 6:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[4]), kind];
        case 7:
         var _y_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[8]);
         return [0, caml_call2(Re_Automata[16], ids, _y_), kind];
        case 8:
         return [0, caml_call2(Re_Automata[17], ids, Re_Category[9]), kind];
        default:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[9]), kind];
      }
     switch(ast$0[0]){
       case 0:
        var s = ast$0[1], match = caml_call1(Re_Cset[40], s);
        if(match)
         var
          i = match[1],
          _h_ = caml_call2(Re_Color_map[2][1], colors, i),
          _z_ = caml_call1(Re_Cset[46], _h_);
        else{
         var v = [0, caml_call1(Re_Cset[42], s), s];
         try{var _j_ = caml_call2(Re_Cset[44][17], v, cache[1]), _z_ = _j_;}
         catch(_Q_){
          var _i_ = caml_wrap_exception(_Q_);
          if(_i_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_i_, 0);
          var l = caml_call2(Re_Color_map[2][3], colors, s);
          cache[1] = caml_call3(Re_Cset[44][2], v, l, cache[1]);
          var _z_ = l;
         }
        }
        return [0, caml_call2(Re_Automata[7], ids, _z_), kind];
       case 1:
        var l$0 = ast$0[1][1], merged_sequences = caml_call1(Re_Ast[2], l$0);
        if(merged_sequences && ! merged_sequences[2]){
         var
          r = merged_sequences[1],
          match$0 = translate(ctx$0, r),
          kind$0 = match$0[2],
          cr = match$0[1];
         return [0, enforce_kind(ids, kind, kind$0, cr), kind];
        }
        var
         _A_ =
           caml_call2
            (Stdlib_ListLabels[20],
             function(r){
              var
               match = translate(ctx$0, r),
               kind$0 = match[2],
               cr = match[1];
              return enforce_kind(ids, kind, kind$0, cr);
             },
             merged_sequences);
        return [0, caml_call2(Re_Automata[9], ids, _A_), kind];
       case 2:
        var l$1 = ast$0[1]; return [0, trans_seq(ctx$0, l$1), kind];
       case 3:
        var
         j = ast$0[3],
         i$0 = ast$0[2],
         r$0 = ast$0[1],
         match$1 = translate(ctx$0, r$0),
         kind$1 = match$1[2],
         cr$0 = match$1[1];
        if(j)
         var
          j$0 = j[1],
          f =
            620821490 <= greedy
             ? function
              (rem){
               var
                _K_ = caml_call2(Re_Automata[18], ids, cr$0),
                _L_ =
                  [0, caml_call4(Re_Automata[10], ids, kind$1, _K_, rem), 0],
                _M_ = [0, caml_call1(Re_Automata[11], ids), _L_];
               return caml_call2(Re_Automata[9], ids, _M_);
              }
             : function
              (rem){
               var
                _N_ = [0, caml_call1(Re_Automata[11], ids), 0],
                _O_ = caml_call2(Re_Automata[18], ids, cr$0),
                _P_ =
                  [0, caml_call4(Re_Automata[10], ids, kind$1, _O_, rem), _N_];
               return caml_call2(Re_Automata[9], ids, _P_);
              },
          rem = iter(j$0 - i$0 | 0, f, caml_call1(Re_Automata[11], ids));
        else
         var rem = caml_call4(Re_Automata[12], ids, greedy, kind$1, cr$0);
        return [0,
                iter
                 (i$0,
                  function(rem){
                   var _J_ = caml_call2(Re_Automata[18], ids, cr$0);
                   return caml_call4(Re_Automata[10], ids, kind$1, _J_, rem);
                  },
                  rem),
                kind];
       case 4:
        var ast$1 = ast$0[2], n = ast$0[1];
        if(! ign_group){
         var p = pos[1];
         if(n){
          var name = n[1], _B_ = names[1];
          names[1] = [0, [0, name, caml_call1(Re_Automata[1][6], p)], _B_];
         }
         pos[1] = caml_call1(Re_Automata[1][5], pos[1]);
         var
          match$2 = translate(ctx$0, ast$1),
          kind$2 = match$2[2],
          cr$1 = match$2[1],
          _C_ = caml_call1(Re_Automata[1][4], p),
          _D_ = caml_call2(Re_Automata[13], ids, _C_),
          _E_ = caml_call4(Re_Automata[10], ids, 332064784, cr$1, _D_),
          _F_ = caml_call2(Re_Automata[13], ids, p);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _F_, _E_),
                 kind$2];
        }
        ast$0 = ast$1;
        break;
       case 5:
        var
         ast$2 = ast$0[1],
         ctx$1 =
           [0,
            ctx$0[1],
            ctx$0[2],
            1,
            ctx$0[4],
            ctx$0[5],
            ctx$0[6],
            ctx$0[7],
            ctx$0[8]];
        ctx$0 = ctx$1;
        ast$0 = ast$2;
        break;
       case 6:
        var
         r$1 = ast$0[1],
         b = pos[1],
         match$3 = translate(ctx$0, r$1),
         kind$3 = match$3[2],
         cr$2 = match$3[1],
         e = caml_call1(Re_Automata[1][3], pos[1]),
         _G_ = caml_call2(Re_Automata[1][1], e, b);
        if(caml_call2(Re_Import[3], _G_, -1)) return [0, cr$2, kind$3];
        var _H_ = caml_call3(Re_Automata[15], ids, b, e);
        return [0,
                caml_call4(Re_Automata[10], ids, 332064784, _H_, cr$2),
                kind$3];
       case 7:
        var
         r$2 = ast$0[2],
         i$1 = ast$0[1],
         match$4 = translate(ctx$0, r$2),
         kind$4 = match$4[2],
         cr$3 = match$4[1],
         _I_ = caml_call2(Re_Automata[14], ids, i$1);
        return [0,
                caml_call4(Re_Automata[10], ids, 332064784, _I_, cr$3),
                kind$4];
       case 8:
        var
         r$3 = ast$0[2],
         kind$5 = ast$0[1],
         match$5 =
           translate
            ([0,
              ctx$0[1],
              kind$5,
              ctx$0[3],
              ctx$0[4],
              ctx$0[5],
              ctx$0[6],
              ctx$0[7],
              ctx$0[8]],
             r$3),
         kind$6 = match$5[2],
         cr$4 = match$5[1];
        return [0, enforce_kind(ids, kind$5, kind$6, cr$4), kind$5];
       default:
        var
         ast$3 = ast$0[2],
         greedy$0 = ast$0[1],
         ctx$2 =
           [0,
            ctx$0[1],
            ctx$0[2],
            ctx$0[3],
            greedy$0,
            ctx$0[5],
            ctx$0[6],
            ctx$0[7],
            ctx$0[8]];
        ctx$0 = ctx$2;
        ast$0 = ast$3;
     }
    }
   }
   function trans_seq(ctx, param){
    var kind = ctx[2], ids = ctx[1];
    if(! param) return caml_call1(Re_Automata[11], ids);
    var r = param[1];
    if(param[2]){
     var
      rem = param[2],
      match = translate(ctx, r),
      kind$0 = match[2],
      cr = match[1],
      cr$0 = trans_seq(ctx, rem);
     return caml_call1(Re_Automata[4], cr$0)
             ? cr
             : caml_call1
                (Re_Automata[4], cr)
               ? cr$0
               : caml_call4(Re_Automata[10], ids, kind$0, cr, cr$0);
    }
    var match$0 = translate(ctx, r), kind$1 = match$0[2], cr$1 = match$0[1];
    return enforce_kind(ids, kind, kind$1, cr$1);
   }
   function compile(r$0){
    if(caml_call1(Re_Ast[4], r$0))
     var regexp$0 = caml_call2(Re_Ast[6][23], 0, r$0);
    else
     var
      _e_ = [0, caml_call2(Re_Ast[6][23], 0, r$0), 0],
      _f_ = caml_call1(Re_Ast[6][34], Re_Ast[6][11]),
      _g_ = [0, caml_call1(Re_Ast[6][37], _f_), _e_],
      regexp$0 = caml_call1(Re_Ast[6][38], _g_);
    var
     regexp = caml_call2(Re_Ast[3], 0, regexp$0),
     color_map = caml_call1(Re_Color_map[3], 0),
     need_lnl = caml_call2(Re_Ast[5], color_map, regexp),
     match = caml_call1(Re_Color_map[4], color_map),
     color_repr = match[2],
     colors = match[1],
     ncolor = caml_call1(Re_Color_map[1][2], color_repr),
     lnl = need_lnl ? caml_call1(Re_Cset[3], ncolor) : Re_Cset[6],
     ncolor$0 = need_lnl ? ncolor + 1 | 0 : ncolor,
     _c_ = [0, Re_Cset[44][1]],
     _d_ = [0, Re_Automata[1][2]],
     ctx =
       [0,
        caml_call1(Re_Automata[6][1], 0),
        332064784,
        0,
        -904640576,
        _d_,
        [0, 0],
        _c_,
        colors],
     match$0 = translate(ctx, regexp),
     kind = match$0[2],
     r = match$0[1],
     initial = enforce_kind(ctx[1], 332064784, kind, r),
     group_count = caml_call1(Re_Automata[1][6], ctx[5][1]),
     group_names = caml_call1(Stdlib_ListLabels[10], ctx[6][1]),
     _b_ = caml_call1(Re_Automata[21][5][1], 97);
    return [0,
            initial,
            0,
            colors,
            color_repr,
            ncolor$0,
            lnl,
            caml_call1(Re_Automata[22][1], 0),
            _b_,
            group_names,
            group_count];
   }
   var
    Re_Compile =
      [0,
       match_str_no_bounds,
       match_str,
       match_str_p,
       compile,
       group_count,
       group_names,
       pp_re];
   runtime.caml_register_global(14, Re_Compile, "Re__Compile");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Search
//# unitInfo: Requires: Re__Compile, Re__Group, Stdlib, Stdlib__Seq, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Re_all$1 = "Re.all",
    cst_Re_split$1 = "Re.split",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Assert_failure = global_data.Assert_failure,
    Re_Compile = global_data.Re__Compile,
    Stdlib_String = global_data.Stdlib__String,
    Re_Group = global_data.Re__Group,
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    cst_Re_all = cst_Re_all$1,
    cst_Re_all$0 = cst_Re_all$1,
    cst_Re_split = cst_Re_split$1,
    cst_Re_split$0 = cst_Re_split$1,
    _a_ = [0, "lib/search.ml", 55, 6];
   function all(opt, len, re, s){
    var pos = opt ? opt[1] : 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_all);
    if(len){
     var
      l = len[1],
      _r_ = l < 0 ? 1 : 0,
      _s_ = _r_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_s_) caml_call1(Stdlib[1], cst_Re_all$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(pos, on_match, param){
     var pos$0 = pos, on_match$0 = on_match;
     for(;;){
      if(limit < pos$0) return 0;
      var
       match =
         caml_call6(Re_Compile[2], 1, 0, re, s, pos$0, limit - pos$0 | 0);
      if(typeof match !== "number" && 0 === match[0]){
       var
        substr = match[1],
        match$0 = caml_call2(Re_Group[4], substr, 0),
        p2 = match$0[2],
        p1 = match$0[1];
       if(on_match$0 && p1 === pos$0 && p1 === p2){
        var pos$1 = pos$0 + 1 | 0;
        pos$0 = pos$1;
        on_match$0 = 0;
        continue;
       }
       var pos$2 = p1 === p2 ? p2 + 1 | 0 : p2, _v_ = p1 !== p2 ? 1 : 0;
       return [0, substr, function(_w_){return aux(pos$2, _v_, _w_);}];
      }
      return 0;
     }
    }
    var _t_ = 0;
    return function(_u_){return aux(pos, _t_, _u_);};
   }
   function matches(pos, len, re, s){
    var _q_ = all(pos, len, re, s);
    return caml_call1
            (caml_call1
              (Stdlib_Seq[29],
               function(sub){return caml_call2(Re_Group[2], sub, 0);}),
             _q_);
   }
   function split_full(opt, len, re, s){
    var pos = opt ? opt[1] : 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_split);
    if(len){
     var
      l = len[1],
      _h_ = l < 0 ? 1 : 0,
      _i_ = _h_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_i_) caml_call1(Stdlib[1], cst_Re_split$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(state, i, pos$0, param){
     var old_i = i, pos$1 = pos$0;
     for(;;){
      if(typeof state !== "number"){
       var x = state[2], _l_ = 814535476;
       return [0, x, function(_p_){return aux(_l_, old_i, pos$1, _p_);}];
      }
      if(limit < pos$1){
       if(old_i === limit) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      var
       match =
         caml_call6(Re_Compile[2], 1, 0, re, s, pos$1, limit - pos$1 | 0);
      if(typeof match === "number"){
       if(old_i >= limit) return 0;
       var text = caml_call3(Stdlib_String[16], s, old_i, limit - old_i | 0);
       return [0,
               [0, 936573133, text],
               function(_o_){return aux(state, limit, pos$1, _o_);}];
      }
      if(0 !== match[0]) return 0;
      var
       substr = match[1],
       match$0 = caml_call2(Re_Group[4], substr, 0),
       p2 = match$0[2],
       p1 = match$0[1],
       pos$2 = p1 === p2 ? p2 + 1 | 0 : p2;
      if(old_i === p1 && p1 === p2 && pos < p1){old_i = p2; pos$1 = pos$2; continue;}
      if(pos >= p1)
       return [0,
               [0, -363573681, substr],
               function(_n_){return aux(state, p2, pos$2, _n_);}];
      var
       text$0 = caml_call3(Stdlib_String[16], s, old_i, p1 - old_i | 0),
       state$0 = [0, 73271853, [0, -363573681, substr]];
      return [0,
              [0, 936573133, text$0],
              function(_m_){return aux(state$0, p2, pos$2, _m_);}];
     }
    }
    var _j_ = 814535476;
    return function(_k_){return aux(_j_, pos, pos, _k_);};
   }
   function split(pos, len, re, s){
    var seq = split_full(pos, len, re, s);
    function filter(seq, param){
     var seq$0 = seq;
     for(;;){
      var match = caml_call1(seq$0, 0);
      if(! match) return 0;
      var match$0 = match[1];
      if(936573133 <= match$0[1]){
       var tl = match[2], s = match$0[2];
       return [0, s, function(_g_){return filter(tl, _g_);}];
      }
      var seq$1 = match[2];
      seq$0 = seq$1;
     }
    }
    return function(_f_){return filter(seq, _f_);};
   }
   function split_delim(pos, len, re, s){
    var seq = split_full(pos, len, re, s);
    function filter(delim, seq, param){
     var delim$0 = delim, seq$0 = seq;
     for(;;){
      var match = caml_call1(seq$0, 0);
      if(! match) return delim$0 ? [0, cst$0, function(param){return 0;}] : 0;
      var match$0 = match[1];
      if(936573133 <= match$0[1]){
       var tl = match[2], s = match$0[2], _d_ = 0;
       return [0, s, function(_e_){return filter(_d_, tl, _e_);}];
      }
      var seq$1 = match[2];
      if(delim$0)
       return [0, cst, function(param){return filter(1, seq$1, 0);}];
      delim$0 = 1;
      seq$0 = seq$1;
     }
    }
    var _b_ = 1;
    return function(_c_){return filter(_b_, seq, _c_);};
   }
   var Re_Search = [0, all, matches, split_full, split, split_delim];
   runtime.caml_register_global(13, Re_Search, "Re__Search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Core
//# unitInfo: Requires: Re__Ast, Re__Compile, Re__Cset, Re__Group, Re__Pmark, Re__Search, Stdlib, Stdlib__ListLabels, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Search = global_data.Re__Search,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Group = global_data.Re__Group,
    Re_Pmark = global_data.Re__Pmark,
    Re_Compile = global_data.Re__Compile,
    Stdlib = global_data.Stdlib,
    Re_Cset = global_data.Re__Cset,
    Re_Ast = global_data.Re__Ast,
    cset = Re_Ast[7];
   function rg(c$0, c){
    return caml_call1(cset, caml_call2(Re_Cset[25], c$0, c));
   }
   var
    notnl = caml_call1(cset, Re_Cset[22]),
    lower = caml_call1(cset, Re_Cset[30]),
    upper = caml_call1(cset, Re_Cset[31]),
    alpha = caml_call1(cset, Re_Cset[32]),
    digit = caml_call1(cset, Re_Cset[19]),
    alnum = caml_call1(cset, Re_Cset[33]),
    wordc = caml_call1(cset, Re_Cset[34]),
    ascii = caml_call1(cset, Re_Cset[23]),
    blank = caml_call1(cset, Re_Cset[27]),
    cntrl = caml_call1(cset, Re_Cset[35]),
    graph = caml_call1(cset, Re_Cset[36]),
    print = caml_call1(cset, Re_Cset[37]),
    punct = caml_call1(cset, Re_Cset[38]),
    space = caml_call1(cset, Re_Cset[28]),
    xdigit = caml_call1(cset, Re_Cset[29]),
    include = Re_Ast[6],
    empty = include[1],
    epsilon = include[2],
    str = include[3],
    no_case = include[4],
    case$0 = include[5],
    diff = include[6],
    compl = include[7],
    repn = include[8],
    inter = include[9],
    char$0 = include[10],
    any = include[11],
    set = include[12],
    mark = include[13],
    nest = include[14],
    no_group = include[15],
    whole_string = include[16],
    leol = include[17],
    longest = include[18],
    greedy = include[19],
    non_greedy = include[20],
    stop = include[21],
    not_boundary = include[22],
    group = include[23],
    word = include[24],
    first = include[25],
    bos = include[26],
    bow = include[27],
    eow = include[28],
    eos = include[29],
    bol = include[30],
    start = include[31],
    eol = include[32],
    opt = include[33],
    rep = include[34],
    rep1 = include[35],
    alt = include[36],
    shortest = include[37],
    seq = include[38],
    pp = include[39],
    witness = include[40];
   function exec_internal(_e_, opt, partial, groups, re, s){
    var pos = _e_ ? _e_[1] : 0, len = opt ? opt[1] : -1;
    return caml_call6(Re_Compile[2], groups, partial, re, s, pos, len);
   }
   function exec(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return substr;}
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function exec_opt(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return [0, substr];}
    return 0;
   }
   function execp(_d_, opt, re, s){
    var pos = _d_ ? _d_[1] : 0, len = opt ? opt[1] : -1;
    return caml_call4(Re_Compile[3], re, s, pos, len);
   }
   function exec_partial(pos, len, re, s){
    var match = exec_internal(pos, len, 1, 0, re, s);
    return typeof match === "number"
            ? -1062743954
            : 0 === match[0] ? 782112175 : 939392865;
   }
   function exec_partial_detailed(pos, len, re, s){
    var match = exec_internal(pos, len, 1, 1, re, s);
    if(typeof match === "number") return -1062743954;
    if(0 === match[0]){var group = match[1]; return [0, 782112175, group];}
    var no_match_starts_before = match[1];
    return [0, 939392865, no_match_starts_before];
   }
   function marked(g, p){
    var _c_ = caml_call1(Re_Group[13], g);
    return caml_call2(Re_Pmark[5][31], p, _c_);
   }
   function mark_set(g){return caml_call1(Re_Group[13], g);}
   var equal = Re_Pmark[1], compare = Re_Pmark[2];
   function gen_of_seq(s){
    var r = [0, s];
    return function(param){
     var match = caml_call1(r[1], 0);
     if(! match) return 0;
     var tl = match[2], x = match[1];
     r[1] = tl;
     return [0, x];};
   }
   function split_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[4], pos, len, re, s));
   }
   function split_full_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[3], pos, len, re, s));
   }
   function all_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[1], pos, len, re, s));
   }
   function matches_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[2], pos, len, re, s));
   }
   var
    split_full_seq = Re_Search[3],
    split_seq = Re_Search[4],
    matches_seq = Re_Search[2],
    all_seq = Re_Search[1],
    get = Re_Group[2],
    get_ofs = Re_Group[4],
    get_all = Re_Group[10],
    get_all_ofs = Re_Group[11],
    test = Re_Group[12];
   function list_of_seq(s){
    var
     _b_ = caml_call3(Stdlib_Seq[5], function(l, x){return [0, x, l];}, 0, s);
    return caml_call1(Stdlib_ListLabels[10], _b_);
   }
   function all(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[1], pos, len, re, s));
   }
   function matches(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[2], pos, len, re, s));
   }
   function split_full(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[3], pos, len, re, s));
   }
   function split(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[4], pos, len, re, s));
   }
   function split_delim(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[5], pos, len, re, s));
   }
   var
    compile = Re_Compile[4],
    print_re = Re_Compile[7],
    group_names = Re_Compile[6],
    group_count = Re_Compile[5],
    _a_ = Re_Pmark[5],
    Re_Core =
      [0,
       [0,
        Re_Group[2],
        Re_Group[3],
        Re_Group[4],
        Re_Group[5],
        Re_Group[6],
        Re_Group[7],
        Re_Group[8],
        Re_Group[9],
        Re_Group[10],
        Re_Group[11],
        Re_Group[12],
        Re_Group[14],
        Re_Group[15]],
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       [0,
        marked,
        [0,
         _a_[1],
         _a_[2],
         _a_[3],
         _a_[4],
         _a_[5],
         _a_[6],
         _a_[7],
         _a_[8],
         _a_[9],
         _a_[10],
         _a_[11],
         _a_[12],
         _a_[13],
         _a_[14],
         _a_[15],
         _a_[16],
         _a_[17],
         _a_[18],
         _a_[19],
         _a_[20],
         _a_[21],
         _a_[22],
         _a_[23],
         _a_[24],
         _a_[25],
         _a_[26],
         _a_[27],
         _a_[28],
         _a_[29],
         _a_[30],
         _a_[31],
         _a_[32],
         _a_[33],
         _a_[34],
         _a_[35],
         _a_[36],
         _a_[43],
         _a_[37],
         _a_[38],
         _a_[39],
         _a_[40],
         _a_[41],
         _a_[42]],
        mark_set,
        equal,
        compare],
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_delim,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       [0,
        Re_Search[1],
        Re_Search[2],
        Re_Search[4],
        Re_Search[5],
        Re_Search[3]],
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       print_re,
       print_re,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set];
   runtime.caml_register_global(9, Re_Core, "Re__Core");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Parse_buffer
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Parse_error =
      [248, "Re__Parse_buffer.Parse_error", runtime.caml_fresh_oo_id(0)];
   function create(str){return [0, str, 0];}
   function unget(t){t[2] = t[2] - 1 | 0; return 0;}
   function junk(t){t[2] = t[2] + 1 | 0; return 0;}
   function eos(t){return t[2] === caml_ml_string_length(t[1]) ? 1 : 0;}
   function test(t, c){
    var
     _l_ = 1 - eos(t),
     _m_ = _l_ ? caml_string_get(t[1], t[2]) === c ? 1 : 0 : _l_;
    return _m_;
   }
   function test2(t, c$0, c){
    var _i_ = (t[2] + 1 | 0) < caml_ml_string_length(t[1]) ? 1 : 0;
    if(_i_)
     var
      _j_ = caml_string_get(t[1], t[2]) === c$0 ? 1 : 0,
      _k_ = _j_ ? caml_string_get(t[1], t[2] + 1 | 0) === c ? 1 : 0 : _j_;
    else
     var _k_ = _i_;
    return _k_;
   }
   function accept(t, c){
    var r = test(t, c);
    if(r) t[2] = t[2] + 1 | 0;
    return r;
   }
   function accept2(t, c$0, c){
    var r = test2(t, c$0, c);
    if(r) t[2] = t[2] + 2 | 0;
    return r;
   }
   function get(t){
    var r = caml_string_get(t[1], t[2]);
    t[2] = t[2] + 1 | 0;
    return r;
   }
   function accept_s(t, s){
    var len = caml_ml_string_length(s);
    try{
     var _c_ = len - 1 | 0, _b_ = 0;
     if(_c_ >= 0){
      var j = _b_;
      for(;;){
       try{
        var _e_ = caml_string_get(t[1], t[2] + j | 0);
        if(caml_string_get(s, j) !== _e_) throw Stdlib[3];
       }
       catch(_h_){throw Stdlib[3];}
       var _f_ = j + 1 | 0;
       if(_c_ === j) break;
       j = _f_;
      }
     }
     t[2] = t[2] + len | 0;
     var _d_ = 1;
     return _d_;
    }
    catch(_g_){
     var _a_ = caml_wrap_exception(_g_);
     if(_a_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   function integer(t){
    if(eos(t)) return 0;
    var d$0 = get(t);
    if(9 < d$0 - 48 >>> 0){unget(t); return 0;}
    var i$1 = d$0 - 48 | 0, i = i$1;
    for(;;){
     if(eos(t)) return [0, i];
     var d = get(t);
     if(9 < d - 48 >>> 0){unget(t); return [0, i];}
     var i$0 = (10 * i | 0) + (d - 48 | 0) | 0;
     if(i$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
     i = i$0;
    }
   }
   var
    Re_Parse_buffer =
      [0,
       Parse_error,
       create,
       junk,
       unget,
       eos,
       test,
       test2,
       get,
       accept,
       accept2,
       accept_s,
       integer];
   runtime.caml_register_global(2, Re_Parse_buffer, "Re__Parse_buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Emacs
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Parse_error = [248, "Re__Emacs.Parse_error", caml_fresh_oo_id(0)],
    Not_supported = [248, "Re__Emacs.Not_supported", caml_fresh_oo_id(0)];
   function re(opt, s){
    var
     case$0 = opt ? opt[1] : 1,
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf),
     accept2 = caml_call1(Re_Parse_buffer[10], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    var test2 = caml_call1(Re_Parse_buffer[7], buf);
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call2(accept2, 92, 124)) return left$0;
      var
       _h_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _h_);
      left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if
       (!
        eos(0)
        && ! caml_call2(test2, 92, 124) && ! caml_call2(test2, 92, 41)){
       a:
       if(caml_call1(accept, 46))
        var r = Re_Core[62];
       else if(caml_call1(accept, 94))
        var r = Re_Core[35];
       else if(caml_call1(accept, 36))
        var r = Re_Core[36];
       else if(caml_call1(accept, 91))
        if(caml_call1(accept, 94))
         var _d_ = bracket(0), r = caml_call1(Re_Core[60], _d_);
        else
         var _e_ = bracket(0), r = caml_call1(Re_Core[27], _e_);
       else{
        if(! caml_call1(accept, 92)){
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c$0 = get(0);
         b:
         {
          if(44 <= c$0){if(63 === c$0) break b;} else if(42 <= c$0) break b;
          var r = caml_call1(Re_Core[26], c$0);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(caml_call1(accept, 40)){
         var r$0 = regexp(0);
         if(1 - caml_call2(accept2, 92, 41))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         var r = caml_call2(Re_Core[52], 0, r$0);
        }
        else if(caml_call1(accept, 96))
         var r = Re_Core[39];
        else if(caml_call1(accept, 39))
         var r = Re_Core[40];
        else if(caml_call1(accept, 61))
         var r = Re_Core[42];
        else if(caml_call1(accept, 98))
         var
          r = caml_call1(Re_Core[27], [0, Re_Core[37], [0, Re_Core[38], 0]]);
        else if(caml_call1(accept, 66))
         var r = Re_Core[45];
        else if(caml_call1(accept, 60))
         var r = Re_Core[37];
        else if(caml_call1(accept, 62))
         var r = Re_Core[38];
        else if(caml_call1(accept, 119))
         var
          _f_ = [0, caml_call1(Re_Core[26], 95), 0],
          r = caml_call1(Re_Core[27], [0, Re_Core[63], _f_]);
        else if(caml_call1(accept, 87))
         var
          _g_ = [0, caml_call1(Re_Core[26], 95), 0],
          r = caml_call1(Re_Core[60], [0, Re_Core[63], _g_]);
        else{
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(63 <= c){
           if(91 <= c){if(95 > c) break b;} else if(64 > c) break b;
          }
          else
           if(48 <= c){
            if(58 > c) throw caml_maybe_attach_backtrace(Not_supported, 1);
           }
           else if(36 <= c)
            switch(c - 36 | 0){case 0:case 6:case 7:case 10: break b;}
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var r = caml_call1(Re_Core[26], c);
        }
       }
       var
        _c_ =
          caml_call1(accept, 42)
           ? caml_call1(Re_Core[31], r)
           : caml_call1
              (accept, 43)
             ? caml_call1(Re_Core[32], r)
             : caml_call1(accept, 63) ? caml_call1(Re_Core[34], r) : r,
        left$0 = [0, _c_, left];
       left = left$0;
       continue;
      }
      var _b_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _b_);
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var c = char$0(0);
      if(caml_call1(accept, 45)){
       if(caml_call1(accept, 93)){
        var _a_ = [0, caml_call1(Re_Core[26], 45), s$0];
        return [0, caml_call1(Re_Core[26], c), _a_];
       }
       var c$0 = char$0(0), s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
       s$0 = s$1;
      }
      else{var s$2 = [0, caml_call1(Re_Core[26], c), s$0]; s$0 = s$2;}
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     return get(0);
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    return case$0 ? res : caml_call1(Re_Core[78], res);
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    var case$0 = opt ? opt[1] : 1;
    return caml_call1(compile, re([0, case$0], s));
   }
   var Re_Emacs = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(5, Re_Emacs, "Re__Emacs");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Str
//# unitInfo: Requires: CamlinternalLazy, Re__Ast, Re__Compile, Re__Core, Re__Emacs, Re__Group, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Re_Group = global_data.Re__Group,
    Re_Ast = global_data.Re__Ast,
    Re_Compile = global_data.Re__Compile,
    Re_Emacs = global_data.Re__Emacs,
    Re_Core = global_data.Re__Core,
    exec = Re_Core[5],
    exec_partial = Re_Core[8];
   function compile_regexp(s, c){
    var re = caml_call2(Re_Emacs[3], [0, 1 - c], s);
    return [0,
            [246,
             function(param){
              var
               _af_ =
                 caml_call1(Re_Ast[6][38], [0, Re_Ast[6][31], [0, re, 0]]);
              return caml_call1(Re_Compile[4], _af_);
             }],
            [246, function(_ae_){return caml_call1(Re_Compile[4], re);}]];
   }
   var
    state = [0, 0],
    cst_Str_replace_illegal_backsl = "Str.replace: illegal backslash sequence",
    cst_Str_group_beginning = "Str.group_beginning",
    cst_Str_group_end = "Str.group_end";
   function string_match(re, s, p){
    try{
     var _aa_ = re[1], _ab_ = caml_obj_tag(_aa_);
     a:
     if(250 === _ab_)
      var _ac_ = _aa_[1];
     else{
      if(246 !== _ab_ && 244 !== _ab_){var _ac_ = _aa_; break a;}
      var _ac_ = caml_call1(CamlinternalLazy[2], _aa_);
     }
     var res = caml_call4(exec, [0, p], 0, _ac_, s);
    }
    catch(_ad_){
     var _$_ = caml_wrap_exception(_ad_);
     if(_$_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_$_, 0);
     state[1] = 0;
     return 0;
    }
    state[1] = [0, res];
    return 1;
   }
   function string_partial_match(re, s, p){
    var _Y_ = re[1], _Z_ = caml_obj_tag(_Y_);
    a:
    if(250 === _Z_)
     var ___ = _Y_[1];
    else{
     if(246 !== _Z_ && 244 !== _Z_){var ___ = _Y_; break a;}
     var ___ = caml_call1(CamlinternalLazy[2], _Y_);
    }
    var match = caml_call4(exec_partial, [0, p], 0, ___, s);
    return 782112175 === match
            ? string_match(re, s, p)
            : 939392865 <= match ? 1 : 0;
   }
   function search_forward(re, s, p){
    try{
     var _U_ = re[2], _V_ = caml_obj_tag(_U_);
     a:
     if(250 === _V_)
      var _W_ = _U_[1];
     else{
      if(246 !== _V_ && 244 !== _V_){var _W_ = _U_; break a;}
      var _W_ = caml_call1(CamlinternalLazy[2], _U_);
     }
     var res = caml_call4(exec, [0, p], 0, _W_, s);
    }
    catch(_X_){
     var _T_ = caml_wrap_exception(_X_);
     if(_T_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_T_, 0);
     state[1] = 0;
     throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    }
    state[1] = [0, res];
    return caml_call2(Re_Group[4], res, 0)[1];
   }
   function search_backward(re, s, p){
    var p$0 = p;
    for(;;){
     try{
      var _P_ = re[1], _Q_ = caml_obj_tag(_P_);
      a:
      if(250 === _Q_)
       var _R_ = _P_[1];
      else{
       if(246 !== _Q_ && 244 !== _Q_){var _R_ = _P_; break a;}
       var _R_ = caml_call1(CamlinternalLazy[2], _P_);
      }
      var res = caml_call4(exec, [0, p$0], 0, _R_, s);
     }
     catch(_S_){
      var _O_ = caml_wrap_exception(_S_);
      if(_O_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_O_, 0);
      state[1] = 0;
      if(0 === p$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var p$1 = p$0 - 1 | 0;
      p$0 = p$1;
      continue;
     }
     state[1] = [0, res];
     return p$0;
    }
   }
   function valid_group(n){
    var _L_ = 0 <= n ? 1 : 0;
    if(_L_){
     var _M_ = n < 10 ? 1 : 0;
     if(_M_){
      var match = state[1];
      if(match){
       var m = match[1];
       return n < caml_call1(Re_Group[14], m) ? 1 : 0;
      }
      var _N_ = 0;
     }
     else
      var _N_ = _M_;
    }
    else
     var _N_ = _L_;
    return _N_;
   }
   function offset_group(i){
    var match = state[1];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var m = match[1];
    return caml_call2(Re_Group[4], m, i);
   }
   function replacement_text(repl, orig){
    var len = caml_ml_string_length(repl), p = 0, q = 0;
    for(;;){
     if(p >= len) break;
     if(92 === caml_string_get(repl, p)){
      var p$0 = p + 1 | 0;
      if(p$0 === len) caml_call1(Stdlib[2], cst_Str_replace_illegal_backsl);
      var c = caml_string_get(repl, p$0);
      a:
      {
       if(58 <= c){
        if(92 === c){var q$0 = q + 1 | 0; break a;}
       }
       else if(48 <= c){
        var i = c - 48 | 0;
        b:
        {
         try{var val = offset_group(i);}
         catch(_K_){
          var _G_ = caml_wrap_exception(_K_);
          if(_G_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_G_, 0);
          var _H_ = 0;
          break b;
         }
         var e = val[2], b = val[1], _H_ = e - b | 0;
        }
        var q$0 = q + _H_ | 0;
        break a;
       }
       var q$0 = q + 2 | 0;
      }
      var p$1 = p$0 + 1 | 0;
      p = p$1;
      q = q$0;
     }
     else{var q$1 = q + 1 | 0, p$2 = p + 1 | 0; p = p$2; q = q$1;}
    }
    var
     res = runtime.caml_create_bytes(q),
     len$0 = caml_ml_string_length(repl),
     p$3 = 0,
     q$2 = 0;
    for(;;){
     if(p$3 >= len$0) return caml_call1(Stdlib_Bytes[44], res);
     var c$0 = caml_string_get(repl, p$3);
     if(92 === c$0){
      var c$1 = caml_string_get(repl, p$3 + 1 | 0);
      if(58 <= c$1){
       if(92 === c$1){
        caml_bytes_set(res, q$2, 92);
        var q$3 = q$2 + 1 | 0, p$4 = p$3 + 2 | 0;
        p$3 = p$4;
        q$2 = q$3;
        continue;
       }
      }
      else if(48 <= c$1){
       var group = c$1 - 48 | 0;
       a:
       {
        try{var val$0 = offset_group(group);}
        catch(_J_){
         var _I_ = caml_wrap_exception(_J_);
         if(_I_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_I_, 0);
         var d = 0;
         break a;
        }
        var e$0 = val$0[2], b$0 = val$0[1], d$0 = e$0 - b$0 | 0;
        if(0 < d$0) caml_call5(Stdlib_String[6], orig, b$0, res, q$2, d$0);
        var d = d$0;
       }
       var q$5 = q$2 + d | 0, p$6 = p$3 + 2 | 0;
       p$3 = p$6;
       q$2 = q$5;
       continue;
      }
      caml_bytes_set(res, q$2, 92);
      caml_bytes_set(res, q$2 + 1 | 0, c$1);
      var q$4 = q$2 + 2 | 0, p$5 = p$3 + 2 | 0;
      p$3 = p$5;
      q$2 = q$4;
     }
     else{
      caml_bytes_set(res, q$2, c$0);
      var q$6 = q$2 + 1 | 0, p$7 = p$3 + 1 | 0;
      p$3 = p$7;
      q$2 = q$6;
     }
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_call1(Stdlib_Buffer[1], 2 * len | 0),
     _C_ = len - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var c = caml_string_get(s, i), _D_ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < _D_ >>> 0){
         var _E_ = _D_ + 27 | 0;
         if(10 < _E_ >>> 0) break b;
         switch(_E_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= _D_ - 1 >>> 0) break b;
        caml_call2(Stdlib_Buffer[12], buf, 92);
        caml_call2(Stdlib_Buffer[12], buf, c);
        break a;
       }
       caml_call2(Stdlib_Buffer[12], buf, c);
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _F_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function string_before(s, n){
    return caml_call3(Stdlib_String[16], s, 0, n);
   }
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[16], s, n, caml_ml_string_length(s) - n | 0);
   }
   function first_chars(s, n){return caml_call3(Stdlib_String[16], s, 0, n);}
   function last_chars(s, n){
    return caml_call3
            (Stdlib_String[16], s, caml_ml_string_length(s) - n | 0, n);
   }
   function regexp(e){return compile_regexp(e, 0);}
   function regexp_case_fold(e){return compile_regexp(e, 1);}
   function regexp_string(s){return compile_regexp(quote(s), 0);}
   function regexp_string_case_fold(s){return compile_regexp(quote(s), 1);}
   function group_beginning(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_beginning);
    var pos = offset_group(n)[1];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function group_end(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_end);
    var pos = offset_group(n)[2];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function matched_group(n, txt){
    var match = offset_group(n), e = match[2], b = match[1];
    return caml_call3(Stdlib_String[16], txt, b, e - b | 0);
   }
   function replace_matched(repl, matched){
    return replacement_text(repl, matched);
   }
   function match_beginning(param){return group_beginning(0);}
   function match_end(param){return group_end(0);}
   function matched_string(txt){return matched_group(0, txt);}
   function substitute_first(expr, repl_fun, text){
    try{
     var
      pos = search_forward(expr, text, 0),
      _w_ = [0, string_after(text, match_end(0)), 0],
      _x_ = [0, caml_call1(repl_fun, text), _w_],
      _y_ = [0, string_before(text, pos), _x_],
      _z_ = caml_call2(Stdlib_String[7], cst, _y_);
     return _z_;
    }
    catch(_A_){
     var _v_ = caml_wrap_exception(_A_);
     if(_v_ === Stdlib[8]) return text;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
   }
   function global_substitute(expr, repl_fun, text){
    var accu = 0, start = 0, last_was_empty = 0;
    for(;;){
     var startpos = last_was_empty ? start + 1 | 0 : start;
     a:
     {
      if(caml_ml_string_length(text) >= startpos){
       try{var pos = search_forward(expr, text, startpos);}
       catch(_u_){
        var _r_ = caml_wrap_exception(_u_);
        if(_r_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_r_, 0);
        var _s_ = [0, string_after(text, start), accu];
        break a;
       }
       var
        end_pos = match_end(0),
        repl_text = caml_call1(repl_fun, text),
        last_was_empty$0 = end_pos === pos ? 1 : 0,
        accu$0 =
          [0,
           repl_text,
           [0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu]];
       accu = accu$0;
       start = end_pos;
       last_was_empty = last_was_empty$0;
       continue;
      }
      var _s_ = [0, string_after(text, start), accu];
     }
     var _t_ = caml_call1(Stdlib_List[10], _s_);
     return caml_call2(Stdlib_String[7], cst$0, _t_);
    }
   }
   function global_replace(expr, repl, text){
    return global_substitute
            (expr, function(_q_){return replacement_text(repl, _q_);}, text);
   }
   function replace_first(expr, repl, text){
    return substitute_first
            (expr, function(_p_){return replacement_text(repl, _p_);}, text);
   }
   function search_forward_progress(re, s, p){
    var pos = search_forward(re, s, p);
    if(p < match_end(0)) return pos;
    if(p < caml_ml_string_length(s)) return search_forward(re, s, p + 1 | 0);
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function bounded_split(expr, text, num){
    var start = string_match(expr, text, 0) ? match_end(0) : 0;
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _m_ = match_end(0),
       _n_ =
         split
          ([0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu],
           _m_,
           n - 1 | 0);
      return _n_;
     }
     catch(_o_){
      var _l_ = caml_wrap_exception(_o_);
      if(_l_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_l_, 0);
     }
    }
    var _k_ = split(0, start, num);
    return caml_call1(Stdlib_List[10], _k_);
   }
   function split(expr, text){return bounded_split(expr, text, 0);}
   function bounded_split_delim(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) < start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _h_ = match_end(0),
       _i_ =
         split
          ([0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu],
           _h_,
           n - 1 | 0);
      return _i_;
     }
     catch(_j_){
      var _g_ = caml_wrap_exception(_j_);
      if(_g_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_g_, 0);
     }
    }
    if(text === cst$1) return 0;
    var _f_ = split(0, 0, num);
    return caml_call1(Stdlib_List[10], _f_);
   }
   function split_delim(expr, text){
    return bounded_split_delim(expr, text, 0);
   }
   function bounded_full_split(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, [0, string_after(text, start)], accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       s = matched_string(text);
      if(start < pos)
       var
        _c_ = match_end(0),
        _d_ =
          split
           ([0,
             [1, s],
             [0,
              [0, caml_call3(Stdlib_String[16], text, start, pos - start | 0)],
              accu]],
            _c_,
            n - 1 | 0);
      else
       var _d_ = split([0, [1, s], accu], match_end(0), n - 1 | 0);
      return _d_;
     }
     catch(_e_){
      var _b_ = caml_wrap_exception(_e_);
      if(_b_ === Stdlib[8]) return [0, [0, string_after(text, start)], accu];
      throw caml_maybe_attach_backtrace(_b_, 0);
     }
    }
    var _a_ = split(0, 0, num);
    return caml_call1(Stdlib_List[10], _a_);
   }
   function full_split(expr, text){return bounded_full_split(expr, text, 0);}
   var
    Re_Str =
      [0,
       regexp,
       regexp_case_fold,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_backward,
       string_partial_match,
       matched_string,
       match_beginning,
       match_end,
       matched_group,
       group_beginning,
       group_end,
       global_replace,
       replace_first,
       global_substitute,
       substitute_first,
       replace_matched,
       split,
       bounded_split,
       split_delim,
       bounded_split_delim,
       full_split,
       bounded_full_split,
       string_before,
       string_after,
       first_chars,
       last_chars];
   runtime.caml_register_global(17, Re_Str, "Re__Str");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Replace
//# unitInfo: Requires: Re__Compile, Re__Group, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Re_replace$1 = "Re.replace",
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Compile = global_data.Re__Compile,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Re_Group = global_data.Re__Group,
    Stdlib = global_data.Stdlib,
    cst_Re_replace = cst_Re_replace$1,
    cst_Re_replace$0 = cst_Re_replace$1;
   function replace(_a_, len, opt, re, f, s){
    var pos = _a_ ? _a_[1] : 0, all = opt ? opt[1] : 1;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_replace);
    if(len){
     var
      l = len[1],
      _b_ = l < 0 ? 1 : 0,
      _c_ = _b_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_c_) caml_call1(Stdlib[1], cst_Re_replace$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    var
     buf = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(s)),
     pos$0 = pos,
     on_match = 0;
    for(;;){
     if(pos$0 <= limit){
      var
       match =
         caml_call6(Re_Compile[2], 1, 0, re, s, pos$0, limit - pos$0 | 0);
      if(typeof match === "number")
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, limit - pos$0 | 0);
      else if(0 === match[0]){
       var
        substr = match[1],
        match$0 = caml_call2(Re_Group[4], substr, 0),
        p2 = match$0[2],
        p1 = match$0[1];
       if(pos$0 === p1 && p1 === p2 && on_match){
        if(p2 < limit){
         var _d_ = caml_string_get(s, p2);
         caml_call2(Stdlib_Buffer[12], buf, _d_);
        }
        var pos$1 = p2 + 1 | 0;
        pos$0 = pos$1;
        on_match = 0;
        continue;
       }
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, p1 - pos$0 | 0);
       var replacing = caml_call1(f, substr);
       caml_call2(Stdlib_Buffer[16], buf, replacing);
       if(all){
        var on_match$0 = p1 !== p2 ? 1 : 0;
        if(p1 === p2){
         if(p2 < limit){
          var _e_ = caml_string_get(s, p2);
          caml_call2(Stdlib_Buffer[12], buf, _e_);
         }
         var pos$2 = p2 + 1 | 0;
        }
        else
         var pos$2 = p2;
        pos$0 = pos$2;
        on_match = on_match$0;
        continue;
       }
       caml_call4(Stdlib_Buffer[18], buf, s, p2, limit - p2 | 0);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function replace_string(pos, len, all, re, by, s){
    return replace(pos, len, all, re, function(param){return by;}, s);
   }
   var Re_Replace = [0, replace, replace_string];
   runtime.caml_register_global(6, Re_Replace, "Re__Replace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Glob
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    beg = [0, cst$0, 0],
    cst = "/**",
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Parse_error = [248, "Re__Glob.Parse_error", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, 45],
    _b_ = [0, 47],
    _c_ = [0, cst$0, 0],
    _d_ = [0, cst$0, 0],
    _e_ = [0, 47, [0, 92, 0]],
    _f_ = [0, 47, 0],
    _g_ = [0, 1],
    _h_ = [0, 1];
   function mul(l$0, l){
    var
     _ac_ =
       caml_call2
        (Stdlib_List[20],
         function(s){
          return caml_call2
                  (Stdlib_List[20],
                   function(s$0){return caml_call2(Stdlib[28], s, s$0);},
                   l);
         },
         l$0);
    return caml_call1(Stdlib_List[15], _ac_);
   }
   function explicit_period(t){
    var ___ = t[7];
    if(___){
     var _$_ = t[3];
     if(_$_) var _aa_ = _$_; else var _ab_ = t[4], _aa_ = _ab_ ? t[5] : _ab_;
    }
    else
     var _aa_ = ___;
    return _aa_;
   }
   function slashes(t){return t[6] ? _e_ : _f_;}
   function append(opt, t, piece){
    var am_at_start_of_component = opt ? opt[1] : 0;
    return [0,
            [0, piece, t[1]],
            t[2],
            0,
            am_at_start_of_component,
            t[5],
            t[6],
            t[7]];
   }
   function next(t){
    var match = t[2];
    if(! match) return 0;
    var remaining = match[2], piece = match[1];
    return [0, [0, piece, [0, t[1], remaining, t[3], t[4], t[5], t[6], t[7]]]];
   }
   function one(explicit_slash, slashes, explicit_period){
    var
     _V_ = 0,
     _W_ = explicit_period ? [0, caml_call1(Re_Core[26], 46), 0] : 0,
     _X_ = [0, _W_, _V_],
     _Y_ =
       explicit_slash ? caml_call2(Stdlib_List[20], Re_Core[26], slashes) : 0,
     _Z_ = caml_call1(Stdlib_List[14], [0, _Y_, _X_]);
    return caml_call1(Re_Core[60], _Z_);
   }
   function enclosed(enclosed){
    if(0 === enclosed[0]){
     var c = enclosed[1];
     return caml_call1(Re_Core[26], c);
    }
    var high = enclosed[2], low = enclosed[1];
    return caml_call2(Re_Core[57], low, high);
   }
   function enclosed_set(explicit_slash, slashes, explicit_period, kind, set){
    var
     set$0 = caml_call2(Stdlib_List[20], enclosed, set),
     enclosure =
       596216810 <= kind
        ? caml_call1(Re_Core[27], set$0)
        : caml_call1(Re_Core[60], set$0),
     _U_ =
       [0, enclosure, [0, one(explicit_slash, slashes, explicit_period), 0]];
    return caml_call1(Re_Core[58], _U_);
   }
   function exactly(state, c){
    var
     slashes$0 = slashes(state),
     am_at_start_of_component = caml_call2(Stdlib_List[37], c, slashes$0),
     chars = am_at_start_of_component ? slashes$0 : [0, c, 0],
     _T_ = caml_call2(Stdlib_List[20], Re_Core[26], chars);
    return append
            ([0, am_at_start_of_component],
             state,
             caml_call1(Re_Core[27], _T_));
   }
   function many_many(state){
    var
     _H_ = state[7],
     explicit_period$0 = _H_ ? state[5] : _H_,
     first_explicit_period = explicit_period(state),
     slashes$0 = slashes(state);
    function match_component(explicit_period){
     var
      _Q_ = one(1, slashes$0, 0),
      _R_ = [0, caml_call1(Re_Core[31], _Q_), 0],
      _S_ = [0, one(1, slashes$0, explicit_period), _R_];
     return caml_call1(Re_Core[28], _S_);
    }
    var
     _I_ = match_component(explicit_period$0),
     _J_ = [0, caml_call1(Re_Core[34], _I_), 0],
     _K_ = caml_call2(Stdlib_List[20], Re_Core[26], slashes$0),
     _L_ = [0, caml_call1(Re_Core[27], _K_), _J_],
     _M_ = caml_call1(Re_Core[28], _L_),
     _N_ = [0, caml_call1(Re_Core[31], _M_), 0],
     _O_ = match_component(first_explicit_period),
     _P_ = [0, caml_call1(Re_Core[34], _O_), _N_];
    return append(0, state, caml_call1(Re_Core[28], _P_));
   }
   function glob(_o_, _n_, _m_, _l_, _k_, opt, str){
    var
     anchored = _o_ ? _o_[1] : 0,
     pathname = _n_ ? _n_[1] : 1,
     match_backslashes = _m_ ? _m_[1] : 0,
     period = _l_ ? _l_[1] : 1,
     expand_braces = _k_ ? _k_[1] : 0,
     double_asterisk = opt ? opt[1] : 1;
    function to_re(s){
     var buf = caml_call1(Re_Parse_buffer[2], s);
     function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
     function read(c){return caml_call2(Re_Parse_buffer[9], buf, c);}
     function char$0(param){
      read(92);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      return caml_call1(Re_Parse_buffer[8], buf);
     }
     function enclosed(param){
      var s = 0;
      for(;;){
       if(0 !== s && read(93)) return s;
       var c = char$0(0);
       if(read(45)){
        if(read(93)) return [0, [0, c], [0, _a_, s]];
        var c$0 = char$0(0), s$0 = [0, [1, c, c$0], s];
        s = s$0;
       }
       else{var s$1 = [0, [0, c], s]; s = s$1;}
      }
     }
     var pieces = 0;
     for(;;){
      if(eos(0)) break;
      a:
      {
       if(double_asterisk && caml_call2(Re_Parse_buffer[11], buf, cst)){
        var _s_ = eos(0) ? [0, _b_, pieces] : pieces, pieces$0 = [0, 2, _s_];
        break a;
       }
       if(read(42)){
        b:
        {if(double_asterisk && read(42)){var _t_ = 2; break b;} var _t_ = 1;}
        var pieces$0 = [0, _t_, pieces];
       }
       else if(read(63))
        var pieces$0 = [0, 0, pieces];
       else if(read(91)){
        if(! read(94) && ! read(33)){
         var pieces$0 = [0, [1, enclosed(0)], pieces];
         break a;
        }
        var pieces$0 = [0, [2, enclosed(0)], pieces];
       }
       else
        var pieces$0 = [0, [0, char$0(0)], pieces];
      }
      pieces = pieces$0;
     }
     var
      remaining = caml_call1(Stdlib_List[10], pieces),
      state = [0, 0, remaining, 1, 1, pathname, match_backslashes, period],
      state$8 = state;
     for(;;){
      var match$1 = next(state$8);
      if(! match$1){
       var
        _u_ = caml_call1(Stdlib_List[10], state$8[1]),
        re = caml_call1(Re_Core[28], _u_);
       return anchored ? caml_call1(Re_Core[46], re) : re;
      }
      var
       match$2 = match$1[1],
       state$9 = match$2[2],
       piece = match$2[1],
       explicit_slash = state$9[5],
       explicit_period$1 = explicit_period(state$9),
       slashes$1 = slashes(state$9);
      if(typeof piece === "number")
       a:
       switch(piece){
         case 0:
          var
           state$10 =
             append
              (0, state$9, one(explicit_slash, slashes$1, explicit_period$1));
          break;
         case 1:
          var
           explicit_slash$0 = state$9[5],
           explicit_period$0 = explicit_period(state$9),
           slashes$0 = slashes(state$9);
          if(explicit_period$0)
           if(explicit_slash$0){
            var
             _v_ = one(1, slashes$0, 0),
             _w_ = [0, caml_call1(Re_Core[31], _v_), 0],
             _x_ = [0, one(1, slashes$0, 1), _w_],
             not_empty = caml_call1(Re_Core[28], _x_),
             maybe_empty = caml_call1(Re_Core[34], not_empty);
            let slashes = slashes$0, not_empty$1 = not_empty;
            var
             enclosed_set$0 =
               function(state, kind, set){
                var
                 _E_ =
                   [0,
                    not_empty$1,
                    [0, enclosed_set(1, slashes, 0, kind, set), 0]],
                 _F_ = [0, caml_call1(Re_Core[28], _E_), 0],
                 _G_ = [0, enclosed_set(1, slashes, 1, kind, set), _F_];
                return append(0, state, caml_call1(Re_Core[27], _G_));
               };
            b:
            {
             c:
             {
              d:
              {
               var state$0 = state$9;
               for(;;){
                var match = next(state$0);
                if(! match) break;
                var _y_ = match[1], match$0 = _y_[1];
                if(typeof match$0 !== "number") break d;
                switch(match$0){
                  case 0:
                   break b;
                  case 1:
                   var state$2 = _y_[2]; state$0 = state$2; break;
                  default: break c;
                }
               }
               var state$10 = append(0, state$0, maybe_empty);
               break;
              }
              switch(match$0[0]){
                case 0:
                 var
                  state$4 = _y_[2],
                  c = match$0[1],
                  not_empty$0 = 46 === c ? not_empty : maybe_empty,
                  state$5 = append(0, state$4, not_empty$0),
                  state$10 = exactly(state$5, c);
                 break a;
                case 1:
                 var
                  state$6 = _y_[2],
                  enclosed$0 = match$0[1],
                  state$10 = enclosed_set$0(state$6, 596216810, enclosed$0);
                 break a;
                default:
                 var
                  state$7 = _y_[2],
                  enclosed$1 = match$0[1],
                  state$10 = enclosed_set$0(state$7, -188280562, enclosed$1);
                 break a;
              }
             }
             var state$3 = _y_[2], state$10 = many_many(state$3);
             break;
            }
            var state$1 = _y_[2], state$10 = append(0, state$1, not_empty);
           }
           else
            var
             _z_ = one(0, slashes$0, 0),
             _A_ = [0, caml_call1(Re_Core[31], _z_), 0],
             _B_ = [0, one(0, slashes$0, explicit_period$0), _A_],
             _C_ = caml_call1(Re_Core[28], _B_),
             state$10 = append(0, state$9, caml_call1(Re_Core[34], _C_));
          else
           var
            _D_ = one(explicit_slash$0, slashes$0, explicit_period$0),
            state$10 = append(0, state$9, caml_call1(Re_Core[31], _D_));
          break;
         default: var state$10 = many_many(state$9);
       }
      else
       switch(piece[0]){
         case 0:
          var c$0 = piece[1], state$10 = exactly(state$9, c$0); break;
         case 1:
          var
           enclosed$2 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash,
                 slashes$1,
                 explicit_period$1,
                 596216810,
                 enclosed$2));
          break;
         default:
          var
           enclosed$3 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash,
                 slashes$1,
                 explicit_period$1,
                 -188280562,
                 enclosed$3));
       }
      state$8 = state$10;
     }
    }
    if(! expand_braces) return to_re(str);
    var l = runtime.caml_ml_string_length(str);
    function expl(inner, s, i, acc, beg$0){
     var s$0 = s, i$0 = i, acc$0 = acc, beg$1 = beg$0;
     for(;;){
      if(l <= i$0){
       if(inner) throw caml_maybe_attach_backtrace(Parse_error, 1);
       return [0,
               mul
                (beg$1,
                 [0,
                  caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                  0]),
               i$0];
      }
      var match = runtime.caml_string_get(str, i$0);
      if(44 === match){
       if(inner){
        var
         _q_ =
           mul
            (beg$1,
             [0, caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0), 0]),
         acc$1 = caml_call2(Stdlib[37], _q_, acc$0),
         i$1 = i$0 + 1 | 0,
         s$1 = i$0 + 1 | 0;
        s$0 = s$1;
        i$0 = i$1;
        acc$0 = acc$1;
        beg$1 = beg;
        continue;
       }
      }
      else
       if(123 <= match){
        if(126 > match)
         switch(match - 123 | 0){
           case 0:
            var
             match$0 = expl(1, i$0 + 1 | 0, i$0 + 1 | 0, 0, _c_),
             i$3 = match$0[2],
             t = match$0[1],
             beg$2 =
               mul
                (beg$1,
                 mul
                  ([0,
                    caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                    0],
                   t));
            s$0 = i$3;
            i$0 = i$3;
            beg$1 = beg$2;
            continue;
           case 1: break;
           default:
            if(inner){
             var
              _r_ =
                mul
                 (beg$1,
                  [0,
                   caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                   0]);
             return [0, caml_call2(Stdlib[37], _r_, acc$0), i$0 + 1 | 0];
            }
         }
       }
       else if(92 === match){var i$4 = i$0 + 2 | 0; i$0 = i$4; continue;}
      var i$2 = i$0 + 1 | 0;
      i$0 = i$2;
     }
    }
    var
     _i_ = expl(0, 0, 0, 0, _d_)[1],
     _j_ = caml_call1(Stdlib_List[10], _i_),
     _p_ = caml_call2(Stdlib_List[20], to_re, _j_);
    return caml_call1(Re_Core[27], _p_);
   }
   function glob$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], 0, 0, s);
   }
   function globx(anchored, s){return glob(anchored, 0, 0, 0, _g_, 0, s);}
   function globx$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], _h_, 0, s);
   }
   var Re_Glob = [0, Parse_error, glob, glob$0, globx, globx$0];
   runtime.caml_register_global(16, Re_Glob, "Re__Glob");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Posix_class
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_alnum = "alnum",
    cst_alpha = "alpha",
    cst_ascii = "ascii",
    cst_blank = "blank",
    cst_cntrl = "cntrl",
    cst_digit = "digit",
    cst_graph = "graph",
    cst_lower = "lower",
    cst_print = "print",
    cst_punct = "punct",
    cst_space = "space",
    cst_upper = "upper",
    cst_word = "word",
    cst_xdigit = "xdigit",
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ":]",
    names =
      caml_list_of_js_array
       ([cst_alpha,
         cst_alnum,
         cst_ascii,
         cst_blank,
         cst_cntrl,
         cst_digit,
         cst_lower,
         cst_print,
         cst_space,
         cst_upper,
         cst_word,
         cst_punct,
         cst_graph,
         cst_xdigit]),
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Re_Core = global_data.Re__Core,
    cst_Invalid_pcre_class = "Invalid pcre class: ";
   function of_name(class$0){
    var switch$0 = runtime.caml_string_compare(class$0, cst_lower);
    if(0 <= switch$0){
     if(0 >= switch$0) return Re_Core[71];
     if(class$0 === cst_print) return Re_Core[72];
     if(class$0 === cst_punct) return Re_Core[73];
     if(class$0 === cst_space) return Re_Core[74];
     if(class$0 === cst_upper) return Re_Core[75];
     if(class$0 === cst_word) return Re_Core[64];
     if(class$0 === cst_xdigit) return Re_Core[76];
    }
    else{
     if(class$0 === cst_alnum) return Re_Core[63];
     if(class$0 === cst_alpha) return Re_Core[65];
     if(class$0 === cst_ascii) return Re_Core[66];
     if(class$0 === cst_blank) return Re_Core[67];
     if(class$0 === cst_cntrl) return Re_Core[68];
     if(class$0 === cst_digit) return Re_Core[69];
     if(class$0 === cst_graph) return Re_Core[70];
    }
    var _d_ = caml_call2(Stdlib[28], cst_Invalid_pcre_class, class$0);
    return caml_call1(Stdlib[1], _d_);
   }
   function parse(buf){
    var
     accept = caml_call1(Re_Parse_buffer[9], buf),
     accept_s = caml_call1(Re_Parse_buffer[11], buf);
    if(! caml_call1(accept, 58)) return 0;
    var compl = caml_call1(accept, 94);
    try{var cls = caml_call2(Stdlib_List[39], accept_s, names);}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8])
      throw caml_maybe_attach_backtrace(Re_Parse_buffer[1], 1);
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
    if(1 - caml_call1(accept_s, cst))
     throw caml_maybe_attach_backtrace(Re_Parse_buffer[1], 1);
    var
     posix_class = of_name(cls),
     _b_ = compl ? caml_call1(Re_Core[60], [0, posix_class, 0]) : posix_class;
    return [0, _b_];
   }
   var Re_Posix_class = [0, names, of_name, parse];
   runtime.caml_register_global(21, Re_Posix_class, "Re__Posix_class");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Perl
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Re__Posix_class, Stdlib, Stdlib__Buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Re_Core = global_data.Re__Core,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Re_Posix_class = global_data.Re__Posix_class,
    Stdlib = global_data.Stdlib,
    Parse_error = Re_Parse_buffer[1],
    Not_supported =
      [248, "Re__Perl.Not_supported", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, 748194550, 8],
    _b_ = [0, 748194550, 10],
    _c_ = [0, 748194550, 13],
    _d_ = [0, 748194550, 9];
   function char_of_int(x){
    try{var x$0 = caml_call1(Stdlib[29], x); return x$0;}
    catch(_y_){throw caml_maybe_attach_backtrace(Parse_error, 1);}
   }
   function re(opt, s){
    var
     opts = opt ? opt[1] : 0,
     ungreedy = caml_call2(Stdlib_List[38], -243745063, opts),
     dotall = caml_call2(Stdlib_List[38], -424303016, opts),
     dollar_endonly = caml_call2(Stdlib_List[38], -712595228, opts),
     multiline = caml_call2(Stdlib_List[38], 1071952589, opts),
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    function test(c){return caml_call2(Re_Parse_buffer[6], buf, c);}
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function greedy_mod(r){
     var gr = caml_call1(accept, 63), gr$0 = ungreedy ? 1 - gr : gr;
     return gr$0 ? caml_call1(Re_Core[51], r) : caml_call1(Re_Core[50], r);
    }
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call1(accept, 124)) return left$0;
      var
       _x_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _x_);
      left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       var r = atom(0);
       if(caml_call1(accept, 42))
        var _w_ = greedy_mod(caml_call1(Re_Core[31], r));
       else if(caml_call1(accept, 43))
        var _w_ = greedy_mod(caml_call1(Re_Core[32], r));
       else if(caml_call1(accept, 63))
        var _w_ = greedy_mod(caml_call1(Re_Core[34], r));
       else if(caml_call1(accept, 123)){
        var match = caml_call1(Re_Parse_buffer[12], buf);
        if(match){
         var
          i = match[1],
          j =
            caml_call1(accept, 44)
             ? caml_call1(Re_Parse_buffer[12], buf)
             : [0, i];
         if(1 - caml_call1(accept, 125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var _w_ = greedy_mod(caml_call3(Re_Core[33], r, i, j));
        }
        else{caml_call1(Re_Parse_buffer[4], buf); var _w_ = r;}
       }
       else
        var _w_ = r;
       var left$0 = [0, _w_, left];
       left = left$0;
       continue;
      }
      var _v_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _v_);
     }
    }
    function in_brace(f, init){
     if(! caml_call1(accept, 123)) return 0;
     var acc = init;
     for(;;){
      if(caml_call1(accept, 125)) return [0, acc];
      var acc$0 = caml_call1(f, acc);
      acc = acc$0;
     }
    }
    function atom(param){
     if(caml_call1(accept, 46)) return dotall ? Re_Core[61] : Re_Core[62];
     if(! caml_call1(accept, 40)){
      if(caml_call1(accept, 94)) return multiline ? Re_Core[35] : Re_Core[39];
      if(caml_call1(accept, 36))
       return multiline
               ? Re_Core[36]
               : dollar_endonly ? Re_Core[41] : Re_Core[40];
      if(caml_call1(accept, 91)){
       if(caml_call1(accept, 94)){
        var _i_ = bracket(0);
        return caml_call1(Re_Core[60], _i_);
       }
       var _j_ = bracket(0);
       return caml_call1(Re_Core[27], _j_);
      }
      if(! caml_call1(accept, 92)){
       if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
       var c = get(0);
       a:
       {
        if(64 <= c){
         if(92 === c || 123 === c) break a;
        }
        else
         if(44 <= c){if(63 <= c) break a;} else if(42 <= c) break a;
        return caml_call1(Re_Core[26], c);
       }
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      }
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var n1 = get(0), switcher = n1 - 48 | 0;
      if(74 >= switcher >>> 0)
       switch(switcher){
         case 17:
          return Re_Core[39];
         case 18:
          return Re_Core[45];
         case 20:
          return caml_call1(Re_Core[60], [0, Re_Core[69], 0]);
         case 21:
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         case 23:
          return Re_Core[42];
         case 33:
          var buf$0 = caml_call1(Stdlib_Buffer[1], 12);
          for(;;)
           if(caml_call1(accept, 92)){
            if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
            var c$0 = get(0);
            if(69 === c$0){
             var _r_ = caml_call1(Stdlib_Buffer[2], buf$0);
             return caml_call1(Re_Core[25], _r_);
            }
            caml_call2(Stdlib_Buffer[12], buf$0, 92);
            caml_call2(Stdlib_Buffer[12], buf$0, c$0);
           }
           else{
            if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
            var _s_ = get(0);
            caml_call2(Stdlib_Buffer[12], buf$0, _s_);
           }
          break;
         case 35:
          return caml_call1(Re_Core[60], [0, Re_Core[74], 0]);
         case 39:
          var _l_ = [0, caml_call1(Re_Core[26], 95), 0];
          return caml_call1(Re_Core[60], [0, Re_Core[63], _l_]);
         case 42:
          return Re_Core[41];
         case 50:
          return caml_call1
                  (Re_Core[27], [0, Re_Core[37], [0, Re_Core[38], 0]]);
         case 52:
          return Re_Core[69];
         case 53:
          return caml_call1(Re_Core[26], 27);
         case 54:
          return caml_call1(Re_Core[26], 12);
         case 62:
          return caml_call1(Re_Core[26], 10);
         case 63:
          var
           match =
             in_brace
              (function(acc){
                var match = maybe_octaldigit(0);
                if(! match) throw caml_maybe_attach_backtrace(Parse_error, 1);
                var p = match[1];
                return [0, p, acc];
               },
               0);
          if(! match) throw caml_maybe_attach_backtrace(Parse_error, 1);
          var digits$1 = match[1], digits = digits$1, acc = 0, i = 1;
          for(;;){
           if(! digits){
            var _m_ = char_of_int(acc);
            return caml_call1(Re_Core[26], _m_);
           }
           var
            digits$0 = digits[2],
            d = digits[1],
            acc$0 = acc + caml_mul(d, i) | 0,
            i$0 = caml_mul(i, i);
           digits = digits$0;
           acc = acc$0;
           i = i$0;
          }
          break;
         case 66:
          return caml_call1(Re_Core[26], 13);
         case 67:
          return Re_Core[74];
         case 68:
          return caml_call1(Re_Core[26], 9);
         case 71:
          var _n_ = [0, caml_call1(Re_Core[26], 95), 0];
          return caml_call1(Re_Core[27], [0, Re_Core[63], _n_]);
         case 72:
          var
           match$0 = in_brace(function(acc){return [0, hexdigit(0), acc];}, 0);
          a:
          {
           if(match$0){
            var _o_ = match$0[1];
            if(_o_){
             var _p_ = _o_[2], c1 = _o_[1];
             if(! _p_){var c2$0 = c1, c1$0 = 0; break a;}
             if(! _p_[2]){var c2 = _p_[1], c2$0 = c2, c1$0 = c1; break a;}
            }
            throw caml_maybe_attach_backtrace(Parse_error, 1);
           }
           var
            c1$1 = hexdigit(0),
            c2$1 = hexdigit(0),
            c2$0 = c2$1,
            c1$0 = c1$1;
          }
          var code = (c1$0 * 16 | 0) + c2$0 | 0, _q_ = char_of_int(code);
          return caml_call1(Re_Core[26], _q_);
         case 74:
          return Re_Core[40];
         case 8:
         case 9:
          throw caml_maybe_attach_backtrace(Not_supported, 1);
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 7:
          var n2 = maybe_octaldigit(0), n3 = maybe_octaldigit(0);
          if(n2 && n3){
           var
            n3$0 = n3[1],
            n2$0 = n2[1],
            n1$0 = n1 - 48 | 0,
            _k_ =
              char_of_int(((n1$0 * 64 | 0) + (n2$0 * 8 | 0) | 0) + n3$0 | 0);
           return caml_call1(Re_Core[26], _k_);
          }
          throw caml_maybe_attach_backtrace(Not_supported, 1);
         case 10:
         case 11:
         case 12:
         case 13:
         case 14:
         case 15:
         case 16:
         case 43:
         case 44:
         case 45:
         case 46:
         case 47:
         case 48: break;
         default: throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
      return caml_call1(Re_Core[26], n1);
     }
     if(! caml_call1(accept, 63)){
      var r$1 = regexp(0);
      if(1 - caml_call1(accept, 41))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return caml_call2(Re_Core[52], 0, r$1);
     }
     if(caml_call1(accept, 58)){
      var r = regexp(0);
      if(1 - caml_call1(accept, 41))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return r;
     }
     if(! caml_call1(accept, 35)){
      if(! caml_call1(accept, 60))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$1 = get(0), _t_ = c$1 - 91 | 0;
      a:
      {
       if(5 < _t_ >>> 0){
        if(57 < _t_ + 26 >>> 0) break a;
       }
       else if(4 !== _t_) break a;
       var b = caml_call1(Stdlib_Buffer[1], 32);
       caml_call2(Stdlib_Buffer[12], b, c$1);
       for(;;){
        if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
        var c$2 = get(0);
        b:
        {
         if(65 <= c$2){
          var _u_ = c$2 - 91 | 0;
          if(5 < _u_ >>> 0){
           if(32 <= _u_) break b;
          }
          else if(4 !== _u_) break b;
         }
         else{
          if(58 <= c$2){
           if(62 !== c$2) break b;
           var name = caml_call1(Stdlib_Buffer[2], b), r$0 = regexp(0);
           if(1 - caml_call1(accept, 41))
            throw caml_maybe_attach_backtrace(Parse_error, 1);
           return caml_call2(Re_Core[52], [0, name], r$0);
          }
          if(48 > c$2) break b;
         }
         caml_call2(Stdlib_Buffer[12], b, c$2);
         continue;
        }
        throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
      }
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     }
     for(;;){
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(caml_call1(accept, 41)) return Re_Core[30];
      caml_call1(Re_Parse_buffer[3], buf);
     }
    }
    function hexdigit(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var d = get(0);
     if(65 <= d){
      if(97 <= d){
       if(103 > d) return (d - 97 | 0) + 10 | 0;
      }
      else if(71 > d) return (d - 65 | 0) + 10 | 0;
     }
     else if(9 >= d - 48 >>> 0) return d - 48 | 0;
     throw caml_maybe_attach_backtrace(Parse_error, 1);
    }
    function maybe_octaldigit(param){
     if(eos(0)) return 0;
     var d = get(0);
     return 7 < d - 48 >>> 0 ? 0 : [0, d - 48 | 0];
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var match = char$0(0);
      if(748194550 <= match[1]){
       var c = match[2];
       if(caml_call1(accept, 45)){
        if(caml_call1(accept, 93)){
         var _g_ = [0, caml_call1(Re_Core[26], 45), s$0];
         return [0, caml_call1(Re_Core[26], c), _g_];
        }
        var match$0 = char$0(0);
        if(748194550 <= match$0[1])
         var
          c$0 = match$0[2],
          s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
        else
         var
          st = match$0[2],
          _h_ = [0, caml_call1(Re_Core[26], 45), [0, st, s$0]],
          s$1 = [0, caml_call1(Re_Core[26], c), _h_];
        s$0 = s$1;
       }
       else{var s$2 = [0, caml_call1(Re_Core[26], c), s$0]; s$0 = s$2;}
      }
      else{var st$0 = match[2], s$3 = [0, st$0, s$0]; s$0 = s$3;}
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 === c){
      if(caml_call1(accept, 61))
       throw caml_maybe_attach_backtrace(Not_supported, 1);
      var match = caml_call1(Re_Posix_class[3], buf);
      if(match){var set = match[1]; return [0, 4150146, set];}
      if(! caml_call1(accept, 46)) return [0, 748194550, c];
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$0 = get(0);
      if(1 - caml_call1(accept, 46))
       throw caml_maybe_attach_backtrace(Not_supported, 1);
      if(1 - caml_call1(accept, 93))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return [0, 748194550, c$0];
     }
     if(92 !== c) return [0, 748194550, c];
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c$1 = get(0);
     if(58 <= c$1){
      if(123 > c$1)
       switch(c$1 - 58 | 0){
         case 10:
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[69], 0])];
         case 25:
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[74], 0])];
         case 29:
          var _e_ = [0, caml_call1(Re_Core[26], 95), 0];
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[63], _e_])];
         case 40:
          return _a_;
         case 42:
          return [0, 4150146, Re_Core[69]];
         case 52:
          return _b_;
         case 56:
          return _c_;
         case 57:
          return [0, 4150146, Re_Core[74]];
         case 58:
          return _d_;
         case 61:
          var _f_ = [0, caml_call1(Re_Core[26], 95), 0];
          return [0, 4150146, caml_call1(Re_Core[27], [0, Re_Core[63], _f_])];
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 33:
         case 34:
         case 35:
         case 36:
         case 37:
         case 38: break;
         default: throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
     }
     else if(48 <= c$1) throw caml_maybe_attach_backtrace(Not_supported, 1);
     return [0, 748194550, c$1];
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[38], 616470068, opts)
        ? caml_call1(Re_Core[28], [0, Re_Core[42], [0, res, 0]])
        : res,
     r$0 =
       caml_call2(Stdlib_List[38], 604571177, opts)
        ? caml_call1(Re_Core[78], r)
        : r;
    return r$0;
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    var opts = opt ? opt[1] : 0;
    return caml_call1(compile, re([0, opts], s));
   }
   var Re_Perl = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(11, Re_Perl, "Re__Perl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pcre
//# unitInfo: Requires: Re__Core, Re__Perl, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Re_Perl = global_data.Re__Perl,
    Parse_error = Re_Perl[1],
    Not_supported = Re_Perl[2],
    _a_ = [0, -1, -1];
   function re(opt, pat){
    var
     flags = opt ? opt[1] : 0,
     opts =
       caml_call2
        (Stdlib_List[20],
         function(param){
          return 601676297 <= param
                  ? 613575188 <= param ? 616470068 : 604571177
                  : 426394317 <= param ? 1071952589 : -424303016;
         },
         flags);
    return caml_call2(Re_Perl[3], [0, opts], pat);
   }
   function regexp(flags, pat){
    var _u_ = re(flags, pat);
    return caml_call1(Re_Core[2], _u_);
   }
   function extract(rex, s){
    var _t_ = caml_call4(Re_Core[5], 0, 0, rex, s);
    return caml_call1(Re_Core[1][9], _t_);
   }
   function exec(rex, pos, s){return caml_call4(Re_Core[5], pos, 0, rex, s);}
   function get_substring(s, i){return caml_call2(Re_Core[1][1], s, i);}
   function names(rex){
    var
     _q_ = caml_call1(Re_Core[4], rex),
     _r_ =
       caml_call1
        (caml_call1(Stdlib_List[20], function(_s_){return _s_[1];}), _q_);
    return caml_call1(Stdlib_Array[11], _r_);
   }
   function get_named_substring(rex, name, s){
    var param = caml_call1(Re_Core[4], rex);
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var match = param[1], rem = param[2], i = match[2], n = match[1];
     if(n === name)
      try{var _o_ = get_substring(s, i); return _o_;}
      catch(_p_){
       var _n_ = caml_wrap_exception(_p_);
       if(_n_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_n_, 0);
       param = rem;
      }
     else{var rem$0 = param[2]; param = rem$0;}
    }
   }
   function get_substring_ofs(s, i){return caml_call2(Re_Core[1][3], s, i);}
   function pmatch(rex, s){return caml_call4(Re_Core[7], 0, 0, rex, s);}
   function substitute(rex, subst, str){
    var b = caml_call1(Stdlib_Buffer[1], 1024), pos = 0, on_match = 0;
    for(;;){
     a:
     if(caml_call4(Re_Core[7], [0, pos], 0, rex, str)){
      var
       ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
       match = caml_call2(Re_Core[1][3], ss, 0),
       fin = match[2],
       start = match[1];
      if(on_match && start === pos && start === fin){
       if(pos >= caml_ml_string_length(str)) break a;
       var _k_ = caml_string_get(str, pos);
       caml_call2(Stdlib_Buffer[12], b, _k_);
       var pos$0 = pos + 1 | 0;
       pos = pos$0;
       on_match = 0;
       continue;
      }
      var pat = caml_call2(Re_Core[1][1], ss, 0);
      caml_call4(Stdlib_Buffer[18], b, str, pos, start - pos | 0);
      var _l_ = caml_call1(subst, pat);
      caml_call2(Stdlib_Buffer[16], b, _l_);
      if(start !== fin){pos = fin; on_match = 1; continue;}
      if(fin < caml_ml_string_length(str)){
       var _m_ = caml_string_get(str, fin);
       caml_call2(Stdlib_Buffer[12], b, _m_);
       var pos$1 = fin + 1 | 0;
       pos = pos$1;
       on_match = 0;
       continue;
      }
     }
     else
      caml_call4
       (Stdlib_Buffer[18], b, str, pos, caml_ml_string_length(str) - pos | 0);
     return caml_call1(Stdlib_Buffer[2], b);
    }
   }
   function split(rex, str){
    function finish(str, last, accu){
     var
      accu$0 =
        [0,
         caml_call3
          (Stdlib_String[16],
           str,
           last,
           caml_ml_string_length(str) - last | 0),
         accu];
     return caml_call1(Stdlib_List[10], accu$0);
    }
    var accu = 0, last = 0, pos = 0, on_match = 0;
    for(;;){
     if(! caml_call4(Re_Core[7], [0, pos], 0, rex, str))
      return finish(str, last, accu);
     var
      ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
      match = caml_call2(Re_Core[1][3], ss, 0),
      last$0 = match[2],
      start = match[1];
     if(on_match && start === pos && start === last$0){
      if(pos === caml_ml_string_length(str)) return finish(str, last, accu);
      var pos$0 = pos + 1 | 0;
      pos = pos$0;
      on_match = 0;
      continue;
     }
     var
      accu$0 =
        [0, caml_call3(Stdlib_String[16], str, last, start - last | 0), accu];
     if(start === last$0){
      if(last$0 === caml_ml_string_length(str))
       return finish(str, last$0, accu$0);
      var pos$1 = last$0 + 1 | 0;
      accu = accu$0;
      last = last$0;
      pos = pos$1;
      on_match = 0;
     }
     else{accu = accu$0; last = last$0; pos = last$0; on_match = 1;}
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_create_bytes(len << 1),
     pos = [0, 0],
     _h_ = len - 1 | 0,
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var c = runtime.caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        if(91 <= c){
         var _i_ = c - 93 | 0;
         if(29 < _i_ >>> 0){
          if(32 <= _i_) break b;
         }
         else if(1 !== _i_) break b;
        }
        else
         if(47 <= c){
          if(63 !== c) break b;
         }
         else{
          if(36 > c) break b;
          switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
          }
         }
        caml_bytes_unsafe_set(buf, pos[1], 92);
        pos[1]++;
        caml_bytes_unsafe_set(buf, pos[1], c);
        pos[1]++;
        break a;
       }
       caml_bytes_unsafe_set(buf, pos[1], c);
       pos[1]++;
      }
      var _j_ = i + 1 | 0;
      if(_h_ === i) break;
      i = _j_;
     }
    }
    var len$0 = pos[1], r = caml_create_bytes(len$0);
    runtime.caml_blit_bytes(buf, 0, r, 0, len$0);
    return caml_call1(Stdlib_Bytes[44], r);
   }
   function full_split(opt, rex, s){
    var max = opt ? opt[1] : 0;
    if(0 === caml_ml_string_length(s)) return 0;
    if(1 === max) return [0, [0, s], 0];
    var
     results = caml_call4(Re_Core[21], 0, 0, rex, s),
     matches =
       caml_call2
        (Stdlib_List[20],
         function(param){
          if(936573133 <= param[1]){var s = param[2]; return [0, [0, s], 0];}
          var
           d = param[2],
           matches = caml_call1(Re_Core[1][10], d),
           delim = caml_call2(Re_Core[1][1], d, 0),
           l = [0, 0],
           _c_ = matches.length - 2 | 0,
           _b_ = 1;
          if(_c_ >= 1){
           var i = _b_;
           for(;;){
            var
             _d_ = l[1],
             _e_ =
               runtime.caml_equal
                 (runtime.caml_check_bound(matches, i)[1 + i], _a_)
                ? 0
                : [2, i, caml_call2(Re_Core[1][1], d, i)];
            l[1] = [0, _e_, _d_];
            var _f_ = i + 1 | 0;
            if(_c_ === i) break;
            i = _f_;
           }
          }
          return [0, [1, delim], caml_call1(Stdlib_List[10], l[1])];
         },
         results);
    return caml_call1(Stdlib_List[14], matches);
   }
   var
    Re_Pcre =
      [0,
       Parse_error,
       Not_supported,
       re,
       regexp,
       extract,
       exec,
       get_substring,
       names,
       get_named_substring,
       get_substring_ofs,
       pmatch,
       substitute,
       full_split,
       split,
       quote];
   runtime.caml_register_global(9, Re_Pcre, "Re__Pcre");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Posix
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Re__Posix_class, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Re_Posix_class = global_data.Re__Posix_class,
    Parse_error = Re_Parse_buffer[1],
    Not_supported =
      [248, "Re__Posix.Not_supported", runtime.caml_fresh_oo_id(0)];
   function re(opt, s){
    var
     opts = opt ? opt[1] : 0,
     newline = caml_call2(Stdlib_List[38], -638074828, opts),
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    function test(c){return caml_call2(Re_Parse_buffer[6], buf, c);}
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call1(accept, 124)) return left$0;
      var
       _n_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _n_);
      left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       a:
       if(caml_call1(accept, 46))
        var r = newline ? Re_Core[62] : Re_Core[61];
       else if(caml_call1(accept, 40)){
        var r$0 = regexp(0);
        if(1 - caml_call1(accept, 41))
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        var r = caml_call2(Re_Core[52], 0, r$0);
       }
       else if(caml_call1(accept, 94))
        var r = newline ? Re_Core[35] : Re_Core[39];
       else if(caml_call1(accept, 36))
        var r = newline ? Re_Core[36] : Re_Core[40];
       else{
        if(! caml_call1(accept, 91)){
         if(! caml_call1(accept, 92)){
          if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
          var c$0 = get(0);
          b:
          {
           if(64 <= c$0){
            if(92 === c$0 || 123 === c$0) break b;
           }
           else
            if(44 <= c$0){if(63 <= c$0) break b;} else if(42 <= c$0) break b;
           var r = caml_call1(Re_Core[26], c$0);
           break a;
          }
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(91 <= c){
           var _m_ = c - 93 | 0;
           if(29 < _m_ >>> 0){
            if(32 <= _m_) break b;
           }
           else if(1 !== _m_) break b;
          }
          else
           if(47 <= c){
            if(63 !== c) break b;
           }
           else{
            if(36 > c) break b;
            switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
            }
           }
          var r = caml_call1(Re_Core[26], c);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(caml_call1(accept, 94))
         var
          _i_ = caml_call1(Re_Core[26], 10),
          _j_ = bracket(0),
          _k_ = caml_call1(Re_Core[60], _j_),
          r = caml_call2(Re_Core[59], _k_, _i_);
        else
         var _l_ = bracket(0), r = caml_call1(Re_Core[27], _l_);
       }
       if(caml_call1(accept, 42))
        var
         _f_ = caml_call1(Re_Core[54], r),
         _e_ = caml_call1(Re_Core[31], _f_);
       else if(caml_call1(accept, 43))
        var
         _g_ = caml_call1(Re_Core[54], r),
         _e_ = caml_call1(Re_Core[32], _g_);
       else if(caml_call1(accept, 63))
        var _e_ = caml_call1(Re_Core[34], r);
       else if(caml_call1(accept, 123)){
        var match = caml_call1(Re_Parse_buffer[12], buf);
        if(match){
         var
          i = match[1],
          j =
            caml_call1(accept, 44)
             ? caml_call1(Re_Parse_buffer[12], buf)
             : [0, i];
         if(1 - caml_call1(accept, 125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var
          _h_ = caml_call1(Re_Core[54], r),
          _e_ = caml_call3(Re_Core[33], _h_, i, j);
        }
        else{caml_call1(Re_Parse_buffer[4], buf); var _e_ = r;}
       }
       else
        var _e_ = r;
       var left$0 = [0, _e_, left];
       left = left$0;
       continue;
      }
      var _d_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _d_);
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var match = char$0(0);
      if(748194550 <= match[1]){
       var c = match[2];
       if(caml_call1(accept, 45)){
        if(caml_call1(accept, 93)){
         var _b_ = [0, caml_call1(Re_Core[26], 45), s$0];
         return [0, caml_call1(Re_Core[26], c), _b_];
        }
        var match$0 = char$0(0);
        if(748194550 <= match$0[1])
         var
          c$0 = match$0[2],
          s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
        else
         var
          st = match$0[2],
          _c_ = [0, caml_call1(Re_Core[26], 45), [0, st, s$0]],
          s$1 = [0, caml_call1(Re_Core[26], c), _c_];
        s$0 = s$1;
       }
       else{var s$2 = [0, caml_call1(Re_Core[26], c), s$0]; s$0 = s$2;}
      }
      else{var st$0 = match[2], s$3 = [0, st$0, s$0]; s$0 = s$3;}
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 !== c) return [0, 748194550, c];
     var match = caml_call1(Re_Posix_class[3], buf);
     if(match){var set = match[1]; return [0, 4150146, set];}
     if(! caml_call1(accept, 46)) return [0, 748194550, c];
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c$0 = get(0);
     if(1 - caml_call1(accept, 46))
      throw caml_maybe_attach_backtrace(Not_supported, 1);
     if(1 - caml_call1(accept, 93))
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     return [0, 748194550, c$0];
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[38], 886285209, opts)
        ? caml_call1(Re_Core[78], res)
        : res,
     r$0 =
       caml_call2(Stdlib_List[38], 853495711, opts)
        ? caml_call1(Re_Core[53], r)
        : r;
    return r$0;
   }
   function compile(re){
    var _a_ = caml_call1(Re_Core[47], re);
    return caml_call1(Re_Core[2], _a_);
   }
   function compile_pat(opt, s){
    var opts = opt ? opt[1] : 0;
    return compile(re([0, opts], s));
   }
   var Re_Posix = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(5, Re_Posix, "Re__Posix");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re
//# unitInfo: Requires: Re__Core, Re__Replace
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Re_Replace = global_data.Re__Replace,
    Group = Re_Core[1],
    compile = Re_Core[2],
    group_count = Re_Core[3],
    group_names = Re_Core[4],
    exec = Re_Core[5],
    exec_opt = Re_Core[6],
    execp = Re_Core[7],
    exec_partial = Re_Core[8],
    exec_partial_detailed = Re_Core[9],
    Mark = Re_Core[10],
    all = Re_Core[11],
    all_gen = Re_Core[12],
    all_seq = Re_Core[13],
    matches = Re_Core[14],
    matches_gen = Re_Core[15],
    matches_seq = Re_Core[16],
    split = Re_Core[17],
    split_delim = Re_Core[18],
    split_gen = Re_Core[19],
    split_seq = Re_Core[20],
    split_full = Re_Core[21],
    split_full_gen = Re_Core[22],
    split_full_seq = Re_Core[23],
    Seq = Re_Core[24],
    str = Re_Core[25],
    char$0 = Re_Core[26],
    alt = Re_Core[27],
    seq = Re_Core[28],
    empty = Re_Core[29],
    epsilon = Re_Core[30],
    rep = Re_Core[31],
    rep1 = Re_Core[32],
    repn = Re_Core[33],
    opt = Re_Core[34],
    bol = Re_Core[35],
    eol = Re_Core[36],
    bow = Re_Core[37],
    eow = Re_Core[38],
    bos = Re_Core[39],
    eos = Re_Core[40],
    leol = Re_Core[41],
    start = Re_Core[42],
    stop = Re_Core[43],
    word = Re_Core[44],
    not_boundary = Re_Core[45],
    whole_string = Re_Core[46],
    longest = Re_Core[47],
    shortest = Re_Core[48],
    first = Re_Core[49],
    greedy = Re_Core[50],
    non_greedy = Re_Core[51],
    group = Re_Core[52],
    no_group = Re_Core[53],
    nest = Re_Core[54],
    mark = Re_Core[55],
    set = Re_Core[56],
    rg = Re_Core[57],
    inter = Re_Core[58],
    diff = Re_Core[59],
    compl = Re_Core[60],
    any = Re_Core[61],
    notnl = Re_Core[62],
    alnum = Re_Core[63],
    wordc = Re_Core[64],
    alpha = Re_Core[65],
    ascii = Re_Core[66],
    blank = Re_Core[67],
    cntrl = Re_Core[68],
    digit = Re_Core[69],
    graph = Re_Core[70],
    lower = Re_Core[71],
    print = Re_Core[72],
    punct = Re_Core[73],
    space = Re_Core[74],
    upper = Re_Core[75],
    xdigit = Re_Core[76],
    case$0 = Re_Core[77],
    no_case = Re_Core[78],
    pp = Re_Core[79],
    pp_re = Re_Core[80],
    print_re = Re_Core[81],
    witness = Re_Core[82],
    get = Re_Core[83],
    get_ofs = Re_Core[84],
    get_all = Re_Core[85],
    get_all_ofs = Re_Core[86],
    test = Re_Core[87],
    marked = Re_Core[88],
    mark_set = Re_Core[89],
    replace = Re_Replace[1],
    replace_string = Re_Replace[2],
    Re =
      [0,
       Group,
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       Mark,
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_delim,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       Seq,
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       pp_re,
       print_re,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set,
       replace,
       replace_string];
   runtime.caml_register_global(2, Re, "Re");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJSZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsS0FBQSxLQUFBQSxPQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9TIiwiY3N0XzMiLCJjc3QiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYl9BcnJheSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfbGlzdCIsImZwcmludGYiLCJjc3RfTm9uZSIsImFycmF5IiwicHBfc2VwIiwiZm10IiwiYXJyIiwic2V4cCIsInMiLCJwcCIsIngiLCJieXRlcyIsInQiLCJwYWlyIiwicHAxIiwicHAyIiwicGFyYW0iLCJ2MiIsInYxIiwidHJpcGxlIiwicHAzIiwidjMiLCJvcHQiLCJvcHRpbnQiLCJpIiwicHBfZWxlbSIsImNoYXIiLCJjIiwiYm9vbCIsInBwX3N0cl9saXN0IiwibGl0IiwidG9fdG9fc3RyaW5nIiwiYiIsInF1b3RlZF9zdHJpbmciLCJSZV9GbXQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvZm10Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLE1BQUFDLFFBQUF0QixHQUFBdUIsS0FBQUM7QUFBQUEsSUNPaUQsT0FBbUI7QUFBQSw0Q0FBbkIsa0NBQW1CO0FBQUE7QUFBQSxZQUFBQyxLQUFBRixLQUFBRyxHQUFBQyxJQUFBQztBQUFBQSxJQUU5Qyw4Q0FBb0M7QUFBQTtBQUFBLFlBQUFDLE1BQUFOLEtBQUFPO0FBQUFBLFFBQUEsTUFDaEI7QUFBQSxJQUFtQjtBQUFBO0FBQUEsWUFBQUMsS0FBQUMsS0FBQUMsS0FBQVYsS0FBQVc7QUFBQUEsUUFBQUMsS0FFcEQsVUFBQUMsS0FBQTtBQUFBLElBQ1A7QUFBQSxJQUNBO0FBQUEsSUFBcUIsK0JBQ1g7QUFBQTtBQUFBLFlBQUFDLE9BQUFMLEtBQUFDLEtBQUFLLEtBQUFmLEtBQUFXO0FBQUFBLFFBQUFLLEtBR0QsVUFBQUosS0FBQSxVQUFBQyxLQUFBO0FBQUEsSUFDVDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQXFCLCtCQUNYO0FBQUE7QUFBQSxZQUFBSSxJQUFBeEMsR0FBQXVCLEtBQUFLO0FBQUFBLElBSVYsUUFDVSxpREFDc0I7QUFBQSxRQUFBQSxNQUZoQztBQUFBLElBRVksNENBQW9CO0FBQUE7QUFBQSxZQUFBYSxPQUFBbEIsS0FBQVc7QUFBQUEsSUFLdkIsWUFDQztBQUFBLFFBQUFRLElBREQ7QUFBQSxJQUVHLHVDQUFvQjtBQUFBO0FBQUEsWUFBQUMsUUFBQXBCLEtBQUFHO0FBQUFBLElBR2hCLGtEQUE2QjtBQUFBO0FBQUEsWUFBQWtCLE9BQUFyQixLQUFBc0I7QUFBQUEsSUFTOUIsa0RBQXlCO0FBQUE7QUFBQTtBQUFBLElBQUFDLE9EaEQxQztBQUFBLFVDa0RnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxZQUFBeEI7QUFBQUE7QUFBQUEsS0FBQTtBQUFBLE9BTDVCO0FBQUE7QUFBQSxzQkFBQUEsS0FBQVcsT0FBc0Msb0NBQWlCO0FBQUE7QUFBQSxJQUFVO0FBQUE7QUFBQSxZQUFBYyxJQUFBdEIsR0FBQUgsS0FBQVcsT0FNbEQsMENBQXFCO0FBQUEsWUFBQWUsYUFBQXRCLElBQUFDO0FBQUFBO0FBQUFBLEtBQUFzQixJQUc5QjtBQUFBLEtBQUEzQixNQUNFO0FBQUEsSUFDVjtBQUFBLElBQVEsc0NBQ1M7QUFBQTtBQUFBLFlBQUE0QixjQUFBNUIsS0FBQUc7QUFBQUEsSUFHTyxrREFBeUI7QUFBQTtBQUFBO0FBQUEsSUFBQTBCO0FBQUFBLE1BVm5CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURsRGhDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiogVmVyeSBzbWFsbCB0b29saW5nIGZvciBmb3JtYXQgcHJpbnRlcnMuICopXG5cbmluY2x1ZGUgRm9ybWF0XG5cbnR5cGUgJ2EgdCA9IEZvcm1hdC5mb3JtYXR0ZXIgLT4gJ2EgLT4gdW5pdFxuXG5sZXQgbGlzdCA9IHBwX3ByaW50X2xpc3RcbmxldCBhcnJheSA/cHBfc2VwIGYgZm10IGFyciA9IGxpc3QgP3BwX3NlcCBmIGZtdCAoQXJyYXkudG9fbGlzdCBhcnIpXG5sZXQgc3RyID0gcHBfcHJpbnRfc3RyaW5nXG5sZXQgc2V4cCBmbXQgcyBwcCB4ID0gZnByaW50ZiBmbXQgXCJAWzwzPiglc0AgJWEpQF1cIiBzIHBwIHhcbmxldCBieXRlcyBmbXQgdCA9IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVTXCIgKEJ5dGVzLnRvX3N0cmluZyB0KVxuXG5sZXQgcGFpciBwcDEgcHAyIGZtdCAodjEsIHYyKSA9XG4gIHBwMSBmbXQgdjE7XG4gIHBwX3ByaW50X3NwYWNlIGZtdCAoKTtcbiAgcHAyIGZtdCB2MlxuOztcblxubGV0IHRyaXBsZSBwcDEgcHAyIHBwMyBmbXQgKHYxLCB2MiwgdjMpID1cbiAgcHAxIGZtdCB2MTtcbiAgcHBfcHJpbnRfc3BhY2UgZm10ICgpO1xuICBwcDIgZm10IHYyO1xuICBwcF9wcmludF9zcGFjZSBmbXQgKCk7XG4gIHBwMyBmbXQgdjNcbjs7XG5cbmxldCBvcHQgZiBmbXQgeCA9XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gcHBfcHJpbnRfc3RyaW5nIGZtdCBcIjxOb25lPlwiXG4gIHwgU29tZSB4IC0+IGZwcmludGYgZm10IFwiJWFcIiBmIHhcbjs7XG5cbmxldCBpbnQgPSBwcF9wcmludF9pbnRcblxubGV0IG9wdGludCBmbXQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGkgLT4gZnByaW50ZiBmbXQgXCJAICVkXCIgaVxuOztcblxubGV0IHF1b3RlIGZtdCBzID0gRm9ybWF0LmZwcmludGYgZm10IFwiXFxcIiVzXFxcIlwiIHNcblxubGV0IHBwX29saXN0IHBwX2VsZW0gZm10ID1cbiAgRm9ybWF0LmZwcmludGZcbiAgICBmbXRcbiAgICBcIkBbPDM+W0AgJWFAIF1AXVwiXG4gICAgKHBwX3ByaW50X2xpc3QgfnBwX3NlcDooZnVuIGZtdCAoKSAtPiBmcHJpbnRmIGZtdCBcIjtAIFwiKSBwcF9lbGVtKVxuOztcblxubGV0IGNoYXIgZm10IGMgPSBGb3JtYXQuZnByaW50ZiBmbXQgXCIlY1wiIGNcbmxldCBib29sID0gRm9ybWF0LnBwX3ByaW50X2Jvb2xcbmxldCBwcF9zdHJfbGlzdCA9IHBwX29saXN0IHF1b3RlXG5sZXQgbGl0IHMgZm10ICgpID0gcHBfcHJpbnRfc3RyaW5nIGZtdCBzXG5cbmxldCB0b190b19zdHJpbmcgcHAgeCA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgZm10ID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBwcCBmbXQgeDtcbiAgQnVmZmVyLmNvbnRlbnRzIGJcbjs7XG5cbmxldCBxdW90ZWRfc3RyaW5nIGZtdCBzID0gRm9ybWF0LmZwcmludGYgZm10IFwiJVNcIiBzXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJjYW1sX2NhbGw2IiwiYTQiLCJhNSIsImdsb2JhbF9kYXRhIiwiUmVfRm10IiwiU3RkbGliX0Zvcm1hdCIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYiIsIlN0ZGxpYl9DaGFyIiwiY3N0X0JpdF92ZWN0b3Jfc2V0IiwiY3N0X0JpdF92ZWN0b3JfZ2V0IiwiY3N0X2xlbiIsImNzdF9iaXRzIiwibGVuZ3RoIiwidCIsInNldCIsInYiLCJuIiwiYiIsImkiLCJzIiwiYyIsIm1hc2siLCJ4IiwiZ2V0IiwicmVzZXRfemVybyIsImNyZWF0ZV96ZXJvIiwibGVuIiwiciIsInEiLCJiaXRzIiwicHAiLCJmbXQiLCJwYXJhbSIsIlJlX0JpdF92ZWN0b3IiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvYml0X3ZlY3Rvci5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFQLEdBQUFDLElBQUFFLElBQUFFLElBQUFDLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQTtBQUFBLFlBQUFDLE9BQUFDLEdDT2UsWUFBSztBQUFBLFlBQUFDLElBQUFDLEdBQUFDLEdBQUFDO0FBQUFBLFFBQUEsTUFVbEI7QUFBQSxZQUE0QjtBQUFBO0FBQUEsS0FBQUMsSUFQNUI7QUFBQSxLQUFBQyxJQUNBO0FBQUEsS0FBQUMsSUFOYTtBQUFBLEtBQUFDLE9BT2I7QUFBQSxLQUFBQyxJQUNBLG1CQUFvRDtBQUFBLEtBQUFILE1BQXBEO0FBQUEsSUFQb0Qsc0NBQVo7QUFBQSxJQUFZO0FBQUEsR0FZcEM7QUFBQSxZQUFBSSxJQUFBUixHQUFBQztBQUFBQSxRQUFBLE1BU2hCO0FBQUEsWUFBNEI7QUFBQSxRQUFBRSxJQUw1QixhQUFBQyxJQUNBO0FBQUEsSUFsQmEsK0RBa0JBO0FBQUEsR0FLQztBQUFBLFlBQUFLLFdBQUFYO0FBQUFBLElBR0c7QUFBQSw4RUFBZ0Q7QUFBQTtBQUFBLFlBQUFZLFlBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLElBR2pFO0FBQUEsS0FBQUMsSUFFRTtBQUFBLEtBQUFGLFFBQ0E7QUFBQSxLQUFBRyxPQUNBO0FBQUEsSUFFRjtBQUFBLEdBQWE7QUFBQSxZQUFBQyxHQUFBQyxLQUFBQztBQUFBQSxRQUFBSCxPQUdSLFVBQUFILE1BQUE7QUFBQSxhQUFBQSxNQUFBSyxLQUFBQztBQUFBQSxLQUNZLDBEQUE4QjtBQUFBO0FBQUEsYUFBQUgsT0FBQUUsS0FBQUM7QUFBQUEsS0FDN0IsNkRBQWtDO0FBQUE7QUFBQSxJQUNwRCxvRUFBNEM7QUFBQTtBQUFBLE9BQUFDLGdCRDlDOUMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsInR5cGUgdCA9XG4gIHsgbGVuIDogaW50XG4gIDsgYml0cyA6IEJ5dGVzLnRcbiAgfVxuXG5sZXQgYnl0ZSBzIGkgPSBDaGFyLmNvZGUgKEJ5dGVzLnVuc2FmZV9nZXQgcyBpKVxubGV0IHNldF9ieXRlIHMgaSB4ID0gQnl0ZXMudW5zYWZlX3NldCBzIGkgKENoYXIuY2hyIHgpXG5sZXQgbGVuZ3RoIHQgPSB0LmxlblxuXG5sZXQgdW5zYWZlX3NldCB2IG4gYiA9XG4gIGxldCBpID0gbiBsc3IgMyBpblxuICBsZXQgYyA9IGJ5dGUgdi5iaXRzIGkgaW5cbiAgbGV0IG1hc2sgPSAxIGxzbCAobiBsYW5kIDcpIGluXG4gIHNldF9ieXRlIHYuYml0cyBpIChpZiBiIHRoZW4gYyBsb3IgbWFzayBlbHNlIGMgbGFuZCBsbm90IG1hc2spXG47O1xuXG5sZXQgc2V0IHYgbiBiID1cbiAgaWYgbiA8IDAgfHwgbiA+PSB2LmxlbiB0aGVuIGludmFsaWRfYXJnIFwiQml0X3ZlY3Rvci5zZXRcIjtcbiAgdW5zYWZlX3NldCB2IG4gYlxuOztcblxubGV0IHVuc2FmZV9nZXQgdiBuID1cbiAgbGV0IGkgPSBuIGxzciAzIGluXG4gIGJ5dGUgdi5iaXRzIGkgbGFuZCAoMSBsc2wgKG4gbGFuZCA3KSkgPiAwXG47O1xuXG5sZXQgZ2V0IHYgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPj0gdi5sZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkJpdF92ZWN0b3IuZ2V0XCI7XG4gIHVuc2FmZV9nZXQgdiBuXG47O1xuXG5sZXQgcmVzZXRfemVybyB0ID0gQnl0ZXMuZmlsbCB0LmJpdHMgMCAoQnl0ZXMubGVuZ3RoIHQuYml0cykgJ1xcMDAwJ1xuXG5sZXQgY3JlYXRlX3plcm8gbGVuID1cbiAgbGV0IGJpdHMgPVxuICAgIGxldCByID0gbGVuIGxhbmQgNyBpblxuICAgIGxldCBxID0gbGVuIGxzciAzIGluXG4gICAgbGV0IGxlbiA9IGlmIHIgPSAwIHRoZW4gcSBlbHNlIHEgKyAxIGluXG4gICAgQnl0ZXMubWFrZSBsZW4gJ1xcMDAwJ1xuICBpblxuICB7IGxlbjsgYml0cyB9XG47O1xuXG5sZXQgcHAgZm10IHsgbGVuOyBiaXRzIH0gPVxuICBsZXQgbGVuIGZtdCAoKSA9IEZtdC5zZXhwIGZtdCBcImxlblwiIEZtdC5pbnQgbGVuIGluXG4gIGxldCBiaXRzIGZtdCAoKSA9IEZtdC5zZXhwIGZtdCBcImJpdHNcIiBGbXQuYnl0ZXMgYml0cyBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlYUAuJWFALlwiIGxlbiAoKSBiaXRzICgpXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRm9ybWF0IiwiZXF1YWwiLCJ4IiwieSIsImNvbXBhcmUiLCJ0b19pbnQiLCJwcCIsImludGVyc2VjdCIsInN5bWJvbCIsImxldHRlciIsIm5vdF9sZXR0ZXIiLCJmcm9tX2NoYXIiLCJwYXJhbSIsIlJlX0NhdGVnb3J5Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL2NhdGVnb3J5Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLE1BQUFDLEdBQUFDLEdDRWdDLHVCQUFLO0FBQUEsT0FBQUMsVURGckM7QUFBQSxZQUFBQyxPQUFBSCxHQ0llLFNBQUM7QUFBQSxPQUFBSSxLREpoQjtBQUFBLFlBQUFDLFVBQUFMLEdBQUFDLEdDTW9CLDZCQUFhO0FBQUEsWUFBQUssT0FBQU4sR0FBQUMsR0FDaEIsYUFBTztBQUFBLE9BQUFNLFNEUHhCLEdBQUFDLGFBQUE7QUFBQSxZQUFBQyxVQUFBQztBQUFBQTtBQUFBQTtBQUFBQSxLQ2dCZ0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDRCQVRDO0FBQUEsS0FtQlI7QUFBQTtBQUFBLElBRmU7QUFBQSxHQUVMO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRDFCbkIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsInR5cGUgdCA9IGludFxuXG5sZXQgZXF1YWwgKHggOiBpbnQpICh5IDogaW50KSA9IHggPSB5XG5sZXQgY29tcGFyZSAoeCA6IGludCkgKHkgOiBpbnQpID0gY29tcGFyZSB4IHlcbmxldCB0b19pbnQgeCA9IHhcbmxldCBwcCA9IEZvcm1hdC5wcF9wcmludF9pbnRcbmxldCBpbnRlcnNlY3QgeCB5ID0geCBsYW5kIHkgPD4gMFxubGV0ICggKysgKSB4IHkgPSB4IGxvciB5XG5sZXQgZHVtbXkgPSAtMVxubGV0IGluZXhpc3RhbnQgPSAxXG5sZXQgbGV0dGVyID0gMlxubGV0IG5vdF9sZXR0ZXIgPSA0XG5sZXQgbmV3bGluZSA9IDhcbmxldCBsYXN0bmV3bGluZSA9IDE2XG5sZXQgc2VhcmNoX2JvdW5kYXJ5ID0gMzJcblxubGV0IGZyb21fY2hhciA9IGZ1bmN0aW9uXG4gICgqIFNob3VsZCBtYXRjaCBbY3dvcmRdIGRlZmluaXRpb24gKilcbiAgfCAnYScgLi4gJ3onXG4gIHwgJ0EnIC4uICdaJ1xuICB8ICcwJyAuLiAnOSdcbiAgfCAnXycgfCAnXFwxNzAnIHwgJ1xcMTgxJyB8ICdcXDE4NidcbiAgfCAnXFwxOTInIC4uICdcXDIxNCdcbiAgfCAnXFwyMTYnIC4uICdcXDI0NidcbiAgfCAnXFwyNDgnIC4uICdcXDI1NScgLT4gbGV0dGVyXG4gIHwgJ1xcbicgLT4gbm90X2xldHRlciArKyBuZXdsaW5lXG4gIHwgXyAtPiBub3RfbGV0dGVyXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwic3ltYm9sIiwiU3RkbGliIiwiU3RkbGliX0ludCIsIlN0ZGxpYl9PcHRpb24iLCJlcXVhbCIsImNvbXBhcmUiLCJQb2x5IiwiUGh5c19lcXVhbCIsIngiLCJ5IiwibWluIiwibWF4Iiwibm9uZSIsInNvbWUiLCJ2YWx1ZSIsImdldCIsImJpbmQiLCJqb2luIiwibWFwIiwiZm9sZCIsIml0ZXIiLCJpc19ub25lIiwiaXNfc29tZSIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJjc3RfT3B0aW9uX1VuYm94ZWRfdmFsdWVfZXhuX2MiLCJ0IiwidmFsdWVfZXhuIiwidG9fb3B0aW9uIiwiVW5ib3hlZCIsIk9wdGlvbiIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJhYnMiLCJtYXhfaW50IiwibWluX2ludCIsImxvZ25vdCIsInRvX3N0cmluZyIsInNlZWRlZF9oYXNoIiwiaGFzaCIsIkludCIsIlJlX0ltcG9ydCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9yZS9pbXBvcnQubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxZQUFBRixRQUFBO0FBQUEsT0FBQUcsYUFBQSxjQUFBUCxTQUFBO0FBQUEsWUFBQUEsU0FBQVEsR0FBQUM7QUFBQUEsSUNhZ0IsT0FBZSxtQkFBZixvQ0FBb0I7QUFBQTtBQUFBLFlBQUFULFNBQUFRLEdBQUFDO0FBQUFBLElBQ3BCLE9BQWUsbUJBQWYsbUNBQW1CO0FBQUE7QUFBQTtBQUFBLElBQUFDLE1EZG5DO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFOLFlBQUE7QUFBQSxJQUFBTyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFsQixVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFrQixZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxZQUFBWixPQUFBTCxHQ21DaUIsU0FBVTtBQUFBO0FBQUEsSUFBQWtCLGlDRG5DM0I7QUFBQSxZQUFBTCxVQUFBTSxHQ3NDb0Isd0JBQWlCO0FBQUEsWUFBQUwsVUFBQUssR0FDTTtBQUFBLFlBQUFDLFVBQUFEO0FBQUFBLElBR3pCLGFBQU07QUFBQSxJQUNsQjtBQUFBLEdBQVM7QUFBQSxZQUFBRSxVQUFBRixHQUdtQiwwQkFBcUIsYUFBYTtBQUFBLFlBQUFQLE9BQUFPLEdBQUFoQyxHQUNwQyxzQkFBNkIsY0FBYixhQUFhO0FBQUE7QUFBQSxJQUFBbUM7QUFBQUEsTUQvQzdEO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQWxDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUssUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBNEIsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgTGlzdCA9IFN0ZGxpYi5MaXN0TGFiZWxzXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIGxldCBlcXVhbCA9ICggPSApXG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuZW5kXG5cbm1vZHVsZSBQaHlzX2VxdWFsID0gc3RydWN0XG4gIGxldCBlcXVhbCA9ICggPT0gKVxuZW5kXG5cbmxldCAoID0gKSA9IEludC5lcXVhbFxubGV0ICggPT0gKSA9IFsgYFVzZV9waHlzX2VxdWFsIF1cbmxldCAoIDwgKSB4IHkgPSBJbnQuY29tcGFyZSB4IHkgPSAtMVxubGV0ICggPiApIHggeSA9IEludC5jb21wYXJlIHggeSA9IDFcbmxldCBtaW4gPSBJbnQubWluXG5sZXQgbWF4ID0gSW50Lm1heFxubGV0IGNvbXBhcmUgPSBJbnQuY29tcGFyZVxuXG5tb2R1bGUgT3B0aW9uID0gc3RydWN0XG4gIGluY2x1ZGUgT3B0aW9uXG5cbiAgbW9kdWxlIFVuYm94ZWQgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBub25lIDogJ2EgdFxuICAgIHZhbCBzb21lIDogJ2EgLT4gJ2EgdFxuICAgIHZhbCBpc19ub25lIDogJ2EgdCAtPiBib29sXG4gICAgdmFsIGlzX3NvbWUgOiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgdmFsdWVfZXhuIDogJ2EgdCAtPiAnYVxuICAgIHZhbCB0b19vcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9IE9iai50XG5cbiAgICBsZXQgc29tZSB4ID0gT2JqLnJlcHIgeFxuICAgIGxldCBub25lID0gT2JqLnJlcHIgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKC0xKSlcbiAgICBsZXQgcGh5c19lcXVhbCA9IFN0ZGxpYi4oID09IClcbiAgICBsZXQgaXNfbm9uZSB0ID0gcGh5c19lcXVhbCB0IG5vbmVcbiAgICBsZXQgaXNfc29tZSB0ID0gbm90IChwaHlzX2VxdWFsIHQgbm9uZSlcblxuICAgIGxldCB2YWx1ZV9leG4gdCA9XG4gICAgICBpZiBpc19ub25lIHQgdGhlbiBpbnZhbGlkX2FyZyBcIk9wdGlvbi5VbmJveGVkLnZhbHVlX2V4biBjYWxsZWQgb24gTm9uZVwiO1xuICAgICAgT2JqLm9iaiB0XG4gICAgOztcblxuICAgIGxldCB0b19vcHRpb24gdCA9IGlmIGlzX25vbmUgdCB0aGVuIE5vbmUgZWxzZSBTb21lICh2YWx1ZV9leG4gdClcbiAgICBsZXQgaXRlciB0IH5mID0gaWYgaXNfbm9uZSB0IHRoZW4gKCkgZWxzZSBmICh2YWx1ZV9leG4gdClcbiAgZW5kXG5lbmRcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICBsZXRbQHdhcm5pbmcgXCItMzJcIl0gaGFzaCAoeCA6IGludCkgPSBIYXNodGJsLmhhc2ggeFxuXG4gIGluY2x1ZGUgU3RkbGliLkludFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJjYW55IiwiY3N0IiwiUmVfSW1wb3J0IiwiU3RkbGliIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfTGlzdExhYmVscyIsIlN0ZGxpYl9Gb3JtYXQiLCJTdGRsaWJfQ2hhciIsIlJlX0ZtdCIsIlN0ZGxpYl9NYXAiLCJlcXVhbF9jIiwidG9faW50IiwieCIsIm9mX2ludCIsInRvX2NoYXIiLCJ0Iiwib2ZfY2hhciIsImMiLCJjb21wYXJlX3BhaXIiLCJwYXJhbSIsInkiLCJlcXVhbF9wYWlyIiwiZXF1YWwiLCJjb21wYXJlIiwidW5pb24iLCJsIiwiciIsImMyIiwiYzEiLCJtYXRjaCIsImludGVyIiwiZGlmZiIsInNpbmdsZSIsImFkZCIsIm9mZnNldCIsIm8iLCJlbXB0eSIsInVuaW9uX2FsbCIsImludGVyc2VjdF9hbGwiLCJtZW0iLCJzIiwicmVtIiwiaGFzaF9yZWMiLCJqIiwiaSIsImhhc2giLCJwcmludF9vbmUiLCJjaCIsInBwIiwiaXRlciIsInhzIiwib25lX2NoYXIiLCJ2IiwidSIsIkNTZXRNYXAiLCJjc3RfUmVfY3NldF9waWNrIiwiZm9sZF9yaWdodCIsImluaXQiLCJhY2MiLCJjc2luZ2xlIiwiaXNfZW1wdHkiLCJwcmVwZW5kIiwiZCIsInBpY2siLCJjc2VxIiwidXBwZXIiLCJjbG93ZXIiLCJjZGlnaXQiLCJhc2NpaSIsImNhZGQiLCJzcGFjZSIsInhkaWdpdCIsImNhbHBoYSIsImNhbG51bSIsImNhc2VfaW5zZW5zIiwiY3dvcmQiLCJub3RubCIsIm5sIiwic2V0Iiwic3RyIiwiYmxhbmsiLCJsb3dlciIsImFscGhhIiwiYWxudW0iLCJ3b3JkYyIsImNudHJsIiwiZ3JhcGgiLCJwcmludCIsInB1bmN0IiwiUmVfQ3NldCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9yZS9jc2V0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7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REE7QUFBQSxVQURBO0FBQUEsVUFEQTtBQUFBLFVBREE7QUFBQSxVQURBO0FBQUEsVUFEQTtBQUFBLElBQUFDLFFBRkosMEJBQ0k7QUFBQSxJQUFBQztBQUFBQSxNQVVEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDdPTCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIExpc3QgPSBzdHJ1Y3QgZW5kXG5vcGVuIEltcG9ydFxuXG4oKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG50eXBlIGMgPSBpbnRcblxubGV0IGVxdWFsX2MgPSBJbnQuZXF1YWxcbmxldCB0b19pbnQgeCA9IHhcbmxldCBvZl9pbnQgeCA9IHhcbmxldCB0b19jaGFyIHQgPSBDaGFyLmNociB0XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCBudWxsX2NoYXIgPSAtMVxuXG50eXBlIHQgPSAoYyAqIGMpIGxpc3RcblxubGV0IGNvbXBhcmVfcGFpciAoeCwgeSkgKHgnLCB5JykgPVxuICBtYXRjaCBJbnQuY29tcGFyZSB4IHgnIHdpdGhcbiAgfCAwIC0+IEludC5jb21wYXJlIHkgeSdcbiAgfCB4IC0+IHhcbjs7XG5cbmxldCBlcXVhbF9wYWlyICh4LCB5KSAoeCcsIHknKSA9IEludC5lcXVhbCB4IHgnICYmIEludC5lcXVhbCB5IHknXG5sZXQgZXF1YWwgPSBMaXN0LmVxdWFsIH5lcTplcXVhbF9wYWlyXG5sZXQgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQgPSBMaXN0LmNvbXBhcmUgfmNtcDpjb21wYXJlX3BhaXJcblxubGV0IHJlYyB1bmlvbiBsIGwnID1cbiAgbWF0Y2ggbCwgbCcgd2l0aFxuICB8IF8sIFtdIC0+IGxcbiAgfCBbXSwgXyAtPiBsJ1xuICB8IChjMSwgYzIpIDo6IHIsIChjMScsIGMyJykgOjogcicgLT5cbiAgICBpZiBjMiArIDEgPCBjMSdcbiAgICB0aGVuIChjMSwgYzIpIDo6IHVuaW9uIHIgbCdcbiAgICBlbHNlIGlmIGMyJyArIDEgPCBjMVxuICAgIHRoZW4gKGMxJywgYzInKSA6OiB1bmlvbiBsIHInXG4gICAgZWxzZSBpZiBjMiA8IGMyJ1xuICAgIHRoZW4gdW5pb24gciAoKG1pbiBjMSBjMScsIGMyJykgOjogcicpXG4gICAgZWxzZSB1bmlvbiAoKG1pbiBjMSBjMScsIGMyKSA6OiByKSByJ1xuOztcblxubGV0IHJlYyBpbnRlciBsIGwnID1cbiAgbWF0Y2ggbCwgbCcgd2l0aFxuICB8IF8sIFtdIC0+IFtdXG4gIHwgW10sIF8gLT4gW11cbiAgfCAoYzEsIGMyKSA6OiByLCAoYzEnLCBjMicpIDo6IHInIC0+XG4gICAgaWYgYzIgPCBjMSdcbiAgICB0aGVuIGludGVyIHIgbCdcbiAgICBlbHNlIGlmIGMyJyA8IGMxXG4gICAgdGhlbiBpbnRlciBsIHInXG4gICAgZWxzZSBpZiBjMiA8IGMyJ1xuICAgIHRoZW4gKG1heCBjMSBjMScsIGMyKSA6OiBpbnRlciByIGwnXG4gICAgZWxzZSAobWF4IGMxIGMxJywgYzInKSA6OiBpbnRlciBsIHInXG47O1xuXG5sZXQgcmVjIGRpZmYgbCBsJyA9XG4gIG1hdGNoIGwsIGwnIHdpdGhcbiAgfCBfLCBbXSAtPiBsXG4gIHwgW10sIF8gLT4gW11cbiAgfCAoYzEsIGMyKSA6OiByLCAoYzEnLCBjMicpIDo6IHInIC0+XG4gICAgaWYgYzIgPCBjMSdcbiAgICB0aGVuIChjMSwgYzIpIDo6IGRpZmYgciBsJ1xuICAgIGVsc2UgaWYgYzInIDwgYzFcbiAgICB0aGVuIGRpZmYgbCByJ1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHInJyA9IGlmIGMyJyA8IGMyIHRoZW4gKGMyJyArIDEsIGMyKSA6OiByIGVsc2UgciBpblxuICAgICAgaWYgYzEgPCBjMScgdGhlbiAoYzEsIGMxJyAtIDEpIDo6IGRpZmYgcicnIHInIGVsc2UgZGlmZiByJycgcicpXG47O1xuXG5sZXQgc2luZ2xlIGMgPSBbIGMsIGMgXVxubGV0IGFkZCBjIGwgPSB1bmlvbiAoc2luZ2xlIGMpIGxcbmxldCBzZXEgYyBjJyA9IGlmIGMgPD0gYycgdGhlbiBbIGMsIGMnIF0gZWxzZSBbIGMnLCBjIF1cblxubGV0IHJlYyBvZmZzZXQgbyBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCAoYzEsIGMyKSA6OiByIC0+IChjMSArIG8sIGMyICsgbykgOjogb2Zmc2V0IG8gclxuOztcblxubGV0IGVtcHR5ID0gW11cbmxldCBjYW55ID0gWyAwLCAyNTUgXVxubGV0IHVuaW9uX2FsbCA6IHQgbGlzdCAtPiB0ID0gTGlzdC5mb2xkX2xlZnQgfmluaXQ6ZW1wdHkgfmY6dW5pb25cbmxldCBpbnRlcnNlY3RfYWxsIDogdCBsaXN0IC0+IHQgPSBMaXN0LmZvbGRfbGVmdCB+aW5pdDpjYW55IH5mOmludGVyXG5cbmxldCByZWMgbWVtIChjIDogaW50KSBzID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYzEsIGMyKSA6OiByZW0gLT4gaWYgYyA8PSBjMiB0aGVuIGMgPj0gYzEgZWxzZSBtZW0gYyByZW1cbjs7XG5cbigqKioqKVxuXG5sZXQgcmVjIGhhc2hfcmVjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAwXG4gIHwgKGksIGopIDo6IHIgLT4gaSArICgxMyAqIGopICsgKDI1NyAqIGhhc2hfcmVjIHIpXG47O1xuXG5sZXQgaGFzaCBsID0gaGFzaF9yZWMgbCBsYW5kIDB4M0ZGRkZGRkZcblxuKCoqKiopXG5cbmxldCBwcmludF9vbmUgY2ggKGMxLCBjMikgPVxuICBpZiBJbnQuZXF1YWwgYzEgYzIgdGhlbiBGb3JtYXQuZnByaW50ZiBjaCBcIiVkXCIgYzEgZWxzZSBGb3JtYXQuZnByaW50ZiBjaCBcIiVkLSVkXCIgYzEgYzJcbjs7XG5cbmxldCBwcCA9IEZtdC5saXN0IH5wcF9zZXA6KEZtdC5saXQgXCIsIFwiKSBwcmludF9vbmVcblxubGV0IHJlYyBpdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8ICh4LCB5KSA6OiB4cyAtPlxuICAgIGYgeCB5O1xuICAgIGl0ZXIgeHMgfmZcbjs7XG5cbmxldCBvbmVfY2hhciA9IGZ1bmN0aW9uXG4gIHwgWyAoaSwgaikgXSB3aGVuIEludC5lcXVhbCBpIGogLT4gU29tZSBpXG4gIHwgXyAtPiBOb25lXG47O1xuXG5tb2R1bGUgQ1NldE1hcCA9IE1hcC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQgKiAoaW50ICogaW50KSBsaXN0XG5cbiAgICBsZXQgY29tcGFyZSAoaSwgdSkgKGosIHYpID1cbiAgICAgIGxldCBjID0gSW50LmNvbXBhcmUgaSBqIGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSB1IHZcbiAgICA7O1xuICBlbmQpXG5cbmxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBMaXN0LmZvbGRfcmlnaHQgfmY6KGZ1biAoeCwgeSkgYWNjIC0+IGYgeCB5IGFjYykgdCB+aW5pdFxubGV0IGNzaW5nbGUgYyA9IHNpbmdsZSAoQ2hhci5jb2RlIGMpXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCByZWMgcHJlcGVuZCBzIHggbCA9XG4gIG1hdGNoIHMsIGwgd2l0aFxuICB8IFtdLCBfIC0+IGxcbiAgfCBfciwgW10gLT4gW11cbiAgfCAoX2MsIGMnKSA6OiByLCAoWyAoZCwgX2QnKSBdLCBfeCcpIDo6IF9yJyB3aGVuIGMnIDwgZCAtPiBwcmVwZW5kIHIgeCBsXG4gIHwgKGMsIGMnKSA6OiByLCAoWyAoZCwgZCcpIF0sIHgnKSA6OiByJyAtPlxuICAgIGlmIGMgPD0gZFxuICAgIHRoZW5cbiAgICAgIGlmIGMnIDwgZCdcbiAgICAgIHRoZW4gKFsgZCwgYycgXSwgeCBAIHgnKSA6OiBwcmVwZW5kIHIgeCAoKFsgYycgKyAxLCBkJyBdLCB4JykgOjogcicpXG4gICAgICBlbHNlIChbIGQsIGQnIF0sIHggQCB4JykgOjogcHJlcGVuZCBzIHggcidcbiAgICBlbHNlIGlmIGMgPiBkJ1xuICAgIHRoZW4gKFsgZCwgZCcgXSwgeCcpIDo6IHByZXBlbmQgcyB4IHInXG4gICAgZWxzZSAoWyBkLCBjIC0gMSBdLCB4JykgOjogcHJlcGVuZCBzIHggKChbIGMsIGQnIF0sIHgnKSA6OiByJylcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxubGV0IHBpY2sgPSBmdW5jdGlvblxuICB8IFtdIC0+IGludmFsaWRfYXJnIFwiUmVfY3NldC5waWNrXCJcbiAgfCAoeCwgXykgOjogXyAtPiB4XG47O1xuXG5sZXQgY3NlcSBjIGMnID0gc2VxIChvZl9jaGFyIGMpIChvZl9jaGFyIGMnKVxubGV0IHJnID0gY3NlcVxubGV0IGNoYXIgPSBjc2luZ2xlXG5sZXQgdXBwZXIgPSB1bmlvbl9hbGwgWyBjc2VxICdBJyAnWic7IGNzZXEgJ1xcMTkyJyAnXFwyMTQnOyBjc2VxICdcXDIxNicgJ1xcMjIyJyBdXG5sZXQgY2xvd2VyID0gb2Zmc2V0IDMyIHVwcGVyXG5sZXQgY2RpZ2l0ID0gY3NlcSAnMCcgJzknXG5sZXQgYXNjaWkgPSBjc2VxICdcXDAwMCcgJ1xcMTI3J1xubGV0IGNhZGQgYyBzID0gYWRkIChvZl9jaGFyIGMpIHNcbmxldCBzcGFjZSA9IGFkZCAob2ZfY2hhciAnICcpIChjc2VxICdcXDAwOScgJ1xcMDEzJylcbmxldCB4ZGlnaXQgPSB1bmlvbl9hbGwgWyBjZGlnaXQ7IGNzZXEgJ2EnICdmJzsgY3NlcSAnQScgJ0YnIF1cblxubGV0IGNhbHBoYSA9XG4gIExpc3QuZm9sZF9yaWdodFxuICAgIH5mOmNhZGRcbiAgICBbICdcXDE3MCc7ICdcXDE4MSc7ICdcXDE4Nic7ICdcXDIyMyc7ICdcXDI1NScgXVxuICAgIH5pbml0Oih1bmlvbiBjbG93ZXIgdXBwZXIpXG47O1xuXG5sZXQgY2FsbnVtID0gdW5pb24gY2FscGhhIGNkaWdpdFxuXG5sZXQgY2FzZV9pbnNlbnMgcyA9XG4gIHVuaW9uX2FsbCBbIHM7IG9mZnNldCAzMiAoaW50ZXIgcyB1cHBlcik7IG9mZnNldCAoLTMyKSAoaW50ZXIgcyBjbG93ZXIpIF1cbjs7XG5cbmxldCBjd29yZCA9IGNhZGQgJ18nIGNhbG51bVxubGV0IG5vdG5sID0gZGlmZiBjYW55IChjc2luZ2xlICdcXG4nKVxubGV0IG5sID0gY3NpbmdsZSAnXFxuJ1xuXG5sZXQgc2V0IHN0ciA9XG4gIGxldCBzID0gcmVmIGVtcHR5IGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBzIDo9IHVuaW9uIChjc2luZ2xlIHN0ci5baV0pICFzXG4gIGRvbmU7XG4gICFzXG47O1xuXG5sZXQgYmxhbmsgPSBzZXQgXCJcXHQgXCJcblxuKCogQ1Itc29tZWRheSByZ3JpbmJlcmc6IHRoaXMgW2xvd2VyXSBkb2Vzbid0IG1hdGNoIFtjbG93ZXJdICopXG5sZXQgbG93ZXIgPSB1bmlvbl9hbGwgWyByZyAnYScgJ3onOyBjaGFyICdcXDE4MSc7IHJnICdcXDIyMycgJ1xcMjQ2JzsgcmcgJ1xcMjQ4JyAnXFwyNTUnIF1cbmxldCBhbHBoYSA9IHVuaW9uX2FsbCBbIGxvd2VyOyB1cHBlcjsgY2hhciAnXFwxNzAnOyBjaGFyICdcXDE4NicgXVxubGV0IGFsbnVtID0gdW5pb25fYWxsIFsgYWxwaGE7IGNkaWdpdCBdXG5sZXQgd29yZGMgPSB1bmlvbl9hbGwgWyBhbG51bTsgY2hhciAnXycgXVxubGV0IGNudHJsID0gdW5pb25fYWxsIFsgcmcgJ1xcMDAwJyAnXFwwMzEnOyByZyAnXFwxMjcnICdcXDE1OScgXVxubGV0IGdyYXBoID0gdW5pb25fYWxsIFsgcmcgJ1xcMDMzJyAnXFwxMjYnOyByZyAnXFwxNjAnICdcXDI1NScgXVxubGV0IHByaW50ID0gdW5pb25fYWxsIFsgcmcgJ1xcMDMyJyAnXFwxMjYnOyByZyAnXFwxNjAnICdcXDI1NScgXVxuXG5sZXQgcHVuY3QgPVxuICB1bmlvbl9hbGxcbiAgICBbIHJnICdcXDAzMycgJ1xcMDQ3J1xuICAgIDsgcmcgJ1xcMDU4JyAnXFwwNjQnXG4gICAgOyByZyAnXFwwOTEnICdcXDA5NidcbiAgICA7IHJnICdcXDEyMycgJ1xcMTI2J1xuICAgIDsgcmcgJ1xcMTYwJyAnXFwxNjknXG4gICAgOyByZyAnXFwxNzEnICdcXDE4MCdcbiAgICA7IHJnICdcXDE4MicgJ1xcMTg1J1xuICAgIDsgcmcgJ1xcMTg3JyAnXFwxOTEnXG4gICAgOyBjaGFyICdcXDIxNSdcbiAgICA7IGNoYXIgJ1xcMjQ3J1xuICAgIF1cbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6ODc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw2IiwiYTQiLCJhNSIsImdsb2JhbF9kYXRhIiwiUmVfRm10IiwiUmVfSW1wb3J0IiwiU3RkbGliX0xpc3RMYWJlbHMiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX0J5dGVzIiwiQXNzZXJ0X2ZhaWx1cmUiLCJsZW5ndGgiLCJ0IiwidW5zYWZlX2dldCIsImkiLCJ1bnNhZmVfc2V0IiwieCIsIm1ha2VfYWJzZW50IiwibGVuIiwiaW5pdCIsImFic2VudCIsImNzdF9zaXplIiwiY3N0X3RhYmxlIiwiY3JlYXRlIiwicGFyYW0iLCJpbmRleF9vZl9vZmZzZXQiLCJzbG90cyIsImluZGV4IiwiY2xlYXIiLCJtYXRjaCIsImhhc2giLCJpbnNlcnRpbmciLCJpZHgiLCJlbGVtIiwiYWRkIiwib2xkX3RhYmxlIiwidGFibGUiLCJpc19lbXB0eSIsIm1lbSIsImZvdW5kIiwicHAiLCJmbXQiLCJzaXplIiwiYWNjIiwiUmVfSGFzaF9zZXQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvaGFzaF9zZXQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLFlBQUFDLE9BQUFDLEdDTTBCLHVDQUFzQjtBQUFBLFlBQUFDLFdBQUFELEdBQUFFO0FBQUFBLElBQ0gsT0FBa0M7QUFBQSxhQUFsQywyQ0FBa0M7QUFBQTtBQUFBLFlBQUFDLFdBQUFILEdBQUFFLEdBQUFFO0FBQUFBLElBQ1osT0FBZ0I7QUFBQSw2Q0FBaEIsK0JBQWdCO0FB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QUEsYUEySGlCO0FBQUEsTUEzSGpCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0EySGxDO0FBQUEsS0FBQVAsVUFBQTtBQUFBLGFBQUFBLFFBQUFLLEtBQUFqQjtBQUFBQSxTQUFBLE1BSTJDO0FBQUEsS0FBUywwREFBTztBQUFBO0FBQUEsYUFBQWtCLE9BQUFELEtBQUFqQjtBQUFBQSxLQUMzQyw0REFBZ0M7QUFBQTtBQUFBLElBQ2xELHNFQUE4QztBQUFBO0FBQUEsT0FBQW9CLGNBOUZSO0FBQUE7QUFBQTtBQUFBLEVEM0R4QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBJbXBvcnRcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSBCeXRlcy50XG5cbiAgbGV0IHdvcmRzID0gOFxuICBsZXRbQGlubGluZV0gbGVuZ3RoIHQgPSBCeXRlcy5sZW5ndGggdCAvIHdvcmRzXG4gIGxldFtAaW5saW5lXSB1bnNhZmVfZ2V0IHQgaSA9IEludDY0LnRvX2ludCAoQnl0ZXMuZ2V0X2ludDY0X25lIHQgKGkgKiB3b3JkcykpXG4gIGxldFtAaW5saW5lXSB1bnNhZmVfc2V0IHQgaSB4ID0gQnl0ZXMuc2V0X2ludDY0X25lIHQgKGkgKiB3b3JkcykgKEludDY0Lm9mX2ludCB4KVxuXG4gIGxldFtAaW5saW5lXSBtYWtlIGxlbiB4ID1cbiAgICBsZXQgdCA9IEJ5dGVzLmNyZWF0ZSAobGVuICogd29yZHMpIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCB0IGkgeFxuICAgIGRvbmU7XG4gICAgdFxuICA7O1xuXG4gIGxldFtAaW5saW5lXSBtYWtlX2Fic2VudCBsZW4gPSBCeXRlcy5tYWtlIChsZW4gKiB3b3JkcykgJ1xcMjU1J1xuICBsZXQgY2xlYXIgdCA9IEJ5dGVzLmZpbGwgdCAwIChCeXRlcy5sZW5ndGggdCkgJ1xcMjU1J1xuXG4gIGxldCBmb2xkX2xlZnQgdCB+aW5pdCB+ZiA9XG4gICAgbGV0IGluaXQgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICAgIGluaXQgOj0gZiAhaW5pdCAodW5zYWZlX2dldCB0IGkpXG4gICAgZG9uZTtcbiAgICAhaW5pdFxuICA7O1xuZW5kXG5cbigqIEEgc3BlY2lhbGl6ZWQgaGFzaCB0YWJsZSB0aGF0IG1ha2VzIHRoZSBmb2xsb3dpbmcgdHJhZGUtb2ZmczpcbiAgIC0gT3BlbiBhZGRyZXNpbmcuIEJ1Y2tldGluZyBpcyBxdWl0ZSBtZW1vcnkgaW50ZW5zaXZlIGFuZCBkdW5lIGlzIGFscmVhZHlcbiAgICAgYSBtZW1vcnkgaG9nLlxuICAgLSBObyBib3hpbmcgZm9yIGVtcHR5IHNsb3RzLiBXZSBtYWtlIHVzZSBvZiB0aGUgZmFjdCB0aGF0IGlkJ3MgYXJlIG5ldmVyXG4gICAgIG5lZ2F0aXZlIHRvIGFjaGlldmUgdGhpcy5cbiAgIC0gTm8gc2F2aW5nIG9mIHRoZSBoYXNoLiBSZWNvbXB1dGluZyB0aGUgaGFzaCBmb3IgaWQncyBpcyBhIG5vLW9wLlxuKilcblxudHlwZSBub25yZWMgdGFibGUgPVxuICB7IG11dGFibGUgdGFibGUgOiBBcnJheS50XG4gIDsgbXV0YWJsZSBzaXplIDogaW50XG4gIH1cblxudHlwZSB0ID0gdGFibGUgT3B0aW9uLnQgcmVmXG5cbmxldCBpbml0IHQgPVxuICBpZiBPcHRpb24uaXNfbm9uZSAhdCB0aGVuIHQgOj0gT3B0aW9uLnNvbWUgeyBzaXplID0gMDsgdGFibGUgPSBBcnJheS5tYWtlIDAgKC0xKSB9O1xuICBPcHRpb24uZ2V0ICF0XG47O1xuXG5sZXRbQGlubGluZV0gc2hvdWxkX2dyb3cgdCA9XG4gIGxldCBzbG90cyA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gIHNsb3RzID0gMCB8fCAodC5zaXplID4gMCAmJiBzbG90cyAvIHQuc2l6ZSA8IDIpXG47O1xuXG5sZXQgYWJzZW50ID0gLTFcblxubGV0ICgpID1cbiAgbGV0IHggPSBBcnJheS5tYWtlX2Fic2VudCAxIGluXG4gIGFzc2VydCAoQXJyYXkudW5zYWZlX2dldCB4IDAgPSBhYnNlbnQpXG47O1xuXG5sZXQgY3JlYXRlICgpID0gcmVmIE9wdGlvbi5ub25lXG5cbmxldFtAaW5saW5lXSBpbmRleF9vZl9vZmZzZXQgc2xvdHMgaW5kZXggaSA9XG4gIGxldCBpID0gaW5kZXggKyAhaSBpblxuICBpZiBpID49IHNsb3RzIHRoZW4gaSAtIHNsb3RzIGVsc2UgaVxuOztcblxubGV0IGNsZWFyIHQgPVxuICBtYXRjaCAhdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgdCAtPlxuICAgIHQuc2l6ZSA8LSAwO1xuICAgIEFycmF5LmNsZWFyIHQudGFibGVcbjs7XG5cbmxldCBhZGQgdCB4ID1cbiAgbGV0IGhhc2ggPSBJbnQuaGFzaCB4IGluXG4gIGxldCBzbG90cyA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gIGxldCBpbmRleCA9IGhhc2ggbGFuZCAoc2xvdHMgLSAxKSBpblxuICBsZXQgaW5zZXJ0aW5nID0gcmVmIHRydWUgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaW5zZXJ0aW5nIGRvXG4gICAgbGV0IGlkeCA9IGluZGV4X29mX29mZnNldCBzbG90cyBpbmRleCBpIGluXG4gICAgbGV0IGVsZW0gPSBBcnJheS51bnNhZmVfZ2V0IHQudGFibGUgaWR4IGluXG4gICAgaWYgZWxlbSA9IGFic2VudFxuICAgIHRoZW4gKFxuICAgICAgQXJyYXkudW5zYWZlX3NldCB0LnRhYmxlIGlkeCB4O1xuICAgICAgaW5zZXJ0aW5nIDo9IGZhbHNlKVxuICAgIGVsc2UgaW5jciBpXG4gIGRvbmU7XG4gIHQuc2l6ZSA8LSB0LnNpemUgKyAxXG47O1xuXG5sZXQgcmVzaXplIHQgPVxuICBsZXQgb2xkX3RhYmxlID0gdC50YWJsZSBpblxuICBsZXQgc2xvdHMgPSBBcnJheS5sZW5ndGggb2xkX3RhYmxlIGluXG4gIGxldCB0YWJsZSA9IEFycmF5Lm1ha2VfYWJzZW50IChpZiBzbG90cyA9IDAgdGhlbiAxIGVsc2Ugc2xvdHMgbHNsIDEpIGluXG4gIHQudGFibGUgPC0gdGFibGU7XG4gIGZvciBpID0gMCB0byBzbG90cyAtIDEgZG9cbiAgICBsZXQgZWxlbSA9IEFycmF5LnVuc2FmZV9nZXQgb2xkX3RhYmxlIGkgaW5cbiAgICBpZiBlbGVtIDw+IGFic2VudCB0aGVuIGFkZCB0IGVsZW1cbiAgZG9uZVxuOztcblxubGV0IGFkZCB0IHggPVxuICBsZXQgdCA9IGluaXQgdCBpblxuICBpZiBzaG91bGRfZ3JvdyB0IHRoZW4gcmVzaXplIHQ7XG4gIGFkZCB0IHhcbjs7XG5cbmxldFtAaW5saW5lXSBpc19lbXB0eSB0ID1cbiAgbGV0IHQgPSAhdCBpblxuICBpZiBPcHRpb24uaXNfbm9uZSB0XG4gIHRoZW4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgdCA9IE9wdGlvbi5nZXQgdCBpblxuICAgIHQuc2l6ZSA9IDApXG47O1xuXG5sZXQgbWVtIHQgeCA9XG4gIGxldCB0ID0gIXQgaW5cbiAgaWYgT3B0aW9uLmlzX25vbmUgdCB8fCAoT3B0aW9uLmdldCB0KS5zaXplID0gMFxuICB0aGVuIGZhbHNlXG4gIGVsc2UgKFxuICAgIGxldCB0ID0gT3B0aW9uLmdldCB0IGluXG4gICAgbGV0IGhhc2ggPSBJbnQuaGFzaCB4IGluXG4gICAgbGV0IHNsb3RzID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgaW5kZXggPSBoYXNoIGxhbmQgKHNsb3RzIC0gMSkgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGZvdW5kID0gcmVmIGZhbHNlIGluXG4gICAgd2hpbGUgKG5vdCAhZm91bmQpICYmICFpIDwgc2xvdHMgZG9cbiAgICAgIGxldCBpZHggPSBpbmRleF9vZl9vZmZzZXQgc2xvdHMgaW5kZXggaSBpblxuICAgICAgbGV0IGVsZW0gPSBBcnJheS51bnNhZmVfZ2V0IHQudGFibGUgaWR4IGluXG4gICAgICBpZiBJbnQuZXF1YWwgZWxlbSB4XG4gICAgICB0aGVuIGZvdW5kIDo9IHRydWVcbiAgICAgIGVsc2UgaWYgSW50LmVxdWFsIGVsZW0gYWJzZW50XG4gICAgICB0aGVuIGkgOj0gc2xvdHNcbiAgICAgIGVsc2UgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhZm91bmQpXG47O1xuXG5sZXQgcHAgZm10IHQgPVxuICBsZXQgeyB0YWJsZTsgc2l6ZSB9ID0gaW5pdCB0IGluXG4gIGxldCB0YWJsZSA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IHRhYmxlIH5pbml0OltdIH5mOihmdW4gYWNjIGkgLT4gaWYgaSA9IGFic2VudCB0aGVuIGFjYyBlbHNlIGkgOjogYWNjKVxuICAgIHw+IExpc3QucmV2XG4gICAgfD4gU3RkbGliLkFycmF5Lm9mX2xpc3RcbiAgaW5cbiAgbGV0IHRhYmxlIGZtdCAoKSA9IEZtdC5zZXhwIGZtdCBcInRhYmxlXCIgRm10LihhcnJheSBpbnQpIHRhYmxlIGluXG4gIGxldCBzaXplIGZtdCAoKSA9IEZtdC5zZXhwIGZtdCBcInNpemVcIiBGbXQuaW50IHNpemUgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiJWFALiVhQC5cIiB0YWJsZSAoKSBzaXplICgpXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2NhbGwyIiwiZiIsImEwIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlJlX0ltcG9ydCIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwibWFrZSIsIm1hcmtzIiwibGVuIiwibWEiLCJwYXJhbSIsImkiLCJ0IiwidiIsInRlc3QiLCJvZmZzZXQiLCJzdGFydF9pIiwic3RvcF9pIiwic3RhcnQiLCJzdG9wIiwiaXRlcmkiLCJpZHgiLCJSZV9NYXJrX2luZm9zIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL21hcmtfaW5mb3MubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUgsR0FBQUMsSUFBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLEtBQUFDO0FBQUFBO0FBQUFBLEtBQUFDO0FBQUFBLE9DS2dCO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBQUFDLElBQUFDO0FBQUFBLGVBQUFDLElBQWtCO0FBQUEsV0FBa0Isc0NBQVM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUFDLElBQ25EO0FBQUEsSUFDUjtBQUFBO0FBQUEsZUFBQUY7QUFBQUEsV0FBQUcsSUFBYSxVQUFBRixJQUFBO0FBQUEsT0FBZTtBQUFBLE9BQVU7QUFBQSxNQUFDO0FBQUE7QUFBQSxJQUFNO0FBQUEsR0FDNUM7QUFBQSxZQUFBRyxLQUFBRixHQUFBRDtBQUFBQSxJQUdZLGdDQUFnQztBQUFBLGNBQVc7QUFBQSwyREFBUztBQUFBLEdBQU07QUFBQSxZQUFBSSxPQUFBSCxHQUFBRDtBQUFBQSxRQUFBSyxVQUd2RSxXQUFBQyxTQUNBO0FBQUEsSUFDQSwyQkFDSztBQUFBLFFBQUFDLFFBRVM7QUFBQSxJQUNULHdDQUNFO0FBQUEsUUFBQUMsT0FFUTtBQUFBLElBQ1g7QUFBQSxHQUFvQjtBQUFBLFlBQUFDLE1BQUFSLEdBQUFkO0FBQUFBLFFBQUEsTUFJeEI7QUFBQTtBQUFBLFNBQUFhLElBQUE7QUFBQTtBQUFBLFVBQUFVLE1BQ0UsV0FBQUgsUUFDWTtBQUFBLE1BQ1o7QUFBQSxpQkFDSyxhQUFBQyxPQUNRO0FBQUEsT0FDWDtBQUFBO0FBQUEsZ0JBSEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBSEY7QUFBQSxHQU9JO0FBQUEsT0FBQUcsZ0JEbkNOIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuIEltcG9ydFxuXG50eXBlIHQgPSBpbnQgYXJyYXlcblxubGV0IG1ha2UgbWFya3MgPVxuICBsZXQgbGVuID0gMSArIExpc3QuZm9sZF9sZWZ0IH5mOihmdW4gbWEgKGksIF8pIC0+IG1heCBtYSBpKSB+aW5pdDooLTEpIG1hcmtzIGluXG4gIGxldCB0ID0gQXJyYXkubWFrZSBsZW4gKC0xKSBpblxuICBMaXN0Lml0ZXIgfmY6KGZ1biAoaSwgdikgLT4gdC4oaSkgPC0gdikgbWFya3M7XG4gIHRcbjs7XG5cbmxldCB0ZXN0IHQgaSA9IGlmIDIgKiBpID49IEFycmF5Lmxlbmd0aCB0IHRoZW4gZmFsc2UgZWxzZSB0LigyICogaSkgPD4gLTFcblxubGV0IG9mZnNldCB0IGkgPVxuICBsZXQgc3RhcnRfaSA9IDIgKiBpIGluXG4gIGxldCBzdG9wX2kgPSBzdGFydF9pICsgMSBpblxuICBpZiBzdG9wX2kgPj0gQXJyYXkubGVuZ3RoIHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBzdGFydCA9IHQuKHN0YXJ0X2kpIGluXG4gICAgaWYgc3RhcnQgPSAtMVxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHN0b3AgPSB0LihzdG9wX2kpIGluXG4gICAgICBTb21lIChzdGFydCwgc3RvcCkpKVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gKEFycmF5Lmxlbmd0aCB0IC8gMikgLSAxIGRvXG4gICAgbGV0IGlkeCA9IDIgKiBpIGluXG4gICAgbGV0IHN0YXJ0ID0gdC4oaWR4KSBpblxuICAgIGlmIHN0YXJ0IDw+IC0xXG4gICAgdGhlbiAoXG4gICAgICBsZXQgc3RvcCA9IHQuKGlkeCArIDEpIGluXG4gICAgICBmIGkgc3RhcnQgc3RvcClcbiAgZG9uZVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMTk0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX1NldCIsImVxdWFsIiwieCIsInkiLCJjb21wYXJlIiwiciIsImdlbiIsInBhcmFtIiwicHAiLCJTZXQiLCJlbXB0eSIsImFkZCIsInNpbmdsZXRvbiIsInJlbW92ZSIsInVuaW9uIiwiaW50ZXIiLCJkaXNqb2ludCIsImRpZmYiLCJjYXJkaW5hbCIsImVsZW1lbnRzIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwiY2hvb3NlIiwiY2hvb3NlX29wdCIsImZpbmQiLCJmaW5kX29wdCIsImZpbmRfZmlyc3QiLCJmaW5kX2ZpcnN0X29wdCIsImZpbmRfbGFzdCIsImZpbmRfbGFzdF9vcHQiLCJpdGVyIiwiZm9sZCIsIm1hcCIsImZpbHRlciIsImZpbHRlcl9tYXAiLCJwYXJ0aXRpb24iLCJzcGxpdCIsImlzX2VtcHR5IiwibWVtIiwic3Vic2V0IiwiZm9yX2FsbCIsImV4aXN0cyIsInRvX2xpc3QiLCJvZl9saXN0IiwidG9fc2VxX2Zyb20iLCJ0b19zZXEiLCJ0b19yZXZfc2VxIiwiYWRkX3NlcSIsIm9mX3NlcSIsIlJlX1BtYXJrIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL3BtYXJrLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxjQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFDLE1BQUFDLEdBQUFDLEdDR2tDLHVCQUFLO0FBQUEsT0FBQUMsVURIdkMsMEJBQUFDLElBQUE7QUFBQSxZQUFBQyxJQUFBQyxPQ1FJLFFBQ0EsWUFBRTtBQUFBO0FBQUEsSUFBQUMsS0RUTjtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBdkMsVUFBQTtBQUFBLElBQUFHLFlBQUE7QUFBQSxJQUFBcUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm1vZHVsZSBQbWFyayA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgZXF1YWwgKHggOiBpbnQpICh5IDogaW50KSA9IHggPSB5XG4gIGxldCBjb21wYXJlICh4IDogaW50KSAoeSA6IGludCkgPSBjb21wYXJlIHggeVxuICBsZXQgciA9IHJlZiAwXG5cbiAgbGV0IGdlbiAoKSA9XG4gICAgaW5jciByO1xuICAgICFyXG4gIDs7XG5cbiAgbGV0IHBwID0gRm9ybWF0LnBwX3ByaW50X2ludFxuZW5kXG5cbmluY2x1ZGUgUG1hcmtcblxubW9kdWxlIFNldCA9IHN0cnVjdFxuICBtb2R1bGUgU2V0ID0gU2V0Lk1ha2UgKFBtYXJrKVxuXG4gIGxldFtAd2FybmluZyBcIi0zMlwiXSB0b19saXN0IHggPVxuICAgIGxldCBvcGVuIFNldCBpblxuICAgIHRvX3NlcSB4IHw+IExpc3Qub2Zfc2VxXG4gIDs7XG5cbiAgaW5jbHVkZSBTZXRcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJSZV9Dc2V0IiwiUmVfQ2F0ZWdvcnkiLCJSZV9CaXRfdmVjdG9yIiwiU3RkbGliX0xpc3RMYWJlbHMiLCJSZV9JbXBvcnQiLCJTdGRsaWJfRm9ybWF0IiwiUmVfRm10IiwiUmVfTWFya19pbmZvcyIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliIiwiUmVfUG1hcmsiLCJTdGRsaWJfSGFzaHRibCIsIlJlX0hhc2hfc2V0IiwiaGFzaF9jb21iaW5lIiwiaCIsImFjY3UiLCJlcXVhbCIsImNyZWF0ZSIsInBhcmFtIiwiY3N0X2xvbmciLCJjc3RfZmlyc3QiLCJjc3Rfc2hvcnQiLCJjc3RfTm9uX2dyZWVkeSIsImNzdF9HcmVlZHkiLCJwcCIsImNoIiwiayIsImZtdCIsIlJlcF9raW5kIiwiY29tcGFyZSIsInByZXYiLCJ4IiwibmV4dCIsIm5leHQyIiwiZ3JvdXBfY291bnQiLCJ0b19pbnQiLCJ1bmtub3duIiwiY3N0X2VwcyIsImNzdF9jc3QiLCJjc3RfYWx0IiwiY3N0X3NlcSIsImNzdF9yZXAiLCJjc3RfbWFyayIsImNzdF9lcmFzZSIsImNzdF9iZWZvcmUiLCJjc3RfYWZ0ZXIiLCJjc3RfcG1hcmsiLCJlIiwibWF0Y2giLCJsIiwiaSIsImIiLCJjIiwiZXBzX2V4cHIiLCJtayIsImlkcyIsImRlZiIsImVtcHR5IiwiY3N0IiwicyIsImVwcyIsInJlcCIsImtpbmQiLCJzZW0iLCJtYXJrIiwibSIsInBtYXJrIiwiZXJhc2UiLCJiZWZvcmUiLCJhZnRlciIsImFsdCIsInNlcSIsInkiLCJpc19lcHMiLCJleHByIiwicmVuYW1lIiwieiIsImciLCJ0IiwicG1hcmtzIiwibWFya3MiLCJhY2MiLCJhIiwiaGFzaCIsImluaXQiLCJtYXJrc19zZXRfaWR4IiwiaWR4IiwicmVtIiwiU3RhdHVzIiwiZXF1YWxfbGlzdCIsImwxIiwibDIiLCJlMSIsImUyIiwibWFya3MxIiwibWFya3MyIiwibGV0cmVjX2Z1bmN0aW9uX2NvbnRleHQiLCJoYXNoX2xpc3QiLCJ0c2VxIiwiZmlyc3RfbWF0Y2giLCJyIiwicmVtb3ZlX21hdGNoZXMiLCJzZXRfaWR4IiwieHMiLCJkdW1teSIsImluaXRpYWwiLCJjYXQiLCJkZXNjIiwiY2F0ZWdvcnkiLCJzdGF0dXMiLCJzdCIsIlRhYmxlIiwiaW5kZXhfY291bnQiLCJ3IiwibWFya191c2VkX2luZGljZXMiLCJ0YmwiLCJsb29wIiwic2VlbiIsImRlbHRhX2V4cHIiLCJjb3VudGVyIiwiY3R4IiwicmVwX2tpbmQiLCJzdG9wX2luY2x1c2l2ZSIsInN0YXJ0X2luY2x1c2l2ZSIsImRlbHRhX2FsdCIsImRlbHRhX3NlcSIsImRlbHRhX2Rlc2MiLCJkZWx0YSIsInRibF9yZWYiLCJuZXh0X2NhdCIsImNoYXIiLCJwcmV2X2NhdCIsImxlbiIsIlJlX0F1dG9tYXRhIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL2F1dG9tYXRhLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxZQUFBQyxhQUFBQyxHQUFBQyxNQ3dCMEIsa0NBQWtCO0FBQUEsT0FBQUMsUUR4QjVDO0FBQUEsWUFBQUMsT0FBQUMsT0NnRWtCLGNBQUs7QUFBQTtBQUFBLFVEaEV2QjtBQUFBO0FBQUEsSUFBQUYsVUFBQTtBQUFBLElBQUFHLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEs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TUFDVTtBQUFBLEtBQUFqQixNQUNWO0FBQUEsS0FBQTdCLE1BQVU7QUFBQTtBQUFBLEtBUFA7QUFBQTtBQUFBO0FBQUEsVUFBaUI7QUFBQSxVQUFBQSxRQUF1QztBQUFBO0FBQUE7QUFBQTtBQUFBLEtBUXhEO0FBQUEsTUFBd0I7QUFBQSxTQUFBWixTQTJHbEI7QUFBQSxLQUNYLGtDQUEwQjtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUEyRDtBQUFBQSxNQTdFMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVENWpCRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBJbXBvcnRcblxuKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxubGV0IGhhc2hfY29tYmluZSBoIGFjY3UgPSAoYWNjdSAqIDY1NTk5KSArIGhcblxubW9kdWxlIElkcyA6IHNpZ1xuICBtb2R1bGUgSWQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIHplcm8gOiB0XG4gICAgdmFsIGhhc2ggOiB0IC0+IGludFxuICAgIHZhbCBwcCA6IHQgRm10LnRcblxuICAgIG1vZHVsZSBIYXNoX3NldCA6IHNpZ1xuICAgICAgdHlwZSBpZCA6PSB0XG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIGNyZWF0ZSA6IHVuaXQgLT4gdFxuICAgICAgdmFsIG1lbSA6IHQgLT4gaWQgLT4gYm9vbFxuICAgICAgdmFsIGFkZCA6IHQgLT4gaWQgLT4gdW5pdFxuICAgICAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gICAgZW5kXG4gIGVuZFxuXG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGUgOiB1bml0IC0+IHRcbiAgdmFsIG5leHQgOiB0IC0+IElkLnRcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgSWQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnRcblxuICAgIG1vZHVsZSBIYXNoX3NldCA9IEhhc2hfc2V0XG5cbiAgICBsZXQgZXF1YWwgPSBJbnQuZXF1YWxcbiAgICBsZXQgemVybyA9IDBcbiAgICBsZXQgaGFzaCB4ID0geFxuICAgIGxldCBwcCA9IEZtdC5pbnRcbiAgZW5kXG5cbiAgdHlwZSB0ID0gaW50IHJlZlxuXG4gIGxldCBjcmVhdGUgKCkgPSByZWYgMFxuXG4gIGxldCBuZXh0IHQgPVxuICAgIGluY3IgdDtcbiAgICAhdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBJZCA9IElkcy5JZFxuXG5tb2R1bGUgU2VtID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgTG9uZ2VzdFxuICAgIHwgYFNob3J0ZXN0XG4gICAgfCBgRmlyc3RcbiAgICBdXG5cbiAgbGV0IGVxdWFsID0gUG9seS5lcXVhbFxuXG4gIGxldCBwcCBjaCBrID1cbiAgICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nXG4gICAgICBjaFxuICAgICAgKG1hdGNoIGsgd2l0aFxuICAgICAgIHwgYFNob3J0ZXN0IC0+IFwic2hvcnRcIlxuICAgICAgIHwgYExvbmdlc3QgLT4gXCJsb25nXCJcbiAgICAgICB8IGBGaXJzdCAtPiBcImZpcnN0XCIpXG4gIDs7XG5lbmRcblxubW9kdWxlIFJlcF9raW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgR3JlZWR5XG4gICAgfCBgTm9uX2dyZWVkeVxuICAgIF1cblxuICBsZXQgcHAgZm10ID0gZnVuY3Rpb25cbiAgICB8IGBHcmVlZHkgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJHcmVlZHlcIlxuICAgIHwgYE5vbl9ncmVlZHkgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJOb25fZ3JlZWR5XCJcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFyayA6IHNpZ1xuICB0eXBlIHQgPSBwcml2YXRlIGludFxuXG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgcHAgOiB0IEZtdC50XG4gIHZhbCBzdGFydCA6IHRcbiAgdmFsIHByZXYgOiB0IC0+IHRcbiAgdmFsIG5leHQgOiB0IC0+IHRcbiAgdmFsIG5leHQyIDogdCAtPiB0XG4gIHZhbCBncm91cF9jb3VudCA6IHQgLT4gaW50XG4gIHZhbCBvdXRzaWRlX3JhbmdlIDogdCAtPiBzdGFydF9pbmNsdXNpdmU6dCAtPiBzdG9wX2luY2x1c2l2ZTp0IC0+IGJvb2xcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgZXF1YWwgPSBJbnQuZXF1YWxcbiAgbGV0IGNvbXBhcmUgPSBJbnQuY29tcGFyZVxuICBsZXQgcHAgPSBGb3JtYXQucHBfcHJpbnRfaW50XG4gIGxldCBzdGFydCA9IDBcbiAgbGV0IHByZXYgeCA9IHByZWQgeFxuICBsZXQgbmV4dCB4ID0gc3VjYyB4XG4gIGxldCBuZXh0MiB4ID0geCArIDJcbiAgbGV0IGdyb3VwX2NvdW50IHggPSB4IC8gMlxuXG4gIGxldCBvdXRzaWRlX3JhbmdlIHQgfnN0YXJ0X2luY2x1c2l2ZSB+c3RvcF9pbmNsdXNpdmUgPVxuICAgIHQgPCBzdGFydF9pbmNsdXNpdmUgfHwgdCA+IHN0b3BfaW5jbHVzaXZlXG4gIDs7XG5lbmRcblxubW9kdWxlIElkeCA6IHNpZ1xuICB0eXBlIHQgPSBwcml2YXRlIGludFxuXG4gIHZhbCBwcCA6IHQgRm10LnRcbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCB1bmtub3duIDogdFxuICB2YWwgaW5pdGlhbCA6IHRcbiAgdmFsIHVzZWQgOiB0IC0+IGJvb2xcbiAgdmFsIG1ha2UgOiBpbnQgLT4gdFxuICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19pbnQgeCA9IHhcbiAgbGV0IHBwID0gRm9ybWF0LnBwX3ByaW50X2ludFxuICBsZXQgdXNlZCB0ID0gdCA+PSAwXG4gIGxldCBtYWtlIHggPSB4XG4gIGxldCBlcXVhbCA9IEludC5lcXVhbFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpbml0aWFsID0gMFxuZW5kXG5cbm1vZHVsZSBFeHByID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBpZCA6IElkLnRcbiAgICA7IGRlZiA6IGRlZlxuICAgIH1cblxuICBhbmQgZGVmID1cbiAgICB8IENzdCBvZiBDc2V0LnRcbiAgICB8IEFsdCBvZiB0IGxpc3RcbiAgICB8IFNlcSBvZiBTZW0udCAqIHQgKiB0XG4gICAgfCBFcHNcbiAgICB8IFJlcCBvZiBSZXBfa2luZC50ICogU2VtLnQgKiB0XG4gICAgfCBNYXJrIG9mIE1hcmsudFxuICAgIHwgRXJhc2Ugb2YgTWFyay50ICogTWFyay50XG4gICAgfCBCZWZvcmUgb2YgQ2F0ZWdvcnkudFxuICAgIHwgQWZ0ZXIgb2YgQ2F0ZWdvcnkudFxuICAgIHwgUG1hcmsgb2YgUG1hcmsudFxuXG4gIGxldCByZWMgcHAgY2ggZSA9XG4gICAgbGV0IG9wZW4gRm10IGluXG4gICAgbWF0Y2ggZS5kZWYgd2l0aFxuICAgIHwgQ3N0IGwgLT4gc2V4cCBjaCBcImNzdFwiIENzZXQucHAgbFxuICAgIHwgQWx0IGwgLT4gc2V4cCBjaCBcImFsdFwiIChsaXN0IHBwKSBsXG4gICAgfCBTZXEgKGssIGUsIGUnKSAtPiBzZXhwIGNoIFwic2VxXCIgKHRyaXBsZSBTZW0ucHAgcHAgcHApIChrLCBlLCBlJylcbiAgICB8IEVwcyAtPiBzdHIgY2ggXCJlcHNcIlxuICAgIHwgUmVwIChfcmssIGssIGUpIC0+IHNleHAgY2ggXCJyZXBcIiAocGFpciBTZW0ucHAgcHApIChrLCBlKVxuICAgIHwgTWFyayBpIC0+IHNleHAgY2ggXCJtYXJrXCIgTWFyay5wcCBpXG4gICAgfCBQbWFyayBpIC0+IHNleHAgY2ggXCJwbWFya1wiIFBtYXJrLnBwIGlcbiAgICB8IEVyYXNlIChiLCBlKSAtPiBzZXhwIGNoIFwiZXJhc2VcIiAocGFpciBNYXJrLnBwIE1hcmsucHApIChiLCBlKVxuICAgIHwgQmVmb3JlIGMgLT4gc2V4cCBjaCBcImJlZm9yZVwiIENhdGVnb3J5LnBwIGNcbiAgICB8IEFmdGVyIGMgLT4gc2V4cCBjaCBcImFmdGVyXCIgQ2F0ZWdvcnkucHAgY1xuICA7O1xuXG4gIGxldCBlcHNfZXhwciA9IHsgaWQgPSBJZC56ZXJvOyBkZWYgPSBFcHMgfVxuICBsZXQgbWsgaWRzIGRlZiA9IHsgaWQgPSBJZHMubmV4dCBpZHM7IGRlZiB9XG4gIGxldCBlbXB0eSBpZHMgPSBtayBpZHMgKEFsdCBbXSlcbiAgbGV0IGNzdCBpZHMgcyA9IGlmIENzZXQuaXNfZW1wdHkgcyB0aGVuIGVtcHR5IGlkcyBlbHNlIG1rIGlkcyAoQ3N0IHMpXG4gIGxldCBlcHMgaWRzID0gbWsgaWRzIEVwc1xuICBsZXQgcmVwIGlkcyBraW5kIHNlbSB4ID0gbWsgaWRzIChSZXAgKGtpbmQsIHNlbSwgeCkpXG4gIGxldCBtYXJrIGlkcyBtID0gbWsgaWRzIChNYXJrIG0pXG4gIGxldCBwbWFyayBpZHMgaSA9IG1rIGlkcyAoUG1hcmsgaSlcbiAgbGV0IGVyYXNlIGlkcyBtIG0nID0gbWsgaWRzIChFcmFzZSAobSwgbScpKVxuICBsZXQgYmVmb3JlIGlkcyBjID0gbWsgaWRzIChCZWZvcmUgYylcbiAgbGV0IGFmdGVyIGlkcyBjID0gbWsgaWRzIChBZnRlciBjKVxuXG4gIGxldCBhbHQgaWRzID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGVtcHR5IGlkc1xuICAgIHwgWyBjIF0gLT4gY1xuICAgIHwgbCAtPiBtayBpZHMgKEFsdCBsKVxuICA7O1xuXG4gIGxldCBzZXEgaWRzIChraW5kIDogU2VtLnQpIHggeSA9XG4gICAgbWF0Y2ggeC5kZWYsIHkuZGVmIHdpdGhcbiAgICB8IEFsdCBbXSwgXyAtPiB4XG4gICAgfCBfLCBBbHQgW10gLT4geVxuICAgIHwgRXBzLCBfIC0+IHlcbiAgICB8IF8sIEVwcyB3aGVuIFNlbS5lcXVhbCBraW5kIGBGaXJzdCAtPiB4XG4gICAgfCBfIC0+IG1rIGlkcyAoU2VxIChraW5kLCB4LCB5KSlcbiAgOztcblxuICBsZXQgaXNfZXBzIGV4cHIgPVxuICAgIG1hdGNoIGV4cHIuZGVmIHdpdGhcbiAgICB8IEVwcyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHJlYyByZW5hbWUgaWRzIHggPVxuICAgIG1hdGNoIHguZGVmIHdpdGhcbiAgICB8IENzdCBfIHwgRXBzIHwgTWFyayBfIHwgUG1hcmsgXyB8IEVyYXNlIF8gfCBCZWZvcmUgXyB8IEFmdGVyIF8gLT4gbWsgaWRzIHguZGVmXG4gICAgfCBBbHQgbCAtPiBtayBpZHMgKEFsdCAoTGlzdC5tYXAgfmY6KHJlbmFtZSBpZHMpIGwpKVxuICAgIHwgU2VxIChrLCB5LCB6KSAtPiBtayBpZHMgKFNlcSAoaywgcmVuYW1lIGlkcyB5LCByZW5hbWUgaWRzIHopKVxuICAgIHwgUmVwIChnLCBrLCB5KSAtPiBtayBpZHMgKFJlcCAoZywgaywgcmVuYW1lIGlkcyB5KSlcbiAgOztcbmVuZFxuXG50eXBlIGV4cHIgPSBFeHByLnRcblxuaW5jbHVkZSBFeHByXG5cbm1vZHVsZSBNYXJrcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbWFya3MgOiAoTWFyay50ICogSWR4LnQpIGxpc3RcbiAgICA7IHBtYXJrcyA6IFBtYXJrLlNldC50XG4gICAgfVxuXG4gIGxldCBlcXVhbCB7IG1hcmtzOyBwbWFya3MgfSB0ID1cbiAgICBMaXN0LmVxdWFsXG4gICAgICB+ZXE6KGZ1biAoeCwgeSkgKHgnLCB5JykgLT4gTWFyay5lcXVhbCB4IHgnICYmIElkeC5lcXVhbCB5IHknKVxuICAgICAgbWFya3NcbiAgICAgIHQubWFya3NcbiAgICAmJiBQbWFyay5TZXQuZXF1YWwgcG1hcmtzIHQucG1hcmtzXG4gIDs7XG5cbiAgbGV0IGVtcHR5ID0geyBtYXJrcyA9IFtdOyBwbWFya3MgPSBQbWFyay5TZXQuZW1wdHkgfVxuXG4gIGxldCBoYXNoX21hcmtzX29mZnNldCA9XG4gICAgbGV0IGYgYWNjICgoYSA6IE1hcmsudCksIChpIDogSWR4LnQpKSA9XG4gICAgICBoYXNoX2NvbWJpbmUgKGEgOj4gaW50KSAoaGFzaF9jb21iaW5lIChpIDo+IGludCkgYWNjKVxuICAgIGluXG4gICAgZnVuIGwgaW5pdCAtPiBMaXN0LmZvbGRfbGVmdCBsIH5pbml0IH5mXG4gIDs7XG5cbiAgbGV0IGhhc2ggbSBhY2N1ID0gaGFzaF9tYXJrc19vZmZzZXQgbS5tYXJrcyAoaGFzaF9jb21iaW5lIChIYXNodGJsLmhhc2ggbS5wbWFya3MpIGFjY3UpXG5cbiAgbGV0IG1hcmtzX3NldF9pZHggPVxuICAgIGxldCByZWMgbWFya3Nfc2V0X2lkeCBpZHggbWFya3MgPVxuICAgICAgbWF0Y2ggbWFya3Mgd2l0aFxuICAgICAgfCBbXSAtPiBbXVxuICAgICAgfCAoYSwgaWR4JykgOjogcmVtIC0+XG4gICAgICAgIGlmIElkeC5lcXVhbCBpZHgnIElkeC51bmtub3duIHRoZW4gKGEsIGlkeCkgOjogbWFya3Nfc2V0X2lkeCBpZHggcmVtIGVsc2UgbWFya3NcbiAgICBpblxuICAgIGZ1biBtYXJrcyBpZHggLT4geyBtYXJrcyB3aXRoIG1hcmtzID0gbWFya3Nfc2V0X2lkeCBpZHggbWFya3MubWFya3MgfVxuICA7O1xuXG4gIGxldCBmaWx0ZXIgdCAoYiA6IE1hcmsudCkgKGUgOiBNYXJrLnQpID1cbiAgICB7IHQgd2l0aFxuICAgICAgbWFya3MgPVxuICAgICAgICBMaXN0LmZpbHRlciB0Lm1hcmtzIH5mOihmdW4gKChpIDogTWFyay50KSwgXykgLT5cbiAgICAgICAgICBNYXJrLm91dHNpZGVfcmFuZ2UgaSB+c3RhcnRfaW5jbHVzaXZlOmIgfnN0b3BfaW5jbHVzaXZlOmUpXG4gICAgfVxuICA7O1xuXG4gIGxldCBzZXRfbWFyayB0IChpIDogTWFyay50KSA9XG4gICAgeyB0IHdpdGggbWFya3MgPSAoaSwgSWR4LnVua25vd24pIDo6IExpc3QucmVtb3ZlX2Fzc3EgaSB0Lm1hcmtzIH1cbiAgOztcblxuICBsZXQgc2V0X3BtYXJrIHQgaSA9IHsgdCB3aXRoIHBtYXJrcyA9IFBtYXJrLlNldC5hZGQgaSB0LnBtYXJrcyB9XG5cbiAgbGV0IHBwIGZtdCB7IG1hcmtzOyBwbWFya3MgfSA9XG4gICAgRm9ybWF0LnBwX29wZW5fYm94IGZtdCAxO1xuICAgIChtYXRjaCBtYXJrcyB3aXRoXG4gICAgIHwgW10gLT4gKClcbiAgICAgfCBfIDo6IF8gLT5cbiAgICAgICBGb3JtYXQuZnByaW50ZlxuICAgICAgICAgZm10XG4gICAgICAgICBcIkBbPDI+bWFya3NAICVhQF1cIlxuICAgICAgICAgKEZvcm1hdC5wcF9wcmludF9saXN0IChmdW4gZm10IChhLCBpKSAtPlxuICAgICAgICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiJWEtJWFcIiBNYXJrLnBwIGEgSWR4LnBwIGkpKVxuICAgICAgICAgbWFya3MpO1xuICAgIChtYXRjaCBQbWFyay5TZXQudG9fbGlzdCBwbWFya3Mgd2l0aFxuICAgICB8IFtdIC0+ICgpXG4gICAgIHwgcG1hcmtzIC0+XG4gICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiQFs8Mj5wbWFya3MgJWFAXVwiIChGb3JtYXQucHBfcHJpbnRfbGlzdCBQbWFyay5wcCkgcG1hcmtzKTtcbiAgICBGb3JtYXQucHBfY2xvc2VfYm94IGZtdCAoKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBTdGF0dXMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEZhaWxlZFxuICAgIHwgTWF0Y2ggb2YgTWFya19pbmZvcy50ICogUG1hcmsuU2V0LnRcbiAgICB8IFJ1bm5pbmdcbmVuZFxuXG5tb2R1bGUgRGVzYyA6IHNpZ1xuICBtb2R1bGUgRSA6IHNpZ1xuICAgIHR5cGUgdCA9IHByaXZhdGVcbiAgICAgIHwgVFNlcSBvZiBTZW0udCAqIHQgbGlzdCAqIEV4cHIudFxuICAgICAgfCBURXhwIG9mIE1hcmtzLnQgKiBFeHByLnRcbiAgICAgIHwgVE1hdGNoIG9mIE1hcmtzLnRcblxuICAgIHZhbCB0bWF0Y2ggOiBNYXJrcy50IC0+IHRcbiAgICB2YWwgdHNlcSA6IFNlbS50IC0+IHQgbGlzdCAtPiBFeHByLnQgLT4gdCBsaXN0IC0+IHQgbGlzdFxuICAgIHZhbCBpbml0aWFsIDogRXhwci50IC0+IHRcbiAgICB2YWwgZXBzIDogTWFya3MudCAtPiB0XG4gIGVuZFxuXG4gIHR5cGUgdCA9IEUudCBsaXN0XG5cbiAgdmFsIHNldF9pZHggOiBJZHgudCAtPiB0IC0+IHRcbiAgdmFsIGhhc2ggOiB0IC0+IGludCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIHN0YXR1cyA6IHQgLT4gU3RhdHVzLnRcbiAgdmFsIGZpcnN0X21hdGNoIDogdCAtPiBNYXJrcy50IG9wdGlvblxuICB2YWwgcmVtb3ZlX21hdGNoZXMgOiB0IC0+IHRcbiAgdmFsIHNwbGl0X2F0X21hdGNoIDogdCAtPiB0ICogdFxuZW5kID0gc3RydWN0XG4gIG1vZHVsZSBFID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgVFNlcSBvZiBTZW0udCAqIHQgbGlzdCAqIEV4cHIudFxuICAgICAgfCBURXhwIG9mIE1hcmtzLnQgKiBFeHByLnRcbiAgICAgIHwgVE1hdGNoIG9mIE1hcmtzLnRcblxuICAgIGxldCB0bWF0Y2ggbWFya3MgPSBUTWF0Y2ggbWFya3NcbiAgICBsZXQgaW5pdGlhbCBleHByID0gVEV4cCAoTWFya3MuZW1wdHksIGV4cHIpXG4gICAgbGV0IGVwcyBtYXJrcyA9IFRFeHAgKG1hcmtzLCBlcHNfZXhwcilcblxuICAgIGxldCByZWMgZXF1YWxfbGlzdCBsMSBsMiA9IExpc3QuZXF1YWwgfmVxOmVxdWFsIGwxIGwyXG5cbiAgICBhbmQgZXF1YWwgeCB5ID1cbiAgICAgIG1hdGNoIHgsIHkgd2l0aFxuICAgICAgfCBUU2VxIChfLCBsMSwgZTEpLCBUU2VxIChfLCBsMiwgZTIpIC0+IElkLmVxdWFsIGUxLmlkIGUyLmlkICYmIGVxdWFsX2xpc3QgbDEgbDJcbiAgICAgIHwgVEV4cCAobWFya3MxLCBlMSksIFRFeHAgKG1hcmtzMiwgZTIpIC0+XG4gICAgICAgIElkLmVxdWFsIGUxLmlkIGUyLmlkICYmIE1hcmtzLmVxdWFsIG1hcmtzMSBtYXJrczJcbiAgICAgIHwgVE1hdGNoIG1hcmtzMSwgVE1hdGNoIG1hcmtzMiAtPiBNYXJrcy5lcXVhbCBtYXJrczEgbWFya3MyXG4gICAgICB8IF8sIF8gLT4gZmFsc2VcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBoYXNoICh0IDogdCkgYWNjdSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgVFNlcSAoXywgbCwgZSkgLT5cbiAgICAgICAgaGFzaF9jb21iaW5lIDB4MTcyYTFiY2UgKGhhc2hfY29tYmluZSAoSWQuaGFzaCBlLmlkKSAoaGFzaF9saXN0IGwgYWNjdSkpXG4gICAgICB8IFRFeHAgKG1hcmtzLCBlKSAtPlxuICAgICAgICBoYXNoX2NvbWJpbmUgMHgyYjRjMGQ3NyAoaGFzaF9jb21iaW5lIChJZC5oYXNoIGUuaWQpIChNYXJrcy5oYXNoIG1hcmtzIGFjY3UpKVxuICAgICAgfCBUTWF0Y2ggbWFya3MgLT4gaGFzaF9jb21iaW5lIDB4MWMyMDVhZDUgKE1hcmtzLmhhc2ggbWFya3MgYWNjdSlcblxuICAgIGFuZCBoYXNoX2xpc3QgPVxuICAgICAgbGV0IGYgYWNjIHggPSBoYXNoIHggYWNjIGluXG4gICAgICBmdW4gbCBpbml0IC0+IExpc3QuZm9sZF9sZWZ0IGwgfmluaXQgfmZcbiAgICA7O1xuXG4gICAgbGV0IHRzZXEnIGtpbmQgeCB5ID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBbXSAtPiBbXVxuICAgICAgfCBbIFRFeHAgKG1hcmtzLCB7IGRlZiA9IEVwczsgXyB9KSBdIC0+IFsgVEV4cCAobWFya3MsIHkpIF1cbiAgICAgIHwgXyAtPiBbIFRTZXEgKGtpbmQsIHgsIHkpIF1cbiAgICA7O1xuXG4gICAgbGV0IHRzZXEga2luZCB4IHkgcmVtID0gdHNlcScga2luZCB4IHkgQCByZW1cbiAgZW5kXG5cbiAgdHlwZSB0ID0gRS50IGxpc3RcblxuICBvcGVuIEVcblxuICBsZXQgZXF1YWwgPSBFLmVxdWFsX2xpc3RcbiAgbGV0IGhhc2ggPSBFLmhhc2hfbGlzdFxuXG4gIGxldCByZWMgcHJpbnRfc3RhdGVfcmVjIGNoIGUgKHkgOiBFeHByLnQpID1cbiAgICBtYXRjaCBlIHdpdGhcbiAgICB8IFRNYXRjaCBtYXJrcyAtPiBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KE1hdGNoQCAlYSlAXVwiIE1hcmtzLnBwIG1hcmtzXG4gICAgfCBUU2VxIChfa2luZCwgbCcsIHgpIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KFNlcUAgXCI7XG4gICAgICBwcmludF9zdGF0ZV9sc3QgY2ggbCcgeDtcbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQCAlYSlAXVwiIEV4cHIucHAgeFxuICAgIHwgVEV4cCAobWFya3MsIHsgZGVmID0gRXBzOyBfIH0pIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KEV4cEAgJWFAICglYSlAIChlcHMpKUBdXCIgSWQucHAgeS5pZCBNYXJrcy5wcCBtYXJrc1xuICAgIHwgVEV4cCAobWFya3MsIHgpIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KEV4cEAgJWFAICglYSlAICVhKUBdXCIgSWQucHAgeC5pZCBNYXJrcy5wcCBtYXJrcyBFeHByLnBwIHhcblxuICBhbmQgcHJpbnRfc3RhdGVfbHN0IGNoIGwgeSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBGb3JtYXQuZnByaW50ZiBjaCBcIigpXCJcbiAgICB8IGUgOjogcmVtIC0+XG4gICAgICBwcmludF9zdGF0ZV9yZWMgY2ggZSB5O1xuICAgICAgTGlzdC5pdGVyIHJlbSB+ZjooZnVuIGUgLT5cbiAgICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCJAIHwgXCI7XG4gICAgICAgIHByaW50X3N0YXRlX3JlYyBjaCBlIHkpXG4gIDs7XG5cbiAgbGV0IHBwIGNoIHQgPSBwcmludF9zdGF0ZV9sc3QgY2ggWyB0IF0geyBpZCA9IElkLnplcm87IGRlZiA9IEVwcyB9XG5cbiAgbGV0IHJlYyBmaXJzdF9tYXRjaCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBUTWF0Y2ggbWFya3MgOjogXyAtPiBTb21lIG1hcmtzXG4gICAgfCBfIDo6IHIgLT4gZmlyc3RfbWF0Y2ggclxuICA7O1xuXG4gIGxldCByZW1vdmVfbWF0Y2hlcyA9XG4gICAgTGlzdC5maWx0ZXIgfmY6KGZ1bmN0aW9uXG4gICAgICB8IFRNYXRjaCBfIC0+IGZhbHNlXG4gICAgICB8IF8gLT4gdHJ1ZSlcbiAgOztcblxuICBsZXQgc3BsaXRfYXRfbWF0Y2ggPVxuICAgIGxldCByZWMgc3BsaXRfYXRfbWF0Y2hfcmVjIGwgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgVE1hdGNoIF8gOjogciAtPiBMaXN0LnJldiBsLCByZW1vdmVfbWF0Y2hlcyByXG4gICAgICB8IHggOjogciAtPiBzcGxpdF9hdF9tYXRjaF9yZWMgKHggOjogbCkgclxuICAgIGluXG4gICAgZnVuIGwgLT4gc3BsaXRfYXRfbWF0Y2hfcmVjIFtdIGxcbiAgOztcblxuICBsZXQgc3RhdHVzIDogXyAtPiBTdGF0dXMudCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBGYWlsZWRcbiAgICB8IFRNYXRjaCBtIDo6IF8gLT4gTWF0Y2ggKE1hcmtfaW5mb3MubWFrZSAobS5tYXJrcyA6PiAoaW50ICogaW50KSBsaXN0KSwgbS5wbWFya3MpXG4gICAgfCBfIC0+IFJ1bm5pbmdcbiAgOztcblxuICBsZXQgc2V0X2lkeCA9XG4gICAgbGV0IHJlYyBmIGlkeCA9IGZ1bmN0aW9uXG4gICAgICB8IFRNYXRjaCBtYXJrcyAtPiBUTWF0Y2ggKE1hcmtzLm1hcmtzX3NldF9pZHggbWFya3MgaWR4KVxuICAgICAgfCBUU2VxIChraW5kLCBsLCB4KSAtPiBUU2VxIChraW5kLCBzZXRfaWR4IGlkeCBsLCB4KVxuICAgICAgfCBURXhwIChtYXJrcywgeCkgLT4gVEV4cCAoTWFya3MubWFya3Nfc2V0X2lkeCBtYXJrcyBpZHgsIHgpXG4gICAgYW5kIHNldF9pZHggaWR4IHhzID0gTGlzdC5tYXAgeHMgfmY6KGYgaWR4KSBpblxuICAgIHNldF9pZHhcbiAgOztcblxuICBsZXRbQG9jYW1sLndhcm5pbmcgXCItMzJcIl0gcHAgZm10IHQgPVxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlslYV1cIiAoRm9ybWF0LnBwX3ByaW50X2xpc3QgfnBwX3NlcDooRm10LmxpdCBcIjsgXCIpIHBwKSB0XG4gIDs7XG5lbmRcblxubW9kdWxlIEUgPSBEZXNjLkVcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBpZHggOiBJZHgudFxuICAgIDsgY2F0ZWdvcnkgOiBDYXRlZ29yeS50XG4gICAgOyBkZXNjIDogRGVzYy50XG4gICAgOyBtdXRhYmxlIHN0YXR1cyA6IFN0YXR1cy50IE9wdGlvbi5VbmJveGVkLnRcbiAgICA7IGhhc2ggOiBpbnRcbiAgICB9XG5cbiAgbGV0W0BpbmxpbmVdIGlkeCB0ID0gdC5pZHhcblxuICBsZXQgZHVtbXkgPVxuICAgIHsgaWR4ID0gSWR4LnVua25vd25cbiAgICA7IGNhdGVnb3J5ID0gQ2F0ZWdvcnkuZHVtbXlcbiAgICA7IGRlc2MgPSBbXVxuICAgIDsgc3RhdHVzID0gT3B0aW9uLlVuYm94ZWQubm9uZVxuICAgIDsgaGFzaCA9IC0xXG4gICAgfVxuICA7O1xuXG4gIGxldCBoYXNoIGlkeCBjYXQgZGVzYyA9XG4gICAgRGVzYy5oYXNoIGRlc2MgKGhhc2hfY29tYmluZSBpZHggKGhhc2hfY29tYmluZSAoQ2F0ZWdvcnkudG9faW50IGNhdCkgMCkpXG4gICAgbGFuZCAweDNGRkZGRkZGXG4gIDs7XG5cbiAgbGV0IG1rIGlkeCBjYXQgZGVzYyA9XG4gICAgeyBpZHhcbiAgICA7IGNhdGVnb3J5ID0gY2F0XG4gICAgOyBkZXNjXG4gICAgOyBzdGF0dXMgPSBPcHRpb24uVW5ib3hlZC5ub25lXG4gICAgOyBoYXNoID0gaGFzaCAoaWR4IDo+IGludCkgY2F0IGRlc2NcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSBjYXQgZSA9IG1rIElkeC5pbml0aWFsIGNhdCBbIEUuaW5pdGlhbCBlIF1cblxuICBsZXQgZXF1YWwgeyBpZHg7IGNhdGVnb3J5OyBkZXNjOyBzdGF0dXMgPSBfOyBoYXNoIH0gdCA9XG4gICAgSW50LmVxdWFsIGhhc2ggdC5oYXNoXG4gICAgJiYgSWR4LmVxdWFsIGlkeCB0LmlkeFxuICAgICYmIENhdGVnb3J5LmVxdWFsIGNhdGVnb3J5IHQuY2F0ZWdvcnlcbiAgICAmJiBEZXNjLmVxdWFsIGRlc2MgdC5kZXNjXG4gIDs7XG5cbiAgbGV0IHN0YXR1cyBzID1cbiAgICBsZXQgc3RhdHVzID0gcy5zdGF0dXMgaW5cbiAgICBtYXRjaCBPcHRpb24uVW5ib3hlZC5pc19zb21lIHN0YXR1cyB3aXRoXG4gICAgfCB0cnVlIC0+IE9wdGlvbi5VbmJveGVkLnZhbHVlX2V4biBzdGF0dXNcbiAgICB8IGZhbHNlIC0+XG4gICAgICBsZXQgc3QgPSBEZXNjLnN0YXR1cyBzLmRlc2MgaW5cbiAgICAgIHMuc3RhdHVzIDwtIE9wdGlvbi5VbmJveGVkLnNvbWUgc3Q7XG4gICAgICBzdFxuICA7O1xuXG4gIG1vZHVsZSBUYWJsZSA9IEhhc2h0YmwuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgZXF1YWwgPSBlcXVhbFxuICAgICAgbGV0IGhhc2ggdCA9IHQuaGFzaFxuICAgIGVuZClcbmVuZFxuXG4oKioqKiBGaW5kIGEgZnJlZSBpbmRleCAqKioqKVxuXG5tb2R1bGUgV29ya2luZ19hcmVhID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBtdXRhYmxlIGlkcyA6IEJpdF92ZWN0b3IudFxuICAgIDsgc2VlbiA6IElkLkhhc2hfc2V0LnRcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSAoKSA9IHsgaWRzID0gQml0X3ZlY3Rvci5jcmVhdGVfemVybyAxOyBzZWVuID0gSWQuSGFzaF9zZXQuY3JlYXRlICgpIH1cbiAgbGV0IGluZGV4X2NvdW50IHcgPSBCaXRfdmVjdG9yLmxlbmd0aCB3Lmlkc1xuXG4gIGxldCByZWMgbWFya191c2VkX2luZGljZXMgdGJsID1cbiAgICBMaXN0Lml0ZXIgfmY6KGZ1biAoZSA6IEUudCkgLT5cbiAgICAgIG1hdGNoIGUgd2l0aFxuICAgICAgfCBUU2VxIChfLCBsLCBfKSAtPiBtYXJrX3VzZWRfaW5kaWNlcyB0YmwgbFxuICAgICAgfCBURXhwIChtYXJrcywgXykgfCBUTWF0Y2ggbWFya3MgLT5cbiAgICAgICAgTGlzdC5pdGVyIG1hcmtzLm1hcmtzIH5mOihmdW4gKF8sIGkpIC0+XG4gICAgICAgICAgaWYgSWR4LnVzZWQgaSB0aGVuIEJpdF92ZWN0b3Iuc2V0IHRibCAoaSA6PiBpbnQpIHRydWUpKVxuICA7O1xuXG4gIGxldCByZWMgZmluZF9mcmVlIHRibCBpZHggbGVuID1cbiAgICBpZiBpZHggPSBsZW4gfHwgbm90IChCaXRfdmVjdG9yLmdldCB0YmwgaWR4KSB0aGVuIGlkeCBlbHNlIGZpbmRfZnJlZSB0YmwgKGlkeCArIDEpIGxlblxuICA7O1xuXG4gIGxldCBmcmVlX2luZGV4IHQgbCA9XG4gICAgQml0X3ZlY3Rvci5yZXNldF96ZXJvIHQuaWRzO1xuICAgIG1hcmtfdXNlZF9pbmRpY2VzIHQuaWRzIGw7XG4gICAgbGV0IGxlbiA9IEJpdF92ZWN0b3IubGVuZ3RoIHQuaWRzIGluXG4gICAgbGV0IGlkeCA9IGZpbmRfZnJlZSB0LmlkcyAwIGxlbiBpblxuICAgIGlmIGlkeCA9IGxlbiB0aGVuIHQuaWRzIDwtIEJpdF92ZWN0b3IuY3JlYXRlX3plcm8gKDIgKiBsZW4pO1xuICAgIElkeC5tYWtlIGlkeFxuICA7O1xuZW5kXG5cbigqKioqIENvbXB1dGF0aW9uIG9mIHRoZSBuZXh0IHN0YXRlICoqKiopXG5cbmxldCByZW1vdmVfZHVwbGljYXRlcyA9XG4gIGxldCByZWMgbG9vcCBzZWVuIChsIDogRGVzYy50KSB5ID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFtdXG4gICAgfCAoVE1hdGNoIF8gYXMgeCkgOjogXyAtPlxuICAgICAgKCogVHJ1bmNhdGUgYWZ0ZXIgZmlyc3QgbWF0Y2ggKilcbiAgICAgIFsgeCBdXG4gICAgfCBUU2VxIChraW5kLCBsLCB4KSA6OiByIC0+XG4gICAgICBsZXQgbCA9IGxvb3Agc2VlbiBsIHggaW5cbiAgICAgIGxldCByID0gbG9vcCBzZWVuIHIgeSBpblxuICAgICAgRS50c2VxIGtpbmQgbCB4IHJcbiAgICB8IChURXhwIChfbWFya3MsIHsgZGVmID0gRXBzOyBfIH0pIGFzIGUpIDo6IHIgLT5cbiAgICAgIGlmIElkLkhhc2hfc2V0Lm1lbSBzZWVuIHkuaWRcbiAgICAgIHRoZW4gbG9vcCBzZWVuIHIgeVxuICAgICAgZWxzZSAoXG4gICAgICAgIElkLkhhc2hfc2V0LmFkZCBzZWVuIHkuaWQ7XG4gICAgICAgIGUgOjogbG9vcCBzZWVuIHIgeSlcbiAgICB8IChURXhwIChfbWFya3MsIHgpIGFzIGUpIDo6IHIgLT5cbiAgICAgIGlmIElkLkhhc2hfc2V0Lm1lbSBzZWVuIHguaWRcbiAgICAgIHRoZW4gbG9vcCBzZWVuIHIgeVxuICAgICAgZWxzZSAoXG4gICAgICAgIElkLkhhc2hfc2V0LmFkZCBzZWVuIHguaWQ7XG4gICAgICAgIGUgOjogbG9vcCBzZWVuIHIgeSlcbiAgaW5cbiAgZnVuIHNlZW4gbCB5IC0+XG4gICAgSWQuSGFzaF9zZXQuY2xlYXIgc2VlbjtcbiAgICBsb29wIHNlZW4gbCB5XG47O1xuXG50eXBlIGN0eCA9XG4gIHsgYyA6IENzZXQuY1xuICA7IHByZXZfY2F0IDogQ2F0ZWdvcnkudFxuICA7IG5leHRfY2F0IDogQ2F0ZWdvcnkudFxuICB9XG5cbmxldCByZWMgZGVsdGFfZXhwciAoeyBjOyBfIH0gYXMgY3R4KSBtYXJrcyAoeCA6IEV4cHIudCkgcmVtID1cbiAgKCpGb3JtYXQuZXByaW50ZiBcIiVkQC5cIiB4LmlkOyopXG4gIG1hdGNoIHguZGVmIHdpdGhcbiAgfCBDc3QgcyAtPiBpZiBDc2V0Lm1lbSBjIHMgdGhlbiBFLmVwcyBtYXJrcyA6OiByZW0gZWxzZSByZW1cbiAgfCBBbHQgbCAtPiBkZWx0YV9hbHQgY3R4IG1hcmtzIGwgcmVtXG4gIHwgU2VxIChraW5kLCB5LCB6KSAtPlxuICAgIGxldCB5ID0gZGVsdGFfZXhwciBjdHggbWFya3MgeSBbXSBpblxuICAgIGRlbHRhX3NlcSBjdHgga2luZCB5IHogcmVtXG4gIHwgUmVwIChyZXBfa2luZCwga2luZCwgeSkgLT5cbiAgICBsZXQgeSwgbWFya3MnID1cbiAgICAgIGxldCB5ID0gZGVsdGFfZXhwciBjdHggbWFya3MgeSBbXSBpblxuICAgICAgbWF0Y2ggRGVzYy5maXJzdF9tYXRjaCB5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiB5LCBtYXJrc1xuICAgICAgfCBTb21lIG1hcmtzIC0+IERlc2MucmVtb3ZlX21hdGNoZXMgeSwgbWFya3NcbiAgICBpblxuICAgIChtYXRjaCByZXBfa2luZCB3aXRoXG4gICAgIHwgYEdyZWVkeSAtPiBFLnRzZXEga2luZCB5IHggKEUudG1hdGNoIG1hcmtzJyA6OiByZW0pXG4gICAgIHwgYE5vbl9ncmVlZHkgLT4gRS50bWF0Y2ggbWFya3MgOjogRS50c2VxIGtpbmQgeSB4IHJlbSlcbiAgfCBFcHMgLT4gRS50bWF0Y2ggbWFya3MgOjogcmVtXG4gIHwgTWFyayBpIC0+IEUudG1hdGNoIChNYXJrcy5zZXRfbWFyayBtYXJrcyBpKSA6OiByZW1cbiAgfCBQbWFyayBpIC0+IEUudG1hdGNoIChNYXJrcy5zZXRfcG1hcmsgbWFya3MgaSkgOjogcmVtXG4gIHwgRXJhc2UgKGIsIGUpIC0+IEUudG1hdGNoIChNYXJrcy5maWx0ZXIgbWFya3MgYiBlKSA6OiByZW1cbiAgfCBCZWZvcmUgY2F0IC0+XG4gICAgaWYgQ2F0ZWdvcnkuaW50ZXJzZWN0IGN0eC5uZXh0X2NhdCBjYXQgdGhlbiBFLnRtYXRjaCBtYXJrcyA6OiByZW0gZWxzZSByZW1cbiAgfCBBZnRlciBjYXQgLT5cbiAgICBpZiBDYXRlZ29yeS5pbnRlcnNlY3QgY3R4LnByZXZfY2F0IGNhdCB0aGVuIEUudG1hdGNoIG1hcmtzIDo6IHJlbSBlbHNlIHJlbVxuXG5hbmQgZGVsdGFfYWx0IGN0eCBtYXJrcyBsIHJlbSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IHJlbVxuICB8IHkgOjogciAtPiBkZWx0YV9leHByIGN0eCBtYXJrcyB5IChkZWx0YV9hbHQgY3R4IG1hcmtzIHIgcmVtKVxuXG5hbmQgZGVsdGFfc2VxIGN0eCAoa2luZCA6IFNlbS50KSB5IHogcmVtID1cbiAgbWF0Y2ggRGVzYy5maXJzdF9tYXRjaCB5IHdpdGhcbiAgfCBOb25lIC0+IEUudHNlcSBraW5kIHkgeiByZW1cbiAgfCBTb21lIG1hcmtzIC0+XG4gICAgKG1hdGNoIGtpbmQgd2l0aFxuICAgICB8IGBMb25nZXN0IC0+IEUudHNlcSBraW5kIChEZXNjLnJlbW92ZV9tYXRjaGVzIHkpIHogKGRlbHRhX2V4cHIgY3R4IG1hcmtzIHogcmVtKVxuICAgICB8IGBTaG9ydGVzdCAtPiBkZWx0YV9leHByIGN0eCBtYXJrcyB6IChFLnRzZXEga2luZCAoRGVzYy5yZW1vdmVfbWF0Y2hlcyB5KSB6IHJlbSlcbiAgICAgfCBgRmlyc3QgLT5cbiAgICAgICBsZXQgeSwgeScgPSBEZXNjLnNwbGl0X2F0X21hdGNoIHkgaW5cbiAgICAgICBFLnRzZXEga2luZCB5IHogKGRlbHRhX2V4cHIgY3R4IG1hcmtzIHogKEUudHNlcSBraW5kIHknIHogcmVtKSkpXG47O1xuXG5sZXQgcmVjIGRlbHRhX2UgY3R4IG1hcmtzICh4IDogRS50KSByZW0gPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBUU2VxIChraW5kLCB5LCB6KSAtPlxuICAgIGxldCB5ID0gZGVsdGFfZGVzYyBjdHggbWFya3MgeSBbXSBpblxuICAgIGRlbHRhX3NlcSBjdHgga2luZCB5IHogcmVtXG4gIHwgVEV4cCAobWFya3MsIGUpIC0+IGRlbHRhX2V4cHIgY3R4IG1hcmtzIGUgcmVtXG4gIHwgVE1hdGNoIF8gLT4geCA6OiByZW1cblxuYW5kIGRlbHRhX2Rlc2MgY3R4IG1hcmtzIGwgcmVtID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmVtXG4gIHwgeSA6OiByIC0+IGRlbHRhX2UgY3R4IG1hcmtzIHkgKGRlbHRhX2Rlc2MgY3R4IG1hcmtzIHIgcmVtKVxuOztcblxubGV0IGRlbHRhICh0YmxfcmVmIDogV29ya2luZ19hcmVhLnQpIG5leHRfY2F0IGNoYXIgKHN0IDogU3RhdGUudCkgPVxuICBsZXQgZXhwciA9XG4gICAgbGV0IHByZXZfY2F0ID0gc3QuY2F0ZWdvcnkgaW5cbiAgICBsZXQgY3R4ID0geyBjID0gY2hhcjsgbmV4dF9jYXQ7IHByZXZfY2F0IH0gaW5cbiAgICByZW1vdmVfZHVwbGljYXRlcyB0YmxfcmVmLnNlZW4gKGRlbHRhX2Rlc2MgY3R4IE1hcmtzLmVtcHR5IHN0LmRlc2MgW10pIEV4cHIuZXBzX2V4cHJcbiAgaW5cbiAgbGV0IGlkeCA9IFdvcmtpbmdfYXJlYS5mcmVlX2luZGV4IHRibF9yZWYgZXhwciBpblxuICBsZXQgZXhwciA9IERlc2Muc2V0X2lkeCBpZHggZXhwciBpblxuICBTdGF0ZS5tayBpZHggbmV4dF9jYXQgZXhwclxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxOTgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2J5dGVzX3NldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiUmVfQ3NldCIsIlN0ZGxpYl9DaGFyIiwiU3RkbGliX0J5dGVzIiwicmVwciIsInQiLCJjb2xvciIsImxlbmd0aCIsIlJlcHIiLCJnZXRfY2hhciIsImMiLCJnZXQiLCJ0cmFuc2xhdGVfY29sb3JzIiwiY20iLCJjc2V0IiwiaSIsImoiLCJsIiwic3RhcnQiLCJzdG9wIiwiVGFibGUiLCJtYWtlIiwicGFyYW0iLCJmbGF0dGVuIiwiY29sb3JfcmVwciIsInYiLCJzcGxpdCIsInNldCIsIlJlX0NvbG9yX21hcCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9yZS9jb2xvcl9tYXAubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0FBQUM7QUFBQUEsSUNnQndCLE9BQUgsbUJBQUcsOEJBQWtCO0FBQUE7QUFBQSxPQUFBQyxTRGhCMUMsK0JBQUFDLE9BQUE7QUFBQSxZQUFBQyxTQUFBSixHQUFBSztBQUFBQSxJQ3VCd0IsT0FBSCxtQkFBRywwQkFBYztBQUFBO0FBQUEsWUFBQUMsSUFBQU4sR0FBQUs7QUFBQUEsSUFDdEIsbUVBQWdEO0FBQUE7QUFBQSxZQUFBRSxpQkFBQUMsSUFBQUM7QUFBQUEsSUFHNUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQUMsR0FBQUMsR0FBQUM7QUFBQUE7QUFBQUEsZUFBQUMsUUFDYztBQUFBLGVBQUFDLE9BQ0Q7QUFBQSxxQkFDQTtBQUFBLGNBQXNCLHFDQUFFO0FBQUEsZUFBQztBQUFBO0FBQUEsT0FBQUMsUUQ5QjFDO0FBQUEsWUFBQUMsS0FBQUMsT0NrQ2MsMENBQXFCO0FBQUEsWUFBQUMsUUFBQVY7QUFBQUE7QUFBQUEsS0FBQUgsSUFHekI7QUFBQSxLQUFBYyxhQUNTO0FBQUEsS0FBQUMsSUFDakI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLFFBQUFWLElBQTZCO0FBQUE7QUFBQSxLQUV4Qix3Q0FBOEI7QUFBQSxLQUNqQyxxQkFBYztBQUFBLGVBQ1U7QUFBQSxLQUF4QjtBQUFBLGVBQW9DO0FBQUE7QUFBQSxnQkFFWjtBQUFBLE1BQTFCLGdEQUF3QjtBQUFBO0FBQUEsS0FGYztBQUFBO0FBQUEsR0FFMEI7QUFBQSxZQUFBVyxNQUFBckIsR0FBQXNCO0FBQUFBLElBS2hFO0FBQUE7QUFBQTtBQUFBLHNCQUFBWixHQUFBQztBQUFBQSxjQUNFLGtCQUFZO0FBQUEsY0FDQyxPQUFiLGtCQUFhLHFDQUF5QjtBQUFBLGVBQUM7QUFBQTtBQUFBLE9BQUFZLGVEdEQzQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogSW4gcmVhbGl0eSwgdGhpcyBjYW4gcmVhbGx5IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbCBhcnJheS5cblxuICAgVGhlIHJlcHJlc2VudGF0aW9uIGlzIGJlc3QgdGhvdWdodCBvZiBhcyBhIGxpc3Qgb2YgYWxsIGNoYXJzIGFsb25nIHdpdGggYVxuICAgZmxhZzpcblxuICAgKGEsIDApLCAoYiwgMSksIChjLCAwKSwgKGQsIDApLCAuLi5cblxuICAgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgY29sb3IgYXJlIHJlcHJlc2VudGVkIGJ5IHNlcXVuY2VzIG9mXG4gICBjaGFyYWN0ZXJzIHdpdGggdGhlIGZsYWcgc2V0IHRvIDAuXG4qKVxuXG50eXBlIHQgPSBCeXRlcy50XG5cbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCByZXByIHQgY29sb3IgPSB0LltDc2V0LnRvX2ludCBjb2xvcl1cbiAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGhcbmVuZFxuXG5tb2R1bGUgVGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgbGV0IGdldF9jaGFyIHQgYyA9IHQuW0NzZXQudG9faW50IGNdXG4gIGxldCBnZXQgdCBjID0gQ3NldC5vZl9jaGFyIChTdHJpbmcudW5zYWZlX2dldCB0IChDaGFyLmNvZGUgYykpXG5cbiAgbGV0IHRyYW5zbGF0ZV9jb2xvcnMgKGNtIDogdCkgY3NldCA9XG4gICAgQ3NldC5mb2xkX3JpZ2h0IGNzZXQgfmluaXQ6Q3NldC5lbXB0eSB+ZjooZnVuIGkgaiBsIC0+XG4gICAgICBsZXQgc3RhcnQgPSBnZXRfY2hhciBjbSBpIGluXG4gICAgICBsZXQgc3RvcCA9IGdldF9jaGFyIGNtIGogaW5cbiAgICAgIENzZXQudW5pb24gKENzZXQuY3NlcSBzdGFydCBzdG9wKSBsKVxuICA7O1xuZW5kXG5cbmxldCBtYWtlICgpID0gQnl0ZXMubWFrZSAyNTcgJ1xcMDAwJ1xuXG5sZXQgZmxhdHRlbiBjbSA9XG4gIGxldCBjID0gQnl0ZXMuY3JlYXRlIDI1NiBpblxuICBsZXQgY29sb3JfcmVwciA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IHYgPSByZWYgMCBpblxuICBCeXRlcy5zZXQgYyAwICdcXDAwMCc7XG4gIEJ5dGVzLnNldCBjb2xvcl9yZXByIDAgJ1xcMDAwJztcbiAgZm9yIGkgPSAxIHRvIDI1NSBkb1xuICAgIGlmIEJ5dGVzLmdldCBjbSBpIDw+ICdcXDAwMCcgdGhlbiBpbmNyIHY7XG4gICAgQnl0ZXMuc2V0IGMgaSAoQ2hhci5jaHIgIXYpO1xuICAgIEJ5dGVzLnNldCBjb2xvcl9yZXByICF2IChDaGFyLmNociBpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGMsIEJ5dGVzLnN1Yl9zdHJpbmcgY29sb3JfcmVwciAwICghdiArIDEpXG47O1xuXG4oKiBtYXJrIGFsbCB0aGUgZW5kcG9pbnRzIG9mIHRoZSBpbnRlcnZhbHMgb2YgdGhlIGNoYXIgc2V0IHdpdGggdGhlIDEgYnl0ZSAqKVxubGV0IHNwbGl0IHQgc2V0ID1cbiAgQ3NldC5pdGVyIHNldCB+ZjooZnVuIGkgaiAtPlxuICAgIEJ5dGVzLnNldCB0IChDc2V0LnRvX2ludCBpKSAnXFwwMDEnO1xuICAgIEJ5dGVzLnNldCB0IChDc2V0LnRvX2ludCBqICsgMSkgJ1xcMDAxJylcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjA3MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X1JlX3JlcG4iLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDciLCJhNCIsImE1IiwiYTYiLCJnbG9iYWxfZGF0YSIsInMiLCJlbXB0eV9hbHRlcm5hdGl2ZSIsIlJlX0ZtdCIsIlN0ZGxpYl9Gb3JtYXQiLCJSZV9QbWFyayIsIlJlX0F1dG9tYXRhIiwiUmVfQ3NldCIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiUmVfSW1wb3J0IiwiU3RkbGliIiwiUmVfQ29sb3JfbWFwIiwiU3RkbGliX1N0cmluZyIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0J1ZmZlciIsImNzdF9BbHRlcm5hdGl2ZSIsImNzdF9Ob19jYXNlIiwiY3N0X0Nhc2UiLCJjc3RfQmVnX29mX2xpbmUiLCJjc3RfRW5kX29mX2xpbmUiLCJjc3RfQmVnX29mX3dvcmQiLCJjc3RfRW5kX29mX3dvcmQiLCJjc3RfTm90X2JvdW5kIiwiY3N0X0JlZ19vZl9zdHIiLCJjc3RfRW5kX29mX3N0ciIsImNzdF9MYXN0X2VuZF9vZl9saW5lIiwiY3N0X1N0YXJ0IiwiY3N0X1N0b3AiLCJjc3RfUmVwZWF0IiwiY3N0X05hbWVkX2dyb3VwIiwiY3N0X0dyb3VwIiwiY3N0X05vX2dyb3VwIiwiY3N0X05lc3QiLCJjc3RfUG1hcmsiLCJjc3RfU2VtIiwiY3N0X1NlbV9ncmVlZHkiLCJjc3RfU2V0IiwiY3N0X0ludGVyc2VjdGlvbiIsImNzdF9Db21wbGVtZW50IiwiY3N0X0RpZmZlcmVuY2UiLCJwcF9hc3QiLCJmbXQiLCJhc3QiLCJ2YXIiLCJyZSIsImFsdCIsImMiLCJwcF9nZW4iLCJwcF9jc2V0IiwidCIsInBwIiwiY3NldCIsImEiLCJyZWwiLCJzdG9wIiwic3RhcnQiLCJwYXJhbSIsIm1hdGNoIiwibiIsInIiLCJtIiwic2VtIiwiayIsInNlcSIsImIiLCJlcXVhbCIsIngxIiwieDIiLCJzMiIsInMxIiwieSIsIngiLCJlcSIsImwyIiwibDEiLCJqMiIsImkyIiwiajEiLCJpMSIsInIyIiwibTIiLCJyMSIsIm0xIiwicmVwIiwiaGFuZGxlX2Nhc2VfY3NldCIsImlnbl9jYXNlIiwibCIsImhhbmRsZV9jYXNlIiwiaiIsImkiLCJjaGFyIiwiYW55Iiwic3RyIiwiYXNfc2V0X2VsZW1zIiwiZWxlbXMiLCJlIiwiZW1wdHkiLCJlcHNpbG9uIiwicmVwbiIsInJlcDEiLCJvcHQiLCJib3ciLCJlb3ciLCJ3b3JkIiwiYm9zIiwiZW9zIiwid2hvbGVfc3RyaW5nIiwiY3N0X1JlX2ludGVyIiwiY3N0X1JlX2NvbXBsIiwiY3N0X1JlX2RpZmYiLCJtYWtlX3NldCIsInByZXNlcnZlX3NldCIsImxvbmdlc3QiLCJzaG9ydGVzdCIsImZpcnN0IiwiZ3JlZWR5Iiwibm9uX2dyZWVkeSIsImdyb3VwIiwibmFtZSIsIm5vX2dyb3VwIiwibmVzdCIsInNldCIsIm1hcmsiLCJhc19zZXRfb3JfZXJyb3IiLCJpbnRlciIsImNvbXBsIiwiZGlmZiIsImNhc2UiLCJub19jYXNlIiwid2l0bmVzcyIsInhzIiwiZnJvbSIsInciLCJtZXJnZV9zZXF1ZW5jZXMiLCJjb2xvcml6ZSIsImNvbG9yX21hcCIsInJlZ2V4cCIsImxubCIsImFuY2hvcmVkIiwiYWxzIiwidF9vZl9jc2V0IiwiUmVfQXN0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL2FzdC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLElBQUE7QUFBQSxJQUFBbkIsTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBb0Isb0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQzZIdUI7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFB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cmF0ZWQgY29kZSAqKSIsIm9wZW4gSW1wb3J0XG5cbnR5cGUgKCdhLCBfKSBhc3QgPVxuICB8IEFsdGVybmF0aXZlIDogJ2EgbGlzdCAtPiAoJ2EsIFs+IGBVbmNhc2VkIF0pIGFzdFxuICB8IE5vX2Nhc2UgOiAnYSAtPiAoJ2EsIFs+IGBDYXNlZCBdKSBhc3RcbiAgfCBDYXNlIDogJ2EgLT4gKCdhLCBbPiBgQ2FzZWQgXSkgYXN0XG5cbmxldCBlbXB0eV9hbHRlcm5hdGl2ZSA6ICgnYSwgJ2IpIGFzdCA9IEFsdGVybmF0aXZlIFtdXG5cbmxldCBlcXVhbF9hc3QgKHR5cGUgYSkgZXEgKHggOiAoYSwgWyBgVW5jYXNlZCBdKSBhc3QpICh5IDogKGEsIFsgYFVuY2FzZWQgXSkgYXN0KSA9XG4gIG1hdGNoIHgsIHkgd2l0aFxuICB8IEFsdGVybmF0aXZlIGEsIEFsdGVybmF0aXZlIGIgLT4gTGlzdC5lcXVhbCB+ZXEgYSBiXG47O1xuXG5sZXQgcHBfYXN0ICh0eXBlIGEgYikgZiBmbXQgKGFzdCA6IChhLCBiKSBhc3QpID1cbiAgbGV0IG9wZW4gRm10IGluXG4gIGxldCB2YXIgcyByZSA9IHNleHAgZm10IHMgZiByZSBpblxuICBtYXRjaCBhc3Qgd2l0aFxuICB8IEFsdGVybmF0aXZlIGFsdCAtPiBzZXhwIGZtdCBcIkFsdGVybmF0aXZlXCIgKGxpc3QgZikgYWx0XG4gIHwgQ2FzZSBjIC0+IHZhciBcIkNhc2VcIiBjXG4gIHwgTm9fY2FzZSBjIC0+IHZhciBcIk5vX2Nhc2VcIiBjXG47O1xuXG50eXBlIGNzZXQgPVxuICB8IENzZXQgb2YgQ3NldC50XG4gIHwgSW50ZXJzZWN0aW9uIG9mIGNzZXQgbGlzdFxuICB8IENvbXBsZW1lbnQgb2YgY3NldCBsaXN0XG4gIHwgRGlmZmVyZW5jZSBvZiBjc2V0ICogY3NldFxuICB8IENhc3Qgb2YgKGNzZXQsIFsgYENhc2VkIHwgYFVuY2FzZWQgXSkgYXN0XG5cbnR5cGUgKCdhLCAnY2FzZSkgZ2VuID1cbiAgfCBTZXQgb2YgJ2FcbiAgfCBBc3Qgb2YgKCgnYSwgJ2Nhc2UpIGdlbiwgJ2Nhc2UpIGFzdFxuICB8IFNlcXVlbmNlIG9mICgnYSwgJ2Nhc2UpIGdlbiBsaXN0XG4gIHwgUmVwZWF0IG9mICgnYSwgJ2Nhc2UpIGdlbiAqIGludCAqIGludCBvcHRpb25cbiAgfCBCZWdfb2ZfbGluZVxuICB8IEVuZF9vZl9saW5lXG4gIHwgQmVnX29mX3dvcmRcbiAgfCBFbmRfb2Zfd29yZFxuICB8IE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHJcbiAgfCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0YXJ0XG4gIHwgU3RvcFxuICB8IEdyb3VwIG9mIHN0cmluZyBvcHRpb24gKiAoJ2EsICdjYXNlKSBnZW5cbiAgfCBOb19ncm91cCBvZiAoJ2EsICdjYXNlKSBnZW5cbiAgfCBOZXN0IG9mICgnYSwgJ2Nhc2UpIGdlblxuICB8IFBtYXJrIG9mIFBtYXJrLnQgKiAoJ2EsICdjYXNlKSBnZW5cbiAgfCBTZW0gb2YgQXV0b21hdGEuU2VtLnQgKiAoJ2EsICdjYXNlKSBnZW5cbiAgfCBTZW1fZ3JlZWR5IG9mIEF1dG9tYXRhLlJlcF9raW5kLnQgKiAoJ2EsICdjYXNlKSBnZW5cblxubGV0IHJlYyBwcF9nZW4gcHBfY3NldCBmbXQgdCA9XG4gIGxldCBvcGVuIEZvcm1hdCBpblxuICBsZXQgb3BlbiBGbXQgaW5cbiAgbGV0IHBwID0gcHBfZ2VuIHBwX2NzZXQgaW5cbiAgbGV0IHZhciBzIHJlID0gc2V4cCBmbXQgcyBwcCByZSBpblxuICBsZXQgc2VxIHMgcmVsID0gc2V4cCBmbXQgcyAobGlzdCBwcCkgcmVsIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNldCBjc2V0IC0+IHBwX2NzZXQgZm10IGNzZXRcbiAgfCBTZXF1ZW5jZSBzcSAtPiBzZXEgXCJTZXF1ZW5jZVwiIHNxXG4gIHwgUmVwZWF0IChyZSwgc3RhcnQsIHN0b3ApIC0+XG4gICAgbGV0IHBwJyBmbXQgKCkgPSBmcHJpbnRmIGZtdCBcIiVhQCAlZCVhXCIgcHAgcmUgc3RhcnQgb3B0aW50IHN0b3AgaW5cbiAgICBzZXhwIGZtdCBcIlJlcGVhdFwiIHBwJyAoKVxuICB8IEJlZ19vZl9saW5lIC0+IHN0ciBmbXQgXCJCZWdfb2ZfbGluZVwiXG4gIHwgRW5kX29mX2xpbmUgLT4gc3RyIGZtdCBcIkVuZF9vZl9saW5lXCJcbiAgfCBCZWdfb2Zfd29yZCAtPiBzdHIgZm10IFwiQmVnX29mX3dvcmRcIlxuICB8IEVuZF9vZl93b3JkIC0+IHN0ciBmbXQgXCJFbmRfb2Zfd29yZFwiXG4gIHwgTm90X2JvdW5kIC0+IHN0ciBmbXQgXCJOb3RfYm91bmRcIlxuICB8IEJlZ19vZl9zdHIgLT4gc3RyIGZtdCBcIkJlZ19vZl9zdHJcIlxuICB8IEVuZF9vZl9zdHIgLT4gc3RyIGZtdCBcIkVuZF9vZl9zdHJcIlxuICB8IExhc3RfZW5kX29mX2xpbmUgLT4gc3RyIGZtdCBcIkxhc3RfZW5kX29mX2xpbmVcIlxuICB8IFN0YXJ0IC0+IHN0ciBmbXQgXCJTdGFydFwiXG4gIHwgU3RvcCAtPiBzdHIgZm10IFwiU3RvcFwiXG4gIHwgR3JvdXAgKE5vbmUsIGMpIC0+IHZhciBcIkdyb3VwXCIgY1xuICB8IEdyb3VwIChTb21lIG4sIGMpIC0+IHNleHAgZm10IFwiTmFtZWRfZ3JvdXBcIiAocGFpciBzdHIgcHApIChuLCBjKVxuICB8IE5lc3QgYyAtPiB2YXIgXCJOZXN0XCIgY1xuICB8IFBtYXJrIChtLCByKSAtPiBzZXhwIGZtdCBcIlBtYXJrXCIgKHBhaXIgUG1hcmsucHAgcHApIChtLCByKVxuICB8IEFzdCBhIC0+IHBwX2FzdCBwcCBmbXQgYVxuICB8IFNlbSAoc2VtLCBhKSAtPiBzZXhwIGZtdCBcIlNlbVwiIChwYWlyIEF1dG9tYXRhLlNlbS5wcCBwcCkgKHNlbSwgYSlcbiAgfCBTZW1fZ3JlZWR5IChrLCByZSkgLT4gc2V4cCBmbXQgXCJTZW1fZ3JlZWR5XCIgKHBhaXIgQXV0b21hdGEuUmVwX2tpbmQucHAgcHApIChrLCByZSlcbiAgfCBOb19ncm91cCBjIC0+IHZhciBcIk5vX2dyb3VwXCIgY1xuOztcblxubGV0IHJlYyBwcF9jc2V0IGZtdCBjc2V0ID1cbiAgbGV0IG9wZW4gRm10IGluXG4gIGxldCBzZXEgcyByZWwgPSBzZXhwIGZtdCBzIChsaXN0IHBwX2NzZXQpIHJlbCBpblxuICBtYXRjaCBjc2V0IHdpdGhcbiAgfCBDYXN0IHMgLT4gcHBfYXN0IHBwX2NzZXQgZm10IHNcbiAgfCBDc2V0IHMgLT4gc2V4cCBmbXQgXCJTZXRcIiBDc2V0LnBwIHNcbiAgfCBJbnRlcnNlY3Rpb24gYyAtPiBzZXEgXCJJbnRlcnNlY3Rpb25cIiBjXG4gIHwgQ29tcGxlbWVudCBjIC0+IHNlcSBcIkNvbXBsZW1lbnRcIiBjXG4gIHwgRGlmZmVyZW5jZSAoYSwgYikgLT4gc2V4cCBmbXQgXCJEaWZmZXJlbmNlXCIgKHBhaXIgcHBfY3NldCBwcF9jc2V0KSAoYSwgYilcbjs7XG5cbmxldCByZWMgZXF1YWwgY3NldCB4MSB4MiA9XG4gIG1hdGNoIHgxLCB4MiB3aXRoXG4gIHwgU2V0IHMxLCBTZXQgczIgLT4gY3NldCBzMSBzMlxuICB8IFNlcXVlbmNlIGwxLCBTZXF1ZW5jZSBsMiAtPiBMaXN0LmVxdWFsIH5lcTooZXF1YWwgY3NldCkgbDEgbDJcbiAgfCBSZXBlYXQgKHgxJywgaTEsIGoxKSwgUmVwZWF0ICh4MicsIGkyLCBqMikgLT5cbiAgICBJbnQuZXF1YWwgaTEgaTIgJiYgT3B0aW9uLmVxdWFsIEludC5lcXVhbCBqMSBqMiAmJiBlcXVhbCBjc2V0IHgxJyB4MidcbiAgfCBCZWdfb2ZfbGluZSwgQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZSwgRW5kX29mX2xpbmVcbiAgfCBCZWdfb2Zfd29yZCwgQmVnX29mX3dvcmRcbiAgfCBFbmRfb2Zfd29yZCwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmQsIE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHIsIEJlZ19vZl9zdHJcbiAgfCBFbmRfb2Zfc3RyLCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0YXJ0LCBTdGFydFxuICB8IFN0b3AsIFN0b3AgLT4gdHJ1ZVxuICB8IEdyb3VwIF8sIEdyb3VwIF8gLT5cbiAgICAoKiBEbyBub3QgbWVyZ2UgZ3JvdXBzISAqKVxuICAgIGZhbHNlXG4gIHwgUG1hcmsgKG0xLCByMSksIFBtYXJrIChtMiwgcjIpIC0+IFBtYXJrLmVxdWFsIG0xIG0yICYmIGVxdWFsIGNzZXQgcjEgcjJcbiAgfCBOZXN0IHgsIE5lc3QgeSAtPiBlcXVhbCBjc2V0IHggeVxuICB8IEFzdCB4LCBBc3QgeSAtPiBlcXVhbF9hc3QgKGVxdWFsIGNzZXQpIHggeVxuICB8IFNlbSAoc2VtLCBhKSwgU2VtIChzZW0nLCBhJykgLT4gUG9seS5lcXVhbCBzZW0gc2VtJyAmJiBlcXVhbCBjc2V0IGEgYSdcbiAgfCBTZW1fZ3JlZWR5IChyZXAsIGEpLCBTZW1fZ3JlZWR5IChyZXAnLCBhJykgLT4gUG9seS5lcXVhbCByZXAgcmVwJyAmJiBlcXVhbCBjc2V0IGEgYSdcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG50eXBlIHQgPSAoY3NldCwgWyBgQ2FzZWQgfCBgVW5jYXNlZCBdKSBnZW5cbnR5cGUgbm9fY2FzZSA9IChDc2V0LnQsIFsgYFVuY2FzZWQgXSkgZ2VuXG5cbmxldCBwcCA9IHBwX2dlbiBwcF9jc2V0XG5sZXQgY3NldCBjc2V0ID0gU2V0IChDc2V0IGNzZXQpXG5cbmxldCByZWMgaGFuZGxlX2Nhc2VfY3NldCBpZ25fY2FzZSA9IGZ1bmN0aW9uXG4gIHwgQ3NldCBzIC0+IGlmIGlnbl9jYXNlIHRoZW4gQ3NldC5jYXNlX2luc2VucyBzIGVsc2Ugc1xuICB8IENhc3QgKEFsdGVybmF0aXZlIGwpIC0+IExpc3QubWFwIH5mOihoYW5kbGVfY2FzZV9jc2V0IGlnbl9jYXNlKSBsIHw+IENzZXQudW5pb25fYWxsXG4gIHwgQ29tcGxlbWVudCBsIC0+XG4gICAgTGlzdC5tYXAgfmY6KGhhbmRsZV9jYXNlX2NzZXQgaWduX2Nhc2UpIGwgfD4gQ3NldC51bmlvbl9hbGwgfD4gQ3NldC5kaWZmIENzZXQuY2FueVxuICB8IERpZmZlcmVuY2UgKHIsIHInKSAtPlxuICAgIENzZXQuaW50ZXJcbiAgICAgIChoYW5kbGVfY2FzZV9jc2V0IGlnbl9jYXNlIHIpXG4gICAgICAoQ3NldC5kaWZmIENzZXQuY2FueSAoaGFuZGxlX2Nhc2VfY3NldCBpZ25fY2FzZSByJykpXG4gIHwgSW50ZXJzZWN0aW9uIGwgLT4gTGlzdC5tYXAgfmY6KGhhbmRsZV9jYXNlX2NzZXQgaWduX2Nhc2UpIGwgfD4gQ3NldC5pbnRlcnNlY3RfYWxsXG4gIHwgQ2FzdCAoTm9fY2FzZSBhKSAtPiBoYW5kbGVfY2FzZV9jc2V0IHRydWUgYVxuICB8IENhc3QgKENhc2UgYSkgLT4gaGFuZGxlX2Nhc2VfY3NldCBmYWxzZSBhXG47O1xuXG5sZXQgcmVjIGhhbmRsZV9jYXNlIGlnbl9jYXNlIDogdCAtPiAoQ3NldC50LCBbIGBVbmNhc2VkIF0pIGdlbiA9IGZ1bmN0aW9uXG4gIHwgU2V0IHMgLT4gU2V0IChoYW5kbGVfY2FzZV9jc2V0IGlnbl9jYXNlIHMpXG4gIHwgU2VxdWVuY2UgbCAtPiBTZXF1ZW5jZSAoTGlzdC5tYXAgfmY6KGhhbmRsZV9jYXNlIGlnbl9jYXNlKSBsKVxuICB8IEFzdCAoQWx0ZXJuYXRpdmUgbCkgLT5cbiAgICBsZXQgbCA9IExpc3QubWFwIH5mOihoYW5kbGVfY2FzZSBpZ25fY2FzZSkgbCBpblxuICAgIEFzdCAoQWx0ZXJuYXRpdmUgbClcbiAgfCBSZXBlYXQgKHIsIGksIGopIC0+IFJlcGVhdCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UgciwgaSwgailcbiAgfCAoIEJlZ19vZl9saW5lXG4gICAgfCBFbmRfb2ZfbGluZVxuICAgIHwgQmVnX29mX3dvcmRcbiAgICB8IEVuZF9vZl93b3JkXG4gICAgfCBOb3RfYm91bmRcbiAgICB8IEJlZ19vZl9zdHJcbiAgICB8IEVuZF9vZl9zdHJcbiAgICB8IExhc3RfZW5kX29mX2xpbmVcbiAgICB8IFN0YXJ0XG4gICAgfCBTdG9wICkgYXMgciAtPiByXG4gIHwgU2VtIChrLCByKSAtPiBTZW0gKGssIGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG4gIHwgU2VtX2dyZWVkeSAoaywgcikgLT4gU2VtX2dyZWVkeSAoaywgaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcilcbiAgfCBHcm91cCAobiwgcikgLT4gR3JvdXAgKG4sIGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG4gIHwgTm9fZ3JvdXAgciAtPiBOb19ncm91cCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcilcbiAgfCBOZXN0IHIgLT4gTmVzdCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcilcbiAgfCBBc3QgKENhc2UgcikgLT4gaGFuZGxlX2Nhc2UgZmFsc2UgclxuICB8IEFzdCAoTm9fY2FzZSByKSAtPiBoYW5kbGVfY2FzZSB0cnVlIHJcbiAgfCBQbWFyayAoaSwgcikgLT4gUG1hcmsgKGksIGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG47O1xuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHBwID0gcHBcblxuICBsZXQgc2VxID0gZnVuY3Rpb25cbiAgICB8IFsgciBdIC0+IHJcbiAgICB8IGwgLT4gU2VxdWVuY2UgbFxuICA7O1xuXG4gIGxldCBjaGFyIGMgOiB0ID0gY3NldCAoQ3NldC5jc2luZ2xlIGMpXG4gIGxldCBhbnkgPSBjc2V0IENzZXQuY2FueVxuXG4gIGxldCBzdHIgcyA6IHQgPVxuICAgIGxldCBsID0gcmVmIFtdIGluXG4gICAgZm9yIGkgPSBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgICBsIDo9IGNoYXIgcy5baV0gOjogIWxcbiAgICBkb25lO1xuICAgIHNlcSAhbFxuICA7O1xuXG4gIGxldCBhc19zZXRfZWxlbXMgZWxlbXMgPVxuICAgIG1hdGNoXG4gICAgICBMaXN0Lm1hcCBlbGVtcyB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBTZXQgZSAtPiBlXG4gICAgICAgIHwgXyAtPiByYWlzZV9ub3RyYWNlIEV4aXQpXG4gICAgd2l0aFxuICAgIHwgZXhjZXB0aW9uIEV4aXQgLT4gTm9uZVxuICAgIHwgZSAtPiBTb21lIGVcbiAgOztcblxuICBsZXQgZW1wdHkgOiB0ID0gQXN0IGVtcHR5X2FsdGVybmF0aXZlXG5cbiAgbGV0IGFsdCAoZWxlbXMgOiB0IGxpc3QpIDogdCA9XG4gICAgbWF0Y2ggZWxlbXMgd2l0aFxuICAgIHwgW10gLT4gZW1wdHlcbiAgICB8IFsgeCBdIC0+IHhcbiAgICB8IF8gLT5cbiAgICAgIChtYXRjaCBhc19zZXRfZWxlbXMgZWxlbXMgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBBc3QgKEFsdGVybmF0aXZlIGVsZW1zKVxuICAgICAgIHwgU29tZSBlbGVtcyAtPiBTZXQgKENhc3QgKEFsdGVybmF0aXZlIGVsZW1zKSkpXG4gIDs7XG5cbiAgbGV0IGVwc2lsb24gPSBzZXEgW11cblxuICBsZXQgcmVwbiByIGkgaiA9XG4gICAgaWYgaSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnJlcG5cIjtcbiAgICBtYXRjaCBqLCBpIHdpdGhcbiAgICB8IFNvbWUgaiwgXyB3aGVuIGogPCBpIC0+IGludmFsaWRfYXJnIFwiUmUucmVwblwiXG4gICAgfCBTb21lIDAsIDAgLT4gZXBzaWxvblxuICAgIHwgU29tZSAxLCAxIC0+IHJcbiAgICB8IF8gLT4gUmVwZWF0IChyLCBpLCBqKVxuICA7O1xuXG4gIGxldCByZXAgciA9IHJlcG4gciAwIE5vbmVcbiAgbGV0IHJlcDEgciA9IHJlcG4gciAxIE5vbmVcbiAgbGV0IG9wdCByID0gcmVwbiByIDAgKFNvbWUgMSlcbiAgbGV0IGJvbCA9IEJlZ19vZl9saW5lXG4gIGxldCBlb2wgPSBFbmRfb2ZfbGluZVxuICBsZXQgYm93ID0gQmVnX29mX3dvcmRcbiAgbGV0IGVvdyA9IEVuZF9vZl93b3JkXG4gIGxldCB3b3JkIHIgPSBzZXEgWyBib3c7IHI7IGVvdyBdXG4gIGxldCBub3RfYm91bmRhcnkgPSBOb3RfYm91bmRcbiAgbGV0IGJvcyA9IEJlZ19vZl9zdHJcbiAgbGV0IGVvcyA9IEVuZF9vZl9zdHJcbiAgbGV0IHdob2xlX3N0cmluZyByID0gc2VxIFsgYm9zOyByOyBlb3MgXVxuICBsZXQgbGVvbCA9IExhc3RfZW5kX29mX2xpbmVcbiAgbGV0IHN0YXJ0ID0gU3RhcnRcbiAgbGV0IHN0b3AgPSBTdG9wXG5cbiAgdHlwZSAnYiBmID0geyBmIDogJ2EuICdhIC0+ICgnYSwgJ2IpIGFzdCB9XG5cbiAgbGV0IG1ha2Vfc2V0IGYgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBTZXQgeCAtPiBTZXQgKENhc3QgKGYuZiB4KSlcbiAgICB8IF8gLT4gQXN0IChmLmYgdClcbiAgOztcblxuICBsZXQgcHJlc2VydmVfc2V0IGYgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBTZXQgXyAtPiB0XG4gICAgfCBfIC0+IGYgdFxuICA7O1xuXG4gIGxldCBsb25nZXN0ID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBTZW0gKGBMb25nZXN0LCB0KSlcbiAgbGV0IHNob3J0ZXN0ID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBTZW0gKGBTaG9ydGVzdCwgdCkpXG4gIGxldCBmaXJzdCA9IHByZXNlcnZlX3NldCAoZnVuIHQgLT4gU2VtIChgRmlyc3QsIHQpKVxuICBsZXQgZ3JlZWR5ID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBTZW1fZ3JlZWR5IChgR3JlZWR5LCB0KSlcbiAgbGV0IG5vbl9ncmVlZHkgPSBwcmVzZXJ2ZV9zZXQgKGZ1biB0IC0+IFNlbV9ncmVlZHkgKGBOb25fZ3JlZWR5LCB0KSlcbiAgbGV0IGdyb3VwID9uYW1lIHIgPSBHcm91cCAobmFtZSwgcilcbiAgbGV0IG5vX2dyb3VwID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBOb19ncm91cCB0KVxuICBsZXQgbmVzdCByID0gTmVzdCByXG4gIGxldCBzZXQgc3RyID0gY3NldCAoQ3NldC5zZXQgc3RyKVxuXG4gIGxldCBtYXJrIHIgPVxuICAgIGxldCBpID0gUG1hcmsuZ2VuICgpIGluXG4gICAgaSwgUG1hcmsgKGksIHIpXG4gIDs7XG5cbiAgKCoqKiogQ2hhcmFjdGVyIHNldHMgKioqKilcbiAgbGV0IGFzX3NldF9vcl9lcnJvciBuYW1lIGVsZW1zID1cbiAgICBtYXRjaCBhc19zZXRfZWxlbXMgZWxlbXMgd2l0aFxuICAgIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBuYW1lXG4gICAgfCBTb21lIHMgLT4gc1xuICA7O1xuXG4gIGxldCBpbnRlciBlbGVtcyA9IFNldCAoSW50ZXJzZWN0aW9uIChhc19zZXRfb3JfZXJyb3IgXCJSZS5pbnRlclwiIGVsZW1zKSlcbiAgbGV0IGNvbXBsIGVsZW1zID0gU2V0IChDb21wbGVtZW50IChhc19zZXRfb3JfZXJyb3IgXCJSZS5jb21wbFwiIGVsZW1zKSlcblxuICBsZXQgZGlmZiByIHInID1cbiAgICBtYXRjaCByLCByJyB3aXRoXG4gICAgfCBTZXQgciwgU2V0IHInIC0+IFNldCAoRGlmZmVyZW5jZSAociwgcicpKVxuICAgIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIlJlLmRpZmZcIlxuICA7O1xuXG4gIGxldCBjYXNlID1cbiAgICBsZXQgZiA9IHsgZiA9IChmdW4gciAtPiBDYXNlIHIpIH0gaW5cbiAgICBmdW4gdCAtPiBtYWtlX3NldCBmIHRcbiAgOztcblxuICBsZXQgbm9fY2FzZSA9XG4gICAgbGV0IGYgPSB7IGYgPSAoZnVuIHIgLT4gTm9fY2FzZSByKSB9IGluXG4gICAgZnVuIHQgLT4gbWFrZV9zZXQgZiB0XG4gIDs7XG5cbiAgbGV0IHdpdG5lc3MgdCA9XG4gICAgbGV0IHJlYyB3aXRuZXNzICh0IDogbm9fY2FzZSkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFNldCBjIC0+IFN0cmluZy5tYWtlIDEgKENzZXQudG9fY2hhciAoQ3NldC5waWNrIGMpKVxuICAgICAgfCBTZXF1ZW5jZSB4cyAtPiBTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QubWFwIH5mOndpdG5lc3MgeHMpXG4gICAgICB8IEFzdCAoQWx0ZXJuYXRpdmUgKHggOjogXykpIC0+IHdpdG5lc3MgeFxuICAgICAgfCBBc3QgKEFsdGVybmF0aXZlIFtdKSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgUmVwZWF0IChyLCBmcm9tLCBfdG8pIC0+XG4gICAgICAgIGxldCB3ID0gd2l0bmVzcyByIGluXG4gICAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCB3ICogZnJvbSkgaW5cbiAgICAgICAgZm9yIF9pID0gMSB0byBmcm9tIGRvXG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYiB3XG4gICAgICAgIGRvbmU7XG4gICAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gICAgICB8IE5vX2dyb3VwIHIgLT4gd2l0bmVzcyByXG4gICAgICB8IFNlbV9ncmVlZHkgKF8sIHIpIHwgU2VtIChfLCByKSB8IE5lc3QgciB8IFBtYXJrIChfLCByKSB8IEdyb3VwIChfLCByKSAtPiB3aXRuZXNzIHJcbiAgICAgIHwgQmVnX29mX2xpbmVcbiAgICAgIHwgRW5kX29mX2xpbmVcbiAgICAgIHwgQmVnX29mX3dvcmRcbiAgICAgIHwgRW5kX29mX3dvcmRcbiAgICAgIHwgTm90X2JvdW5kXG4gICAgICB8IEJlZ19vZl9zdHJcbiAgICAgIHwgTGFzdF9lbmRfb2ZfbGluZVxuICAgICAgfCBTdGFydFxuICAgICAgfCBTdG9wXG4gICAgICB8IEVuZF9vZl9zdHIgLT4gXCJcIlxuICAgIGluXG4gICAgd2l0bmVzcyAoaGFuZGxlX2Nhc2UgZmFsc2UgdClcbiAgOztcbmVuZFxuXG5vcGVuIEV4cG9ydFxuXG5sZXQgcmVjIG1lcmdlX3NlcXVlbmNlcyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCBBc3QgKEFsdGVybmF0aXZlIGwnKSA6OiByIC0+IG1lcmdlX3NlcXVlbmNlcyAobCcgQCByKVxuICB8IFNlcXVlbmNlICh4IDo6IHkpIDo6IHIgLT5cbiAgICAobWF0Y2ggbWVyZ2Vfc2VxdWVuY2VzIHIgd2l0aFxuICAgICB8IFNlcXVlbmNlICh4JyA6OiB5JykgOjogcicgd2hlbiBlcXVhbCBDc2V0LmVxdWFsIHggeCcgLT5cbiAgICAgICBTZXF1ZW5jZSBbIHg7IEFzdCAoQWx0ZXJuYXRpdmUgWyBzZXEgeTsgc2VxIHknIF0pIF0gOjogcidcbiAgICAgfCByJyAtPiBTZXF1ZW5jZSAoeCA6OiB5KSA6OiByJylcbiAgfCB4IDo6IHIgLT4geCA6OiBtZXJnZV9zZXF1ZW5jZXMgclxuOztcblxuKCpYWFggVXNlIGEgYmV0dGVyIGFsZ29yaXRobSBhbGxvd2luZyBub24tY29udGlndW91cyByZWdpb25zPyAqKVxuXG5sZXQgY29sb3JpemUgY29sb3JfbWFwIChyZWdleHAgOiBub19jYXNlKSA9XG4gIGxldCBsbmwgPSByZWYgZmFsc2UgaW5cbiAgbGV0IHJlYyBjb2xvcml6ZSByZWdleHAgPVxuICAgIG1hdGNoIChyZWdleHAgOiBub19jYXNlKSB3aXRoXG4gICAgfCBTZXQgcyAtPiBDb2xvcl9tYXAuc3BsaXQgY29sb3JfbWFwIHNcbiAgICB8IFNlcXVlbmNlIGwgLT4gTGlzdC5pdGVyIH5mOmNvbG9yaXplIGxcbiAgICB8IEFzdCAoQWx0ZXJuYXRpdmUgbCkgLT4gTGlzdC5pdGVyIH5mOmNvbG9yaXplIGxcbiAgICB8IFJlcGVhdCAociwgXywgXykgLT4gY29sb3JpemUgclxuICAgIHwgQmVnX29mX2xpbmUgfCBFbmRfb2ZfbGluZSAtPiBDb2xvcl9tYXAuc3BsaXQgY29sb3JfbWFwIENzZXQubmxcbiAgICB8IEJlZ19vZl93b3JkIHwgRW5kX29mX3dvcmQgfCBOb3RfYm91bmQgLT4gQ29sb3JfbWFwLnNwbGl0IGNvbG9yX21hcCBDc2V0LmN3b3JkXG4gICAgfCBCZWdfb2Zfc3RyIHwgRW5kX29mX3N0ciB8IFN0YXJ0IHwgU3RvcCAtPiAoKVxuICAgIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBsbmwgOj0gdHJ1ZVxuICAgIHwgTm9fZ3JvdXAgciB8IEdyb3VwIChfLCByKSB8IE5lc3QgciB8IFBtYXJrIChfLCByKSAtPiBjb2xvcml6ZSByXG4gICAgfCBTZW0gKF8sIHIpIHwgU2VtX2dyZWVkeSAoXywgcikgLT4gY29sb3JpemUgclxuICBpblxuICBjb2xvcml6ZSByZWdleHA7XG4gICFsbmxcbjs7XG5cbmxldCByZWMgYW5jaG9yZWRfYXN0IDogKHQsIF8pIGFzdCAtPiBib29sID0gZnVuY3Rpb25cbiAgfCBBbHRlcm5hdGl2ZSBhbHMgLT4gTGlzdC5mb3JfYWxsIH5mOmFuY2hvcmVkIGFsc1xuICB8IE5vX2Nhc2UgciB8IENhc2UgciAtPiBhbmNob3JlZCByXG5cbmFuZCBhbmNob3JlZCA6IHQgLT4gYm9vbCA9IGZ1bmN0aW9uXG4gIHwgQXN0IGEgLT4gYW5jaG9yZWRfYXN0IGFcbiAgfCBTZXF1ZW5jZSBsIC0+IExpc3QuZXhpc3RzIH5mOmFuY2hvcmVkIGxcbiAgfCBSZXBlYXQgKHIsIGksIF8pIC0+IGkgPiAwICYmIGFuY2hvcmVkIHJcbiAgfCBOb19ncm91cCByIHwgU2VtIChfLCByKSB8IFNlbV9ncmVlZHkgKF8sIHIpIHwgR3JvdXAgKF8sIHIpIHwgTmVzdCByIHwgUG1hcmsgKF8sIHIpIC0+XG4gICAgYW5jaG9yZWQgclxuICB8IFNldCBfXG4gIHwgQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkXG4gIHwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmRcbiAgfCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0b3AgLT4gZmFsc2VcbiAgfCBCZWdfb2Zfc3RyIHwgU3RhcnQgLT4gdHJ1ZVxuOztcblxubGV0IHRfb2ZfY3NldCB4ID0gU2V0IHhcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyODgxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJSZV9Bc3QiLCJTdGRsaWJfTGlzdExhYmVscyIsIlJlX0NzZXQiLCJmb2xkX3JpZ2h0IiwiZmlyc3QiLCJ0IiwibGFzdCIsIlJhbmdlIiwidmlldyIsImFjYyIsInJhbmdlIiwidmlld19hc3QiLCJhIiwicGFyYW0iLCJjc2V0Iiwic2V0Iiwic2V0cyIsInkiLCJ4IiwiYXN0IiwicyIsIm5hbWUiLCJwbWFyayIsInNlbSIsIlJlX1ZpZXciXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvdmlldy5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFDLE1BQUFDLEdDV2tCLFlBQU87QUFBQSxZQUFBQyxLQUFBRCxHQUNSLFlBQU07QUFBQSxPQUFBRSxRRFp2QjtBQUFBLFlBQUFDLEtBQUFIO0FBQUFBLElDZ0JJO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQUFELE9BQUFFLE1BQUFHO0FBQUFBO0FBQUFBLGVBQUEsTUFDeUQ7QUFBQSxlQUFBQyxRQUEzQjtBQUFBLGNBQzVCO0FBQUEsYUFBWSxFQUFDO0FBQUE7QUFBQSxZQUFBQyxTQUFBbEIsR0FBQVk7QUFBQUEsSUFtQ2pCO0FBQUE7QUFBQSxXQUFBTyxJQUFBLE1BQytCLG1EQUFlO0FBQUE7QUFBQSxXQUFBQSxNQUQ5QyxNQUV1QiwrQkFBSztBQUFBLG1CQUFBQSxNQUY1QixNQUdpQiw4QkFBSztBQUFBO0FBQUE7QUFBQSxZQUFBSixPQUFBSztBQUFBQSxJQVlBO0FBQUE7QUFBQTtBQUFBLFFBT0w7QUFBQTtBQUFBLFFBQ0E7QUFBQTtBQUFBLFFBQ0E7QUFBQTtBQUFBLFFBQ0E7QUFBQTtBQUFBLFFBQ0Y7QUFBQTtBQUFBLFFBQ0M7QUFBQTtBQUFBLFFBQ0E7QUFBQTtBQUFBLFFBQ007QUFBQTtBQUFBLFFBQ1g7QUFBQSxnQkFDRDtBQUFBO0FBQUEsSUFoQlk7QUFBQTtBQUFBLFdBQUFDLE9BQUE7QUFBQSxPQVJ0QjtBQUFBO0FBQUEsY0FBQUMsTUFBQSxTQUNjO0FBQUE7QUFBQSxjQUFBQyxPQURkO0FBQUEsVUFFb0MsK0RBQWdDO0FBQUE7QUFBQSxjQUFBQSxTQUZwRTtBQUFBLFVBR2dDLGlFQUFnQztBQUFBO0FBQUEsY0FBQUMsSUFIaEUsU0FBQUMsSUFBQSxlQUlvRDtBQUFBLFVBQWpCLDBDQUFlO0FBQUEsc0JBQUFDLE1BSmxELFNBS2MsK0JBdUJ3QjtBQUFBO0FBQUE7QUFBQSxXQUFBQyxJQXBCaEIsVUFFWCx5QkFBQUYsR0FBbUIsU0FBQyxLQWtCTztBQUFBO0FBQUEsV0FBQUUsTUFwQmhCLFVBS047QUFBQTtBQUFBLFdBQUFILE1BTE0sVUFBQUMsTUFBQSxVQUFBYixJQUFBO0FBQUEsT0FNQTtBQUFBO0FBQUEsV0FBQUEsTUFOQSxVQUFBZ0IsT0FBQSxVQWtCRDtBQUFBO0FBQUEsV0FBQVQsSUFsQkMsVUFpQk47QUFBQTtBQUFBLFdBQUFQLE1BakJNLFVBbUJWO0FBQUE7QUFBQSxXQUFBQSxNQW5CVSxVQUFBaUIsUUFBQSxVQW9CQTtBQUFBO0FBQUEsV0FBQVYsTUFwQkEsVUFBQVcsTUFBQSxVQUdKO0FBQUEsbUJBQUFYLE1BSEksVUFBQVcsUUFBQSxVQUlHO0FBQUE7QUFBQSxHQWdCYTtBQUFBLE9BQUFDLFVEeEZ4QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBJbXBvcnRcblxubW9kdWxlIENzZXQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDc2V0XG5cbiAgbW9kdWxlIFJhbmdlID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgZmlyc3QgOiBDaGFyLnRcbiAgICAgIDsgbGFzdCA6IENoYXIudFxuICAgICAgfVxuXG4gICAgbGV0IGZpcnN0IHQgPSB0LmZpcnN0XG4gICAgbGV0IGxhc3QgdCA9IHQubGFzdFxuICBlbmRcblxuICBsZXQgdmlldyB0ID1cbiAgICBmb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biBmaXJzdCBsYXN0IGFjYyAtPlxuICAgICAgbGV0IHJhbmdlID0geyBSYW5nZS5maXJzdCA9IENzZXQudG9fY2hhciBmaXJzdDsgbGFzdCA9IENzZXQudG9fY2hhciBsYXN0IH0gaW5cbiAgICAgIHJhbmdlIDo6IGFjYylcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2VtID0gQXV0b21hdGEuU2VtXG5tb2R1bGUgUmVwX2tpbmQgPSBBdXRvbWF0YS5SZXBfa2luZFxuXG50eXBlIHQgPVxuICB8IFNldCBvZiBDc2V0LnRcbiAgfCBTZXF1ZW5jZSBvZiBBc3QudCBsaXN0XG4gIHwgQWx0ZXJuYXRpdmUgb2YgQXN0LnQgbGlzdFxuICB8IFJlcGVhdCBvZiBBc3QudCAqIGludCAqIGludCBvcHRpb25cbiAgfCBCZWdfb2ZfbGluZVxuICB8IEVuZF9vZl9saW5lXG4gIHwgQmVnX29mX3dvcmRcbiAgfCBFbmRfb2Zfd29yZFxuICB8IE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHJcbiAgfCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0YXJ0XG4gIHwgU3RvcFxuICB8IFNlbSBvZiBBdXRvbWF0YS5TZW0udCAqIEFzdC50XG4gIHwgU2VtX2dyZWVkeSBvZiBBdXRvbWF0YS5SZXBfa2luZC50ICogQXN0LnRcbiAgfCBHcm91cCBvZiBzdHJpbmcgb3B0aW9uICogQXN0LnRcbiAgfCBOb19ncm91cCBvZiBBc3QudFxuICB8IE5lc3Qgb2YgQXN0LnRcbiAgfCBDYXNlIG9mIEFzdC50XG4gIHwgTm9fY2FzZSBvZiBBc3QudFxuICB8IEludGVyc2VjdGlvbiBvZiBBc3QudCBsaXN0XG4gIHwgQ29tcGxlbWVudCBvZiBBc3QudCBsaXN0XG4gIHwgRGlmZmVyZW5jZSBvZiBBc3QudCAqIEFzdC50XG4gIHwgUG1hcmsgb2YgUG1hcmsudCAqIEFzdC50XG5cbmxldCB2aWV3X2FzdCBmICh0IDogXyBBc3QuYXN0KSA6IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBBbHRlcm5hdGl2ZSBhIC0+IEFsdGVybmF0aXZlIChMaXN0Lm1hcCB+ZiBhKVxuICB8IE5vX2Nhc2UgYSAtPiBOb19jYXNlIChmIGEpXG4gIHwgQ2FzZSBhIC0+IENhc2UgKGYgYSlcbjs7XG5cbmxldCB2aWV3X3NldCAoY3NldCA6IEFzdC5jc2V0KSA6IHQgPVxuICBtYXRjaCBjc2V0IHdpdGhcbiAgfCBDc2V0IHNldCAtPiBTZXQgc2V0XG4gIHwgSW50ZXJzZWN0aW9uIHNldHMgLT4gSW50ZXJzZWN0aW9uIChMaXN0Lm1hcCBzZXRzIH5mOkFzdC50X29mX2NzZXQpXG4gIHwgQ29tcGxlbWVudCBzZXRzIC0+IENvbXBsZW1lbnQgKExpc3QubWFwIHNldHMgfmY6QXN0LnRfb2ZfY3NldClcbiAgfCBEaWZmZXJlbmNlICh4LCB5KSAtPiBEaWZmZXJlbmNlIChBc3QudF9vZl9jc2V0IHgsIEFzdC50X29mX2NzZXQgeSlcbiAgfCBDYXN0IGFzdCAtPiB2aWV3X2FzdCBBc3QudF9vZl9jc2V0IGFzdFxuOztcblxubGV0IHZpZXcgOiBBc3QudCAtPiB0ID0gZnVuY3Rpb25cbiAgfCBTZXQgcyAtPiB2aWV3X3NldCBzXG4gIHwgQXN0IHMgLT4gdmlld19hc3QgKGZ1biB4IC0+IHgpIHNcbiAgfCBTZW0gKHNlbSwgYSkgLT4gU2VtIChzZW0sIGEpXG4gIHwgU2VtX2dyZWVkeSAoc2VtLCBhKSAtPiBTZW1fZ3JlZWR5IChzZW0sIGEpXG4gIHwgU2VxdWVuY2UgcyAtPiBTZXF1ZW5jZSBzXG4gIHwgUmVwZWF0ICh0LCB4LCB5KSAtPiBSZXBlYXQgKHQsIHgsIHkpXG4gIHwgQmVnX29mX2xpbmUgLT4gQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZSAtPiBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkIC0+IEJlZ19vZl93b3JkXG4gIHwgRW5kX29mX3dvcmQgLT4gRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmQgLT4gTm90X2JvdW5kXG4gIHwgQmVnX29mX3N0ciAtPiBCZWdfb2Zfc3RyXG4gIHwgRW5kX29mX3N0ciAtPiBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBMYXN0X2VuZF9vZl9saW5lXG4gIHwgU3RhcnQgLT4gU3RhcnRcbiAgfCBTdG9wIC0+IFN0b3BcbiAgfCBOb19ncm91cCBhIC0+IE5vX2dyb3VwIGFcbiAgfCBHcm91cCAobmFtZSwgdCkgLT4gR3JvdXAgKG5hbWUsIHQpXG4gIHwgTmVzdCB0IC0+IE5lc3QgdFxuICB8IFBtYXJrIChwbWFyaywgdCkgLT4gUG1hcmsgKHBtYXJrLCB0KVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOTk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9tYWtlX3ZlY3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJkdW1teV9vZmZzZXQiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX0FycmF5IiwiUmVfRm10IiwiU3RkbGliX1N0cmluZyIsIlJlX01hcmtfaW5mb3MiLCJTdGRsaWJfT3B0aW9uIiwiU3RkbGliIiwiY3N0X0dyb3VwIiwiY3JlYXRlIiwicyIsImdjb3VudCIsImdwb3MiLCJtYXJrcyIsInBtYXJrcyIsIm9mZnNldF9vcHQiLCJ0IiwiaSIsInBhcmFtIiwic3RvcCIsInN0YXJ0Iiwib3Jfbm90X2ZvdW5kIiwib2Zmc2V0IiwiZ2V0IiwicDIiLCJwMSIsInN0YXJ0X29wdCIsInN1YnMiLCJzdG9wX29wdCIsInRlc3QiLCJnZXRfb3B0IiwiYWxsX29mZnNldCIsInJlcyIsImFsbCIsInBwIiwiZm10Iiwib2Zmc2V0cyIsInN0cnMiLCJtYXRjaGVzIiwicHBfbWF0Y2giLCJtYXRjaCIsInN0ciIsIm5iX2dyb3VwcyIsIlJlX0dyb3VwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL2dyb3VwLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxZQUFBQyxPQUFBQyxHQUFBQyxRQUFBQyxNQUFBQyxPQUFBQyxRQ29CMEM7QUFBQSxHQUFrQztBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLFFBQUEsTUFHMUU7QUFBQSxJQUNHLE9BQStEO0FBQUEsYUFBL0Q7QUFBQTtBQUFBLHdCQUFBQztBQUFBQTtBQUFBQSxpQkFBQUMsT0FBVztBQUFBLGlCQUFBQyxRQUFBO0FBQUEsdUJBQXNDO0FBQUEsZ0JBQWhCLHlEQUFjO0FBQUEsZUFBZ0I7QUFBQTtBQUFBO0FBQUEsWUFBQUMsYUFBQUg7QUFBQUEsSUFHakQsWUFDUDtBQUFBLFFBQUFSLElBRE87QUFBQSxJQUVMO0FBQUEsR0FBQztBQUFBLFlBQUFZLE9BQUFOLEdBQUFDLEdBR0UsT0FBYyxhQUFkLGlCQUE4QjtBQUFBLFlBQUFILE9BQUFFLEdBTWhDLFlBQVE7QUFBQSxZQUFBTyxJQUFBUCxHQUFBQztBQUFBQSxRQUFBLE1BSHJCO0FBQUEsSUFBa0IsT0FJSztBQUFBLGFBSm1EO0FBQUEsZUFBeEQ7QUFBQTtBQUFBLDBCQUFBQztBQUFBQSxzQkFBQU0sS0FBVyxVQUFBQyxLQUFBO0FBQUEsa0JBQWlCLDJEQUE0QjtBQUFBO0FBQUEsb0JBSW5DO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxNQUFBVjtBQUFBQSxRQUFBLE1BQ2xCO0FBQUEsSUFBcUIsT0FBYztBQUFBLGFBQWQsMkNEeEM1QyxzQkN3QzBEO0FBQUE7QUFBQSxZQUFBRyxNQUFBTyxNQUFBVixHQUN2QyxPQUFnQixhQUFoQixtQkFBZ0M7QUFBQSxZQUFBVyxTQUFBRCxNQUFBVjtBQUFBQSxRQUFBLE1BQzdCO0FBQUEsSUFBcUIsT0FBYztBQUFBLGFBQWQsMkNEMUMzQyxzQkMwQ3lEO0FBQUE7QUFBQSxZQUFBRSxLQUFBUSxNQUFBVixHQUN2QyxPQUFlLGFBQWYsa0JBQStCO0FBQUEsWUFBQVksS0FBQWIsR0FBQUMsR0FDbEMsNENBQXlCO0FBQUEsWUFBQWEsUUFBQWQsR0FBQUMsR0FDbkIsd0JBQW1CLGNBQW1CO0FBQUEsWUFBQWMsV0FBQWY7QUFBQUEsUUFBQWdCLE1BSS9DO0FBQUEsSUFDVjtBQUFBO0FBQUE7QUFBQSxlQUFBZixHQUFBRyxPQUFBRDtBQUFBQTtBQUFBQSxRQUFBTSxLQUNXO0FBQUEsUUFBQUQsS0FDQTtBQUFBLE9BQ1Q7QUFBQSxPQUFpQjtBQUFBO0FBQUEsSUFBQztBQUFBLEdBQ2pCO0FBQUEsWUFBQVMsSUFBQWpCO0FBQUFBLFFBQUFnQixNQU1PO0FBQUEsSUFDVjtBQUFBO0FBQUE7QUFBQSxlQUFBZixHQUFBRyxPQUFBRDtBQUFBQTtBQUFBQSxRQUFBTSxLQUNXO0FBQUEsUUFBQUQsS0FDQTtBQUFBLGNBQ0U7QUFBQSxPQUFYO0FBQUEsT0FBc0M7QUFBQTtBQUFBLElBQUM7QUFBQSxHQUN0QztBQUFBLFlBQUFVLEdBQUFDLEtBQUFuQjtBQUFBQTtBQUFBQSxLQUFBb0IsVUFLYTtBQUFBLEtBQUFDLE9BQ0g7QUFBQTtBQUFBLE9BQ0c7QUFBQTtBQUFBO0FBQUEsa0JBQUFwQjtBQUFBQSxjQUFBLE1BQW9EO0FBQUEsVUFBVixpREFBUTtBQUFBLFNBQWE7QUFBQSxLQUFBcUIsVUFBN0U7QUFBQSxhQUFBQyxTQUFBSixLQUFBakI7QUFBQUEsU0FBQXNCLFFBSVcsVUFBQXJCLE9BQUEsVUFBQUMsUUFBQSxVQUFBcUIsTUFBQTtBQUFBLEtBQTJCLGlFQUE2QztBQUFBO0FBQUEsY0FDcEU7QUFBQSxJQUFlLDBEQUFRO0FBQUE7QUFBQSxZQUFBQyxVQUFBMUIsR0FHeEIsWUFBUTtBQUFBO0FBQUEsSUFBQTJCO0FBQUFBLE1EaEYxQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogUmVzdWx0IG9mIGEgc3VjY2Vzc2Z1bCBtYXRjaC4gKilcbnR5cGUgdCA9XG4gIHsgKCogSW5wdXQgc3RyaW5nLiBNYXRjaGVkIHN0cmluZ3MgYXJlIHN1YnN0cmluZ3Mgb2YgcyAqKVxuICAgIHMgOiBzdHJpbmdcbiAgICAgICgqIE1hcHBpbmcgZnJvbSBncm91cCBpbmRpY2VzIHRvIHBvc2l0aW9ucyBpbiBncG9zLiBncm91cCBpIGhhcyBwb3NpdGlvbnMgMippXG4gICAgICAgICAtIDEsIDIqaSArIDEgaW4gZ3Bvcy4gSWYgdGhlIGdyb3VwIHdhc24ndCBtYXRjaGVkLCB0aGVuIGl0cyBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgIHZhbHVlcyBpbiBtYXJrcyB3aWxsIGJlIC0xLC0xICopXG4gIDsgbWFya3MgOiBNYXJrX2luZm9zLnRcbiAgOyAoKiBNYXJrcyBwb3NpdGlvbnMuIGkuZS4gdGhvc2UgbWFya3MgY3JlYXRlZCB3aXRoIFJlLm1hcmtzICopXG4gICAgcG1hcmtzIDogUG1hcmsuU2V0LnRcbiAgOyAoKiBHcm91cCBwb3NpdGlvbnMuIEFkamFjZW50IGVsZW1lbnRzIGFyZSAoc3RhcnQsIHN0b3ApIG9mIGdyb3VwIG1hdGNoLlxuICAgICAgIGluZGV4ZWQgYnkgdGhlIHZhbHVlcyBpbiBtYXJrcy4gU28gZ3JvdXAgaSBpbiBhbiByZSB3b3VsZCBiZSB0aGUgc3Vic3RyaW5nOlxuXG4gICAgICAgc3RhcnQgPSB0Lmdwb3MuKG1hcmtzLigyKmkpKSAtIDFcbiAgICAgICBzdG9wID0gdC5ncG9zLihtYXJrcy4oMippICsgMSkpIC0gMSAqKVxuICAgIGdwb3MgOiBpbnQgYXJyYXlcbiAgOyAoKiBOdW1iZXIgb2YgZ3JvdXBzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gY29udGFpbnMuIE1hdGNoZWQgb3Igbm90ICopXG4gICAgZ2NvdW50IDogaW50XG4gIH1cblxubGV0IGNyZWF0ZSBzIH5nY291bnQgfmdwb3MgbWFya3MgcG1hcmtzID0geyBzOyBnY291bnQ7IGdwb3M7IG1hcmtzOyBwbWFya3MgfVxuXG5sZXQgb2Zmc2V0X29wdCB0IGkgPVxuICBNYXJrX2luZm9zLm9mZnNldCB0Lm1hcmtzIGlcbiAgfD4gT3B0aW9uLm1hcCAoZnVuIChzdGFydCwgc3RvcCkgLT4gdC5ncG9zLihzdGFydCksIHQuZ3Bvcy4oc3RvcCkpXG47O1xuXG5sZXQgb3Jfbm90X2ZvdW5kID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IFNvbWUgcyAtPiBzXG47O1xuXG5sZXQgb2Zmc2V0IHQgaSA9IG9mZnNldF9vcHQgdCBpIHw+IG9yX25vdF9mb3VuZFxuXG5sZXQgZ2V0X29wdCB0IGkgPVxuICBvZmZzZXRfb3B0IHQgaSB8PiBPcHRpb24ubWFwIChmdW4gKHAxLCBwMikgLT4gU3RyaW5nLnN1YiB0LnMgcDEgKHAyIC0gcDEpKVxuOztcblxubGV0IHBtYXJrcyB0ID0gdC5wbWFya3NcbmxldCBnZXQgdCBpID0gZ2V0X29wdCB0IGkgfD4gb3Jfbm90X2ZvdW5kXG5sZXQgc3RhcnRfb3B0IHN1YnMgaSA9IG9mZnNldF9vcHQgc3VicyBpIHw+IE9wdGlvbi5tYXAgZnN0XG5sZXQgc3RhcnQgc3VicyBpID0gc3RhcnRfb3B0IHN1YnMgaSB8PiBvcl9ub3RfZm91bmRcbmxldCBzdG9wX29wdCBzdWJzIGkgPSBvZmZzZXRfb3B0IHN1YnMgaSB8PiBPcHRpb24ubWFwIHNuZFxubGV0IHN0b3Agc3VicyBpID0gc3RvcF9vcHQgc3VicyBpIHw+IG9yX25vdF9mb3VuZFxubGV0IHRlc3QgdCBpID0gTWFya19pbmZvcy50ZXN0IHQubWFya3MgaVxubGV0IGdldF9vcHQgdCBpID0gaWYgdGVzdCB0IGkgdGhlbiBTb21lIChnZXQgdCBpKSBlbHNlIE5vbmVcbmxldCBkdW1teV9vZmZzZXQgPSAtMSwgLTFcblxubGV0IGFsbF9vZmZzZXQgdCA9XG4gIGxldCByZXMgPSBBcnJheS5tYWtlIHQuZ2NvdW50IGR1bW15X29mZnNldCBpblxuICBNYXJrX2luZm9zLml0ZXJpIHQubWFya3MgfmY6KGZ1biBpIHN0YXJ0IHN0b3AgLT5cbiAgICBsZXQgcDEgPSB0Lmdwb3MuKHN0YXJ0KSBpblxuICAgIGxldCBwMiA9IHQuZ3Bvcy4oc3RvcCkgaW5cbiAgICByZXMuKGkpIDwtIHAxLCBwMik7XG4gIHJlc1xuOztcblxubGV0IGR1bW15X3N0cmluZyA9IFwiXCJcblxubGV0IGFsbCB0ID1cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgdC5nY291bnQgZHVtbXlfc3RyaW5nIGluXG4gIE1hcmtfaW5mb3MuaXRlcmkgdC5tYXJrcyB+ZjooZnVuIGkgc3RhcnQgc3RvcCAtPlxuICAgIGxldCBwMSA9IHQuZ3Bvcy4oc3RhcnQpIGluXG4gICAgbGV0IHAyID0gdC5ncG9zLihzdG9wKSBpblxuICAgIHJlcy4oaSkgPC0gU3RyaW5nLnN1YiB0LnMgcDEgKHAyIC0gcDEpKTtcbiAgcmVzXG47O1xuXG5sZXQgcHAgZm10IHQgPVxuICBsZXQgbWF0Y2hlcyA9XG4gICAgbGV0IG9mZnNldHMgPSBhbGxfb2Zmc2V0IHQgaW5cbiAgICBsZXQgc3RycyA9IGFsbCB0IGluXG4gICAgQXJyYXkudG9fbGlzdCAoQXJyYXkuaW5pdCAoQXJyYXkubGVuZ3RoIHN0cnMpIChmdW4gaSAtPiBzdHJzLihpKSwgb2Zmc2V0cy4oaSkpKVxuICBpblxuICBsZXQgb3BlbiBGb3JtYXQgaW5cbiAgbGV0IG9wZW4gRm10IGluXG4gIGxldCBwcF9tYXRjaCBmbXQgKHN0ciwgKHN0YXJ0LCBzdG9wKSkgPSBmcHJpbnRmIGZtdCBcIkBbKCVzICglZCAlZCkpQF1cIiBzdHIgc3RhcnQgc3RvcCBpblxuICBzZXhwIGZtdCBcIkdyb3VwXCIgKGxpc3QgcHBfbWF0Y2gpIG1hdGNoZXNcbjs7XG5cbmxldCBuYl9ncm91cHMgdCA9IHQuZ2NvdW50XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzE4MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X1JlX2V4ZWNfb3V0X29mX2JvdW5kcyIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21ha2VfdmVjdCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJSZV9JbXBvcnQiLCJSZV9Db2xvcl9tYXAiLCJSZV9Dc2V0IiwiU3RkbGliX0NoYXIiLCJSZV9BdXRvbWF0YSIsIlJlX0NhdGVnb3J5IiwiUmVfQXN0IiwiU3RkbGliX0xpc3RMYWJlbHMiLCJTdGRsaWIiLCJSZV9Hcm91cCIsIlN0ZGxpYl9BcnJheSIsIml0ZXIiLCJuIiwidiIsImJyZWFrX2lkeCIsInQiLCJnZXRfaW5mbyIsInBhcmFtIiwiZm9sbG93X3RyYW5zaXRpb24iLCJjb2xvciIsInNldF90cmFuc2l0aW9uIiwic3QiLCJpbmZvIiwidW5rbm93bl9zdGF0ZSIsInBwX3JlIiwiY2giLCJyZSIsImdyb3VwX2NvdW50IiwiZ3JvdXBfbmFtZXMiLCJlbXB0eSIsInNldCIsImlkeCIsInBvcyIsImNhdGVnb3J5IiwiZmluZF9zdGF0ZSIsImRlc2MiLCJtYXRjaCIsImJyZWFrX3N0YXRlIiwic3RhdGUiLCJuY29sIiwiZGVsdGEiLCJwb3NpdGlvbnMiLCJjYXQiLCJsZW4iLCJ2YWxpZGF0ZSIsInMiLCJuZXh0IiwiY29sb3JzIiwiZ2V0X2NvbG9yIiwic2xlbiIsInNjYW5fc3RyIiwiaW5pdGlhbF9zdGF0ZSIsImxhc3QiLCJncm91cHMiLCJ4IiwicmVhbF9jIiwic3QwIiwiZmluYWxfYm91bmRhcnlfY2hlY2siLCJzdGF0ZV9pbmZvIiwiZmluYWxfY2F0IiwicmVzIiwibWFrZV9tYXRjaF9zdHIiLCJwYXJ0aWFsIiwiaW5pdGlhbF9jYXQiLCJzdGF0dXMiLCJtYXRjaF9zdHJfbm9fYm91bmRzIiwicG1hcmtzIiwibWFya3MiLCJub19tYXRjaF9zdGFydHNfYmVmb3JlIiwibWF0Y2hfc3RyX3AiLCJtYXRjaF9zdHIiLCJlbmZvcmNlX2tpbmQiLCJpZHMiLCJraW5kIiwiY3IiLCJ0cmFuc2xhdGUiLCJjdHgiLCJhc3QiLCJjYWNoZSIsIm5hbWVzIiwiZ3JlZWR5IiwiaWduX2dyb3VwIiwiaSIsImwiLCJtZXJnZWRfc2VxdWVuY2VzIiwiciIsImoiLCJyZW0iLCJwIiwibmFtZSIsImIiLCJlIiwidHJhbnNfc2VxIiwiY29tcGlsZSIsInJlZ2V4cCIsImNvbG9yX21hcCIsIm5lZWRfbG5sIiwiY29sb3JfcmVwciIsIm5jb2xvciIsImxubCIsImluaXRpYWwiLCJSZV9Db21waWxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL2NvbXBpbGUubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxj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ZW4gSW1wb3J0XG5cbmxldCByZWMgaXRlciBuIGYgdiA9IGlmIEludC5lcXVhbCBuIDAgdGhlbiB2IGVsc2UgaXRlciAobiAtIDEpIGYgKGYgdilcblxubW9kdWxlIElkeCA6IHNpZ1xuICB0eXBlIHQgW0BAaW1tZWRpYXRlXVxuXG4gIHZhbCB1bmtub3duIDogdFxuICB2YWwgbWFrZV9icmVhayA6IEF1dG9tYXRhLklkeC50IC0+IHRcbiAgdmFsIG9mX2lkeCA6IEF1dG9tYXRhLklkeC50IC0+IHRcbiAgdmFsIGlzX2lkeCA6IHQgLT4gYm9vbFxuICB2YWwgaXNfYnJlYWsgOiB0IC0+IGJvb2xcbiAgdmFsIGlkeCA6IHQgLT4gaW50XG4gIHZhbCBicmVha19pZHggOiB0IC0+IGludFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB1bmtub3duID0gLTJcbiAgbGV0IGJyZWFrID0gLTNcbiAgbGV0IG9mX2lkeCAoeCA6IEF1dG9tYXRhLklkeC50KSA9IEF1dG9tYXRhLklkeC50b19pbnQgeCBbQEBpbmxpbmUgYWx3YXlzXVxuICBsZXQgaXNfaWR4IHQgPSB0ID49IDAgW0BAaW5saW5lIGFsd2F5c11cbiAgbGV0IGlzX2JyZWFrIHggPSB4IDw9IGJyZWFrIFtAQGlubGluZSBhbHdheXNdXG4gIGxldCBpZHggdCA9IHQgW0BAaW5saW5lIGFsd2F5c11cbiAgbGV0IG1ha2VfYnJlYWsgKGlkeCA6IEF1dG9tYXRhLklkeC50KSA9IC01IC0gQXV0b21hdGEuSWR4LnRvX2ludCBpZHggW0BAaW5saW5lIGFsd2F5c11cbiAgbGV0IGJyZWFrX2lkeCB0ID0gKHQgKyA1KSAqIC0xIFtAQGlubGluZSBhbHdheXNdXG5lbmRcblxudHlwZSBtYXRjaF9pbmZvID1cbiAgfCBNYXRjaCBvZiBHcm91cC50XG4gIHwgRmFpbGVkXG4gIHwgUnVubmluZyBvZiB7IG5vX21hdGNoX3N0YXJ0c19iZWZvcmUgOiBpbnQgfVxuXG50eXBlIHN0YXRlX2luZm8gPVxuICB7IGlkeCA6IElkeC50XG4gIDsgKCogSW5kZXggb2YgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHBvc2l0aW9uIHRhYmxlLlxuICAgICAgIE5vdCB5ZXQgY29tcHV0ZWQgdHJhbnNpdGlvbnMgcG9pbnQgdG8gYSBkdW1teSBzdGF0ZSB3aGVyZVxuICAgICAgIFtpZHhdIGlzIHNldCB0byBbdW5rbm93bl07XG4gICAgICAgSWYgW2lkeF0gaXMgc2V0IHRvIFticmVha10gZm9yIHN0YXRlcyB0aGF0IGVpdGhlciBhbHdheXNcbiAgICAgICBzdWNjZWVkIG9yIGFsd2F5cyBmYWlsLiAqKVxuICAgIG11dGFibGUgZmluYWwgOiAoQ2F0ZWdvcnkudCAqIChBdXRvbWF0YS5JZHgudCAqIEF1dG9tYXRhLlN0YXR1cy50KSkgbGlzdFxuICA7ICgqIE1hcHBpbmcgZnJvbSB0aGUgY2F0ZWdvcnkgb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvXG4gICAgICAgLSB0aGUgaW5kZXggd2hlcmUgdGhlIG5leHQgcG9zaXRpb24gc2hvdWxkIGJlIHNhdmVkXG4gICAgICAgLSBwb3NzaWJseSwgdGhlIGxpc3Qgb2YgbWFya3MgKGFuZCB0aGUgY29ycmVzcG9uZGluZyBpbmRpY2VzKVxuICAgICAgICAgY29ycmVzcG9uZGluZyB0byB0aGUgYmVzdCBtYXRjaCAqKVxuICAgIGRlc2MgOiBBdXRvbWF0YS5TdGF0ZS50ICgqIERlc2NyaXB0aW9uIG9mIHRoaXMgc3RhdGUgb2YgdGhlIGF1dG9tYXRhICopXG4gIH1cblxuKCogQSBzdGF0ZSBbdF0gaXMgYSBwYWlyIGNvbXBvc2VkIG9mIHNvbWUgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gICBzdGF0ZSBbc3RhdGVfaW5mb10gYW5kIGEgdHJhbnNpdGlvbiB0YWJsZSBbdCBhcnJheV0sIGluZGV4ZWQgYnlcbiAgIGNvbG9yLiBGb3IgcGVyZm9ybWFuY2UgcmVhc29uLCB0byBhdm9pZCBhbiBpbmRpcmVjdGlvbiwgd2UgbWFudWFsbHlcbiAgIHVuYm94IHRoZSB0cmFuc2l0aW9uIHRhYmxlOiB3ZSBhbGxvY2F0ZSBhIHNpbmdsZSBhcnJheSwgd2l0aCB0aGVcbiAgIHN0YXRlIGluZm9ybWF0aW9uIGF0IGluZGV4IDAsIGZvbGxvd2VkIGJ5IHRoZSB0cmFuc2l0aW9ucy4gKilcbm1vZHVsZSBTdGF0ZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgbWFrZSA6IG5jb2w6aW50IC0+IHN0YXRlX2luZm8gLT4gdFxuICB2YWwgbWFrZV9icmVhayA6IHN0YXRlX2luZm8gLT4gdFxuICB2YWwgZ2V0X2luZm8gOiB0IC0+IHN0YXRlX2luZm9cbiAgdmFsIGZvbGxvd190cmFuc2l0aW9uIDogdCAtPiBjb2xvcjpDc2V0LmMgLT4gdFxuICB2YWwgc2V0X3RyYW5zaXRpb24gOiB0IC0+IGNvbG9yOkNzZXQuYyAtPiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBUYWJsZSBvZiB0IGFycmF5IFtAQHVuYm94ZWRdXG5cbiAgbGV0IGdldF9pbmZvIChUYWJsZSBzdCkgOiBzdGF0ZV9pbmZvID0gT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IHN0IDApXG4gIFtAQGlubGluZSBhbHdheXNdXG4gIDs7XG5cbiAgbGV0IHNldF9pbmZvIChUYWJsZSBzdCkgKGluZm8gOiBzdGF0ZV9pbmZvKSA9IHN0LigwKSA8LSBPYmoubWFnaWMgaW5mb1xuXG4gIGxldCBmb2xsb3dfdHJhbnNpdGlvbiAoVGFibGUgc3QpIH5jb2xvciA9IEFycmF5LnVuc2FmZV9nZXQgc3QgKDEgKyBDc2V0LnRvX2ludCBjb2xvcilcbiAgW0BAaW5saW5lIGFsd2F5c11cbiAgOztcblxuICBsZXQgc2V0X3RyYW5zaXRpb24gKFRhYmxlIHN0KSB+Y29sb3Igc3QnID0gc3QuKDEgKyBDc2V0LnRvX2ludCBjb2xvcikgPC0gc3QnXG4gIGxldCBkdW1teSAoaW5mbyA6IHN0YXRlX2luZm8pID0gVGFibGUgW3wgT2JqLm1hZ2ljIGluZm8gfF1cbiAgbGV0IHVua25vd25fc3RhdGUgPSBkdW1teSB7IGlkeCA9IElkeC51bmtub3duOyBmaW5hbCA9IFtdOyBkZXNjID0gQXV0b21hdGEuU3RhdGUuZHVtbXkgfVxuXG4gIGxldCBtYWtlIH5uY29sIHN0YXRlID1cbiAgICBsZXQgc3QgPSBUYWJsZSAoQXJyYXkubWFrZSAobmNvbCArIDEpIHVua25vd25fc3RhdGUpIGluXG4gICAgc2V0X2luZm8gc3Qgc3RhdGU7XG4gICAgc3RcbiAgOztcblxuICBsZXQgbWFrZV9icmVhayBzdGF0ZSA9IFRhYmxlIFt8IE9iai5tYWdpYyBzdGF0ZSB8XVxuZW5kXG5cbigqIEF1dG9tYXRhIChjb21waWxlZCByZWd1bGFyIGV4cHJlc3Npb24pICopXG50eXBlIHJlID1cbiAgeyBpbml0aWFsIDogQXV0b21hdGEuZXhwclxuICA7ICgqIFRoZSB3aG9sZSByZWd1bGFyIGV4cHJlc3Npb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc3RhdGVzIDogKENhdGVnb3J5LnQgKiBTdGF0ZS50KSBsaXN0XG4gIDsgKCogSW5pdGlhbCBzdGF0ZXMsIGluZGV4ZWQgYnkgaW5pdGlhbCBjYXRlZ29yeSAqKVxuICAgIGNvbG9ycyA6IENvbG9yX21hcC5UYWJsZS50XG4gIDsgKCogQ29sb3IgdGFibGUgKilcbiAgICBjb2xvcl9yZXByIDogQ29sb3JfbWFwLlJlcHIudFxuICA7ICgqIFRhYmxlIGZyb20gY29sb3JzIHRvIG9uZSBjaGFyYWN0ZXIgb2YgdGhpcyBjb2xvciAqKVxuICAgIG5jb2xvciA6IGludFxuICA7ICgqIE51bWJlciBvZiBjb2xvcnMuICopXG4gICAgbG5sIDogQ3NldC5jXG4gIDsgKCogQ29sb3Igb2YgdGhlIGxhc3QgbmV3bGluZS4gW0NzZXQubnVsbF9jaGFyXSBpZiB1bm5lY2Vzc2FyeSAqKVxuICAgIHRibCA6IEF1dG9tYXRhLldvcmtpbmdfYXJlYS50XG4gIDsgKCogVGVtcG9yYXJ5IHRhYmxlIHVzZWQgdG8gY29tcHV0ZSB0aGUgZmlyc3QgYXZhaWxhYmxlIGluZGV4XG4gICAgICAgd2hlbiBjb21wdXRpbmcgYSBuZXcgc3RhdGUgKilcbiAgICBzdGF0ZXMgOiBTdGF0ZS50IEF1dG9tYXRhLlN0YXRlLlRhYmxlLnRcbiAgOyAoKiBTdGF0ZXMgb2YgdGhlIGRldGVybWluaXN0aWMgYXV0b21hdGEgKilcbiAgICBncm91cF9uYW1lcyA6IChzdHJpbmcgKiBpbnQpIGxpc3RcbiAgOyAoKiBOYW1lZCBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICAgIGdyb3VwX2NvdW50IDogaW50ICgqIE51bWJlciBvZiBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICB9XG5cbmxldCBwcF9yZSBjaCByZSA9IEF1dG9tYXRhLnBwIGNoIHJlLmluaXRpYWxcbmxldCBncm91cF9jb3VudCByZSA9IHJlLmdyb3VwX2NvdW50XG5sZXQgZ3JvdXBfbmFtZXMgcmUgPSByZS5ncm91cF9uYW1lc1xuXG5tb2R1bGUgUG9zaXRpb25zID0gc3RydWN0XG4gICgqIEluZm9ybWF0aW9uIHVzZWQgZHVyaW5nIG1hdGNoaW5nICopXG4gIHR5cGUgdCA9XG4gICAgeyBtdXRhYmxlIHBvc2l0aW9ucyA6IGludCBhcnJheVxuICAgICgqIEFycmF5IG9mIG1hcmsgcG9zaXRpb25zXG4gICAgICAgVGhlIG1hcmsgYXJlIG9mZiBieSBvbmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKilcbiAgICB9XG5cbiAgbGV0IGVtcHR5ID0geyBwb3NpdGlvbnMgPSBbfHxdIH1cbiAgbGV0IGxlbmd0aCB0ID0gQXJyYXkubGVuZ3RoIHQucG9zaXRpb25zXG4gIGxldCBzZXQgdCBpZHggcG9zID0gQXJyYXkudW5zYWZlX3NldCB0LnBvc2l0aW9ucyBpZHggcG9zXG5cbiAgbGV0IHJlc2l6ZSB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQucG9zaXRpb25zIGluXG4gICAgbGV0IHBvcyA9IHQucG9zaXRpb25zIGluXG4gICAgdC5wb3NpdGlvbnMgPC0gQXJyYXkubWFrZSAoMiAqIGxlbikgMDtcbiAgICBBcnJheS5ibGl0IHBvcyAwIHQucG9zaXRpb25zIDAgbGVuXG4gIDs7XG5cbiAgbGV0IGFsbCB0ID0gdC5wb3NpdGlvbnNcbiAgbGV0IGZpcnN0IHQgPSB0LnBvc2l0aW9ucy4oMClcblxuICBsZXQgbWFrZSB+Z3JvdXBzIHJlID1cbiAgICBpZiBncm91cHNcbiAgICB0aGVuXG4gICAgICB7IHBvc2l0aW9ucyA9XG4gICAgICAgICAgKGxldCBuID0gQXV0b21hdGEuV29ya2luZ19hcmVhLmluZGV4X2NvdW50IHJlLnRibCArIDEgaW5cbiAgICAgICAgICAgaWYgbiA8PSAxMCB0aGVuIFt8IDA7IDA7IDA7IDA7IDA7IDA7IDA7IDA7IDA7IDAgfF0gZWxzZSBBcnJheS5tYWtlIG4gMClcbiAgICAgIH1cbiAgICBlbHNlIGVtcHR5XG4gIDs7XG5lbmRcblxuKCoqKiopXG5cbmxldCBjYXRlZ29yeSByZSB+Y29sb3IgPVxuICBpZiBDc2V0LmVxdWFsX2MgY29sb3IgQ3NldC5udWxsX2NoYXJcbiAgdGhlbiBDYXRlZ29yeS5pbmV4aXN0YW50ICgqIFNwZWNpYWwgY2F0ZWdvcnkgZm9yIHRoZSBsYXN0IG5ld2xpbmUgKilcbiAgZWxzZSBpZiBDc2V0LmVxdWFsX2MgY29sb3IgcmUubG5sXG4gIHRoZW4gQ2F0ZWdvcnkuKGxhc3RuZXdsaW5lICsrIG5ld2xpbmUgKysgbm90X2xldHRlcilcbiAgZWxzZSBDYXRlZ29yeS5mcm9tX2NoYXIgKENvbG9yX21hcC5SZXByLnJlcHIgcmUuY29sb3JfcmVwciBjb2xvcilcbjs7XG5cbigqKioqKVxuXG5sZXQgZmluZF9zdGF0ZSByZSBkZXNjID1cbiAgdHJ5IEF1dG9tYXRhLlN0YXRlLlRhYmxlLmZpbmQgcmUuc3RhdGVzIGRlc2Mgd2l0aFxuICB8IE5vdF9mb3VuZCAtPlxuICAgIGxldCBzdCA9XG4gICAgICBsZXQgYnJlYWtfc3RhdGUgPVxuICAgICAgICBtYXRjaCBBdXRvbWF0YS5TdGF0ZS5zdGF0dXMgZGVzYyB3aXRoXG4gICAgICAgIHwgUnVubmluZyAtPiBmYWxzZVxuICAgICAgICB8IEZhaWxlZCB8IE1hdGNoIF8gLT4gdHJ1ZVxuICAgICAgaW5cbiAgICAgIGxldCBzdCA9XG4gICAgICAgIHsgaWR4ID1cbiAgICAgICAgICAgIChsZXQgaWR4ID0gQXV0b21hdGEuU3RhdGUuaWR4IGRlc2MgaW5cbiAgICAgICAgICAgICBpZiBicmVha19zdGF0ZSB0aGVuIElkeC5tYWtlX2JyZWFrIGlkeCBlbHNlIElkeC5vZl9pZHggaWR4KVxuICAgICAgICA7IGZpbmFsID0gW11cbiAgICAgICAgOyBkZXNjXG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICBpZiBicmVha19zdGF0ZSB0aGVuIFN0YXRlLm1ha2VfYnJlYWsgc3QgZWxzZSBTdGF0ZS5tYWtlIH5uY29sOnJlLm5jb2xvciBzdFxuICAgIGluXG4gICAgQXV0b21hdGEuU3RhdGUuVGFibGUuYWRkIHJlLnN0YXRlcyBkZXNjIHN0O1xuICAgIHN0XG47O1xuXG4oKioqKiBNYXRjaCB3aXRoIG1hcmtzICoqKiopXG5cbmxldCBkZWx0YSByZSBwb3NpdGlvbnMgY2F0IH5jb2xvciBzdCA9XG4gIGxldCBkZXNjID0gQXV0b21hdGEuZGVsdGEgcmUudGJsIGNhdCBjb2xvciBzdC5kZXNjIGluXG4gIGxldCBsZW4gPSBQb3NpdGlvbnMubGVuZ3RoIHBvc2l0aW9ucyBpblxuICBpZiBsZW4gPiAwICYmIEF1dG9tYXRhLlN0YXRlLmlkeCBkZXNjIHw+IEF1dG9tYXRhLklkeC50b19pbnQgPSBsZW5cbiAgdGhlbiBQb3NpdGlvbnMucmVzaXplIHBvc2l0aW9ucztcbiAgZGVzY1xuOztcblxubGV0IHZhbGlkYXRlIHJlIHBvc2l0aW9ucyAocyA6IHN0cmluZykgfnBvcyBzdCA9XG4gIGxldCBjb2xvciA9IENvbG9yX21hcC5UYWJsZS5nZXQgcmUuY29sb3JzIHMuW3Bvc10gaW5cbiAgbGV0IHN0JyA9XG4gICAgbGV0IGRlc2MnID1cbiAgICAgIGxldCBjYXQgPSBjYXRlZ29yeSByZSB+Y29sb3IgaW5cbiAgICAgIGRlbHRhIHJlIHBvc2l0aW9ucyBjYXQgfmNvbG9yIChTdGF0ZS5nZXRfaW5mbyBzdClcbiAgICBpblxuICAgIGZpbmRfc3RhdGUgcmUgZGVzYydcbiAgaW5cbiAgU3RhdGUuc2V0X3RyYW5zaXRpb24gc3QgfmNvbG9yIHN0J1xuOztcblxubGV0IG5leHQgY29sb3JzIHN0IHMgcG9zID1cbiAgU3RhdGUuZm9sbG93X3RyYW5zaXRpb24gc3QgfmNvbG9yOihDb2xvcl9tYXAuVGFibGUuZ2V0IGNvbG9ycyAoU3RyaW5nLnVuc2FmZV9nZXQgcyBwb3MpKVxuOztcblxubGV0IHJlYyBsb29wIHJlIH5jb2xvcnMgfnBvc2l0aW9ucyBzIH5wb3Mgfmxhc3Qgc3QwIHN0ID1cbiAgaWYgcG9zIDwgbGFzdFxuICB0aGVuIChcbiAgICBsZXQgc3QnID0gbmV4dCBjb2xvcnMgc3QgcyBwb3MgaW5cbiAgICBsZXQgaWR4ID0gKFN0YXRlLmdldF9pbmZvIHN0JykuaWR4IGluXG4gICAgaWYgSWR4LmlzX2lkeCBpZHhcbiAgICB0aGVuIChcbiAgICAgIFBvc2l0aW9ucy5zZXQgcG9zaXRpb25zIChJZHguaWR4IGlkeCkgcG9zO1xuICAgICAgbG9vcCByZSB+Y29sb3JzIH5wb3NpdGlvbnMgcyB+cG9zOihwb3MgKyAxKSB+bGFzdCBzdCcgc3QnKVxuICAgIGVsc2UgaWYgSWR4LmlzX2JyZWFrIGlkeFxuICAgIHRoZW4gKFxuICAgICAgUG9zaXRpb25zLnNldCBwb3NpdGlvbnMgKElkeC5icmVha19pZHggaWR4KSBwb3M7XG4gICAgICBzdCcpXG4gICAgZWxzZSAoXG4gICAgICAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSByZSBwb3NpdGlvbnMgcyB+cG9zIHN0MDtcbiAgICAgIGxvb3AgcmUgfmNvbG9ycyB+cG9zaXRpb25zIHMgfnBvcyB+bGFzdCBzdDAgc3QwKSlcbiAgZWxzZSBzdFxuOztcblxubGV0IHJlYyBsb29wX25vX21hcmsgcmUgfmNvbG9ycyBzIH5wb3Mgfmxhc3Qgc3QwIHN0ID1cbiAgaWYgcG9zIDwgbGFzdFxuICB0aGVuIChcbiAgICBsZXQgc3QnID0gbmV4dCBjb2xvcnMgc3QgcyBwb3MgaW5cbiAgICBsZXQgaWR4ID0gKFN0YXRlLmdldF9pbmZvIHN0JykuaWR4IGluXG4gICAgaWYgSWR4LmlzX2lkeCBpZHhcbiAgICB0aGVuIGxvb3Bfbm9fbWFyayByZSB+Y29sb3JzIHMgfnBvczoocG9zICsgMSkgfmxhc3Qgc3QnIHN0J1xuICAgIGVsc2UgaWYgSWR4LmlzX2JyZWFrIGlkeFxuICAgIHRoZW4gc3QnXG4gICAgZWxzZSAoXG4gICAgICAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSByZSBQb3NpdGlvbnMuZW1wdHkgcyB+cG9zIHN0MDtcbiAgICAgIGxvb3Bfbm9fbWFyayByZSB+Y29sb3JzIHMgfnBvcyB+bGFzdCBzdDAgc3QwKSlcbiAgZWxzZSBzdFxuOztcblxubGV0IGZpbmFsIHJlIHBvc2l0aW9ucyBzdCBjYXQgPVxuICB0cnkgTGlzdC5hc3NxIGNhdCBzdC5maW5hbCB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+XG4gICAgbGV0IHN0JyA9IGRlbHRhIHJlIHBvc2l0aW9ucyBjYXQgfmNvbG9yOkNzZXQubnVsbF9jaGFyIHN0IGluXG4gICAgbGV0IHJlcyA9IEF1dG9tYXRhLlN0YXRlLmlkeCBzdCcsIEF1dG9tYXRhLlN0YXRlLnN0YXR1cyBzdCcgaW5cbiAgICBzdC5maW5hbCA8LSAoY2F0LCByZXMpIDo6IHN0LmZpbmFsO1xuICAgIHJlc1xuOztcblxubGV0IGZpbmRfaW5pdGlhbF9zdGF0ZSByZSBjYXQgPVxuICB0cnkgTGlzdC5hc3NxIGNhdCByZS5pbml0aWFsX3N0YXRlcyB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+XG4gICAgbGV0IHN0ID0gZmluZF9zdGF0ZSByZSAoQXV0b21hdGEuU3RhdGUuY3JlYXRlIGNhdCByZS5pbml0aWFsKSBpblxuICAgIHJlLmluaXRpYWxfc3RhdGVzIDwtIChjYXQsIHN0KSA6OiByZS5pbml0aWFsX3N0YXRlcztcbiAgICBzdFxuOztcblxubGV0IGdldF9jb2xvciByZSAocyA6IHN0cmluZykgcG9zID1cbiAgaWYgcG9zIDwgMFxuICB0aGVuIENzZXQubnVsbF9jaGFyXG4gIGVsc2UgKFxuICAgIGxldCBzbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgaWYgcG9zID49IHNsZW5cbiAgICB0aGVuIENzZXQubnVsbF9jaGFyXG4gICAgZWxzZSBpZiBwb3MgPSBzbGVuIC0gMVxuICAgICAgICAgICAgJiYgKG5vdCAoQ3NldC5lcXVhbF9jIHJlLmxubCBDc2V0Lm51bGxfY2hhcikpXG4gICAgICAgICAgICAmJiBDaGFyLmVxdWFsIChTdHJpbmcudW5zYWZlX2dldCBzIHBvcykgJ1xcbidcbiAgICB0aGVuICgqIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGxhc3QgbmV3bGluZSAqKVxuICAgICAgcmUubG5sXG4gICAgZWxzZSBDb2xvcl9tYXAuVGFibGUuZ2V0IHJlLmNvbG9ycyAoU3RyaW5nLnVuc2FmZV9nZXQgcyBwb3MpKVxuOztcblxubGV0IHJlYyBoYW5kbGVfbGFzdF9uZXdsaW5lIHJlIHBvc2l0aW9ucyB+cG9zIHN0IH5ncm91cHMgPVxuICBsZXQgc3QnID0gU3RhdGUuZm9sbG93X3RyYW5zaXRpb24gc3QgfmNvbG9yOnJlLmxubCBpblxuICBsZXQgaW5mbyA9IFN0YXRlLmdldF9pbmZvIHN0JyBpblxuICBpZiBJZHguaXNfaWR4IGluZm8uaWR4XG4gIHRoZW4gKFxuICAgIGlmIGdyb3VwcyB0aGVuIFBvc2l0aW9ucy5zZXQgcG9zaXRpb25zIChJZHguaWR4IGluZm8uaWR4KSBwb3M7XG4gICAgc3QnKVxuICBlbHNlIGlmIElkeC5pc19icmVhayBpbmZvLmlkeFxuICB0aGVuIChcbiAgICBpZiBncm91cHMgdGhlbiBQb3NpdGlvbnMuc2V0IHBvc2l0aW9ucyAoSWR4LmJyZWFrX2lkeCBpbmZvLmlkeCkgcG9zO1xuICAgIHN0JylcbiAgZWxzZSAoXG4gICAgKCogVW5rbm93biAqKVxuICAgIGxldCBjb2xvciA9IHJlLmxubCBpblxuICAgIGxldCBzdCcgPVxuICAgICAgbGV0IGRlc2MgPVxuICAgICAgICBsZXQgY2F0ID0gY2F0ZWdvcnkgcmUgfmNvbG9yIGluXG4gICAgICAgIGxldCByZWFsX2MgPSBDb2xvcl9tYXAuVGFibGUuZ2V0IHJlLmNvbG9ycyAnXFxuJyBpblxuICAgICAgICBkZWx0YSByZSBwb3NpdGlvbnMgY2F0IH5jb2xvcjpyZWFsX2MgKFN0YXRlLmdldF9pbmZvIHN0KVxuICAgICAgaW5cbiAgICAgIGZpbmRfc3RhdGUgcmUgZGVzY1xuICAgIGluXG4gICAgU3RhdGUuc2V0X3RyYW5zaXRpb24gc3QgfmNvbG9yIHN0JztcbiAgICBoYW5kbGVfbGFzdF9uZXdsaW5lIHJlIHBvc2l0aW9ucyB+cG9zIHN0IH5ncm91cHMpXG47O1xuXG5sZXQgcmVjIHNjYW5fc3RyIHJlIHBvc2l0aW9ucyAocyA6IHN0cmluZykgaW5pdGlhbF9zdGF0ZSB+bGFzdCB+cG9zIH5ncm91cHMgPVxuICBpZiBsYXN0ID0gU3RyaW5nLmxlbmd0aCBzXG4gICAgICYmIChub3QgKENzZXQuZXF1YWxfYyByZS5sbmwgQ3NldC5udWxsX2NoYXIpKVxuICAgICAmJiBsYXN0ID4gcG9zXG4gICAgICYmIENoYXIuZXF1YWwgKFN0cmluZy5nZXQgcyAobGFzdCAtIDEpKSAnXFxuJ1xuICB0aGVuIChcbiAgICBsZXQgbGFzdCA9IGxhc3QgLSAxIGluXG4gICAgbGV0IHN0ID0gc2Nhbl9zdHIgcmUgcG9zaXRpb25zIH5wb3MgcyBpbml0aWFsX3N0YXRlIH5sYXN0IH5ncm91cHMgaW5cbiAgICBpZiBJZHguaXNfYnJlYWsgKFN0YXRlLmdldF9pbmZvIHN0KS5pZHhcbiAgICB0aGVuIHN0XG4gICAgZWxzZSBoYW5kbGVfbGFzdF9uZXdsaW5lIHJlIHBvc2l0aW9ucyB+cG9zOmxhc3Qgc3Qgfmdyb3VwcylcbiAgZWxzZSBpZiBncm91cHNcbiAgdGhlbiBsb29wIHJlIH5jb2xvcnM6cmUuY29sb3JzIH5wb3NpdGlvbnMgcyB+cG9zIH5sYXN0IGluaXRpYWxfc3RhdGUgaW5pdGlhbF9zdGF0ZVxuICBlbHNlIGxvb3Bfbm9fbWFyayByZSB+Y29sb3JzOnJlLmNvbG9ycyBzIH5wb3Mgfmxhc3QgaW5pdGlhbF9zdGF0ZSBpbml0aWFsX3N0YXRlXG47O1xuXG4oKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBmaW5hbCBib3VuZGFyeSBjaGVjayBvbiB0aGUgaW5wdXQuXG4gICBUaGlzIGlzIHVzZWZ1bCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBvdXRwdXQgZmFpbGVkIGJlY2F1c2VcbiAgIG9mIGluc3VmZmljaWVudCBpbnB1dCwgb3IgdG8gdmVyaWZ5IHRoYXQgdGhlIG91dHB1dCBhY3R1YWxseVxuICAgbWF0Y2hlcyBmb3IgcmVnZXggdGhhdCBoYXZlIGJvdW5kYXJ5IGNvbmRpdGlvbnMgd2l0aCByZXNwZWN0XG4gICB0byB0aGUgaW5wdXQgc3RyaW5nLlxuKilcbmxldCBmaW5hbF9ib3VuZGFyeV9jaGVjayByZSBwb3NpdGlvbnMgfmxhc3QgfnNsZW4gcyBzdGF0ZV9pbmZvIH5ncm91cHMgPVxuICBsZXQgaWR4LCByZXMgPVxuICAgIGxldCBmaW5hbF9jYXQgPVxuICAgICAgQ2F0ZWdvcnkuKFxuICAgICAgICBzZWFyY2hfYm91bmRhcnlcbiAgICAgICAgKysgaWYgbGFzdCA9IHNsZW4gdGhlbiBpbmV4aXN0YW50IGVsc2UgY2F0ZWdvcnkgcmUgfmNvbG9yOihnZXRfY29sb3IgcmUgcyBsYXN0KSlcbiAgICBpblxuICAgIGZpbmFsIHJlIHBvc2l0aW9ucyBzdGF0ZV9pbmZvIGZpbmFsX2NhdFxuICBpblxuICAobWF0Y2ggZ3JvdXBzLCByZXMgd2l0aFxuICAgfCB0cnVlLCBNYXRjaCBfIC0+IFBvc2l0aW9ucy5zZXQgcG9zaXRpb25zIChBdXRvbWF0YS5JZHgudG9faW50IGlkeCkgbGFzdFxuICAgfCBfIC0+ICgpKTtcbiAgcmVzXG47O1xuXG5sZXQgbWFrZV9tYXRjaF9zdHIgcmUgcG9zaXRpb25zIH5sZW4gfmdyb3VwcyB+cGFydGlhbCBzIH5wb3MgPVxuICBsZXQgc2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGFzdCA9IGlmIGxlbiA9IC0xIHRoZW4gc2xlbiBlbHNlIHBvcyArIGxlbiBpblxuICBsZXQgc3QgPVxuICAgIGxldCBpbml0aWFsX3N0YXRlID1cbiAgICAgIGxldCBpbml0aWFsX2NhdCA9XG4gICAgICAgIENhdGVnb3J5LihcbiAgICAgICAgICBzZWFyY2hfYm91bmRhcnlcbiAgICAgICAgICArKyBpZiBwb3MgPSAwIHRoZW4gaW5leGlzdGFudCBlbHNlIGNhdGVnb3J5IHJlIH5jb2xvcjooZ2V0X2NvbG9yIHJlIHMgKHBvcyAtIDEpKSlcbiAgICAgIGluXG4gICAgICBmaW5kX2luaXRpYWxfc3RhdGUgcmUgaW5pdGlhbF9jYXRcbiAgICBpblxuICAgIHNjYW5fc3RyIHJlIHBvc2l0aW9ucyBzIGluaXRpYWxfc3RhdGUgfnBvcyB+bGFzdCB+Z3JvdXBzXG4gIGluXG4gIGxldCBzdGF0ZV9pbmZvID0gU3RhdGUuZ2V0X2luZm8gc3QgaW5cbiAgaWYgSWR4LmlzX2JyZWFrIHN0YXRlX2luZm8uaWR4IHx8IChwYXJ0aWFsICYmIG5vdCBncm91cHMpXG4gIHRoZW4gQXV0b21hdGEuU3RhdGUuc3RhdHVzIHN0YXRlX2luZm8uZGVzY1xuICBlbHNlIGlmIHBhcnRpYWwgJiYgZ3JvdXBzXG4gIHRoZW4gKFxuICAgIG1hdGNoIEF1dG9tYXRhLlN0YXRlLnN0YXR1cyBzdGF0ZV9pbmZvLmRlc2Mgd2l0aFxuICAgIHwgKE1hdGNoIF8gfCBGYWlsZWQpIGFzIHN0YXR1cyAtPiBzdGF0dXNcbiAgICB8IFJ1bm5pbmcgLT5cbiAgICAgICgqIFRoaXMgY291bGQgYmUgYmVjYXVzZSBpdCdzIHN0aWxsIG5vdCBmdWxseSBtYXRjaGVkLCBvciBpdFxuICAgICAgICAgY291bGQgYmUgdGhhdCBiZWNhdXNlIHdlIG5lZWQgdG8gcnVuIHNwZWNpYWwgZW5kIG9mIGlucHV0XG4gICAgICAgICBjaGVja3MuICopXG4gICAgICAobWF0Y2ggZmluYWxfYm91bmRhcnlfY2hlY2sgcmUgcG9zaXRpb25zIH5sYXN0IH5zbGVuIHMgc3RhdGVfaW5mbyB+Z3JvdXBzIHdpdGhcbiAgICAgICB8IE1hdGNoIF8gYXMgc3RhdHVzIC0+IHN0YXR1c1xuICAgICAgIHwgRmFpbGVkIHwgUnVubmluZyAtPlxuICAgICAgICAgKCogQSBmYWlsdXJlIGhlcmUganVzdCBtZWFucyB0aGF0IHdlIG5lZWQgbW9yZSBkYXRhLCBpLmUuXG4gICAgICAgICAgICBpdCdzIGEgcGFydGlhbCBtYXRjaC4gKilcbiAgICAgICAgIFJ1bm5pbmcpKVxuICBlbHNlIGZpbmFsX2JvdW5kYXJ5X2NoZWNrIHJlIHBvc2l0aW9ucyB+bGFzdCB+c2xlbiBzIHN0YXRlX2luZm8gfmdyb3Vwc1xuOztcblxubGV0IG1hdGNoX3N0cl9ub19ib3VuZHMgfmdyb3VwcyB+cGFydGlhbCByZSBzIH5wb3MgfmxlbiA9XG4gIGxldCBwb3NpdGlvbnMgPSBQb3NpdGlvbnMubWFrZSB+Z3JvdXBzIHJlIGluXG4gIG1hdGNoIG1ha2VfbWF0Y2hfc3RyIHJlIHBvc2l0aW9ucyB+bGVuIH5ncm91cHMgfnBhcnRpYWwgcyB+cG9zIHdpdGhcbiAgfCBNYXRjaCAobWFya3MsIHBtYXJrcykgLT5cbiAgICBNYXRjaFxuICAgICAgKEdyb3VwLmNyZWF0ZSBzIG1hcmtzIHBtYXJrcyB+Z3BvczooUG9zaXRpb25zLmFsbCBwb3NpdGlvbnMpIH5nY291bnQ6cmUuZ3JvdXBfY291bnQpXG4gIHwgRmFpbGVkIC0+IEZhaWxlZFxuICB8IFJ1bm5pbmcgLT5cbiAgICBsZXQgbm9fbWF0Y2hfc3RhcnRzX2JlZm9yZSA9IGlmIGdyb3VwcyB0aGVuIFBvc2l0aW9ucy5maXJzdCBwb3NpdGlvbnMgZWxzZSAwIGluXG4gICAgUnVubmluZyB7IG5vX21hdGNoX3N0YXJ0c19iZWZvcmUgfVxuOztcblxubGV0IG1hdGNoX3N0cl9wIHJlIHMgfnBvcyB+bGVuID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAtMSB8fCBwb3MgKyBsZW4gPiBTdHJpbmcubGVuZ3RoIHNcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLmV4ZWM6IG91dCBvZiBib3VuZHNcIjtcbiAgbWF0Y2ggbWFrZV9tYXRjaF9zdHIgcmUgUG9zaXRpb25zLmVtcHR5IH5sZW4gfmdyb3VwczpmYWxzZSB+cGFydGlhbDpmYWxzZSBzIH5wb3Mgd2l0aFxuICB8IE1hdGNoIF8gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBtYXRjaF9zdHIgfmdyb3VwcyB+cGFydGlhbCByZSBzIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgLTEgfHwgcG9zICsgbGVuID4gU3RyaW5nLmxlbmd0aCBzXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5leGVjOiBvdXQgb2YgYm91bmRzXCI7XG4gIG1hdGNoX3N0cl9ub19ib3VuZHMgfmdyb3VwcyB+cGFydGlhbCByZSBzIH5wb3MgfmxlblxuOztcblxubGV0IG1rX3JlIH5pbml0aWFsIH5jb2xvcnMgfmNvbG9yX3JlcHIgfm5jb2xvciB+bG5sIH5ncm91cF9uYW1lcyB+Z3JvdXBfY291bnQgPVxuICB7IGluaXRpYWxcbiAgOyBpbml0aWFsX3N0YXRlcyA9IFtdXG4gIDsgY29sb3JzXG4gIDsgY29sb3JfcmVwclxuICA7IG5jb2xvclxuICA7IGxubFxuICA7IHRibCA9IEF1dG9tYXRhLldvcmtpbmdfYXJlYS5jcmVhdGUgKClcbiAgOyBzdGF0ZXMgPSBBdXRvbWF0YS5TdGF0ZS5UYWJsZS5jcmVhdGUgOTdcbiAgOyBncm91cF9uYW1lc1xuICA7IGdyb3VwX2NvdW50XG4gIH1cbjs7XG5cbigqKioqIENvbXBpbGF0aW9uICoqKiopXG5cbm1vZHVsZSBBID0gQXV0b21hdGFcblxubGV0IGVuZm9yY2Vfa2luZCBpZHMga2luZCBraW5kJyBjciA9XG4gIG1hdGNoIGtpbmQsIGtpbmQnIHdpdGhcbiAgfCBgRmlyc3QsIGBGaXJzdCAtPiBjclxuICB8IGBGaXJzdCwgayAtPiBBLnNlcSBpZHMgayBjciAoQS5lcHMgaWRzKVxuICB8IF8gLT4gY3Jcbjs7XG5cbnR5cGUgY29udGV4dCA9XG4gIHsgaWRzIDogQS5JZHMudFxuICA7IGtpbmQgOiBBLlNlbS50XG4gIDsgaWduX2dyb3VwIDogYm9vbFxuICA7IGdyZWVkeSA6IEEuUmVwX2tpbmQudFxuICA7IHBvcyA6IEEuTWFyay50IHJlZlxuICA7IG5hbWVzIDogKHN0cmluZyAqIGludCkgbGlzdCByZWZcbiAgOyBjYWNoZSA6IENzZXQudCBDc2V0LkNTZXRNYXAudCByZWZcbiAgOyBjb2xvcnMgOiBDb2xvcl9tYXAuVGFibGUudFxuICB9XG5cbmxldCB0cmFuc19zZXQgY2FjaGUgKGNtIDogQ29sb3JfbWFwLlRhYmxlLnQpIHMgPVxuICBtYXRjaCBDc2V0Lm9uZV9jaGFyIHMgd2l0aFxuICB8IFNvbWUgaSAtPiBDc2V0LmNzaW5nbGUgKENvbG9yX21hcC5UYWJsZS5nZXRfY2hhciBjbSBpKVxuICB8IE5vbmUgLT5cbiAgICBsZXQgdiA9IENzZXQuaGFzaCBzLCBzIGluXG4gICAgKHRyeSBDc2V0LkNTZXRNYXAuZmluZCB2ICFjYWNoZSB3aXRoXG4gICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgbGV0IGwgPSBDb2xvcl9tYXAuVGFibGUudHJhbnNsYXRlX2NvbG9ycyBjbSBzIGluXG4gICAgICAgY2FjaGUgOj0gQ3NldC5DU2V0TWFwLmFkZCB2IGwgIWNhY2hlO1xuICAgICAgIGwpXG47O1xuXG5sZXQgbWFrZV9yZXBlYXRlciBpZHMgY3Iga2luZCBncmVlZHkgPVxuICBtYXRjaCBncmVlZHkgd2l0aFxuICB8IGBHcmVlZHkgLT4gZnVuIHJlbSAtPiBBLmFsdCBpZHMgWyBBLnNlcSBpZHMga2luZCAoQS5yZW5hbWUgaWRzIGNyKSByZW07IEEuZXBzIGlkcyBdXG4gIHwgYE5vbl9ncmVlZHkgLT5cbiAgICBmdW4gcmVtIC0+IEEuYWx0IGlkcyBbIEEuZXBzIGlkczsgQS5zZXEgaWRzIGtpbmQgKEEucmVuYW1lIGlkcyBjcikgcmVtIF1cbjs7XG5cbigqIFhYWCBzaG91bGQgcHJvYmFibHkgY29tcHV0ZSBhIGNhdGVnb3J5IG1hc2sgKilcbmxldCByZWMgdHJhbnNsYXRlXG4gICh7IGlkczsga2luZDsgaWduX2dyb3VwOyBncmVlZHk7IHBvczsgbmFtZXM7IGNhY2hlOyBjb2xvcnMgfSBhcyBjdHgpXG4gIChhc3QgOiBBc3Qubm9fY2FzZSlcbiAgPVxuICBtYXRjaCBhc3Qgd2l0aFxuICB8IFNldCBzIC0+IEEuY3N0IGlkcyAodHJhbnNfc2V0IGNhY2hlIGNvbG9ycyBzKSwga2luZFxuICB8IFNlcXVlbmNlIGwgLT4gdHJhbnNfc2VxIGN0eCBsLCBraW5kXG4gIHwgQXN0IChBbHRlcm5hdGl2ZSBsKSAtPlxuICAgIChtYXRjaCBBc3QubWVyZ2Vfc2VxdWVuY2VzIGwgd2l0aFxuICAgICB8IFsgcicgXSAtPlxuICAgICAgIGxldCBjciwga2luZCcgPSB0cmFuc2xhdGUgY3R4IHInIGluXG4gICAgICAgZW5mb3JjZV9raW5kIGlkcyBraW5kIGtpbmQnIGNyLCBraW5kXG4gICAgIHwgbWVyZ2VkX3NlcXVlbmNlcyAtPlxuICAgICAgICggQS5hbHRcbiAgICAgICAgICAgaWRzXG4gICAgICAgICAgIChMaXN0Lm1hcCBtZXJnZWRfc2VxdWVuY2VzIH5mOihmdW4gcicgLT5cbiAgICAgICAgICAgICAgbGV0IGNyLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggcicgaW5cbiAgICAgICAgICAgICAgZW5mb3JjZV9raW5kIGlkcyBraW5kIGtpbmQnIGNyKSlcbiAgICAgICAsIGtpbmQgKSlcbiAgfCBSZXBlYXQgKHInLCBpLCBqKSAtPlxuICAgIGxldCBjciwga2luZCcgPSB0cmFuc2xhdGUgY3R4IHInIGluXG4gICAgbGV0IHJlbSA9XG4gICAgICBtYXRjaCBqIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBBLnJlcCBpZHMgZ3JlZWR5IGtpbmQnIGNyXG4gICAgICB8IFNvbWUgaiAtPlxuICAgICAgICBsZXQgZiA9IG1ha2VfcmVwZWF0ZXIgaWRzIGNyIGtpbmQnIGdyZWVkeSBpblxuICAgICAgICBpdGVyIChqIC0gaSkgZiAoQS5lcHMgaWRzKVxuICAgIGluXG4gICAgaXRlciBpIChmdW4gcmVtIC0+IEEuc2VxIGlkcyBraW5kJyAoQS5yZW5hbWUgaWRzIGNyKSByZW0pIHJlbSwga2luZFxuICB8IEJlZ19vZl9saW5lIC0+IEEuYWZ0ZXIgaWRzIENhdGVnb3J5LihpbmV4aXN0YW50ICsrIG5ld2xpbmUpLCBraW5kXG4gIHwgRW5kX29mX2xpbmUgLT4gQS5iZWZvcmUgaWRzIENhdGVnb3J5LihpbmV4aXN0YW50ICsrIG5ld2xpbmUpLCBraW5kXG4gIHwgQmVnX29mX3dvcmQgLT5cbiAgICAoIEEuc2VxXG4gICAgICAgIGlkc1xuICAgICAgICBgRmlyc3RcbiAgICAgICAgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LihpbmV4aXN0YW50ICsrIG5vdF9sZXR0ZXIpKVxuICAgICAgICAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LmxldHRlcilcbiAgICAsIGtpbmQgKVxuICB8IEVuZF9vZl93b3JkIC0+XG4gICAgKCBBLnNlcVxuICAgICAgICBpZHNcbiAgICAgICAgYEZpcnN0XG4gICAgICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS5sZXR0ZXIpXG4gICAgICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbm90X2xldHRlcikpXG4gICAgLCBraW5kIClcbiAgfCBOb3RfYm91bmQgLT5cbiAgICAoIEEuYWx0XG4gICAgICAgIGlkc1xuICAgICAgICBbIEEuc2VxIGlkcyBgRmlyc3QgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LmxldHRlcikgKEEuYmVmb3JlIGlkcyBDYXRlZ29yeS5sZXR0ZXIpXG4gICAgICAgIDsgKGxldCBjYXQgPSBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBub3RfbGV0dGVyKSBpblxuICAgICAgICAgICBBLnNlcSBpZHMgYEZpcnN0IChBLmFmdGVyIGlkcyBjYXQpIChBLmJlZm9yZSBpZHMgY2F0KSlcbiAgICAgICAgXVxuICAgICwga2luZCApXG4gIHwgQmVnX29mX3N0ciAtPiBBLmFmdGVyIGlkcyBDYXRlZ29yeS5pbmV4aXN0YW50LCBraW5kXG4gIHwgRW5kX29mX3N0ciAtPiBBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuaW5leGlzdGFudCwga2luZFxuICB8IExhc3RfZW5kX29mX2xpbmUgLT4gQS5iZWZvcmUgaWRzIENhdGVnb3J5LihpbmV4aXN0YW50ICsrIGxhc3RuZXdsaW5lKSwga2luZFxuICB8IFN0YXJ0IC0+IEEuYWZ0ZXIgaWRzIENhdGVnb3J5LnNlYXJjaF9ib3VuZGFyeSwga2luZFxuICB8IFN0b3AgLT4gQS5iZWZvcmUgaWRzIENhdGVnb3J5LnNlYXJjaF9ib3VuZGFyeSwga2luZFxuICB8IFNlbSAoa2luZCcsIHInKSAtPlxuICAgIGxldCBjciwga2luZCcnID0gdHJhbnNsYXRlIHsgY3R4IHdpdGgga2luZCA9IGtpbmQnIH0gcicgaW5cbiAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQnIGtpbmQnJyBjciwga2luZCdcbiAgfCBTZW1fZ3JlZWR5IChncmVlZHknLCByJykgLT4gdHJhbnNsYXRlIHsgY3R4IHdpdGggZ3JlZWR5ID0gZ3JlZWR5JyB9IHInXG4gIHwgR3JvdXAgKG4sIHInKSAtPlxuICAgIGlmIGlnbl9ncm91cFxuICAgIHRoZW4gdHJhbnNsYXRlIGN0eCByJ1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHAgPSAhcG9zIGluXG4gICAgICBsZXQgKCkgPVxuICAgICAgICBtYXRjaCBuIHdpdGhcbiAgICAgICAgfCBTb21lIG5hbWUgLT4gbmFtZXMgOj0gKG5hbWUsIEEuTWFyay5ncm91cF9jb3VudCBwKSA6OiAhbmFtZXNcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICBpblxuICAgICAgcG9zIDo9IEEuTWFyay5uZXh0MiAhcG9zO1xuICAgICAgbGV0IGNyLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggcicgaW5cbiAgICAgICggQS5zZXEgaWRzIGBGaXJzdCAoQS5tYXJrIGlkcyBwKSAoQS5zZXEgaWRzIGBGaXJzdCBjciAoQS5tYXJrIGlkcyAoQS5NYXJrLm5leHQgcCkpKVxuICAgICAgLCBraW5kJyApKVxuICB8IE5vX2dyb3VwIHInIC0+IHRyYW5zbGF0ZSB7IGN0eCB3aXRoIGlnbl9ncm91cCA9IHRydWUgfSByJ1xuICB8IE5lc3QgcicgLT5cbiAgICBsZXQgYiA9ICFwb3MgaW5cbiAgICBsZXQgY3IsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByJyBpblxuICAgIGxldCBlID0gQS5NYXJrLnByZXYgIXBvcyBpblxuICAgIGlmIEEuTWFyay5jb21wYXJlIGUgYiA9IC0xXG4gICAgdGhlbiBjciwga2luZCdcbiAgICBlbHNlIEEuc2VxIGlkcyBgRmlyc3QgKEEuZXJhc2UgaWRzIGIgZSkgY3IsIGtpbmQnXG4gIHwgUG1hcmsgKGksIHInKSAtPlxuICAgIGxldCBjciwga2luZCcgPSB0cmFuc2xhdGUgY3R4IHInIGluXG4gICAgQS5zZXEgaWRzIGBGaXJzdCAoQS5wbWFyayBpZHMgaSkgY3IsIGtpbmQnXG5cbmFuZCB0cmFuc19zZXEgKHsgaWRzOyBraW5kOyBfIH0gYXMgY3R4KSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gQS5lcHMgaWRzXG4gIHwgWyByIF0gLT5cbiAgICBsZXQgY3InLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggciBpblxuICAgIGVuZm9yY2Vfa2luZCBpZHMga2luZCBraW5kJyBjcidcbiAgfCByIDo6IHJlbSAtPlxuICAgIGxldCBjcicsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByIGluXG4gICAgbGV0IGNyJycgPSB0cmFuc19zZXEgY3R4IHJlbSBpblxuICAgIGlmIEEuaXNfZXBzIGNyJycgdGhlbiBjcicgZWxzZSBpZiBBLmlzX2VwcyBjcicgdGhlbiBjcicnIGVsc2UgQS5zZXEgaWRzIGtpbmQnIGNyJyBjcicnXG47O1xuXG5sZXQgY29tcGlsZV8xIHJlZ2V4cCA9XG4gIGxldCByZWdleHAgPSBBc3QuaGFuZGxlX2Nhc2UgZmFsc2UgcmVnZXhwIGluXG4gIGxldCBjb2xvcl9tYXAgPSBDb2xvcl9tYXAubWFrZSAoKSBpblxuICBsZXQgbmVlZF9sbmwgPSBBc3QuY29sb3JpemUgY29sb3JfbWFwIHJlZ2V4cCBpblxuICBsZXQgY29sb3JzLCBjb2xvcl9yZXByID0gQ29sb3JfbWFwLmZsYXR0ZW4gY29sb3JfbWFwIGluXG4gIGxldCBuY29sb3IgPSBDb2xvcl9tYXAuUmVwci5sZW5ndGggY29sb3JfcmVwciBpblxuICBsZXQgbG5sID0gaWYgbmVlZF9sbmwgdGhlbiBDc2V0Lm9mX2ludCBuY29sb3IgZWxzZSBDc2V0Lm51bGxfY2hhciBpblxuICBsZXQgbmNvbG9yID0gaWYgbmVlZF9sbmwgdGhlbiBuY29sb3IgKyAxIGVsc2UgbmNvbG9yIGluXG4gIGxldCBjdHggPVxuICAgIHsgaWRzID0gQS5JZHMuY3JlYXRlICgpXG4gICAgOyBraW5kID0gYEZpcnN0XG4gICAgOyBpZ25fZ3JvdXAgPSBmYWxzZVxuICAgIDsgZ3JlZWR5ID0gYEdyZWVkeVxuICAgIDsgcG9zID0gcmVmIEEuTWFyay5zdGFydFxuICAgIDsgbmFtZXMgPSByZWYgW11cbiAgICA7IGNhY2hlID0gcmVmIENzZXQuQ1NldE1hcC5lbXB0eVxuICAgIDsgY29sb3JzXG4gICAgfVxuICBpblxuICBsZXQgciwga2luZCA9IHRyYW5zbGF0ZSBjdHggcmVnZXhwIGluXG4gIGxldCByID0gZW5mb3JjZV9raW5kIGN0eC5pZHMgYEZpcnN0IGtpbmQgciBpblxuICAoKkZvcm1hdC5lcHJpbnRmIFwiPCVkICVkPkAuXCIgIWlkcyBuY29sOyopXG4gIG1rX3JlXG4gICAgfmluaXRpYWw6clxuICAgIH5jb2xvcnNcbiAgICB+Y29sb3JfcmVwclxuICAgIH5uY29sb3JcbiAgICB+bG5sXG4gICAgfmdyb3VwX25hbWVzOihMaXN0LnJldiAhKGN0eC5uYW1lcykpXG4gICAgfmdyb3VwX2NvdW50OihBLk1hcmsuZ3JvdXBfY291bnQgIShjdHgucG9zKSlcbjs7XG5cbmxldCBjb21waWxlIHIgPVxuICBsZXQgb3BlbiBBc3QuRXhwb3J0IGluXG4gIGNvbXBpbGVfMSAoaWYgQXN0LmFuY2hvcmVkIHIgdGhlbiBncm91cCByIGVsc2Ugc2VxIFsgc2hvcnRlc3QgKHJlcCBhbnkpOyBncm91cCByIF0pXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5MDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9SZV9hbGwiLCJjc3RfUmVfc3BsaXQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNiIsImEzIiwiYTQiLCJhNSIsImdsb2JhbF9kYXRhIiwiQXNzZXJ0X2ZhaWx1cmUiLCJSZV9Db21waWxlIiwiU3RkbGliX1N0cmluZyIsIlJlX0dyb3VwIiwiU3RkbGliIiwiU3RkbGliX1NlcSIsImFsbCIsIm9wdCIsImxlbiIsInJlIiwicyIsInBvcyIsImwiLCJsaW1pdCIsImF1eCIsIm9uX21hdGNoIiwicGFyYW0iLCJtYXRjaCIsInN1YnN0ciIsInAyIiwicDEiLCJtYXRjaGVzIiwic3ViIiwic3BsaXRfZnVsbCIsInN0YXRlIiwiaSIsIm9sZF9pIiwieCIsInRleHQiLCJzcGxpdCIsInNlcSIsImZpbHRlciIsInRsIiwic3BsaXRfZGVsaW0iLCJkZWxpbSIsIlJlX1NlYXJjaCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9yZS9zZWFyY2gubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFB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QW9CLE1BSVA7QUFBQSxhQUFBQyxPQUFBRCxLQUFBZDtBQUFBQSxTQUFBYyxRQUVSO0FBQUE7QUFBQSxVQUFBYixRQUFNO0FBQUEsTUFBTSxZQUNDO0FBQUEsVUFBQUEsVUFERDtBQUFBO0FBQUEsV0FBQWUsS0FBQSxVQUFBdEIsSUFBQTtBQUFBLE9BR3NDLDRCQUFULHlCQUFTO0FBQUE7QUFBQSxVQUFBb0IsUUFIdEM7QUFBQSxNQUVpQjtBQUFBO0FBQUEsSUFDc0I7QUFBQSxJQUVyRDtBQUFBLEdBQVU7QUFBQSxZQUFBRyxZQUFBdEIsS0FBQUgsS0FBQUMsSUFBQUM7QUFBQUEsUUFBQW9CLE1BSUE7QUFBQSxhQUFBQyxPQUFBRyxPQUFBSixLQUFBZDtBQUFBQSxTQUFBa0IsVUFFUixPQUFBSixRQUFBO0FBQUE7QUFBQSxVQUFBYixRQUFNO0FBQUEsTUFBTSxZQUNDLHFDQUFBRCxPQUFzQyxTQUFPLE1BS007QUFBQSxVQUFBQyxVQU5wRDtBQUFBO0FBQUEsV0FBQWUsS0FBQSxVQUFBdEIsSUFBQSxrQkFNNkI7QUFBQSxPQUFzQiw0QkFBdEIsOEJBQXNCO0FBQUE7QUFBQSxVQUFBb0IsUUFObkQ7QUFBQSxNQUdWO0FBQUEsT0FDSyx5QkFBQWQsT0FBd0IsMEJBQXdCLEdBQWhEO0FBQUEsTUFDQTtBQUFBO0FBQUE7QUFBQSxJQUN5RDtBQUFBLGNBRWxFO0FBQUEseUJEOUdGLDhCQzhHRTtBQUFBLEdBQXNCO0FBQUEsT0FBQW1CLFlEOUd4QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibGV0IGFsbCA/KHBvcyA9IDApID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5hbGxcIjtcbiAgKCogaW5kZXggb2YgdGhlIGZpcnN0IHBvc2l0aW9uIHdlIGRvIG5vdCBjb25zaWRlci5cbiAgICAgIXBvcyA8IGxpbWl0IGlzIGFuIGludmFyaWFudCAqKVxuICBsZXQgbGltaXQgPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc1xuICAgIHwgU29tZSBsIC0+XG4gICAgICBpZiBsIDwgMCB8fCBwb3MgKyBsID4gU3RyaW5nLmxlbmd0aCBzIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5hbGxcIjtcbiAgICAgIHBvcyArIGxcbiAgaW5cbiAgKCogaXRlcmF0ZSBvbiBtYXRjaGVzLiBXaGVuIGEgbWF0Y2ggaXMgZm91bmQsIHNlYXJjaCBmb3IgdGhlIG5leHRcbiAgICAgb25lIGp1c3QgYWZ0ZXIgaXRzIGVuZCAqKVxuICBsZXQgcmVjIGF1eCBwb3Mgb25fbWF0Y2ggKCkgPVxuICAgIGlmIHBvcyA+IGxpbWl0XG4gICAgdGhlbiBTZXEuTmlsICgqIG5vIG1vcmUgbWF0Y2hlcyAqKVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2hcbiAgICAgICAgQ29tcGlsZS5tYXRjaF9zdHIgfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOmZhbHNlIHJlIHMgfnBvcyB+bGVuOihsaW1pdCAtIHBvcylcbiAgICAgIHdpdGhcbiAgICAgIHwgTWF0Y2ggc3Vic3RyIC0+XG4gICAgICAgIGxldCBwMSwgcDIgPSBHcm91cC5vZmZzZXQgc3Vic3RyIDAgaW5cbiAgICAgICAgaWYgb25fbWF0Y2ggJiYgcDEgPSBwb3MgJiYgcDEgPSBwMlxuICAgICAgICB0aGVuICgqIHNraXAgZW1wdHkgbWF0Y2ggcmlnaHQgYWZ0ZXIgYSBtYXRjaCAqKVxuICAgICAgICAgIGF1eCAocG9zICsgMSkgZmFsc2UgKClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHBvcyA9IGlmIHAxID0gcDIgdGhlbiBwMiArIDEgZWxzZSBwMiBpblxuICAgICAgICAgIFNlcS5Db25zIChzdWJzdHIsIGF1eCBwb3MgKHAxIDw+IHAyKSkpXG4gICAgICB8IFJ1bm5pbmcgXyB8IEZhaWxlZCAtPiBTZXEuTmlsKVxuICBpblxuICBhdXggcG9zIGZhbHNlXG47O1xuXG5sZXQgbWF0Y2hlcyA/cG9zID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICBhbGwgP3BvcyA/bGVuIHJlIHMgfD4gU2VxLm1hcCAoZnVuIHN1YiAtPiBHcm91cC5nZXQgc3ViIDApXG47O1xuXG5sZXQgc3BsaXRfZnVsbCA/KHBvcyA9IDApID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5zcGxpdFwiO1xuICBsZXQgbGltaXQgPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc1xuICAgIHwgU29tZSBsIC0+XG4gICAgICBpZiBsIDwgMCB8fCBwb3MgKyBsID4gU3RyaW5nLmxlbmd0aCBzIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5zcGxpdFwiO1xuICAgICAgcG9zICsgbFxuICBpblxuICAoKiBpOiBzdGFydCBvZiBkZWxpbWl0ZWQgc3RyaW5nXG4gICAgIHBvczogZmlyc3QgcG9zaXRpb24gYWZ0ZXIgbGFzdCBtYXRjaCBvZiBbcmVdXG4gICAgIGxpbWl0OiBmaXJzdCBpbmRleCB3ZSBpZ25vcmUgKCFwb3MgPCBsaW1pdCBpcyBhbiBpbnZhcmlhbnQpICopXG4gIGxldCBwb3MwID0gcG9zIGluXG4gIGxldCByZWMgYXV4IHN0YXRlIGkgcG9zICgpID1cbiAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgfCBgSWRsZSB3aGVuIHBvcyA+IGxpbWl0IC0+XG4gICAgICAoKiBXZSBoYWQgYW4gZW1wdHkgbWF0Y2ggYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nICopXG4gICAgICBhc3NlcnQgKGkgPSBsaW1pdCk7XG4gICAgICBTZXEuTmlsXG4gICAgfCBgSWRsZSAtPlxuICAgICAgKG1hdGNoXG4gICAgICAgICBDb21waWxlLm1hdGNoX3N0ciB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB+cG9zIH5sZW46KGxpbWl0IC0gcG9zKVxuICAgICAgIHdpdGhcbiAgICAgICB8IE1hdGNoIHN1YnN0ciAtPlxuICAgICAgICAgbGV0IHAxLCBwMiA9IEdyb3VwLm9mZnNldCBzdWJzdHIgMCBpblxuICAgICAgICAgbGV0IHBvcyA9IGlmIHAxID0gcDIgdGhlbiBwMiArIDEgZWxzZSBwMiBpblxuICAgICAgICAgbGV0IG9sZF9pID0gaSBpblxuICAgICAgICAgbGV0IGkgPSBwMiBpblxuICAgICAgICAgaWYgb2xkX2kgPSBwMSAmJiBwMSA9IHAyICYmIHAxID4gcG9zMFxuICAgICAgICAgdGhlbiAoKiBTa2lwIGVtcHR5IG1hdGNoIHJpZ2h0IGFmdGVyIGEgZGVsaW1pdGVyICopXG4gICAgICAgICAgIGF1eCBzdGF0ZSBpIHBvcyAoKVxuICAgICAgICAgZWxzZSBpZiBwMSA+IHBvczBcbiAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAoKiBzdHJpbmcgZG9lcyBub3Qgc3RhcnQgYnkgYSBkZWxpbWl0ZXIgKilcbiAgICAgICAgICAgbGV0IHRleHQgPSBTdHJpbmcuc3ViIHMgb2xkX2kgKHAxIC0gb2xkX2kpIGluXG4gICAgICAgICAgIGxldCBzdGF0ZSA9IGBZaWVsZCAoYERlbGltIHN1YnN0cikgaW5cbiAgICAgICAgICAgU2VxLkNvbnMgKGBUZXh0IHRleHQsIGF1eCBzdGF0ZSBpIHBvcykpXG4gICAgICAgICBlbHNlIFNlcS5Db25zIChgRGVsaW0gc3Vic3RyLCBhdXggc3RhdGUgaSBwb3MpXG4gICAgICAgfCBSdW5uaW5nIF8gLT4gU2VxLk5pbFxuICAgICAgIHwgRmFpbGVkIC0+XG4gICAgICAgICBpZiBpIDwgbGltaXRcbiAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5zdWIgcyBpIChsaW1pdCAtIGkpIGluXG4gICAgICAgICAgICgqIHlpZWxkIGxhc3Qgc3RyaW5nICopXG4gICAgICAgICAgIFNlcS5Db25zIChgVGV4dCB0ZXh0LCBhdXggc3RhdGUgbGltaXQgcG9zKSlcbiAgICAgICAgIGVsc2UgU2VxLk5pbClcbiAgICB8IGBZaWVsZCB4IC0+IFNlcS5Db25zICh4LCBhdXggYElkbGUgaSBwb3MpXG4gIGluXG4gIGF1eCBgSWRsZSBwb3MgcG9zXG47O1xuXG5sZXQgc3BsaXQgP3BvcyA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgbGV0IHNlcSA9IHNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgaW5cbiAgbGV0IHJlYyBmaWx0ZXIgc2VxICgpID1cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgU2VxLk5pbCAtPiBTZXEuTmlsXG4gICAgfCBTZXEuQ29ucyAoYERlbGltIF8sIHRsKSAtPiBmaWx0ZXIgdGwgKClcbiAgICB8IFNlcS5Db25zIChgVGV4dCBzLCB0bCkgLT4gU2VxLkNvbnMgKHMsIGZpbHRlciB0bClcbiAgaW5cbiAgZmlsdGVyIHNlcVxuOztcblxubGV0IHNwbGl0X2RlbGltID9wb3MgP2xlbiByZSBzIDogXyBTZXEudCA9XG4gIGxldCBzZXEgPSBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIGluXG4gIGxldCByZWMgZmlsdGVyIH5kZWxpbSBzZXEgKCkgPVxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IGlmIGRlbGltIHRoZW4gU2VxLkNvbnMgKFwiXCIsIGZ1biAoKSAtPiBTZXEuTmlsKSBlbHNlIFNlcS5OaWxcbiAgICB8IFNlcS5Db25zIChgRGVsaW0gXywgdGwpIC0+XG4gICAgICBpZiBkZWxpbVxuICAgICAgdGhlbiBTZXEuQ29ucyAoXCJcIiwgZnVuICgpIC0+IGZpbHRlciB+ZGVsaW06dHJ1ZSB0bCAoKSlcbiAgICAgIGVsc2UgZmlsdGVyIH5kZWxpbTp0cnVlIHRsICgpXG4gICAgfCBTZXEuQ29ucyAoYFRleHQgcywgdGwpIC0+IFNlcS5Db25zIChzLCBmaWx0ZXIgfmRlbGltOmZhbHNlIHRsKVxuICBpblxuICBmaWx0ZXIgfmRlbGltOnRydWUgc2VxXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw2IiwiYTQiLCJhNSIsImdsb2JhbF9kYXRhIiwiUmVfU2VhcmNoIiwiU3RkbGliX1NlcSIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiUmVfR3JvdXAiLCJSZV9QbWFyayIsIlJlX0NvbXBpbGUiLCJTdGRsaWIiLCJSZV9Dc2V0IiwiUmVfQXN0IiwiY3NldCIsInJnIiwiYyIsIm5vdG5sIiwibG93ZXIiLCJ1cHBlciIsImFscGhhIiwiZGlnaXQiLCJhbG51bSIsIndvcmRjIiwiYXNjaWkiLCJibGFuayIsImNudHJsIiwiZ3JhcGgiLCJwcmludCIsInB1bmN0Iiwic3BhY2UiLCJ4ZGlnaXQiLCJpbmNsdWRlIiwiZW1wdHkiLCJlcHNpbG9uIiwic3RyIiwibm9fY2FzZSIsImNhc2UiLCJkaWZmIiwiY29tcGwiLCJyZXBuIiwiaW50ZXIiLCJjaGFyIiwiYW55Iiwic2V0IiwibWFyayIsIm5lc3QiLCJub19ncm91cCIsIndob2xlX3N0cmluZyIsImxlb2wiLCJsb25nZXN0IiwiZ3JlZWR5Iiwibm9uX2dyZWVkeSIsInN0b3AiLCJub3RfYm91bmRhcnkiLCJncm91cCIsIndvcmQiLCJmaXJzdCIsImJvcyIsImJvdyIsImVvdyIsImVvcyIsImJvbCIsInN0YXJ0IiwiZW9sIiwib3B0IiwicmVwIiwicmVwMSIsImFsdCIsInNob3J0ZXN0Iiwic2VxIiwicHAiLCJ3aXRuZXNzIiwiZXhlY19pbnRlcm5hbCIsInBhcnRpYWwiLCJncm91cHMiLCJyZSIsInMiLCJwb3MiLCJsZW4iLCJleGVjIiwibWF0Y2giLCJzdWJzdHIiLCJleGVjX29wdCIsImV4ZWNwIiwiZXhlY19wYXJ0aWFsIiwiZXhlY19wYXJ0aWFsX2RldGFpbGVkIiwibm9fbWF0Y2hfc3RhcnRzX2JlZm9yZSIsIm1hcmtlZCIsImciLCJwIiwibWFya19zZXQiLCJlcXVhbCIsImNvbXBhcmUiLCJnZW5fb2Zfc2VxIiwiciIsInBhcmFtIiwidGwiLCJ4Iiwic3BsaXRfZ2VuIiwic3BsaXRfZnVsbF9nZW4iLCJhbGxfZ2VuIiwibWF0Y2hlc19nZW4iLCJzcGxpdF9mdWxsX3NlcSIsInNwbGl0X3NlcSIsIm1hdGNoZXNfc2VxIiwiYWxsX3NlcSIsImdldCIsImdldF9vZnMiLCJnZXRfYWxsIiwiZ2V0X2FsbF9vZnMiLCJ0ZXN0IiwibGlzdF9vZl9zZXEiLCJsIiwiYWxsIiwibWF0Y2hlcyIsInNwbGl0X2Z1bGwiLCJzcGxpdCIsInNwbGl0X2RlbGltIiwiY29tcGlsZSIsInByaW50X3JlIiwiZ3JvdXBfbmFtZXMiLCJncm91cF9jb3VudCIsIlJlX0NvcmUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvY29yZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFB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LFlBQTNCLDBDQUEwQztBQUFBO0FBQUEsWUFBQXlDLFlBQUF4QyxLQUFBQyxLQUFBSCxJQUFBQztBQUFBQSxJQUNwQyxPQUFpQyxZQUFqQywwQ0FBZ0Q7QUFBQTtBQUFBO0FBQUEsSUFBQTBDLFVBakhwRDtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR6Qy9CIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG5vcGVuIEltcG9ydFxuXG5pbmNsdWRlIHN0cnVjdFxuICBsZXQgY3NldCA9IEFzdC5jc2V0XG4gIGxldCByZyBjIGMnID0gY3NldCAoQ3NldC5jc2VxIGMgYycpXG4gIGxldCBub3RubCA9IGNzZXQgQ3NldC5ub3RubFxuICBsZXQgbG93ZXIgPSBjc2V0IENzZXQubG93ZXJcbiAgbGV0IHVwcGVyID0gY3NldCBDc2V0LnVwcGVyXG4gIGxldCBhbHBoYSA9IGNzZXQgQ3NldC5hbHBoYVxuICBsZXQgZGlnaXQgPSBjc2V0IENzZXQuY2RpZ2l0XG4gIGxldCBhbG51bSA9IGNzZXQgQ3NldC5hbG51bVxuICBsZXQgd29yZGMgPSBjc2V0IENzZXQud29yZGNcbiAgbGV0IGFzY2lpID0gY3NldCBDc2V0LmFzY2lpXG4gIGxldCBibGFuayA9IGNzZXQgQ3NldC5ibGFua1xuICBsZXQgY250cmwgPSBjc2V0IENzZXQuY250cmxcbiAgbGV0IGdyYXBoID0gY3NldCBDc2V0LmdyYXBoXG4gIGxldCBwcmludCA9IGNzZXQgQ3NldC5wcmludFxuICBsZXQgcHVuY3QgPSBjc2V0IENzZXQucHVuY3RcbiAgbGV0IHNwYWNlID0gY3NldCBDc2V0LnNwYWNlXG4gIGxldCB4ZGlnaXQgPSBjc2V0IENzZXQueGRpZ2l0XG5lbmRcblxuaW5jbHVkZSBBc3QuRXhwb3J0XG5cbmxldCBleGVjX2ludGVybmFsID8ocG9zID0gMCkgPyhsZW4gPSAtMSkgfnBhcnRpYWwgfmdyb3VwcyByZSBzID1cbiAgQ29tcGlsZS5tYXRjaF9zdHIgfmdyb3VwcyB+cGFydGlhbCByZSBzIH5wb3MgfmxlblxuOztcblxubGV0IGV4ZWMgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsID9wb3MgP2xlbiB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB3aXRoXG4gIHwgTWF0Y2ggc3Vic3RyIC0+IHN1YnN0clxuICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG47O1xuXG5sZXQgZXhlY19vcHQgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsID9wb3MgP2xlbiB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB3aXRoXG4gIHwgTWF0Y2ggc3Vic3RyIC0+IFNvbWUgc3Vic3RyXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgZXhlY3AgPyhwb3MgPSAwKSA/KGxlbiA9IC0xKSByZSBzID0gQ29tcGlsZS5tYXRjaF9zdHJfcCB+cG9zIH5sZW4gcmUgc1xuXG5sZXQgZXhlY19wYXJ0aWFsID9wb3MgP2xlbiByZSBzID1cbiAgbWF0Y2ggZXhlY19pbnRlcm5hbCB+Z3JvdXBzOmZhbHNlIH5wYXJ0aWFsOnRydWUgP3BvcyA/bGVuIHJlIHMgd2l0aFxuICB8IE1hdGNoIF8gLT4gYEZ1bGxcbiAgfCBSdW5uaW5nIF8gLT4gYFBhcnRpYWxcbiAgfCBGYWlsZWQgLT4gYE1pc21hdGNoXG47O1xuXG5sZXQgZXhlY19wYXJ0aWFsX2RldGFpbGVkID9wb3MgP2xlbiByZSBzID1cbiAgbWF0Y2ggZXhlY19pbnRlcm5hbCB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6dHJ1ZSA/cG9zID9sZW4gcmUgcyB3aXRoXG4gIHwgTWF0Y2ggZ3JvdXAgLT4gYEZ1bGwgZ3JvdXBcbiAgfCBSdW5uaW5nIHsgbm9fbWF0Y2hfc3RhcnRzX2JlZm9yZSB9IC0+IGBQYXJ0aWFsIG5vX21hdGNoX3N0YXJ0c19iZWZvcmVcbiAgfCBGYWlsZWQgLT4gYE1pc21hdGNoXG47O1xuXG5tb2R1bGUgTWFyayA9IHN0cnVjdFxuICB0eXBlIHQgPSBQbWFyay50XG5cbiAgbGV0IHRlc3QgKGcgOiBHcm91cC50KSBwID0gUG1hcmsuU2V0Lm1lbSBwIChHcm91cC5wbWFya3MgZylcbiAgbGV0IGFsbCAoZyA6IEdyb3VwLnQpID0gR3JvdXAucG1hcmtzIGdcblxuICBtb2R1bGUgU2V0ID0gUG1hcmsuU2V0XG5cbiAgbGV0IGVxdWFsID0gUG1hcmsuZXF1YWxcbiAgbGV0IGNvbXBhcmUgPSBQbWFyay5jb21wYXJlXG5lbmRcblxudHlwZSBzcGxpdF90b2tlbiA9XG4gIFsgYFRleHQgb2Ygc3RyaW5nXG4gIHwgYERlbGltIG9mIEdyb3VwLnRcbiAgXVxuXG5tb2R1bGUgR2VuID0gc3RydWN0XG4gIHR5cGUgJ2EgZ2VuID0gdW5pdCAtPiAnYSBvcHRpb25cblxuICBsZXQgZ2VuX29mX3NlcSAocyA6ICdhIFNlcS50KSA6ICdhIGdlbiA9XG4gICAgbGV0IHIgPSByZWYgcyBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggIXIgKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IE5vbmVcbiAgICAgIHwgU2VxLkNvbnMgKHgsIHRsKSAtPlxuICAgICAgICByIDo9IHRsO1xuICAgICAgICBTb21lIHhcbiAgOztcblxuICBsZXQgc3BsaXQgP3BvcyA/bGVuIHJlIHMgOiBfIGdlbiA9IFNlYXJjaC5zcGxpdCA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG4gIGxldCBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIDogXyBnZW4gPSBTZWFyY2guc3BsaXRfZnVsbCA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG4gIGxldCBhbGwgP3BvcyA/bGVuIHJlIHMgPSBTZWFyY2guYWxsID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcbiAgbGV0IG1hdGNoZXMgP3BvcyA/bGVuIHJlIHMgPSBTZWFyY2gubWF0Y2hlcyA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG5lbmRcblxubW9kdWxlIEdyb3VwID0gR3JvdXBcblxuKCoqIHsyIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5sZXQgc3BsaXRfZnVsbF9zZXEgPSBTZWFyY2guc3BsaXRfZnVsbFxubGV0IHNwbGl0X3NlcSA9IFNlYXJjaC5zcGxpdFxubGV0IG1hdGNoZXNfc2VxID0gU2VhcmNoLm1hdGNoZXNcbmxldCBhbGxfc2VxID0gU2VhcmNoLmFsbFxuXG50eXBlICdhIGdlbiA9ICdhIEdlbi5nZW5cblxubGV0IGFsbF9nZW4gPSBHZW4uYWxsXG5sZXQgbWF0Y2hlc19nZW4gPSBHZW4ubWF0Y2hlc1xubGV0IHNwbGl0X2dlbiA9IEdlbi5zcGxpdFxubGV0IHNwbGl0X2Z1bGxfZ2VuID0gR2VuLnNwbGl0X2Z1bGxcblxudHlwZSBzdWJzdHJpbmdzID0gR3JvdXAudFxuXG5sZXQgZ2V0ID0gR3JvdXAuZ2V0XG5sZXQgZ2V0X29mcyA9IEdyb3VwLm9mZnNldFxubGV0IGdldF9hbGwgPSBHcm91cC5hbGxcbmxldCBnZXRfYWxsX29mcyA9IEdyb3VwLmFsbF9vZmZzZXRcbmxldCB0ZXN0ID0gR3JvdXAudGVzdFxuXG50eXBlIG1hcmtpZCA9IE1hcmsudFxuXG5sZXQgbWFya2VkID0gTWFyay50ZXN0XG5sZXQgbWFya19zZXQgPSBNYXJrLmFsbFxuXG50eXBlIGdyb3VwcyA9IEdyb3VwLnRcblxubW9kdWxlIExpc3QgPSBzdHJ1Y3RcbiAgbGV0IGxpc3Rfb2Zfc2VxIChzIDogJ2EgU2VxLnQpIDogJ2EgbGlzdCA9XG4gICAgU2VxLmZvbGRfbGVmdCAoZnVuIGwgeCAtPiB4IDo6IGwpIFtdIHMgfD4gTGlzdC5yZXZcbiAgOztcblxuICBsZXQgYWxsID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLmFsbCA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuICBsZXQgbWF0Y2hlcyA/cG9zID9sZW4gcmUgcyA9IFNlYXJjaC5tYXRjaGVzID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG4gIGxldCBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLnNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgfD4gbGlzdF9vZl9zZXFcbiAgbGV0IHNwbGl0ID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLnNwbGl0ID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG4gIGxldCBzcGxpdF9kZWxpbSA/cG9zID9sZW4gcmUgcyA9IFNlYXJjaC5zcGxpdF9kZWxpbSA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuZW5kXG5cbmluY2x1ZGUgTGlzdFxuXG5pbmNsdWRlIHN0cnVjdFxuICBvcGVuIENvbXBpbGVcblxuICB0eXBlIG5vbnJlYyByZSA9IHJlXG5cbiAgbGV0IGNvbXBpbGUgPSBjb21waWxlXG4gIGxldCBwcF9yZSA9IHBwX3JlXG4gIGxldCBwcmludF9yZSA9IHBwX3JlXG4gIGxldCBncm91cF9uYW1lcyA9IGdyb3VwX25hbWVzXG4gIGxldCBncm91cF9jb3VudCA9IGdyb3VwX2NvdW50XG5lbmRcblxubW9kdWxlIFNlcSA9IFNlYXJjaFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ0NjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIlBhcnNlX2Vycm9yIiwiY3JlYXRlIiwic3RyIiwidW5nZXQiLCJ0IiwianVuayIsImVvcyIsInRlc3QiLCJjIiwidGVzdDIiLCJhY2NlcHQiLCJyIiwiYWNjZXB0MiIsImdldCIsImFjY2VwdF9zIiwicyIsImxlbiIsImoiLCJpbnRlZ2VyIiwiZCIsImkiLCJSZV9QYXJzZV9idWZmZXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvcGFyc2VfYnVmZmVyLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsT0FBQUMsS0NPaUIsbUJBQWdCO0FBQUEsWUFBQUMsTUFBQUMsR0FDbkIsOEJBQWtCO0FBQUEsWUFBQUMsS0FBQUQsR0FDbkIsOEJBQWtCO0FBQUEsWUFBQUUsSUFBQUYsR0FDbkIsb0RBQTJCO0FBQUEsWUFBQUcsS0FBQUgsR0FBQUk7QUFBQUE7QUFBQUEsS0FBQSxNQUNuQjtBQUFBLFdBQU8sTUFBSztBQUFBLElBQUw7QUFBQSxHQUFzQjtBQUFBLFlBQUFDLE1BQUFMLEdBQUFJLEtBQUFBO0FBQUFBLFFBQUEsTUFHL0M7QUFBQTtBQUFBO0FBQUEsWUFBbUM7QUFBQSxZQUFhLE1BQVE7QUFBQTtBQUFBLGVBQXhEO0FBQUE7QUFBQSxHQUE4RTtBQUFBLFlBQUFFLE9BQUFOLEdBQUFJO0FBQUFBLFFBQUFHLElBSXRFO0FBQUEsSUFDUixNQUFVO0FBQUEsSUFDVjtBQUFBLEdBQUM7QUFBQSxZQUFBQyxRQUFBUixHQUFBSSxLQUFBQTtBQUFBQSxRQUFBRyxJQUlPO0FBQUEsSUFDUixNQUFVO0FBQUEsSUFDVjtBQUFBLEdBQUM7QUFBQSxZQUFBRSxJQUFBVDtBQUFBQSxRQUFBTyxJQUlPO0FBQUEsSUFDUjtBQUFBLElBQ0E7QUFBQSxHQUFDO0FBQUEsWUFBQUcsU0FBQVYsR0FBQVc7QUFBQUEsUUFBQUMsTUFJRDtBQUFBLElBQ0E7QUFBQTtBQUFBO0FBQUEsVUFBQUMsSUFBQTtBQUFBO0FBQUEsT0FFSTtBQUFBLGtCQUFpQjtBQUFBLFFBQVYsa0NBQWlDO0FBQUE7QUFBQSxrQkR2QzlDO0FBQUEsaUJDdUNNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUdGO0FBQUEsZUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVEM0NKO0FBQUEsMkJDNkNZO0FBQUEsS0Q3Q1o7QUFBQTtBQUFBLEdDNkNpQjtBQUFBLFlBQUFDLFFBQUFkO0FBQUFBLElBa0JaLFdBQ0U7QUFBQSxRQUFBZSxNQUVHO0FBQUEsSUFBSyx1QkFHVCxVQUFPO0FBQUEsUUFBQUMsTUFGWSxjQUFBQSxJQUFBO0FBQUE7QUFBQSxLQWxCcEIsV0FDRTtBQUFBLFNBQUFELElBRUc7QUFBQSxLQUFLLHFCQU1ULFVBQU87QUFBQSxTQUFBQyxNQUpQO0FBQUEsS0FDQSxZQUFlO0FBQUEsS0FDZjtBQUFBO0FBQUEsR0FjSztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUR0RVgiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsInR5cGUgdCA9XG4gIHsgc3RyIDogc3RyaW5nXG4gIDsgbXV0YWJsZSBwb3MgOiBpbnRcbiAgfVxuXG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxubGV0IGNyZWF0ZSBzdHIgPSB7IHN0cjsgcG9zID0gMCB9XG5sZXQgdW5nZXQgdCA9IHQucG9zIDwtIHQucG9zIC0gMVxubGV0IGp1bmsgdCA9IHQucG9zIDwtIHQucG9zICsgMVxubGV0IGVvcyB0ID0gdC5wb3MgPSBTdHJpbmcubGVuZ3RoIHQuc3RyXG5sZXQgdGVzdCB0IGMgPSAobm90IChlb3MgdCkpICYmIHQuc3RyLlt0LnBvc10gPSBjXG5cbmxldCB0ZXN0MiB0IGMgYycgPVxuICB0LnBvcyArIDEgPCBTdHJpbmcubGVuZ3RoIHQuc3RyICYmIHQuc3RyLlt0LnBvc10gPSBjICYmIHQuc3RyLlt0LnBvcyArIDFdID0gYydcbjs7XG5cbmxldCBhY2NlcHQgdCBjID1cbiAgbGV0IHIgPSB0ZXN0IHQgYyBpblxuICBpZiByIHRoZW4gdC5wb3MgPC0gdC5wb3MgKyAxO1xuICByXG47O1xuXG5sZXQgYWNjZXB0MiB0IGMgYycgPVxuICBsZXQgciA9IHRlc3QyIHQgYyBjJyBpblxuICBpZiByIHRoZW4gdC5wb3MgPC0gdC5wb3MgKyAyO1xuICByXG47O1xuXG5sZXQgZ2V0IHQgPVxuICBsZXQgciA9IHQuc3RyLlt0LnBvc10gaW5cbiAgdC5wb3MgPC0gdC5wb3MgKyAxO1xuICByXG47O1xuXG5sZXQgYWNjZXB0X3MgdCBzJyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMnIGluXG4gIHRyeVxuICAgIGZvciBqID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB0cnkgaWYgcycuW2pdIDw+IHQuc3RyLlt0LnBvcyArIGpdIHRoZW4gcmFpc2Vfbm90cmFjZSBFeGl0IHdpdGhcbiAgICAgIHwgXyAtPiByYWlzZV9ub3RyYWNlIEV4aXRcbiAgICBkb25lO1xuICAgIHQucG9zIDwtIHQucG9zICsgbGVuO1xuICAgIHRydWVcbiAgd2l0aFxuICB8IEV4aXQgLT4gZmFsc2Vcbjs7XG5cbmxldCByZWMgaW50ZWdlcicgdCBpID1cbiAgaWYgZW9zIHRcbiAgdGhlbiBTb21lIGlcbiAgZWxzZSAoXG4gICAgbWF0Y2ggZ2V0IHQgd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBkIC0+XG4gICAgICBsZXQgaScgPSAoMTAgKiBpKSArIChDaGFyLmNvZGUgZCAtIENoYXIuY29kZSAnMCcpIGluXG4gICAgICBpZiBpJyA8IGkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIGludGVnZXInIHQgaSdcbiAgICB8IF8gLT5cbiAgICAgIHVuZ2V0IHQ7XG4gICAgICBTb21lIGkpXG47O1xuXG5sZXQgaW50ZWdlciB0ID1cbiAgaWYgZW9zIHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIG1hdGNoIGdldCB0IHdpdGhcbiAgICB8ICcwJyAuLiAnOScgYXMgZCAtPiBpbnRlZ2VyJyB0IChDaGFyLmNvZGUgZCAtIENoYXIuY29kZSAnMCcpXG4gICAgfCBfIC0+XG4gICAgICB1bmdldCB0O1xuICAgICAgTm9uZSlcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDU3MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlJlX0NvcmUiLCJTdGRsaWJfTGlzdCIsIlJlX1BhcnNlX2J1ZmZlciIsIlBhcnNlX2Vycm9yIiwiTm90X3N1cHBvcnRlZCIsInJlIiwib3B0IiwicyIsImNhc2UiLCJidWYiLCJhY2NlcHQiLCJhY2NlcHQyIiwiZW9zIiwicGFyYW0iLCJ0ZXN0MiIsImdldCIsInJlZ2V4cCIsImxlZnQiLCJicmFuY2giLCJyIiwiYyIsImJyYWNrZXQiLCJjaGFyIiwicmVzIiwiY29tcGlsZSIsImNvbXBpbGVfcGF0IiwiUmVfRW1hY3MiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvZW1hY3MubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLEdBQUFDLEtBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLFNDc0hPO0FBQUEsS0FBQUMsTUExRks7QUFBQSxLQUFBQyxTQUNHO0FBQUEsS0FBQUMsVUFDQztBQUFBLGFBQUFDLElBQUFDLE9BQ0QsMENBQW9CO0FBQUEsUUFBQUMsUUFDckI7QUFBQSxhQUFBQyxJQUFBRixPQUNDLDBDQUFvQjtBQUFBLGFBQUFHLE9BQUFIO0FBQUFBLFNBQUFJLE9BQ0wsV0FBQUEsU0FBVztBQUFBO0FBQUEsTUFFbEMsbUNBQWdFO0FBQUE7QUFBQSxhQUFsQjtBQUFBLE9BQUFBLFNBQWhCO0FBQUEsTUFBNEI7QUFBQTtBQUFBLElBRnhCO0FBQUEsYUFBQUMsT0FBQUw7QUFBQUEsU0FBQUksT0FHdkI7QUFBQTtBQUFBLE1BRVg7QUFBQTtBQUFBO0FBQUEsYUFBVSxnQ0FBa0I7QUFBQTtBQUFBLFVBYTVCO0FBQUEsWUFBQUUsSUFDRTtBQUFBLGVBQ0c7QUFBQSxZQUFBQSxJQUNIO0FBQUEsZUFDRztBQUFBLFlBQUFBLElBQ0g7QUFBQSxlQUNHO0FBQUEsUUFDQTtBQUFBLG1CQUF5QixZQUFBQSxJQUFZO0FBQUE7QUFBQSxtQkFBYSxZQUFBQSxJQUFZO0FBQUE7QUFBQSxRQUM5RDtBQUFBLFNBZ0NILFdBQVk7QUFBQSxhQUFBQyxNQUNUO0FBQUE7QUFBQTtBQUFBLFVBQU07QUFBQSxjQUFBRCxJQUVMO0FBQUE7QUFBQTtBQUFBLFNBRGM7QUFBQTtBQUFBLFFBaENsQjtBQUFBLGFBQUFBLE1BRU87QUFBQSxTQUNEO0FBQUEsVUFBd0I7QUFBQSxhQUFBQSxJQUMvQjtBQUFBO0FBQUEsZ0JBQ007QUFBQSxhQUFBQSxJQUNIO0FBQUEsZ0JBQ0c7QUFBQSxhQUFBQSxJQUNIO0FBQUEsZ0JBQ0c7QUFBQSxhQUFBQSxJQUNIO0FBQUEsZ0JBQ0c7QUFBQTtBQUFBLFVBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBLGFBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBLGFBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBLGFBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBO0FBQUEsZ0JBQ2dCO0FBQUEsVUFBQUEsSUFBVztBQUFBLGdCQUMzQjtBQUFBO0FBQUEsZ0JBQ2tCO0FBQUEsVUFBQUEsSUFBVztBQUFBO0FBQUEsU0FFaEMsV0FBWTtBQUFBLGFBQUFDLElBQ1Q7QUFBQTtBQUFBO0FBQUEsVUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBRUk7QUFBQTtBQUFBO0FBQUEsWUFGSjtBQUFBLFVBR0w7QUFBQTtBQUFBLGFBQUFELElBRjBEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQTVDbEU7QUFBQSxhQUNFO0FBQUEsYUFDRztBQUFBO0FBQUEsZUFDSDtBQUFBLGVBQ0cseUJBQ0g7QUFBQSxRQUFBRixTQVJpQjtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQURWO0FBQUEsTUFBZSxtQ0FISDtBQUFBO0FBQUE7QUFBQSxhQUFBSSxRQUFBZDtBQUFBQSxTQUFBQSxNQTREeEI7QUFBQTtBQUFBLHNCQUFjLHdCQUNUO0FBQUEsVUFBQWEsSUFFSztBQUFBLE1BQ0w7QUFBQSxPQUVFO0FBQUEsa0JBQ2U7QUFBQSxRQUFiLDJDQUFTO0FBQUE7QUFBQSxXQUFBQSxNQUVILFdBQUFiLE1BQ0E7QUFBQSxPQUFVO0FBQUE7QUFBQSxlQUFBQSxNQUNULHNDQUFTO0FBQUE7QUFBQSxJQUFPO0FBQUEsYUFBQWUsT0FBQVQ7QUFBQUEsS0FFN0IsV0FBWTtBQUFBLEtBQ2YsYUFBTTtBQUFBO0FBQUEsUUFBQVUsTUFFRTtBQUFBLElBQ0gsZUFBYztBQUFBLElBTXJCLHNCQUFvQiw0QkFBWTtBQUFBO0FBQUEsT0FBQUMsVUR4SGxDO0FBQUEsWUFBQUMsWUFBQW5CLEtBQUFDO0FBQUFBLFFBQUFDLFNDNEhnQjtBQUFBLElBQTJCLE9BQVksb0JBQVosbUJBQVk7QUFBQTtBQUFBLE9BQUFrQixXRDVIdkQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5leGNlcHRpb24gTm90X3N1cHBvcnRlZFxuXG5sZXQgcGFyc2UgcyA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBhY2NlcHQyID0gUGFyc2VfYnVmZmVyLmFjY2VwdDIgYnVmIGluXG4gIGxldCBlb3MgKCkgPSBQYXJzZV9idWZmZXIuZW9zIGJ1ZiBpblxuICBsZXQgdGVzdDIgPSBQYXJzZV9idWZmZXIudGVzdDIgYnVmIGluXG4gIGxldCBnZXQgKCkgPSBQYXJzZV9idWZmZXIuZ2V0IGJ1ZiBpblxuICBsZXQgcmVjIHJlZ2V4cCAoKSA9IHJlZ2V4cCcgKGJyYW5jaCAoKSlcbiAgYW5kIHJlZ2V4cCcgbGVmdCA9XG4gICAgaWYgYWNjZXB0MiAnXFxcXCcgJ3wnIHRoZW4gcmVnZXhwJyAoUmUuYWx0IFsgbGVmdDsgYnJhbmNoICgpIF0pIGVsc2UgbGVmdFxuICBhbmQgYnJhbmNoICgpID0gYnJhbmNoJyBbXVxuICBhbmQgYnJhbmNoJyBsZWZ0ID1cbiAgICBpZiBlb3MgKCkgfHwgdGVzdDIgJ1xcXFwnICd8JyB8fCB0ZXN0MiAnXFxcXCcgJyknXG4gICAgdGhlbiBSZS5zZXEgKExpc3QucmV2IGxlZnQpXG4gICAgZWxzZSBicmFuY2gnIChwaWVjZSAoKSA6OiBsZWZ0KVxuICBhbmQgcGllY2UgKCkgPVxuICAgIGxldCByID0gYXRvbSAoKSBpblxuICAgIGlmIGFjY2VwdCAnKidcbiAgICB0aGVuIFJlLnJlcCByXG4gICAgZWxzZSBpZiBhY2NlcHQgJysnXG4gICAgdGhlbiBSZS5yZXAxIHJcbiAgICBlbHNlIGlmIGFjY2VwdCAnPydcbiAgICB0aGVuIFJlLm9wdCByXG4gICAgZWxzZSByXG4gIGFuZCBhdG9tICgpID1cbiAgICBpZiBhY2NlcHQgJy4nXG4gICAgdGhlbiBSZS5ub3RubFxuICAgIGVsc2UgaWYgYWNjZXB0ICdeJ1xuICAgIHRoZW4gUmUuYm9sXG4gICAgZWxzZSBpZiBhY2NlcHQgJyQnXG4gICAgdGhlbiBSZS5lb2xcbiAgICBlbHNlIGlmIGFjY2VwdCAnWydcbiAgICB0aGVuIGlmIGFjY2VwdCAnXicgdGhlbiBSZS5jb21wbCAoYnJhY2tldCBbXSkgZWxzZSBSZS5hbHQgKGJyYWNrZXQgW10pXG4gICAgZWxzZSBpZiBhY2NlcHQgJ1xcXFwnXG4gICAgdGhlblxuICAgICAgaWYgYWNjZXB0ICcoJ1xuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0MiAnXFxcXCcgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICBSZS5ncm91cCByKVxuICAgICAgZWxzZSBpZiBhY2NlcHQgJ2AnXG4gICAgICB0aGVuIFJlLmJvc1xuICAgICAgZWxzZSBpZiBhY2NlcHQgJ1xcJydcbiAgICAgIHRoZW4gUmUuZW9zXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPSdcbiAgICAgIHRoZW4gUmUuc3RhcnRcbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdiJ1xuICAgICAgdGhlbiBSZS5hbHQgWyBSZS5ib3c7IFJlLmVvdyBdXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnQidcbiAgICAgIHRoZW4gUmUubm90X2JvdW5kYXJ5XG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPCdcbiAgICAgIHRoZW4gUmUuYm93XG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPidcbiAgICAgIHRoZW4gUmUuZW93XG4gICAgICBlbHNlIGlmIGFjY2VwdCAndydcbiAgICAgIHRoZW4gUmUuYWx0IFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF1cbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdXJ1xuICAgICAgdGhlbiBSZS5jb21wbCBbIFJlLmFsbnVtOyBSZS5jaGFyICdfJyBdXG4gICAgICBlbHNlIChcbiAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAgIHwgKCcqJyB8ICcrJyB8ICc/JyB8ICdbJyB8ICddJyB8ICcuJyB8ICdeJyB8ICckJyB8ICdcXFxcJykgYXMgYyAtPiBSZS5jaGFyIGNcbiAgICAgICAgfCAnMCcgLi4gJzknIC0+IHJhaXNlIE5vdF9zdXBwb3J0ZWRcbiAgICAgICAgfCBfIC0+IHJhaXNlIFBhcnNlX2Vycm9yKVxuICAgIGVsc2UgKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAnKicgfCAnKycgfCAnPycgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIHwgYyAtPiBSZS5jaGFyIGMpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGMgPSBjaGFyICgpIGluXG4gICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICB0aGVuXG4gICAgICAgIGlmIGFjY2VwdCAnXSdcbiAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgYycgPSBjaGFyICgpIGluXG4gICAgICAgICAgYnJhY2tldCAoUmUucmcgYyBjJyA6OiBzKSlcbiAgICAgIGVsc2UgYnJhY2tldCAoUmUuY2hhciBjIDo6IHMpKVxuICBhbmQgY2hhciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgZ2V0ICgpXG4gIGluXG4gIGxldCByZXMgPSByZWdleHAgKCkgaW5cbiAgaWYgbm90IChlb3MgKCkpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gIHJlc1xuOztcblxubGV0IHJlID8oY2FzZSA9IHRydWUpIHMgPVxuICBsZXQgciA9IHBhcnNlIHMgaW5cbiAgaWYgY2FzZSB0aGVuIHIgZWxzZSBSZS5ub19jYXNlIHJcbjs7XG5cbmxldCBjb21waWxlID0gUmUuY29tcGlsZVxubGV0IGNvbXBpbGVfcGF0ID8oY2FzZSA9IHRydWUpIHMgPSBjb21waWxlIChyZSB+Y2FzZSBzKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ3NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWIiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfQnVmZmVyIiwiU3RkbGliX0J5dGVzIiwiUmVfR3JvdXAiLCJSZV9Bc3QiLCJSZV9Db21waWxlIiwiUmVfRW1hY3MiLCJSZV9Db3JlIiwiZXhlYyIsImV4ZWNfcGFydGlhbCIsImNvbXBpbGVfcmVnZXhwIiwicyIsImMiLCJyZSIsInBhcmFtIiwic3RhdGUiLCJjc3RfU3RyX3JlcGxhY2VfaWxsZWdhbF9iYWNrc2wiLCJjc3RfU3RyX2dyb3VwX2JlZ2lubmluZyIsImNzdF9TdHJfZ3JvdXBfZW5kIiwic3RyaW5nX21hdGNoIiwicCIsInJlcyIsInN0cmluZ19wYXJ0aWFsX21hdGNoIiwibWF0Y2giLCJzZWFyY2hfZm9yd2FyZCIsInNlYXJjaF9iYWNrd2FyZCIsInZhbGlkX2dyb3VwIiwibiIsIm0iLCJvZmZzZXRfZ3JvdXAiLCJpIiwicmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwibGVuIiwicSIsInZhbCIsImUiLCJiIiwiZ3JvdXAiLCJkIiwicXVvdGUiLCJidWYiLCJzdHJpbmdfYmVmb3JlIiwic3RyaW5nX2FmdGVyIiwiZmlyc3RfY2hhcnMiLCJsYXN0X2NoYXJzIiwicmVnZXhwIiwicmVnZXhwX2Nhc2VfZm9sZCIsInJlZ2V4cF9zdHJpbmciLCJyZWdleHBfc3RyaW5nX2Nhc2VfZm9sZCIsImdyb3VwX2JlZ2lubmluZyIsInBvcyIsImdyb3VwX2VuZCIsIm1hdGNoZWRfZ3JvdXAiLCJ0eHQiLCJyZXBsYWNlX21hdGNoZWQiLCJtYXRjaGVkIiwibWF0Y2hfYmVnaW5uaW5nIiwibWF0Y2hfZW5kIiwibWF0Y2hlZF9zdHJpbmciLCJzdWJzdGl0dXRlX2ZpcnN0IiwiZXhwciIsInJlcGxfZnVuIiwidGV4dCIsImdsb2JhbF9zdWJzdGl0dXRlIiwiYWNjdSIsInN0YXJ0IiwibGFzdF93YXNfZW1wdHkiLCJzdGFydHBvcyIsImVuZF9wb3MiLCJyZXBsX3RleHQiLCJnbG9iYWxfcmVwbGFjZSIsInJlcGxhY2VfZmlyc3QiLCJzZWFyY2hfZm9yd2FyZF9wcm9ncmVzcyIsImJvdW5kZWRfc3BsaXQiLCJudW0iLCJzcGxpdCIsImJvdW5kZWRfc3BsaXRfZGVsaW0iLCJzcGxpdF9kZWxpbSIsImJvdW5kZWRfZnVsbF9zcGxpdCIsImZ1bGxfc3BsaXQiLCJSZV9TdHIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvc3RyLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQWxC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TUFHQSx3Q0FBOEI7QUFBQTtBQUFBLElBQUFrQjtBQUFBQSxNRC9TekQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgKilcbigqICBsaW5raW5nIGV4Y2VwdGlvbi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kaWZpZWQgYnkgSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyIGZvciBpbnRlZ3JhdGlvbiBpbiBSRSAqKVxuXG4oKiAkSWQ6IHJlX3N0ci5tbCx2IDEuMyAyMDAyLzA3LzAzIDE1OjQ3OjU0IHZvdWlsbG9uIEV4cCAkICopXG5cbm1vZHVsZSBBc3QgPSBBc3QuRXhwb3J0XG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gQ29yZVxuXG4gIGxldCBleGVjID0gZXhlY1xuICBsZXQgZXhlY19wYXJ0aWFsID0gZXhlY19wYXJ0aWFsXG5lbmRcblxudHlwZSByZWdleHAgPVxuICB7IG10Y2ggOiBDb21waWxlLnJlIExhenkudFxuICA7IHNyY2ggOiBDb21waWxlLnJlIExhenkudFxuICB9XG5cbmxldCBjb21waWxlX3JlZ2V4cCBzIGMgPVxuICBsZXQgcmUgPSBFbWFjcy5yZSB+Y2FzZToobm90IGMpIHMgaW5cbiAgeyBtdGNoID0gbGF6eSAoQ29tcGlsZS5jb21waWxlIChBc3Quc2VxIFsgQXN0LnN0YXJ0OyByZSBdKSlcbiAgOyBzcmNoID0gbGF6eSAoQ29tcGlsZS5jb21waWxlIHJlKVxuICB9XG47O1xuXG5sZXQgc3RhdGUgPSByZWYgTm9uZVxuXG5sZXQgc3RyaW5nX21hdGNoIHJlIHMgcCA9XG4gIG1hdGNoIGV4ZWMgfnBvczpwIChMYXp5LmZvcmNlIHJlLm10Y2gpIHMgd2l0aFxuICB8IHJlcyAtPlxuICAgIHN0YXRlIDo9IFNvbWUgcmVzO1xuICAgIHRydWVcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgc3RhdGUgOj0gTm9uZTtcbiAgICBmYWxzZVxuOztcblxubGV0IHN0cmluZ19wYXJ0aWFsX21hdGNoIHJlIHMgcCA9XG4gIG1hdGNoIGV4ZWNfcGFydGlhbCB+cG9zOnAgKExhenkuZm9yY2UgcmUubXRjaCkgcyB3aXRoXG4gIHwgYEZ1bGwgLT4gc3RyaW5nX21hdGNoIHJlIHMgcFxuICB8IGBQYXJ0aWFsIC0+IHRydWVcbiAgfCBgTWlzbWF0Y2ggLT4gZmFsc2Vcbjs7XG5cbmxldCBzZWFyY2hfZm9yd2FyZCByZSBzIHAgPVxuICBtYXRjaCBleGVjIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5zcmNoKSBzIHdpdGhcbiAgfCByZXMgLT5cbiAgICBzdGF0ZSA6PSBTb21lIHJlcztcbiAgICBmc3QgKEdyb3VwLm9mZnNldCByZXMgMClcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgc3RhdGUgOj0gTm9uZTtcbiAgICByYWlzZSBOb3RfZm91bmRcbjs7XG5cbmxldCByZWMgc2VhcmNoX2JhY2t3YXJkIHJlIHMgcCA9XG4gIG1hdGNoIGV4ZWMgfnBvczpwIChMYXp5LmZvcmNlIHJlLm10Y2gpIHMgd2l0aFxuICB8IHJlcyAtPlxuICAgIHN0YXRlIDo9IFNvbWUgcmVzO1xuICAgIHBcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgc3RhdGUgOj0gTm9uZTtcbiAgICBpZiBwID0gMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlIHNlYXJjaF9iYWNrd2FyZCByZSBzIChwIC0gMSlcbjs7XG5cbmxldCB2YWxpZF9ncm91cCBuID1cbiAgbiA+PSAwXG4gICYmIG4gPCAxMFxuICAmJlxuICBtYXRjaCAhc3RhdGUgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIG0gLT4gbiA8IEdyb3VwLm5iX2dyb3VwcyBtXG47O1xuXG5sZXQgb2Zmc2V0X2dyb3VwIGkgPVxuICBtYXRjaCAhc3RhdGUgd2l0aFxuICB8IFNvbWUgbSAtPiBHcm91cC5vZmZzZXQgbSBpXG4gIHwgTm9uZSAtPiByYWlzZSBOb3RfZm91bmRcbjs7XG5cbmxldCBncm91cF9sZW4gaSA9XG4gIG1hdGNoIG9mZnNldF9ncm91cCBpIHdpdGhcbiAgfCBiLCBlIC0+IGUgLSBiXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiAwXG47O1xuXG5sZXQgcmVjIHJlcGxfbGVuZ3RoIHJlcGwgcCBxIGxlbiA9XG4gIGlmIHAgPCBsZW5cbiAgdGhlblxuICAgIGlmIHJlcGwuW3BdIDw+ICdcXFxcJ1xuICAgIHRoZW4gcmVwbF9sZW5ndGggcmVwbCAocCArIDEpIChxICsgMSkgbGVuXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcCA9IHAgKyAxIGluXG4gICAgICBpZiBwID0gbGVuIHRoZW4gZmFpbHdpdGggXCJTdHIucmVwbGFjZTogaWxsZWdhbCBiYWNrc2xhc2ggc2VxdWVuY2VcIjtcbiAgICAgIGxldCBxID1cbiAgICAgICAgbWF0Y2ggcmVwbC5bcF0gd2l0aFxuICAgICAgICB8ICdcXFxcJyAtPiBxICsgMVxuICAgICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBxICsgZ3JvdXBfbGVuIChDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCcpXG4gICAgICAgIHwgXyAtPiBxICsgMlxuICAgICAgaW5cbiAgICAgIHJlcGxfbGVuZ3RoIHJlcGwgKHAgKyAxKSBxIGxlbilcbiAgZWxzZSBxXG47O1xuXG5sZXQgcmVjIHJlcGxhY2Ugb3JpZyByZXBsIHAgcmVzIHEgbGVuID1cbiAgaWYgcCA8IGxlblxuICB0aGVuIChcbiAgICBsZXQgYyA9IHJlcGwuW3BdIGluXG4gICAgaWYgYyA8PiAnXFxcXCdcbiAgICB0aGVuIChcbiAgICAgIEJ5dGVzLnNldCByZXMgcSBjO1xuICAgICAgcmVwbGFjZSBvcmlnIHJlcGwgKHAgKyAxKSByZXMgKHEgKyAxKSBsZW4pXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCByZXBsLltwICsgMV0gd2l0aFxuICAgICAgfCAnXFxcXCcgLT5cbiAgICAgICAgQnl0ZXMuc2V0IHJlcyBxICdcXFxcJztcbiAgICAgICAgcmVwbGFjZSBvcmlnIHJlcGwgKHAgKyAyKSByZXMgKHEgKyAxKSBsZW5cbiAgICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICAgIGxldCBkID1cbiAgICAgICAgICBsZXQgZ3JvdXAgPSBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCcgaW5cbiAgICAgICAgICBtYXRjaCBvZmZzZXRfZ3JvdXAgZ3JvdXAgd2l0aFxuICAgICAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiAwXG4gICAgICAgICAgfCBiLCBlIC0+XG4gICAgICAgICAgICBsZXQgZCA9IGUgLSBiIGluXG4gICAgICAgICAgICBpZiBkID4gMCB0aGVuIFN0cmluZy5ibGl0IG9yaWcgYiByZXMgcSBkO1xuICAgICAgICAgICAgZFxuICAgICAgICBpblxuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIGQpIGxlblxuICAgICAgfCBjIC0+XG4gICAgICAgIEJ5dGVzLnNldCByZXMgcSAnXFxcXCc7XG4gICAgICAgIEJ5dGVzLnNldCByZXMgKHEgKyAxKSBjO1xuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIDIpIGxlbikpXG47O1xuXG5sZXQgcmVwbGFjZW1lbnRfdGV4dCByZXBsIG9yaWcgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCByZXBsIGluXG4gIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgKHJlcGxfbGVuZ3RoIHJlcGwgMCAwIGxlbikgaW5cbiAgcmVwbGFjZSBvcmlnIHJlcGwgMCByZXMgMCAoU3RyaW5nLmxlbmd0aCByZXBsKTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbjs7XG5cbmxldCBxdW90ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAoMiAqIGxlbikgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAoJ1snIHwgJ10nIHwgJyonIHwgJy4nIHwgJ1xcXFwnIHwgJz8nIHwgJysnIHwgJ14nIHwgJyQnKSBhcyBjIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJztcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgIHwgYyAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgZG9uZTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuOztcblxubGV0IHN0cmluZ19iZWZvcmUgcyBuID0gU3RyaW5nLnN1YiBzIDAgblxubGV0IHN0cmluZ19hZnRlciBzIG4gPSBTdHJpbmcuc3ViIHMgbiAoU3RyaW5nLmxlbmd0aCBzIC0gbilcbmxldCBmaXJzdF9jaGFycyBzIG4gPSBTdHJpbmcuc3ViIHMgMCBuXG5sZXQgbGFzdF9jaGFycyBzIG4gPSBTdHJpbmcuc3ViIHMgKFN0cmluZy5sZW5ndGggcyAtIG4pIG5cbmxldCByZWdleHAgZSA9IGNvbXBpbGVfcmVnZXhwIGUgZmFsc2VcbmxldCByZWdleHBfY2FzZV9mb2xkIGUgPSBjb21waWxlX3JlZ2V4cCBlIHRydWVcbmxldCByZWdleHBfc3RyaW5nIHMgPSBjb21waWxlX3JlZ2V4cCAocXVvdGUgcykgZmFsc2VcbmxldCByZWdleHBfc3RyaW5nX2Nhc2VfZm9sZCBzID0gY29tcGlsZV9yZWdleHAgKHF1b3RlIHMpIHRydWVcblxubGV0IGdyb3VwX2JlZ2lubmluZyBuID1cbiAgaWYgbm90ICh2YWxpZF9ncm91cCBuKSB0aGVuIGludmFsaWRfYXJnIFwiU3RyLmdyb3VwX2JlZ2lubmluZ1wiO1xuICBsZXQgcG9zID0gZnN0IChvZmZzZXRfZ3JvdXAgbikgaW5cbiAgaWYgcG9zID0gLTEgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZSBwb3Ncbjs7XG5cbmxldCBncm91cF9lbmQgbiA9XG4gIGlmIG5vdCAodmFsaWRfZ3JvdXAgbikgdGhlbiBpbnZhbGlkX2FyZyBcIlN0ci5ncm91cF9lbmRcIjtcbiAgbGV0IHBvcyA9IHNuZCAob2Zmc2V0X2dyb3VwIG4pIGluXG4gIGlmIHBvcyA9IC0xIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2UgcG9zXG47O1xuXG5sZXQgbWF0Y2hlZF9ncm91cCBuIHR4dCA9XG4gIGxldCBiLCBlID0gb2Zmc2V0X2dyb3VwIG4gaW5cbiAgU3RyaW5nLnN1YiB0eHQgYiAoZSAtIGIpXG47O1xuXG5sZXQgcmVwbGFjZV9tYXRjaGVkIHJlcGwgbWF0Y2hlZCA9IHJlcGxhY2VtZW50X3RleHQgcmVwbCBtYXRjaGVkXG5cbmxldCBtYXRjaF9iZWdpbm5pbmcgKCkgPSBncm91cF9iZWdpbm5pbmcgMFxuYW5kIG1hdGNoX2VuZCAoKSA9IGdyb3VwX2VuZCAwXG5hbmQgbWF0Y2hlZF9zdHJpbmcgdHh0ID0gbWF0Y2hlZF9ncm91cCAwIHR4dFxuXG5sZXQgc3Vic3RpdHV0ZV9maXJzdCBleHByIHJlcGxfZnVuIHRleHQgPVxuICB0cnlcbiAgICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmQgZXhwciB0ZXh0IDAgaW5cbiAgICBTdHJpbmcuY29uY2F0XG4gICAgICBcIlwiXG4gICAgICBbIHN0cmluZ19iZWZvcmUgdGV4dCBwb3M7IHJlcGxfZnVuIHRleHQ7IHN0cmluZ19hZnRlciB0ZXh0IChtYXRjaF9lbmQgKCkpIF1cbiAgd2l0aFxuICB8IE5vdF9mb3VuZCAtPiB0ZXh0XG47O1xuXG5sZXQgZ2xvYmFsX3N1YnN0aXR1dGUgZXhwciByZXBsX2Z1biB0ZXh0ID1cbiAgbGV0IHJlYyByZXBsYWNlIGFjY3Ugc3RhcnQgbGFzdF93YXNfZW1wdHkgPVxuICAgIGxldCBzdGFydHBvcyA9IGlmIGxhc3Rfd2FzX2VtcHR5IHRoZW4gc3RhcnQgKyAxIGVsc2Ugc3RhcnQgaW5cbiAgICBpZiBzdGFydHBvcyA+IFN0cmluZy5sZW5ndGggdGV4dFxuICAgIHRoZW4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggc2VhcmNoX2ZvcndhcmQgZXhwciB0ZXh0IHN0YXJ0cG9zIHdpdGhcbiAgICAgIHwgcG9zIC0+XG4gICAgICAgIGxldCBlbmRfcG9zID0gbWF0Y2hfZW5kICgpIGluXG4gICAgICAgIGxldCByZXBsX3RleHQgPSByZXBsX2Z1biB0ZXh0IGluXG4gICAgICAgIHJlcGxhY2VcbiAgICAgICAgICAocmVwbF90ZXh0IDo6IFN0cmluZy5zdWIgdGV4dCBzdGFydCAocG9zIC0gc3RhcnQpIDo6IGFjY3UpXG4gICAgICAgICAgZW5kX3Bvc1xuICAgICAgICAgIChlbmRfcG9zID0gcG9zKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IHN0cmluZ19hZnRlciB0ZXh0IHN0YXJ0IDo6IGFjY3UpXG4gIGluXG4gIFN0cmluZy5jb25jYXQgXCJcIiAoTGlzdC5yZXYgKHJlcGxhY2UgW10gMCBmYWxzZSkpXG47O1xuXG5sZXQgZ2xvYmFsX3JlcGxhY2UgZXhwciByZXBsIHRleHQgPSBnbG9iYWxfc3Vic3RpdHV0ZSBleHByIChyZXBsYWNlbWVudF90ZXh0IHJlcGwpIHRleHRcbmFuZCByZXBsYWNlX2ZpcnN0IGV4cHIgcmVwbCB0ZXh0ID0gc3Vic3RpdHV0ZV9maXJzdCBleHByIChyZXBsYWNlbWVudF90ZXh0IHJlcGwpIHRleHRcblxubGV0IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIHJlIHMgcCA9XG4gIGxldCBwb3MgPSBzZWFyY2hfZm9yd2FyZCByZSBzIHAgaW5cbiAgaWYgbWF0Y2hfZW5kICgpID4gcFxuICB0aGVuIHBvc1xuICBlbHNlIGlmIHAgPCBTdHJpbmcubGVuZ3RoIHNcbiAgdGhlbiBzZWFyY2hfZm9yd2FyZCByZSBzIChwICsgMSlcbiAgZWxzZSByYWlzZSBOb3RfZm91bmRcbjs7XG5cbmxldCBib3VuZGVkX3NwbGl0IGV4cHIgdGV4dCBudW0gPVxuICBsZXQgc3RhcnQgPSBpZiBzdHJpbmdfbWF0Y2ggZXhwciB0ZXh0IDAgdGhlbiBtYXRjaF9lbmQgKCkgZWxzZSAwIGluXG4gIGxldCByZWMgc3BsaXQgYWNjdSBzdGFydCBuID1cbiAgICBpZiBzdGFydCA+PSBTdHJpbmcubGVuZ3RoIHRleHRcbiAgICB0aGVuIGFjY3VcbiAgICBlbHNlIGlmIG4gPSAxXG4gICAgdGhlbiBzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCA6OiBhY2N1XG4gICAgZWxzZSAoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3MgLSBzdGFydCkgOjogYWNjdSkgKG1hdGNoX2VuZCAoKSkgKG4gLSAxKVxuICAgICAgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdSlcbiAgaW5cbiAgTGlzdC5yZXYgKHNwbGl0IFtdIHN0YXJ0IG51bSlcbjs7XG5cbmxldCBzcGxpdCBleHByIHRleHQgPSBib3VuZGVkX3NwbGl0IGV4cHIgdGV4dCAwXG5cbmxldCBib3VuZGVkX3NwbGl0X2RlbGltIGV4cHIgdGV4dCBudW0gPVxuICBsZXQgcmVjIHNwbGl0IGFjY3Ugc3RhcnQgbiA9XG4gICAgaWYgc3RhcnQgPiBTdHJpbmcubGVuZ3RoIHRleHRcbiAgICB0aGVuIGFjY3VcbiAgICBlbHNlIGlmIG4gPSAxXG4gICAgdGhlbiBzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCA6OiBhY2N1XG4gICAgZWxzZSAoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3MgLSBzdGFydCkgOjogYWNjdSkgKG1hdGNoX2VuZCAoKSkgKG4gLSAxKVxuICAgICAgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdSlcbiAgaW5cbiAgaWYgdGV4dCA9IFwiXCIgdGhlbiBbXSBlbHNlIExpc3QucmV2IChzcGxpdCBbXSAwIG51bSlcbjs7XG5cbmxldCBzcGxpdF9kZWxpbSBleHByIHRleHQgPSBib3VuZGVkX3NwbGl0X2RlbGltIGV4cHIgdGV4dCAwXG5cbnR5cGUgc3BsaXRfcmVzdWx0ID1cbiAgfCBUZXh0IG9mIHN0cmluZ1xuICB8IERlbGltIG9mIHN0cmluZ1xuXG5sZXQgYm91bmRlZF9mdWxsX3NwbGl0IGV4cHIgdGV4dCBudW0gPVxuICBsZXQgcmVjIHNwbGl0IGFjY3Ugc3RhcnQgbiA9XG4gICAgaWYgc3RhcnQgPj0gU3RyaW5nLmxlbmd0aCB0ZXh0XG4gICAgdGhlbiBhY2N1XG4gICAgZWxzZSBpZiBuID0gMVxuICAgIHRoZW4gVGV4dCAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3VcbiAgICBlbHNlIChcbiAgICAgIHRyeVxuICAgICAgICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmRfcHJvZ3Jlc3MgZXhwciB0ZXh0IHN0YXJ0IGluXG4gICAgICAgIGxldCBzID0gbWF0Y2hlZF9zdHJpbmcgdGV4dCBpblxuICAgICAgICBpZiBwb3MgPiBzdGFydFxuICAgICAgICB0aGVuXG4gICAgICAgICAgc3BsaXRcbiAgICAgICAgICAgIChEZWxpbSBzIDo6IFRleHQgKFN0cmluZy5zdWIgdGV4dCBzdGFydCAocG9zIC0gc3RhcnQpKSA6OiBhY2N1KVxuICAgICAgICAgICAgKG1hdGNoX2VuZCAoKSlcbiAgICAgICAgICAgIChuIC0gMSlcbiAgICAgICAgZWxzZSBzcGxpdCAoRGVsaW0gcyA6OiBhY2N1KSAobWF0Y2hfZW5kICgpKSAobiAtIDEpXG4gICAgICB3aXRoXG4gICAgICB8IE5vdF9mb3VuZCAtPiBUZXh0IChzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCkgOjogYWNjdSlcbiAgaW5cbiAgTGlzdC5yZXYgKHNwbGl0IFtdIDAgbnVtKVxuOztcblxubGV0IGZ1bGxfc3BsaXQgZXhwciB0ZXh0ID0gYm91bmRlZF9mdWxsX3NwbGl0IGV4cHIgdGV4dCAwXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTI4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X1JlX3JlcGxhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJjYW1sX2NhbGw2IiwiYTQiLCJhNSIsImdsb2JhbF9kYXRhIiwiUmVfQ29tcGlsZSIsIlN0ZGxpYl9CdWZmZXIiLCJSZV9Hcm91cCIsIlN0ZGxpYiIsInJlcGxhY2UiLCJsZW4iLCJvcHQiLCJyZSIsInMiLCJwb3MiLCJhbGwiLCJsIiwibGltaXQiLCJidWYiLCJvbl9tYXRjaCIsIm1hdGNoIiwic3Vic3RyIiwicDIiLCJwMSIsInJlcGxhY2luZyIsInJlcGxhY2Vfc3RyaW5nIiwiYnkiLCJwYXJhbSIsIlJlX1JlcGxhY2UiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvcmVwbGFjZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUCxHQUFBQyxJQUFBRSxJQUFBRSxJQUFBQyxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBbEIsaUJBQUE7QUFBQSxJQUFBQSxtQkFBQTtBQUFBLFlBQUFtQixRQUFBLEtBQUFDLEtBQUFDLEtBQUFDLElBQUFsQixHQUFBbUI7QUFBQUEsUUFBQUMsTUNBWSxrQkFBQUMsTUFBQTtBQUFBLElBQ1YsWUFBZ0I7QUFBQSxJQUNoQjtBQUFBO0FBQUEsTUFBQUMsSUFBQTtBQUFBLFlBSUk7QUFBQTtBQUFBLGFBQTJDO0FBQUEsU0FBQUMsUUFDM0M7QUFBQTtBQUFBO0FBQUEsU0FBQUEsUUFIUTtBQUFBO0FBQUEsS0FBQUMsTUFNRiw2QkFBVjtBQUFBLEtBQUFKLFFBcUNBO0FBQUEsS0FBQUssV0FBQTtBQUFBO0FBQUEsS0FsQ0U7QUFBQTtBQUFBLE9BQUFDO0FBQUFBLFNBR0k7QUFBQSxNQUEwRTtBQUFBLE9BNkJoRTtBQUFBO0FBQUE7QUFBQSxRQUFBQyxTQTdCZ0U7QUFBQSxRQUFBRCxVQUc3RDtBQUFBLFFBQUFFLEtBQXFCO0FBQUEsUUFBQUMsS0FBQTtBQUFBLE9BQ2xDO0FBQUEsUUFDSztBQUFBLG1CQUdvQztBQUFBLFNBQXBCO0FBQUE7QUFBQSxZQUFBVCxRQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FHQTtBQUFBLFdBQUFVLFlBRWdCO0FBQUEsT0FDaEI7QUFBQSxPQUErQjtBQUFBLFlBQUFMLGFBSTdCO0FBQUE7QUFBQSxTQUVRO0FBQUEsb0JBRW9DO0FBQUEsVUFBcEI7QUFBQTtBQUFBLGFBQUFMLFFBQ25CO0FBQUE7QUFBQTtBQUFBLGFBQUFBLFFBQ0c7QUFBQSxRQU5SO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FRRztBQUFBO0FBQUE7QUFBQSxLQUlDLHdDQUNLO0FBQUE7QUFBQTtBQUFBLFlBQUFXLGVBQUFYLEtBQUFKLEtBQUFLLEtBQUFILElBQUFjLElBQUFiO0FBQUFBLElBR3dCLDJDQUFBYyxPQUF5QyxVQUFFLEtBQUM7QUFBQTtBQUFBLE9BQUFDLGFEbkR6RiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibGV0IHJlcGxhY2UgPyhwb3MgPSAwKSA/bGVuID8oYWxsID0gdHJ1ZSkgcmUgfmYgcyA9XG4gIGlmIHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnJlcGxhY2VcIjtcbiAgbGV0IGxpbWl0ID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHNcbiAgICB8IFNvbWUgbCAtPlxuICAgICAgaWYgbCA8IDAgfHwgcG9zICsgbCA+IFN0cmluZy5sZW5ndGggcyB0aGVuIGludmFsaWRfYXJnIFwiUmUucmVwbGFjZVwiO1xuICAgICAgcG9zICsgbFxuICBpblxuICAoKiBidWZmZXIgaW50byB3aGljaCB3ZSB3cml0ZSB0aGUgcmVzdWx0ICopXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMpIGluXG4gICgqIGl0ZXJhdGUgb24gbWF0Y2hlZCBzdWJzdHJpbmdzLiAqKVxuICBsZXQgcmVjIGl0ZXIgcG9zIG9uX21hdGNoID1cbiAgICBpZiBwb3MgPD0gbGltaXRcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoXG4gICAgICAgIENvbXBpbGUubWF0Y2hfc3RyIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIH5wb3MgfmxlbjoobGltaXQgLSBwb3MpXG4gICAgICB3aXRoXG4gICAgICB8IE1hdGNoIHN1YnN0ciAtPlxuICAgICAgICBsZXQgcDEsIHAyID0gR3JvdXAub2Zmc2V0IHN1YnN0ciAwIGluXG4gICAgICAgIGlmIHBvcyA9IHAxICYmIHAxID0gcDIgJiYgb25fbWF0Y2hcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogaWYgd2UgbWF0Y2hlZCBhbiBlbXB0eSBzdHJpbmcgcmlnaHQgYWZ0ZXIgYSBtYXRjaCxcbiAgICAgICAgICAgICB3ZSBtdXN0IG1hbnVhbGx5IGFkdmFuY2UgYnkgMSAqKVxuICAgICAgICAgIGlmIHAyIDwgbGltaXQgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmIHMuW3AyXTtcbiAgICAgICAgICBpdGVyIChwMiArIDEpIGZhbHNlKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBhZGQgc3RyaW5nIGJldHdlZW4gcHJldmlvdXMgbWF0Y2ggYW5kIGN1cnJlbnQgbWF0Y2ggKilcbiAgICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgcyBwb3MgKHAxIC0gcG9zKTtcbiAgICAgICAgICAoKiB3aGF0IHNob3VsZCB3ZSByZXBsYWNlIHRoZSBtYXRjaGVkIGdyb3VwIHdpdGg/ICopXG4gICAgICAgICAgbGV0IHJlcGxhY2luZyA9IGYgc3Vic3RyIGluXG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHJlcGxhY2luZztcbiAgICAgICAgICBpZiBhbGxcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAoKiBpZiB3ZSBtYXRjaGVkIGFuIGVtcHR5IHN0cmluZywgd2UgbXVzdCBtYW51YWxseSBhZHZhbmNlIGJ5IDEgKilcbiAgICAgICAgICAgIGl0ZXJcbiAgICAgICAgICAgICAgKGlmIHAxID0gcDJcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAoKiBhIG5vbiBjaGFyIGNvdWxkIGJlIHBhc3QgdGhlIGVuZCBvZiBzdHJpbmcuIGUuZy4gJCAqKVxuICAgICAgICAgICAgICAgICBpZiBwMiA8IGxpbWl0IHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiBzLltwMl07XG4gICAgICAgICAgICAgICAgIHAyICsgMSlcbiAgICAgICAgICAgICAgIGVsc2UgcDIpXG4gICAgICAgICAgICAgIChwMSA8PiBwMilcbiAgICAgICAgICBlbHNlIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzIHAyIChsaW1pdCAtIHAyKSlcbiAgICAgIHwgUnVubmluZyBfIC0+ICgpXG4gICAgICB8IEZhaWxlZCAtPiBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgcyBwb3MgKGxpbWl0IC0gcG9zKSlcbiAgaW5cbiAgaXRlciBwb3MgZmFsc2U7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcbjs7XG5cbmxldCByZXBsYWNlX3N0cmluZyA/cG9zID9sZW4gP2FsbCByZSB+YnkgcyA9IHJlcGxhY2UgP3BvcyA/bGVuID9hbGwgcmUgcyB+ZjooZnVuIF8gLT4gYnkpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTM5NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiYmVnIiwiUmVfQ29yZSIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYiIsIlJlX1BhcnNlX2J1ZmZlciIsIlBhcnNlX2Vycm9yIiwibXVsIiwibCIsInMiLCJleHBsaWNpdF9wZXJpb2QiLCJ0Iiwic2xhc2hlcyIsImFwcGVuZCIsIm9wdCIsInBpZWNlIiwiYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50IiwibmV4dCIsIm1hdGNoIiwicmVtYWluaW5nIiwib25lIiwiZXhwbGljaXRfc2xhc2giLCJlbmNsb3NlZCIsImMiLCJoaWdoIiwibG93IiwiZW5jbG9zZWRfc2V0Iiwia2luZCIsInNldCIsImVuY2xvc3VyZSIsImV4YWN0bHkiLCJzdGF0ZSIsImNoYXJzIiwibWFueV9tYW55IiwiZmlyc3RfZXhwbGljaXRfcGVyaW9kIiwibWF0Y2hfY29tcG9uZW50IiwiZ2xvYiIsInN0ciIsImFuY2hvcmVkIiwicGF0aG5hbWUiLCJtYXRjaF9iYWNrc2xhc2hlcyIsInBlcmlvZCIsImV4cGFuZF9icmFjZXMiLCJkb3VibGVfYXN0ZXJpc2siLCJ0b19yZSIsImJ1ZiIsImVvcyIsInBhcmFtIiwicmVhZCIsImNoYXIiLCJwaWVjZXMiLCJyZSIsIm5vdF9lbXB0eSIsIm1heWJlX2VtcHR5IiwiZXhwbCIsImlubmVyIiwiaSIsImFjYyIsImdsb2J4IiwiUmVfR2xvYiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lh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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQU41RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQVMsVUFHQztBQUFBLGFBQUFzQyxNQUFtQztBQUFBLGFBQUE3QyxJQUFBO0FBQUEsYUFBQVg7QUFBQUEsZUFDMUI7QUFBQTtBQUFBLGlCQUFTO0FBQUE7QUFBQSxvQkFBTztBQUFBO0FBQUE7QUFBQSxZQUE4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUcxRDtBQUFBO0FBQUE7QUFBQSxnQkFBUztBQUFBO0FBQUE7QUFBQSxtQkFBVTtBQUFBO0FBQUEsYUFBViwyREFBMEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FBQXdELE1BTnBEO0FBQUEsVUFBQUEsTUFPSDtBQUFBO0FBQUE7QUFBQSxJQUE2QjtBQUFBO0FBQUEsV0FFMUI7QUFBQSxXQUEwQjtBQUFBLFdBbU5YO0FBQUEsSUFBNEIsbUNBQWE7QUFBQTtBQUFBLFlBQUFwQixPQUFBRSxVQUFBRyxRQUFBaEM7QUFBQUEsSUFHekMsaURBQXdCO0FBQUE7QUFBQSxZQUFBaUQsTUFBQXBCLFVBQUE3QixHQUMvQix5Q0FBb0M7QUFBQSxZQUFBaUQsUUFBQXBCLFVBQUFHLFFBQUFoQztBQUFBQSxJQUM1QixtREFBNEM7QUFBQTtBQUFBLE9BQUFrRCxVRGhVNUUiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5cbnR5cGUgZW5jbG9zZWQgPVxuICB8IENoYXIgb2YgY2hhclxuICB8IFJhbmdlIG9mIGNoYXIgKiBjaGFyXG5cbnR5cGUgcGllY2UgPVxuICB8IEV4YWN0bHkgb2YgY2hhclxuICB8IEFueV9vZiBvZiBlbmNsb3NlZCBsaXN0XG4gIHwgQW55X2J1dCBvZiBlbmNsb3NlZCBsaXN0XG4gIHwgT25lXG4gIHwgTWFueVxuICB8IE1hbnlNYW55XG5cbnR5cGUgdCA9IHBpZWNlIGxpc3RcblxubGV0IG9mX3N0cmluZyB+ZG91YmxlX2FzdGVyaXNrIHMgOiB0ID1cbiAgbGV0IGJ1ZiA9IFBhcnNlX2J1ZmZlci5jcmVhdGUgcyBpblxuICBsZXQgZW9zICgpID0gUGFyc2VfYnVmZmVyLmVvcyBidWYgaW5cbiAgbGV0IHJlYWQgYyA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGMgaW5cbiAgbGV0IGNoYXIgKCkgPVxuICAgIGlnbm9yZSAocmVhZCAnXFxcXCcgOiBib29sKTtcbiAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICBQYXJzZV9idWZmZXIuZ2V0IGJ1ZlxuICBpblxuICBsZXQgZW5jbG9zZWQgKCkgOiBlbmNsb3NlZCBsaXN0ID1cbiAgICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgICAoKiBUaGlzIHJldHVybnMgdGhlIGxpc3QgaW4gcmV2ZXJzZSBvcmRlciwgYnV0IG9yZGVyIGlzbid0IGltcG9ydGFudFxuICAgICAgICAgYW55d2F5ICopXG4gICAgICBpZiBzIDw+IFtdICYmIHJlYWQgJ10nXG4gICAgICB0aGVuIHNcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYyA9IGNoYXIgKCkgaW5cbiAgICAgICAgaWYgbm90IChyZWFkICctJylcbiAgICAgICAgdGhlbiBsb29wIChDaGFyIGMgOjogcylcbiAgICAgICAgZWxzZSBpZiByZWFkICddJ1xuICAgICAgICB0aGVuIENoYXIgYyA6OiBDaGFyICctJyA6OiBzXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBjJyA9IGNoYXIgKCkgaW5cbiAgICAgICAgICBsb29wIChSYW5nZSAoYywgYycpIDo6IHMpKSlcbiAgICBpblxuICAgIGxvb3AgW11cbiAgaW5cbiAgbGV0IHBpZWNlIGFjYyA9XG4gICAgaWYgZG91YmxlX2FzdGVyaXNrICYmIFBhcnNlX2J1ZmZlci5hY2NlcHRfcyBidWYgXCIvKipcIlxuICAgIHRoZW4gTWFueU1hbnkgOjogKGlmIGVvcyAoKSB0aGVuIEV4YWN0bHkgJy8nIDo6IGFjYyBlbHNlIGFjYylcbiAgICBlbHNlIGlmIHJlYWQgJyonXG4gICAgdGhlbiAoaWYgZG91YmxlX2FzdGVyaXNrICYmIHJlYWQgJyonIHRoZW4gTWFueU1hbnkgZWxzZSBNYW55KSA6OiBhY2NcbiAgICBlbHNlIGlmIHJlYWQgJz8nXG4gICAgdGhlbiBPbmUgOjogYWNjXG4gICAgZWxzZSBpZiBub3QgKHJlYWQgJ1snKVxuICAgIHRoZW4gRXhhY3RseSAoY2hhciAoKSkgOjogYWNjXG4gICAgZWxzZSBpZiByZWFkICdeJyB8fCByZWFkICchJ1xuICAgIHRoZW4gQW55X2J1dCAoZW5jbG9zZWQgKCkpIDo6IGFjY1xuICAgIGVsc2UgQW55X29mIChlbmNsb3NlZCAoKSkgOjogYWNjXG4gIGluXG4gIGxldCByZWMgbG9vcCBwaWVjZXMgPSBpZiBlb3MgKCkgdGhlbiBMaXN0LnJldiBwaWVjZXMgZWxzZSBsb29wIChwaWVjZSBwaWVjZXMpIGluXG4gIGxvb3AgW11cbjs7XG5cbmxldCBtdWwgbCBsJyA9IExpc3QuZmxhdHRlbiAoTGlzdC5tYXAgKGZ1biBzIC0+IExpc3QubWFwIChmdW4gcycgLT4gcyBeIHMnKSBsJykgbClcblxubGV0IGV4cGxvZGUgc3RyID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVjIGV4cGwgaW5uZXIgcyBpIGFjYyBiZWcgPVxuICAgIGlmIGkgPj0gbFxuICAgIHRoZW4gKFxuICAgICAgaWYgaW5uZXIgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG11bCBiZWcgWyBTdHJpbmcuc3ViIHN0ciBzIChpIC0gcykgXSwgaSlcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgfCAnXFxcXCcgLT4gZXhwbCBpbm5lciBzIChpICsgMikgYWNjIGJlZ1xuICAgICAgfCAneycgLT5cbiAgICAgICAgbGV0IHQsIGknID0gZXhwbCB0cnVlIChpICsgMSkgKGkgKyAxKSBbXSBbIFwiXCIgXSBpblxuICAgICAgICBleHBsIGlubmVyIGknIGknIGFjYyAobXVsIGJlZyAobXVsIFsgU3RyaW5nLnN1YiBzdHIgcyAoaSAtIHMpIF0gdCkpXG4gICAgICB8ICcsJyB3aGVuIGlubmVyIC0+XG4gICAgICAgIGV4cGwgaW5uZXIgKGkgKyAxKSAoaSArIDEpIChtdWwgYmVnIFsgU3RyaW5nLnN1YiBzdHIgcyAoaSAtIHMpIF0gQCBhY2MpIFsgXCJcIiBdXG4gICAgICB8ICd9JyB3aGVuIGlubmVyIC0+IG11bCBiZWcgWyBTdHJpbmcuc3ViIHN0ciBzIChpIC0gcykgXSBAIGFjYywgaSArIDFcbiAgICAgIHwgXyAtPiBleHBsIGlubmVyIHMgKGkgKyAxKSBhY2MgYmVnKVxuICBpblxuICBMaXN0LnJldiAoZnN0IChleHBsIGZhbHNlIDAgMCBbXSBbIFwiXCIgXSkpXG47O1xuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHJlX3BpZWNlcyA6IFJlLnQgbGlzdCAoKiBsYXN0IHBpZWNlIGF0IGhlYWQgb2YgbGlzdC4gKilcbiAgICA7IHJlbWFpbmluZyA6IHBpZWNlIGxpc3QgKCogbGFzdCBwaWVjZSBhdCB0YWlsIG9mIGxpc3QuICopXG4gICAgOyBhbV9hdF9zdGFydF9vZl9wYXR0ZXJuIDogYm9vbCAoKiB0cnVlIGF0IHN0YXJ0IG9mIHBhdHRlcm4gKilcbiAgICA7IGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCA6IGJvb2xcbiAgICAgICAgKCogdHJ1ZSBhdCBzdGFydCBvZiBwYXR0ZXJuIG9yIGltbWVkaWF0ZWx5XG4gICAgICAgICAgIGFmdGVyICcvJyAqKVxuICAgIDsgcGF0aG5hbWUgOiBib29sXG4gICAgOyBtYXRjaF9iYWNrc2xhc2hlcyA6IGJvb2xcbiAgICA7IHBlcmlvZCA6IGJvb2xcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSB+cGVyaW9kIH5wYXRobmFtZSB+bWF0Y2hfYmFja3NsYXNoZXMgcmVtYWluaW5nID1cbiAgICB7IHJlX3BpZWNlcyA9IFtdXG4gICAgOyBhbV9hdF9zdGFydF9vZl9wYXR0ZXJuID0gdHJ1ZVxuICAgIDsgYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ID0gdHJ1ZVxuICAgIDsgcGF0aG5hbWVcbiAgICA7IG1hdGNoX2JhY2tzbGFzaGVzXG4gICAgOyBwZXJpb2RcbiAgICA7IHJlbWFpbmluZ1xuICAgIH1cbiAgOztcblxuICBsZXQgZXhwbGljaXRfcGVyaW9kIHQgPVxuICAgIHQucGVyaW9kICYmICh0LmFtX2F0X3N0YXJ0X29mX3BhdHRlcm4gfHwgKHQuYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ICYmIHQucGF0aG5hbWUpKVxuICA7O1xuXG4gIGxldCBleHBsaWNpdF9zbGFzaCB0ID0gdC5wYXRobmFtZVxuICBsZXQgc2xhc2hlcyB0ID0gaWYgdC5tYXRjaF9iYWNrc2xhc2hlcyB0aGVuIFsgJy8nOyAnXFxcXCcgXSBlbHNlIFsgJy8nIF1cblxuICBsZXQgYXBwZW5kID8oYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ID0gZmFsc2UpIHQgcGllY2UgPVxuICAgIHsgdCB3aXRoXG4gICAgICByZV9waWVjZXMgPSBwaWVjZSA6OiB0LnJlX3BpZWNlc1xuICAgIDsgYW1fYXRfc3RhcnRfb2ZfcGF0dGVybiA9IGZhbHNlXG4gICAgOyBhbV9hdF9zdGFydF9vZl9jb21wb25lbnRcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHRvX3JlIHQgPSBSZS5zZXEgKExpc3QucmV2IHQucmVfcGllY2VzKVxuXG4gIGxldCBuZXh0IHQgPVxuICAgIG1hdGNoIHQucmVtYWluaW5nIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHBpZWNlIDo6IHJlbWFpbmluZyAtPiBTb21lIChwaWVjZSwgeyB0IHdpdGggcmVtYWluaW5nIH0pXG4gIDs7XG5lbmRcblxubGV0IG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZCA9XG4gIFJlLmNvbXBsXG4gICAgKExpc3QuY29uY2F0XG4gICAgICAgWyAoaWYgZXhwbGljaXRfc2xhc2ggdGhlbiBMaXN0Lm1hcCBSZS5jaGFyIHNsYXNoZXMgZWxzZSBbXSlcbiAgICAgICA7IChpZiBleHBsaWNpdF9wZXJpb2QgdGhlbiBbIFJlLmNoYXIgJy4nIF0gZWxzZSBbXSlcbiAgICAgICBdKVxuOztcblxubGV0IGVuY2xvc2VkIGVuY2xvc2VkID1cbiAgbWF0Y2ggZW5jbG9zZWQgd2l0aFxuICB8IENoYXIgYyAtPiBSZS5jaGFyIGNcbiAgfCBSYW5nZSAobG93LCBoaWdoKSAtPiBSZS5yZyBsb3cgaGlnaFxuOztcblxubGV0IGVuY2xvc2VkX3NldCB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZCBraW5kIHNldCA9XG4gIGxldCBzZXQgPSBMaXN0Lm1hcCBlbmNsb3NlZCBzZXQgaW5cbiAgbGV0IGVuY2xvc3VyZSA9XG4gICAgbWF0Y2gga2luZCB3aXRoXG4gICAgfCBgQW55X29mIC0+IFJlLmFsdCBzZXRcbiAgICB8IGBBbnlfYnV0IC0+IFJlLmNvbXBsIHNldFxuICBpblxuICBSZS5pbnRlciBbIGVuY2xvc3VyZTsgb25lIH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kIF1cbjs7XG5cbmxldCBleGFjdGx5IHN0YXRlIGMgPVxuICBsZXQgc2xhc2hlcyA9IFN0YXRlLnNsYXNoZXMgc3RhdGUgaW5cbiAgbGV0IGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCA9IExpc3QubWVtIGMgc2xhc2hlcyBpblxuICBsZXQgY2hhcnMgPSBpZiBhbV9hdF9zdGFydF9vZl9jb21wb25lbnQgdGhlbiBzbGFzaGVzIGVsc2UgWyBjIF0gaW5cbiAgU3RhdGUuYXBwZW5kIHN0YXRlIChSZS5hbHQgKExpc3QubWFwIFJlLmNoYXIgY2hhcnMpKSB+YW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50XG47O1xuXG5sZXQgbWFueV9tYW55IHN0YXRlID1cbiAgbGV0IGV4cGxpY2l0X3BlcmlvZCA9IHN0YXRlLlN0YXRlLnBlcmlvZCAmJiBzdGF0ZS5TdGF0ZS5wYXRobmFtZSBpblxuICBsZXQgZmlyc3RfZXhwbGljaXRfcGVyaW9kID0gU3RhdGUuZXhwbGljaXRfcGVyaW9kIHN0YXRlIGluXG4gIGxldCBzbGFzaGVzID0gU3RhdGUuc2xhc2hlcyBzdGF0ZSBpblxuICBsZXQgbWF0Y2hfY29tcG9uZW50IH5leHBsaWNpdF9wZXJpb2QgPVxuICAgIFJlLnNlcVxuICAgICAgWyBvbmUgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZFxuICAgICAgOyBSZS5yZXAgKG9uZSB+ZXhwbGljaXRfc2xhc2g6dHJ1ZSB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kOmZhbHNlKVxuICAgICAgXVxuICBpblxuICAoKiBXZSBtdXN0IG1hdGNoIGNvbXBvbmVudHMgaW5kaXZpZHVhbGx5IHdoZW4gW3BlcmlvZF0gZmxhZyBpcyBzZXQsXG4gICAgIG1ha2luZyBzdXJlIHRvIG5vdCBtYXRjaCBbXCJmb28vLmJhclwiXS4gKilcbiAgU3RhdGUuYXBwZW5kXG4gICAgc3RhdGVcbiAgICAoUmUuc2VxXG4gICAgICAgWyBSZS5vcHQgKG1hdGNoX2NvbXBvbmVudCB+ZXhwbGljaXRfcGVyaW9kOmZpcnN0X2V4cGxpY2l0X3BlcmlvZClcbiAgICAgICA7IFJlLnJlcFxuICAgICAgICAgICAoUmUuc2VxXG4gICAgICAgICAgICAgIFsgUmUuYWx0IChMaXN0Lm1hcCBSZS5jaGFyIHNsYXNoZXMpXG4gICAgICAgICAgICAgIDsgUmUub3B0IChtYXRjaF9jb21wb25lbnQgfmV4cGxpY2l0X3BlcmlvZClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICBdKVxuOztcblxubGV0IG1hbnkgKHN0YXRlIDogU3RhdGUudCkgPVxuICBsZXQgZXhwbGljaXRfc2xhc2ggPSBTdGF0ZS5leHBsaWNpdF9zbGFzaCBzdGF0ZSBpblxuICBsZXQgZXhwbGljaXRfcGVyaW9kID0gU3RhdGUuZXhwbGljaXRfcGVyaW9kIHN0YXRlIGluXG4gIGxldCBzbGFzaGVzID0gU3RhdGUuc2xhc2hlcyBzdGF0ZSBpblxuICAoKiBXaGV0aGVyIHdlIG11c3QgZXhwbGljaXRseSBtYXRjaCBwZXJpb2QgZGVwZW5kcyBvbiB0aGUgc3Vycm91bmRpbmdcbiAgICAgY2hhcmFjdGVycywgYnV0IHNsYXNoZXMgYXJlIGVhc3kgdG8gZXhwbGljaXQgbWF0Y2guIFRoaXMgY29uZGl0aW9uYWxcbiAgICAgc3BsaXRzIG91dCBzb21lIHNpbXBsZSBjYXNlcy4gKilcbiAgaWYgbm90IGV4cGxpY2l0X3BlcmlvZFxuICB0aGVuIFN0YXRlLmFwcGVuZCBzdGF0ZSAoUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QpKVxuICBlbHNlIGlmIG5vdCBleHBsaWNpdF9zbGFzaFxuICB0aGVuXG4gICAgKCogSW4gdGhpcyBzdGF0ZSwgd2UgZXhwbGljaXRseSBtYXRjaCBwZXJpb2RzIG9ubHkgYXQgdGhlIHZlcnkgYmVnaW5uaW5nICopXG4gICAgU3RhdGUuYXBwZW5kXG4gICAgICBzdGF0ZVxuICAgICAgKFJlLm9wdFxuICAgICAgICAgKFJlLnNlcVxuICAgICAgICAgICAgWyBvbmUgfmV4cGxpY2l0X3NsYXNoOmZhbHNlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2RcbiAgICAgICAgICAgIDsgUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoOmZhbHNlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q6ZmFsc2UpXG4gICAgICAgICAgICBdKSlcbiAgZWxzZSAoXG4gICAgbGV0IG5vdF9lbXB0eSA9XG4gICAgICBSZS5zZXFcbiAgICAgICAgWyBvbmUgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDp0cnVlXG4gICAgICAgIDsgUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDpmYWxzZSlcbiAgICAgICAgXVxuICAgIGluXG4gICAgKCogW21heWJlX2VtcHR5XSBpcyB0aGUgZGVmYXVsdCB0cmFuc2xhdGlvbiBvZiBNYW55LCBleGNlcHQgaW4gc29tZSBzcGVjaWFsXG4gICAgICAgY2FzZXMuICopXG4gICAgbGV0IG1heWJlX2VtcHR5ID0gUmUub3B0IG5vdF9lbXB0eSBpblxuICAgIGxldCBlbmNsb3NlZF9zZXQgc3RhdGUga2luZCBzZXQgPVxuICAgICAgU3RhdGUuYXBwZW5kXG4gICAgICAgIHN0YXRlXG4gICAgICAgIChSZS5hbHRcbiAgICAgICAgICAgWyBlbmNsb3NlZF9zZXQga2luZCBzZXQgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDp0cnVlXG4gICAgICAgICAgIDsgUmUuc2VxXG4gICAgICAgICAgICAgICBbIG5vdF9lbXB0eVxuICAgICAgICAgICAgICAgOyAoKiBTaW5jZSBbbm90X2VtcHR5XSBtYXRjaGVkLCBzdWJzZXF1ZW50IGRvdHMgYXJlIG5vdCBsZWFkaW5nLiAqKVxuICAgICAgICAgICAgICAgICBlbmNsb3NlZF9zZXRcbiAgICAgICAgICAgICAgICAgICBraW5kXG4gICAgICAgICAgICAgICAgICAgc2V0XG4gICAgICAgICAgICAgICAgICAgfmV4cGxpY2l0X3NsYXNoOnRydWVcbiAgICAgICAgICAgICAgICAgICB+c2xhc2hlc1xuICAgICAgICAgICAgICAgICAgIH5leHBsaWNpdF9wZXJpb2Q6ZmFsc2VcbiAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgXSlcbiAgICBpblxuICAgIGxldCByZWMgbG9va2FoZWFkIHN0YXRlID1cbiAgICAgIG1hdGNoIFN0YXRlLm5leHQgc3RhdGUgd2l0aFxuICAgICAgfCBOb25lIC0+IFN0YXRlLmFwcGVuZCBzdGF0ZSBtYXliZV9lbXB0eVxuICAgICAgKCogZ2xvYiAqKiA9PT0gZ2xvYiAqIC4gKilcbiAgICAgIHwgU29tZSAoTWFueSwgc3RhdGUpIC0+IGxvb2thaGVhZCBzdGF0ZVxuICAgICAgfCBTb21lIChFeGFjdGx5IGMsIHN0YXRlKSAtPlxuICAgICAgICBsZXQgc3RhdGUgPSBTdGF0ZS5hcHBlbmQgc3RhdGUgKGlmIGMgPSAnLicgdGhlbiBub3RfZW1wdHkgZWxzZSBtYXliZV9lbXB0eSkgaW5cbiAgICAgICAgZXhhY3RseSBzdGF0ZSBjXG4gICAgICAoKiBnbG9iICo/ID09PSBnbG9iID8qICopXG4gICAgICB8IFNvbWUgKE9uZSwgc3RhdGUpIC0+IFN0YXRlLmFwcGVuZCBzdGF0ZSBub3RfZW1wdHlcbiAgICAgIHwgU29tZSAoQW55X29mIGVuY2xvc2VkLCBzdGF0ZSkgLT4gZW5jbG9zZWRfc2V0IHN0YXRlIGBBbnlfb2YgZW5jbG9zZWRcbiAgICAgIHwgU29tZSAoQW55X2J1dCBlbmNsb3NlZCwgc3RhdGUpIC0+IGVuY2xvc2VkX3NldCBzdGF0ZSBgQW55X2J1dCBlbmNsb3NlZFxuICAgICAgKCogKiB0aGVuICoqID09PSAqKiAqKVxuICAgICAgfCBTb21lIChNYW55TWFueSwgc3RhdGUpIC0+IG1hbnlfbWFueSBzdGF0ZVxuICAgIGluXG4gICAgbG9va2FoZWFkIHN0YXRlKVxuOztcblxubGV0IHBpZWNlIHN0YXRlIHBpZWNlID1cbiAgbGV0IGV4cGxpY2l0X3NsYXNoID0gU3RhdGUuZXhwbGljaXRfc2xhc2ggc3RhdGUgaW5cbiAgbGV0IGV4cGxpY2l0X3BlcmlvZCA9IFN0YXRlLmV4cGxpY2l0X3BlcmlvZCBzdGF0ZSBpblxuICBsZXQgc2xhc2hlcyA9IFN0YXRlLnNsYXNoZXMgc3RhdGUgaW5cbiAgbWF0Y2ggcGllY2Ugd2l0aFxuICB8IE9uZSAtPiBTdGF0ZS5hcHBlbmQgc3RhdGUgKG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZClcbiAgfCBNYW55IC0+IG1hbnkgc3RhdGVcbiAgfCBBbnlfb2YgZW5jbG9zZWQgLT5cbiAgICBTdGF0ZS5hcHBlbmRcbiAgICAgIHN0YXRlXG4gICAgICAoZW5jbG9zZWRfc2V0IGBBbnlfb2YgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QgZW5jbG9zZWQpXG4gIHwgQW55X2J1dCBlbmNsb3NlZCAtPlxuICAgIFN0YXRlLmFwcGVuZFxuICAgICAgc3RhdGVcbiAgICAgIChlbmNsb3NlZF9zZXQgYEFueV9idXQgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QgZW5jbG9zZWQpXG4gIHwgRXhhY3RseSBjIC0+IGV4YWN0bHkgc3RhdGUgY1xuICB8IE1hbnlNYW55IC0+IG1hbnlfbWFueSBzdGF0ZVxuOztcblxubGV0IGdsb2IgfnBhdGhuYW1lIH5tYXRjaF9iYWNrc2xhc2hlcyB+cGVyaW9kIGdsb2IgPVxuICBsZXQgcmVjIGxvb3Agc3RhdGUgPVxuICAgIG1hdGNoIFN0YXRlLm5leHQgc3RhdGUgd2l0aFxuICAgIHwgTm9uZSAtPiBTdGF0ZS50b19yZSBzdGF0ZVxuICAgIHwgU29tZSAocCwgc3RhdGUpIC0+IGxvb3AgKHBpZWNlIHN0YXRlIHApXG4gIGluXG4gIGxvb3AgKFN0YXRlLmNyZWF0ZSB+cGF0aG5hbWUgfm1hdGNoX2JhY2tzbGFzaGVzIH5wZXJpb2QgZ2xvYilcbjs7XG5cbmxldCBnbG9iXG4gID8oYW5jaG9yZWQgPSBmYWxzZSlcbiAgPyhwYXRobmFtZSA9IHRydWUpXG4gID8obWF0Y2hfYmFja3NsYXNoZXMgPSBmYWxzZSlcbiAgPyhwZXJpb2QgPSB0cnVlKVxuICA/KGV4cGFuZF9icmFjZXMgPSBmYWxzZSlcbiAgPyhkb3VibGVfYXN0ZXJpc2sgPSB0cnVlKVxuICBzXG4gID1cbiAgbGV0IHRvX3JlIHMgPVxuICAgIGxldCByZSA9IGdsb2IgfnBhdGhuYW1lIH5tYXRjaF9iYWNrc2xhc2hlcyB+cGVyaW9kIChvZl9zdHJpbmcgfmRvdWJsZV9hc3RlcmlzayBzKSBpblxuICAgIGlmIGFuY2hvcmVkIHRoZW4gUmUud2hvbGVfc3RyaW5nIHJlIGVsc2UgcmVcbiAgaW5cbiAgaWYgZXhwYW5kX2JyYWNlcyB0aGVuIFJlLmFsdCAoTGlzdC5tYXAgdG9fcmUgKGV4cGxvZGUgcykpIGVsc2UgdG9fcmUgc1xuOztcblxubGV0IGdsb2InID9hbmNob3JlZCBwZXJpb2QgcyA9IGdsb2IgP2FuY2hvcmVkIH5wZXJpb2Qgc1xubGV0IGdsb2J4ID9hbmNob3JlZCBzID0gZ2xvYiA/YW5jaG9yZWQgfmV4cGFuZF9icmFjZXM6dHJ1ZSBzXG5sZXQgZ2xvYngnID9hbmNob3JlZCBwZXJpb2QgcyA9IGdsb2IgP2FuY2hvcmVkIH5leHBhbmRfYnJhY2VzOnRydWUgfnBlcmlvZCBzXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTg0OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2FsbnVtIiwiY3N0X2FscGhhIiwiY3N0X2FzY2lpIiwiY3N0X2JsYW5rIiwiY3N0X2NudHJsIiwiY3N0X2RpZ2l0IiwiY3N0X2dyYXBoIiwiY3N0X2xvd2VyIiwiY3N0X3ByaW50IiwiY3N0X3B1bmN0IiwiY3N0X3NwYWNlIiwiY3N0X3VwcGVyIiwiY3N0X3dvcmQiLCJjc3RfeGRpZ2l0IiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsImNzdCIsIm5hbWVzIiwiUmVfUGFyc2VfYnVmZmVyIiwiU3RkbGliX0xpc3QiLCJTdGRsaWIiLCJSZV9Db3JlIiwiY3N0X0ludmFsaWRfcGNyZV9jbGFzcyIsIm9mX25hbWUiLCJjbGFzcyIsInN3aXRjaCIsInBhcnNlIiwiYnVmIiwiYWNjZXB0IiwiYWNjZXB0X3MiLCJjb21wbCIsImNscyIsInBvc2l4X2NsYXNzIiwiUmVfUG9zaXhfY2xhc3MiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvcG9zaXhfY2xhc3MubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxZQUFBQyxRQUFBQztBQUFBQSxRQUFBQyxXQ0VjO0FBQUE7QUFBQSx1QkFPQztBQUFBLEtBUEQsMEJBUUM7QUFBQSxLQVJELDBCQVlDO0FBQUEsS0FaRCwwQkFTQztBQUFBLEtBVEQsMEJBVUM7QUFBQSxLQVZELHlCQVdBO0FBQUEsS0FYQSwyQkFjRTtBQUFBO0FBQUE7QUFBQSxLQWRGLDBCQUVDO0FBQUEsS0FGRCwwQkFDQztBQUFBLEtBREQsMEJBR0M7QUFBQSxLQUhELDBCQUlDO0FBQUEsS0FKRCwwQkFLQztBQUFBLEtBTEQsMEJBTUM7QUFBQSxLQU5ELDBCQWFDO0FBQUE7QUFBQSxjQUVXO0FBQUEsSUFBaUM7QUFBQTtBQUFBLFlBQUFDLE1BQUFDO0FBQUFBO0FBQUFBLEtBQUFDLFNBc0I1QztBQUFBLEtBQUFDLFdBQ0U7QUFBQSxJQUNULDZCQUNLO0FBQUEsUUFBQUMsUUFFRztBQUFBLElBQ1osUUFBQUMsTUFDTTtBQUFBO0FBQUEsZUQ5Q1Y7QUFBQTtBQUFBLE1DK0NxQjtBQUFBLEtEL0NyQjtBQUFBO0FBQUEsSUNpRFc7QUFBQSxLQUFxQjtBQUFBO0FBQUEsS0FBQUMsY0FDVjtBQUFBLFdBQ2xCLFFBQW9CO0FBQUEsSUFBcEI7QUFBQSxHQUE4RDtBQUFBLE9BQUFDLGlCRG5EbEUiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm1vZHVsZSBSZSA9IENvcmVcblxubGV0IG9mX25hbWUgPSBmdW5jdGlvblxuICB8IFwiYWxwaGFcIiAtPiBSZS5hbHBoYVxuICB8IFwiYWxudW1cIiAtPiBSZS5hbG51bVxuICB8IFwiYXNjaWlcIiAtPiBSZS5hc2NpaVxuICB8IFwiYmxhbmtcIiAtPiBSZS5ibGFua1xuICB8IFwiY250cmxcIiAtPiBSZS5jbnRybFxuICB8IFwiZGlnaXRcIiAtPiBSZS5kaWdpdFxuICB8IFwibG93ZXJcIiAtPiBSZS5sb3dlclxuICB8IFwicHJpbnRcIiAtPiBSZS5wcmludFxuICB8IFwic3BhY2VcIiAtPiBSZS5zcGFjZVxuICB8IFwidXBwZXJcIiAtPiBSZS51cHBlclxuICB8IFwid29yZFwiIC0+IFJlLndvcmRjXG4gIHwgXCJwdW5jdFwiIC0+IFJlLnB1bmN0XG4gIHwgXCJncmFwaFwiIC0+IFJlLmdyYXBoXG4gIHwgXCJ4ZGlnaXRcIiAtPiBSZS54ZGlnaXRcbiAgfCBjbGFzc18gLT4gaW52YWxpZF9hcmcgKFwiSW52YWxpZCBwY3JlIGNsYXNzOiBcIiBeIGNsYXNzXylcbjs7XG5cbmxldCBuYW1lcyA9XG4gIFsgXCJhbHBoYVwiXG4gIDsgXCJhbG51bVwiXG4gIDsgXCJhc2NpaVwiXG4gIDsgXCJibGFua1wiXG4gIDsgXCJjbnRybFwiXG4gIDsgXCJkaWdpdFwiXG4gIDsgXCJsb3dlclwiXG4gIDsgXCJwcmludFwiXG4gIDsgXCJzcGFjZVwiXG4gIDsgXCJ1cHBlclwiXG4gIDsgXCJ3b3JkXCJcbiAgOyBcInB1bmN0XCJcbiAgOyBcImdyYXBoXCJcbiAgOyBcInhkaWdpdFwiXG4gIF1cbjs7XG5cbmxldCBwYXJzZSBidWYgPVxuICBsZXQgYWNjZXB0ID0gUGFyc2VfYnVmZmVyLmFjY2VwdCBidWYgaW5cbiAgbGV0IGFjY2VwdF9zID0gUGFyc2VfYnVmZmVyLmFjY2VwdF9zIGJ1ZiBpblxuICBtYXRjaCBhY2NlcHQgJzonIHdpdGhcbiAgfCBmYWxzZSAtPiBOb25lXG4gIHwgdHJ1ZSAtPlxuICAgIGxldCBjb21wbCA9IGFjY2VwdCAnXicgaW5cbiAgICBsZXQgY2xzID1cbiAgICAgIHRyeSBMaXN0LmZpbmQgYWNjZXB0X3MgbmFtZXMgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gcmFpc2UgUGFyc2VfYnVmZmVyLlBhcnNlX2Vycm9yXG4gICAgaW5cbiAgICBpZiBub3QgKGFjY2VwdF9zIFwiOl1cIikgdGhlbiByYWlzZSBQYXJzZV9idWZmZXIuUGFyc2VfZXJyb3I7XG4gICAgbGV0IHBvc2l4X2NsYXNzID0gb2ZfbmFtZSBjbHMgaW5cbiAgICBTb21lIChpZiBjb21wbCB0aGVuIFJlLmNvbXBsIFsgcG9zaXhfY2xhc3MgXSBlbHNlIHBvc2l4X2NsYXNzKVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1OTU1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX211bCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9MaXN0IiwiUmVfQ29yZSIsIlJlX1BhcnNlX2J1ZmZlciIsIlN0ZGxpYl9CdWZmZXIiLCJSZV9Qb3NpeF9jbGFzcyIsIlN0ZGxpYiIsIlBhcnNlX2Vycm9yIiwiTm90X3N1cHBvcnRlZCIsImNoYXJfb2ZfaW50IiwieCIsInJlIiwib3B0IiwicyIsIm9wdHMiLCJ1bmdyZWVkeSIsImRvdGFsbCIsImRvbGxhcl9lbmRvbmx5IiwibXVsdGlsaW5lIiwiYnVmIiwiYWNjZXB0IiwiZW9zIiwicGFyYW0iLCJ0ZXN0IiwiYyIsImdldCIsImdyZWVkeV9tb2QiLCJyIiwiZ3IiLCJyZWdleHAiLCJsZWZ0IiwiYnJhbmNoIiwibWF0Y2giLCJpIiwiaiIsImluX2JyYWNlIiwiaW5pdCIsImFjYyIsImF0b20iLCJuMSIsInN3aXRjaGVyIiwicCIsImRpZ2l0cyIsImQiLCJjMSIsImMyIiwiY29kZSIsIm4yIiwibjMiLCJiIiwibmFtZSIsImhleGRpZ2l0IiwibWF5YmVfb2N0YWxkaWdpdCIsImJyYWNrZXQiLCJzdCIsImNoYXIiLCJzZXQiLCJyZXMiLCJjb21waWxlIiwiY29tcGlsZV9wYXQiLCJSZV9QZXJsIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3JlL3BlcmwubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1B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QUFBLFVBVWMsaUVBQXVCO0FBQUE7QUFBQSxVQUZ2QixpRUFBdUI7QUFBQTtBQUFBLG9CQUZEO0FBQUEsVUFBdEIsbUVBQW9DO0FBQUE7QUFBQSxVQUx6QztBQUFBO0FBQUEsVUFRQTtBQUFBO0FBQUEsVUFQQTtBQUFBO0FBQUEsVUFDQTtBQUFBO0FBQUEsVUFJQTtBQUFBO0FBQUEsVUFIQTtBQUFBO0FBQUEsb0JBQ3lCO0FBQUEsVUFBcEIsbUVBQWtDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFNbkI7QUFBQTtBQUFBO0FBQUEsd0JBQ2I7QUFBQSxLQUNUO0FBQUEsSUFDRztBQUFBLFFBQUFpQyxNQVNKO0FBQUEsSUFDSCxlQUFjO0FBQUE7QUFBQSxLQUFBOUI7QUFBQUEsT0FzQlY7QUFBQSxVQUE4QjtBQUFBO0FBQUEsS0FBQUE7QUFBQUEsT0FDOUI7QUFBQSxVQUE4QjtBQUFBO0FBQUEsSUFDekM7QUFBQSxHQUFDO0FBQUEsT0FBQStCLFVBdlNEO0FBQUEsWUFBQUMsWUFBQS9DLEtBQUFDO0FBQUFBLFFBQUFDLE9BMlNjO0FBQUEsSUFBeUIsT0FBWSxvQkFBWixpQkFBWTtBQUFBO0FBQUEsT0FBQThDLFVBM1NuRDtBQUFBO0FBQUE7QUFBQSxFRHBDRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxubW9kdWxlIFJlID0gQ29yZVxuXG5leGNlcHRpb24gUGFyc2VfZXJyb3IgPSBQYXJzZV9idWZmZXIuUGFyc2VfZXJyb3JcbmV4Y2VwdGlvbiBOb3Rfc3VwcG9ydGVkXG5cbmxldCBhY2NfZGlnaXRzID1cbiAgbGV0IHJlYyBsb29wIGJhc2UgZGlnaXRzIGFjYyBpID1cbiAgICBtYXRjaCBkaWdpdHMgd2l0aFxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBkIDo6IGRpZ2l0cyAtPlxuICAgICAgbGV0IGFjYyA9IGFjYyArIChkICogaSkgaW5cbiAgICAgIGxldCBpID0gaSAqIGkgaW5cbiAgICAgIGxvb3AgYmFzZSBkaWdpdHMgYWNjIGlcbiAgaW5cbiAgZnVuIH5iYXNlIH5kaWdpdHMgLT4gbG9vcCBiYXNlIGRpZ2l0cyAwIDFcbjs7XG5cbmxldCBjaGFyX29mX2ludCB4ID1cbiAgbWF0Y2ggY2hhcl9vZl9pbnQgeCB3aXRoXG4gIHwgeCAtPiB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gcmFpc2UgUGFyc2VfZXJyb3Jcbjs7XG5cbmxldCBwYXJzZSBtdWx0aWxpbmUgZG9sbGFyX2VuZG9ubHkgZG90YWxsIHVuZ3JlZWR5IHMgPVxuICBsZXQgYnVmID0gUGFyc2VfYnVmZmVyLmNyZWF0ZSBzIGluXG4gIGxldCBhY2NlcHQgPSBQYXJzZV9idWZmZXIuYWNjZXB0IGJ1ZiBpblxuICBsZXQgZW9zICgpID0gUGFyc2VfYnVmZmVyLmVvcyBidWYgaW5cbiAgbGV0IHRlc3QgYyA9IFBhcnNlX2J1ZmZlci50ZXN0IGJ1ZiBjIGluXG4gIGxldCB1bmdldCAoKSA9IFBhcnNlX2J1ZmZlci51bmdldCBidWYgaW5cbiAgbGV0IGdldCAoKSA9IFBhcnNlX2J1ZmZlci5nZXQgYnVmIGluXG4gIGxldCBncmVlZHlfbW9kIHIgPVxuICAgIGxldCBnciA9IGFjY2VwdCAnPycgaW5cbiAgICBsZXQgZ3IgPSBpZiB1bmdyZWVkeSB0aGVuIG5vdCBnciBlbHNlIGdyIGluXG4gICAgaWYgZ3IgdGhlbiBSZS5ub25fZ3JlZWR5IHIgZWxzZSBSZS5ncmVlZHkgclxuICBpblxuICBsZXQgcmVjIHJlZ2V4cCAoKSA9IHJlZ2V4cCcgKGJyYW5jaCAoKSlcbiAgYW5kIHJlZ2V4cCcgbGVmdCA9IGlmIGFjY2VwdCAnfCcgdGhlbiByZWdleHAnIChSZS5hbHQgWyBsZWZ0OyBicmFuY2ggKCkgXSkgZWxzZSBsZWZ0XG4gIGFuZCBicmFuY2ggKCkgPSBicmFuY2gnIFtdXG4gIGFuZCBicmFuY2gnIGxlZnQgPVxuICAgIGlmIGVvcyAoKSB8fCB0ZXN0ICd8JyB8fCB0ZXN0ICcpJ1xuICAgIHRoZW4gUmUuc2VxIChMaXN0LnJldiBsZWZ0KVxuICAgIGVsc2UgYnJhbmNoJyAocGllY2UgKCkgOjogbGVmdClcbiAgYW5kIGluX2JyYWNlIH5mIH5pbml0ID1cbiAgICBtYXRjaCBhY2NlcHQgJ3snIHdpdGhcbiAgICB8IGZhbHNlIC0+IE5vbmVcbiAgICB8IHRydWUgLT5cbiAgICAgIGxldCByZWMgbG9vcCBhY2MgPVxuICAgICAgICBpZiBhY2NlcHQgJ30nXG4gICAgICAgIHRoZW4gYWNjXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBhY2MgPSBmIGFjYyBpblxuICAgICAgICAgIGxvb3AgYWNjKVxuICAgICAgaW5cbiAgICAgIFNvbWUgKGxvb3AgaW5pdClcbiAgYW5kIHBpZWNlICgpID1cbiAgICBsZXQgciA9IGF0b20gKCkgaW5cbiAgICBpZiBhY2NlcHQgJyonXG4gICAgdGhlbiBncmVlZHlfbW9kIChSZS5yZXAgcilcbiAgICBlbHNlIGlmIGFjY2VwdCAnKydcbiAgICB0aGVuIGdyZWVkeV9tb2QgKFJlLnJlcDEgcilcbiAgICBlbHNlIGlmIGFjY2VwdCAnPydcbiAgICB0aGVuIGdyZWVkeV9tb2QgKFJlLm9wdCByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICd7J1xuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggUGFyc2VfYnVmZmVyLmludGVnZXIgYnVmIHdpdGhcbiAgICAgIHwgU29tZSBpIC0+XG4gICAgICAgIGxldCBqID0gaWYgYWNjZXB0ICcsJyB0aGVuIFBhcnNlX2J1ZmZlci5pbnRlZ2VyIGJ1ZiBlbHNlIFNvbWUgaSBpblxuICAgICAgICBpZiBub3QgKGFjY2VwdCAnfScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIChtYXRjaCBqIHdpdGhcbiAgICAgICAgIHwgU29tZSBqIHdoZW4gaiA8IGkgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgICAgIHwgXyAtPiAoKSk7XG4gICAgICAgIGdyZWVkeV9tb2QgKFJlLnJlcG4gciBpIGopXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgdW5nZXQgKCk7XG4gICAgICAgIHIpXG4gICAgZWxzZSByXG4gIGFuZCBhdG9tICgpID1cbiAgICBpZiBhY2NlcHQgJy4nXG4gICAgdGhlbiBpZiBkb3RhbGwgdGhlbiBSZS5hbnkgZWxzZSBSZS5ub3RubFxuICAgIGVsc2UgaWYgYWNjZXB0ICcoJ1xuICAgIHRoZW5cbiAgICAgIGlmIGFjY2VwdCAnPydcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgYWNjZXB0ICc6J1xuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgciA9IHJlZ2V4cCAoKSBpblxuICAgICAgICAgIGlmIG5vdCAoYWNjZXB0ICcpJykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgICByKVxuICAgICAgICBlbHNlIGlmIGFjY2VwdCAnIydcbiAgICAgICAgdGhlbiBjb21tZW50ICgpXG4gICAgICAgIGVsc2UgaWYgYWNjZXB0ICc8J1xuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbmFtZSA9IG5hbWUgKCkgaW5cbiAgICAgICAgICBsZXQgciA9IHJlZ2V4cCAoKSBpblxuICAgICAgICAgIGlmIG5vdCAoYWNjZXB0ICcpJykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgICBSZS5ncm91cCB+bmFtZSByKVxuICAgICAgICBlbHNlIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHIgPSByZWdleHAgKCkgaW5cbiAgICAgICAgaWYgbm90IChhY2NlcHQgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICBSZS5ncm91cCByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICdeJ1xuICAgIHRoZW4gaWYgbXVsdGlsaW5lIHRoZW4gUmUuYm9sIGVsc2UgUmUuYm9zXG4gICAgZWxzZSBpZiBhY2NlcHQgJyQnXG4gICAgdGhlbiBpZiBtdWx0aWxpbmUgdGhlbiBSZS5lb2wgZWxzZSBpZiBkb2xsYXJfZW5kb25seSB0aGVuIFJlLmxlb2wgZWxzZSBSZS5lb3NcbiAgICBlbHNlIGlmIGFjY2VwdCAnWydcbiAgICB0aGVuIGlmIGFjY2VwdCAnXicgdGhlbiBSZS5jb21wbCAoYnJhY2tldCBbXSkgZWxzZSBSZS5hbHQgKGJyYWNrZXQgW10pXG4gICAgZWxzZSBpZiBhY2NlcHQgJ1xcXFwnXG4gICAgdGhlbiAoXG4gICAgICAoKiBYWFhcbiAgICAgICAgIC0gQmFjay1yZWZlcmVuY2VzXG4gICAgICAgICAtIFxcY3ggKGNvbnRyb2wteCksIFxcZGRkXG4gICAgICAqKVxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAndycgLT4gUmUuYWx0IFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF1cbiAgICAgIHwgJ1cnIC0+IFJlLmNvbXBsIFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF1cbiAgICAgIHwgJ3MnIC0+IFJlLnNwYWNlXG4gICAgICB8ICdTJyAtPiBSZS5jb21wbCBbIFJlLnNwYWNlIF1cbiAgICAgIHwgJ2QnIC0+IFJlLmRpZ2l0XG4gICAgICB8ICdEJyAtPiBSZS5jb21wbCBbIFJlLmRpZ2l0IF1cbiAgICAgIHwgJ2InIC0+IFJlLmFsdCBbIFJlLmJvdzsgUmUuZW93IF1cbiAgICAgIHwgJ0InIC0+IFJlLm5vdF9ib3VuZGFyeVxuICAgICAgfCAnQScgLT4gUmUuYm9zXG4gICAgICB8ICdaJyAtPiBSZS5sZW9sXG4gICAgICB8ICd6JyAtPiBSZS5lb3NcbiAgICAgIHwgJ0cnIC0+IFJlLnN0YXJ0XG4gICAgICB8ICdlJyAtPiBSZS5jaGFyICdcXHgxYidcbiAgICAgIHwgJ2YnIC0+IFJlLmNoYXIgJ1xceDBjJ1xuICAgICAgfCAnbicgLT4gUmUuY2hhciAnXFxuJ1xuICAgICAgfCAncicgLT4gUmUuY2hhciAnXFxyJ1xuICAgICAgfCAndCcgLT4gUmUuY2hhciAnXFx0J1xuICAgICAgfCAnUScgLT4gcXVvdGUgKEJ1ZmZlci5jcmVhdGUgMTIpXG4gICAgICB8ICdFJyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCAneCcgLT5cbiAgICAgICAgbGV0IGMxLCBjMiA9XG4gICAgICAgICAgbWF0Y2ggaW5fYnJhY2UgfmluaXQ6W10gfmY6KGZ1biBhY2MgLT4gaGV4ZGlnaXQgKCkgOjogYWNjKSB3aXRoXG4gICAgICAgICAgfCBTb21lIFsgYzE7IGMyIF0gLT4gYzEsIGMyXG4gICAgICAgICAgfCBTb21lIFsgYzIgXSAtPiAwLCBjMlxuICAgICAgICAgIHwgU29tZSBfIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBsZXQgYzEgPSBoZXhkaWdpdCAoKSBpblxuICAgICAgICAgICAgbGV0IGMyID0gaGV4ZGlnaXQgKCkgaW5cbiAgICAgICAgICAgIGMxLCBjMlxuICAgICAgICBpblxuICAgICAgICBsZXQgY29kZSA9IChjMSAqIDE2KSArIGMyIGluXG4gICAgICAgIFJlLmNoYXIgKGNoYXJfb2ZfaW50IGNvZGUpXG4gICAgICB8ICdvJyAtPlxuICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgaW5fYnJhY2UgfmluaXQ6W10gfmY6KGZ1biBhY2MgLT5cbiAgICAgICAgICAgICBtYXRjaCBtYXliZV9vY3RhbGRpZ2l0ICgpIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgICAgICAgICB8IFNvbWUgcCAtPiBwIDo6IGFjYylcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgICAgfCBTb21lIGRpZ2l0cyAtPiBSZS5jaGFyIChjaGFyX29mX2ludCAoYWNjX2RpZ2l0cyB+YmFzZTo4IH5kaWdpdHMpKSlcbiAgICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIHwgJzAnIC4uICc3JyBhcyBuMSAtPlxuICAgICAgICBsZXQgbjIgPSBtYXliZV9vY3RhbGRpZ2l0ICgpIGluXG4gICAgICAgIGxldCBuMyA9IG1heWJlX29jdGFsZGlnaXQgKCkgaW5cbiAgICAgICAgKG1hdGNoIG4yLCBuMyB3aXRoXG4gICAgICAgICB8IFNvbWUgbjIsIFNvbWUgbjMgLT5cbiAgICAgICAgICAgbGV0IG4xID0gQ2hhci5jb2RlIG4xIC0gQ2hhci5jb2RlICcwJyBpblxuICAgICAgICAgICBSZS5jaGFyIChjaGFyX29mX2ludCAoKG4xICogKDggKiA4KSkgKyAobjIgKiA4KSArIG4zKSlcbiAgICAgICAgIHwgXywgXyAtPiByYWlzZSBOb3Rfc3VwcG9ydGVkKVxuICAgICAgfCAnOCcgLi4gJzknIC0+IHJhaXNlIE5vdF9zdXBwb3J0ZWRcbiAgICAgIHwgYyAtPiBSZS5jaGFyIGMpXG4gICAgZWxzZSAoXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICB8ICcqJyB8ICcrJyB8ICc/JyB8ICd7JyB8ICdcXFxcJyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCBjIC0+IFJlLmNoYXIgYylcbiAgYW5kIHF1b3RlIGJ1ZiA9XG4gICAgaWYgYWNjZXB0ICdcXFxcJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAnRScgLT4gUmUuc3RyIChCdWZmZXIuY29udGVudHMgYnVmKVxuICAgICAgfCBjIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcXFwnO1xuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGM7XG4gICAgICAgIHF1b3RlIGJ1ZilcbiAgICBlbHNlIChcbiAgICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAoZ2V0ICgpKTtcbiAgICAgIHF1b3RlIGJ1ZilcbiAgYW5kIGhleGRpZ2l0ICgpID1cbiAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBkIC0+IENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ2EnIC4uICdmJyBhcyBkIC0+IENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCAnQScgLi4gJ0YnIGFzIGQgLT4gQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgYW5kIG1heWJlX29jdGFsZGlnaXQgKCkgPVxuICAgIGlmIGVvcyAoKVxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgIHwgJzAnIC4uICc3JyBhcyBkIC0+IFNvbWUgKENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICcwJylcbiAgICAgIHwgXyAtPiBOb25lKVxuICBhbmQgbmFtZSAoKSA9XG4gICAgaWYgZW9zICgpXG4gICAgdGhlbiByYWlzZSBQYXJzZV9lcnJvclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgIHwgKCdfJyB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onKSBhcyBjIC0+XG4gICAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAzMiBpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjO1xuICAgICAgICBuYW1lJyBiXG4gICAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3IpXG4gIGFuZCBuYW1lJyBiID1cbiAgICBpZiBlb3MgKClcbiAgICB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAoJ18nIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknKSBhcyBjIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGM7XG4gICAgICAgIG5hbWUnIGJcbiAgICAgIHwgJz4nIC0+IEJ1ZmZlci5jb250ZW50cyBiXG4gICAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3IpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggY2hhciAoKSB3aXRoXG4gICAgICB8IGBTZXQgc3QgLT4gYnJhY2tldCAoc3QgOjogcylcbiAgICAgIHwgYENoYXIgYyAtPlxuICAgICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBhY2NlcHQgJ10nXG4gICAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyYWNrZXRcbiAgICAgICAgICAgICAgKG1hdGNoIGNoYXIgKCkgd2l0aFxuICAgICAgICAgICAgICAgfCBgQ2hhciBjJyAtPiBSZS5yZyBjIGMnIDo6IHNcbiAgICAgICAgICAgICAgIHwgYFNldCBzdCcgLT4gUmUuY2hhciBjIDo6IFJlLmNoYXIgJy0nIDo6IHN0JyA6OiBzKVxuICAgICAgICBlbHNlIGJyYWNrZXQgKFJlLmNoYXIgYyA6OiBzKSlcbiAgYW5kIGNoYXIgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgaWYgYyA9ICdbJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgYWNjZXB0ICc9JyB0aGVuIHJhaXNlIE5vdF9zdXBwb3J0ZWQ7XG4gICAgICBtYXRjaCBQb3NpeF9jbGFzcy5wYXJzZSBidWYgd2l0aFxuICAgICAgfCBTb21lIHNldCAtPiBgU2V0IHNldFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGlmIGFjY2VwdCAnLidcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgbGV0IGMgPSBnZXQgKCkgaW5cbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnLicpIHRoZW4gcmFpc2UgTm90X3N1cHBvcnRlZDtcbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnXScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgYENoYXIgYylcbiAgICAgICAgZWxzZSBgQ2hhciBjKVxuICAgIGVsc2UgaWYgYyA9ICdcXFxcJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBsZXQgYyA9IGdldCAoKSBpblxuICAgICAgKCogWFhYXG4gICAgICAgICBcXDEyNywgLi4uXG4gICAgICAqKVxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICdiJyAtPiBgQ2hhciAnXFwwMDgnXG4gICAgICB8ICduJyAtPiBgQ2hhciAnXFxuJyAoKlhYWCopXG4gICAgICB8ICdyJyAtPiBgQ2hhciAnXFxyJyAoKlhYWCopXG4gICAgICB8ICd0JyAtPiBgQ2hhciAnXFx0JyAoKlhYWCopXG4gICAgICB8ICd3JyAtPiBgU2V0IChSZS5hbHQgWyBSZS5hbG51bTsgUmUuY2hhciAnXycgXSlcbiAgICAgIHwgJ1cnIC0+IGBTZXQgKFJlLmNvbXBsIFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF0pXG4gICAgICB8ICdzJyAtPiBgU2V0IFJlLnNwYWNlXG4gICAgICB8ICdTJyAtPiBgU2V0IChSZS5jb21wbCBbIFJlLnNwYWNlIF0pXG4gICAgICB8ICdkJyAtPiBgU2V0IFJlLmRpZ2l0XG4gICAgICB8ICdEJyAtPiBgU2V0IChSZS5jb21wbCBbIFJlLmRpZ2l0IF0pXG4gICAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICB8ICcwJyAuLiAnOScgLT4gcmFpc2UgTm90X3N1cHBvcnRlZFxuICAgICAgfCBfIC0+IGBDaGFyIGMpXG4gICAgZWxzZSBgQ2hhciBjXG4gIGFuZCBjb21tZW50ICgpID1cbiAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICBpZiBhY2NlcHQgJyknXG4gICAgdGhlbiBSZS5lcHNpbG9uXG4gICAgZWxzZSAoXG4gICAgICBQYXJzZV9idWZmZXIuanVuayBidWY7XG4gICAgICBjb21tZW50ICgpKVxuICBpblxuICBsZXQgcmVzID0gcmVnZXhwICgpIGluXG4gIGlmIG5vdCAoZW9zICgpKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICByZXNcbjs7XG5cbnR5cGUgb3B0ID1cbiAgWyBgVW5ncmVlZHlcbiAgfCBgRG90YWxsXG4gIHwgYERvbGxhcl9lbmRvbmx5XG4gIHwgYE11bHRpbGluZVxuICB8IGBBbmNob3JlZFxuICB8IGBDYXNlbGVzc1xuICBdXG5cbmxldCByZSA/KG9wdHMgPSBbXSkgcyA9XG4gIGxldCByID1cbiAgICBwYXJzZVxuICAgICAgKExpc3QubWVtcSBgTXVsdGlsaW5lIG9wdHMpXG4gICAgICAoTGlzdC5tZW1xIGBEb2xsYXJfZW5kb25seSBvcHRzKVxuICAgICAgKExpc3QubWVtcSBgRG90YWxsIG9wdHMpXG4gICAgICAoTGlzdC5tZW1xIGBVbmdyZWVkeSBvcHRzKVxuICAgICAgc1xuICBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgQW5jaG9yZWQgb3B0cyB0aGVuIFJlLnNlcSBbIFJlLnN0YXJ0OyByIF0gZWxzZSByIGluXG4gIGxldCByID0gaWYgTGlzdC5tZW1xIGBDYXNlbGVzcyBvcHRzIHRoZW4gUmUubm9fY2FzZSByIGVsc2UgciBpblxuICByXG47O1xuXG5sZXQgY29tcGlsZSA9IFJlLmNvbXBpbGVcbmxldCBjb21waWxlX3BhdCA/KG9wdHMgPSBbXSkgcyA9IGNvbXBpbGUgKHJlIH5vcHRzIHMpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjQ0OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImdsb2JhbF9kYXRhIiwiUmVfQ29yZSIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0J5dGVzIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWIiLCJTdGRsaWJfQXJyYXkiLCJSZV9QZXJsIiwiUGFyc2VfZXJyb3IiLCJOb3Rfc3VwcG9ydGVkIiwicmUiLCJvcHQiLCJwYXQiLCJmbGFncyIsIm9wdHMiLCJwYXJhbSIsInJlZ2V4cCIsImV4dHJhY3QiLCJyZXgiLCJzIiwiZXhlYyIsInBvcyIsImdldF9zdWJzdHJpbmciLCJpIiwibmFtZXMiLCJnZXRfbmFtZWRfc3Vic3RyaW5nIiwibmFtZSIsIm1hdGNoIiwicmVtIiwibiIsImdldF9zdWJzdHJpbmdfb2ZzIiwicG1hdGNoIiwic3Vic3RpdHV0ZSIsInN1YnN0Iiwic3RyIiwiYiIsIm9uX21hdGNoIiwic3MiLCJmaW4iLCJzdGFydCIsInNwbGl0IiwiZmluaXNoIiwibGFzdCIsImFjY3UiLCJxdW90ZSIsImxlbiIsImJ1ZiIsImMiLCJyIiwiZnVsbF9zcGxpdCIsIm1heCIsInJlc3VsdHMiLCJtYXRjaGVzIiwiZCIsImRlbGltIiwibCIsIlJlX1BjcmUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvcmUvcGNyZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3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QUFBQSxXQUFBa0MsSUFEZjtBQUFBLFdBQUFELFVBR2tCO0FBQUEsV0FBQUUsUUFDRjtBQUFBLFdBQUFDLElBQ1o7QUFBQSxpQkFHQztBQUFBO0FBQUE7QUFBQSxlQUFBaEMsSUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFFUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEseUJBQW1EO0FBQUEsWUFBN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFHL0IseURBQVc7QUFBQSxTQUFFO0FBQUE7QUFBQSxJQUd0QiwyQ0FBb0I7QUFBQTtBQUFBO0FBQUEsSUFBQWlDO0FBQUFBLE1Edkt4QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIFJlID0gQ29yZVxuXG5leGNlcHRpb24gUGFyc2VfZXJyb3IgPSBQZXJsLlBhcnNlX2Vycm9yXG5leGNlcHRpb24gTm90X3N1cHBvcnRlZCA9IFBlcmwuTm90X3N1cHBvcnRlZFxuXG50eXBlIHJlZ2V4cCA9IFJlLnJlXG5cbnR5cGUgZmxhZyA9XG4gIFsgYENBU0VMRVNTXG4gIHwgYE1VTFRJTElORVxuICB8IGBBTkNIT1JFRFxuICB8IGBET1RBTExcbiAgXVxuXG50eXBlIHNwbGl0X3Jlc3VsdCA9XG4gIHwgVGV4dCBvZiBzdHJpbmdcbiAgfCBEZWxpbSBvZiBzdHJpbmdcbiAgfCBHcm91cCBvZiBpbnQgKiBzdHJpbmdcbiAgfCBOb0dyb3VwXG5cbnR5cGUgZ3JvdXBzID0gQ29yZS5Hcm91cC50XG5cbmxldCByZSA/KGZsYWdzID0gW10pIHBhdCA9XG4gIGxldCBvcHRzID1cbiAgICBMaXN0Lm1hcFxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgYENBU0VMRVNTIC0+IGBDYXNlbGVzc1xuICAgICAgICB8IGBNVUxUSUxJTkUgLT4gYE11bHRpbGluZVxuICAgICAgICB8IGBBTkNIT1JFRCAtPiBgQW5jaG9yZWRcbiAgICAgICAgfCBgRE9UQUxMIC0+IGBEb3RhbGwpXG4gICAgICBmbGFnc1xuICBpblxuICBQZXJsLnJlIH5vcHRzIHBhdFxuOztcblxubGV0IHJlZ2V4cCA/ZmxhZ3MgcGF0ID0gUmUuY29tcGlsZSAocmUgP2ZsYWdzIHBhdClcbmxldCBleHRyYWN0IH5yZXggcyA9IFJlLkdyb3VwLmFsbCAoUmUuZXhlYyByZXggcylcbmxldCBleGVjIH5yZXggP3BvcyBzID0gUmUuZXhlYyByZXggP3BvcyBzXG5sZXQgZ2V0X3N1YnN0cmluZyBzIGkgPSBSZS5Hcm91cC5nZXQgcyBpXG5sZXQgbmFtZXMgcmV4ID0gUmUuZ3JvdXBfbmFtZXMgcmV4IHw+IExpc3QubWFwIGZzdCB8PiBBcnJheS5vZl9saXN0XG5cbmxldCBnZXRfbmFtZWRfc3Vic3RyaW5nIHJleCBuYW1lIHMgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCAobiwgaSkgOjogcmVtIHdoZW4gbiA9IG5hbWUgLT5cbiAgICAgICh0cnkgZ2V0X3N1YnN0cmluZyBzIGkgd2l0aFxuICAgICAgIHwgTm90X2ZvdW5kIC0+IGxvb3AgcmVtKVxuICAgIHwgXyA6OiByZW0gLT4gbG9vcCByZW1cbiAgaW5cbiAgbG9vcCAoUmUuZ3JvdXBfbmFtZXMgcmV4KVxuOztcblxubGV0IGdldF9zdWJzdHJpbmdfb2ZzIHMgaSA9IFJlLkdyb3VwLm9mZnNldCBzIGlcbmxldCBwbWF0Y2ggfnJleCBzID0gUmUuZXhlY3AgcmV4IHNcblxubGV0IHN1YnN0aXR1dGUgfnJleCB+c3Vic3Qgc3RyID1cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgbGV0IHJlYyBsb29wIHBvcyBvbl9tYXRjaCA9XG4gICAgaWYgUmUuZXhlY3AgfnBvcyByZXggc3RyXG4gICAgdGhlbiAoXG4gICAgICBsZXQgc3MgPSBSZS5leGVjIH5wb3MgcmV4IHN0ciBpblxuICAgICAgbGV0IHN0YXJ0LCBmaW4gPSBSZS5Hcm91cC5vZmZzZXQgc3MgMCBpblxuICAgICAgaWYgb25fbWF0Y2ggJiYgc3RhcnQgPSBwb3MgJiYgc3RhcnQgPSBmaW5cbiAgICAgIHRoZW4gKFxuICAgICAgICBpZiAoKiBFbXB0eSBtYXRjaCBmb2xsb3dpbmcgYSBtYXRjaCAqKVxuICAgICAgICAgICBwb3MgPCBTdHJpbmcubGVuZ3RoIHN0clxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBzdHIuW3Bvc107XG4gICAgICAgICAgbG9vcCAocG9zICsgMSkgZmFsc2UpKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBwYXQgPSBSZS5Hcm91cC5nZXQgc3MgMCBpblxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBiIHN0ciBwb3MgKHN0YXJ0IC0gcG9zKTtcbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYiAoc3Vic3QgcGF0KTtcbiAgICAgICAgaWYgc3RhcnQgPSBmaW5cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgaWYgKCogTWFudWFsbHkgYWR2YW5jZSBieSBvbmUgYWZ0ZXIgYW4gZW1wdHkgbWF0Y2ggKilcbiAgICAgICAgICAgICBmaW4gPCBTdHJpbmcubGVuZ3RoIHN0clxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgc3RyLltmaW5dO1xuICAgICAgICAgICAgbG9vcCAoZmluICsgMSkgZmFsc2UpKVxuICAgICAgICBlbHNlIGxvb3AgZmluIHRydWUpKVxuICAgIGVsc2UgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYiBzdHIgcG9zIChTdHJpbmcubGVuZ3RoIHN0ciAtIHBvcylcbiAgaW5cbiAgbG9vcCAwIGZhbHNlO1xuICBCdWZmZXIuY29udGVudHMgYlxuOztcblxubGV0IHNwbGl0IH5yZXggc3RyID1cbiAgbGV0IGZpbmlzaCBzdHIgbGFzdCBhY2N1ID1cbiAgICBsZXQgYWNjdSA9IFN0cmluZy5zdWIgc3RyIGxhc3QgKFN0cmluZy5sZW5ndGggc3RyIC0gbGFzdCkgOjogYWNjdSBpblxuICAgIExpc3QucmV2IGFjY3VcbiAgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbGFzdCBwb3Mgb25fbWF0Y2ggPVxuICAgIGlmIFJlLmV4ZWNwIH5wb3MgcmV4IHN0clxuICAgIHRoZW4gKFxuICAgICAgbGV0IHNzID0gUmUuZXhlYyB+cG9zIHJleCBzdHIgaW5cbiAgICAgIGxldCBzdGFydCwgZmluID0gUmUuR3JvdXAub2Zmc2V0IHNzIDAgaW5cbiAgICAgIGlmIG9uX21hdGNoICYmIHN0YXJ0ID0gcG9zICYmIHN0YXJ0ID0gZmluXG4gICAgICB0aGVuXG4gICAgICAgIGlmICgqIEVtcHR5IG1hdGNoIGZvbGxvd2luZyBhIG1hdGNoICopXG4gICAgICAgICAgIHBvcyA9IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICAgIHRoZW4gZmluaXNoIHN0ciBsYXN0IGFjY3VcbiAgICAgICAgZWxzZSBsb29wIGFjY3UgbGFzdCAocG9zICsgMSkgZmFsc2VcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYWNjdSA9IFN0cmluZy5zdWIgc3RyIGxhc3QgKHN0YXJ0IC0gbGFzdCkgOjogYWNjdSBpblxuICAgICAgICBpZiBzdGFydCA9IGZpblxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgKCogTWFudWFsbHkgYWR2YW5jZSBieSBvbmUgYWZ0ZXIgYW4gZW1wdHkgbWF0Y2ggKilcbiAgICAgICAgICAgICBmaW4gPSBTdHJpbmcubGVuZ3RoIHN0clxuICAgICAgICAgIHRoZW4gZmluaXNoIHN0ciBmaW4gYWNjdVxuICAgICAgICAgIGVsc2UgbG9vcCBhY2N1IGZpbiAoZmluICsgMSkgZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIGFjY3UgZmluIGZpbiB0cnVlKSlcbiAgICBlbHNlIGZpbmlzaCBzdHIgbGFzdCBhY2N1XG4gIGluXG4gIGxvb3AgW10gMCAwIGZhbHNlXG47O1xuXG4oKiBGcm9tIFBDUkUgKilcbmxldCBzdHJpbmdfdW5zYWZlX3N1YiBzIG9mcyBsZW4gPVxuICBsZXQgciA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgQnl0ZXMudW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByXG47O1xuXG5sZXQgcXVvdGUgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAobGVuIGxzbCAxKSBpblxuICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgIHwgKCdcXFxcJyB8ICdeJyB8ICckJyB8ICcuJyB8ICdbJyB8ICd8JyB8ICcoJyB8ICcpJyB8ICc/JyB8ICcqJyB8ICcrJyB8ICd7JykgYXMgYyAtPlxuICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgIXBvcyAnXFxcXCc7XG4gICAgICBpbmNyIHBvcztcbiAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgYnVmICFwb3MgYztcbiAgICAgIGluY3IgcG9zXG4gICAgfCBjIC0+XG4gICAgICBCeXRlcy51bnNhZmVfc2V0IGJ1ZiAhcG9zIGM7XG4gICAgICBpbmNyIHBvc1xuICBkb25lO1xuICBzdHJpbmdfdW5zYWZlX3N1YiBidWYgMCAhcG9zXG47O1xuXG5sZXQgZnVsbF9zcGxpdCA/KG1heCA9IDApIH5yZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA9IDBcbiAgdGhlbiBbXVxuICBlbHNlIGlmIG1heCA9IDFcbiAgdGhlbiBbIFRleHQgcyBdXG4gIGVsc2UgKFxuICAgIGxldCByZXN1bHRzID0gUmUuc3BsaXRfZnVsbCByZXggcyBpblxuICAgIGxldCBtYXRjaGVzID1cbiAgICAgIExpc3QubWFwXG4gICAgICAgIChmdW5jdGlvblxuICAgICAgICAgIHwgYFRleHQgcyAtPiBbIFRleHQgcyBdXG4gICAgICAgICAgfCBgRGVsaW0gZCAtPlxuICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBSZS5Hcm91cC5hbGxfb2Zmc2V0IGQgaW5cbiAgICAgICAgICAgIGxldCBkZWxpbSA9IFJlLkdyb3VwLmdldCBkIDAgaW5cbiAgICAgICAgICAgIERlbGltIGRlbGltXG4gICAgICAgICAgICA6OlxuICAgICAgICAgICAgKGxldCBsID0gcmVmIFtdIGluXG4gICAgICAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBtYXRjaGVzIC0gMSBkb1xuICAgICAgICAgICAgICAgbFxuICAgICAgICAgICAgICAgOj0gKGlmIG1hdGNoZXMuKGkpID0gKC0xLCAtMSkgdGhlbiBOb0dyb3VwIGVsc2UgR3JvdXAgKGksIFJlLkdyb3VwLmdldCBkIGkpKVxuICAgICAgICAgICAgICAgICAgOjogIWxcbiAgICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgIExpc3QucmV2ICFsKSlcbiAgICAgICAgcmVzdWx0c1xuICAgIGluXG4gICAgTGlzdC5jb25jYXQgbWF0Y2hlcylcbjs7XG5cbnR5cGUgc3Vic3RyaW5ncyA9IEdyb3VwLnRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo2NzM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJSZV9Db3JlIiwiU3RkbGliX0xpc3QiLCJSZV9QYXJzZV9idWZmZXIiLCJSZV9Qb3NpeF9jbGFzcyIsIlBhcnNlX2Vycm9yIiwiTm90X3N1cHBvcnRlZCIsInJlIiwib3B0IiwicyIsIm9wdHMiLCJuZXdsaW5lIiwiYnVmIiwiYWNjZXB0IiwiZW9zIiwicGFyYW0iLCJ0ZXN0IiwiYyIsImdldCIsInJlZ2V4cCIsImxlZnQiLCJicmFuY2giLCJyIiwibWF0Y2giLCJpIiwiaiIsImJyYWNrZXQiLCJzdCIsImNoYXIiLCJzZXQiLCJyZXMiLCJjb21waWxlIiwiY29tcGlsZV9wYXQiLCJSZV9Qb3NpeCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9yZS9wb3NpeC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsR0FBQUMsS0FBQUM7QUFBQUE7QUFBQUEsS0FBQUMsT0NrSk87QUFBQSxLQUFBQyxVQUNTO0FBQUEsS0FBQUMsTUEvR0o7QUFBQSxLQUFBQyxTQUNHO0FBQUEsYUFBQUMsSUFBQUMsT0FDQSwwQ0FBb0I7QUFBQSxhQUFBQyxLQUFBQyxHQUNwQiw2Q0FBdUI7QUFBQSxhQUFBQyxJQUFBSCxPQUV2QiwwQ0FBb0I7QUFBQSxhQUFBSSxPQUFBSjtBQUFBQSxTQUFBSyxPQUNMLFdBQUFBLFNBQVc7QUFBQTtBQUFBLE1BQ2pCLDhCQUEwRDtBQUFBO0FBQUEsYUFBbEI7QUFBQSxPQUFBQSxTQUFoQjtBQUFBLE1BQTRCO0FBQUE7QUFBQSxJQURuQztBQUFBLGFBQUFDLE9BQUFOO0FBQUFBLFNBQUFLLE9BRXZCO0FBQUE7QUFBQSxNQUVYLGlCQUFVLGVBQVk7QUFBQTtBQUFBLFVBMEJ0QjtBQUFBLFlBQUFFLElBQ0U7QUFBQSxlQUNHO0FBQUEsWUFBQUEsTUFFRTtBQUFBLFFBQ0Q7QUFBQSxTQUFrQjtBQUFBLFlBQUFBLElBQ3pCO0FBQUE7QUFBQSxlQUNNO0FBQUEsWUFBQUEsSUFDSDtBQUFBLGVBQ0c7QUFBQSxZQUFBQSxJQUNIO0FBQUE7QUFBQSxRQUNHO0FBQUEsU0FLQTtBQUFBLFVBUUgsV0FBWTtBQUFBLGNBQUFMLE1BQ1Q7QUFBQTtBQUFBO0FBQUEsV0FBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFBQUssSUFFTDtBQUFBO0FBQUE7QUFBQSxVQUQyQjtBQUFBO0FBQUEsU0FSL0IsV0FBWTtBQUFBLGFBQUFMLElBQ1Q7QUFBQTtBQUFBO0FBQUEsVUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFLLElBRVY7QUFBQTtBQUFBO0FBQUEsU0FDSztBQUFBO0FBQUEsUUFUSjtBQUFBO0FBQUEsZ0JBQ2tDO0FBQUEsZ0JBQWQ7QUFBQSxnQkFBVjtBQUFBLFVBQUFBLElBQXVCO0FBQUE7QUFBQSxtQkFDeEIsWUFBQUEsSUFBWTtBQUFBO0FBQUEsT0FwQ3ZCO0FBQUE7QUFBQSxlQUNTO0FBQUEsZUFBVztBQUFBLGVBQ2Y7QUFBQTtBQUFBLGVBQ0s7QUFBQSxlQUFXO0FBQUEsZUFDaEI7QUFBQSxrQkFDSDtBQUFBLGVBQ0c7QUFBQSxZQUFBQyxRQUVBO0FBQUEsUUFBd0I7QUFBQTtBQUFBLFVBQUFDLElBQUE7QUFBQSxVQUFBQztBQUFBQSxZQUVqQjtBQUFBLGVBQWdCO0FBQUE7QUFBQSxTQUNwQjtBQUFBLFVBQWtCO0FBQUEsU0FDekI7QUFBQSxjQUFBQSxNQUFBO0FBQUEsVUFDZSxZQUFTO0FBQUE7QUFBQTtBQUFBLGdCQUVoQjtBQUFBLGdCQUFXO0FBQUE7QUFBQSxhQTFCViwrQ0E0QkQ7QUFBQTtBQUFBO0FBQUEsa0JBRVA7QUFBQSxXQUFBTCxTQXRCaUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFEVjtBQUFBLE1BQWUsbUNBSEg7QUFBQTtBQUFBO0FBQUEsYUFBQU0sUUFBQWpCO0FBQUFBLFNBQUFBLE1BeUR4QjtBQUFBO0FBQUEsc0JBQWMsd0JBQ1Q7QUFBQSxVQUFBYyxRQUVHO0FBQUEsTUFBTztBQUFBLFdBQUFOLElBQUE7QUFBQSxPQUdSO0FBQUEsUUFFRTtBQUFBLG1CQUNlO0FBQUEsU0FBYiwyQ0FBUztBQUFBO0FBQUEsWUFBQU0sVUFHSDtBQUFBLFFBQU87QUFBQTtBQUFBLFVBQUFOLE1BQUE7QUFBQSxVQUFBUixNQUNXLElBQVY7QUFBQTtBQUFBO0FBQUEsVUFBQWtCLEtBREQ7QUFBQSxnQkFFYztBQUFBLFVBQUFsQixNQUFKLElBQVQ7QUFBQSxRQUZEO0FBQUE7QUFBQSxnQkFBQUEsTUFHTixzQ0FBUztBQUFBO0FBQUEsZUFBQWtCLE9BWlosVUFBQWxCLE1BQ0E7QUFBQTtBQUFBLElBV21CO0FBQUEsYUFBQW1CLE9BQUFiO0FBQUFBLEtBRS9CLFdBQVk7QUFBQSxTQUFBRSxJQUNQO0FBQUEsS0FDUixhQWFLO0FBQUEsU0FBQU0sUUFYRztBQUFBLEtBQXFCLGNBQUFNLE1BQUEsVUFDYjtBQUFBLEtBRVQsNkJBT0U7QUFBQSxLQUxBLFdBQVk7QUFBQSxTQUFBWixNQUNQO0FBQUEsS0FDRDtBQUFBLE1BQWtCO0FBQUEsS0FDbEI7QUFBQSxNQUFrQjtBQUFBLEtBQ3pCO0FBQUEsSUFFTTtBQUFBLFFBQUFhLE1BRUo7QUFBQSxJQUNILGVBQWM7QUFBQTtBQUFBLEtBQUFSO0FBQUFBLE9BWVY7QUFBQSxVQUEyQjtBQUFBO0FBQUEsS0FBQUE7QUFBQUEsT0FDM0I7QUFBQSxVQUEyQjtBQUFBO0FBQUEsSUFDdEM7QUFBQSxHQUFDO0FBQUEsWUFBQVMsUUFBQXhCO0FBQUFBLFFBQUEsTUFHeUI7QUFBQSxJQUFlO0FBQUE7QUFBQSxZQUFBeUIsWUFBQXhCLEtBQUFDO0FBQUFBLFFBQUFDLE9BQzNCO0FBQUEsSUFBeUIsT0FBWSxRQUFaLGlCQUFZO0FBQUE7QUFBQSxPQUFBdUIsV0QxSnJEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG4oKlxuICAgV2hhdCB3ZSBjb3VsZCAoc2hvdWxkPykgZG86XG4gICAtIGEqID09PiBsb25nZXN0ICgoc2hvcnRlc3QgKG5vX2dyb3VwIGEpKiApLCBhIHwgKCkpICAoISEhKVxuICAgLSBhYmMgdW5kZXJzdG9vZCBhcyAoYWIpY1xuICAgLSBcIigoYT8pfGIpXCIgYWdhaW5zdCBcImFiXCIgc2hvdWxkIG5vdCBiaW5kIHRoZSBmaXJzdCBzdWJwYXR0ZXJuIHRvIGFueXRoaW5nXG5cbiAgIE5vdGUgdGhhdCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gaGFuZGxlIFwiKCgoYWIpYylkKWVcIiBlZmZpY2llbnRseVxuKilcbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yID0gUGFyc2VfYnVmZmVyLlBhcnNlX2Vycm9yXG5leGNlcHRpb24gTm90X3N1cHBvcnRlZFxuXG5sZXQgcGFyc2UgbmV3bGluZSBzID1cbiAgbGV0IGJ1ZiA9IFBhcnNlX2J1ZmZlci5jcmVhdGUgcyBpblxuICBsZXQgYWNjZXB0ID0gUGFyc2VfYnVmZmVyLmFjY2VwdCBidWYgaW5cbiAgbGV0IGVvcyAoKSA9IFBhcnNlX2J1ZmZlci5lb3MgYnVmIGluXG4gIGxldCB0ZXN0IGMgPSBQYXJzZV9idWZmZXIudGVzdCBidWYgYyBpblxuICBsZXQgdW5nZXQgKCkgPSBQYXJzZV9idWZmZXIudW5nZXQgYnVmIGluXG4gIGxldCBnZXQgKCkgPSBQYXJzZV9idWZmZXIuZ2V0IGJ1ZiBpblxuICBsZXQgcmVjIHJlZ2V4cCAoKSA9IHJlZ2V4cCcgKGJyYW5jaCAoKSlcbiAgYW5kIHJlZ2V4cCcgbGVmdCA9IGlmIGFjY2VwdCAnfCcgdGhlbiByZWdleHAnIChSZS5hbHQgWyBsZWZ0OyBicmFuY2ggKCkgXSkgZWxzZSBsZWZ0XG4gIGFuZCBicmFuY2ggKCkgPSBicmFuY2gnIFtdXG4gIGFuZCBicmFuY2gnIGxlZnQgPVxuICAgIGlmIGVvcyAoKSB8fCB0ZXN0ICd8JyB8fCB0ZXN0ICcpJ1xuICAgIHRoZW4gUmUuc2VxIChMaXN0LnJldiBsZWZ0KVxuICAgIGVsc2UgYnJhbmNoJyAocGllY2UgKCkgOjogbGVmdClcbiAgYW5kIHBpZWNlICgpID1cbiAgICBsZXQgciA9IGF0b20gKCkgaW5cbiAgICBpZiBhY2NlcHQgJyonXG4gICAgdGhlbiBSZS5yZXAgKFJlLm5lc3QgcilcbiAgICBlbHNlIGlmIGFjY2VwdCAnKydcbiAgICB0aGVuIFJlLnJlcDEgKFJlLm5lc3QgcilcbiAgICBlbHNlIGlmIGFjY2VwdCAnPydcbiAgICB0aGVuIFJlLm9wdCByXG4gICAgZWxzZSBpZiBhY2NlcHQgJ3snXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBQYXJzZV9idWZmZXIuaW50ZWdlciBidWYgd2l0aFxuICAgICAgfCBTb21lIGkgLT5cbiAgICAgICAgbGV0IGogPSBpZiBhY2NlcHQgJywnIHRoZW4gUGFyc2VfYnVmZmVyLmludGVnZXIgYnVmIGVsc2UgU29tZSBpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0ICd9JykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgKG1hdGNoIGogd2l0aFxuICAgICAgICAgfCBTb21lIGogd2hlbiBqIDwgaSAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgICAgfCBfIC0+ICgpKTtcbiAgICAgICAgUmUucmVwbiAoUmUubmVzdCByKSBpIGpcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICB1bmdldCAoKTtcbiAgICAgICAgcilcbiAgICBlbHNlIHJcbiAgYW5kIGF0b20gKCkgPVxuICAgIGlmIGFjY2VwdCAnLidcbiAgICB0aGVuIGlmIG5ld2xpbmUgdGhlbiBSZS5ub3RubCBlbHNlIFJlLmFueVxuICAgIGVsc2UgaWYgYWNjZXB0ICcoJ1xuICAgIHRoZW4gKFxuICAgICAgbGV0IHIgPSByZWdleHAgKCkgaW5cbiAgICAgIGlmIG5vdCAoYWNjZXB0ICcpJykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIFJlLmdyb3VwIHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJ14nXG4gICAgdGhlbiBpZiBuZXdsaW5lIHRoZW4gUmUuYm9sIGVsc2UgUmUuYm9zXG4gICAgZWxzZSBpZiBhY2NlcHQgJyQnXG4gICAgdGhlbiBpZiBuZXdsaW5lIHRoZW4gUmUuZW9sIGVsc2UgUmUuZW9zXG4gICAgZWxzZSBpZiBhY2NlcHQgJ1snXG4gICAgdGhlblxuICAgICAgaWYgYWNjZXB0ICdeJ1xuICAgICAgdGhlbiBSZS5kaWZmIChSZS5jb21wbCAoYnJhY2tldCBbXSkpIChSZS5jaGFyICdcXG4nKVxuICAgICAgZWxzZSBSZS5hbHQgKGJyYWNrZXQgW10pXG4gICAgZWxzZSBpZiBhY2NlcHQgJ1xcXFwnXG4gICAgdGhlbiAoXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICB8ICgnfCcgfCAnKCcgfCAnKScgfCAnKicgfCAnKycgfCAnPycgfCAnWycgfCAnLicgfCAnXicgfCAnJCcgfCAneycgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgUmUuY2hhciBjXG4gICAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3IpXG4gICAgZWxzZSAoXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICB8ICcqJyB8ICcrJyB8ICc/JyB8ICd7JyB8ICdcXFxcJyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCBjIC0+IFJlLmNoYXIgYylcbiAgYW5kIGJyYWNrZXQgcyA9XG4gICAgaWYgcyA8PiBbXSAmJiBhY2NlcHQgJ10nXG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBjaGFyICgpIHdpdGhcbiAgICAgIHwgYFNldCBzdCAtPiBicmFja2V0IChzdCA6OiBzKVxuICAgICAgfCBgQ2hhciBjIC0+XG4gICAgICAgIGlmIGFjY2VwdCAnLSdcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmIGFjY2VwdCAnXSdcbiAgICAgICAgICB0aGVuIFJlLmNoYXIgYyA6OiBSZS5jaGFyICctJyA6OiBzXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJhY2tldFxuICAgICAgICAgICAgICAobWF0Y2ggY2hhciAoKSB3aXRoXG4gICAgICAgICAgICAgICB8IGBDaGFyIGMnIC0+IFJlLnJnIGMgYycgOjogc1xuICAgICAgICAgICAgICAgfCBgU2V0IHN0JyAtPiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc3QnIDo6IHMpXG4gICAgICAgIGVsc2UgYnJhY2tldCAoUmUuY2hhciBjIDo6IHMpKVxuICBhbmQgY2hhciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgbGV0IGMgPSBnZXQgKCkgaW5cbiAgICBpZiBjID0gJ1snXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBQb3NpeF9jbGFzcy5wYXJzZSBidWYgd2l0aFxuICAgICAgfCBTb21lIHNldCAtPiBgU2V0IHNldFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGlmIGFjY2VwdCAnLidcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgbGV0IGMgPSBnZXQgKCkgaW5cbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnLicpIHRoZW4gcmFpc2UgTm90X3N1cHBvcnRlZDtcbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnXScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgYENoYXIgYylcbiAgICAgICAgZWxzZSBgQ2hhciBjKVxuICAgIGVsc2UgYENoYXIgY1xuICBpblxuICBsZXQgcmVzID0gcmVnZXhwICgpIGluXG4gIGlmIG5vdCAoZW9zICgpKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICByZXNcbjs7XG5cbnR5cGUgb3B0ID1cbiAgWyBgSUNhc2VcbiAgfCBgTm9TdWJcbiAgfCBgTmV3bGluZVxuICBdXG5cbmxldCByZSA/KG9wdHMgPSBbXSkgcyA9XG4gIGxldCByID0gcGFyc2UgKExpc3QubWVtcSBgTmV3bGluZSBvcHRzKSBzIGluXG4gIGxldCByID0gaWYgTGlzdC5tZW1xIGBJQ2FzZSBvcHRzIHRoZW4gUmUubm9fY2FzZSByIGVsc2UgciBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgTm9TdWIgb3B0cyB0aGVuIFJlLm5vX2dyb3VwIHIgZWxzZSByIGluXG4gIHJcbjs7XG5cbmxldCBjb21waWxlIHJlID0gUmUuY29tcGlsZSAoUmUubG9uZ2VzdCByZSlcbmxldCBjb21waWxlX3BhdCA/KG9wdHMgPSBbXSkgcyA9IGNvbXBpbGUgKHJlIH5vcHRzIHMpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Njk2OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJSZV9Db3JlIiwiUmVfUmVwbGFjZSIsIkdyb3VwIiwiY29tcGlsZSIsImdyb3VwX2NvdW50IiwiZ3JvdXBfbmFtZXMiLCJleGVjIiwiZXhlY19vcHQiLCJleGVjcCIsImV4ZWNfcGFydGlhbCIsImV4ZWNfcGFydGlhbF9kZXRhaWxlZCIsIk1hcmsiLCJhbGwiLCJhbGxfZ2VuIiwiYWxsX3NlcSIsIm1hdGNoZXMiLCJtYXRjaGVzX2dlbiIsIm1hdGNoZXNfc2VxIiwic3BsaXQiLCJzcGxpdF9kZWxpbSIsInNwbGl0X2dlbiIsInNwbGl0X3NlcSIsInNwbGl0X2Z1bGwiLCJzcGxpdF9mdWxsX2dlbiIsInNwbGl0X2Z1bGxfc2VxIiwiU2VxIiwic3RyIiwiY2hhciIsImFsdCIsInNlcSIsImVtcHR5IiwiZXBzaWxvbiIsInJlcCIsInJlcDEiLCJyZXBuIiwib3B0IiwiYm9sIiwiZW9sIiwiYm93IiwiZW93IiwiYm9zIiwiZW9zIiwibGVvbCIsInN0YXJ0Iiwic3RvcCIsIndvcmQiLCJub3RfYm91bmRhcnkiLCJ3aG9sZV9zdHJpbmciLCJsb25nZXN0Iiwic2hvcnRlc3QiLCJmaXJzdCIsImdyZWVkeSIsIm5vbl9ncmVlZHkiLCJncm91cCIsIm5vX2dyb3VwIiwibmVzdCIsIm1hcmsiLCJzZXQiLCJyZyIsImludGVyIiwiZGlmZiIsImNvbXBsIiwiYW55Iiwibm90bmwiLCJhbG51bSIsIndvcmRjIiwiYWxwaGEiLCJhc2NpaSIsImJsYW5rIiwiY250cmwiLCJkaWdpdCIsImdyYXBoIiwibG93ZXIiLCJwcmludCIsInB1bmN0Iiwic3BhY2UiLCJ1cHBlciIsInhkaWdpdCIsImNhc2UiLCJub19jYXNlIiwicHAiLCJwcF9yZSIsInByaW50X3JlIiwid2l0bmVzcyIsImdldCIsImdldF9vZnMiLCJnZXRfYWxsIiwiZ2V0X2FsbF9vZnMiLCJ0ZXN0IiwibWFya2VkIiwibWFya19zZXQiLCJyZXBsYWNlIiwicmVwbGFjZV9zdHJpbmciLCJSZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
