// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Base_quickcheck__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck = [0];
   runtime.caml_register_global(0, Base_quickcheck, "Base_quickcheck__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__With_basic_types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck_With_basic_typ = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_With_basic_typ, "Base_quickcheck__With_basic_types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Bigarray_helpers
//# unitInfo: Requires: Base, Base__Array, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_get_2 = runtime.caml_ba_get_2,
    caml_ba_layout = runtime.caml_ba_layout;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Base_Array = global_data.Base__Array,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray;
   function offset(param){return param ? 1 : 0;}
   var Layout = [0, offset];
   function iteri(t, f){
    var
     _s_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _s_),
     _u_ = caml_ba_dim_1(t) - 1 | 0,
     _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      caml_call2(f, i + offset | 0, caml_ba_get_1(t, i + offset | 0));
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    return 0;
   }
   function init(kind, layout, dim, f){
    var t = caml_call3(Stdlib_Bigarray[20][1], kind, layout, dim);
    iteri
     (t,
      function(i, param){
       return runtime.caml_ba_set_1(t, i, caml_call1(f, i));
      });
    return t;
   }
   function fold(t, init, f){
    var init$0 = [0, init];
    iteri
     (t,
      function(i, param){
       var _r_ = caml_ba_get_1(t, i);
       init$0[1] = caml_call2(f, init$0[1], _r_);
       return 0;
      });
    return init$0[1];
   }
   function to_array(t){
    var
     _p_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _p_),
     _q_ = caml_ba_dim_1(t);
    return caml_call2
            (Base_Array[40],
             _q_,
             function(i){return caml_ba_get_1(t, i + offset | 0);});
   }
   function sexp_of_t(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_001 = to_array(t);
    return caml_call2(Base[92], sexp_of_elt, x_001);
   }
   function hash_fold(hash_fold_elt, state, t){
    var _o_ = caml_ba_dim_1(t), state$0 = caml_call2(Base[122], state, _o_);
    return fold(t, state$0, hash_fold_elt);
   }
   function iteri$0(t, f){
    var
     _h_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _h_),
     _j_ = caml_ba_dim_1(t) - 1 | 0,
     _i_ = 0;
    if(_j_ >= 0){
     var i = _i_;
     for(;;){
      var _l_ = caml_ba_dim_2(t) - 1 | 0, _k_ = 0;
      if(_l_ >= 0){
       var j = _k_;
       for(;;){
        caml_call3
         (f,
          i + offset | 0,
          j + offset | 0,
          caml_ba_get_2(t, i + offset | 0, j + offset | 0));
        var _n_ = j + 1 | 0;
        if(_l_ === j) break;
        j = _n_;
       }
      }
      var _m_ = i + 1 | 0;
      if(_j_ === i) break;
      i = _m_;
     }
    }
    return 0;
   }
   function init$0(kind, layout, dim1, dim2, f){
    var t = caml_call4(Stdlib_Bigarray[21][1], kind, layout, dim1, dim2);
    iteri$0
     (t,
      function(i, j, param){
       return runtime.caml_ba_set_2(t, i, j, caml_call2(f, i, j));
      });
    return t;
   }
   function fold$0(t, init, f){
    var init$0 = [0, init];
    iteri$0
     (t,
      function(_g_, param, elt){
       init$0[1] = caml_call2(f, init$0[1], elt);
       return 0;
      });
    return init$0[1];
   }
   function to_array$0(t){
    var
     _d_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _d_),
     _e_ = caml_ba_dim_1(t);
    return caml_call2
            (Base_Array[40],
             _e_,
             function(i){
              var _f_ = caml_ba_dim_2(t);
              return caml_call2
                      (Base_Array[40],
                       _f_,
                       function(j){
                        return caml_ba_get_2(t, i + offset | 0, j + offset | 0);
                       });
             });
   }
   function sexp_of_t$0(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_002 = to_array$0(t), _c_ = caml_call1(Base[92], sexp_of_elt);
    return caml_call2(Base[92], _c_, x_002);
   }
   function hash_fold$0(hash_fold_elt, state, t){
    var
     _a_ = caml_ba_dim_1(t),
     state$0 = caml_call2(Base[122], state, _a_),
     _b_ = caml_ba_dim_2(t),
     state$1 = caml_call2(Base[122], state$0, _b_);
    return fold$0(t, state$1, hash_fold_elt);
   }
   var
    Base_quickcheck_Bigarray_helpe =
      [0,
       Layout,
       [0, sexp_of_t, init, iteri, fold, to_array, hash_fold],
       [0, sexp_of_t$0, init$0, iteri$0, fold$0, to_array$0, hash_fold$0]];
   runtime.caml_register_global
    (3, Base_quickcheck_Bigarray_helpe, "Base_quickcheck__Bigarray_helpers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer0
//# unitInfo: Requires: Base, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Observer_o =
      "Base_quickcheck.Observer.observe: size < 0";
   function create(f){return f;}
   function observe(t, x, size, hash){
    if(0 <= size) return caml_call3(t, x, size, hash);
    var
     _c_ = [0, [1, [0, _a_, [0, caml_call1(Base[125], size), 0]]], 0],
     _d_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Observer_o),
         _c_]];
    return caml_call1(Base[217], _d_);
   }
   function opaque(_b_, param, hash){return hash;}
   var Base_quickcheck_Observer0 = [0, opaque, create, observe];
   runtime.caml_register_global
    (4, Base_quickcheck_Observer0, "Base_quickcheck__Observer0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Generator
//# unitInfo: Requires: Base, Base__Applicative, Base__Array, Base__Bytes, Base__Char, Base__Either, Base__Error, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Lazy, Base__List, Base__Map, Base__Monad, Base__Nativeint, Base__Option, Base__Sequence, Base__Set, Base__Staged, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Observer0, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lower_bound = "lower_bound",
    cst_src_generator_ml = "src/generator.ml",
    cst_upper_bound = "upper_bound",
    cst_weight = "weight",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_Array = global_data.Base__Array,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Set = global_data.Base__Set,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Float = global_data.Base__Float,
    Splittable_random = global_data.Splittable_random,
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int63 = global_data.Base__Int63,
    Stdlib = global_data.Stdlib,
    Base_Char = global_data.Base__Char,
    Base_Lazy = global_data.Base__Lazy,
    Base_Int = global_data.Base__Int,
    Base_Either = global_data.Base__Either,
    Base_Option = global_data.Base__Option,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Error = global_data.Base__Error,
    Base_Hash = global_data.Base__Hash,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Staged = global_data.Base__Staged,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Bytes = global_data.Base__Bytes,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Generator_ =
      "Base_quickcheck.Generator.generate: size < 0";
   function create(f){return caml_call1(Base_Staged[1], f);}
   function generate(t, size, random){
    if(0 <= size) return caml_call3(Base_Staged[2], t, size, random);
    var
     _cy_ = [0, [1, [0, _a_, [0, caml_call1(Base[125], size), 0]]], 0],
     _cz_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_),
         _cy_]];
    return caml_call1(Base[217], _cz_);
   }
   var size = create(function(size, param){return size;});
   function fn(dom, rng){
    return create
            (function(size, random){
              var random$0 = caml_call1(Splittable_random[1][5], random);
              return function(x){
               var
                _cw_ = caml_call1(Base_Hash[7], 0),
                hash =
                  caml_call4(Base_quickcheck_Observer0[3], dom, x, size, _cw_),
                random = caml_call1(Splittable_random[1][4], random$0),
                _cx_ = caml_call1(Base_Hash[9], hash);
               caml_call2(Splittable_random[1][3], random, _cx_);
               return generate(rng, size, random);};
             });
   }
   function with_size(t, size){
    return create(function(param, random){return generate(t, size, random);});
   }
   function perturb(t, salt){
    return create
            (function(size, random){
              caml_call2(Splittable_random[1][3], random, salt);
              return generate(t, size, random);
             });
   }
   function filter_map(t, f){
    function loop(size, random){
     var size$0 = size;
     for(;;){
      var x = generate(t, size$0, random), match = caml_call1(f, x);
      if(match){var y = match[1]; return y;}
      var size$1 = size$0 + 1 | 0;
      size$0 = size$1;
     }
    }
    return create(loop);
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function return$0(x){return create(function(_cv_, param){return x;});}
   function map(t, f){
    return create
            (function(size, random){
              return caml_call1(f, generate(t, size, random));
             });
   }
   function apply(tf, tx){
    return create
            (function(size, random){
              var
               f = generate(tf, size, random),
               x = generate(tx, size, random);
              return caml_call1(f, x);
             });
   }
   function bind(t, f){
    return create
            (function(size, random){
              var x = generate(t, size, random);
              return generate(caml_call1(f, x), size, random);
             });
   }
   function all(list){
    return create
            (function(size, random){
              return caml_call2
                      (Base_List[52],
                       list,
                       function(_cu_){return generate(_cu_, size, random);});
             });
   }
   function all_unit(list){
    return create
            (function(size, random){
              return caml_call2
                      (Base_List[19],
                       list,
                       function(_ct_){return generate(_ct_, size, random);});
             });
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[6], [0, return$0, apply, map$0]),
    both = For_applicative[3],
    map2 = For_applicative[9],
    map3 = For_applicative[10],
    include = For_applicative[13],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    map$1 = [0, -198771759, map],
    For_monad = caml_call1(Base_Monad[1], [0, bind, return$0, map$1]),
    ignore_m = For_monad[8],
    join = For_monad[7],
    include$0 = For_monad[3],
    symbol_bind = include$0[1],
    symbol_map = include$0[2],
    cst_Base_quickcheck_Generator_$0 =
      "Base_quickcheck.Generator.of_list: empty list",
    cst_Base_quickcheck_Generator_$1 =
      "Base_quickcheck.Generator.of_weighted_list: empty list",
    _b_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$2 =
      "Base_quickcheck.Generator.of_weighted_list: weight is not finite",
    _c_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$3 =
      "Base_quickcheck.Generator.of_weighted_list: weight is negative",
    cst_Base_quickcheck_Generator_$4 =
      "Base_quickcheck.Generator.of_weighted_list: total weight is zero",
    _d_ = [0, cst_src_generator_ml, 160, 14],
    cst_Base_quickcheck_Generator_$5 =
      "Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty",
    _e_ = [0, cst_src_generator_ml, 225, 6],
    _f_ = [0, cst_src_generator_ml, 198, 4];
   function of_list(list){
    if(caml_call1(Base_List[18], list)){
     var
      _cs_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$0);
     caml_call1(Base_Error[30], _cs_);
    }
    var
     array = caml_call1(Base_Array[8], list),
     hi = array.length - 2 | 0,
     lo = 0;
    return create
            (function(param, random){
              var index = caml_call3(Splittable_random[3], random, lo, hi);
              return caml_check_bound(array, index)[1 + index];
             });
   }
   function union(list){return caml_call1(join, of_list(list));}
   function of_weighted_list(alist){
    if(caml_call1(Base_List[18], alist)){
     var
      _cm_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$1);
     caml_call1(Base_Error[30], _cm_);
    }
    var
     match = caml_call1(Base_List[105], alist),
     values = match[2],
     weights = match[1],
     value_array = caml_call1(Base_Array[8], values),
     array =
       caml_call2
        (Base_Array[40], value_array.length - 1, function(param){return 0.;}),
     sum =
       caml_call3
        (Base_List[33],
         weights,
         0.,
         function(index, acc, weight){
          if(1 - caml_call1(Base_Float[86], weight)){
           var
            _co_ =
              [0, [1, [0, _b_, [0, caml_call1(Base[117], weight), 0]]], 0],
            _cp_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$2),
                _co_]];
           caml_call1(Base_Error[30], _cp_);
          }
          if(caml_call2(Base_Float[14], weight, 0.)){
           var
            _cq_ =
              [0, [1, [0, _c_, [0, caml_call1(Base[117], weight), 0]]], 0],
            _cr_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$3),
                _cq_]];
           caml_call1(Base_Error[30], _cr_);
          }
          var cumulative = caml_call2(Base[205], acc, weight);
          caml_check_bound(array, index)[1 + index] = cumulative;
          return cumulative;
         });
    if(caml_call2(Base_Float[11], sum, 0.)){
     var
      _cn_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$4);
     caml_call1(Base_Error[30], _cn_);
    }
    return create
            (function(param, random){
              var
               choice = caml_call3(Splittable_random[8], random, 0., sum),
               match =
                 caml_call6
                  (Base_Array[6],
                   0,
                   0,
                   array,
                   Base_Float[17],
                   926943384,
                   choice);
              if(! match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              var index = match[1];
              return caml_check_bound(value_array, index)[1 + index];
             });
   }
   function weighted_union(alist){
    return caml_call1(join, of_weighted_list(alist));
   }
   function of_lazy(lazy_t){
    return create
            (function(size, random){
              var _ck_ = caml_obj_tag(lazy_t);
              a:
              if(250 === _ck_)
               var _cl_ = lazy_t[1];
              else{
               if(246 !== _ck_ && 244 !== _ck_){var _cl_ = lazy_t; break a;}
               var _cl_ = caml_call1(CamlinternalLazy[2], lazy_t);
              }
              return generate(_cl_, size, random);
             });
   }
   function fixed_point(of_generator){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246,
       function(param){return caml_call1(of_generator, of_lazy(lazy_t));}]);
    var _cj_ = caml_obj_tag(lazy_t);
    if(250 === _cj_) return lazy_t[1];
    if(246 !== _cj_ && 244 !== _cj_) return lazy_t;
    return caml_call1(CamlinternalLazy[2], lazy_t);
   }
   function weighted_recursive_union(nonrec_list, f){
    return fixed_point
            (function(self){
              var
               _cf_ = caml_call1(f, self),
               rec_list =
                 caml_call2
                  (Base_List[52],
                   _cf_,
                   function(param){
                    var t = param[2], w = param[1];
                    return [0,
                            w,
                            caml_call2
                             (For_monad[11][4][2],
                              size,
                              function(n){return with_size(t, n - 1 | 0);})];
                   }),
               _cg_ = caml_call1(Base_List[18], nonrec_list),
               _ch_ = _cg_ || caml_call1(Base_List[18], rec_list);
              if(_ch_){
               var
                _ci_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$5);
               caml_call1(Base[217], _ci_);
              }
              var
               nonrec_gen = weighted_union(nonrec_list),
               rec_gen =
                 weighted_union(caml_call2(Base[193], nonrec_list, rec_list));
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(param){return 0 === param ? nonrec_gen : rec_gen;});
             });
   }
   function recursive_union(nonrec_list, f){
    function weighted(list){
     return caml_call2(Base_List[52], list, function(t){return [0, 1., t];});
    }
    return weighted_recursive_union
            (weighted(nonrec_list),
             function(self){return weighted(caml_call1(f, self));});
   }
   function sizes(_b8_, opt, param){
    var
     min_length = _b8_ ? _b8_[1] : 0,
     max_length = opt ? opt[1] : Base_Int[62];
    return create
            (function(size, random){
              if(min_length > max_length)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
              var
               upper_bound = min_length + size | 0,
               max_length$0 =
                 min_length <= upper_bound
                  ? caml_call2(Base[204], max_length, upper_bound)
                  : max_length,
               len =
                 caml_call3
                  (Splittable_random[10][1], random, min_length, max_length$0);
              if(0 === len) return 0;
              var
               sizes =
                 caml_call2(Base_Array[40], len, function(param){return 0;}),
               remaining = size - (len - min_length | 0) | 0,
               max_index = len - 1 | 0,
               _b9_ = 1;
              if(remaining >= 1){
               var for$0 = _b9_;
               for(;;){
                var
                 index =
                   caml_call3(Splittable_random[10][1], random, 0, max_index);
                sizes[1 + index] =
                 caml_check_bound(sizes, index)[1 + index] + 1 | 0;
                var _cb_ = for$0 + 1 | 0;
                if(remaining === for$0) break;
                for$0 = _cb_;
               }
              }
              var _b$_ = max_index - 1 | 0, _b__ = 0;
              if(_b$_ >= 0){
               var i = _b__;
               for(;;){
                var
                 j = caml_call3(Splittable_random[3], random, i, max_index);
                caml_call3(Base_Array[80], sizes, i, j);
                var _ca_ = i + 1 | 0;
                if(_b$_ === i) break;
                i = _ca_;
               }
              }
              if
               ((caml_call3
                 (Base_Array[26],
                  [0,
                   Base_Int[76],
                   function(_ce_, _cd_){return _ce_ + _cd_ | 0;}],
                  sizes,
                  function(_cc_){return _cc_;})
                + (len - min_length | 0)
                | 0)
                === size)
               return caml_call1(Base_Array[29], sizes);
              throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
             });
   }
   var
    unit = caml_call1(For_monad[11][1], 0),
    bool =
      create
       (function(param, random){
         return caml_call1(Splittable_random[2], random);
        }),
    _g_ = [0, 1],
    _h_ = [0, 0];
   function option(value_t){
    var _b7_ = [0, map(value_t, Base_Option[21]), 0];
    return union([0, caml_call1(For_monad[11][1], 0), _b7_]);
   }
   function either(fst_t, snd_t){
    var _b6_ = [0, map(snd_t, Base_Either[18]), 0];
    return union([0, map(fst_t, Base_Either[17]), _b6_]);
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function list_generic(min_length, max_length, elt_gen){
    var _b5_ = sizes(min_length, max_length, 0);
    return caml_call2
            (For_monad[11][4][2],
             _b5_,
             function(sizes){
              return all
                      (caml_call2
                        (Base_List[52],
                         sizes,
                         function(size){return with_size(elt_gen, size);}));
             });
   }
   function list(elt_gen){return list_generic(0, 0, elt_gen);}
   function list_non_empty(elt_gen){return list_generic(_g_, 0, elt_gen);}
   function list_with_length(elt_gen, length){
    return list_generic([0, length], [0, length], elt_gen);
   }
   function list_filtered(elts){
    var
     elts$0 = caml_call1(Base_Array[8], elts),
     length_of_input = elts$0.length - 1;
    return create
            (function(param, random){
              var
               length_of_output =
                 caml_call3(Splittable_random[3], random, 0, length_of_input),
               indices =
                 caml_call2
                  (Base_Array[40],
                   length_of_input,
                   function(_b4_){return _b4_;}),
               _b1_ = length_of_output - 1 | 0,
               _b0_ = 0;
              if(_b1_ >= 0){
               var i = _b0_;
               for(;;){
                var
                 j =
                   caml_call3
                    (Splittable_random[3], random, i, length_of_input - 1 | 0);
                caml_call3(Base_Array[80], indices, i, j);
                var _b2_ = i + 1 | 0;
                if(_b1_ === i) break;
                i = _b2_;
               }
              }
              caml_call4
               (Base_Array[65],
                _h_,
                [0, length_of_output],
                indices,
                Base_Int[14]);
              return caml_call2
                      (Base_List[40],
                       length_of_output,
                       function(i){
                        var _b3_ = caml_check_bound(indices, i)[1 + i];
                        return caml_check_bound(elts$0, _b3_)[1 + _b3_];
                       });
             });
   }
   function list_permutations(list){
    return create
            (function(param, random){
              var
               array = caml_call1(Base_Array[8], list),
               _bY_ = array.length - 2 | 0,
               _bX_ = 1;
              if(_bY_ >= 1){
               var i = _bX_;
               for(;;){
                var j = caml_call3(Splittable_random[3], random, 0, i);
                caml_call3(Base_Array[80], array, i, j);
                var _bZ_ = i + 1 | 0;
                if(_bY_ === i) break;
                i = _bZ_;
               }
              }
              return caml_call1(Base_Array[29], array);
             });
   }
   function array(t){var _bW_ = Base_Array[8]; return map(list(t), _bW_);}
   function ref(t){return map(t, function(_bV_){return [0, _bV_];});}
   function lazy_t(t){return map(t, Base_Lazy[21]);}
   function char_uniform_inclusive(lo, hi){
    return create
            (function(param, random){
              var
               _bS_ = caml_call1(Base_Char[30], hi),
               _bT_ = caml_call1(Base_Char[30], lo),
               _bU_ = caml_call3(Splittable_random[3], random, _bT_, _bS_);
              return caml_call1(Base_Char[33], _bU_);
             });
   }
   var
    char_uppercase = char_uniform_inclusive(65, 90),
    char_lowercase = char_uniform_inclusive(97, 122),
    char_digit = char_uniform_inclusive(48, 57),
    char_print_uniform = char_uniform_inclusive(32, 126),
    char_uniform = char_uniform_inclusive(Base_Char[51], Base_Char[52]),
    char_alpha = union([0, char_lowercase, [0, char_uppercase, 0]]),
    char_alphanum =
      weighted_union([0, [0, 52., char_alpha], [0, [0, 10., char_digit], 0]]),
    char_whitespace =
      of_list(caml_call2(Base_List[11], Base_Char[1], Base_Char[43])),
    char_print =
      weighted_union
       ([0, [0, 10., char_alphanum], [0, [0, 1., char_print_uniform], 0]]),
    _i_ = [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[52])], 0],
    char$0 =
      weighted_union
       ([0,
         [0, 100., char_print],
         [0,
          [0, 10., char_uniform],
          [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[51])], _i_]]]);
   function small_int(allow_zero){
    return create
            (function(size, random){
              var
               lower_bound = allow_zero ? 0 : 1,
               upper_bound = size + 1 | 0,
               weighted_low =
                 caml_call3
                  (Splittable_random[10][1],
                   random,
                   0,
                   upper_bound - lower_bound | 0),
               weighted_high = upper_bound - weighted_low | 0;
              return weighted_high;
             });
   }
   var
    small_positive_or_zero_int = small_int(1),
    small_strictly_positive_int = small_int(0),
    _j_ = [0, "p"],
    cst_geometric_distribution_p_m =
      "geometric distribution: p must be between 0 and 1",
    dummy = 0;
   function For_integer(Integer){
    function geometric(lo, p){
     if(caml_call2(Base_Float[16], p, 1.))
      return caml_call1(For_monad[11][1], lo);
     if(caml_call2(Base_Float[16], p, 0.))
      return caml_call1(For_monad[11][1], Integer[85]);
     if
      (!
       caml_call2(Base_Float[14], p, 0.)
       &&
        ! caml_call2(Base_Float[13], p, 1.) && ! caml_call1(Base_Float[84], p)){
      var denominator = runtime.caml_log1p_float(caml_call1(Base[211], p));
      return create
              (function(param, random){
                var
                 uniform = caml_call1(Splittable_random[9], random),
                 exponential =
                   caml_call2(Base[208], Math.log(uniform), denominator),
                 float$0 = caml_call1(Base_Float[63], exponential);
                try{var int$0 = caml_call1(Integer[2], float$0);}
                catch(_bR_){
                 var _bQ_ = caml_wrap_exception(_bR_);
                 if(_bQ_[1] === Stdlib[6]) return Integer[85];
                 throw caml_maybe_attach_backtrace(_bQ_, 0);
                }
                var int$1 = caml_call2(Integer[42], lo, int$0);
                return caml_call2(Integer[16], int$1, lo)
                        ? Integer[85]
                        : int$1;
               });
     }
     var
      _bO_ = [0, [1, [0, _j_, [0, caml_call1(Base[117], p), 0]]], 0],
      _bP_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_geometric_distribution_p_m),
          _bO_]];
     return caml_call1(Base[217], _bP_);
    }
    function uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[97], random, lo, hi);
              });
    }
    function log_uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[98], random, lo, hi);
              });
    }
    function non_uniform(f, lo, hi){
     var
      _bM_ = [0, [0, 0.9, caml_call2(f, lo, hi)], 0],
      _bN_ = [0, [0, 0.05, caml_call1(For_monad[11][1], hi)], _bM_];
     return weighted_union
             ([0, [0, 0.05, caml_call1(For_monad[11][1], lo)], _bN_]);
    }
    function inclusive(_bK_, _bL_){
     return non_uniform(uniform_inclusive, _bK_, _bL_);
    }
    function log_inclusive(_bI_, _bJ_){
     return non_uniform(log_uniform_inclusive, _bI_, _bJ_);
    }
    var
     uniform_all = uniform_inclusive(Integer[86], Integer[85]),
     let_syntax_004 =
       non_uniform(log_uniform_inclusive, Integer[39], Integer[85]),
     _bH_ = caml_call2(For_monad[11][4][4], bool, let_syntax_004),
     all =
       caml_call2
        (For_monad[11][4][3],
         _bH_,
         function(param){
          var magnitude = param[2], negative = param[1];
          return negative ? caml_call1(Integer[71], magnitude) : magnitude;
         });
    return [0,
            geometric,
            uniform_inclusive,
            log_uniform_inclusive,
            ,
            inclusive,
            log_inclusive,
            uniform_all,
            all];
   }
   var
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    invariant = Base_Int[30],
    Hex = Base_Int[31],
    of_string_opt = Base_Int[32],
    to_string_hum = Base_Int[33],
    one = Base_Int[34],
    minus_one = Base_Int[35],
    rem = Base_Int[36],
    round = Base_Int[37],
    round_towards_zero = Base_Int[38],
    round_down = Base_Int[39],
    round_up = Base_Int[40],
    round_nearest = Base_Int[41],
    succ = Base_Int[42],
    pred = Base_Int[43],
    pow = Base_Int[44],
    bit_and = Base_Int[45],
    bit_or = Base_Int[46],
    bit_xor = Base_Int[47],
    bit_not = Base_Int[48],
    popcount = Base_Int[49],
    shift_left = Base_Int[50],
    shift_right = Base_Int[51],
    decr = Base_Int[52],
    incr = Base_Int[53],
    of_int32_exn = Base_Int[54],
    to_int32_exn = Base_Int[55],
    of_int64_exn = Base_Int[56],
    to_int64 = Base_Int[57],
    of_nativeint_exn = Base_Int[58],
    to_nativeint_exn = Base_Int[59],
    of_float_unchecked = Base_Int[60],
    num_bits = Base_Int[61],
    max_value = Base_Int[62],
    min_value = Base_Int[63],
    shift_right_logical = Base_Int[64],
    ceil_pow2 = Base_Int[65],
    floor_pow2 = Base_Int[66],
    ceil_log2 = Base_Int[67],
    floor_log2 = Base_Int[68],
    is_pow2 = Base_Int[69],
    clz = Base_Int[70],
    ctz = Base_Int[71],
    O = Base_Int[72],
    symbol$2 = Base_Int[73],
    lnot = Base_Int[74],
    abs = Base_Int[75],
    zero = Base_Int[76],
    symbol$3 = Base_Int[77],
    symbol$4 = Base_Int[78],
    symbol$5 = Base_Int[79],
    uniform = Splittable_random[3],
    log_uniform = Splittable_random[10][1],
    For_int =
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_bG_, _bF_){return _bF_ <= _bG_ ? 1 : 0;},
         function(_bE_, _bD_){return _bE_ <= _bD_ ? 1 : 0;},
         function(_bC_, _bB_){return _bC_ === _bB_ ? 1 : 0;},
         function(_bA_, _bz_){return _bz_ < _bA_ ? 1 : 0;},
         function(_by_, _bx_){return _by_ < _bx_ ? 1 : 0;},
         function(_bw_, _bv_){return _bw_ !== _bv_ ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         of_string_opt,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(_bu_, _bt_){return _bu_ + _bt_ | 0;},
         function(_bs_, _br_){return _bs_ - _br_ | 0;},
         caml_mul,
         symbol$2,
         function(_bq_){return - _bq_ | 0;},
         function(_bp_){return - _bp_ | 0;},
         symbol$4,
         symbol$3,
         caml_div,
         rem,
         symbol$5,
         function(_bo_, _bn_){return _bo_ & _bn_;},
         function(_bm_, _bl_){return _bm_ | _bl_;},
         function(_bk_, _bj_){return _bk_ ^ _bj_;},
         lnot,
         function(_bi_, _bh_){return _bi_ << _bh_;},
         function(_bg_, _bf_){return _bg_ >> _bf_;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         function(_be_, _bd_){return _be_ >>> _bd_ | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         [0,
          function(_bc_, _bb_){return _bc_ + _bb_ | 0;},
          function(_ba_, _a$_){return _ba_ - _a$_ | 0;},
          caml_mul,
          caml_div,
          function(_a__){return - _a__ | 0;},
          O[1],
          function(_a9_, _a8_){return _a8_ <= _a9_ ? 1 : 0;},
          function(_a7_, _a6_){return _a7_ <= _a6_ ? 1 : 0;},
          function(_a5_, _a4_){return _a5_ === _a4_ ? 1 : 0;},
          function(_a3_, _a2_){return _a2_ < _a3_ ? 1 : 0;},
          function(_a1_, _a0_){return _a1_ < _a0_ ? 1 : 0;},
          function(_aZ_, _aY_){return _aZ_ !== _aY_ ? 1 : 0;},
          O[3],
          function(_aX_){return - _aX_ | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(_aW_, _aV_){return _aW_ & _aV_;},
          function(_aU_, _aT_){return _aU_ | _aT_;},
          function(_aS_, _aR_){return _aS_ ^ _aR_;},
          O[2],
          function(_aQ_, _aP_){return _aQ_ << _aP_;},
          function(_aO_, _aN_){return _aO_ >> _aN_;},
          function(_aM_, _aL_){return _aM_ >>> _aL_ | 0;}],
         uniform,
         log_uniform]),
    int$0 = For_int[8],
    int_uniform = For_int[7],
    int_inclusive = For_int[5],
    int_uniform_inclusive = For_int[2],
    int_log_inclusive = For_int[6],
    int_log_uniform_inclusive = For_int[3],
    int_geometric = For_int[1],
    t_sexp_grammar$0 = Base_Int32[2],
    of_float$0 = Base_Int32[3],
    to_float$0 = Base_Int32[4],
    of_int_exn$0 = Base_Int32[5],
    to_int_exn$0 = Base_Int32[6],
    hash_fold_t$0 = Base_Int32[7],
    hash$0 = Base_Int32[8],
    t_of_sexp$0 = Base_Int32[9],
    sexp_of_t$0 = Base_Int32[10],
    of_string$0 = Base_Int32[11],
    to_string$0 = Base_Int32[12],
    symbol$6 = Base_Int32[13],
    symbol$7 = Base_Int32[14],
    symbol$8 = Base_Int32[15],
    symbol$9 = Base_Int32[16],
    symbol$10 = Base_Int32[17],
    symbol$11 = Base_Int32[18],
    equal$0 = Base_Int32[19],
    compare$0 = Base_Int32[20],
    min$0 = Base_Int32[21],
    max$0 = Base_Int32[22],
    ascending$0 = Base_Int32[23],
    descending$0 = Base_Int32[24],
    between$0 = Base_Int32[25],
    clamp_exn$0 = Base_Int32[26],
    clamp$0 = Base_Int32[27],
    comparator$0 = Base_Int32[28],
    pp$0 = Base_Int32[29],
    hashable$0 = Base_Int32[30],
    is_positive$0 = Base_Int32[31],
    is_non_negative$0 = Base_Int32[32],
    is_negative$0 = Base_Int32[33],
    is_non_positive$0 = Base_Int32[34],
    sign$0 = Base_Int32[35],
    invariant$0 = Base_Int32[36],
    Hex$0 = Base_Int32[37],
    of_string_opt$0 = Base_Int32[38],
    to_string_hum$0 = Base_Int32[39],
    zero$0 = Base_Int32[40],
    one$0 = Base_Int32[41],
    minus_one$0 = Base_Int32[42],
    symbol$12 = Base_Int32[43],
    symbol$13 = Base_Int32[44],
    symbol$14 = Base_Int32[45],
    symbol$15 = Base_Int32[46],
    neg = Base_Int32[47],
    symbol$16 = Base_Int32[48],
    symbol$17 = Base_Int32[49],
    symbol$18 = Base_Int32[50],
    symbol$19 = Base_Int32[51],
    rem$0 = Base_Int32[52],
    symbol$20 = Base_Int32[53],
    land = Base_Int32[54],
    lor = Base_Int32[55],
    lxor = Base_Int32[56],
    lnot$0 = Base_Int32[57],
    lsl = Base_Int32[58],
    asr = Base_Int32[59],
    round$0 = Base_Int32[60],
    round_towards_zero$0 = Base_Int32[61],
    round_down$0 = Base_Int32[62],
    round_up$0 = Base_Int32[63],
    round_nearest$0 = Base_Int32[64],
    abs$0 = Base_Int32[65],
    succ$0 = Base_Int32[66],
    pred$0 = Base_Int32[67],
    pow$0 = Base_Int32[68],
    bit_and$0 = Base_Int32[69],
    bit_or$0 = Base_Int32[70],
    bit_xor$0 = Base_Int32[71],
    bit_not$0 = Base_Int32[72],
    popcount$0 = Base_Int32[73],
    shift_left$0 = Base_Int32[74],
    shift_right$0 = Base_Int32[75],
    decr$0 = Base_Int32[76],
    incr$0 = Base_Int32[77],
    of_int32_exn$0 = Base_Int32[78],
    to_int32_exn$0 = Base_Int32[79],
    of_int64_exn$0 = Base_Int32[80],
    to_int64$0 = Base_Int32[81],
    of_nativeint_exn$0 = Base_Int32[82],
    to_nativeint_exn$0 = Base_Int32[83],
    of_float_unchecked$0 = Base_Int32[84],
    num_bits$0 = Base_Int32[85],
    max_value$0 = Base_Int32[86],
    min_value$0 = Base_Int32[87],
    lsr = Base_Int32[88],
    shift_right_logical$0 = Base_Int32[89],
    ceil_pow2$0 = Base_Int32[90],
    floor_pow2$0 = Base_Int32[91],
    ceil_log2$0 = Base_Int32[92],
    floor_log2$0 = Base_Int32[93],
    is_pow2$0 = Base_Int32[94],
    clz$0 = Base_Int32[95],
    ctz$0 = Base_Int32[96],
    O$0 = Base_Int32[97],
    uniform$0 = Splittable_random[4],
    log_uniform$0 = Splittable_random[10][2],
    For_int32 =
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         of_string_opt$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
    int32 = For_int32[8],
    int32_uniform = For_int32[7],
    int32_inclusive = For_int32[5],
    int32_uniform_inclusive = For_int32[2],
    int32_log_inclusive = For_int32[6],
    int32_log_uniform_inclusive = For_int32[3],
    int32_geometric = For_int32[1],
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$21 = Base_Int63[12],
    symbol$22 = Base_Int63[13],
    symbol$23 = Base_Int63[14],
    symbol$24 = Base_Int63[15],
    symbol$25 = Base_Int63[16],
    symbol$26 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    invariant$1 = Base_Int63[35],
    Hex$1 = Base_Int63[36],
    of_string_opt$1 = Base_Int63[37],
    to_string_hum$1 = Base_Int63[38],
    zero$1 = Base_Int63[39],
    one$1 = Base_Int63[40],
    minus_one$1 = Base_Int63[41],
    symbol$27 = Base_Int63[42],
    symbol$28 = Base_Int63[43],
    symbol$29 = Base_Int63[44],
    symbol$30 = Base_Int63[45],
    neg$0 = Base_Int63[46],
    symbol$31 = Base_Int63[47],
    symbol$32 = Base_Int63[48],
    symbol$33 = Base_Int63[49],
    symbol$34 = Base_Int63[50],
    rem$1 = Base_Int63[51],
    symbol$35 = Base_Int63[52],
    land$0 = Base_Int63[53],
    lor$0 = Base_Int63[54],
    lxor$0 = Base_Int63[55],
    lnot$1 = Base_Int63[56],
    lsl$0 = Base_Int63[57],
    asr$0 = Base_Int63[58],
    round$1 = Base_Int63[59],
    round_towards_zero$1 = Base_Int63[60],
    round_down$1 = Base_Int63[61],
    round_up$1 = Base_Int63[62],
    round_nearest$1 = Base_Int63[63],
    abs$1 = Base_Int63[64],
    succ$1 = Base_Int63[65],
    pred$1 = Base_Int63[66],
    pow$1 = Base_Int63[67],
    bit_and$1 = Base_Int63[68],
    bit_or$1 = Base_Int63[69],
    bit_xor$1 = Base_Int63[70],
    bit_not$1 = Base_Int63[71],
    popcount$1 = Base_Int63[72],
    shift_left$1 = Base_Int63[73],
    shift_right$1 = Base_Int63[74],
    decr$1 = Base_Int63[75],
    incr$1 = Base_Int63[76],
    of_int32_exn$1 = Base_Int63[77],
    to_int32_exn$1 = Base_Int63[78],
    of_int64_exn$1 = Base_Int63[79],
    to_int64$1 = Base_Int63[80],
    of_nativeint_exn$1 = Base_Int63[81],
    to_nativeint_exn$1 = Base_Int63[82],
    of_float_unchecked$1 = Base_Int63[83],
    num_bits$1 = Base_Int63[84],
    max_value$1 = Base_Int63[85],
    min_value$1 = Base_Int63[86],
    lsr$0 = Base_Int63[87],
    shift_right_logical$1 = Base_Int63[88],
    ceil_pow2$1 = Base_Int63[89],
    floor_pow2$1 = Base_Int63[90],
    ceil_log2$1 = Base_Int63[91],
    is_pow2$1 = Base_Int63[92],
    clz$1 = Base_Int63[93],
    ctz$1 = Base_Int63[94],
    O$1 = Base_Int63[95],
    floor_log2$1 = Base_Int63[114],
    uniform$1 = Splittable_random[5],
    log_uniform$1 = Splittable_random[10][3],
    For_int63 =
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         of_string_opt$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
    int63 = For_int63[8],
    int63_uniform = For_int63[7],
    int63_inclusive = For_int63[5],
    int63_uniform_inclusive = For_int63[2],
    int63_log_inclusive = For_int63[6],
    int63_log_uniform_inclusive = For_int63[3],
    int63_geometric = For_int63[1],
    t_sexp_grammar$2 = Base_Int64[2],
    of_float$2 = Base_Int64[3],
    to_float$2 = Base_Int64[4],
    of_int_exn$2 = Base_Int64[5],
    to_int_exn$2 = Base_Int64[6],
    hash_fold_t$2 = Base_Int64[7],
    hash$2 = Base_Int64[8],
    t_of_sexp$2 = Base_Int64[9],
    sexp_of_t$2 = Base_Int64[10],
    of_string$2 = Base_Int64[11],
    to_string$2 = Base_Int64[12],
    equal$2 = Base_Int64[13],
    compare$2 = Base_Int64[14],
    min$2 = Base_Int64[15],
    max$2 = Base_Int64[16],
    ascending$2 = Base_Int64[17],
    descending$2 = Base_Int64[18],
    between$2 = Base_Int64[19],
    clamp_exn$2 = Base_Int64[20],
    clamp$2 = Base_Int64[21],
    comparator$2 = Base_Int64[22],
    pp$2 = Base_Int64[23],
    hashable$2 = Base_Int64[24],
    is_positive$2 = Base_Int64[25],
    is_non_negative$2 = Base_Int64[26],
    is_negative$2 = Base_Int64[27],
    is_non_positive$2 = Base_Int64[28],
    sign$2 = Base_Int64[29],
    invariant$2 = Base_Int64[30],
    Hex$2 = Base_Int64[31],
    of_string_opt$2 = Base_Int64[32],
    to_string_hum$2 = Base_Int64[33],
    one$2 = Base_Int64[34],
    minus_one$2 = Base_Int64[35],
    rem$2 = Base_Int64[36],
    round$2 = Base_Int64[37],
    round_towards_zero$2 = Base_Int64[38],
    round_down$2 = Base_Int64[39],
    round_up$2 = Base_Int64[40],
    round_nearest$2 = Base_Int64[41],
    succ$2 = Base_Int64[42],
    pred$2 = Base_Int64[43],
    pow$2 = Base_Int64[44],
    bit_and$2 = Base_Int64[45],
    bit_or$2 = Base_Int64[46],
    bit_xor$2 = Base_Int64[47],
    bit_not$2 = Base_Int64[48],
    popcount$2 = Base_Int64[49],
    shift_left$2 = Base_Int64[50],
    shift_right$2 = Base_Int64[51],
    decr$2 = Base_Int64[52],
    incr$2 = Base_Int64[53],
    of_int32_exn$2 = Base_Int64[54],
    to_int32_exn$2 = Base_Int64[55],
    of_int64_exn$2 = Base_Int64[56],
    to_int64$2 = Base_Int64[57],
    of_nativeint_exn$2 = Base_Int64[58],
    to_nativeint_exn$2 = Base_Int64[59],
    of_float_unchecked$2 = Base_Int64[60],
    num_bits$2 = Base_Int64[61],
    max_value$2 = Base_Int64[62],
    min_value$2 = Base_Int64[63],
    shift_right_logical$2 = Base_Int64[64],
    ceil_pow2$2 = Base_Int64[65],
    floor_pow2$2 = Base_Int64[66],
    ceil_log2$2 = Base_Int64[67],
    floor_log2$2 = Base_Int64[68],
    is_pow2$2 = Base_Int64[69],
    clz$2 = Base_Int64[70],
    ctz$2 = Base_Int64[71],
    O$2 = Base_Int64[72],
    symbol$36 = Base_Int64[73],
    lnot$2 = Base_Int64[74],
    abs$2 = Base_Int64[75],
    zero$2 = Base_Int64[76],
    symbol$37 = Base_Int64[77],
    symbol$38 = Base_Int64[78],
    symbol$39 = Base_Int64[79],
    uniform$2 = Splittable_random[6],
    log_uniform$2 = Splittable_random[10][4],
    For_int64 =
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         of_string_opt$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
    int64 = For_int64[8],
    int64_uniform = For_int64[7],
    int64_inclusive = For_int64[5],
    int64_uniform_inclusive = For_int64[2],
    int64_log_inclusive = For_int64[6],
    int64_log_uniform_inclusive = For_int64[3],
    int64_geometric = For_int64[1],
    t_sexp_grammar$3 = Base_Nativeint[2],
    of_float$3 = Base_Nativeint[3],
    to_float$3 = Base_Nativeint[4],
    of_int_exn$3 = Base_Nativeint[5],
    to_int_exn$3 = Base_Nativeint[6],
    hash_fold_t$3 = Base_Nativeint[7],
    hash$3 = Base_Nativeint[8],
    t_of_sexp$3 = Base_Nativeint[9],
    sexp_of_t$3 = Base_Nativeint[10],
    of_string$3 = Base_Nativeint[11],
    to_string$3 = Base_Nativeint[12],
    symbol$40 = Base_Nativeint[13],
    symbol$41 = Base_Nativeint[14],
    symbol$42 = Base_Nativeint[15],
    symbol$43 = Base_Nativeint[16],
    symbol$44 = Base_Nativeint[17],
    symbol$45 = Base_Nativeint[18],
    equal$3 = Base_Nativeint[19],
    compare$3 = Base_Nativeint[20],
    min$3 = Base_Nativeint[21],
    max$3 = Base_Nativeint[22],
    ascending$3 = Base_Nativeint[23],
    descending$3 = Base_Nativeint[24],
    between$3 = Base_Nativeint[25],
    clamp_exn$3 = Base_Nativeint[26],
    clamp$3 = Base_Nativeint[27],
    comparator$3 = Base_Nativeint[28],
    pp$3 = Base_Nativeint[29],
    hashable$3 = Base_Nativeint[30],
    is_positive$3 = Base_Nativeint[31],
    is_non_negative$3 = Base_Nativeint[32],
    is_negative$3 = Base_Nativeint[33],
    is_non_positive$3 = Base_Nativeint[34],
    sign$3 = Base_Nativeint[35],
    invariant$3 = Base_Nativeint[36],
    Hex$3 = Base_Nativeint[37],
    of_string_opt$3 = Base_Nativeint[38],
    to_string_hum$3 = Base_Nativeint[39],
    zero$3 = Base_Nativeint[40],
    one$3 = Base_Nativeint[41],
    minus_one$3 = Base_Nativeint[42],
    symbol$46 = Base_Nativeint[43],
    symbol$47 = Base_Nativeint[44],
    symbol$48 = Base_Nativeint[45],
    symbol$49 = Base_Nativeint[46],
    neg$1 = Base_Nativeint[47],
    symbol$50 = Base_Nativeint[48],
    symbol$51 = Base_Nativeint[49],
    symbol$52 = Base_Nativeint[50],
    symbol$53 = Base_Nativeint[51],
    rem$3 = Base_Nativeint[52],
    symbol$54 = Base_Nativeint[53],
    land$1 = Base_Nativeint[54],
    lor$1 = Base_Nativeint[55],
    lxor$1 = Base_Nativeint[56],
    lnot$3 = Base_Nativeint[57],
    lsl$1 = Base_Nativeint[58],
    asr$1 = Base_Nativeint[59],
    round$3 = Base_Nativeint[60],
    round_towards_zero$3 = Base_Nativeint[61],
    round_down$3 = Base_Nativeint[62],
    round_up$3 = Base_Nativeint[63],
    round_nearest$3 = Base_Nativeint[64],
    abs$3 = Base_Nativeint[65],
    succ$3 = Base_Nativeint[66],
    pred$3 = Base_Nativeint[67],
    pow$3 = Base_Nativeint[68],
    bit_and$3 = Base_Nativeint[69],
    bit_or$3 = Base_Nativeint[70],
    bit_xor$3 = Base_Nativeint[71],
    bit_not$3 = Base_Nativeint[72],
    popcount$3 = Base_Nativeint[73],
    shift_left$3 = Base_Nativeint[74],
    shift_right$3 = Base_Nativeint[75],
    decr$3 = Base_Nativeint[76],
    incr$3 = Base_Nativeint[77],
    of_int32_exn$3 = Base_Nativeint[78],
    to_int32_exn$3 = Base_Nativeint[79],
    of_int64_exn$3 = Base_Nativeint[80],
    to_int64$3 = Base_Nativeint[81],
    of_nativeint_exn$3 = Base_Nativeint[82],
    to_nativeint_exn$3 = Base_Nativeint[83],
    of_float_unchecked$3 = Base_Nativeint[84],
    num_bits$3 = Base_Nativeint[85],
    max_value$3 = Base_Nativeint[86],
    min_value$3 = Base_Nativeint[87],
    lsr$1 = Base_Nativeint[88],
    shift_right_logical$3 = Base_Nativeint[89],
    ceil_pow2$3 = Base_Nativeint[90],
    floor_pow2$3 = Base_Nativeint[91],
    ceil_log2$3 = Base_Nativeint[92],
    floor_log2$3 = Base_Nativeint[93],
    is_pow2$3 = Base_Nativeint[94],
    clz$3 = Base_Nativeint[95],
    ctz$3 = Base_Nativeint[96],
    O$3 = Base_Nativeint[97],
    uniform$3 = Splittable_random[7],
    log_uniform$3 = Splittable_random[10][5],
    For_nativeint =
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         of_string_opt$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
    nativeint = For_nativeint[8],
    nativeint_uniform = For_nativeint[7],
    nativeint_inclusive = For_nativeint[5],
    nativeint_uniform_inclusive = For_nativeint[2],
    nativeint_log_inclusive = For_nativeint[6],
    nativeint_log_uniform_inclusiv = For_nativeint[3],
    nativeint_geometric = For_nativeint[1],
    float_zero_exponent = caml_call1(Base_Float[123], 0.),
    float_zero_mantissa = caml_call1(Base_Float[124], 0.),
    float_max_positive_subnormal_v =
      caml_call2(Base_Float[53], 759637122, Base_Float[49]),
    float_subnormal_exponent = caml_call1(Base_Float[123], Base_Float[48]),
    float_min_subnormal_mantissa = caml_call1(Base_Float[124], Base_Float[48]),
    float_max_subnormal_mantissa =
      caml_call1(Base_Float[124], float_max_positive_subnormal_v),
    float_max_positive_normal_valu = Base_Float[47],
    float_min_normal_exponent = caml_call1(Base_Float[123], Base_Float[49]),
    float_max_normal_exponent =
      caml_call1(Base_Float[123], float_max_positive_normal_valu),
    float_max_normal_mantissa =
      caml_call1(Base_Float[124], float_max_positive_normal_valu),
    float_inf_exponent = caml_call1(Base_Float[123], Base_Float[35]),
    float_inf_mantissa = caml_call1(Base_Float[124], Base_Float[35]),
    float_nan_exponent = caml_call1(Base_Float[123], Base_Float[34]),
    float_min_nan_mantissa = caml_call1(Base_Int63[65], float_inf_mantissa),
    _k_ = For_int[2].call(null, 0, 52),
    float_normal_mantissa =
      caml_call2
       (For_monad[11][4][2],
        _k_,
        function(num_bits){
         var
          _aI_ = caml_call2(Base_Int63[73], Base_Int63[40], num_bits),
          _aJ_ = caml_call1(Base_Int63[66], _aI_),
          _aK_ = For_int63[5].call(null, Base_Int63[39], _aJ_);
         return caml_call2
                 (For_monad[11][4][3],
                  _aK_,
                  function(bits){
                   return caml_call2(Base_Int63[73], bits, 52 - num_bits | 0);
                  });
        }),
    lower_bound = caml_call1(Base_Float[123], 1.),
    _l_ =
      For_int[6].call(null, 0, float_max_normal_exponent - lower_bound | 0),
    _n_ =
      [0,
       caml_call2
        (For_monad[11][4][3],
         _l_,
         function(offset){return lower_bound + offset | 0;}),
       0],
    _m_ =
      For_int[6].call(null, 0, lower_bound - float_min_normal_exponent | 0),
    float_exponent =
      union
       ([0,
         caml_call2
          (For_monad[11][4][3],
           _m_,
           function(offset){return lower_bound - offset | 0;}),
         _n_]),
    float_zero =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return caml_call3
                 (Base_Float[121],
                  negative,
                  float_zero_exponent,
                  float_zero_mantissa);
        }),
    let_syntax_012 = caml_call1(For_monad[11][1], float_subnormal_exponent),
    let_syntax_013 =
      For_int63[6].call
       (null, float_min_subnormal_mantissa, float_max_subnormal_mantissa),
    _o_ = caml_call2(For_monad[11][4][4], let_syntax_012, let_syntax_013),
    _p_ = caml_call2(For_monad[11][4][4], bool, _o_),
    float_subnormal =
      caml_call2
       (For_monad[11][4][3],
        _p_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[121], negative, exponent, mantissa);
        }),
    _q_ =
      caml_call2(For_monad[11][4][4], float_exponent, float_normal_mantissa),
    _r_ = caml_call2(For_monad[11][4][4], bool, _q_),
    float_normal =
      caml_call2
       (For_monad[11][4][3],
        _r_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[121], negative, exponent, mantissa);
        }),
    float_infinite =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return caml_call3
                 (Base_Float[121],
                  negative,
                  float_inf_exponent,
                  float_inf_mantissa);
        }),
    let_syntax_021 = caml_call1(For_monad[11][1], float_nan_exponent),
    let_syntax_022 =
      For_int63[5].call
       (null, float_min_nan_mantissa, float_max_normal_mantissa),
    _s_ = caml_call2(For_monad[11][4][4], let_syntax_021, let_syntax_022),
    _t_ = caml_call2(For_monad[11][4][4], bool, _s_),
    float_nan =
      caml_call2
       (For_monad[11][4][3],
        _t_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[121], negative, exponent, mantissa);
        });
   function float_of_class(c){
    switch(c){
      case 0:
       return float_infinite;
      case 1:
       return float_nan;
      case 2:
       return float_normal;
      case 3:
       return float_subnormal;
      default: return float_zero;
    }
   }
   function float_matching_classes(filter){
    return weighted_union
            (caml_call2
              (Base_List[12],
               Base_Float[115][2],
               function(c){
                if(! caml_call1(filter, c)) return 0;
                var _aG_ = float_of_class(c);
                switch(c){
                  case 0:
                   var _aH_ = 1.; break;
                  case 1:
                   var _aH_ = 1.; break;
                  case 2:
                   var _aH_ = 100.; break;
                  case 3:
                   var _aH_ = 10.; break;
                  default: var _aH_ = 1.;
                }
                return [0, [0, _aH_, _aG_]];
               }));
   }
   var
    float_finite =
      float_matching_classes(function(param){return 2 <= param ? 1 : 0;}),
    float_without_nan =
      float_matching_classes(function(param){return 1 === param ? 0 : 1;}),
    float$0 = float_matching_classes(function(param){return 1;}),
    float_finite_non_zero =
      float_matching_classes
       (function(param){return 1 < param - 2 >>> 0 ? 0 : 1;}),
    float_strictly_positive =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){return caml_call1(Base_Float[104], t);}),
    float_strictly_negative =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){
         var _aF_ = caml_call1(Base_Float[104], t);
         return caml_call1(Base[211], _aF_);
        }),
    float_positive_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){return caml_call1(Base_Float[104], t);}),
    float_negative_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){
         var _aE_ = caml_call1(Base_Float[104], t);
         return caml_call1(Base[211], _aE_);
        }),
    _u_ = [0, cst_upper_bound],
    _v_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_bo =
      "Float.uniform_exclusive: bounds are not finite",
    _w_ = [0, cst_upper_bound],
    _x_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_re =
      "Float.uniform_exclusive: requested range is empty";
   function float_uniform_exclusive(lower_bound, upper_bound){
    var
     _aw_ = 1 - caml_call1(Base_Float[86], lower_bound),
     _ax_ = _aw_ || 1 - caml_call1(Base_Float[86], upper_bound);
    if(_ax_){
     var
      _ay_ = [0, [1, [0, _u_, [0, caml_call1(Base[117], upper_bound), 0]]], 0],
      _az_ =
        [0, [1, [0, _v_, [0, caml_call1(Base[117], lower_bound), 0]]], _ay_],
      _aA_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_bo),
          _az_]];
     caml_call1(Base[217], _aA_);
    }
    var
     lower_inclusive = caml_call2(Base_Float[53], 19067, lower_bound),
     upper_inclusive = caml_call2(Base_Float[53], 759637122, upper_bound);
    if(caml_call2(Base_Float[105][11], lower_inclusive, upper_inclusive)){
     var
      _aB_ = [0, [1, [0, _w_, [0, caml_call1(Base[117], upper_bound), 0]]], 0],
      _aC_ =
        [0, [1, [0, _x_, [0, caml_call1(Base[117], lower_bound), 0]]], _aB_],
      _aD_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_re),
          _aC_]];
     caml_call1(Base[217], _aD_);
    }
    return create
            (function(param, random){
              return caml_call3
                      (Splittable_random[8],
                       random,
                       lower_inclusive,
                       upper_inclusive);
             });
   }
   function float_inclusive(lower_bound, upper_bound){
    if(caml_call2(Base_Float[16], lower_bound, upper_bound))
     return caml_call1(For_monad[11][1], lower_bound);
    var _as_ = caml_call2(Base_Float[53], 19067, lower_bound);
    if(caml_call2(Base_Float[12], _as_, upper_bound)){
     var _at_ = [0, caml_call1(For_monad[11][1], upper_bound), 0];
     return union([0, caml_call1(For_monad[11][1], lower_bound), _at_]);
    }
    var
     _au_ =
       [0, [0, 0.9, float_uniform_exclusive(lower_bound, upper_bound)], 0],
     _av_ = [0, [0, 0.05, caml_call1(For_monad[11][1], upper_bound)], _au_];
    return weighted_union
            ([0, [0, 0.05, caml_call1(For_monad[11][1], lower_bound)], _av_]);
   }
   function string_with_length_of(char_gen, length){
    var _ar_ = list_with_length(char_gen, length);
    return map(_ar_, Base_String[133]);
   }
   function string_of(char_gen){
    return bind
            (small_positive_or_zero_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   function string_non_empty_of(char_gen){
    return bind
            (small_strictly_positive_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   var
    string = string_of(char$0),
    string_non_empty = string_non_empty_of(char$0);
   function string_with_length(length){
    return string_with_length_of(char$0, length);
   }
   function edit_insert(string){
    var _al_ = int_uniform_inclusive(0, caml_ml_string_length(string));
    return caml_call2
            (For_monad[11][4][2],
             _al_,
             function(pos){
              var _am_ = int_geometric(1, 0.5);
              return caml_call2
                      (For_monad[11][4][2],
                       _am_,
                       function(length){
                        var _an_ = string_with_length_of(char$0, length);
                        return caml_call2
                                (For_monad[11][4][2],
                                 _an_,
                                 function(str){
                                  var
                                   _ao_ =
                                     [0, str, [0, caml_call2(Base_String[120], string, pos), 0]],
                                   _ap_ = [0, caml_call2(Base_String[118], string, pos), _ao_],
                                   _aq_ = caml_call2(Base_String[67], 0, _ap_);
                                  return caml_call1(For_monad[11][1], _aq_);
                                 });
                       });
             });
   }
   function edit(string, n_times){
    if(0 >= n_times) return caml_call1(For_monad[11][1], string);
    function _Y_(string){return edit(string, n_times - 1 | 0);}
    if(caml_call1(Base_String[14], string))
     var _Z_ = edit_insert(string);
    else
     var
      _U_ = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      _V_ =
        [0,
         caml_call2
          (For_monad[11][4][2],
           _U_,
           function(len){
            var
             _ah_ =
               int_uniform_inclusive
                (0, caml_ml_string_length(string) - len | 0);
            return caml_call2
                    (For_monad[11][4][2],
                     _ah_,
                     function(pos){
                      var
                       _ai_ = [0, caml_call2(Base_String[120], string, pos), 0],
                       _aj_ =
                         [0,
                          caml_call2(Base_String[118], string, pos + len | 0),
                          _ai_],
                       _ak_ = caml_call2(Base_String[67], 0, _aj_);
                      return caml_call1(For_monad[11][1], _ak_);
                     });
           }),
         0],
      _T_ = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      _W_ =
        [0,
         caml_call2
          (For_monad[11][4][2],
           _T_,
           function(length){
            var
             _ac_ =
               int_uniform_inclusive
                (0, caml_ml_string_length(string) - length | 0);
            return caml_call2
                    (For_monad[11][4][2],
                     _ac_,
                     function(pos){
                      var _ad_ = string_with_length_of(char$0, length);
                      return caml_call2
                              (For_monad[11][4][2],
                               _ad_,
                               function(str){
                                var
                                 _ae_ =
                                   [0,
                                    str,
                                    [0,
                                     caml_call2(Base_String[120], string, pos + length | 0),
                                     0]],
                                 _af_ = [0, caml_call2(Base_String[118], string, pos), _ae_],
                                 _ag_ = caml_call2(Base_String[67], 0, _af_);
                                return caml_call1(For_monad[11][1], _ag_);
                               });
                     });
           }),
         _V_],
      _S_ = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      _X_ =
        [0,
         caml_call2
          (For_monad[11][4][2],
           _S_,
           function(len){
            var
             ___ =
               int_uniform_inclusive
                (0, caml_ml_string_length(string) - len | 0);
            return caml_call2
                    (For_monad[11][4][2],
                     ___,
                     function(pos){
                      var
                       _$_ =
                         [0, caml_call2(Base_String[120], string, pos + len | 0), 0],
                       _aa_ = [0, caml_call2(Base_String[118], string, pos), _$_],
                       _ab_ = caml_call2(Base_String[67], 0, _aa_);
                      return caml_call1(For_monad[11][1], _ab_);
                     });
           }),
         _W_],
      _Z_ = union([0, edit_insert(string), _X_]);
    return caml_call2(For_monad[11][4][2], _Z_, _Y_);
   }
   function string_like(string){
    var _R_ = int_geometric(0, 0.5);
    return caml_call2
            (For_monad[11][4][2],
             _R_,
             function(n_times){return edit(string, n_times);});
   }
   var bytes = map(string, Base_Bytes[26]);
   function sexp_of(atom){
    return fixed_point
            (function(self){
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(size){
                        var _P_ = For_int[3].call(null, 0, size + 1 | 0);
                        return caml_call2
                                (For_monad[11][4][2],
                                 _P_,
                                 function(param){
                                  if(0 === param)
                                   return caml_call2
                                           (For_monad[11][4][3],
                                            atom,
                                            function(atom){return [0, atom];});
                                  var _Q_ = list(self);
                                  return caml_call2
                                          (For_monad[11][4][3],
                                           _Q_,
                                           function(list){return [1, list];});
                                 });
                       });
             });
   }
   var sexp = sexp_of(string);
   function map_tree_using_comparator(comparator, key_gen, data_gen){
    var _L_ = list(key_gen);
    return caml_call2
            (For_monad[11][4][2],
             _L_,
             function(keys){
              var
               keys$0 = caml_call2(Base_List[124], keys, comparator[1]),
               _M_ =
                 list_with_length(data_gen, caml_call1(Base_List[17], keys$0));
              return caml_call2
                      (For_monad[11][4][2],
                       _M_,
                       function(data){
                        var
                         _N_ = caml_call2(Base_List[108], keys$0, data),
                         _O_ = caml_call2(Base_Map[112][3][13], comparator, _N_);
                        return caml_call1(For_monad[11][1], _O_);
                       });
             });
   }
   function set_tree_using_comparator(comparator, elt_gen){
    var _K_ = caml_call1(Base_Set[76][3][56], comparator);
    return map(list(elt_gen), _K_);
   }
   function map_t_m(m, key_gen, data_gen){
    var
     comparator = m[1],
     _J_ = map_tree_using_comparator(comparator, key_gen, data_gen);
    return map(_J_, caml_call1(Base_Map[112][31], comparator));
   }
   function set_t_m(m, elt_gen){
    var
     comparator = m[1],
     _I_ = set_tree_using_comparator(comparator, elt_gen);
    return map(_I_, caml_call1(Base_Set[76][66], comparator));
   }
   function bigarray1(t, kind, layout){
    var _G_ = list(t);
    return caml_call2
            (For_monad[11][4][3],
             _G_,
             function(elts){
              var
               elts$0 = caml_call1(Base_Array[8], elts),
               dim = elts$0.length - 1,
               offset =
                 caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
              return caml_call4
                      (Base_quickcheck_Bigarray_helpe[2][2],
                       kind,
                       layout,
                       dim,
                       function(i){
                        var _H_ = i - offset | 0;
                        return caml_check_bound(elts$0, _H_)[1 + _H_];
                       });
             });
   }
   var
    bigstring = bigarray1(char$0, 12, 0),
    float32_vec = bigarray1(float$0, 0, 1),
    float64_vec = bigarray1(float$0, 1, 1),
    _y_ = [0, 0, 0],
    bigarray2_dim =
      caml_call2
       (For_monad[11][4][2],
        size,
        function(max_total_size){
         if(0 === max_total_size) return caml_call1(For_monad[11][1], _y_);
         var _D_ = int_log_uniform_inclusive(1, max_total_size);
         return caml_call2
                 (For_monad[11][4][2],
                  _D_,
                  function(a){
                   var
                    max_b = caml_div(max_total_size, a),
                    _E_ = int_log_uniform_inclusive(0, max_b),
                    _F_ =
                      caml_call2
                       (For_monad[11][4][3],
                        _E_,
                        function(b_weighted_low){return max_b - b_weighted_low | 0;});
                   return caml_call2
                           (For_monad[11][4][2],
                            _F_,
                            function(b){
                             return caml_call2
                                     (For_monad[11][4][3],
                                      bool,
                                      function(param){return param ? [0, a, b] : [0, b, a];});
                            });
                  });
        });
   function bigarray2(t, kind, layout){
    return caml_call2
            (For_monad[11][4][2],
             bigarray2_dim,
             function(param){
              var
               dim2 = param[2],
               dim1 = param[1],
               _A_ = list_with_length(list_with_length(t, dim2), dim1);
              return caml_call2
                      (For_monad[11][4][3],
                       _A_,
                       function(elts){
                        var
                         elts$0 = caml_call2(Base_Array[84], elts, Base_Array[8]),
                         offset =
                           caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
                        return caml_call5
                                (Base_quickcheck_Bigarray_helpe[3][2],
                                 kind,
                                 layout,
                                 dim1,
                                 dim2,
                                 function(i, j){
                                  var _B_ = j - offset | 0, _C_ = i - offset | 0;
                                  return caml_check_bound
                                           (caml_check_bound(elts$0, _C_)[1 + _C_], _B_)
                                          [1 + _B_];
                                 });
                       });
             });
   }
   var
    float32_mat = bigarray2(float$0, 0, 1),
    float64_mat = bigarray2(float$0, 1, 1);
   function coverage(Cmp, sample){
    var _z_ = caml_call1(Base_Map[6], Cmp);
    return caml_call3
            (Base_Sequence[8],
             sample,
             _z_,
             function(counts, value){
              return caml_call3
                      (Base_Map[39],
                       counts,
                       value,
                       function(param){
                        if(! param) return 1;
                        var prev = param[1];
                        return prev + 1 | 0;
                       });
             });
   }
   function monitor(t, f){
    return map(t, function(value){caml_call1(f, value); return value;});
   }
   var
    Debug = [0, coverage, monitor],
    Base_quickcheck_Generator =
      [0,
       unit,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       symbol_bind,
       symbol_map,
       For_monad[3],
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       nativeint_uniform,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       nativeint_inclusive,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       nativeint_uniform_inclusive,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       nativeint_log_uniform_inclusiv,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       nativeint_log_inclusive,
       int_geometric,
       int32_geometric,
       int63_geometric,
       int64_geometric,
       nativeint_geometric,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       string_like,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       perturb,
       create,
       generate,
       Debug];
   runtime.caml_register_global
    (88, Base_quickcheck_Generator, "Base_quickcheck__Generator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Shrinker
//# unitInfo: Requires: Base__Array, Base__Bytes, Base__Either, Base__Field, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Option, Base__Sequence, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, CamlinternalLazy, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_layout = runtime.caml_ba_layout,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_List = global_data.Base__List,
    Base_Either = global_data.Base__Either,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Lazy = global_data.Base__Lazy,
    Base_Array = global_data.Base__Array,
    Base_Option = global_data.Base__Option,
    Base_Field = global_data.Base__Field,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Int = global_data.Base__Int,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes;
   function atomic(param){return Base_Sequence[38];}
   function create(_X_){return _X_;}
   function shrink(_W_){return _W_;}
   function map(t, f, f_inverse){
    return function(x){
     var _V_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[32], _V_, f);};
   }
   function filter(t, f){
    return function(x){
     var _U_ = caml_call1(t, x);
     return caml_call2(Base_Sequence[51], _U_, f);};
   }
   function filter_map(t, f, f_inverse){
    return function(x){
     var _T_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[78], _T_, f);};
   }
   function of_lazy(lazy_t){
    return function(x){
     return caml_call1
             (Base_Sequence[105],
              [246,
               function(_Q_){
                var _R_ = caml_obj_tag(lazy_t);
                a:
                if(250 === _R_)
                 var _S_ = lazy_t[1];
                else{
                 if(246 !== _R_ && 244 !== _R_){var _S_ = lazy_t; break a;}
                 var _S_ = caml_call1(CamlinternalLazy[2], lazy_t);
                }
                return caml_call1(_S_, x);
               }]);};
   }
   function fixed_point(of_shrinker){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(of_shrinker, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   function both(fst_t, snd_t){
    return function(param){
     var
      snd = param[2],
      fst = param[1],
      _M_ = caml_call1(snd_t, snd),
      _N_ =
        [0,
         caml_call2
          (Base_Sequence[32], _M_, function(snd){return [0, fst, snd];}),
         0],
      _O_ = caml_call1(fst_t, fst),
      _P_ =
        [0,
         caml_call2
          (Base_Sequence[32], _O_, function(fst){return [0, fst, snd];}),
         _N_];
     return caml_call1(Base_Sequence[68], _P_);};
   }
   function float32_vec(src){
    var dim = caml_ba_dim_1(src);
    if(0 === dim) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
    return caml_call2
            (Base_Sequence[77],
             dim,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              return caml_call4
                      (Base_quickcheck_Bigarray_helpe[2][2],
                       kind,
                       layout,
                       dim - 1 | 0,
                       function(i){
                        var i$0 = i < to_skip$0 ? i : i + 1 | 0;
                        return runtime.caml_ba_get_1(src, i$0);
                       });
             });
   }
   function dim2(r){return r[2];}
   function dim1(r){return r[1];}
   var
    dim2$0 =
      [0,
       function(param){return 0;},
       "dim2",
       0,
       dim2,
       function(r, v){return [0, r[1], v];}],
    dim1$0 =
      [0,
       function(param){return 0;},
       "dim1",
       0,
       dim1,
       function(r, v){return [0, v, r[2]];}];
   function shrink$0(field, src){
    var _K_ = runtime.caml_ba_dim_2(src), dims = [0, caml_ba_dim_1(src), _K_];
    if(0 === caml_call2(Base_Field[3], field, dims)) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout),
     match = caml_call3(Base_Field[6], field, dims, Base_Int[43]),
     dim2 = match[2],
     dim1 = match[1],
     _L_ = caml_call2(Base_Field[3], field, dims);
    return caml_call2
            (Base_Sequence[77],
             _L_,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              function skip(i){return i < to_skip$0 ? i : i + 1 | 0;}
              return caml_call5
                      (Base_quickcheck_Bigarray_helpe[3][2],
                       kind,
                       layout,
                       dim1,
                       dim2,
                       function(dim1, dim2){
                        var
                         match =
                           caml_call3(Base_Field[6], field, [0, dim1, dim2], skip),
                         dim2$0 = match[2],
                         dim1$0 = match[1];
                        return runtime.caml_ba_get_2(src, dim1$0, dim2$0);
                       });
             });
   }
   function float32_mat(src){
    var
     _I_ = [0, shrink$0(dim2$0, src), 0],
     _J_ = [0, shrink$0(dim1$0, src), _I_];
    return caml_call1(Base_Sequence[68], _J_);
   }
   function option(value_t){
    return function(param){
     if(! param) return Base_Sequence[38];
     var
      value = param[1],
      _E_ = Base_Option[21],
      _F_ = caml_call1(value_t, value),
      _G_ = caml_call2(Base_Sequence[32], _F_, _E_),
      _H_ = caml_call1(Base_Sequence[99], 0);
     return caml_call2(Base_Sequence[63], _H_, _G_);};
   }
   function list(elt_t){
    return fixed_point
            (function(list_t){
              return function(param){
               if(! param) return Base_Sequence[38];
               var
                tail = param[2],
                head = param[1],
                _z_ = caml_call1(list_t, tail),
                _A_ =
                  [0,
                   caml_call2
                    (Base_Sequence[32],
                     _z_,
                     function(tail){return [0, head, tail];}),
                   0],
                _B_ = caml_call1(elt_t, head),
                _C_ =
                  [0,
                   caml_call2
                    (Base_Sequence[32],
                     _B_,
                     function(head){return [0, head, tail];}),
                   _A_],
                _D_ = [0, caml_call1(Base_Sequence[99], tail), _C_];
               return caml_call1(Base_Sequence[68], _D_);};
             });
   }
   var
    _a_ = Base_String[25],
    _b_ = Base_String[133],
    string = map(list(atomic), _b_, _a_),
    bytes = map(string, Base_Bytes[26], Base_Bytes[27]);
   function array(t){
    var _x_ = Base_Array[29], _y_ = Base_Array[8];
    return map(list(t), _y_, _x_);
   }
   function ref(t){
    return map
            (t,
             function(_w_){return [0, _w_];},
             function(_v_){return _v_[1];});
   }
   function lazy_t(t){
    return map
            (t,
             Base_Lazy[21],
             function(_t_){
              var _u_ = caml_obj_tag(_t_);
              if(250 === _u_) return _t_[1];
              if(246 !== _u_ && 244 !== _u_) return _t_;
              return caml_call1(CamlinternalLazy[2], _t_);
             });
   }
   var
    sexp =
      fixed_point
       (function(shrinker){
         return function(param){
          if(0 === param[0]) return Base_Sequence[38];
          var
           l = param[1],
           _s_ = list(shrinker)(l),
           shrink_list =
             caml_call2(Base_Sequence[32], _s_, function(l){return [1, l];}),
           shrink_tree = caml_call1(Base_Sequence[104], l);
          return caml_call1
                  (Base_Sequence[68], [0, shrink_list, [0, shrink_tree, 0]]);};
        });
   function either(fst_t, snd_t){
    return function(either){
     if(0 === either[0]){
      var
       fst = either[1],
       _o_ = Base_Either[17],
       _p_ = caml_call1(fst_t, fst);
      return caml_call2(Base_Sequence[32], _p_, _o_);
     }
     var snd = either[1], _q_ = Base_Either[18], _r_ = caml_call1(snd_t, snd);
     return caml_call2(Base_Sequence[32], _r_, _q_);};
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             },
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function map_tree_using_comparator(comparator, key_t, data_t){
    return function(tree){
     var
      alist = caml_call2(Base_Map[112][3][71], 0, tree),
      _j_ = caml_call1(Base_Sequence[104], alist),
      drop_keys =
        caml_call2
         (Base_Sequence[32],
          _j_,
          function(param){
           var k = param[1];
           return caml_call3(Base_Map[112][3][44], comparator, tree, k);
          }),
      _k_ =
        caml_call2
         (Base_List[52],
          alist,
          function(param){
           var
            data = param[2],
            key = param[1],
            tree$0 = caml_call3(Base_Map[112][3][44], comparator, tree, key),
            _n_ = caml_call1(key_t, key);
           return caml_call2
                   (Base_Sequence[78],
                    _n_,
                    function(smaller_key){
                     var
                      match =
                        caml_call4
                         (Base_Map[112][3][34],
                          comparator,
                          tree$0,
                          smaller_key,
                          data);
                     if(typeof match === "number") return 0;
                     var tree = match[2];
                     return [0, tree];
                    });
          }),
      shrink_keys = caml_call1(Base_Sequence[68], _k_),
      _l_ =
        caml_call2
         (Base_List[52],
          alist,
          function(param){
           var
            data = param[2],
            key = param[1],
            _m_ = caml_call1(data_t, data);
           return caml_call2
                   (Base_Sequence[32],
                    _m_,
                    function(smaller_data){
                     return caml_call4
                             (Base_Map[112][3][36], comparator, tree, key, smaller_data);
                    });
          }),
      shrink_data = caml_call1(Base_Sequence[68], _l_);
     return caml_call1
             (Base_Sequence[68],
              [0, drop_keys, [0, shrink_keys, [0, shrink_data, 0]]]);};
   }
   function set_tree_using_comparator(comparator, elt_t){
    return function(tree){
     var
      list = caml_call1(Base_Set[76][3][14], tree),
      _g_ = caml_call1(Base_Sequence[104], list),
      drop_elts =
        caml_call2
         (Base_Sequence[32],
          _g_,
          function(elt){
           return caml_call3(Base_Set[76][3][19], comparator, tree, elt);
          }),
      _h_ =
        caml_call2
         (Base_List[52],
          list,
          function(elt){
           var
            tree$0 = caml_call3(Base_Set[76][3][19], comparator, tree, elt),
            _i_ = caml_call1(elt_t, elt);
           return caml_call2
                   (Base_Sequence[78],
                    _i_,
                    function(smaller_elt){
                     return caml_call3
                              (Base_Set[76][3][17], comparator, tree$0, smaller_elt)
                             ? 0
                             : [0,
                               caml_call3
                                (Base_Set[76][3][18], comparator, tree$0, smaller_elt)];
                    });
          }),
      shrink_elts = caml_call1(Base_Sequence[68], _h_);
     return caml_call1(Base_Sequence[68], [0, drop_elts, [0, shrink_elts, 0]]);};
   }
   function map_t(key_t, data_t){
    return function(map_t){
     var
      comparator = caml_call1(Base_Map[5], map_t),
      _e_ = Base_Map[112][98],
      _f_ = caml_call1(Base_Map[112][31], comparator),
      t = map(map_tree_using_comparator(comparator, key_t, data_t), _f_, _e_);
     return t(map_t);};
   }
   function set_t(elt_t){
    return function(set_t){
     var
      comparator = caml_call1(Base_Set[4], set_t),
      _c_ = Base_Set[76][49],
      _d_ = caml_call1(Base_Set[76][66], comparator),
      t = map(set_tree_using_comparator(comparator, elt_t), _d_, _c_);
     return t(set_t);};
   }
   var
    Base_quickcheck_Shrinker =
      [0,
       atomic,
       atomic,
       atomic,
       atomic,
       string,
       bytes,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       float32_vec,
       float32_vec,
       float32_vec,
       float32_mat,
       float32_mat,
       map_t,
       set_t,
       map_tree_using_comparator,
       set_tree_using_comparator,
       map,
       filter,
       filter_map,
       fixed_point,
       of_lazy,
       create,
       shrink];
   runtime.caml_register_global
    (17, Base_quickcheck_Shrinker, "Base_quickcheck__Shrinker");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck_Test_intf = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_Test_intf, "Base_quickcheck__Test_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test
//# unitInfo: Requires: Base, Base__Backtrace, Base__Error, Base__Field, Base__List, Base__Or_error, Base__Random, Base__Sequence, Base__String, Base__Word_size, Base_quickcheck__Generator, Base_quickcheck__Shrinker, Base_quickcheck__Test_intf, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_seed = "seed",
    cst_shrink_count = "shrink_count",
    cst_sizes = "sizes",
    cst_test_count = "test_count";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "...",
    names =
      [0,
       cst_seed,
       [0, cst_test_count, [0, cst_shrink_count, [0, cst_sizes, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Sequence = global_data.Base__Sequence,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base = global_data.Base,
    Splittable_random = global_data.Splittable_random,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Random = global_data.Base__Random,
    Base_Field = global_data.Base__Field,
    Base_List = global_data.Base__List,
    Base_Word_size = global_data.Base__Word_size,
    _a_ = [0, "Deterministic"],
    _b_ = [0, "Nondeterministic"];
   function sexp_of_t(param){
    if(! param) return _b_;
    var arg0_001 = param[1], res0_002 = caml_call1(Base[177], arg0_001);
    return [1, [0, _a_, [0, res0_002, 0]]];
   }
   var Seed = [0, sexp_of_t];
   function sizes(r){return r[4];}
   function shrink_count(r){return r[3];}
   function test_count(r){return r[2];}
   function seed(r){return r[1];}
   var
    sizes$0 =
      [0,
       function(param){return 0;},
       cst_sizes,
       0,
       sizes,
       function(r, v){return [0, r[1], r[2], r[3], v];}],
    shrink_count$0 =
      [0,
       function(param){return 0;},
       cst_shrink_count,
       0,
       shrink_count,
       function(r, v){return [0, r[1], r[2], v, r[4]];}],
    test_count$0 =
      [0,
       function(param){return 0;},
       cst_test_count,
       0,
       test_count,
       function(r, v){return [0, r[1], v, r[3], r[4]];}],
    seed$0 =
      [0,
       function(param){return 0;},
       cst_seed,
       0,
       seed,
       function(r, v){return [0, v, r[2], r[3], r[4]];}];
   function make_creator
   (seed_fun, test_count_fun, shrink_count_fun, sizes_fun, compile_acc){
    var
     match = caml_call2(seed_fun, seed$0, compile_acc),
     compile_acc$0 = match[2],
     seed_gen = match[1],
     match$0 = caml_call2(test_count_fun, test_count$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     test_count_gen = match$0[1],
     match$1 = caml_call2(shrink_count_fun, shrink_count$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     shrink_count_gen = match$1[1],
     match$2 = caml_call2(sizes_fun, sizes$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     sizes_gen = match$2[1];
    return [0,
            function(acc){
             var
              seed = caml_call1(seed_gen, acc),
              test_count = caml_call1(test_count_gen, acc),
              shrink_count = caml_call1(shrink_count_gen, acc),
              sizes = caml_call1(sizes_gen, acc);
             return [0, seed, test_count, shrink_count, sizes];
            },
            compile_acc$3];
   }
   function create(seed, test_count, shrink_count, sizes){return [0, seed, test_count, shrink_count, sizes];
   }
   function map(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ak_ = caml_call1(sizes_fun, sizes$0),
     _al_ = caml_call1(shrink_count_fun, shrink_count$0),
     _am_ = caml_call1(test_count_fun, test_count$0);
    return [0, caml_call1(seed_fun, seed$0), _am_, _al_, _ak_];
   }
   function iter(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call1(seed_fun, seed$0);
    caml_call1(test_count_fun, test_count$0);
    caml_call1(shrink_count_fun, shrink_count$0);
    return caml_call1(sizes_fun, sizes$0);
   }
   function fold(init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    return caml_call2
            (sizes_fun,
             caml_call2
              (shrink_count_fun,
               caml_call2
                (test_count_fun,
                 caml_call2(seed_fun, init, seed$0),
                 test_count$0),
               shrink_count$0),
             sizes$0);
   }
   function map_poly(record){
    var
     _ah_ = [0, caml_call1(record[1], sizes$0), 0],
     _ai_ = [0, caml_call1(record[1], shrink_count$0), _ah_],
     _aj_ = [0, caml_call1(record[1], test_count$0), _ai_];
    return [0, caml_call1(record[1], seed$0), _aj_];
   }
   function for_all(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ae_ = caml_call1(seed_fun, seed$0),
     _af_ = _ae_ ? caml_call1(test_count_fun, test_count$0) : _ae_,
     _ag_ = _af_ ? caml_call1(shrink_count_fun, shrink_count$0) : _af_;
    return _ag_ ? caml_call1(sizes_fun, sizes$0) : _ag_;
   }
   function exists(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ad_ = caml_call1(seed_fun, seed$0),
     _ab_ = _ad_ || caml_call1(test_count_fun, test_count$0),
     _ac_ = _ab_ || caml_call1(shrink_count_fun, shrink_count$0);
    return _ac_ ? _ac_ : caml_call1(sizes_fun, sizes$0);
   }
   function to_list(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     ___ = [0, caml_call1(sizes_fun, sizes$0), 0],
     _$_ = [0, caml_call1(shrink_count_fun, shrink_count$0), ___],
     _aa_ = [0, caml_call1(test_count_fun, test_count$0), _$_];
    return [0, caml_call1(seed_fun, seed$0), _aa_];
   }
   function iter$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call3(seed_fun, seed$0, record, record[1]);
    caml_call3(test_count_fun, test_count$0, record, record[2]);
    caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function fold$0
   (record, init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var _X_ = record[4], _Y_ = record[3], _Z_ = record[2];
    return caml_call4
            (sizes_fun,
             caml_call4
              (shrink_count_fun,
               caml_call4
                (test_count_fun,
                 caml_call4(seed_fun, init, seed$0, record, record[1]),
                 test_count$0,
                 record,
                 _Z_),
               shrink_count$0,
               record,
               _Y_),
             sizes$0,
             record,
             _X_);
   }
   function for_all$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _U_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _V_ =
       _U_ ? caml_call3(test_count_fun, test_count$0, record, record[2]) : _U_,
     _W_ =
       _V_
        ? caml_call3(shrink_count_fun, shrink_count$0, record, record[3])
        : _V_;
    return _W_ ? caml_call3(sizes_fun, sizes$0, record, record[4]) : _W_;
   }
   function exists$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _T_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _R_ = _T_ || caml_call3(test_count_fun, test_count$0, record, record[2]),
     _S_ =
       _R_ || caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return _S_ ? _S_ : caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function to_list$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _O_ = [0, caml_call3(sizes_fun, sizes$0, record, record[4]), 0],
     _P_ =
       [0,
        caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
        _O_],
     _Q_ =
       [0, caml_call3(test_count_fun, test_count$0, record, record[2]), _P_];
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _Q_];
   }
   function map$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _L_ = caml_call3(sizes_fun, sizes$0, record, record[4]),
     _M_ = caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
     _N_ = caml_call3(test_count_fun, test_count$0, record, record[2]);
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _N_, _M_, _L_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    _c_ = [0, cst_sizes],
    _d_ = [0, cst_shrink_count],
    _e_ = [0, cst_test_count],
    _f_ = [0, cst_seed];
   function sexp_of_t$0(param){
    var
     sizes_010 = param[4],
     shrink_count_008 = param[3],
     test_count_006 = param[2],
     seed_004 = param[1],
     sexp_of_elt = Base[125],
     match = caml_call2(Base_Sequence[88], sizes_010, 100),
     suffix = match[2],
     prefix = match[1],
     prefix$0 = caml_call2(Base_List[52], prefix, sexp_of_elt),
     bnds_003 = 0,
     suffix$0 =
       caml_call1(Base_Sequence[6], suffix)
        ? 0
        : [0, caml_call1(Sexplib0_Sexp_conv[7], cst), 0],
     arg_011 = [1, caml_call2(Base[193], prefix$0, suffix$0)],
     bnds_003$0 = [0, [1, [0, _c_, [0, arg_011, 0]]], bnds_003],
     arg_009 = caml_call1(Base[125], shrink_count_008),
     bnds_003$1 = [0, [1, [0, _d_, [0, arg_009, 0]]], bnds_003$0],
     arg_007 = caml_call1(Base[125], test_count_006),
     bnds_003$2 = [0, [1, [0, _e_, [0, arg_007, 0]]], bnds_003$1],
     arg_005 = caml_call1(Seed[1], seed_004),
     bnds_003$3 = [0, [1, [0, _f_, [0, arg_005, 0]]], bnds_003$2];
    return [1, bnds_003$3];
   }
   var
    _g_ = caml_call5(Base_List[129], 0, [0, 104758188], [0, 104758188], 0, 30),
    _h_ = caml_call1(Base_Sequence[97], _g_),
    _p_ = [0, 0],
    _q_ = [0, "error"],
    _r_ = [0, "input"],
    cst_Base_quickcheck_Test_run_t = "Base_quickcheck.Test.run: test failed",
    _n_ = [0, 0],
    _o_ = [0, 0],
    _l_ = [0, "number_of_size_values"],
    _m_ = [0, cst_test_count],
    cst_Base_quickcheck_Test_run_i =
      "Base_quickcheck.Test.run: insufficient size values for test count",
    _k_ = [0, "an arbitrary but deterministic string"],
    _i_ = 10000,
    _j_ = Base_Word_size[3] ? 10000 : 1000,
    default_config = [0, _k_, _j_, _i_, _h_],
    lazy_nondeterministic_state =
      [246, function(_K_){return caml_call2(Base_Random[18][3], 0, 0);}];
   function with_sample(f, _G_, opt, generator){
    var
     config = _G_ ? _G_[1] : default_config,
     examples = opt ? opt[1] : 0,
     match = config[1];
    if(match)
     var
      string = match[1],
      _A_ = runtime.Base_hash_string(string),
      random = caml_call1(Splittable_random[1][2], _A_);
    else{
     var _B_ = runtime.caml_obj_tag(lazy_nondeterministic_state);
     a:
     if(250 === _B_)
      var _C_ = lazy_nondeterministic_state[1];
     else{
      if(246 !== _B_ && 244 !== _B_){
       var _C_ = lazy_nondeterministic_state;
       break a;
      }
      var _C_ = caml_call1(CamlinternalLazy[2], lazy_nondeterministic_state);
     }
     var random = caml_call1(Splittable_random[1][1], _C_);
    }
    var
     _D_ =
       caml_call2
        (Base_Sequence[42],
         [0, config[4], 0],
         function(param){
          var number_of_size_values = param[2], sizes = param[1];
          if(config[2] <= number_of_size_values) return 0;
          var match = caml_call1(Base_Sequence[39], sizes);
          if(match){
           var
            match$0 = match[1],
            remaining_sizes = match$0[2],
            size = match$0[1];
           return [0,
                   [0,
                    size,
                    [0, remaining_sizes, number_of_size_values + 1 | 0]]];
          }
          var
           _H_ =
             [0,
              [1,
               [0, _l_, [0, caml_call1(Base[125], number_of_size_values), 0]]],
              0],
           _I_ =
             [0, [1, [0, _m_, [0, caml_call1(Base[125], config[2]), 0]]], _H_],
           _J_ =
             [1,
              [0,
               caml_call1
                (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_i),
               _I_]];
          return caml_call1(Base[217], _J_);
         }),
     _E_ =
       caml_call2
        (Base_Sequence[32],
         _D_,
         function(size){
          return caml_call3
                  (Base_quickcheck_Generator[124], generator, size, random);
         }),
     _F_ = caml_call1(Base_Sequence[104], examples),
     sequence = caml_call2(Base_Sequence[63], _F_, _E_);
    return caml_call1(f, sequence);
   }
   function result(f, _z_, opt, m){
    var config = _z_ ? _z_[1] : default_config, examples = opt ? opt[1] : 0;
    return with_sample
            (function(sequence){
              var
               match$2 =
                 caml_call3
                  (Base_Sequence[9],
                   sequence,
                   0,
                   function(param, input){
                    var match = caml_call1(f, input);
                    if(0 === match[0]) return _n_;
                    var error = match[1];
                    return [1, [0, input, error]];
                   });
              if(0 === match$2[0]) return _o_;
              var
               match$3 = match$2[1],
               error$1 = match$3[2],
               input$0 = match$3[1],
               shrinker = m[3],
               shrink_count$1 = config[3],
               alternates$2 =
                 caml_call2(Base_quickcheck_Shrinker[37], shrinker, input$0),
               shrink_count = shrink_count$1,
               alternates = alternates$2,
               input = input$0,
               error = error$1;
              for(;;){
               if(0 !== shrink_count){
                var
                 shrink_count$0 = shrink_count - 1 | 0,
                 match = caml_call1(Base_Sequence[39], alternates);
                if(match){
                 var
                  match$0 = match[1],
                  alternates$0 = match$0[2],
                  alternate = match$0[1],
                  match$1 = caml_call1(f, alternate);
                 if(0 === match$1[0]){
                  shrink_count = shrink_count$0;
                  alternates = alternates$0;
                  continue;
                 }
                 var
                  error$0 = match$1[1],
                  alternates$1 =
                    caml_call2
                     (Base_quickcheck_Shrinker[37], shrinker, alternate);
                 shrink_count = shrink_count$0;
                 alternates = alternates$1;
                 input = alternate;
                 error = error$0;
                 continue;
                }
               }
               return [1, [0, input, error]];
              }
             },
             [0, config],
             [0, examples],
             m[2]);
   }
   function run(f, config, examples, M){
    function f$0(x){
     var _y_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2
             (Base_Or_error[29],
              _y_,
              function(param){return caml_call1(f, x);});
    }
    var match = result(f$0, config, examples, M);
    if(0 === match[0]) return _p_;
    var
     match$0 = match[1],
     error = match$0[2],
     input = match$0[1],
     _v_ = [0, [1, [0, _q_, [0, caml_call1(Base_Error[6], error), 0]]], 0],
     _w_ = [0, [1, [0, _r_, [0, caml_call1(M[1], input), 0]]], _v_],
     _x_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_t),
         _w_]];
    return caml_call1(Base_Or_error[35], _x_);
   }
   function with_sample_exn(f, config, examples, generator){
    function f$0(x){
     return caml_call2
             (Base_Or_error[28], 0, function(param){return caml_call1(f, x);});
    }
    var _u_ = with_sample(f$0, config, examples, generator);
    return caml_call1(Base_Or_error[31], _u_);
   }
   function run_exn(f, config, examples, testable){
    function f$0(x){
     var _t_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2
             (Base_Or_error[28],
              _t_,
              function(param){return caml_call1(f, x);});
    }
    var _s_ = run(f$0, config, examples, testable);
    return caml_call1(Base_Or_error[31], _s_);
   }
   var
    Base_quickcheck_Test =
      [0,
       [0,
        Seed,
        sizes,
        shrink_count,
        test_count,
        seed,
        [0,
         names,
         sizes$0,
         shrink_count$0,
         test_count$0,
         seed$0,
         fold,
         make_creator,
         create,
         map,
         iter,
         for_all,
         exists,
         to_list,
         map_poly,
         Direct],
        sexp_of_t$0],
       default_config,
       run,
       run_exn,
       result,
       with_sample,
       with_sample_exn];
   runtime.caml_register_global
    (38, Base_quickcheck_Test, "Base_quickcheck__Test");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer
//# unitInfo: Requires: Base, Base__Array, Base__Bool, Base__Bytes, Base__Char, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__List, Base__Map, Base__Nativeint, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Generator, Base_quickcheck__Observer0, CamlinternalLazy, Splittable_random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_Hash = global_data.Base__Hash,
    Splittable_random = global_data.Splittable_random,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array = global_data.Base__Array,
    Base = global_data.Base,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int63 = global_data.Base__Int63,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Float = global_data.Base__Float,
    Base_String = global_data.Base__String,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Bytes = global_data.Base__Bytes,
    opaque = Base_quickcheck_Observer0[1],
    create = Base_quickcheck_Observer0[2],
    observe = Base_quickcheck_Observer0[3];
   function unmap(t, f){
    return caml_call1
            (create,
             function(x, size, hash){
              return caml_call4(observe, t, caml_call1(f, x), size, hash);
             });
   }
   function of_hash_fold(f){
    return caml_call1
            (create, function(x, param, hash){return caml_call2(f, hash, x);});
   }
   function of_lazy(lazy_t){
    return caml_call1
            (create,
             function(x, size, hash){
              var _n_ = caml_obj_tag(lazy_t);
              a:
              if(250 === _n_)
               var _o_ = lazy_t[1];
              else{
               if(246 !== _n_ && 244 !== _n_){var _o_ = lazy_t; break a;}
               var _o_ = caml_call1(CamlinternalLazy[2], lazy_t);
              }
              return caml_call4(observe, _o_, x, size, hash);
             });
   }
   function fixed_point(wrap){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(wrap, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   var
    bool = of_hash_fold(Base_Bool[4]),
    char$0 = of_hash_fold(Base_Char[4]),
    int$0 = of_hash_fold(Base_Int[7]),
    int32 = of_hash_fold(Base_Int32[7]),
    int63 = of_hash_fold(Base_Int63[6]),
    int64 = of_hash_fold(Base_Int64[7]),
    nativeint = of_hash_fold(Base_Nativeint[7]),
    float$0 = of_hash_fold(Base_Float[5]),
    string = of_hash_fold(Base_String[40]),
    sexp = of_hash_fold(Base[85][1]),
    bigstring =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[105])),
    float32_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[114])),
    float64_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[114])),
    float32_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[114])),
    float64_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[114])),
    bytes = unmap(string, Base_Bytes[27]),
    _a_ = [0, 0];
   function either(fst_t, snd_t){
    return caml_call1
            (create,
             function(either, size, hash){
              if(0 === either[0]){
               var fst = either[1];
               return caml_call4
                       (observe, fst_t, fst, size, caml_call2(Base[122], hash, 1));
              }
              var snd = either[1];
              return caml_call4
                      (observe, snd_t, snd, size, caml_call2(Base[122], hash, 2));
             });
   }
   function result(ok_t, err_t){
    return unmap
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function both(fst_t, snd_t){
    return caml_call1
            (create,
             function(param, size, hash){
              var
               snd = param[2],
               fst = param[1],
               hash$0 = caml_call4(observe, fst_t, fst, size, hash),
               hash$1 = caml_call4(observe, snd_t, snd, size, hash$0);
              return hash$1;
             });
   }
   function option(value_t){
    return unmap
            (either(opaque, value_t),
             function(param){
              if(! param) return _a_;
              var value = param[1];
              return [1, value];
             });
   }
   function list(elt_t){
    return caml_call1
            (create,
             function(list, size, hash){
              var
               _k_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _k_),
               length = caml_call1(Base_List[17], list),
               _l_ =
                 caml_call3
                  (Base_quickcheck_Generator[53], [0, length], [0, length], 0),
               sizes =
                 caml_call3(Base_quickcheck_Generator[124], _l_, size, random),
               _m_ = caml_call2(Base[122], hash, 0);
              return caml_call4
                      (Base_List[69],
                       list,
                       sizes,
                       _m_,
                       function(hash, elt, size){
                        return caml_call4
                                (observe, elt_t, elt, size, caml_call2(Base[122], hash, 1));
                       });
             });
   }
   function array(t){var _j_ = Base_Array[29]; return unmap(list(t), _j_);}
   function ref(t){return unmap(t, function(_i_){return _i_[1];});}
   function lazy_t(t){
    return unmap
            (t,
             function(_g_){
              var _h_ = caml_obj_tag(_g_);
              if(250 === _h_) return _g_[1];
              if(246 !== _h_ && 244 !== _h_) return _g_;
              return caml_call1(CamlinternalLazy[2], _g_);
             });
   }
   function fn(dom, rng){
    return caml_call1
            (create,
             function(f, size, hash){
              var
               _e_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _e_),
               _f_ = caml_call3(Base_quickcheck_Generator[53], 0, 0, 0),
               sizes =
                 caml_call3
                  (Base_quickcheck_Generator[124], _f_, size * 2 | 0, random);
              return caml_call3
                      (Base_List[20],
                       sizes,
                       hash,
                       function(hash, size){
                        var
                         x =
                           caml_call3
                            (Base_quickcheck_Generator[124], dom, size, random);
                        return caml_call4
                                (observe, rng, caml_call1(f, x), size, hash);
                       });
             });
   }
   function map_tree(key_obs, data_obs){
    var arg = Base_Map[112][3][71];
    return unmap
            (list(both(key_obs, data_obs)),
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function set_tree(elt_obs){
    var _d_ = Base_Set[76][3][14];
    return unmap(list(elt_obs), _d_);
   }
   function map_t(key_obs, data_obs){
    var _c_ = Base_Map[112][98];
    return unmap(map_tree(key_obs, data_obs), _c_);
   }
   function set_t(elt_obs){
    var _b_ = Base_Set[76][49];
    return unmap(set_tree(elt_obs), _b_);
   }
   var
    Base_quickcheck_Observer =
      [0,
       opaque,
       opaque,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t,
       set_t,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point,
       of_lazy,
       create,
       observe];
   runtime.caml_register_global
    (22, Base_quickcheck_Observer, "Base_quickcheck__Observer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Export
//# unitInfo: Requires: Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    quickcheck_generator_unit = Base_quickcheck_Generator[1],
    quickcheck_generator_bool = Base_quickcheck_Generator[2],
    quickcheck_generator_char = Base_quickcheck_Generator[3],
    quickcheck_generator_string = Base_quickcheck_Generator[4],
    quickcheck_generator_bytes = Base_quickcheck_Generator[5],
    quickcheck_generator_int = Base_quickcheck_Generator[6],
    quickcheck_generator_int32 = Base_quickcheck_Generator[7],
    quickcheck_generator_int64 = Base_quickcheck_Generator[9],
    quickcheck_generator_nativeint = Base_quickcheck_Generator[10],
    quickcheck_generator_float = Base_quickcheck_Generator[11],
    quickcheck_generator_option = Base_quickcheck_Generator[13],
    quickcheck_generator_list = Base_quickcheck_Generator[14],
    quickcheck_generator_array = Base_quickcheck_Generator[15],
    quickcheck_generator_ref = Base_quickcheck_Generator[16],
    quickcheck_generator_lazy_t = Base_quickcheck_Generator[17],
    quickcheck_observer_unit = Base_quickcheck_Observer[2],
    quickcheck_observer_bool = Base_quickcheck_Observer[3],
    quickcheck_observer_char = Base_quickcheck_Observer[4],
    quickcheck_observer_string = Base_quickcheck_Observer[5],
    quickcheck_observer_bytes = Base_quickcheck_Observer[6],
    quickcheck_observer_int = Base_quickcheck_Observer[7],
    quickcheck_observer_int32 = Base_quickcheck_Observer[8],
    quickcheck_observer_int64 = Base_quickcheck_Observer[10],
    quickcheck_observer_nativeint = Base_quickcheck_Observer[11],
    quickcheck_observer_float = Base_quickcheck_Observer[12],
    quickcheck_observer_option = Base_quickcheck_Observer[14],
    quickcheck_observer_list = Base_quickcheck_Observer[15],
    quickcheck_observer_array = Base_quickcheck_Observer[16],
    quickcheck_observer_ref = Base_quickcheck_Observer[17],
    quickcheck_observer_lazy_t = Base_quickcheck_Observer[18],
    quickcheck_shrinker_unit = Base_quickcheck_Shrinker[2],
    quickcheck_shrinker_bool = Base_quickcheck_Shrinker[3],
    quickcheck_shrinker_char = Base_quickcheck_Shrinker[4],
    quickcheck_shrinker_string = Base_quickcheck_Shrinker[5],
    quickcheck_shrinker_bytes = Base_quickcheck_Shrinker[6],
    quickcheck_shrinker_int = Base_quickcheck_Shrinker[7],
    quickcheck_shrinker_int32 = Base_quickcheck_Shrinker[8],
    quickcheck_shrinker_int64 = Base_quickcheck_Shrinker[10],
    quickcheck_shrinker_nativeint = Base_quickcheck_Shrinker[11],
    quickcheck_shrinker_float = Base_quickcheck_Shrinker[12],
    quickcheck_shrinker_option = Base_quickcheck_Shrinker[14],
    quickcheck_shrinker_list = Base_quickcheck_Shrinker[15],
    quickcheck_shrinker_array = Base_quickcheck_Shrinker[16],
    quickcheck_shrinker_ref = Base_quickcheck_Shrinker[17],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Shrinker[18],
    Base_quickcheck_Export =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
   runtime.caml_register_global
    (3, Base_quickcheck_Export, "Base_quickcheck__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck
//# unitInfo: Requires: Base_quickcheck__Export
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Export = global_data.Base_quickcheck__Export,
    quickcheck_generator_unit = Base_quickcheck_Export[1],
    quickcheck_generator_bool = Base_quickcheck_Export[2],
    quickcheck_generator_char = Base_quickcheck_Export[3],
    quickcheck_generator_string = Base_quickcheck_Export[4],
    quickcheck_generator_bytes = Base_quickcheck_Export[5],
    quickcheck_generator_int = Base_quickcheck_Export[6],
    quickcheck_generator_int32 = Base_quickcheck_Export[7],
    quickcheck_generator_int64 = Base_quickcheck_Export[8],
    quickcheck_generator_nativeint = Base_quickcheck_Export[9],
    quickcheck_generator_float = Base_quickcheck_Export[10],
    quickcheck_observer_unit = Base_quickcheck_Export[11],
    quickcheck_observer_bool = Base_quickcheck_Export[12],
    quickcheck_observer_char = Base_quickcheck_Export[13],
    quickcheck_observer_string = Base_quickcheck_Export[14],
    quickcheck_observer_bytes = Base_quickcheck_Export[15],
    quickcheck_observer_int = Base_quickcheck_Export[16],
    quickcheck_observer_int32 = Base_quickcheck_Export[17],
    quickcheck_observer_int64 = Base_quickcheck_Export[18],
    quickcheck_observer_nativeint = Base_quickcheck_Export[19],
    quickcheck_observer_float = Base_quickcheck_Export[20],
    quickcheck_shrinker_unit = Base_quickcheck_Export[21],
    quickcheck_shrinker_bool = Base_quickcheck_Export[22],
    quickcheck_shrinker_char = Base_quickcheck_Export[23],
    quickcheck_shrinker_string = Base_quickcheck_Export[24],
    quickcheck_shrinker_bytes = Base_quickcheck_Export[25],
    quickcheck_shrinker_int = Base_quickcheck_Export[26],
    quickcheck_shrinker_int32 = Base_quickcheck_Export[27],
    quickcheck_shrinker_int64 = Base_quickcheck_Export[28],
    quickcheck_shrinker_nativeint = Base_quickcheck_Export[29],
    quickcheck_shrinker_float = Base_quickcheck_Export[30],
    quickcheck_generator_option = Base_quickcheck_Export[31],
    quickcheck_generator_list = Base_quickcheck_Export[32],
    quickcheck_generator_array = Base_quickcheck_Export[33],
    quickcheck_generator_ref = Base_quickcheck_Export[34],
    quickcheck_generator_lazy_t = Base_quickcheck_Export[35],
    quickcheck_observer_option = Base_quickcheck_Export[36],
    quickcheck_observer_list = Base_quickcheck_Export[37],
    quickcheck_observer_array = Base_quickcheck_Export[38],
    quickcheck_observer_ref = Base_quickcheck_Export[39],
    quickcheck_observer_lazy_t = Base_quickcheck_Export[40],
    quickcheck_shrinker_option = Base_quickcheck_Export[41],
    quickcheck_shrinker_list = Base_quickcheck_Export[42],
    quickcheck_shrinker_array = Base_quickcheck_Export[43],
    quickcheck_shrinker_ref = Base_quickcheck_Export[44],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Export[45],
    Private = [0],
    Base_quickcheck =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
   runtime.caml_register_global(1, Base_quickcheck, "Base_quickcheck");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfcXVpY2tjaGVjayJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsa0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfcXVpY2tjaGVja19XaXRoX2Jhc2ljX3R5cCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2JhX2RpbV8xIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfYmFfZ2V0XzEiLCJjYW1sX2JhX2dldF8yIiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJCYXNlIiwiQmFzZV9BcnJheSIsIlN0ZGxpYl9CaWdhcnJheSIsIm9mZnNldCIsInBhcmFtIiwiTGF5b3V0IiwiaXRlcmkiLCJ0IiwiaSIsImluaXQiLCJraW5kIiwibGF5b3V0IiwiZGltIiwiZm9sZCIsInRvX2FycmF5Iiwic2V4cF9vZl90Iiwic2V4cF9vZl9lbHQiLCJzZXhwX29mX3BhY2siLCJzZXhwX29mX2xheW91dCIsInhfMDAxIiwiaGFzaF9mb2xkIiwiaGFzaF9mb2xkX2VsdCIsInN0YXRlIiwiaiIsImRpbTEiLCJkaW0yIiwiZWx0IiwieF8wMDIiLCJCYXNlX3F1aWNrY2hlY2tfQmlnYXJyYXlfaGVscGUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZV9xdWlja2NoZWNrL2JpZ2FycmF5X2hlbHBlcnMubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsWUFBQUMsT0FBQUMsT0NLTSxvQkFFc0I7QUFBQSxPQUFBQyxTRFA1QjtBQUFBLFlBQUFDLE1BQUFDLEdBQUFoQjtBQUFBQTtBQUFBQSxLQUFBLE1DZStCO0FBQUEsS0FBQVksU0FBZDtBQUFBLFdBQ0E7QUFBQSxXQUFxQjtBQUFBO0FBQUEsU0FBQUssSUFBQTtBQUFBO0FBQUEsTUFDaEMsOEJBQWU7QUFBQSxnQkFBYztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFERztBQUFBLEdBRTlCO0FBQUEsWUFBQUMsS0FBQUMsTUFBQUMsUUFBQUMsS0FBQXJCO0FBQUFBLFFBQUFnQixJQUlJO0FBQUEsSUFDUjtBQUFBO0FBQUEsZUFBQUMsR0FBQUo7QUFBQUEsT0FBd0MsT0FBVCw0QkFBUyxpQkFBRztBQUFBO0FBQUEsSUFBQztBQUFBLEdBQzNDO0FBQUEsWUFBQVMsS0FBQU4sR0FBQUUsTUFBQWxCO0FBQUFBLFFBQUFrQixTQUlEO0FBQUEsSUFDQTtBQUFBO0FBQUEsZUFBQUQsR0FBQUo7QUFBQUEsV0FBQSxNQUErQztBQUFBLE9BQVI7QUFBQSxPQUFhO0FBQUE7QUFBQSxJQUFDO0FBQUEsR0FDaEQ7QUFBQSxZQUFBVSxTQUFBUDtBQUFBQTtBQUFBQSxLQUFBLE1BSXNCO0FBQUEsS0FBQUosU0FBZDtBQUFBLFdBQ0Y7QUFBQSxJQUF1QjtBQUFBO0FBQUE7QUFBQSxzQkFBQUssR0FBYyx1Q0FBYyxHQUFDO0FBQUE7QUFBQSxZQUFBTyxVQUFBQyxhQUFBQyxjQUFBQyxnQkFBQVg7QUFBQUEsUUFBQVksUUFJdkQ7QUFBQSxJQUFhLCtDQUFVO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxlQUFBQyxPQUFBZjtBQUFBQSxRQUFBLE1BSUMsa0JBQUFlLFVBQXBCO0FBQUEsSUFDWixzQ0FBbUM7QUFBQTtBQUFBLFlBQUFoQixRQUFBQyxHQUFBaEI7QUFBQUE7QUFBQUEsS0FBQSxNQVFSO0FBQUEsS0FBQVksU0FBZDtBQUFBLFdBQ0E7QUFBQSxXQUFzQjtBQUFBO0FBQUEsU0FBQUssSUFBQTtBQUFBO0FBQUEsZ0JBQ3BCLGdDQUFzQjtBQUFBO0FBQUEsV0FBQWUsSUFBQTtBQUFBO0FBQUEsUUFDakM7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUE0QjtBQUFBLGtCQUEwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBRHJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQURGO0FBQUEsR0FJL0I7QUFBQSxZQUFBZCxPQUFBQyxNQUFBQyxRQUFBYSxNQUFBQyxNQUFBbEM7QUFBQUEsUUFBQWdCLElBSUk7QUFBQSxJQUNSO0FBQUE7QUFBQSxlQUFBQyxHQUFBZSxHQUFBbkI7QUFBQUEsT0FBNkMsT0FBWiwrQkFBWSxvQkFBSztBQUFBO0FBQUEsSUFBQztBQUFBLEdBQ2xEO0FBQUEsWUFBQVMsT0FBQU4sR0FBQUUsTUFBQWxCO0FBQUFBLFFBQUFrQixTQUlEO0FBQUEsSUFDQTtBQUFBO0FBQUEsb0JBQUFMLE9BQUFzQjtBQUFBQSxPQUFtRDtBQUFBLE9BQVc7QUFBQTtBQUFBLElBQUM7QUFBQSxHQUMxRDtBQUFBLFlBQUFaLFdBQUFQO0FBQUFBO0FBQUFBLEtBQUEsTUFJc0I7QUFBQSxLQUFBSixTQUFkO0FBQUEsV0FDRjtBQUFBLElBQXdCO0FBQUE7QUFBQTtBQUFBLHNCQUFBSztBQUFBQSxrQkFBQSxNQUN0QjtBQUFBLGNBQXdCO0FBQUE7QUFBQTtBQUFBLGdDQUFBZTtBQUFBQSx3QkFBYyx1REFBMEI7QUFBQSx5QkFBQztBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFSLFlBQUFDLGFBQUFDLGNBQUFDLGdCQUFBWDtBQUFBQSxRQUFBb0IsUUFJdkUscUJBQWE7QUFBQSxJQUFlLHVDQUFDO0FBQUE7QUFBQSxZQUFBUCxZQUFBQyxlQUFBQyxPQUFBZjtBQUFBQTtBQUFBQSxLQUFBLE1BSUw7QUFBQSxLQUFBZSxVQUFwQjtBQUFBLFdBQ29CO0FBQUEsS0FBQUEsVUFBcEI7QUFBQSxJQUNaLHdDQUFtQztBQUFBO0FBQUE7QUFBQSxJQUFBTTtBQUFBQSxNRHJGdkMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEJhc2VcblxubW9kdWxlIExheW91dCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBCaWdhcnJheS5sYXlvdXRcblxuICBsZXQgb2Zmc2V0IDogdHlwZSBhLiBhIHQgLT4gaW50ID0gZnVuY3Rpb25cbiAgICB8IEJpZ2FycmF5LkZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICB8IEJpZ2FycmF5LkNfbGF5b3V0IC0+IDBcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgQmlnYXJyYXkuQXJyYXkxLnRcblxuICBsZXQgaXRlcmkgdCB+ZiA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBmb3IgaSA9IDAgdG8gQmlnYXJyYXkuQXJyYXkxLmRpbSB0IC0gMSBkb1xuICAgICAgZiAoaSArIG9mZnNldCkgdC57aSArIG9mZnNldH1cbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGluaXQgKHR5cGUgZWx0KSAoa2luZCA6IChlbHQsIF8pIEJpZ2FycmF5LmtpbmQpIGxheW91dCBkaW0gfmYgPVxuICAgIGxldCB0ID0gQmlnYXJyYXkuQXJyYXkxLmNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSAoXyA6IGVsdCkgLT4gdC57aX0gPC0gZiBpKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgKF8gOiBlbHQpIC0+IGluaXQgOj0gZiAhaW5pdCB0LntpfSk7XG4gICAgIWluaXRcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTEuZGltIHQpIH5mOihmdW4gaSAtPiB0LntpICsgb2Zmc2V0fSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IF9zZXhwX29mX3BhY2sgX3NleHBfb2ZfbGF5b3V0IHQgPVxuICAgIFslc2V4cCAodG9fYXJyYXkgdCA6IGVsdCBhcnJheSldXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZCBoYXNoX2ZvbGRfZWx0IHN0YXRlIHQgPVxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5MS5kaW0gdCkgaW5cbiAgICBmb2xkIHQgfmluaXQ6c3RhdGUgfmY6aGFzaF9mb2xkX2VsdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBCaWdhcnJheS5BcnJheTIudFxuXG4gIGxldCBpdGVyaSB0IH5mID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkyLmxheW91dCB0KSBpblxuICAgIGZvciBpID0gMCB0byBCaWdhcnJheS5BcnJheTIuZGltMSB0IC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIEJpZ2FycmF5LkFycmF5Mi5kaW0yIHQgLSAxIGRvXG4gICAgICAgIGYgKGkgKyBvZmZzZXQpIChqICsgb2Zmc2V0KSB0LntpICsgb2Zmc2V0LCBqICsgb2Zmc2V0fVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgaW5pdCAodHlwZSBlbHQpIChraW5kIDogKGVsdCwgXykgQmlnYXJyYXkua2luZCkgbGF5b3V0IGRpbTEgZGltMiB+ZiA9XG4gICAgbGV0IHQgPSBCaWdhcnJheS5BcnJheTIuY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIGogKF8gOiBlbHQpIC0+IHQue2ksIGp9IDwtIGYgaSBqKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIChfIDogaW50KSAoXyA6IGludCkgZWx0IC0+IGluaXQgOj0gZiAhaW5pdCBlbHQpO1xuICAgICFpbml0XG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTIubGF5b3V0IHQpIGluXG4gICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgfmY6KGZ1biBpIC0+XG4gICAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTIuZGltMiB0KSB+ZjooZnVuIGogLT4gdC57aSArIG9mZnNldCwgaiArIG9mZnNldH0pKVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgX3NleHBfb2ZfcGFjayBfc2V4cF9vZl9sYXlvdXQgdCA9XG4gICAgWyVzZXhwICh0b19hcnJheSB0IDogZWx0IGFycmF5IGFycmF5KV1cbiAgOztcblxuICBsZXQgaGFzaF9mb2xkIGhhc2hfZm9sZF9lbHQgc3RhdGUgdCA9XG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgaW5cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTIuZGltMiB0KSBpblxuICAgIGZvbGQgdCB+aW5pdDpzdGF0ZSB+ZjpoYXNoX2ZvbGRfZWx0XG4gIDs7XG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMyIsImExIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2UiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJjc3RfQmFzZV9xdWlja2NoZWNrX09ic2VydmVyX28iLCJjcmVhdGUiLCJvYnNlcnZlIiwidCIsIngiLCJzaXplIiwiaGFzaCIsIm9wYXF1ZSIsInBhcmFtIiwiQmFzZV9xdWlja2NoZWNrX09ic2VydmVyMCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlX3F1aWNrY2hlY2svb2JzZXJ2ZXIwLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsT0FBQVQsR0NJcUIsU0FBQztBQUFBLFlBQUFVLFFBQUFDLEdBQUFDLEdBQUFDLE1BQUFDO0FBQUFBLElBR3BCLGNBRUssbUNBQWU7QUFBQTtBQUFBLFdBRGdEO0FBQUE7QUFBQSxPQUE3QztBQUFBO0FBQUE7QUFBQTtBQUFBLElBQTRDLGlDQUMvQztBQUFBO0FBQUEsWUFBQUMsT0FBQSxLQUFBQyxPQUFBRixNQUdPLFlBQUk7QUFBQSxPQUFBRyw0QkRaakMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEJhc2VcblxudHlwZSAnYSB0ID0gJ2EgLT4gc2l6ZTppbnQgLT4gaGFzaDpIYXNoLnN0YXRlIC0+IEhhc2guc3RhdGVcblxubGV0IGNyZWF0ZSBmIDogXyB0ID0gZlxuXG5sZXQgb2JzZXJ2ZSAodCA6IF8gdCkgeCB+c2l6ZSB+aGFzaCA9XG4gIGlmIHNpemUgPCAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suT2JzZXJ2ZXIub2JzZXJ2ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gIGVsc2UgdCB4IH5zaXplIH5oYXNoXG47O1xuXG5sZXQgb3BhcXVlIF8gfnNpemU6XyB+aGFzaCA9IGhhc2hcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfbG93ZXJfYm91bmQiLCJjc3Rfc3JjX2dlbmVyYXRvcl9tbCIsImNzdF91cHBlcl9ib3VuZCIsImNzdF93ZWlnaHQiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9kaXYiLCJjYW1sX2VxdWFsIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfbXVsIiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfb2JqX3RhZyIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiY2FtbF9jYWxsNiIsImE1IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX01hcCIsIkJhc2VfU2VxdWVuY2UiLCJCYXNlX0FycmF5IiwiQmFzZV9xdWlja2NoZWNrX0JpZ2FycmF5X2hlbHBlIiwiQmFzZV9TZXQiLCJCYXNlX0xpc3QiLCJCYXNlX1N0cmluZyIsIkJhc2VfRmxvYXQiLCJTcGxpdHRhYmxlX3JhbmRvbSIsIkJhc2UiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJCYXNlX0ludDYzIiwiU3RkbGliIiwiQmFzZV9DaGFyIiwiQmFzZV9MYXp5IiwiQmFzZV9JbnQiLCJCYXNlX0VpdGhlciIsIkJhc2VfT3B0aW9uIiwiQXNzZXJ0X2ZhaWx1cmUiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9FcnJvciIsIkJhc2VfSGFzaCIsIkJhc2VfcXVpY2tjaGVja19PYnNlcnZlcjAiLCJCYXNlX1N0YWdlZCIsIkJhc2VfQXBwbGljYXRpdmUiLCJCYXNlX01vbmFkIiwiQmFzZV9JbnQzMiIsIkJhc2VfSW50NjQiLCJCYXNlX05hdGl2ZWludCIsIkJhc2VfQnl0ZXMiLCJjc3RfQmFzZV9xdWlja2NoZWNrX0dlbmVyYXRvcl8iLCJjcmVhdGUiLCJnZW5lcmF0ZSIsInQiLCJzaXplIiwicmFuZG9tIiwicGFyYW0iLCJmbiIsImRvbSIsInJuZyIsIngiLCJoYXNoIiwid2l0aF9zaXplIiwicGVydHVyYiIsInNhbHQiLCJmaWx0ZXJfbWFwIiwibG9vcCIsIm1hdGNoIiwieSIsImZpbHRlciIsInJldHVybiIsIm1hcCIsImFwcGx5IiwidGYiLCJ0eCIsImJpbmQiLCJhbGwiLCJsaXN0IiwiYWxsX3VuaXQiLCJGb3JfYXBwbGljYXRpdmUiLCJib3RoIiwibWFwMiIsIm1hcDMiLCJpbmNsdWRlIiwic3ltYm9sIiwiRm9yX21vbmFkIiwiaWdub3JlX20iLCJqb2luIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwib2ZfbGlzdCIsImFycmF5IiwiaGkiLCJsbyIsImluZGV4IiwidW5pb24iLCJvZl93ZWlnaHRlZF9saXN0IiwiYWxpc3QiLCJ2YWx1ZXMiLCJ3ZWlnaHRzIiwidmFsdWVfYXJyYXkiLCJzdW0iLCJhY2MiLCJ3ZWlnaHQiLCJjdW11bGF0aXZlIiwiY2hvaWNlIiwid2VpZ2h0ZWRfdW5pb24iLCJvZl9sYXp5IiwibGF6eV90IiwiZml4ZWRfcG9pbnQiLCJvZl9nZW5lcmF0b3IiLCJ3ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb24iLCJub25yZWNfbGlzdCIsInNlbGYiLCJyZWNfbGlzdCIsInciLCJuIiwibm9ucmVjX2dlbiIsInJlY19nZW4iLCJyZWN1cnNpdmVfdW5pb24iLCJ3ZWlnaHRlZCIsInNpemVzIiwib3B0IiwibWluX2xlbmd0aCIsIm1heF9sZW5ndGgiLCJ1cHBlcl9ib3VuZCIsImxlbiIsInJlbWFpbmluZyIsIm1heF9pbmRleCIsImZvciIsImkiLCJqIiwidW5pdCIsImJvb2wiLCJvcHRpb24iLCJ2YWx1ZV90IiwiZWl0aGVyIiwiZnN0X3QiLCJzbmRfdCIsInJlc3VsdCIsIm9rX3QiLCJlcnJfdCIsIm9rIiwiZXJyIiwibGlzdF9nZW5lcmljIiwiZWx0X2dlbiIsImxpc3Rfbm9uX2VtcHR5IiwibGlzdF93aXRoX2xlbmd0aCIsImxlbmd0aCIsImxpc3RfZmlsdGVyZWQiLCJlbHRzIiwibGVuZ3RoX29mX2lucHV0IiwibGVuZ3RoX29mX291dHB1dCIsImluZGljZXMiLCJsaXN0X3Blcm11dGF0aW9ucyIsInJlZiIsImNoYXJfdW5pZm9ybV9pbmNsdXNpdmUiLCJjaGFyX3VwcGVyY2FzZSIsImNoYXJfbG93ZXJjYXNlIiwiY2hhcl9kaWdpdCIsImNoYXJfcHJpbnRfdW5pZm9ybSIsImNoYXJfdW5pZm9ybSIsImNoYXJfYWxwaGEiLCJjaGFyX2FscGhhbnVtIiwiY2hhcl93aGl0ZXNwYWNlIiwiY2hhcl9wcmludCIsImNoYXIiLCJzbWFsbF9pbnQiLCJhbGxvd196ZXJvIiwibG93ZXJfYm91bmQiLCJ3ZWlnaHRlZF9sb3ciLCJ3ZWlnaHRlZF9oaWdoIiwic21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQiLCJzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQiLCJjc3RfZ2VvbWV0cmljX2Rpc3RyaWJ1dGlvbl9wX20iLCJkdW1teSIsIkZvcl9pbnRlZ2VyIiwiSW50ZWdlciIsImdlb21ldHJpYyIsInAiLCJkZW5vbWluYXRvciIsInVuaWZvcm0iLCJleHBvbmVudGlhbCIsImZsb2F0IiwiaW50IiwidW5pZm9ybV9pbmNsdXNpdmUiLCJsb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJub25fdW5pZm9ybSIsImluY2x1c2l2ZSIsImxvZ19pbmNsdXNpdmUiLCJ1bmlmb3JtX2FsbCIsImxldF9zeW50YXhfMDA0IiwibWFnbml0dWRlIiwibmVnYXRpdmUiLCJ0X3NleHBfZ3JhbW1hciIsIm9mX2Zsb2F0IiwidG9fZmxvYXQiLCJvZl9pbnRfZXhuIiwidG9faW50X2V4biIsImhhc2hfZm9sZF90IiwidF9vZl9zZXhwIiwic2V4cF9vZl90Iiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwiZXF1YWwiLCJjb21wYXJlIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNvbXBhcmF0b3IiLCJwcCIsImhhc2hhYmxlIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24iLCJpbnZhcmlhbnQiLCJIZXgiLCJvZl9zdHJpbmdfb3B0IiwidG9fc3RyaW5nX2h1bSIsIm9uZSIsIm1pbnVzX29uZSIsInJlbSIsInJvdW5kIiwicm91bmRfdG93YXJkc196ZXJvIiwicm91bmRfZG93biIsInJvdW5kX3VwIiwicm91bmRfbmVhcmVzdCIsInN1Y2MiLCJwcmVkIiwicG93IiwiYml0X2FuZCIsImJpdF9vciIsImJpdF94b3IiLCJiaXRfbm90IiwicG9wY291bnQiLCJzaGlmdF9sZWZ0Iiwic2hpZnRfcmlnaHQiLCJkZWNyIiwiaW5jciIsIm9mX2ludDMyX2V4biIsInRvX2ludDMyX2V4biIsIm9mX2ludDY0X2V4biIsInRvX2ludDY0Iiwib2ZfbmF0aXZlaW50X2V4biIsInRvX25hdGl2ZWludF9leG4iLCJvZl9mbG9hdF91bmNoZWNrZWQiLCJudW1fYml0cyIsIm1heF92YWx1ZSIsIm1pbl92YWx1ZSIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJjZWlsX3BvdzIiLCJmbG9vcl9wb3cyIiwiY2VpbF9sb2cyIiwiZmxvb3JfbG9nMiIsImlzX3BvdzIiLCJjbHoiLCJjdHoiLCJPIiwibG5vdCIsImFicyIsInplcm8iLCJsb2dfdW5pZm9ybSIsIkZvcl9pbnQiLCJpbnRfdW5pZm9ybSIsImludF9pbmNsdXNpdmUiLCJpbnRfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnRfbG9nX2luY2x1c2l2ZSIsImludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnRfZ2VvbWV0cmljIiwibmVnIiwibGFuZCIsImxvciIsImx4b3IiLCJsc2wiLCJhc3IiLCJsc3IiLCJGb3JfaW50MzIiLCJpbnQzMiIsImludDMyX3VuaWZvcm0iLCJpbnQzMl9pbmNsdXNpdmUiLCJpbnQzMl91bmlmb3JtX2luY2x1c2l2ZSIsImludDMyX2xvZ19pbmNsdXNpdmUiLCJpbnQzMl9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnQzMl9nZW9tZXRyaWMiLCJGb3JfaW50NjMiLCJpbnQ2MyIsImludDYzX3VuaWZvcm0iLCJpbnQ2M19pbmNsdXNpdmUiLCJpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2xvZ19pbmNsdXNpdmUiLCJpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnQ2M19nZW9tZXRyaWMiLCJGb3JfaW50NjQiLCJpbnQ2NCIsImludDY0X3VuaWZvcm0iLCJpbnQ2NF9pbmNsdXNpdmUiLCJpbnQ2NF91bmlmb3JtX2luY2x1c2l2ZSIsImludDY0X2xvZ19pbmNsdXNpdmUiLCJpbnQ2NF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnQ2NF9nZW9tZXRyaWMiLCJGb3JfbmF0aXZlaW50IiwibmF0aXZlaW50IiwibmF0aXZlaW50X3VuaWZvcm0iLCJuYXRpdmVpbnRfaW5jbHVzaXZlIiwibmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlIiwibmF0aXZlaW50X2xvZ19pbmNsdXNpdmUiLCJuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXYiLCJuYXRpdmVpbnRfZ2VvbWV0cmljIiwiZmxvYXRfemVyb19leHBvbmVudCIsImZsb2F0X3plcm9fbWFudGlzc2EiLCJmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3YiLCJmbG9hdF9zdWJub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9taW5fc3Vibm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfbWF4X3N1Ym5vcm1hbF9tYW50aXNzYSIsImZsb2F0X21heF9wb3NpdGl2ZV9ub3JtYWxfdmFsdSIsImZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50IiwiZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYSIsImZsb2F0X2luZl9leHBvbmVudCIsImZsb2F0X2luZl9tYW50aXNzYSIsImZsb2F0X25hbl9leHBvbmVudCIsImZsb2F0X21pbl9uYW5fbWFudGlzc2EiLCJmbG9hdF9ub3JtYWxfbWFudGlzc2EiLCJiaXRzIiwib2Zmc2V0IiwiZmxvYXRfZXhwb25lbnQiLCJmbG9hdF96ZXJvIiwibGV0X3N5bnRheF8wMTIiLCJsZXRfc3ludGF4XzAxMyIsImZsb2F0X3N1Ym5vcm1hbCIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJmbG9hdF9ub3JtYWwiLCJmbG9hdF9pbmZpbml0ZSIsImxldF9zeW50YXhfMDIxIiwibGV0X3N5bnRheF8wMjIiLCJmbG9hdF9uYW4iLCJmbG9hdF9vZl9jbGFzcyIsImMiLCJmbG9hdF9tYXRjaGluZ19jbGFzc2VzIiwiZmxvYXRfZmluaXRlIiwiZmxvYXRfd2l0aG91dF9uYW4iLCJmbG9hdF9maW5pdGVfbm9uX3plcm8iLCJmbG9hdF9zdHJpY3RseV9wb3NpdGl2ZSIsImZsb2F0X3N0cmljdGx5X25lZ2F0aXZlIiwiZmxvYXRfcG9zaXRpdmVfb3JfemVybyIsImZsb2F0X25lZ2F0aXZlX29yX3plcm8iLCJjc3RfRmxvYXRfdW5pZm9ybV9leGNsdXNpdmVfYm8iLCJjc3RfRmxvYXRfdW5pZm9ybV9leGNsdXNpdmVfcmUiLCJmbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZSIsImxvd2VyX2luY2x1c2l2ZSIsInVwcGVyX2luY2x1c2l2ZSIsImZsb2F0X2luY2x1c2l2ZSIsInN0cmluZ193aXRoX2xlbmd0aF9vZiIsImNoYXJfZ2VuIiwic3RyaW5nX29mIiwic3RyaW5nX25vbl9lbXB0eV9vZiIsInN0cmluZyIsInN0cmluZ19ub25fZW1wdHkiLCJzdHJpbmdfd2l0aF9sZW5ndGgiLCJlZGl0X2luc2VydCIsInBvcyIsInN0ciIsImVkaXQiLCJuX3RpbWVzIiwic3RyaW5nX2xpa2UiLCJieXRlcyIsInNleHBfb2YiLCJhdG9tIiwic2V4cCIsIm1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IiLCJrZXlfZ2VuIiwiZGF0YV9nZW4iLCJrZXlzIiwiZGF0YSIsInNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IiLCJtYXBfdF9tIiwibSIsInNldF90X20iLCJiaWdhcnJheTEiLCJraW5kIiwibGF5b3V0IiwiZGltIiwiYmlnc3RyaW5nIiwiZmxvYXQzMl92ZWMiLCJmbG9hdDY0X3ZlYyIsImJpZ2FycmF5Ml9kaW0iLCJtYXhfdG90YWxfc2l6ZSIsImEiLCJtYXhfYiIsImJfd2VpZ2h0ZWRfbG93IiwiYiIsImJpZ2FycmF5MiIsImRpbTIiLCJkaW0xIiwiZmxvYXQzMl9tYXQiLCJmbG9hdDY0X21hdCIsImNvdmVyYWdlIiwiQ21wIiwic2FtcGxlIiwiY291bnRzIiwidmFsdWUiLCJwcmV2IiwibW9uaXRvciIsIkRlYnVnIiwiQmFzZV9xdWlja2NoZWNrX0dlbmVyYXRvciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlX3F1aWNrY2hlY2svZ2VuZXJhdG9yLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVYsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsT0FBQTVDLEdDVXVCLG9DQUFjO0FBQUEsWUFBQTZDLFNBQUFDLEdBQUFDLE1BQUFDO0FBQUFBLElBR2pDLGNBRUssa0RBQThCO0FBQUE7QUFBQSxZQURtQztBQUFBO0FBQUEsT0FBL0M7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUE4QyxrQ0FDbEM7QUFBQTtBQUFBLE9BQUFELE9BTTVCLGdCQUFBQSxNQUFBRSxPQUErQixZQUFJO0FBQUEsWUFBQUMsR0FBQUMsS0FBQUM7QUFBQUEsSUFHNUM7QUFBQSxzQkFBQUwsTUFBQUM7QUFBQUEsa0JBQUFBLFdBQ2U7QUFBQSxjQUNiLGdCQUFBSztBQUFBQTtBQUFBQSxnQkFBQSxPQUNpRDtBQUFBLGdCQUFBQztBQUFBQSxrQkFBcEM7QUFBQSxnQkFBQU4sU0FDRTtBQUFBLHVCQUMwQjtBQUFBLGVBQXZDO0FBQUEsZUFBaUUsa0NBQ3ZDLEVBSjVCO0FBQUEsYUFJNEIsRUFBQztBQUFBO0FBQUEsWUFBQU8sVUFBQVQsR0FBQUM7QUFBQUEsSUFHVCx1QkFBQUUsT0FBQUQsUUFBK0IsZ0NBQXdCLEdBQUM7QUFBQTtBQUFBLFlBQUFRLFFBQUFWLEdBQUFXO0FBQUFBLElBRzlFO0FBQUEsc0JBQUFWLE1BQUFDO0FBQUFBLGNBQ0U7QUFBQSxjQUEyQyxnQ0FDbkI7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBVSxXQUFBWixHQUFBOUM7QUFBQUEsYUFBQTJELEtBQUFaLE1BQUFDO0FBQUFBLFNBQUFELFNBS2pCO0FBQUE7QUFBQSxVQUFBTSxJQUFBLDZCQUFBTyxRQUNGO0FBQUEsTUFBRyxjQUFBQyxJQUFBLFVBQ0c7QUFBQSxVQUFBZCxTQUNGO0FBQUE7QUFBQTtBQUFBLElBQTZCO0FBQUEsSUFFekMsbUJBQVc7QUFBQTtBQUFBLFlBQUFlLE9BQUFoQixHQUFBOUM7QUFBQUEsSUFHSyw4QkFBQXFELEdBQTZCLG9DQUF5QixHQUFDO0FBQUE7QUFBQSxZQUFBVSxTQUFBVixHQUMxRCw2QkFBQUosT0FBaUMsU0FBQyxFQUFDO0FBQUEsWUFBQWUsSUFBQWxCLEdBQUE5QztBQUFBQSxJQUNuQztBQUFBLHNCQUFBK0MsTUFBQUM7QUFBQUEsY0FBK0IsT0FBMEIsY0FBMUIsMEJBQTBCO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQWlCLE1BQUFDLElBQUFDO0FBQUFBLElBR3ZFO0FBQUEsc0JBQUFwQixNQUFBQztBQUFBQTtBQUFBQSxlQUFBaEQsSUFDVTtBQUFBLGVBQUFxRCxJQUNBO0FBQUEsY0FDUix1QkFBRztBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFlLEtBQUF0QixHQUFBOUM7QUFBQUEsSUFJTjtBQUFBLHNCQUFBK0MsTUFBQUM7QUFBQUEsa0JBQUFLLElBQ1U7QUFBQSxjQUNDLE9BQUssU0FBTCwrQkFBbUI7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBZ0IsSUFBQUM7QUFBQUEsSUFHbEI7QUFBQSxzQkFBQXZCLE1BQUFDO0FBQUFBLGNBQTZCO0FBQUE7QUFBQTtBQUFBLHNDRHBFNUMsc0NDb0VxRjtBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUF1QixTQUFBRDtBQUFBQSxJQUdwRjtBQUFBLHNCQUFBdkIsTUFBQUM7QUFBQUEsY0FBNkI7QUFBQTtBQUFBO0FBQUEsc0NEdkUvQixzQ0N1RXlFO0FBQUEsZUFBQztBQUFBO0FBQUE7QUFBQSxJQUFBZ0IsUUFsRDNCO0FBQUEsSUFBQVE7QUFBQUEsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBYixRQUFBO0FBQUEsSUFBQWMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUosWUFBQTtBQUFBLElBQUFLLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQXZDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQTtBQUFBQSxNQUFBO0FBQUE7QUFBQSxJQUFBQTtBQUFBQSxNQUFBO0FBQUE7QUFBQSxJQUFBQTtBQUFBQSxNQUFBO0FBQUEsSUFBQUE7QUFBQUEsTUFBQTtBQUFBO0FBQUEsSUFBQUE7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBd0MsUUFBQWI7QUFBQUEsSUFxRjFDO0FBQUE7QUFBQTtBQUFBLFFBQzBCO0FBQUEsS0FBeEI7QUFBQTtBQUFBO0FBQUEsS0FBQWMsUUFDTztBQUFBLEtBQUFDLEtBRVo7QUFBQSxLQUFBQyxLQUNBO0FBQUE7QUFBQSxzQkFBQXJDLE9BQUFEO0FBQUFBLGtCQUFBdUMsUUFDYztBQUFBLGNBQ1osZ0RBQWE7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBQyxNQUFBbEIsTUFHSSxPQUFjLGlCQUFkLGNBQWM7QUFBQSxZQUFBbUIsaUJBQUFDO0FBQUFBLElBRy9CO0FBQUE7QUFBQTtBQUFBLFFBQzBCO0FBQUEsS0FBeEI7QUFBQTtBQUFBO0FBQUEsS0FBQTlCLFFBQ2lCO0FBQUEsS0FBQStCLFNBQWdCO0FBQUEsS0FBQUMsVUFBQTtBQUFBLEtBQUFDLGNBQ3BCO0FBQUEsS0FBQVQ7QUFBQUEsT0FFSjtBQUFBLDBEQUFBbkMsT0FBbUQsVUFBRTtBQUFBLEtBQUE2QztBQUFBQSxPQUUvRDtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUFBUCxPQUFBUSxLQUFBQztBQUFBQSxVQUNTO0FBQUE7QUFBQTtBQUFBLGNBS0M7QUFBQTtBQUFBLGNBREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBRko7QUFBQTtBQUFBLFVBSUM7QUFBQTtBQUFBO0FBQUEsY0FLSztBQUFBO0FBQUEsY0FERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FGSjtBQUFBO0FBQUEsY0FBQUMsYUFJZTtBQUFBLFVBQ2pCO0FBQUEsVUFBMkI7QUFBQSxTQUNqQjtBQUFBLElBRVg7QUFBQTtBQUFBO0FBQUEsUUFHVztBQUFBLEtBRFo7QUFBQTtBQUFBLElBSUo7QUFBQSxzQkFBQWhELE9BQUFEO0FBQUFBO0FBQUFBLGVBQUFrRCxTQUNlO0FBQUEsZUFBQXRDO0FBQUFBLGlCQUVYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUlRO0FBQUEsZUFHQTtBQUFBLGtCQUFBMkIsUUFIQTtBQUFBLGNBRU0sc0RBQW1CO0FBQUEsYUFDYixFQUFDO0FBQUE7QUFBQSxZQUFBWSxlQUFBVDtBQUFBQSxJQUdLLE9BQXdCLGlCQUF4Qix3QkFBd0I7QUFBQTtBQUFBLFlBQUFVLFFBQUFDO0FBQUFBLElBQ25DO0FBQUEsc0JBQUF0RCxNQUFBQztBQUFBQSxrQkFBQSxPQUE2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaURBQXFDO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQXNELFlBQUFDO0FBQUFBLFFBQUFGLFNBR3RGO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUFwRCxPQUFvQyxPQUFnQix5QkFBaEIsZ0JBQWdCO0FBQUEsZUFDcEQ7QUFBQTtBQUFBO0FBQUEsa0RBQVk7QUFBQTtBQUFBLFlBQUF1RCx5QkFBQUMsYUFBQXpHO0FBQUFBLElBSVo7QUFBQSxzQkFBQTBHO0FBQUFBO0FBQUFBLGVBQUEsT0FFYTtBQUFBLGVBQUFDO0FBQUFBLGlCQUFUO0FBQUE7QUFBQTtBQUFBLDRCQUFBMUQ7QUFBQUEsd0JBQUFILElBQXFCLFVBQUE4RCxJQUFBO0FBQUEsb0JBRWpCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1Q0FBQUMsR0FDQSw4QkFBeUI7QUFBQSxtQkFBRztBQUFBLHNCQUUvQjtBQUFBLHNCQUF5QixRQUFJO0FBQUEsY0FBSjtBQUFBO0FBQUE7QUFBQSxrQkFJdEI7QUFBQTtBQUFBLGVBRko7QUFBQTtBQUFBO0FBQUEsZUFBQUMsYUFHZTtBQUFBLGVBQUFDO0FBQUFBLGlCQUNILGVBQWU7QUFBQSxjQUM3QjtBQUFBO0FBQUE7QUFBQSxnQ0FBQTlELE9BQUEseUNBRWM7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBK0QsZ0JBQUFQLGFBQUF6RztBQUFBQSxhQUFBaUgsU0FBQTNDO0FBQUFBLEtBSUcsZ0RBQUF4QixHQUEyQixrQkFBSyxFQUFDO0FBQUE7QUFBQSxJQUM1QixPQUFzQjtBQUFBLGFBQXRCO0FBQUEsc0JBQUE0RCxNQUFnRCxPQUFRLFNBQVIsb0JBQVEsR0FBQztBQUFBO0FBQUEsWUFBQVEsTUFBQSxNQUFBQyxLQUFBbEU7QUFBQUE7QUFBQUEsS0FBQW1FLGFBRzFFO0FBQUEsS0FBQUMsYUFBQTtBQUFBLElBQ1I7QUFBQSxzQkFBQXRFLE1BQUFDO0FBQUFBLGNBQ0U7QUFBQTtBQUFBO0FBQUEsZUFBQXNFLGNBQ0E7QUFBQSxlQUFBRDtBQUFBQSxpQkFDQTtBQUFBLG9CQUVPO0FBQUE7QUFBQSxlQUFBRTtBQUFBQSxpQkFJRztBQUFBO0FBQUEsY0FHVixjQUNLO0FBQUE7QUFBQSxlQUFBTDtBQUFBQSxpQkFFUyx5Q0FBQWpFLE9BQTRCLFNBQUM7QUFBQSxlQUFBdUUsWUFDekM7QUFBQSxlQUFBQyxZQUNBO0FBQUEsc0JBQ0E7QUFBQTtBQUFBLG1CQUFBQyxRQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFBbkM7QUFBQUEsbUJBRWM7QUFBQSxnQkFDSztBQUFBO0FBQUEsMkJBQWlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFHcEM7QUFBQTtBQUFBLG1CQUFBb0MsSUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFBQUMsSUFDVTtBQUFBLGdCQUNSO0FBQUEsMkJBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUVkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx3Q0RoT2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUNpT00sd0NBQW9CO0FBQUEsY0FEeUI7QUFBQSxhQUN6QixFQUFDO0FBQUE7QUFBQTtBQUFBLElBQUFDLE9BR2hCO0FBQUEsSUFBQUM7QUFBQUEsTUFDQTtBQUFBLGlCQUFBN0UsT0FBQUQ7QUFBQUEsU0FBK0IsK0NBQTZCO0FBQUE7QUFBQSxVQUFDO0FBQUE7QUFBQSxZQUFBK0UsT0FBQUM7QUFBQUEsUUFBQSxPQUM5QjtBQUFBLElBQWIsT0FBVyxVQUFYLHVDQUEyQztBQUFBO0FBQUEsWUFBQUMsT0FBQUMsT0FBQUM7QUFBQUEsUUFBQSxPQUNaO0FBQUEsSUFBM0IsT0FBeUIsVUFBekIsbUNBQXVEO0FBQUE7QUFBQSxZQUFBQyxPQUFBQyxNQUFBQztBQUFBQSxJQUdsRixPQUFtQjtBQUFBLGFBQW5CO0FBQUEsc0JBQUFyRjtBQUFBQSxjQUF1Qix1QkFBQXNGLEtBQUEsVUFDWDtBQUFBLGtCQUFBQyxNQURXO0FBQUEsY0FFVDtBQUFBLGFBQVU7QUFBQTtBQUFBLFlBQUFDLGFBQUFyQixZQUFBQyxZQUFBcUI7QUFBQUEsUUFBQSxPQUlYO0FBQUEsSUFBZ0M7QUFBQTtBQUFBO0FBQUEsc0JBQUF4QjtBQUFBQSxjQUNqRCxPQUF1RDtBQUFBLHVCQUF2RDtBQUFBO0FBQUE7QUFBQSxrQ0FBQW5FLE1BQStCLCtCQUF1QixJQUFRO0FBQUE7QUFBQTtBQUFBLFlBQUF1QixLQUFBb0UsU0FHN0Msa0NBQW9CO0FBQUEsWUFBQUMsZUFBQUQsU0FDVixvQ0FBa0M7QUFBQSxZQUFBRSxpQkFBQUYsU0FBQUc7QUFBQUEsSUFHN0Qsc0RBQTBEO0FBQUE7QUFBQSxZQUFBQyxjQUFBQztBQUFBQTtBQUFBQSxLQUFBQSxTQUkvQztBQUFBLEtBQUFDLGtCQUNYO0FBQUEsSUFDQTtBQUFBLHNCQUFBL0YsT0FBQUQ7QUFBQUE7QUFBQUEsZUFBQWlHO0FBQUFBLGlCQUN5QjtBQUFBLGVBQUFDO0FBQUFBLGlCQUNUO0FBQUE7QUFBQTtBQUFBLGtDRGhRbEI7QUFBQSxzQkNrUUk7QUFBQTtBQUFBO0FBQUEsbUJBQUF2QixJQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFBQztBQUFBQSxtQkFDVTtBQUFBO0FBQUEsZ0JBQ1I7QUFBQSwyQkFBc0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBR3hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQW9FO0FBQUE7QUFBQTtBQUFBLGdDQUFBRDtBQUFBQSw0QkFBQSxPQUV0QjtBQUFBLHdCQUFOLCtDQUFrQjtBQUFBLHlCQUFDO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQXdCLGtCQUFBN0U7QUFBQUEsSUFJOUQ7QUFBQSxzQkFBQXJCLE9BQUFEO0FBQUFBO0FBQUFBLGVBQUFvQyxRQUNjO0FBQUEsc0JBQ1o7QUFBQTtBQUFBO0FBQUEsbUJBQUF1QyxJQUFBO0FBQUE7QUFBQSxvQkFBQUMsSUFDVTtBQUFBLGdCQUNSO0FBQUEsMkJBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUV0Qix3Q0FBbUI7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBeEMsTUFBQXRDLE9BQUEsT0FHTixzQkFBUSxJQUFSLGNBQXlCO0FBQUEsWUFBQXNHLElBQUF0RyxHQUMvQiw2QkR2UlosbUJDdVIrQjtBQUFBLFlBQUF1RCxPQUFBdkQsR0FDaEIsNEJBQXNCO0FBQUEsWUFBQXVHLHVCQUFBL0QsSUFBQUQ7QUFBQUEsSUFHbkM7QUFBQSxzQkFBQXBDLE9BQUFEO0FBQUFBO0FBQUFBLGVBQUEsT0FDd0Q7QUFBQSxzQkFBckI7QUFBQSxzQkFBakM7QUFBQSxjQUFzRSxzQ0FDakQ7QUFBQSxlQUFDO0FBQUE7QUFBQTtBQUFBLElBQUFzRyxpQkFHTDtBQUFBLElBQUFDLGlCQUNBO0FBQUEsSUFBQUMsYUFDSjtBQUFBLElBQUFDLHFCQUNRO0FBQUEsSUFBQUMsZUFDTjtBQUFBLElBQUFDLGFBQ0Y7QUFBQSxJQUFBQztBQUFBQSxNQUdmO0FBQUEsSUFBQUM7QUFBQUEsTUFPb0IsUUFBUTtBQUFBLElBQUFDO0FBQUFBLE1BQ2I7QUFBQTtBQUFBLFVBT1A7QUFBQSxJQUFBQztBQUFBQSxNQUpSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFHUTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBLElBUVI7QUFBQSxzQkFBQWxILE1BQUFDO0FBQUFBO0FBQUFBLGVBQUFrSCxjQUNFO0FBQUEsZUFBQTVDLGNBQ0E7QUFBQSxlQUFBNkM7QUFBQUEsaUJBRUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBQUFDLGdCQUVGO0FBQUEsY0FDQTtBQUFBLGFBQWEsRUFBQztBQUFBO0FBQUE7QUFBQSxJQUFBQyw2QkFHZTtBQUFBLElBQUFDLDhCQUNDO0FBQUEsVUFBMkI7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLFlBQUFDLFlBQUFDO0FBQUFBLGFBQUFDLFVBQUFyRixJQUFBc0Y7QUFBQUEsS0FXdEQ7QUFBQSxNQUNFLHVDQW1CMEQ7QUFBQSxLQWxCdkQ7QUFBQSxNQUNILGdEQWlCMEQ7QUFBQSxLQWhCdkQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFvQix1Q0FBb0I7QUFBQSxVQUFBQyxjQU81Qix5QkFBWTtBQUFBLE1BQzlCO0FBQUEsd0JBQUE1SCxPQUFBRDtBQUFBQTtBQUFBQSxpQkFBQThILFVBQ2dCO0FBQUEsaUJBQUFDO0FBQUFBLG1CQUNJO0FBQUEsaUJBQUFDLFVBQ047QUFBQSxnQkFDWixRQUFBQyxRQUFNO0FBQUE7QUFBQSw0QkRwV2Q7QUFBQSwyQ0NxVzBDO0FBQUEsaUJEclcxQztBQUFBO0FBQUEsb0JBQUFBLFFDdVdvQjtBQUFBLGdCQUNQO0FBQUE7QUFBQSwrQkFBb0Q7QUFBQSxpQkFBRTtBQUFBO0FBQUE7QUFBQSxhQWRTO0FBQUE7QUFBQSxRQUFwRDtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQW1ELGtDQWNSO0FBQUE7QUFBQSxhQUFBQyxrQkFBQTVGLElBQUFEO0FBQUFBLEtBSS9EO0FBQUEsdUJBQUFwQyxPQUFBRDtBQUFBQSxlQUErQiw4Q0FBOEI7QUFBQSxnQkFBQztBQUFBO0FBQUEsYUFBQW1JLHNCQUFBN0YsSUFBQUQ7QUFBQUEsS0FJOUQ7QUFBQSx1QkFBQXBDLE9BQUFEO0FBQUFBLGVBQStCLDhDQUFrQztBQUFBLGdCQUFDO0FBQUE7QUFBQSxhQUFBb0ksWUFBQXBMLEdBQUFzRixJQUFBRDtBQUFBQTtBQUFBQSxNQUFBLE9BSVY7QUFBQSxhQUFoQjtBQUFBLEtBQWpCLE9BQVM7QUFBQSw0QkFBVCx5Q0FBMEM7QUFBQTtBQUFBLGFBQUFnRyxVQUFBO0FBQUEsS0FHbkQ7QUFBQTtBQUFBLGFBQUFDLGNBQUE7QUFBQSxLQUNJO0FBQUE7QUFBQTtBQUFBLEtBQUFDLGNBQ0Y7QUFBQSxLQUFBQztBQUFBQSxPQURFO0FBQUEsWUFLRDtBQUFBLEtBQUFuSDtBQUFBQSxPQUFmO0FBQUE7QUFBQTtBQUFBLGtCQUFBcEI7QUFBQUEsY0FBQXdJLFlBQUEsVUFBQUMsV0FBQTtBQUFBLFVBRUEsa0JBQWlCLDhDQUF3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGlCQXRERjtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQTFJLE9BQUE7QUFBQSxJQUFBMkksWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLElBQUE7QUFBQSxJQUFBbkwsV0FBQTtBQUFBLElB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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBL0YsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBMUksU0FBQTtBQUFBLElBQUEySSxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQXZILFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUF3SCxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBMEMsU0FBQTtBQUFBLElBQUF6QyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUE5SSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQStMLFFBQUE7QUFBQSxJQUFBL0wsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUErSSxRQUFBO0FBQUEsSUFBQS9JLFlBQUE7QUFBQSxJQUFBZ00sU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQWQsU0FBQTtBQUFBLElBQUFlLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQXBELFVBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBaUMsUUFBQTtBQUFBLElBQUFoQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUEyQixRQUFBO0FBQUEsSUFBQTFCLHdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUUsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFKLGVBQUE7QUFBQSxJQUFBOUUsWUFBQTtBQUFBLElBQUFzRixnQkFBQTtBQUFBLElBQUF1QjtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUF2RyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUExSSxTQUFBO0FBQUEsSUFBQTJJLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQW5MLFlBQUE7QUFBQSxJQUFBb0wsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQXRMLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFpRyxZQUFBO0FBQUEsSUFBQXNGLGdCQUFBO0FBQUEsSUFBQStCO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQveUJ4RCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxuXG5tb2R1bGUgVCA6IHNpZ1xuICB0eXBlICsnYSB0XG5cbiAgdmFsIGNyZWF0ZSA6IChzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgZ2VuZXJhdGUgOiAnYSB0IC0+IHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+ICdhXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gKHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+ICdhKSBTdGFnZWQudFxuXG4gIGxldCBjcmVhdGUgZiA6IF8gdCA9IFN0YWdlZC5zdGFnZSBmXG5cbiAgbGV0IGdlbmVyYXRlICh0IDogXyB0KSB+c2l6ZSB+cmFuZG9tID1cbiAgICBpZiBzaXplIDwgMFxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLmdlbmVyYXRlOiBzaXplIDwgMFwiIChzaXplIDogaW50KV1cbiAgICBlbHNlIFN0YWdlZC51bnN0YWdlIHQgfnNpemUgfnJhbmRvbVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgc2l6ZSA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb206XyAtPiBzaXplKVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuc3BsaXQgcmFuZG9tIGluXG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBoYXNoID0gT2JzZXJ2ZXIwLm9ic2VydmUgZG9tIHggfnNpemUgfmhhc2g6KEhhc2guYWxsb2MgKCkpIGluXG4gICAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuY29weSByYW5kb20gaW5cbiAgICAgIFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnBlcnR1cmIgcmFuZG9tIChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpO1xuICAgICAgZ2VuZXJhdGUgcm5nIH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgd2l0aF9zaXplIHQgfnNpemUgPSBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKVxuXG5sZXQgcGVydHVyYiB0IHNhbHQgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUucGVydHVyYiByYW5kb20gc2FsdDtcbiAgICBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIH5zaXplIH5yYW5kb20gPVxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgbWF0Y2ggZiB4IHdpdGhcbiAgICB8IFNvbWUgeSAtPiB5XG4gICAgfCBOb25lIC0+IGxvb3AgfnNpemU6KHNpemUgKyAxKSB+cmFuZG9tXG4gIGluXG4gIGNyZWF0ZSBsb29wXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG5sZXQgcmV0dXJuIHggPSBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb206XyAtPiB4KVxubGV0IG1hcCB0IH5mID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBmIChnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pKVxuXG5sZXQgYXBwbHkgdGYgdHggPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IGYgPSBnZW5lcmF0ZSB0ZiB+c2l6ZSB+cmFuZG9tIGluXG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0eCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgZiB4KVxuOztcblxubGV0IGJpbmQgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSBpblxuICAgIGdlbmVyYXRlIChmIHgpIH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgYWxsIGxpc3QgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IExpc3QubWFwIGxpc3QgfmY6KGdlbmVyYXRlIH5zaXplIH5yYW5kb20pKVxuXG5sZXQgYWxsX3VuaXQgbGlzdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gTGlzdC5pdGVyIGxpc3QgfmY6KGdlbmVyYXRlIH5zaXplIH5yYW5kb20pKVxuOztcblxubW9kdWxlIEZvcl9hcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IGFwcGx5ID0gYXBwbHlcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5sZXQgYm90aCA9IEZvcl9hcHBsaWNhdGl2ZS5ib3RoXG5sZXQgbWFwMiA9IEZvcl9hcHBsaWNhdGl2ZS5tYXAyXG5sZXQgbWFwMyA9IEZvcl9hcHBsaWNhdGl2ZS5tYXAzXG5cbm1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IEZvcl9hcHBsaWNhdGl2ZS5BcHBsaWNhdGl2ZV9pbmZpeFxuaW5jbHVkZSBBcHBsaWNhdGl2ZV9pbmZpeFxuXG5tb2R1bGUgRm9yX21vbmFkID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5sZXQgaWdub3JlX20gPSBGb3JfbW9uYWQuaWdub3JlX21cbmxldCBqb2luID0gRm9yX21vbmFkLmpvaW5cblxubW9kdWxlIE1vbmFkX2luZml4ID0gRm9yX21vbmFkLk1vbmFkX2luZml4XG5pbmNsdWRlIE1vbmFkX2luZml4XG5tb2R1bGUgTGV0X3N5bnRheCA9IEZvcl9tb25hZC5MZXRfc3ludGF4XG5vcGVuIExldF9zeW50YXhcblxubGV0IG9mX2xpc3QgbGlzdCA9XG4gIGlmIExpc3QuaXNfZW1wdHkgbGlzdFxuICB0aGVuIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl9saXN0OiBlbXB0eSBsaXN0XCJdO1xuICBsZXQgYXJyYXkgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgbGV0IGxvID0gMCBpblxuICBsZXQgaGkgPSBBcnJheS5sZW5ndGggYXJyYXkgLSAxIGluXG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBpbmRleCA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvIH5oaSBpblxuICAgIGFycmF5LihpbmRleCkpXG47O1xuXG5sZXQgdW5pb24gbGlzdCA9IGpvaW4gKG9mX2xpc3QgbGlzdClcblxubGV0IG9mX3dlaWdodGVkX2xpc3QgYWxpc3QgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGFsaXN0XG4gIHRoZW4gRXJyb3IucmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLm9mX3dlaWdodGVkX2xpc3Q6IGVtcHR5IGxpc3RcIl07XG4gIGxldCB3ZWlnaHRzLCB2YWx1ZXMgPSBMaXN0LnVuemlwIGFsaXN0IGluXG4gIGxldCB2YWx1ZV9hcnJheSA9IEFycmF5Lm9mX2xpc3QgdmFsdWVzIGluXG4gIGxldCB0b3RhbF93ZWlnaHQsIGN1bXVsYXRpdmVfd2VpZ2h0X2FycmF5ID1cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5pbml0IChBcnJheS5sZW5ndGggdmFsdWVfYXJyYXkpIH5mOihmdW4gXyAtPiAwLikgaW5cbiAgICBsZXQgc3VtID1cbiAgICAgIExpc3QuZm9sZGkgd2VpZ2h0cyB+aW5pdDowLiB+ZjooZnVuIGluZGV4IGFjYyB3ZWlnaHQgLT5cbiAgICAgICAgaWYgbm90IChGbG9hdC5pc19maW5pdGUgd2VpZ2h0KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB3ZWlnaHQgaXMgbm90IGZpbml0ZVwiXG4gICAgICAgICAgICAgICAgKHdlaWdodCA6IGZsb2F0KV07XG4gICAgICAgIGlmIEZsb2F0LiggPCApIHdlaWdodCAwLlxuICAgICAgICB0aGVuXG4gICAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB3ZWlnaHQgaXMgbmVnYXRpdmVcIlxuICAgICAgICAgICAgICAgICh3ZWlnaHQgOiBmbG9hdCldO1xuICAgICAgICBsZXQgY3VtdWxhdGl2ZSA9IGFjYyArLiB3ZWlnaHQgaW5cbiAgICAgICAgYXJyYXkuKGluZGV4KSA8LSBjdW11bGF0aXZlO1xuICAgICAgICBjdW11bGF0aXZlKVxuICAgIGluXG4gICAgaWYgRmxvYXQuKCA8PSApIHN1bSAwLlxuICAgIHRoZW5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB0b3RhbCB3ZWlnaHQgaXMgemVyb1wiXTtcbiAgICBzdW0sIGFycmF5XG4gIGluXG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBjaG9pY2UgPSBTcGxpdHRhYmxlX3JhbmRvbS5mbG9hdCByYW5kb20gfmxvOjAuIH5oaTp0b3RhbF93ZWlnaHQgaW5cbiAgICBtYXRjaFxuICAgICAgQXJyYXkuYmluYXJ5X3NlYXJjaFxuICAgICAgICBjdW11bGF0aXZlX3dlaWdodF9hcnJheVxuICAgICAgICB+Y29tcGFyZTpGbG9hdC5jb21wYXJlXG4gICAgICAgIGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICAgICAgY2hvaWNlXG4gICAgd2l0aFxuICAgIHwgU29tZSBpbmRleCAtPiB2YWx1ZV9hcnJheS4oaW5kZXgpXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB3ZWlnaHRlZF91bmlvbiBhbGlzdCA9IGpvaW4gKG9mX3dlaWdodGVkX2xpc3QgYWxpc3QpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IGdlbmVyYXRlIChmb3JjZSBsYXp5X3QpIH5zaXplIH5yYW5kb20pXG5cbmxldCBmaXhlZF9wb2ludCBvZl9nZW5lcmF0b3IgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKG9mX2dlbmVyYXRvciAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBmb3JjZSBsYXp5X3Rcbjs7XG5cbmxldCB3ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb24gbm9ucmVjX2xpc3QgfmYgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNlbGYgLT5cbiAgICBsZXQgcmVjX2xpc3QgPVxuICAgICAgTGlzdC5tYXAgKGYgc2VsZikgfmY6KGZ1biAodywgdCkgLT5cbiAgICAgICAgKCB3XG4gICAgICAgICwgbGV0JWJpbmQgbiA9IHNpemUgaW5cbiAgICAgICAgICB3aXRoX3NpemUgfnNpemU6KG4gLSAxKSB0ICkpXG4gICAgaW5cbiAgICBpZiBMaXN0LmlzX2VtcHR5IG5vbnJlY19saXN0IHx8IExpc3QuaXNfZW1wdHkgcmVjX2xpc3RcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci53ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb246IGxpc3RzIG11c3QgYmUgbm9uLWVtcHR5XCJdO1xuICAgIGxldCBub25yZWNfZ2VuID0gd2VpZ2h0ZWRfdW5pb24gbm9ucmVjX2xpc3QgaW5cbiAgICBsZXQgcmVjX2dlbiA9IHdlaWdodGVkX3VuaW9uIChub25yZWNfbGlzdCBAIHJlY19saXN0KSBpblxuICAgIG1hdGNoJWJpbmQgc2l6ZSB3aXRoXG4gICAgfCAwIC0+IG5vbnJlY19nZW5cbiAgICB8IF8gLT4gcmVjX2dlbilcbjs7XG5cbmxldCByZWN1cnNpdmVfdW5pb24gbm9ucmVjX2xpc3QgfmYgPVxuICBsZXQgd2VpZ2h0ZWQgbGlzdCA9IExpc3QubWFwIGxpc3QgfmY6KGZ1biB0IC0+IDEuLCB0KSBpblxuICB3ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb24gKHdlaWdodGVkIG5vbnJlY19saXN0KSB+ZjooZnVuIHNlbGYgLT4gd2VpZ2h0ZWQgKGYgc2VsZikpXG47O1xuXG5sZXQgc2l6ZXMgPyhtaW5fbGVuZ3RoID0gMCkgPyhtYXhfbGVuZ3RoID0gSW50Lm1heF92YWx1ZSkgKCkgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgYXNzZXJ0IChtaW5fbGVuZ3RoIDw9IG1heF9sZW5ndGgpO1xuICAgIGxldCB1cHBlcl9ib3VuZCA9IG1pbl9sZW5ndGggKyBzaXplIGluXG4gICAgbGV0IG1heF9sZW5ndGggPVxuICAgICAgaWYgdXBwZXJfYm91bmQgPj0gbWluX2xlbmd0aCAoKiBndWFyZCBhZ2FpbnN0IG92ZXJmbG93ICopXG4gICAgICB0aGVuIG1pbiBtYXhfbGVuZ3RoIHVwcGVyX2JvdW5kXG4gICAgICBlbHNlIG1heF9sZW5ndGhcbiAgICBpblxuICAgICgqIHBpY2sgYSBsZW5ndGgsIHdlaWdodGVkIGxvdyBzbyB0aGF0IG1vc3Qgb2YgdGhlIHNpemUgaXMgc3BlbnQgb24gZWxlbWVudHMgKilcbiAgICBsZXQgbGVuID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50IHJhbmRvbSB+bG86bWluX2xlbmd0aCB+aGk6bWF4X2xlbmd0aCBpblxuICAgICgqIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyByZXR1cm4gYW4gZW1wdHkgYXJyYXksIG90aGVyd2lzZSByZXR1cm4gYSBub24tZW1wdHkgYXJyYXlcbiAgICAgICB3aXRoIHRoZSBzaXplIGRpc3RyaWJ1dGVkIGFtb25nIHRoZSBlbGVtZW50cyAqKVxuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIFtdXG4gICAgZWxzZSAoXG4gICAgICBsZXQgc2l6ZXMgPSBBcnJheS5pbml0IGxlbiB+ZjooZnVuIF8gLT4gMCkgaW5cbiAgICAgIGxldCByZW1haW5pbmcgPSBzaXplIC0gKGxlbiAtIG1pbl9sZW5ndGgpIGluXG4gICAgICBsZXQgbWF4X2luZGV4ID0gbGVuIC0gMSBpblxuICAgICAgZm9yIF8gPSAxIHRvIHJlbWFpbmluZyBkb1xuICAgICAgICAoKiBwaWNrIGFuIGluZGV4LCB3ZWlnaHRlZCBsb3cgc28gdGhhdCB3ZSBzZWUgdW5iYWxhbmNlZCBkaXN0cmlidXRpb25zIG9mdGVuICopXG4gICAgICAgIGxldCBpbmRleCA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOjAgfmhpOm1heF9pbmRleCBpblxuICAgICAgICBzaXplcy4oaW5kZXgpIDwtIHNpemVzLihpbmRleCkgKyAxXG4gICAgICBkb25lO1xuICAgICAgKCogcGVybXV0ZSB0aGUgYXJyYXkgc28gdGhhdCBubyBpbmRleCBpcyBmYXZvcmVkIG92ZXIgYW5vdGhlciAqKVxuICAgICAgZm9yIGkgPSAwIHRvIG1heF9pbmRleCAtIDEgZG9cbiAgICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzppIH5oaTptYXhfaW5kZXggaW5cbiAgICAgICAgQXJyYXkuc3dhcCBzaXplcyBpIGpcbiAgICAgIGRvbmU7XG4gICAgICBhc3NlcnQgKEFycmF5LnN1bSAobW9kdWxlIEludCkgc2l6ZXMgfmY6Rm4uaWQgKyAobGVuIC0gbWluX2xlbmd0aCkgPSBzaXplKTtcbiAgICAgIEFycmF5LnRvX2xpc3Qgc2l6ZXMpKVxuOztcblxubGV0IHVuaXQgPSByZXR1cm4gKClcbmxldCBib29sID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IFNwbGl0dGFibGVfcmFuZG9tLmJvb2wgcmFuZG9tKVxubGV0IG9wdGlvbiB2YWx1ZV90ID0gdW5pb24gWyByZXR1cm4gTm9uZTsgbWFwIHZhbHVlX3QgfmY6T3B0aW9uLnJldHVybiBdXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID0gdW5pb24gWyBtYXAgZnN0X3QgfmY6RWl0aGVyLmZpcnN0OyBtYXAgc25kX3QgfmY6RWl0aGVyLnNlY29uZCBdXG5cbmxldCByZXN1bHQgb2tfdCBlcnJfdCA9XG4gIG1hcCAoZWl0aGVyIG9rX3QgZXJyX3QpIH5mOihmdW5jdGlvblxuICAgIHwgRmlyc3Qgb2sgLT4gT2sgb2tcbiAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuOztcblxubGV0IGxpc3RfZ2VuZXJpYyA/bWluX2xlbmd0aCA/bWF4X2xlbmd0aCBlbHRfZ2VuID1cbiAgbGV0JWJpbmQgc2l6ZXMgPSBzaXplcyA/bWluX2xlbmd0aCA/bWF4X2xlbmd0aCAoKSBpblxuICBMaXN0Lm1hcCBzaXplcyB+ZjooZnVuIHNpemUgLT4gd2l0aF9zaXplIH5zaXplIGVsdF9nZW4pIHw+IGFsbFxuOztcblxubGV0IGxpc3QgZWx0X2dlbiA9IGxpc3RfZ2VuZXJpYyBlbHRfZ2VuXG5sZXQgbGlzdF9ub25fZW1wdHkgZWx0X2dlbiA9IGxpc3RfZ2VuZXJpYyB+bWluX2xlbmd0aDoxIGVsdF9nZW5cblxubGV0IGxpc3Rfd2l0aF9sZW5ndGggZWx0X2dlbiB+bGVuZ3RoID1cbiAgbGlzdF9nZW5lcmljIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggZWx0X2dlblxuOztcblxubGV0IGxpc3RfZmlsdGVyZWQgZWx0cyA9XG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBsZW5ndGhfb2ZfaW5wdXQgPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgbGVuZ3RoX29mX291dHB1dCA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOjAgfmhpOmxlbmd0aF9vZl9pbnB1dCBpblxuICAgIGxldCBpbmRpY2VzID0gQXJyYXkuaW5pdCBsZW5ndGhfb2ZfaW5wdXQgfmY6Rm4uaWQgaW5cbiAgICAoKiBDaG9vc2UgW2xlbmd0aF9vZl9vdXRwdXRdIHJhbmRvbSB2YWx1ZXMgaW4gdGhlIHByZWZpeCBvZiBbaW5kaWNlc10uICopXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aF9vZl9vdXRwdXQgLSAxIGRvXG4gICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOmkgfmhpOihsZW5ndGhfb2ZfaW5wdXQgLSAxKSBpblxuICAgICAgQXJyYXkuc3dhcCBpbmRpY2VzIGkgalxuICAgIGRvbmU7XG4gICAgKCogU29ydCB0aGUgY2hvc2VuIGluZGljZXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHJlb3JkZXIgdGhlbS4gKilcbiAgICBBcnJheS5zb3J0IGluZGljZXMgfnBvczowIH5sZW46bGVuZ3RoX29mX291dHB1dCB+Y29tcGFyZTpJbnQuY29tcGFyZTtcbiAgICAoKiBSZXR1cm4gdGhlIGNob3NlbiBlbGVtZW50cy4gKilcbiAgICBMaXN0LmluaXQgbGVuZ3RoX29mX291dHB1dCB+ZjooZnVuIGkgLT4gZWx0cy4oaW5kaWNlcy4oaSkpKSlcbjs7XG5cbmxldCBsaXN0X3Blcm11dGF0aW9ucyBsaXN0ID1cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGFycmF5ID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDEgZG9cbiAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86MCB+aGk6aSBpblxuICAgICAgQXJyYXkuc3dhcCBhcnJheSBpIGpcbiAgICBkb25lO1xuICAgIEFycmF5LnRvX2xpc3QgYXJyYXkpXG47O1xuXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0XG5sZXQgcmVmIHQgPSBtYXAgdCB+ZjpSZWYuY3JlYXRlXG5sZXQgbGF6eV90IHQgPSBtYXAgdCB+ZjpMYXp5LmZyb21fdmFsXG5cbmxldCBjaGFyX3VuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86KENoYXIudG9faW50IGxvKSB+aGk6KENoYXIudG9faW50IGhpKVxuICAgIHw+IENoYXIudW5zYWZlX29mX2ludClcbjs7XG5cbmxldCBjaGFyX3VwcGVyY2FzZSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJ0EnICdaJ1xubGV0IGNoYXJfbG93ZXJjYXNlID0gY2hhcl91bmlmb3JtX2luY2x1c2l2ZSAnYScgJ3onXG5sZXQgY2hhcl9kaWdpdCA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJzAnICc5J1xubGV0IGNoYXJfcHJpbnRfdW5pZm9ybSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJyAnICd+J1xubGV0IGNoYXJfdW5pZm9ybSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgQ2hhci5taW5fdmFsdWUgQ2hhci5tYXhfdmFsdWVcbmxldCBjaGFyX2FscGhhID0gdW5pb24gWyBjaGFyX2xvd2VyY2FzZTsgY2hhcl91cHBlcmNhc2UgXVxuXG5sZXQgY2hhcl9hbHBoYW51bSA9XG4gIHdlaWdodGVkX3VuaW9uXG4gICAgKCogTW9zdCBwZW9wbGUgcHJvYmFibHkgZXhwZWN0IHRoaXMgdG8gYmUgYSB1bmlmb3JtIGRpc3RyaWJ1dGlvbiwgbm90IHdlaWdodGVkXG4gICAgICAgdG93YXJkIGRpZ2l0cyBsaWtlIHdlIHdvdWxkIGdldCB3aXRoIFt1bmlvbl0gKHNpbmNlIHRoZXJlIGFyZSBmZXdlciBkaWdpdHMgdGhhblxuICAgICAgIGxldHRlcnMpLiAqKVxuICAgIFsgNTIuLCBjaGFyX2FscGhhOyAxMC4sIGNoYXJfZGlnaXQgXVxuOztcblxubGV0IGNoYXJfd2hpdGVzcGFjZSA9IG9mX2xpc3QgKExpc3QuZmlsdGVyIENoYXIuYWxsIH5mOkNoYXIuaXNfd2hpdGVzcGFjZSlcbmxldCBjaGFyX3ByaW50ID0gd2VpZ2h0ZWRfdW5pb24gWyAxMC4sIGNoYXJfYWxwaGFudW07IDEuLCBjaGFyX3ByaW50X3VuaWZvcm0gXVxuXG5sZXQgY2hhciA9XG4gIHdlaWdodGVkX3VuaW9uXG4gICAgWyAxMDAuLCBjaGFyX3ByaW50XG4gICAgOyAxMC4sIGNoYXJfdW5pZm9ybVxuICAgIDsgMS4sIHJldHVybiBDaGFyLm1pbl92YWx1ZVxuICAgIDsgMS4sIHJldHVybiBDaGFyLm1heF92YWx1ZVxuICAgIF1cbjs7XG5cbigqIFByb2R1Y2VzIGEgbnVtYmVyIGZyb20gMCBvciAxIHRvIHNpemUgKyAxLCB3ZWlnaHRlZCBoaWdoLiBXZSBoYXZlIGZvdW5kIHRoaXNcbiAgIGRpc3RyaWJ1dGlvbiBlbXBpcmljYWxseSB1c2VmdWwgZm9yIHN0cmluZyBsZW5ndGhzLiAqKVxubGV0IHNtYWxsX2ludCB+YWxsb3dfemVybyA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgbG93ZXJfYm91bmQgPSBpZiBhbGxvd196ZXJvIHRoZW4gMCBlbHNlIDEgaW5cbiAgICBsZXQgdXBwZXJfYm91bmQgPSBzaXplICsgMSBpblxuICAgIGxldCB3ZWlnaHRlZF9sb3cgPVxuICAgICAgU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50IHJhbmRvbSB+bG86MCB+aGk6KHVwcGVyX2JvdW5kIC0gbG93ZXJfYm91bmQpXG4gICAgaW5cbiAgICBsZXQgd2VpZ2h0ZWRfaGlnaCA9IHVwcGVyX2JvdW5kIC0gd2VpZ2h0ZWRfbG93IGluXG4gICAgd2VpZ2h0ZWRfaGlnaClcbjs7XG5cbmxldCBzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCA9IHNtYWxsX2ludCB+YWxsb3dfemVybzp0cnVlXG5sZXQgc21hbGxfc3RyaWN0bHlfcG9zaXRpdmVfaW50ID0gc21hbGxfaW50IH5hbGxvd196ZXJvOmZhbHNlXG5cbm1vZHVsZSB0eXBlIEludF93aXRoX3JhbmRvbSA9IHNpZ1xuICBpbmNsdWRlIEludC5TXG5cbiAgdmFsIHVuaWZvcm0gOiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0XG4gIHZhbCBsb2dfdW5pZm9ybSA6IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gbG86dCAtPiBoaTp0IC0+IHRcbmVuZFxuXG5tb2R1bGUgRm9yX2ludGVnZXIgKEludGVnZXIgOiBJbnRfd2l0aF9yYW5kb20pID0gc3RydWN0XG4gIGxldCBnZW9tZXRyaWMgbG8gfnAgPVxuICAgIGlmIEZsb2F0LmVxdWFsIHAgMS5cbiAgICB0aGVuIHJldHVybiBsb1xuICAgIGVsc2UgaWYgRmxvYXQuZXF1YWwgcCAwLlxuICAgIHRoZW4gcmV0dXJuIEludGVnZXIubWF4X3ZhbHVlXG4gICAgZWxzZSBpZiBGbG9hdC4oIDwgKSBwIDAuIHx8IEZsb2F0LiggPiApIHAgMS4gfHwgRmxvYXQuaXNfbmFuIHBcbiAgICB0aGVuXG4gICAgICByYWlzZV9zIFslbWVzc2FnZSBcImdlb21ldHJpYyBkaXN0cmlidXRpb246IHAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcIiAocCA6IGZsb2F0KV1cbiAgICBlbHNlIChcbiAgICAgICgqIFdlIHN0YXJ0IHdpdGggYSB1bmlmb3JtIGRpc3RyaWJ1dGlvbi4gV2UgY29udmVydCB0byBleHBvbmVudGlhbCBkaXN0cmlidXRpb25cbiAgICAgICAgIHVzaW5nIFtsb2ddLiBXZSBjb252ZXJ0IHRvIGdlb21ldHJpYyB3aXRoIFtyb3VuZF9kb3duXS4gVGhlbiB3ZSBib3VuZHMgY2hlY2sgYW5kXG4gICAgICAgICByZXR1cm4uICopXG4gICAgICBsZXQgZGVub21pbmF0b3IgPSBGbG9hdC5sb2cxcCAoLS5wKSBpblxuICAgICAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20udW5pdF9mbG9hdCByYW5kb20gaW5cbiAgICAgICAgbGV0IGV4cG9uZW50aWFsID0gRmxvYXQubG9nIHVuaWZvcm0gLy4gZGVub21pbmF0b3IgaW5cbiAgICAgICAgbGV0IGZsb2F0ID0gRmxvYXQucm91bmRfZG93biBleHBvbmVudGlhbCBpblxuICAgICAgICBtYXRjaCBJbnRlZ2VyLm9mX2Zsb2F0IGZsb2F0IHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCBfIC0+IEludGVnZXIubWF4X3ZhbHVlXG4gICAgICAgIHwgaW50IC0+XG4gICAgICAgICAgbGV0IGludCA9IEludGVnZXIuKCArICkgbG8gaW50IGluXG4gICAgICAgICAgaWYgSW50ZWdlci4oIDwgKSBpbnQgbG8gdGhlbiBJbnRlZ2VyLm1heF92YWx1ZSBlbHNlIGludCkpXG4gIDs7XG5cbiAgbGV0IHVuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gSW50ZWdlci51bmlmb3JtIHJhbmRvbSB+bG8gfmhpKVxuICA7O1xuXG4gIGxldCBsb2dfdW5pZm9ybV9pbmNsdXNpdmUgbG8gaGkgPVxuICAgIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBJbnRlZ2VyLmxvZ191bmlmb3JtIHJhbmRvbSB+bG8gfmhpKVxuICA7O1xuXG4gIGxldCBub25fdW5pZm9ybSBmIGxvIGhpID1cbiAgICB3ZWlnaHRlZF91bmlvbiBbIDAuMDUsIHJldHVybiBsbzsgMC4wNSwgcmV0dXJuIGhpOyAwLjksIGYgbG8gaGkgXVxuICA7O1xuXG4gIGxldCBpbmNsdXNpdmUgPSBub25fdW5pZm9ybSB1bmlmb3JtX2luY2x1c2l2ZVxuICBsZXQgbG9nX2luY2x1c2l2ZSA9IG5vbl91bmlmb3JtIGxvZ191bmlmb3JtX2luY2x1c2l2ZVxuICBsZXQgdW5pZm9ybV9hbGwgPSB1bmlmb3JtX2luY2x1c2l2ZSBJbnRlZ2VyLm1pbl92YWx1ZSBJbnRlZ2VyLm1heF92YWx1ZVxuXG4gIGxldCBhbGwgPVxuICAgIFslbWFwXG4gICAgICBsZXQgbmVnYXRpdmUgPSBib29sXG4gICAgICBhbmQgbWFnbml0dWRlID0gbG9nX2luY2x1c2l2ZSBJbnRlZ2VyLnplcm8gSW50ZWdlci5tYXhfdmFsdWUgaW5cbiAgICAgIGlmIG5lZ2F0aXZlIHRoZW4gSW50ZWdlci5iaXRfbm90IG1hZ25pdHVkZSBlbHNlIG1hZ25pdHVkZV1cbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX2ludCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludFxuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnRcbiAgZW5kKVxuXG5sZXQgaW50ID0gRm9yX2ludC5hbGxcbmxldCBpbnRfdW5pZm9ybSA9IEZvcl9pbnQudW5pZm9ybV9hbGxcbmxldCBpbnRfaW5jbHVzaXZlID0gRm9yX2ludC5pbmNsdXNpdmVcbmxldCBpbnRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50X2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmVcbmxldCBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnRfZ2VvbWV0cmljID0gRm9yX2ludC5nZW9tZXRyaWNcblxubW9kdWxlIEZvcl9pbnQzMiA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludDMyXG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludDMyXG4gICAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50MzJcbiAgZW5kKVxuXG5sZXQgaW50MzIgPSBGb3JfaW50MzIuYWxsXG5sZXQgaW50MzJfdW5pZm9ybSA9IEZvcl9pbnQzMi51bmlmb3JtX2FsbFxubGV0IGludDMyX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5pbmNsdXNpdmVcbmxldCBpbnQzMl91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDMyX2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50MzIubG9nX2luY2x1c2l2ZVxubGV0IGludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQzMl9nZW9tZXRyaWMgPSBGb3JfaW50MzIuZ2VvbWV0cmljXG5cbm1vZHVsZSBGb3JfaW50NjMgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQ2M1xuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludDYzXG4gIGVuZClcblxubGV0IGludDYzID0gRm9yX2ludDYzLmFsbFxubGV0IGludDYzX3VuaWZvcm0gPSBGb3JfaW50NjMudW5pZm9ybV9hbGxcbmxldCBpbnQ2M19pbmNsdXNpdmUgPSBGb3JfaW50NjMuaW5jbHVzaXZlXG5sZXQgaW50NjNfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjMudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQ2M19sb2dfaW5jbHVzaXZlID0gRm9yX2ludDYzLmxvZ19pbmNsdXNpdmVcbmxldCBpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjMubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjNfZ2VvbWV0cmljID0gRm9yX2ludDYzLmdlb21ldHJpY1xuXG5tb2R1bGUgRm9yX2ludDY0ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjRcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2NFxuICBlbmQpXG5cbmxldCBpbnQ2NCA9IEZvcl9pbnQ2NC5hbGxcbmxldCBpbnQ2NF91bmlmb3JtID0gRm9yX2ludDY0LnVuaWZvcm1fYWxsXG5sZXQgaW50NjRfaW5jbHVzaXZlID0gRm9yX2ludDY0LmluY2x1c2l2ZVxubGV0IGludDY0X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDY0X2dlb21ldHJpYyA9IEZvcl9pbnQ2NC5nZW9tZXRyaWNcblxubW9kdWxlIEZvcl9uYXRpdmVpbnQgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gICAgaW5jbHVkZSBOYXRpdmVpbnRcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20ubmF0aXZlaW50XG4gICAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0ubmF0aXZlaW50XG4gIGVuZClcblxubGV0IG5hdGl2ZWludCA9IEZvcl9uYXRpdmVpbnQuYWxsXG5sZXQgbmF0aXZlaW50X3VuaWZvcm0gPSBGb3JfbmF0aXZlaW50LnVuaWZvcm1fYWxsXG5sZXQgbmF0aXZlaW50X2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQuaW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC51bmlmb3JtX2luY2x1c2l2ZVxubGV0IG5hdGl2ZWludF9sb2dfaW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5sb2dfaW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2dlb21ldHJpYyA9IEZvcl9uYXRpdmVpbnQuZ2VvbWV0cmljXG5sZXQgZmxvYXRfemVyb19leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgMC5cbmxldCBmbG9hdF96ZXJvX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSAwLlxuXG5sZXQgZmxvYXRfbWF4X3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9XG4gIEZsb2F0Lm9uZV91bHAgYERvd24gRmxvYXQubWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxuOztcblxubGV0IGZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQubWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIEZsb2F0Lm1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZSA9IEZsb2F0Lm1heF9maW5pdGVfdmFsdWVcbmxldCBmbG9hdF9taW5fbm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5taW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X25vcm1hbF9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9ub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIGZsb2F0X21heF9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9pbmZfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0LmluZmluaXR5XG5sZXQgZmxvYXRfaW5mX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBGbG9hdC5pbmZpbml0eVxubGV0IGZsb2F0X25hbl9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQubmFuXG5sZXQgZmxvYXRfbWluX25hbl9tYW50aXNzYSA9IEludDYzLnN1Y2MgZmxvYXRfaW5mX21hbnRpc3NhXG5sZXQgZmxvYXRfbWF4X25hbl9tYW50aXNzYSA9IGZsb2F0X21heF9ub3JtYWxfbWFudGlzc2FcbmxldCBmbG9hdF9udW1fbWFudGlzc2FfYml0cyA9IDUyXG5cbigqIFdlIHdlaWdodCBtYW50aXNzYXMgc28gdGhhdCBcImludGVnZXItbGlrZVwiIHZhbHVlcywgYW5kIHZhbHVlcyB3aXRoIG9ubHkgYSBmZXcgZGlnaXRzXG4gICBwYXN0IHRoZSBkZWNpbWFsLCBhcmUgcmVhc29uYWJseSBjb21tb24uICopXG5sZXQgZmxvYXRfbm9ybWFsX21hbnRpc3NhID1cbiAgbGV0JWJpbmQgbnVtX2JpdHMgPSBGb3JfaW50LnVuaWZvcm1faW5jbHVzaXZlIDAgZmxvYXRfbnVtX21hbnRpc3NhX2JpdHMgaW5cbiAgbGV0JW1hcCBiaXRzID1cbiAgICBGb3JfaW50NjMuaW5jbHVzaXZlIEludDYzLnplcm8gKEludDYzLnByZWQgKEludDYzLnNoaWZ0X2xlZnQgSW50NjMub25lIG51bV9iaXRzKSlcbiAgaW5cbiAgSW50NjMuc2hpZnRfbGVmdCBiaXRzIChJbnQuKCAtICkgZmxvYXRfbnVtX21hbnRpc3NhX2JpdHMgbnVtX2JpdHMpXG47O1xuXG5sZXQgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfbG93IGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0JW1hcCBvZmZzZXQgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmUgMCAoSW50LiggLSApIHVwcGVyX2JvdW5kIGxvd2VyX2JvdW5kKSBpblxuICBJbnQuKCArICkgbG93ZXJfYm91bmQgb2Zmc2V0XG47O1xuXG5sZXQgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfaGlnaCBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCA9XG4gIGxldCVtYXAgb2Zmc2V0ID0gRm9yX2ludC5sb2dfaW5jbHVzaXZlIDAgKEludC4oIC0gKSB1cHBlcl9ib3VuZCBsb3dlcl9ib3VuZCkgaW5cbiAgSW50LiggLSApIHVwcGVyX2JvdW5kIG9mZnNldFxuOztcblxuKCogV2Ugd2VpZ2h0IGV4cG9uZW50cyBzdWNoIHRoYXQgdmFsdWVzIG5lYXIgMSBhcmUgbW9yZSBsaWtlbHkuICopXG5sZXQgZmxvYXRfZXhwb25lbnQgPVxuICBsZXQgbWlkcG9pbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IDEuIGluXG4gIHVuaW9uXG4gICAgWyBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9oaWdoIGZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQgbWlkcG9pbnRcbiAgICA7IGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2xvdyBtaWRwb2ludCBmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50XG4gICAgXVxuOztcblxubGV0IGZsb2F0X3plcm8gPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbCBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG5cbiAgICB+bmVnYXRpdmVcbiAgICB+ZXhwb25lbnQ6ZmxvYXRfemVyb19leHBvbmVudFxuICAgIH5tYW50aXNzYTpmbG9hdF96ZXJvX21hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfc3Vibm9ybWFsID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gcmV0dXJuIGZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPVxuICAgIEZvcl9pbnQ2My5sb2dfaW5jbHVzaXZlIGZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EgZmxvYXRfbWF4X3N1Ym5vcm1hbF9tYW50aXNzYVxuICBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9ub3JtYWwgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSBmbG9hdF9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPSBmbG9hdF9ub3JtYWxfbWFudGlzc2EgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfaW5maW5pdGUgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbCBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG5cbiAgICB+bmVnYXRpdmVcbiAgICB+ZXhwb25lbnQ6ZmxvYXRfaW5mX2V4cG9uZW50XG4gICAgfm1hbnRpc3NhOmZsb2F0X2luZl9tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X25hbiA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IHJldHVybiBmbG9hdF9uYW5fZXhwb25lbnRcbiAgYW5kIG1hbnRpc3NhID0gRm9yX2ludDYzLmluY2x1c2l2ZSBmbG9hdF9taW5fbmFuX21hbnRpc3NhIGZsb2F0X21heF9uYW5fbWFudGlzc2EgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfb2ZfY2xhc3MgYyA9XG4gIG1hdGNoIChjIDogRmxvYXQuQ2xhc3MudCkgd2l0aFxuICB8IFplcm8gLT4gZmxvYXRfemVyb1xuICB8IFN1Ym5vcm1hbCAtPiBmbG9hdF9zdWJub3JtYWxcbiAgfCBOb3JtYWwgLT4gZmxvYXRfbm9ybWFsXG4gIHwgSW5maW5pdGUgLT4gZmxvYXRfaW5maW5pdGVcbiAgfCBOYW4gLT4gZmxvYXRfbmFuXG47O1xuXG5sZXQgZmxvYXRfd2VpZ2h0X29mX2NsYXNzIGMgPVxuICBtYXRjaCAoYyA6IEZsb2F0LkNsYXNzLnQpIHdpdGhcbiAgfCBaZXJvIC0+IDEuXG4gIHwgU3Vibm9ybWFsIC0+IDEwLlxuICB8IE5vcm1hbCAtPiAxMDAuXG4gIHwgSW5maW5pdGUgLT4gMS5cbiAgfCBOYW4gLT4gMS5cbjs7XG5cbmxldCBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIGZpbHRlciA9XG4gIExpc3QuZmlsdGVyX21hcCBGbG9hdC5DbGFzcy5hbGwgfmY6KGZ1biBjIC0+XG4gICAgaWYgZmlsdGVyIGMgdGhlbiBTb21lIChmbG9hdF93ZWlnaHRfb2ZfY2xhc3MgYywgZmxvYXRfb2ZfY2xhc3MgYykgZWxzZSBOb25lKVxuICB8PiB3ZWlnaHRlZF91bmlvblxuOztcblxubGV0IGZsb2F0X2Zpbml0ZSA9XG4gIGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1bmN0aW9uXG4gICAgfCBaZXJvIHwgU3Vibm9ybWFsIHwgTm9ybWFsIC0+IHRydWVcbiAgICB8IEluZmluaXRlIHwgTmFuIC0+IGZhbHNlKVxuOztcblxubGV0IGZsb2F0X3dpdGhvdXRfbmFuID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFplcm8gfCBTdWJub3JtYWwgfCBOb3JtYWwgfCBJbmZpbml0ZSAtPiB0cnVlXG4gICAgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXQgPSBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW4gXyAtPiB0cnVlKVxuXG5sZXQgZmxvYXRfZmluaXRlX25vbl96ZXJvID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFN1Ym5vcm1hbCB8IE5vcm1hbCAtPiB0cnVlXG4gICAgfCBaZXJvIHwgSW5maW5pdGUgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXRfc3RyaWN0bHlfcG9zaXRpdmUgPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGVfbm9uX3plcm8gaW5cbiAgRmxvYXQuYWJzIHRcbjs7XG5cbmxldCBmbG9hdF9zdHJpY3RseV9uZWdhdGl2ZSA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZV9ub25femVybyBpblxuICB+LS4oRmxvYXQuYWJzIHQpXG47O1xuXG5sZXQgZmxvYXRfcG9zaXRpdmVfb3JfemVybyA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZSBpblxuICBGbG9hdC5hYnMgdFxuOztcblxubGV0IGZsb2F0X25lZ2F0aXZlX29yX3plcm8gPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGUgaW5cbiAgfi0uKEZsb2F0LmFicyB0KVxuOztcblxubGV0IGZsb2F0X3VuaWZvcm1fZXhjbHVzaXZlIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0IG9wZW4gRmxvYXQuTyBpblxuICBpZiAobm90IChGbG9hdC5pc19maW5pdGUgbG93ZXJfYm91bmQpKSB8fCBub3QgKEZsb2F0LmlzX2Zpbml0ZSB1cHBlcl9ib3VuZClcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkZsb2F0LnVuaWZvcm1fZXhjbHVzaXZlOiBib3VuZHMgYXJlIG5vdCBmaW5pdGVcIlxuICAgICAgICAgIChsb3dlcl9ib3VuZCA6IGZsb2F0KVxuICAgICAgICAgICh1cHBlcl9ib3VuZCA6IGZsb2F0KV07XG4gIGxldCBsb3dlcl9pbmNsdXNpdmUgPSBGbG9hdC5vbmVfdWxwIGBVcCBsb3dlcl9ib3VuZCBpblxuICBsZXQgdXBwZXJfaW5jbHVzaXZlID0gRmxvYXQub25lX3VscCBgRG93biB1cHBlcl9ib3VuZCBpblxuICBpZiBsb3dlcl9pbmNsdXNpdmUgPiB1cHBlcl9pbmNsdXNpdmVcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkZsb2F0LnVuaWZvcm1fZXhjbHVzaXZlOiByZXF1ZXN0ZWQgcmFuZ2UgaXMgZW1wdHlcIlxuICAgICAgICAgIChsb3dlcl9ib3VuZCA6IGZsb2F0KVxuICAgICAgICAgICh1cHBlcl9ib3VuZCA6IGZsb2F0KV07XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLmZsb2F0IHJhbmRvbSB+bG86bG93ZXJfaW5jbHVzaXZlIH5oaTp1cHBlcl9pbmNsdXNpdmUpXG47O1xuXG5sZXQgZmxvYXRfaW5jbHVzaXZlIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgaWYgRmxvYXQuZXF1YWwgbG93ZXJfYm91bmQgdXBwZXJfYm91bmRcbiAgdGhlbiByZXR1cm4gbG93ZXJfYm91bmRcbiAgZWxzZSBpZiBGbG9hdC4oID0gKSAoRmxvYXQub25lX3VscCBgVXAgbG93ZXJfYm91bmQpIHVwcGVyX2JvdW5kXG4gIHRoZW4gdW5pb24gWyByZXR1cm4gbG93ZXJfYm91bmQ7IHJldHVybiB1cHBlcl9ib3VuZCBdXG4gIGVsc2VcbiAgICB3ZWlnaHRlZF91bmlvblxuICAgICAgWyAwLjA1LCByZXR1cm4gbG93ZXJfYm91bmRcbiAgICAgIDsgMC4wNSwgcmV0dXJuIHVwcGVyX2JvdW5kXG4gICAgICA7IDAuOSwgZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmRcbiAgICAgIF1cbjs7XG5cbmxldCBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aCA9XG4gIGxpc3Rfd2l0aF9sZW5ndGggY2hhcl9nZW4gfmxlbmd0aCB8PiBtYXAgfmY6U3RyaW5nLm9mX2NoYXJfbGlzdFxuOztcblxubGV0IHN0cmluZ19vZiBjaGFyX2dlbiA9XG4gIGJpbmQgc21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQgfmY6KGZ1biBsZW5ndGggLT5cbiAgICBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aClcbjs7XG5cbmxldCBzdHJpbmdfbm9uX2VtcHR5X29mIGNoYXJfZ2VuID1cbiAgYmluZCBzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQgfmY6KGZ1biBsZW5ndGggLT5cbiAgICBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aClcbjs7XG5cbmxldCBzdHJpbmcgPSBzdHJpbmdfb2YgY2hhclxubGV0IHN0cmluZ19ub25fZW1wdHkgPSBzdHJpbmdfbm9uX2VtcHR5X29mIGNoYXJcbmxldCBzdHJpbmdfd2l0aF9sZW5ndGggfmxlbmd0aCA9IHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyIH5sZW5ndGhcblxubW9kdWxlIEVkaXRfc3RyaW5nID0gc3RydWN0XG4gIGxldCBlZGl0X2luc2VydCBzdHJpbmcgPVxuICAgIGxldCViaW5kIHBvcyA9IGludF91bmlmb3JtX2luY2x1c2l2ZSAwIChTdHJpbmcubGVuZ3RoIHN0cmluZykgaW5cbiAgICBsZXQlYmluZCBsZW4gPSBpbnRfZ2VvbWV0cmljIDEgfnA6MC41IGluXG4gICAgbGV0JWJpbmQgc3RyID0gc3RyaW5nX3dpdGhfbGVuZ3RoIH5sZW5ndGg6bGVuIGluXG4gICAgWyBTdHJpbmcucHJlZml4IHN0cmluZyBwb3M7IHN0cjsgU3RyaW5nLmRyb3BfcHJlZml4IHN0cmluZyBwb3MgXVxuICAgIHw+IFN0cmluZy5jb25jYXRcbiAgICB8PiByZXR1cm5cbiAgOztcblxuICBsZXQgZWRpdF9yZW1vdmUgc3RyaW5nID1cbiAgICBsZXQlYmluZCBsZW4gPSBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgKFN0cmluZy5sZW5ndGggc3RyaW5nKSBpblxuICAgIGxldCViaW5kIHBvcyA9IGludF91bmlmb3JtX2luY2x1c2l2ZSAwIChTdHJpbmcubGVuZ3RoIHN0cmluZyAtIGxlbikgaW5cbiAgICBbIFN0cmluZy5wcmVmaXggc3RyaW5nIHBvczsgU3RyaW5nLmRyb3BfcHJlZml4IHN0cmluZyAocG9zICsgbGVuKSBdXG4gICAgfD4gU3RyaW5nLmNvbmNhdFxuICAgIHw+IHJldHVyblxuICA7O1xuXG4gIGxldCBlZGl0X3JlcGxhY2Ugc3RyaW5nID1cbiAgICBsZXQlYmluZCBsZW4gPSBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgKFN0cmluZy5sZW5ndGggc3RyaW5nKSBpblxuICAgIGxldCViaW5kIHBvcyA9IGludF91bmlmb3JtX2luY2x1c2l2ZSAwIChTdHJpbmcubGVuZ3RoIHN0cmluZyAtIGxlbikgaW5cbiAgICBsZXQlYmluZCBzdHIgPSBzdHJpbmdfd2l0aF9sZW5ndGggfmxlbmd0aDpsZW4gaW5cbiAgICBbIFN0cmluZy5wcmVmaXggc3RyaW5nIHBvczsgc3RyOyBTdHJpbmcuZHJvcF9wcmVmaXggc3RyaW5nIChwb3MgKyBsZW4pIF1cbiAgICB8PiBTdHJpbmcuY29uY2F0XG4gICAgfD4gcmV0dXJuXG4gIDs7XG5cbiAgbGV0IGVkaXRfZG91YmxlIHN0cmluZyA9XG4gICAgbGV0JWJpbmQgbGVuID0gaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSAxIChTdHJpbmcubGVuZ3RoIHN0cmluZykgaW5cbiAgICBsZXQlYmluZCBwb3MgPSBpbnRfdW5pZm9ybV9pbmNsdXNpdmUgMCAoU3RyaW5nLmxlbmd0aCBzdHJpbmcgLSBsZW4pIGluXG4gICAgWyBTdHJpbmcucHJlZml4IHN0cmluZyAocG9zICsgbGVuKTsgU3RyaW5nLmRyb3BfcHJlZml4IHN0cmluZyBwb3MgXVxuICAgIHw+IFN0cmluZy5jb25jYXRcbiAgICB8PiByZXR1cm5cbiAgOztcblxuICBsZXQgZWRpdF9ub25lbXB0eSBzdHJpbmcgPVxuICAgIFsgZWRpdF9pbnNlcnQgc3RyaW5nOyBlZGl0X3JlbW92ZSBzdHJpbmc7IGVkaXRfcmVwbGFjZSBzdHJpbmc7IGVkaXRfZG91YmxlIHN0cmluZyBdXG4gICAgfD4gdW5pb25cbiAgOztcblxuICBsZXQgcmVjIGVkaXQgc3RyaW5nIG5fdGltZXMgPVxuICAgIGlmIG5fdGltZXMgPD0gMFxuICAgIHRoZW4gcmV0dXJuIHN0cmluZ1xuICAgIGVsc2UgKFxuICAgICAgbGV0JWJpbmQgc3RyaW5nID1cbiAgICAgICAgaWYgU3RyaW5nLmlzX2VtcHR5IHN0cmluZyB0aGVuIGVkaXRfaW5zZXJ0IHN0cmluZyBlbHNlIGVkaXRfbm9uZW1wdHkgc3RyaW5nXG4gICAgICBpblxuICAgICAgZWRpdCBzdHJpbmcgKG5fdGltZXMgLSAxKSlcbiAgOztcbmVuZFxuXG5sZXQgc3RyaW5nX2xpa2Ugc3RyaW5nID1cbiAgbGV0JWJpbmQgbl90aW1lcyA9IGludF9nZW9tZXRyaWMgMCB+cDowLjUgaW5cbiAgRWRpdF9zdHJpbmcuZWRpdCBzdHJpbmcgbl90aW1lc1xuOztcblxubGV0IGJ5dGVzID0gbWFwIHN0cmluZyB+ZjpCeXRlcy5vZl9zdHJpbmdcblxubGV0IHNleHBfb2YgYXRvbSA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2VsZiAtPlxuICAgIGxldCViaW5kIHNpemUgPSBzaXplIGluXG4gICAgKCogY2hvb3NlIGEgbnVtYmVyIHdlaWdodGVkIGxvdyBzbyB3ZSBoYXZlIGEgZGVjcmVhc2luZywgYnV0IG5vdCB2YW5pc2hpbmcsIGNoYW5jZVxuICAgICAgIHRvIGdlbmVyYXRlIGF0b21zIGFzIHNpemUgZ3Jvd3MgKilcbiAgICBtYXRjaCViaW5kIEZvcl9pbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlIDAgKHNpemUgKyAxKSB3aXRoXG4gICAgKCogZ2VuZXJhdGUgYW4gYXRvbSB1c2luZyB0aGUgZ2l2ZW4gc2l6ZSAqKVxuICAgIHwgMCAtPlxuICAgICAgbGV0JW1hcCBhdG9tID0gYXRvbSBpblxuICAgICAgU2V4cC5BdG9tIGF0b21cbiAgICAoKiByZWx5aW5nIG9uIFtMaXN0Lmdlbl0gdG8gZGlzdHJpYnV0ZSBbc2l6ZV0gb3ZlciBzdWItc2V4cHMgKilcbiAgICB8IF8gLT5cbiAgICAgIGxldCVtYXAgbGlzdCA9IGxpc3Qgc2VsZiBpblxuICAgICAgU2V4cC5MaXN0IGxpc3QpXG47O1xuXG5sZXQgc2V4cCA9IHNleHBfb2Ygc3RyaW5nXG5cbmxldCBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW4gPVxuICBsZXQlYmluZCBrZXlzID0gbGlzdCBrZXlfZ2VuIGluXG4gIGxldCBrZXlzID0gTGlzdC5kZWR1cF9hbmRfc29ydCBrZXlzIH5jb21wYXJlOmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gIGxldCViaW5kIGRhdGEgPSBsaXN0X3dpdGhfbGVuZ3RoIGRhdGFfZ2VuIH5sZW5ndGg6KExpc3QubGVuZ3RoIGtleXMpIGluXG4gIHJldHVybiAoTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgKExpc3QuemlwX2V4biBrZXlzIGRhdGEpKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X2dlbiA9XG4gIG1hcCAobGlzdCBlbHRfZ2VuKSB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9saXN0IH5jb21wYXJhdG9yKVxuOztcblxubGV0IGNvbXBhcmF0b3Jfb2ZfbVxuICAgICAgKHR5cGUgYSBjKVxuICAgICAgKG1vZHVsZSBNIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjKVxuICA9XG4gIE0uY29tcGFyYXRvclxuOztcblxubGV0IG1hcF90X20gbSBrZXlfZ2VuIGRhdGFfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW5cbiAgfD4gbWFwIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IHNldF90X20gbSBlbHRfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF9nZW5cbiAgfD4gbWFwIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IGJpZ2FycmF5MSB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JW1hcCBlbHRzID0gbGlzdCB0IGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBkaW0gPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICBCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5pbml0IGtpbmQgbGF5b3V0IGRpbSB+ZjooZnVuIGkgLT4gZWx0cy4oaSAtIG9mZnNldCkpXG47O1xuXG5sZXQgYmlnc3RyaW5nID0gYmlnYXJyYXkxIGNoYXIgQ2hhciBDX2xheW91dFxubGV0IGZsb2F0MzJfdmVjID0gYmlnYXJyYXkxIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X3ZlYyA9IGJpZ2FycmF5MSBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbmxldCBiaWdhcnJheTJfZGltID1cbiAgbWF0Y2glYmluZCBzaXplIHdpdGhcbiAgfCAwIC0+IHJldHVybiAoMCwgMClcbiAgfCBtYXhfdG90YWxfc2l6ZSAtPlxuICAgIGxldCViaW5kIGEgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZV0sIHdlaWdodGVkIGxvdyB0byBnaXZlIHRoZSBvdGhlclxuICAgICAgICAgZGltZW5zaW9uIGEgZ29vZCBjaGFuY2Ugb2YgYmVpbmcgY29tcGFyYXRpdmVseSBoaWdoICopXG4gICAgICBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgbWF4X3RvdGFsX3NpemVcbiAgICBpblxuICAgIGxldCViaW5kIGIgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZSAvIGFdLCB3ZWlnaHRlZCBoaWdoIHRvIHJlYWNoIGNsb3NlIHRvXG4gICAgICAgICBbbWF4X3RvdGFsX3NpemVdIG1vc3Qgb2YgdGhlIHRpbWUgKilcbiAgICAgIGxldCBtYXhfYiA9IG1heF90b3RhbF9zaXplIC8gYSBpblxuICAgICAgbGV0JW1hcCBiX3dlaWdodGVkX2xvdyA9IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMCBtYXhfYiBpblxuICAgICAgbWF4X2IgLSBiX3dlaWdodGVkX2xvd1xuICAgIGluXG4gICAgKCogYXZvaWQgYW55IHNrZXcgb2YgYSB2cyBiIGJ5IHJhbmRvbWx5IHN3YXBwaW5nICopXG4gICAgaWYlbWFwIGJvb2wgdGhlbiBhLCBiIGVsc2UgYiwgYVxuOztcblxubGV0IGJpZ2FycmF5MiB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JWJpbmQgZGltMSwgZGltMiA9IGJpZ2FycmF5Ml9kaW0gaW5cbiAgbGV0JW1hcCBlbHRzID0gbGlzdF93aXRoX2xlbmd0aCB+bGVuZ3RoOmRpbTEgKGxpc3Rfd2l0aF9sZW5ndGggfmxlbmd0aDpkaW0yIHQpIGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdF9tYXAgfmY6QXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkyLmluaXQga2luZCBsYXlvdXQgZGltMSBkaW0yIH5mOihmdW4gaSBqIC0+XG4gICAgZWx0cy4oaSAtIG9mZnNldCkuKGogLSBvZmZzZXQpKVxuOztcblxubGV0IGZsb2F0MzJfbWF0ID0gYmlnYXJyYXkyIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X21hdCA9IGJpZ2FycmF5MiBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBEZWJ1ZyA9IHN0cnVjdFxuICBsZXQgY292ZXJhZ2VcbiAgICAgICAgKHR5cGUgayBjbXApXG4gICAgICAgIChtb2R1bGUgQ21wIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICAgIHNhbXBsZVxuICAgID1cbiAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICBzYW1wbGVcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgKG1vZHVsZSBDbXApKVxuICAgICAgfmY6KGZ1biBjb3VudHMgdmFsdWUgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBjb3VudHMgdmFsdWUgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBwcmV2ICsgMSkpXG4gIDs7XG5cbiAgbGV0IG1vbml0b3IgdCB+ZiA9XG4gICAgbWFwIHQgfmY6KGZ1biB2YWx1ZSAtPlxuICAgICAgZiB2YWx1ZTtcbiAgICAgIHZhbHVlKVxuICA7O1xuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjczOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfYmFfZGltXzEiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2JhX2xheW91dCIsImNhbWxfb2JqX3RhZyIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIkJhc2VfU2V0IiwiQmFzZV9NYXAiLCJCYXNlX1NlcXVlbmNlIiwiQmFzZV9MaXN0IiwiQmFzZV9FaXRoZXIiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9MYXp5IiwiQmFzZV9BcnJheSIsIkJhc2VfT3B0aW9uIiwiQmFzZV9GaWVsZCIsIkJhc2VfcXVpY2tjaGVja19CaWdhcnJheV9oZWxwZSIsIkJhc2VfSW50IiwiQmFzZV9TdHJpbmciLCJCYXNlX0J5dGVzIiwiYXRvbWljIiwicGFyYW0iLCJjcmVhdGUiLCJzaHJpbmsiLCJtYXAiLCJ0IiwiZl9pbnZlcnNlIiwieCIsImZpbHRlciIsImZpbHRlcl9tYXAiLCJvZl9sYXp5IiwibGF6eV90IiwiZml4ZWRfcG9pbnQiLCJvZl9zaHJpbmtlciIsImJvdGgiLCJmc3RfdCIsInNuZF90Iiwic25kIiwiZnN0IiwiZmxvYXQzMl92ZWMiLCJzcmMiLCJkaW0iLCJraW5kIiwibGF5b3V0Iiwib2Zmc2V0IiwidG9fc2tpcCIsImkiLCJkaW0yIiwiciIsImRpbTEiLCJ2IiwiZmllbGQiLCJkaW1zIiwibWF0Y2giLCJza2lwIiwiZmxvYXQzMl9tYXQiLCJvcHRpb24iLCJ2YWx1ZV90IiwidmFsdWUiLCJsaXN0IiwiZWx0X3QiLCJsaXN0X3QiLCJ0YWlsIiwiaGVhZCIsInN0cmluZyIsImJ5dGVzIiwiYXJyYXkiLCJyZWYiLCJzZXhwIiwic2hyaW5rZXIiLCJsIiwic2hyaW5rX2xpc3QiLCJzaHJpbmtfdHJlZSIsImVpdGhlciIsInJlc3VsdCIsIm9rX3QiLCJlcnJfdCIsIm9rIiwiZXJyIiwibWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciIsImNvbXBhcmF0b3IiLCJrZXlfdCIsImRhdGFfdCIsInRyZWUiLCJhbGlzdCIsImRyb3Bfa2V5cyIsImsiLCJkYXRhIiwia2V5Iiwic21hbGxlcl9rZXkiLCJzaHJpbmtfa2V5cyIsInNtYWxsZXJfZGF0YSIsInNocmlua19kYXRhIiwic2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciIsImRyb3BfZWx0cyIsImVsdCIsInNtYWxsZXJfZWx0Iiwic2hyaW5rX2VsdHMiLCJtYXBfdCIsInNldF90IiwiQmFzZV9xdWlja2NoZWNrX1Nocmlua2VyIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2VfcXVpY2tjaGVjay9zaHJpbmtlci5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFB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LElBSWxELGdCQUFBZ0I7QUFBQUE7QUFBQUEsTUFBQWxCLGFBQ21CO0FBQUEsWUFJVjtBQUFBO0FBQUEsTUFBQXZELElBRkwsSUFDRTtBQUFBLEtBSUosZUFBYyxFQVJoQjtBQUFBLEdBUWlCO0FBQUEsWUFBQTBFLE1BQUF2QztBQUFBQSxJQUlqQixnQkFBQXVDO0FBQUFBO0FBQUFBLE1BQUFuQixhQUNtQjtBQUFBLFlBSVY7QUFBQTtBQUFBLE1BQUF2RCxJQUZMLElBQ0U7QUFBQSxLQUlKLGVBQWMsRUFSaEI7QUFBQSxHQVFpQjtBQUFBO0FBQUEsSUFBQTJFO0FBQUFBLE1BeEZ3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQxSTNEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBUIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBhdG9taWMgOiBfIHRcbiAgdmFsIGNyZWF0ZSA6ICgnYSAtPiAnYSBTZXF1ZW5jZS50KSAtPiAnYSB0XG4gIHZhbCBzaHJpbmsgOiAnYSB0IC0+ICdhIC0+ICdhIFNlcXVlbmNlLnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgbGV0IGF0b21pYyBfID0gU2VxdWVuY2UuZW1wdHlcbiAgbGV0IGNyZWF0ZSA9IEZuLmlkXG4gIGxldCBzaHJpbmsgPSBGbi5pZFxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgbWFwIHQgfmYgfmZfaW52ZXJzZSA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UubWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbmxldCBmaWx0ZXIgdCB+ZiA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UuZmlsdGVyIH5mIChzaHJpbmsgdCB4KSlcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiB+Zl9pbnZlcnNlID1cbiAgY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5maWx0ZXJfbWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbjs7XG5cbmxldCBvZl9sYXp5IGxhenlfdCA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2Uub2ZfbGF6eSAobGF6eSAoc2hyaW5rIChmb3JjZSBsYXp5X3QpIHgpKSlcblxubGV0IGZpeGVkX3BvaW50IG9mX3Nocmlua2VyID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9zaHJpbmtlciAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBvZl9sYXp5IGxhenlfdFxuOztcblxubGV0IGJvdGggZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biAoZnN0LCBzbmQpIC0+XG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgIFsgU2VxdWVuY2UubWFwIChzaHJpbmsgZnN0X3QgZnN0KSB+ZjooZnVuIGZzdCAtPiBmc3QsIHNuZClcbiAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgc25kX3Qgc25kKSB+ZjooZnVuIHNuZCAtPiBmc3QsIHNuZClcbiAgICAgIF0pXG47O1xuXG5sZXQgdW5pdCA9IGF0b21pY1xubGV0IGJvb2wgPSBhdG9taWNcbmxldCBjaGFyID0gYXRvbWljXG5sZXQgaW50ID0gYXRvbWljXG5sZXQgaW50MzIgPSBhdG9taWNcbmxldCBpbnQ2MyA9IGF0b21pY1xubGV0IGludDY0ID0gYXRvbWljXG5sZXQgbmF0aXZlaW50ID0gYXRvbWljXG5sZXQgZmxvYXQgPSBhdG9taWNcblxubGV0IGJpZ2FycmF5MSBzcmMgPVxuICBsZXQgZGltID0gQmlnYXJyYXkuQXJyYXkxLmRpbSBzcmMgaW5cbiAgbWF0Y2ggZGltIHdpdGhcbiAgfCAwIC0+IFNlcXVlbmNlLmVtcHR5XG4gIHwgXyAtPlxuICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkxLmtpbmQgc3JjIGluXG4gICAgbGV0IGxheW91dCA9IEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgc3JjIGluXG4gICAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgICBTZXF1ZW5jZS5pbml0IGRpbSB+ZjooZnVuIHRvX3NraXAgLT5cbiAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaW5pdCBraW5kIGxheW91dCAoZGltIC0gMSkgfmY6KGZ1biBpIC0+XG4gICAgICAgIHNyYy57aWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDF9KSlcbjs7XG5cbmxldCBiaWdzdHJpbmcgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQzMl92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQ2NF92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5cbmxldCBiaWdhcnJheTIgPVxuICBsZXQgbW9kdWxlIERpbXMgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBkaW0xIDogaW50XG4gICAgICA7IGRpbTIgOiBpbnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICBsZXQgY3JlYXRlIGEgPSBCaWdhcnJheS5BcnJheTIueyBkaW0xID0gZGltMSBhOyBkaW0yID0gZGltMiBhIH1cbiAgZW5kXG4gIGluXG4gIGxldCBzaHJpbmsgZmllbGQgc3JjID1cbiAgICBsZXQgZGltcyA9IERpbXMuY3JlYXRlIHNyYyBpblxuICAgIG1hdGNoIEZpZWxkLmdldCBmaWVsZCBkaW1zIHdpdGhcbiAgICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgICB8IF8gLT5cbiAgICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkyLmtpbmQgc3JjIGluXG4gICAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkyLmxheW91dCBzcmMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCBkaW1zIH5mOkludC5wcmVkIGluXG4gICAgICBTZXF1ZW5jZS5pbml0IChGaWVsZC5nZXQgZmllbGQgZGltcykgfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgICBsZXQgc2tpcCBpID0gaWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDEgaW5cbiAgICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaW5pdCBraW5kIGxheW91dCBkaW0xIGRpbTIgfmY6KGZ1biBkaW0xIGRpbTIgLT5cbiAgICAgICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCB7IGRpbTE7IGRpbTIgfSB+Zjpza2lwIGluXG4gICAgICAgICAgc3JjLntkaW0xLCBkaW0yfSkpXG4gIGluXG4gIGZ1biBzcmMgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmluayBEaW1zLkZpZWxkcy5kaW0xIHNyYzsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTIgc3JjIF1cbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcbmxldCBmbG9hdDY0X21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcblxubGV0IG9wdGlvbiB2YWx1ZV90ID1cbiAgY3JlYXRlIChmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgU2VxdWVuY2UuYXBwZW5kXG4gICAgICAgIChTZXF1ZW5jZS5zaW5nbGV0b24gTm9uZSlcbiAgICAgICAgKFNlcXVlbmNlLm1hcCB+ZjpPcHRpb24ucmV0dXJuIChzaHJpbmsgdmFsdWVfdCB2YWx1ZSkpKVxuOztcblxubGV0IGxpc3QgZWx0X3QgPVxuICBmaXhlZF9wb2ludCAoZnVuIGxpc3RfdCAtPlxuICAgIGNyZWF0ZSAoZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gU2VxdWVuY2UuZW1wdHlcbiAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgICAgWyBTZXF1ZW5jZS5zaW5nbGV0b24gdGFpbFxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgZWx0X3QgaGVhZCkgfmY6KGZ1biBoZWFkIC0+IGhlYWQgOjogdGFpbClcbiAgICAgICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGxpc3RfdCB0YWlsKSB+ZjooZnVuIHRhaWwgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIF0pKVxuOztcblxubGV0IHN0cmluZyA9IG1hcCAobGlzdCBjaGFyKSB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0IH5mX2ludmVyc2U6U3RyaW5nLnRvX2xpc3RcbmxldCBieXRlcyA9IG1hcCBzdHJpbmcgfmY6Qnl0ZXMub2Zfc3RyaW5nIH5mX2ludmVyc2U6Qnl0ZXMudG9fc3RyaW5nXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0IH5mX2ludmVyc2U6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZSB+Zl9pbnZlcnNlOlJlZi4oICEgKVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbCB+Zl9pbnZlcnNlOkxhenkuZm9yY2VcblxubGV0IHNleHAgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNocmlua2VyIC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBTZXhwLkF0b20gXyAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBTZXhwLkxpc3QgbCAtPlxuICAgICAgICBsZXQgc2hyaW5rX2xpc3QgPVxuICAgICAgICAgIHNocmluayAobGlzdCBzaHJpbmtlcikgbCB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBsIC0+IFNleHAuTGlzdCBsKVxuICAgICAgICBpblxuICAgICAgICBsZXQgc2hyaW5rX3RyZWUgPSBTZXF1ZW5jZS5vZl9saXN0IGwgaW5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBzaHJpbmtfbGlzdDsgc2hyaW5rX3RyZWUgXSkpXG47O1xuXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gZWl0aGVyIC0+XG4gICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGZzdCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOkVpdGhlci5maXJzdFxuICAgIHwgU2Vjb25kIHNuZCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOkVpdGhlci5zZWNvbmQpXG47O1xuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXBcbiAgICAoZWl0aGVyIG9rX3QgZXJyX3QpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuICAgIH5mX2ludmVyc2U6KGZ1bmN0aW9uXG4gICAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgICB8IEVycm9yIGVyciAtPiBTZWNvbmQgZXJyKVxuOztcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gdHJlZSAtPlxuICAgIGxldCBhbGlzdCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fYWxpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2tleXMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGFsaXN0KSB+ZjooZnVuIChrLCBfKSAtPlxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGspXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2tleXMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGtleSBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsga2V5X3Qga2V5KSB+ZjooZnVuIHNtYWxsZXJfa2V5IC0+XG4gICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuYWRkIH5jb21wYXJhdG9yIHRyZWUgfmtleTpzbWFsbGVyX2tleSB+ZGF0YVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IGBPayB0cmVlIC0+IFNvbWUgdHJlZVxuICAgICAgICAgICAgIHwgYER1cGxpY2F0ZSAtPiBOb25lKSkpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2RhdGEgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgU2VxdWVuY2UubWFwIChzaHJpbmsgZGF0YV90IGRhdGEpIH5mOihmdW4gc21hbGxlcl9kYXRhIC0+XG4gICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5zZXQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5IH5kYXRhOnNtYWxsZXJfZGF0YSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2tleXM7IHNocmlua19rZXlzOyBzaHJpbmtfZGF0YSBdKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGxpc3QgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2xpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2VsdHMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGxpc3QpIH5mOihmdW4gZWx0IC0+XG4gICAgICAgIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgZWx0KVxuICAgIGluXG4gICAgbGV0IHNocmlua19lbHRzID1cbiAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgIChMaXN0Lm1hcCBsaXN0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIGxldCB0cmVlID0gU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQgaW5cbiAgICAgICAgICAgU2VxdWVuY2UuZmlsdGVyX21hcCAoc2hyaW5rIGVsdF90IGVsdCkgfmY6KGZ1biBzbWFsbGVyX2VsdCAtPlxuICAgICAgICAgICAgIG1hdGNoIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUubWVtIH5jb21wYXJhdG9yIHRyZWUgc21hbGxlcl9lbHQgd2l0aFxuICAgICAgICAgICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgICAgICAgICAgfCBmYWxzZSAtPiBTb21lIChTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLmFkZCB0cmVlIH5jb21wYXJhdG9yIHNtYWxsZXJfZWx0KSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2VsdHM7IHNocmlua19lbHRzIF0pXG47O1xuXG5sZXQgbWFwX3Qga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gbWFwX3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIG1hcF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV90IGRhdGFfdClcbiAgICAgICAgfmY6KE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3IpXG4gICAgICAgIH5mX2ludmVyc2U6TWFwLlVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxuICAgIGluXG4gICAgc2hyaW5rIHQgbWFwX3QpXG47O1xuXG5sZXQgc2V0X3QgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biBzZXRfdCAtPlxuICAgIGxldCBjb21wYXJhdG9yID0gU2V0LmNvbXBhcmF0b3Igc2V0X3QgaW5cbiAgICBsZXQgdCA9XG4gICAgICBtYXBcbiAgICAgICAgKHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QpXG4gICAgICAgIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOlNldC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IHNldF90KVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMTk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2VfcXVpY2tjaGVjay5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9xdWlja2NoZWNrX1Rlc3RfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsNEJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMjEwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2VfcXVpY2tjaGVjay5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3NlZWQiLCJjc3Rfc2hyaW5rX2NvdW50IiwiY3N0X3NpemVzIiwiY3N0X3Rlc3RfY291bnQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJuYW1lcyIsIkJhc2VfQmFja3RyYWNlIiwiQmFzZV9Pcl9lcnJvciIsIkJhc2VfRXJyb3IiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJCYXNlX1NlcXVlbmNlIiwiQmFzZV9xdWlja2NoZWNrX0dlbmVyYXRvciIsIkJhc2VfcXVpY2tjaGVja19TaHJpbmtlciIsIkJhc2UiLCJTcGxpdHRhYmxlX3JhbmRvbSIsIkNhbWxpbnRlcm5hbExhenkiLCJCYXNlX1JhbmRvbSIsIkJhc2VfRmllbGQiLCJCYXNlX0xpc3QiLCJCYXNlX1dvcmRfc2l6ZSIsInNleHBfb2ZfdCIsInBhcmFtIiwiYXJnMF8wMDEiLCJyZXMwXzAwMiIsIlNlZWQiLCJzaXplcyIsInIiLCJzaHJpbmtfY291bnQiLCJ0ZXN0X2NvdW50Iiwic2VlZCIsInYiLCJtYWtlX2NyZWF0b3IiLCJzZWVkX2Z1biIsInRlc3RfY291bnRfZnVuIiwic2hyaW5rX2NvdW50X2Z1biIsInNpemVzX2Z1biIsImNvbXBpbGVfYWNjIiwibWF0Y2giLCJzZWVkX2dlbiIsInRlc3RfY291bnRfZ2VuIiwic2hyaW5rX2NvdW50X2dlbiIsInNpemVzX2dlbiIsImFjYyIsImNyZWF0ZSIsIm1hcCIsIml0ZXIiLCJmb2xkIiwiaW5pdCIsIm1hcF9wb2x5IiwicmVjb3JkIiwiZm9yX2FsbCIsImV4aXN0cyIsInRvX2xpc3QiLCJzZXRfYWxsX211dGFibGVfZmllbGRzIiwiRGlyZWN0Iiwic2l6ZXNfMDEwIiwic2hyaW5rX2NvdW50XzAwOCIsInRlc3RfY291bnRfMDA2Iiwic2VlZF8wMDQiLCJzZXhwX29mX2VsdCIsInN1ZmZpeCIsInByZWZpeCIsImJuZHNfMDAzIiwiYXJnXzAxMSIsImFyZ18wMDkiLCJhcmdfMDA3IiwiYXJnXzAwNSIsImNzdF9CYXNlX3F1aWNrY2hlY2tfVGVzdF9ydW5fdCIsImNzdF9CYXNlX3F1aWNrY2hlY2tfVGVzdF9ydW5faSIsImRlZmF1bHRfY29uZmlnIiwibGF6eV9ub25kZXRlcm1pbmlzdGljX3N0YXRlIiwid2l0aF9zYW1wbGUiLCJvcHQiLCJnZW5lcmF0b3IiLCJjb25maWciLCJleGFtcGxlcyIsInN0cmluZyIsInJhbmRvbSIsIm51bWJlcl9vZl9zaXplX3ZhbHVlcyIsInJlbWFpbmluZ19zaXplcyIsInNpemUiLCJzZXF1ZW5jZSIsInJlc3VsdCIsIm0iLCJpbnB1dCIsImVycm9yIiwic2hyaW5rZXIiLCJhbHRlcm5hdGVzIiwiYWx0ZXJuYXRlIiwicnVuIiwiTSIsIngiLCJ3aXRoX3NhbXBsZV9leG4iLCJydW5fZXhuIiwidGVzdGFibGUiLCJCYXNlX3F1aWNrY2hlY2tfVGVzdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlX3F1aWNrY2hlY2svdGVzdC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFB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LElBQWlDLHlDQUFtQjtBQUFBO0FBQUE7QUFBQSxJQUFBMEU7QUFBQUEsTUFqR2tDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEN0N4RiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxuaW5jbHVkZSBUZXN0X2ludGZcblxubW9kdWxlIENvbmZpZyA9IHN0cnVjdFxuICBtb2R1bGUgU2VlZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IE5vbmRldGVybWluaXN0aWNcbiAgICAgIHwgRGV0ZXJtaW5pc3RpYyBvZiBzdHJpbmdcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBtb2R1bGUgUG90ZW50aWFsbHlfaW5maW5pdGVfc2VxdWVuY2UgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBTZXF1ZW5jZS50XG5cbiAgICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IHNlcXVlbmNlID1cbiAgICAgIGxldCBwcmVmaXgsIHN1ZmZpeCA9IFNlcXVlbmNlLnNwbGl0X24gc2VxdWVuY2UgMTAwIGluXG4gICAgICBsZXQgcHJlZml4ID0gTGlzdC5tYXAgcHJlZml4IH5mOnNleHBfb2ZfZWx0IGluXG4gICAgICBsZXQgc3VmZml4ID1cbiAgICAgICAgbWF0Y2ggU2VxdWVuY2UuaXNfZW1wdHkgc3VmZml4IHdpdGhcbiAgICAgICAgfCB0cnVlIC0+IFtdXG4gICAgICAgIHwgZmFsc2UgLT4gWyBbJW1lc3NhZ2UgXCIuLi5cIl0gXVxuICAgICAgaW5cbiAgICAgIFNleHAuTGlzdCAocHJlZml4IEAgc3VmZml4KVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgdCA9XG4gICAgeyBzZWVkIDogU2VlZC50XG4gICAgOyB0ZXN0X2NvdW50IDogaW50XG4gICAgOyBzaHJpbmtfY291bnQgOiBpbnRcbiAgICA7IHNpemVzIDogaW50IFBvdGVudGlhbGx5X2luZmluaXRlX3NlcXVlbmNlLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cbmVuZFxuXG5sZXQgZGVmYXVsdF9jb25maWcgOiBDb25maWcudCA9XG4gIHsgc2VlZCA9IERldGVybWluaXN0aWMgXCJhbiBhcmJpdHJhcnkgYnV0IGRldGVybWluaXN0aWMgc3RyaW5nXCJcbiAgOyB0ZXN0X2NvdW50ID1cbiAgICAgICgqIFtTcGxpdHRhYmxlX3JhbmRvbV0gaXMgYmFzZWQgb24gNjQtYml0IGFyaXRobWV0aWMsIGFuZCBzbyB0ZXN0cyBydW4gbXVjaCBzbG93ZXJcbiAgICAgICAgIG9uIDMyLWJpdCB0YXJnZXRzLiBXZSBydW4gYW4gb3JkZXIgb2YgbWFnbml0dWRlIGZld2VyIHRyaWFscyBzbyBhcyBub3QgdG9cbiAgICAgICAgIGNvbXBsZXRlbHkgYm9nIGRvd24gY29udGludW91cyBpbnRlZ3JhdGlvbiBzeXN0ZW1zLiAqKVxuICAgICAgKG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgICAgIHwgVzY0IC0+IDEwXzAwMFxuICAgICAgIHwgVzMyIC0+IDFfMDAwKVxuICA7IHNocmlua19jb3VudCA9IDEwXzAwMFxuICA7IHNpemVzID0gU2VxdWVuY2UuY3ljbGVfbGlzdF9leG4gKExpc3QucmFuZ2UgMCB+c3RhcnQ6YGluY2x1c2l2ZSAzMCB+c3RvcDpgaW5jbHVzaXZlKVxuICB9XG47O1xuXG5sZXQgbGF6eV9ub25kZXRlcm1pbmlzdGljX3N0YXRlID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuXG5sZXQgaW5pdGlhbF9yYW5kb21fc3RhdGUgfmNvbmZpZyA9XG4gIG1hdGNoIENvbmZpZy5zZWVkIGNvbmZpZyB3aXRoXG4gIHwgTm9uZGV0ZXJtaW5pc3RpYyAtPiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5jcmVhdGUgKGZvcmNlIGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSlcbiAgfCBEZXRlcm1pbmlzdGljIHN0cmluZyAtPiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5vZl9pbnQgKFN0cmluZy5oYXNoIHN0cmluZylcbjs7XG5cbmxldCBvbmVfc2l6ZV9wZXJfdGVzdCB+KGNvbmZpZyA6IENvbmZpZy50KSA9XG4gIFNlcXVlbmNlLnVuZm9sZCB+aW5pdDooY29uZmlnLnNpemVzLCAwKSB+ZjooZnVuIChzaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzKSAtPlxuICAgIG1hdGNoIG51bWJlcl9vZl9zaXplX3ZhbHVlcyA+PSBjb25maWcudGVzdF9jb3VudCB3aXRoXG4gICAgfCB0cnVlIC0+IE5vbmVcbiAgICB8IGZhbHNlIC0+XG4gICAgICAobWF0Y2ggU2VxdWVuY2UubmV4dCBzaXplcyB3aXRoXG4gICAgICAgfCBTb21lIChzaXplLCByZW1haW5pbmdfc2l6ZXMpIC0+XG4gICAgICAgICBTb21lIChzaXplLCAocmVtYWluaW5nX3NpemVzLCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgKyAxKSlcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IGluc3VmZmljaWVudCBzaXplIHZhbHVlcyBmb3IgdGVzdCBjb3VudFwiXG4gICAgICAgICAgICAgICB+dGVzdF9jb3VudDooY29uZmlnLnRlc3RfY291bnQgOiBpbnQpXG4gICAgICAgICAgICAgICAobnVtYmVyX29mX3NpemVfdmFsdWVzIDogaW50KV0pKVxuOztcblxubGV0IHNocmlua19lcnJvciB+c2hyaW5rZXIgfmNvbmZpZyB+ZiBpbnB1dCBlcnJvciA9XG4gIGxldCByZWMgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGlucHV0IGVycm9yID1cbiAgICBtYXRjaCBzaHJpbmtfY291bnQgd2l0aFxuICAgIHwgMCAtPiBpbnB1dCwgZXJyb3JcbiAgICB8IF8gLT5cbiAgICAgIGxldCBzaHJpbmtfY291bnQgPSBzaHJpbmtfY291bnQgLSAxIGluXG4gICAgICAobWF0Y2ggU2VxdWVuY2UubmV4dCBhbHRlcm5hdGVzIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gaW5wdXQsIGVycm9yXG4gICAgICAgfCBTb21lIChhbHRlcm5hdGUsIGFsdGVybmF0ZXMpIC0+XG4gICAgICAgICAobWF0Y2ggZiBhbHRlcm5hdGUgd2l0aFxuICAgICAgICAgIHwgT2sgKCkgLT4gbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGlucHV0IGVycm9yXG4gICAgICAgICAgfCBFcnJvciBlcnJvciAtPlxuICAgICAgICAgICAgbGV0IGFsdGVybmF0ZXMgPSBTaHJpbmtlci5zaHJpbmsgc2hyaW5rZXIgYWx0ZXJuYXRlIGluXG4gICAgICAgICAgICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgYWx0ZXJuYXRlIGVycm9yKSlcbiAgaW5cbiAgbGV0IHNocmlua19jb3VudCA9IENvbmZpZy5zaHJpbmtfY291bnQgY29uZmlnIGluXG4gIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGlucHV0IGluXG4gIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuOztcblxubGV0IGlucHV0X3NlcXVlbmNlIH5jb25maWcgfmV4YW1wbGVzIH5nZW5lcmF0b3IgPVxuICBsZXQgcmFuZG9tID0gaW5pdGlhbF9yYW5kb21fc3RhdGUgfmNvbmZpZyBpblxuICBTZXF1ZW5jZS5hcHBlbmRcbiAgICAoU2VxdWVuY2Uub2ZfbGlzdCBleGFtcGxlcylcbiAgICAob25lX3NpemVfcGVyX3Rlc3QgfmNvbmZpZ1xuICAgICB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBzaXplIC0+IEdlbmVyYXRvci5nZW5lcmF0ZSBnZW5lcmF0b3IgfnNpemUgfnJhbmRvbSkpXG47O1xuXG5sZXQgd2l0aF9zYW1wbGUgfmYgPyhjb25maWcgPSBkZWZhdWx0X2NvbmZpZykgPyhleGFtcGxlcyA9IFtdKSBnZW5lcmF0b3IgPVxuICBsZXQgc2VxdWVuY2UgPSBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yIGluXG4gIGYgc2VxdWVuY2Vcbjs7XG5cbmxldCByZXN1bHQgKHR5cGUgYSkgfmYgPyhjb25maWcgPSBkZWZhdWx0X2NvbmZpZykgPyhleGFtcGxlcyA9IFtdKSBtID1cbiAgbGV0IChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9IG0gaW5cbiAgd2l0aF9zYW1wbGUgTS5xdWlja2NoZWNrX2dlbmVyYXRvciB+Y29uZmlnIH5leGFtcGxlcyB+ZjooZnVuIHNlcXVlbmNlIC0+XG4gICAgbWF0Y2hcbiAgICAgIFNlcXVlbmNlLmZvbGRfcmVzdWx0IHNlcXVlbmNlIH5pbml0OigpIH5mOihmdW4gKCkgaW5wdXQgLT5cbiAgICAgICAgbWF0Y2ggZiBpbnB1dCB3aXRoXG4gICAgICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICAgICAgfCBFcnJvciBlcnJvciAtPiBFcnJvciAoaW5wdXQsIGVycm9yKSlcbiAgICB3aXRoXG4gICAgfCBPayAoKSAtPiBPayAoKVxuICAgIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICAgIGxldCBzaHJpbmtlciA9IE0ucXVpY2tjaGVja19zaHJpbmtlciBpblxuICAgICAgbGV0IGlucHV0LCBlcnJvciA9IHNocmlua19lcnJvciB+c2hyaW5rZXIgfmNvbmZpZyB+ZiBpbnB1dCBlcnJvciBpblxuICAgICAgRXJyb3IgKGlucHV0LCBlcnJvcikpXG47O1xuXG5sZXQgcnVuICh0eXBlIGEpIH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoX2pvaW4gfmJhY2t0cmFjZTooQmFja3RyYWNlLkV4bi5hbV9yZWNvcmRpbmcgKCkpIChmdW4gKCkgLT4gZiB4KVxuICBpblxuICBtYXRjaCByZXN1bHQgfmYgP2NvbmZpZyA/ZXhhbXBsZXMgKG1vZHVsZSBNKSB3aXRoXG4gIHwgT2sgKCkgLT4gT2sgKClcbiAgfCBFcnJvciAoaW5wdXQsIGVycm9yKSAtPlxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5UZXN0LnJ1bjogdGVzdCBmYWlsZWRcIiAoaW5wdXQgOiBNLnQpIChlcnJvciA6IEVycm9yLnQpXVxuOztcblxubGV0IHdpdGhfc2FtcGxlX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgPVxuICBsZXQgZiB4ID0gT3JfZXJyb3IudHJ5X3dpdGggKGZ1biAoKSAtPiBmIHgpIGluXG4gIHdpdGhfc2FtcGxlIH5mID9jb25maWcgP2V4YW1wbGVzIGdlbmVyYXRvciB8PiBPcl9lcnJvci5va19leG5cbjs7XG5cbmxldCBydW5fZXhuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlID1cbiAgbGV0IGYgeCA9XG4gICAgT3JfZXJyb3IudHJ5X3dpdGggfmJhY2t0cmFjZTooQmFja3RyYWNlLkV4bi5hbV9yZWNvcmRpbmcgKCkpIChmdW4gKCkgLT4gZiB4KVxuICBpblxuICBydW4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgdGVzdGFibGUgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3MzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1NldCIsIkJhc2VfTWFwIiwiQmFzZV9xdWlja2NoZWNrX0dlbmVyYXRvciIsIkJhc2VfSGFzaCIsIlNwbGl0dGFibGVfcmFuZG9tIiwiQmFzZV9MaXN0IiwiQ2FtbGludGVybmFsTGF6eSIsIkJhc2VfQXJyYXkiLCJCYXNlIiwiQmFzZV9xdWlja2NoZWNrX09ic2VydmVyMCIsIkJhc2VfQm9vbCIsIkJhc2VfQ2hhciIsIkJhc2VfSW50IiwiQmFzZV9JbnQzMiIsIkJhc2VfSW50NjMiLCJCYXNlX0ludDY0IiwiQmFzZV9OYXRpdmVpbnQiLCJCYXNlX0Zsb2F0IiwiQmFzZV9TdHJpbmciLCJCYXNlX3F1aWNrY2hlY2tfQmlnYXJyYXlfaGVscGUiLCJCYXNlX0J5dGVzIiwib3BhcXVlIiwiY3JlYXRlIiwib2JzZXJ2ZSIsInVubWFwIiwidCIsIngiLCJzaXplIiwiaGFzaCIsIm9mX2hhc2hfZm9sZCIsInBhcmFtIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwid3JhcCIsImJvb2wiLCJjaGFyIiwiaW50IiwiaW50MzIiLCJpbnQ2MyIsImludDY0IiwibmF0aXZlaW50IiwiZmxvYXQiLCJzdHJpbmciLCJzZXhwIiwiYmlnc3RyaW5nIiwiZmxvYXQzMl92ZWMiLCJmbG9hdDY0X3ZlYyIsImZsb2F0MzJfbWF0IiwiZmxvYXQ2NF9tYXQiLCJieXRlcyIsImVpdGhlciIsImZzdF90Iiwic25kX3QiLCJmc3QiLCJzbmQiLCJyZXN1bHQiLCJva190IiwiZXJyX3QiLCJvayIsImVyciIsImJvdGgiLCJvcHRpb24iLCJ2YWx1ZV90IiwidmFsdWUiLCJsaXN0IiwiZWx0X3QiLCJyYW5kb20iLCJsZW5ndGgiLCJzaXplcyIsImVsdCIsImFycmF5IiwicmVmIiwiZm4iLCJkb20iLCJybmciLCJtYXBfdHJlZSIsImtleV9vYnMiLCJkYXRhX29icyIsImFyZyIsImV0YSIsInNldF90cmVlIiwiZWx0X29icyIsIm1hcF90Iiwic2V0X3QiLCJCYXNlX3F1aWNrY2hlY2tfT2JzZXJ2ZXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZV9xdWlja2NoZWNrL29ic2VydmVyLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLFlBQUFDLE1BQUFDLEdBQUFsQztBQUFBQSxJQ0dpQjtBQUFBO0FBQUEsc0JBQUFtQyxHQUFBQyxNQUFBQztBQUFBQSxjQUF1QyxPQUFLLHVCQUFMLDZCQUFpQjtBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFDLGFBQUF0QztBQUFB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b0MsTUFBQUM7QUFBQUE7QUFBQUEsZUFBQSxNQUM4QztBQUFBLGVBQUF1QyxTQUEvQjtBQUFBLHFCQUlRO0FBQUEsZUFBQUU7QUFBQUEsaUJBQW5CO0FBQUE7QUFBQSxjQUVGO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0NBQUF6QyxNQUFBRDtBQUFBQTtBQUFBQSx5QkFBQUQ7QUFBQUEsMkJBQ1U7QUFBQTtBQUFBLHdCQUNJLE9BQUs7QUFBQSwrQ0FBTCw2QkFBaUI7QUFBQSx5QkFBQztBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFrRCxTQUFBQyxTQUFBQztBQUFBQSxRQUFBQyxNQUluQztBQUFBLElBQVksT0FBd0I7QUFBQSxhQUE5QixLQUFNO0FBQUEsc0JBQUFDLEtEdEZkLGlDQ3NGNEU7QUFBQTtBQUFBLFlBQUFDLFNBQUFDO0FBQUFBLFFBQUEsTUFHL0M7QUFBQSxXQUFjLE1BQWQsbUJBQW1EO0FBQUE7QUFBQSxZQUFBQyxNQUFBTixTQUFBQztBQUFBQSxRQUFBLE1BR3hFO0FBQUEsV0FBMkIsTUFBM0IsaUNBQTJEO0FBQUE7QUFBQSxZQUFBTSxNQUFBRjtBQUFBQSxRQUFBLE1BR3pDO0FBQUEsV0FBa0IsTUFBbEIsdUJBQWtEO0FBQUE7QUFBQTtBQUFBLElBQUFHO0FBQUFBLE1BbkVqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQ1QjNDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5pbmNsdWRlIE9ic2VydmVyMFxuXG5sZXQgdW5tYXAgdCB+ZiA9IGNyZWF0ZSAoZnVuIHggfnNpemUgfmhhc2ggLT4gb2JzZXJ2ZSB0IChmIHgpIH5zaXplIH5oYXNoKVxubGV0IG9mX2hhc2hfZm9sZCBmID0gY3JlYXRlIChmdW4geCB+c2l6ZTpfIH5oYXNoIC0+IGYgaGFzaCB4KVxubGV0IG9mX2xhenkgbGF6eV90ID0gY3JlYXRlIChmdW4geCB+c2l6ZSB+aGFzaCAtPiBvYnNlcnZlIChmb3JjZSBsYXp5X3QpIHggfnNpemUgfmhhc2gpXG5cbmxldCBmaXhlZF9wb2ludCB3cmFwID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5ICh3cmFwIChvZl9sYXp5IGxhenlfdCkpIGluXG4gIG9mX2xhenkgbGF6eV90XG47O1xuXG5sZXQgdW5pdCA9IG9wYXF1ZVxubGV0IGJvb2wgPSBvZl9oYXNoX2ZvbGQgQm9vbC5oYXNoX2ZvbGRfdFxubGV0IGNoYXIgPSBvZl9oYXNoX2ZvbGQgQ2hhci5oYXNoX2ZvbGRfdFxubGV0IGludCA9IG9mX2hhc2hfZm9sZCBJbnQuaGFzaF9mb2xkX3RcbmxldCBpbnQzMiA9IG9mX2hhc2hfZm9sZCBJbnQzMi5oYXNoX2ZvbGRfdFxubGV0IGludDYzID0gb2ZfaGFzaF9mb2xkIEludDYzLmhhc2hfZm9sZF90XG5sZXQgaW50NjQgPSBvZl9oYXNoX2ZvbGQgSW50NjQuaGFzaF9mb2xkX3RcbmxldCBuYXRpdmVpbnQgPSBvZl9oYXNoX2ZvbGQgTmF0aXZlaW50Lmhhc2hfZm9sZF90XG5sZXQgZmxvYXQgPSBvZl9oYXNoX2ZvbGQgRmxvYXQuaGFzaF9mb2xkX3RcbmxldCBzdHJpbmcgPSBvZl9oYXNoX2ZvbGQgU3RyaW5nLmhhc2hfZm9sZF90XG5sZXQgc2V4cCA9IG9mX2hhc2hfZm9sZCBTZXhwLmhhc2hfZm9sZF90XG5sZXQgYmlnc3RyaW5nID0gb2ZfaGFzaF9mb2xkIChCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5oYXNoX2ZvbGQgaGFzaF9mb2xkX2NoYXIpXG5sZXQgZmxvYXQzMl92ZWMgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfZmxvYXQpXG5sZXQgZmxvYXQ2NF92ZWMgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfZmxvYXQpXG5sZXQgZmxvYXQzMl9tYXQgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkyLmhhc2hfZm9sZCBoYXNoX2ZvbGRfZmxvYXQpXG5sZXQgZmxvYXQ2NF9tYXQgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkyLmhhc2hfZm9sZCBoYXNoX2ZvbGRfZmxvYXQpXG5sZXQgYnl0ZXMgPSB1bm1hcCBzdHJpbmcgfmY6Qnl0ZXMudG9fc3RyaW5nXG5cbmxldCBlaXRoZXIgZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biBlaXRoZXIgfnNpemUgfmhhc2ggLT5cbiAgICBtYXRjaCAoZWl0aGVyIDogXyBFaXRoZXIudCkgd2l0aFxuICAgIHwgRmlyc3QgZnN0IC0+IG9ic2VydmUgZnN0X3QgZnN0IH5zaXplIH5oYXNoOihoYXNoX2ZvbGRfaW50IGhhc2ggMSlcbiAgICB8IFNlY29uZCBzbmQgLT4gb2JzZXJ2ZSBzbmRfdCBzbmQgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAyKSlcbjs7XG5cbmxldCByZXN1bHQgb2tfdCBlcnJfdCA9XG4gIHVubWFwIChlaXRoZXIgb2tfdCBlcnJfdCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBPayBvayAtPiBGaXJzdCBva1xuICAgIHwgRXJyb3IgZXJyIC0+IFNlY29uZCBlcnIpXG47O1xuXG5sZXQgYm90aCBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIChmc3QsIHNuZCkgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgaGFzaCA9IG9ic2VydmUgZnN0X3QgZnN0IH5zaXplIH5oYXNoIGluXG4gICAgbGV0IGhhc2ggPSBvYnNlcnZlIHNuZF90IHNuZCB+c2l6ZSB+aGFzaCBpblxuICAgIGhhc2gpXG47O1xuXG5sZXQgb3B0aW9uIHZhbHVlX3QgPVxuICB1bm1hcCAoZWl0aGVyIG9wYXF1ZSB2YWx1ZV90KSB+ZjooZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gRmlyc3QgKClcbiAgICB8IFNvbWUgdmFsdWUgLT4gU2Vjb25kIHZhbHVlKVxuOztcblxubGV0IGxpc3QgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biBsaXN0IH5zaXplIH5oYXNoIC0+XG4gICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLm9mX2ludCAoSGFzaC5nZXRfaGFzaF92YWx1ZSBoYXNoKSBpblxuICAgIGxldCBsZW5ndGggPSBMaXN0Lmxlbmd0aCBsaXN0IGluXG4gICAgbGV0IHNpemVzID1cbiAgICAgIEdlbmVyYXRvci5zaXplcyB+bWluX2xlbmd0aDpsZW5ndGggfm1heF9sZW5ndGg6bGVuZ3RoICgpXG4gICAgICB8PiBHZW5lcmF0b3IuZ2VuZXJhdGUgfnNpemUgfnJhbmRvbVxuICAgIGluXG4gICAgTGlzdC5mb2xkMl9leG4gbGlzdCBzaXplcyB+aW5pdDooaGFzaF9mb2xkX2ludCBoYXNoIDApIH5mOihmdW4gaGFzaCBlbHQgc2l6ZSAtPlxuICAgICAgb2JzZXJ2ZSBlbHRfdCBlbHQgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAxKSkpXG47O1xuXG5sZXQgYXJyYXkgdCA9IHVubWFwIChsaXN0IHQpIH5mOkFycmF5LnRvX2xpc3RcbmxldCByZWYgdCA9IHVubWFwIHQgfmY6UmVmLiggISApXG5sZXQgbGF6eV90IHQgPSB1bm1hcCB0IH5mOkxhenkuZm9yY2VcblxubGV0IGZuIGRvbSBybmcgPVxuICBjcmVhdGUgKGZ1biBmIH5zaXplIH5oYXNoIC0+XG4gICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLm9mX2ludCAoSGFzaC5nZXRfaGFzaF92YWx1ZSBoYXNoKSBpblxuICAgIGxldCBzaXplcyA9XG4gICAgICAoKiBFbXBpcmljYWxseSwgZG91YmxpbmcgdGhlIHNpemUgd2hlbiBnZW5lcmF0aW5nIHRoZSBsaXN0IG9mIGlucHV0cyBnaXZlcyB1cyBtdWNoXG4gICAgICAgICBiZXR0ZXIgY292ZXJhZ2Ugb2YgdGhlIHNwYWNlIG9mIGZ1bmN0aW9ucy4gKilcbiAgICAgIEdlbmVyYXRvci5nZW5lcmF0ZSAoR2VuZXJhdG9yLnNpemVzICgpKSB+c2l6ZTooc2l6ZSAqIDIpIH5yYW5kb21cbiAgICBpblxuICAgIExpc3QuZm9sZCBzaXplcyB+aW5pdDpoYXNoIH5mOihmdW4gaGFzaCBzaXplIC0+XG4gICAgICBsZXQgeCA9IEdlbmVyYXRvci5nZW5lcmF0ZSBkb20gfnNpemUgfnJhbmRvbSBpblxuICAgICAgb2JzZXJ2ZSBybmcgKGYgeCkgfnNpemUgfmhhc2gpKVxuOztcblxubGV0IG1hcF90cmVlIGtleV9vYnMgZGF0YV9vYnMgPVxuICB1bm1hcCAobGlzdCAoYm90aCBrZXlfb2JzIGRhdGFfb2JzKSkgfmY6TWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS50b19hbGlzdFxuOztcblxubGV0IHNldF90cmVlIGVsdF9vYnMgPSB1bm1hcCAobGlzdCBlbHRfb2JzKSB+ZjpTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2xpc3RcblxubGV0IG1hcF90IGtleV9vYnMgZGF0YV9vYnMgPVxuICB1bm1hcCAobWFwX3RyZWUga2V5X29icyBkYXRhX29icykgfmY6TWFwLlVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxuOztcblxubGV0IHNldF90IGVsdF9vYnMgPSB1bm1hcCAoc2V0X3RyZWUgZWx0X29icykgfmY6U2V0LlVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwMTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIkJhc2VfcXVpY2tjaGVja19HZW5lcmF0b3IiLCJCYXNlX3F1aWNrY2hlY2tfT2JzZXJ2ZXIiLCJCYXNlX3F1aWNrY2hlY2tfU2hyaW5rZXIiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl91bml0IiwicXVpY2tjaGVja19nZW5lcmF0b3JfYm9vbCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2NoYXIiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9zdHJpbmciLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9ieXRlcyIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2ludCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2ludDMyIiwicXVpY2tjaGVja19nZW5lcmF0b3JfaW50NjQiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9uYXRpdmVpbnQiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9mbG9hdCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX29wdGlvbiIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2xpc3QiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9hcnJheSIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX3JlZiIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2xhenlfdCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfdW5pdCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfYm9vbCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfY2hhciIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfc3RyaW5nIiwicXVpY2tjaGVja19vYnNlcnZlcl9ieXRlcyIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfaW50IiwicXVpY2tjaGVja19vYnNlcnZlcl9pbnQzMiIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfaW50NjQiLCJxdWlja2NoZWNrX29ic2VydmVyX25hdGl2ZWludCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfZmxvYXQiLCJxdWlja2NoZWNrX29ic2VydmVyX29wdGlvbiIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfbGlzdCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfYXJyYXkiLCJxdWlja2NoZWNrX29ic2VydmVyX3JlZiIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfbGF6eV90IiwicXVpY2tjaGVja19zaHJpbmtlcl91bml0IiwicXVpY2tjaGVja19zaHJpbmtlcl9ib29sIiwicXVpY2tjaGVja19zaHJpbmtlcl9jaGFyIiwicXVpY2tjaGVja19zaHJpbmtlcl9zdHJpbmciLCJxdWlja2NoZWNrX3Nocmlua2VyX2J5dGVzIiwicXVpY2tjaGVja19zaHJpbmtlcl9pbnQiLCJxdWlja2NoZWNrX3Nocmlua2VyX2ludDMyIiwicXVpY2tjaGVja19zaHJpbmtlcl9pbnQ2NCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfbmF0aXZlaW50IiwicXVpY2tjaGVja19zaHJpbmtlcl9mbG9hdCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfb3B0aW9uIiwicXVpY2tjaGVja19zaHJpbmtlcl9saXN0IiwicXVpY2tjaGVja19zaHJpbmtlcl9hcnJheSIsInF1aWNrY2hlY2tfc2hyaW5rZXJfcmVmIiwicXVpY2tjaGVja19zaHJpbmtlcl9sYXp5X3QiLCJCYXNlX3F1aWNrY2hlY2tfRXhwb3J0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxnQ0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxnQ0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0MTI4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2VfcXVpY2tjaGVjay5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX3F1aWNrY2hlY2tfRXhwb3J0IiwicXVpY2tjaGVja19nZW5lcmF0b3JfdW5pdCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2Jvb2wiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9jaGFyIiwicXVpY2tjaGVja19nZW5lcmF0b3Jfc3RyaW5nIiwicXVpY2tjaGVja19nZW5lcmF0b3JfYnl0ZXMiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9pbnQiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9pbnQzMiIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2ludDY0IiwicXVpY2tjaGVja19nZW5lcmF0b3JfbmF0aXZlaW50IiwicXVpY2tjaGVja19nZW5lcmF0b3JfZmxvYXQiLCJxdWlja2NoZWNrX29ic2VydmVyX3VuaXQiLCJxdWlja2NoZWNrX29ic2VydmVyX2Jvb2wiLCJxdWlja2NoZWNrX29ic2VydmVyX2NoYXIiLCJxdWlja2NoZWNrX29ic2VydmVyX3N0cmluZyIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfYnl0ZXMiLCJxdWlja2NoZWNrX29ic2VydmVyX2ludCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfaW50MzIiLCJxdWlja2NoZWNrX29ic2VydmVyX2ludDY0IiwicXVpY2tjaGVja19vYnNlcnZlcl9uYXRpdmVpbnQiLCJxdWlja2NoZWNrX29ic2VydmVyX2Zsb2F0IiwicXVpY2tjaGVja19zaHJpbmtlcl91bml0IiwicXVpY2tjaGVja19zaHJpbmtlcl9ib29sIiwicXVpY2tjaGVja19zaHJpbmtlcl9jaGFyIiwicXVpY2tjaGVja19zaHJpbmtlcl9zdHJpbmciLCJxdWlja2NoZWNrX3Nocmlua2VyX2J5dGVzIiwicXVpY2tjaGVja19zaHJpbmtlcl9pbnQiLCJxdWlja2NoZWNrX3Nocmlua2VyX2ludDMyIiwicXVpY2tjaGVja19zaHJpbmtlcl9pbnQ2NCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfbmF0aXZlaW50IiwicXVpY2tjaGVja19zaHJpbmtlcl9mbG9hdCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX29wdGlvbiIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2xpc3QiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9hcnJheSIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX3JlZiIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2xhenlfdCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfb3B0aW9uIiwicXVpY2tjaGVja19vYnNlcnZlcl9saXN0IiwicXVpY2tjaGVja19vYnNlcnZlcl9hcnJheSIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfcmVmIiwicXVpY2tjaGVja19vYnNlcnZlcl9sYXp5X3QiLCJxdWlja2NoZWNrX3Nocmlua2VyX29wdGlvbiIsInF1aWNrY2hlY2tfc2hyaW5rZXJfbGlzdCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfYXJyYXkiLCJxdWlja2NoZWNrX3Nocmlua2VyX3JlZiIsInF1aWNrY2hlY2tfc2hyaW5rZXJfbGF6eV90IiwiUHJpdmF0ZSIsIkJhc2VfcXVpY2tjaGVjayJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLGdDQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsZ0NBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
