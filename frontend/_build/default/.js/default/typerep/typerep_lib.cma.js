// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Typerep_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib = [0];
   runtime.caml_register_global(0, Typerep_lib, "Typerep_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Named_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Named_intf = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Named_intf, "Typerep_lib__Named_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function conv(param, x){return x;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   var Typerep_lib_Type_equal = [0, conv, 0, Lift];
   runtime.caml_register_global
    (0, Typerep_lib_Type_equal, "Typerep_lib__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typename
//# unitInfo: Requires: Base, Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printf, Typerep_lib__Type_equal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Base = global_data.Base,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   global_data.Stdlib__List;
   function compare(a, b){return runtime.caml_int_compare(a[1], b[1]);}
   function equal(a, b){return a[1] === b[1] ? 1 : 0;}
   var uid = [0, 0];
   function next(name){var code = uid[1]; uid[1]++; return [0, code, name];}
   function hash(a){return caml_call1(Stdlib_Hashtbl[28], a[1]);}
   function name(a){return a[2];}
   var static$0 = next("static");
   function compare$0(k1, k2){
    if(k1 === k2) return 0;
    var cmp = compare(k1[1], k2[1]);
    if(0 !== cmp) return cmp;
    var b$0 = k2[2], a$0 = k1[2], a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = compare$0(x, y);
     if(0 !== n) return n;
     a = xs;
     b = ys;
    }
   }
   function equal$0(a, b){return 0 === compare$0(a, b) ? 1 : 0;}
   var
    hash$0 = Stdlib_Hashtbl[28],
    static$1 = [0, static$0, 0],
    cst_Typename_create = "Typename.create",
    cst_Typename_same_witness_exn = "Typename.same_witness_exn";
   function key(t){return t;}
   function uid$0(t){return t[1];}
   function name$0(t){var a = t[1]; return a[2];}
   function create(opt, param){
    var name = opt ? opt[1] : cst_Typename_create;
    return [0, next(name), 0];
   }
   function same(nm1, nm2){return 0 === compare$0(nm1, nm2) ? 1 : 0;}
   function same_witness(nm1, nm2){
    return 0 === compare$0(nm1, nm2) ? [0, Typerep_lib_Type_equal[2]] : 0;
   }
   function same_witness_exn(nm1, nm2){
    return 0 === compare$0(nm1, nm2)
            ? Typerep_lib_Type_equal[2]
            : caml_call1(Stdlib[2], cst_Typename_same_witness_exn);
   }
   var
    Key_table = caml_call1(Stdlib_Hashtbl[26], [0, equal$0, hash$0]),
    _a_ =
      [0,
       [11, "Typename.Same_witness_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "Typename.Same_witness_exn %S %S"];
   function Table(X){
    function create(int$0){return caml_call1(Key_table[1], int$0);}
    function mem(table, name){return caml_call2(Key_table[11], table, name);}
    function set(table, name, data){
     return caml_call3(Key_table[10], table, name, [0, name, data]);
    }
    function find(table, name){
     try{var _c_ = [0, caml_call2(Key_table[7], table, name)], data = _c_;}
     catch(_d_){
      var _b_ = caml_wrap_exception(_d_);
      if(_b_[1] !== Base[219] && _b_ !== Stdlib[8])
       throw caml_maybe_attach_backtrace(_b_, 0);
      var data = 0;
     }
     if(! data) return 0;
     var match = data[1], data$0 = match[2], name$0 = match[1];
     same_witness_exn(name$0, name);
     return [0, data$0];
    }
    return [0, create, mem, set, find];
   }
   function fail(uid_a, uid_b){
    var msg = caml_call3(Stdlib_Printf[4], _a_, uid_a[2], uid_b[2]);
    return caml_call1(Stdlib[2], msg);
   }
   function Same_witness_exn_1(A, B){
    var
     t = caml_call1(A[1], static$1),
     uid_a = t[1],
     t$0 = caml_call1(B[1], static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_2(A, B){
    var
     t = caml_call2(A[1], static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call2(B[1], static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_3(A, B){
    var
     t = caml_call3(A[1], static$1, static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call3(B[1], static$1, static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_4(A, B){
    var
     t = caml_call4(A[1], static$1, static$1, static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call4(B[1], static$1, static$1, static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_5(A, B){
    var
     t = caml_call5(A[1], static$1, static$1, static$1, static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call5(B[1], static$1, static$1, static$1, static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   var
    Typerep_lib_Typename =
      [0,
       create,
       static$1,
       same,
       same_witness,
       same_witness_exn,
       [0, compare$0, equal$0, hash$0],
       key,
       [0, compare, equal, hash, name],
       uid$0,
       name$0,
       function(X){
        var uid = next(X[1]), typename_of_t = [0, uid, 0];
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a){return [0, uid, [0, a, 0]];}
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b){return [0, uid, [0, a, [0, b, 0]]];}
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c){
         return [0, uid, [0, a, [0, b, [0, c, 0]]]];
        }
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c, d){
         return [0, uid, [0, a, [0, b, [0, c, [0, d, 0]]]]];
        }
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c, d, e){
         return [0, uid, [0, a, [0, b, [0, c, [0, d, [0, e, 0]]]]]];
        }
        return [0, typename_of_t];
       },
       Table,
       Same_witness_exn_1,
       Same_witness_exn_2,
       Same_witness_exn_3,
       Same_witness_exn_4,
       Same_witness_exn_5];
   runtime.caml_register_global
    (10, Typerep_lib_Typename, "Typerep_lib__Typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Variant_and_record_intf
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array;
   function M(X){
    var Tag_internal = [0];
    function label(t){return t[1];}
    function arity(t){return t[3];}
    function args_labels(t){return t[4];}
    function index(t){return t[5];}
    function ocaml_repr(t){return t[6];}
    function create(t){return t[8];}
    function tyid(t){return t[7];}
    function traverse(t){return t[2];}
    function internal_use_only(t){return t;}
    var
     Tag =
       [0,
        label,
        arity,
        args_labels,
        index,
        ocaml_repr,
        create,
        tyid,
        traverse,
        internal_use_only],
     Variant_internal = [0];
    function typename_of_t(t){return t[1];}
    function length(t){return t[2].length - 1;}
    function tag(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function is_polymorphic(t){return t[3];}
    function value(t){return t[4];}
    function fold(t, init, f){
     return caml_call3(Stdlib_Array[18], f, init, t[2]);
    }
    function internal_use_only$0(t){return t;}
    var
     Variant =
       [0,
        typename_of_t,
        length,
        tag,
        is_polymorphic,
        value,
        fold,
        internal_use_only$0],
     Field_internal = [0];
    function label$0(t){return t[1];}
    function index$0(t){return t[3];}
    function get(t){return t[5];}
    function is_mutable(t){return t[6];}
    function tyid$0(t){return t[4];}
    function traverse$0(t){return t[2];}
    function internal_use_only$1(t){return t;}
    var
     Field =
       [0,
        label$0,
        index$0,
        get,
        is_mutable,
        tyid$0,
        traverse$0,
        internal_use_only$1],
     Record_internal = [0];
    function typename_of_t$0(t){return t[1];}
    function length$0(t){return t[2].length - 1;}
    function field(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function has_double_array_tag(t){return t[3];}
    function create$0(t){return t[4];}
    function fold$0(t, init, f){
     return caml_call3(Stdlib_Array[18], f, init, t[2]);
    }
    function internal_use_only$2(t){return t;}
    var
     Record =
       [0,
        typename_of_t$0,
        length$0,
        field,
        has_double_array_tag,
        create$0,
        fold$0,
        internal_use_only$2];
    return [0,
            Tag_internal,
            Tag,
            Variant_internal,
            Variant,
            Field_internal,
            Field,
            Record_internal,
            Record];
   }
   var Typerep_lib_Variant_and_record = [0, M];
   runtime.caml_register_global
    (1,
     Typerep_lib_Variant_and_record,
     "Typerep_lib__Variant_and_record_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std_internal
//# unitInfo: Requires: Base__Int63, CamlinternalLazy, CamlinternalMod, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_std_internal_ml = "lib/std_internal.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "int",
    name$0 = "int32",
    name$1 = "int64",
    name$2 = "nativeint",
    name$3 = "char",
    name$4 = "float",
    name$5 = "string",
    name$6 = "bytes",
    name$7 = "bool",
    name$8 = "unit",
    name$9 = "option",
    name$10 = "list",
    name$11 = "array",
    name$12 = "lazy_t",
    name$13 = "ref",
    name$14 = "function",
    name$15 = "tuple0",
    name$16 = "tuple2",
    name$17 = "tuple3",
    name$18 = "tuple4",
    name$19 = "tuple5",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    CamlinternalMod = global_data.CamlinternalMod,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    Base_Int63 = global_data.Base__Int63,
    typename_of_int = caml_call1(Typerep_lib_Typename[11], [0, name])[1],
    typename_of_int32 = caml_call1(Typerep_lib_Typename[11], [0, name$0])[1],
    typename_of_int64 = caml_call1(Typerep_lib_Typename[11], [0, name$1])[1],
    typename_of_nativeint =
      caml_call1(Typerep_lib_Typename[11], [0, name$2])[1],
    typename_of_char = caml_call1(Typerep_lib_Typename[11], [0, name$3])[1],
    typename_of_float = caml_call1(Typerep_lib_Typename[11], [0, name$4])[1],
    typename_of_string = caml_call1(Typerep_lib_Typename[11], [0, name$5])[1],
    typename_of_bytes = caml_call1(Typerep_lib_Typename[11], [0, name$6])[1],
    typename_of_bool = caml_call1(Typerep_lib_Typename[11], [0, name$7])[1],
    typename_of_unit = caml_call1(Typerep_lib_Typename[11], [0, name$8])[1],
    M_option = caml_call1(Typerep_lib_Typename[12], [0, name$9]),
    typename_of_option = M_option[1],
    M_list = caml_call1(Typerep_lib_Typename[12], [0, name$10]),
    typename_of_list = M_list[1],
    M_array = caml_call1(Typerep_lib_Typename[12], [0, name$11]),
    typename_of_array = M_array[1],
    M_lazy_t = caml_call1(Typerep_lib_Typename[12], [0, name$12]),
    typename_of_lazy_t = M_lazy_t[1],
    M_ref = caml_call1(Typerep_lib_Typename[12], [0, name$13]),
    typename_of_ref = M_ref[1],
    M_function = caml_call1(Typerep_lib_Typename[13], [0, name$14]),
    typename_of_function = M_function[1],
    M_tuple0 = caml_call1(Typerep_lib_Typename[11], [0, name$15]),
    typename_of_tuple0 = M_tuple0[1],
    M_tuple2 = caml_call1(Typerep_lib_Typename[13], [0, name$16]),
    typename_of_tuple2 = M_tuple2[1],
    M_tuple3 = caml_call1(Typerep_lib_Typename[14], [0, name$17]),
    typename_of_tuple3 = M_tuple3[1],
    M_tuple4 = caml_call1(Typerep_lib_Typename[15], [0, name$18]),
    typename_of_tuple4 = M_tuple4[1],
    M_tuple5 = caml_call1(Typerep_lib_Typename[16], [0, name$19]),
    typename_of_tuple5 = M_tuple5[1],
    Typerep =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_lib_std_internal_ml, 401, 6],
        [0,
         [0,
          [0, [0, 0, 0, 0]],
          [0, [0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          0,
          0,
          0,
          0,
          0]]);
   function arity(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t(param){
    switch(param[0]){
      case 0:
       var rep = param[1]; return rep[2];
      case 1:
       var rep$0 = param[1]; return rep$0[3];
      case 2:
       var rep$1 = param[1]; return rep$1[4];
      case 3:
       var rep$2 = param[1]; return rep$2[5];
      case 4:
       var rep$3 = param[1]; return rep$3[6];
      default: var rep$4 = param[1]; return rep$4[7];
    }
   }
   function name$20(rep){
    var
     _Z_ = typename_of_t(rep),
     ___ = caml_call1(Typerep_lib_Typename[9], _Z_);
    return caml_call1(Typerep_lib_Typename[8][4], ___);
   }
   var Named = [0, arity, typename_of_t, name$20];
   function arity$0(param){
    switch(param[0]){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t$0(param){
    switch(param[0]){
      case 0:
       var
        match = param[1],
        b = match[2],
        a = match[1],
        _P_ = caml_call1(Typerep[14], b);
       return caml_call2(typename_of_tuple2, caml_call1(Typerep[14], a), _P_);
      case 1:
       var
        match$0 = param[1],
        c = match$0[3],
        b$0 = match$0[2],
        a$0 = match$0[1],
        _Q_ = caml_call1(Typerep[14], c),
        _R_ = caml_call1(Typerep[14], b$0);
       return caml_call3
               (typename_of_tuple3, caml_call1(Typerep[14], a$0), _R_, _Q_);
      case 2:
       var
        match$1 = param[1],
        d = match$1[4],
        c$0 = match$1[3],
        b$1 = match$1[2],
        a$1 = match$1[1],
        _S_ = caml_call1(Typerep[14], d),
        _T_ = caml_call1(Typerep[14], c$0),
        _U_ = caml_call1(Typerep[14], b$1);
       return caml_call4
               (typename_of_tuple4,
                caml_call1(Typerep[14], a$1),
                _U_,
                _T_,
                _S_);
      default:
       var
        match$2 = param[1],
        e = match$2[5],
        d$0 = match$2[4],
        c$1 = match$2[3],
        b$2 = match$2[2],
        a$2 = match$2[1],
        _V_ = caml_call1(Typerep[14], e),
        _W_ = caml_call1(Typerep[14], d$0),
        _X_ = caml_call1(Typerep[14], c$1),
        _Y_ = caml_call1(Typerep[14], b$2);
       return caml_call5
               (typename_of_tuple5,
                caml_call1(Typerep[14], a$2),
                _Y_,
                _X_,
                _W_,
                _V_);
    }
   }
   var
    Tuple = [0, arity$0, typename_of_t$0],
    include = caml_call1(Typerep_lib_Variant_and_record[1], [0]),
    Tag_internal = include[1],
    Tag = include[2],
    Variant_internal = include[3],
    Variant = include[4],
    Field_internal = include[5],
    Field = include[6],
    Record_internal = include[7],
    Record = include[8],
    _a_ = [0, 0],
    _b_ = [0, 0],
    _c_ = [0, 0],
    _d_ = [0, 0],
    _e_ = [0, 0],
    _f_ = [0, 0],
    _g_ = [0, 0],
    _h_ = [0, 0],
    _i_ = [0, 0],
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 0],
    _p_ = [0, cst_lib_std_internal_ml, 802, 14];
   function typename_of_t$1(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return typename_of_int;
       case 1:
        return typename_of_int32;
       case 2:
        return typename_of_int64;
       case 3:
        return typename_of_nativeint;
       case 4:
        return typename_of_char;
       case 5:
        return typename_of_float;
       case 6:
        return typename_of_string;
       case 7:
        return typename_of_bytes;
       case 8:
        return typename_of_bool;
       default: return typename_of_unit;
     }
    switch(param[0]){
      case 0:
       var rep = param[1];
       return caml_call1(typename_of_option, typename_of_t$1(rep));
      case 1:
       var rep$0 = param[1];
       return caml_call1(typename_of_list, typename_of_t$1(rep$0));
      case 2:
       var rep$1 = param[1];
       return caml_call1(typename_of_array, typename_of_t$1(rep$1));
      case 3:
       var rep$2 = param[1];
       return caml_call1(typename_of_lazy_t, typename_of_t$1(rep$2));
      case 4:
       var rep$3 = param[1];
       return caml_call1(typename_of_ref, typename_of_t$1(rep$3));
      case 5:
       var
        match = param[1],
        rng = match[2],
        dom = match[1],
        _O_ = typename_of_t$1(rng);
       return caml_call2(typename_of_function, typename_of_t$1(dom), _O_);
      case 6:
       var rep$4 = param[1]; return caml_call1(Typerep[2][2], rep$4);
      case 7:
       var rep$5 = param[1]; return caml_call1(Typerep[10][1], rep$5);
      case 8:
       var rep$6 = param[1]; return caml_call1(Typerep[6][1], rep$6);
      default: var name = param[1][1]; return caml_call1(Named[2], name);
    }
   }
   function same_witness(t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     a:
     {
      if(typeof t1$0 === "number")
       switch(t1$0){
         case 0:
          if(typeof t2$0 === "number"){if(0 === t2$0) return _a_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 1:
          if(typeof t2$0 === "number"){if(1 === t2$0) return _b_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 2:
          if(typeof t2$0 === "number"){if(2 === t2$0) return _c_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 3:
          if(typeof t2$0 === "number"){if(3 === t2$0) return _d_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 4:
          if(typeof t2$0 === "number"){if(4 === t2$0) return _e_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 5:
          if(typeof t2$0 === "number"){if(5 === t2$0) return _f_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 6:
          if(typeof t2$0 === "number"){if(6 === t2$0) return _g_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 7:
          if(typeof t2$0 === "number"){if(7 === t2$0) return _h_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 8:
          if(typeof t2$0 === "number"){if(8 === t2$0) return _i_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         default:
          if(typeof t2$0 === "number"){if(9 === t2$0) return _j_; break a;}
          if(9 !== t2$0[0]) break a;
       }
      else
       b:
       switch(t1$0[0]){
         case 0:
          var r1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 0:
              var r2$0 = t2$0[1], x = same_witness(r1, r2$0);
              return x ? x : x;
             case 9:
              break b;
           }
          break a;
         case 1:
          var r1$0 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 1:
              var r2$1 = t2$0[1], x$0 = same_witness(r1$0, r2$1);
              return x$0 ? x$0 : x$0;
             case 9:
              break b;
           }
          break a;
         case 2:
          var r1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 2:
              var r2$2 = t2$0[1], x$1 = same_witness(r1$1, r2$2);
              return x$1 ? x$1 : x$1;
             case 9:
              break b;
           }
          break a;
         case 3:
          var r1$2 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 3:
              var r2$3 = t2$0[1], x$2 = same_witness(r1$2, r2$3);
              return x$2 ? x$2 : x$2;
             case 9:
              break b;
           }
          break a;
         case 4:
          var r1$3 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 4:
              var r2$4 = t2$0[1], x$3 = same_witness(r1$3, r2$4);
              return x$3 ? x$3 : x$3;
             case 9:
              break b;
           }
          break a;
         case 5:
          var _v_ = t1$0[1], rng1 = _v_[2], dom1 = _v_[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 5:
              var
               match = t2$0[1],
               rng2 = match[2],
               dom2 = match[1],
               match$0 = same_witness(dom1, dom2),
               match$1 = same_witness(rng1, rng2);
              if(match$0 && match$1) return _k_;
              return 0;
             case 9:
              break b;
           }
          break a;
         case 6:
          var t1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 6:
              var t2$2 = t2$0[1];
              switch(t1$1[0]){
                case 0:
                 var _w_ = t1$1[1];
                 if(0 !== t2$2[0]) return 0;
                 var
                  match$2 = t2$2[1],
                  b2 = match$2[2],
                  a2 = match$2[1],
                  b1 = _w_[2],
                  a1 = _w_[1],
                  match$3 = same_witness(a1, a2),
                  match$4 = same_witness(b1, b2);
                 if(match$3 && match$4) return _l_;
                 return 0;
                case 1:
                 var _x_ = t1$1[1];
                 if(1 !== t2$2[0]) return 0;
                 var
                  match$5 = t2$2[1],
                  c2 = match$5[3],
                  b2$0 = match$5[2],
                  a2$0 = match$5[1],
                  c1 = _x_[3],
                  b1$0 = _x_[2],
                  a1$0 = _x_[1],
                  match$6 = same_witness(a1$0, a2$0),
                  match$7 = same_witness(b1$0, b2$0),
                  match$8 = same_witness(c1, c2);
                 if(match$6 && match$7 && match$8) return _m_;
                 return 0;
                case 2:
                 var _y_ = t1$1[1];
                 if(2 !== t2$2[0]) return 0;
                 var
                  match$9 = t2$2[1],
                  d2 = match$9[4],
                  c2$0 = match$9[3],
                  b2$1 = match$9[2],
                  a2$1 = match$9[1],
                  d1 = _y_[4],
                  c1$0 = _y_[3],
                  b1$1 = _y_[2],
                  a1$1 = _y_[1],
                  match$10 = same_witness(a1$1, a2$1),
                  match$11 = same_witness(b1$1, b2$1),
                  match$12 = same_witness(c1$0, c2$0),
                  match$13 = same_witness(d1, d2);
                 if(match$10 && match$11 && match$12 && match$13) return _n_;
                 return 0;
                default:
                 var _z_ = t1$1[1];
                 if(3 !== t2$2[0]) return 0;
                 var
                  match$14 = t2$2[1],
                  e2 = match$14[5],
                  d2$0 = match$14[4],
                  c2$1 = match$14[3],
                  b2$2 = match$14[2],
                  a2$2 = match$14[1],
                  e1 = _z_[5],
                  d1$0 = _z_[4],
                  c1$1 = _z_[3],
                  b1$2 = _z_[2],
                  a1$2 = _z_[1],
                  match$15 = same_witness(a1$2, a2$2),
                  match$16 = same_witness(b1$2, b2$2),
                  match$17 = same_witness(c1$1, c2$1),
                  match$18 = same_witness(d1$0, d2$0),
                  match$19 = same_witness(e1, e2);
                 if(match$15 && match$16 && match$17 && match$18 && match$19)
                  return _o_;
                 return 0;
              }
             case 9:
              break b;
           }
          break a;
         case 7:
          var r1$4 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 7:
              var
               r2$5 = t2$0[1],
               _A_ = caml_call1(Typerep[10][1], r2$5),
               _B_ = caml_call1(Typerep[10][1], r1$4);
              return caml_call2(Typerep_lib_Typename[4], _B_, _A_);
             case 9:
              break b;
           }
          break a;
         case 8:
          var r1$5 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 8:
              var
               r2$6 = t2$0[1],
               _C_ = caml_call1(Typerep[6][1], r2$6),
               _D_ = caml_call1(Typerep[6][1], r1$5);
              return caml_call2(Typerep_lib_Typename[4], _D_, _C_);
             case 9:
              break b;
           }
          break a;
         default:
          var match$20 = t1$0[1], name1 = match$20[1];
          if(typeof t2$0 !== "number" && 9 === t2$0[0]){
           var
            match$21 = t2$0[1],
            r2$7 = match$21[2],
            name2 = match$21[1],
            r1$7 = match$20[2],
            _G_ = caml_call1(Named[2], name2),
            _H_ = caml_call1(Named[2], name1),
            x$4 = caml_call2(Typerep_lib_Typename[4], _H_, _G_);
           if(x$4) return x$4;
           if(r1$7){
            var _I_ = r1$7[1], _J_ = caml_obj_tag(_I_);
            c:
            if(250 === _J_)
             var t1$3 = _I_[1];
            else{
             if(246 !== _J_ && 244 !== _J_){var t1$3 = _I_; break c;}
             var t1$3 = caml_call1(CamlinternalLazy[2], _I_);
            }
            if(! r2$7){t1$0 = t1$3; continue;}
            var _K_ = r2$7[1], _L_ = caml_obj_tag(_K_);
            c:
            if(250 === _L_)
             var t2$3 = _K_[1];
            else{
             if(246 !== _L_ && 244 !== _L_){var t2$3 = _K_; break c;}
             var t2$3 = caml_call1(CamlinternalLazy[2], _K_);
            }
            t1$0 = t1$3;
            t2$0 = t2$3;
            continue;
           }
           if(! r2$7) return 0;
           var _M_ = r2$7[1], _N_ = caml_obj_tag(_M_);
           c:
           if(250 === _N_)
            var t2$4 = _M_[1];
           else{
            if(246 !== _N_ && 244 !== _N_){var t2$4 = _M_; break c;}
            var t2$4 = caml_call1(CamlinternalLazy[2], _M_);
           }
           t2$0 = t2$4;
           continue;
          }
          var r1$6 = match$20[2];
          if(! r1$6) return 0;
          var _E_ = r1$6[1], _F_ = caml_obj_tag(_E_);
          c:
          if(250 === _F_)
           var t1$2 = _E_[1];
          else{
           if(246 !== _F_ && 244 !== _F_){var t1$2 = _E_; break c;}
           var t1$2 = caml_call1(CamlinternalLazy[2], _E_);
          }
          t1$0 = t1$2;
          continue;
       }
      var r2 = t2$0[1][2];
      if(! r2) return 0;
      var _t_ = r2[1], _u_ = caml_obj_tag(_t_);
      b:
      if(250 === _u_)
       var t2$1 = _t_[1];
      else{
       if(246 !== _u_ && 244 !== _u_){var t2$1 = _t_; break b;}
       var t2$1 = caml_call1(CamlinternalLazy[2], _t_);
      }
      t2$0 = t2$1;
      continue;
     }
     if(typeof t1$0 === "number")
      switch(t1$0){
        case 0: break;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        case 8:
         return 0;
        default: return 0;
      }
     else
      switch(t1$0[0]){
        case 9: break;
        case 0:
         return 0;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        default: return 0;
      }
     return 0;
    }
   }
   function same(a, b){return 0 !== same_witness(a, b) ? 1 : 0;}
   function same_witness_exn(a, b){
    var match = same_witness(a, b);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var proof = match[1];
    return proof;
   }
   function head(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 !== "number" && 9 === t$0[0]){
      var _q_ = t$0[1][2];
      if(_q_){
       var _r_ = _q_[1], _s_ = caml_obj_tag(_r_);
       a:
       if(250 === _s_)
        var t$1 = _r_[1];
       else{
        if(246 !== _s_ && 244 !== _s_){var t$1 = _r_; break a;}
        var t$1 = caml_call1(CamlinternalLazy[2], _r_);
       }
       t$0 = t$1;
       continue;
      }
     }
     return t$0;
    }
   }
   caml_call3
    (CamlinternalMod[2],
     [0,
      [0,
       [0, [0, 0, 0, 0]],
       [0, [0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       0,
       0,
       0,
       0,
       0]],
     Typerep,
     [0,
      Named,
      Tuple,
      Tag_internal,
      Tag,
      Variant_internal,
      Variant,
      Field_internal,
      Field,
      Record_internal,
      Record,
      same,
      same_witness,
      same_witness_exn,
      typename_of_t$1,
      head]);
   var typerep_of_int = 0, typerep_of_int64 = 2;
   function typerep_of_option(rep){return [0, rep];}
   function typerep_of_list(rep){return [1, rep];}
   function typerep_of_array(rep){return [2, rep];}
   function typerep_of_lazy_t(rep){return [3, rep];}
   function typerep_of_ref(rep){return [4, rep];}
   function typerep_of_function(dom, rng){return [5, [0, dom, rng]];}
   function typerep_of_tuple2(a, b){return [6, [0, [0, a, b]]];}
   function typerep_of_tuple3(a, b, c){return [6, [1, [0, a, b, c]]];}
   function typerep_of_tuple4(a, b, c, d){return [6, [2, [0, a, b, c, d]]];}
   function typerep_of_tuple5(a, b, c, d, e){return [6, [3, [0, a, b, c, d, e]]];
   }
   var
    typerep_of_int32 = 1,
    typerep_of_nativeint = 3,
    typerep_of_char = 4,
    typerep_of_float = 5,
    typerep_of_string = 6,
    typerep_of_bytes = 7,
    typerep_of_bool = 8,
    typerep_of_unit = 9,
    typerep_of_tuple0 = 9,
    value_tuple0 = 0,
    match =
      Base_Int63[115][2]
       ? [0, typerep_of_int64, typename_of_int64]
       : [0, typerep_of_int, typename_of_int],
    typename_of_int63 = match[2],
    typerep_of_int63 = match[1],
    Typerep_lib_Std_internal =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global
    (46, Typerep_lib_Std_internal, "Typerep_lib__Std_internal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerepable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Typerepable = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Typerepable, "Typerep_lib__Typerepable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerep_obj
//# unitInfo: Requires: Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_typerep_obj_ml = "lib/typerep_obj.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, cst_lib_typerep_obj_ml, 11, 4],
    _b_ = [0, cst_lib_typerep_obj_ml, 9, 4];
   function repr_of_poly_variant(variant){
    if(typeof variant === "number") return variant;
    var size = variant.length - 1;
    if(2 !== size)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var repr = variant[1];
    if(typeof repr === "number") return repr;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function hash_variant(s){
    var
     accu = [0, 0],
     _k_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _l_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _l_ | 0;
      var _m_ = i + 1 | 0;
      if(_k_ === i) break;
      i = _m_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    return 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
   }
   var
    _c_ = hash_variant("Latency_stats"),
    _h_ = [0, cst_lib_typerep_obj_ml, 28, 9],
    cst_zero = "zero",
    _g_ = [0, cst_lib_typerep_obj_ml, 29, 9],
    _f_ = [0, cst_lib_typerep_obj_ml, 49, 2],
    _e_ = [0, cst_lib_typerep_obj_ml, 50, 2];
   if(repr_of_poly_variant(-894644482) !== _c_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var _d_ = hash_variant(cst_zero);
   if(repr_of_poly_variant(-789508312) !== _d_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   function double_array_value(param){return 0.;}
   function has_double_array_tag(a){
    var _i_ = runtime.caml_obj_tag(a);
    return Stdlib_Obj[17] === _i_ ? 1 : 0;
   }
   var double$0 = [254, 0., 0.], simple = [0, 0., 0.];
   if(! has_double_array_tag(double$0))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   if(has_double_array_tag(simple))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   var
    Typerep_lib_Typerep_obj =
      [0,
       repr_of_poly_variant,
       hash_variant,
       double_array_value,
       has_double_array_tag];
   runtime.caml_register_global
    (11, Typerep_lib_Typerep_obj, "Typerep_lib__Typerep_obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function M(X){return [0];}
   var Typerep_lib_Type_generic_intf = [0, M];
   runtime.caml_register_global
    (0, Typerep_lib_Type_generic_intf, "Typerep_lib__Type_generic_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic
//# unitInfo: Requires: Base, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Lazy, Stdlib__List, Stdlib__Printf, Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Type_generic_intf, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_type_generic_ml = "lib/type_generic.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Typerep_lib_Type_generic_intf = global_data.Typerep_lib__Type_generic_intf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf;
   function Helper(A, B){
    function map_variant(param, variant){
     var
      map = param[1],
      typename = caml_call1(A[4][1], variant),
      polymorphic = caml_call1(A[4][4], variant),
      _au_ = caml_call1(A[4][2], variant),
      tags =
        caml_call2
         (Stdlib_Array[1],
          _au_,
          function(index$0){
           var
            tag$0 = caml_call2(A[4][3], variant, index$0),
            tag = tag$0[1],
            label = caml_call1(A[2][1], tag),
            rep = caml_call1(map, caml_call1(A[2][8], tag)),
            arity = caml_call1(A[2][2], tag),
            args_labels = caml_call1(A[2][3], tag),
            index = caml_call1(A[2][4], tag),
            ocaml_repr = caml_call1(A[2][5], tag),
            tyid = caml_call1(A[2][7], tag),
            param = caml_call1(A[2][6], tag);
           if(0 === param[0])
            var fct = param[1], create = [0, fct];
           else
            var k = param[1], create = [1, k];
           return [0,
                   caml_call1
                    (B[2][9],
                     [0,
                      label,
                      rep,
                      arity,
                      args_labels,
                      index,
                      ocaml_repr,
                      tyid,
                      create])];
          });
     function value(a){
      var
       match = caml_call2(A[4][5], variant, a),
       a$0 = match[2],
       atag = match[1],
       _av_ = caml_call1(A[2][4], atag),
       btag = caml_check_bound(tags, _av_)[1 + _av_][1],
       _aw_ = caml_call1(B[2][7], btag),
       _ax_ = caml_call1(A[2][7], atag);
      caml_call2(Typerep_lib_Typename[5], _ax_, _aw_);
      return [0, btag, a$0];
     }
     return caml_call1(B[4][7], [0, typename, tags, polymorphic, value]);
    }
    function map_record(param, record){
     var
      map = param[1],
      typename = caml_call1(A[8][1], record),
      has_double_array_tag = caml_call1(A[8][4], record),
      _aq_ = caml_call1(A[8][2], record),
      fields =
        caml_call2
         (Stdlib_Array[1],
          _aq_,
          function(index$0){
           var
            field$0 = caml_call2(A[8][3], record, index$0),
            field = field$0[1],
            label = caml_call1(A[6][1], field),
            rep = caml_call1(map, caml_call1(A[6][6], field)),
            index = caml_call1(A[6][2], field),
            is_mutable = caml_call1(A[6][4], field),
            tyid = caml_call1(A[6][5], field),
            get = caml_call1(A[6][3], field);
           return [0,
                   caml_call1
                    (B[6][7], [0, label, rep, index, tyid, get, is_mutable])];
          });
     function create(param){
      var get = param[1];
      function get$0(afield){
       var
        _ar_ = caml_call1(A[6][2], afield),
        bfield = caml_check_bound(fields, _ar_)[1 + _ar_][1],
        _as_ = caml_call1(B[6][5], bfield),
        _at_ = caml_call1(A[6][5], afield);
       caml_call2(Typerep_lib_Typename[5], _at_, _as_);
       return caml_call1(get, bfield);
      }
      return caml_call2(A[8][5], record, [0, get$0]);
     }
     return caml_call1
             (B[8][7], [0, typename, fields, has_double_array_tag, create]);
    }
    return [0, map_variant, map_record];
   }
   var
    Broken_dependency =
      [248,
       "Typerep_lib.Type_generic.Ident.Broken_dependency",
       caml_fresh_oo_id(0)],
    _d_ = Typerep_lib_Typename[6];
   caml_call1(Stdlib_Hashtbl[26], [0, _d_[2], _d_[3]]);
   var
    _c_ =
      [0,
       [11,
        "Type_generic ",
        [3,
         0,
         [11, " requires ", [3, 0, [11, " for uid ", [3, 0, [12, 10, 0]]]]]]],
       "Type_generic %S requires %S for uid %S\n"],
    cst_Typerep_lib_Type_generic_M$0 =
      "Typerep_lib.Type_generic.Make_S_implementation(X).Not_implemented",
    dummy = 0,
    cst_Typerep_lib_Type_generic_M =
      "Typerep_lib.Type_generic.Make_named_for_closure(X).Undefined",
    _a_ = [0, cst_lib_type_generic_ml, 185, 16],
    _b_ = [0, cst_lib_type_generic_ml, 187, 69],
    Typerep_lib_Type_generic =
      [0,
       Typerep_lib_Variant_and_record,
       Helper,
       function(_an_){
        function create(_ap_){return 0;}
        var
         Context = [0, create],
         Undefined =
           [248, cst_Typerep_lib_Type_generic_M, caml_fresh_oo_id(0)];
        function init(param, name){
         var
          _ao_ = caml_call1(Typerep_lib_Typename[9], name),
          path = caml_call1(Typerep_lib_Typename[8][4], _ao_),
          r =
            [0,
             function(param){
              throw caml_maybe_attach_backtrace([0, Undefined, path], 1);
             }];
         return [0,
                 function(input){return caml_call1(r[1], input);},
                 r,
                 [0, 0]];
        }
        function get_wip_computation(shared){
         var match = shared[3][1];
         if(! match) return shared[1];
         var clos = match[1];
         return clos;
        }
        function set_final_computation(shared, computation){
         var compiletime_dereference = shared[3];
         if(compiletime_dereference[1])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         if(shared[1] === computation)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         compiletime_dereference[1] = [0, computation];
         shared[2][1] = computation;
         return computation;
        }
        function share(param){return 1;}
        return [0,
                Context,
                init,
                get_wip_computation,
                set_final_computation,
                share];
       },
       [0],
       function(X){
        var required = X[2], name = X[1];
        caml_call1(Typerep_lib_Type_generic_intf[1], [0]);
        var
         _e_ = Typerep_lib_Typename[8],
         include = caml_call1(Stdlib_Hashtbl[26], [0, _e_[2], _e_[3]]),
         create = include[1],
         replace = include[10],
         mem = include[11],
         _f_ = include[7];
        function find(table, key){
         if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
         var _aj_ = caml_obj_tag(table);
         a:
         if(250 === _aj_)
          var table$0 = table[1];
         else{
          if(246 !== _aj_ && 244 !== _aj_){var table$0 = table; break a;}
          var table$0 = caml_call1(CamlinternalLazy[2], table);
         }
         try{var _al_ = [0, caml_call2(_f_, table$0, key)]; return _al_;}
         catch(_am_){
          var _ak_ = caml_wrap_exception(_am_);
          if(_ak_[1] !== Base[219] && _ak_ !== Stdlib[8])
           throw caml_maybe_attach_backtrace(_ak_, 0);
          return 0;
         }
        }
        var
         check_dependencies =
           required
            ? function
             (uid){
              return caml_call2
                      (Stdlib_List[18],
                       function(param){
                        var
                         implements$0 = param[2],
                         name$0 = param[1],
                         _ah_ = 1 - caml_call1(implements$0, uid);
                        if(! _ah_) return _ah_;
                        var
                         _ai_ = caml_call1(Typerep_lib_Typename[8][4], uid),
                         message =
                           caml_call4(Stdlib_Printf[4], _c_, name, name$0, _ai_);
                        caml_call1(Stdlib[53], message);
                        throw caml_maybe_attach_backtrace
                               ([0, Broken_dependency, message], 1);
                       },
                       required);
             }
            : function(param){};
        function replace$0(table, key, value){
         check_dependencies(key);
         var _af_ = caml_obj_tag(table);
         a:
         if(250 === _af_)
          var _ag_ = table[1];
         else{
          if(246 !== _af_ && 244 !== _af_){var _ag_ = table; break a;}
          var _ag_ = caml_call1(CamlinternalLazy[2], table);
         }
         return caml_call3(replace, _ag_, key, value);
        }
        function mem$0(table, key){
         if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
         var _ae_ = caml_obj_tag(table);
         a:
         if(250 === _ae_)
          var table$0 = table[1];
         else{
          if(246 !== _ae_ && 244 !== _ae_){var table$0 = table; break a;}
          var table$0 = caml_call1(CamlinternalLazy[2], table);
         }
         return caml_call2(mem, table$0, key);
        }
        var
         size = 256,
         table0 = [246, function(_ad_){return caml_call1(create, size);}],
         table1 = [246, function(_ac_){return caml_call1(create, size);}],
         table2 = [246, function(_ab_){return caml_call1(create, size);}],
         table3 = [246, function(_aa_){return caml_call1(create, size);}],
         table4 = [246, function(_$_){return caml_call1(create, size);}],
         table5 = [246, function(___){return caml_call1(create, size);}];
        function is_registered(uid){
         var _U_ = mem$0(table0, uid);
         if(_U_)
          var _V_ = _U_;
         else{
          var _W_ = mem$0(table1, uid);
          if(_W_)
           var _V_ = _W_;
          else{
           var _X_ = mem$0(table2, uid);
           if(_X_)
            var _V_ = _X_;
           else{
            var _Y_ = mem$0(table3, uid);
            if(_Y_)
             var _V_ = _Y_;
            else{
             var _Z_ = mem$0(table4, uid);
             if(! _Z_) return mem$0(table5, uid);
             var _V_ = _Z_;
            }
           }
          }
         }
         return _V_;
        }
        var ident = [0, name, is_registered], unit = Typerep_lib_Typename[2];
        function register0(compute){
         var uid = caml_call1(Typerep_lib_Typename[9], compute[2]);
         return replace$0(table0, uid, compute);
        }
        function register1(compute){
         var
          _T_ = caml_call1(compute[2], unit),
          uid = caml_call1(Typerep_lib_Typename[9], _T_);
         return replace$0(table1, uid, compute);
        }
        function register2(compute){
         var
          _S_ = caml_call2(compute[2], unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _S_);
         return replace$0(table2, uid, compute);
        }
        function register3(compute){
         var
          _R_ = caml_call3(compute[2], unit, unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _R_);
         return replace$0(table3, uid, compute);
        }
        function register4(compute){
         var
          _Q_ = caml_call4(compute[2], unit, unit, unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _Q_);
         return replace$0(table4, uid, compute);
        }
        function register5(compute){
         var
          _P_ = caml_call5(compute[2], unit, unit, unit, unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _P_);
         return replace$0(table5, uid, compute);
        }
        function register(typerep_of_a, compute){
         var
          typename_of_t =
            caml_call1(Typerep_lib_Std_internal[1][14], typerep_of_a);
         return register0([0, typerep_of_a, typename_of_t, compute]);
        }
        var
         Not_implemented =
           [248, cst_Typerep_lib_Type_generic_M$0, caml_fresh_oo_id(0)],
         Memo = caml_call1(Typerep_lib_Typename[17], [0]),
         _g_ = Typerep_lib_Std_internal[1],
         Helper$0 =
           Helper
            ([0,
              _g_[3],
              _g_[4],
              _g_[5],
              _g_[6],
              _g_[7],
              _g_[8],
              _g_[9],
              _g_[10]],
             [0, X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10]]);
        function of_typerep(rep){
         var
          context = caml_call1(X[33][1][1], 0),
          memo_table = caml_call1(Memo[1], 32);
         function of_typerep(param){
          var param$0 = param;
          for(;;){
           if(typeof param$0 === "number")
            switch(param$0){
              case 0:
               return X[11];
              case 1:
               return X[12];
              case 2:
               return X[13];
              case 3:
               return X[14];
              case 4:
               return X[15];
              case 5:
               return X[16];
              case 6:
               return X[17];
              case 7:
               return X[18];
              case 8:
               return X[19];
              default: return X[20];
            }
           switch(param$0[0]){
             case 0:
              var rep$11 = param$0[1], _D_ = of_typerep(rep$11);
              return caml_call1(X[21], _D_);
             case 1:
              var rep$12 = param$0[1], _E_ = of_typerep(rep$12);
              return caml_call1(X[22], _E_);
             case 2:
              var rep$13 = param$0[1], _F_ = of_typerep(rep$13);
              return caml_call1(X[23], _F_);
             case 3:
              var rep$14 = param$0[1], _G_ = of_typerep(rep$14);
              return caml_call1(X[24], _G_);
             case 4:
              var rep$15 = param$0[1], _H_ = of_typerep(rep$15);
              return caml_call1(X[25], _H_);
             case 5:
              var
               match$11 = param$0[1],
               rng = match$11[2],
               dom = match$11[1],
               _I_ = of_typerep(rng),
               _J_ = of_typerep(dom);
              return caml_call2(X[26], _J_, _I_);
             case 6:
              var tuple = param$0[1];
              switch(tuple[0]){
                case 0:
                 var
                  match$12 = tuple[1],
                  b = match$12[2],
                  a = match$12[1],
                  ra = of_typerep(a),
                  rb = of_typerep(b);
                 return caml_call2(X[27], ra, rb);
                case 1:
                 var
                  match$13 = tuple[1],
                  c = match$13[3],
                  b$0 = match$13[2],
                  a$0 = match$13[1],
                  ra$0 = of_typerep(a$0),
                  rb$0 = of_typerep(b$0),
                  rc = of_typerep(c);
                 return caml_call3(X[28], ra$0, rb$0, rc);
                case 2:
                 var
                  match$14 = tuple[1],
                  d = match$14[4],
                  c$0 = match$14[3],
                  b$1 = match$14[2],
                  a$1 = match$14[1],
                  ra$1 = of_typerep(a$1),
                  rb$1 = of_typerep(b$1),
                  rc$0 = of_typerep(c$0),
                  rd = of_typerep(d);
                 return caml_call4(X[29], ra$1, rb$1, rc$0, rd);
                default:
                 var
                  match$15 = tuple[1],
                  e = match$15[5],
                  d$0 = match$15[4],
                  c$1 = match$15[3],
                  b$2 = match$15[2],
                  a$2 = match$15[1],
                  ra$2 = of_typerep(a$2),
                  rb$2 = of_typerep(b$2),
                  rc$1 = of_typerep(c$1),
                  rd$0 = of_typerep(d$0),
                  re = of_typerep(e);
                 return caml_call5(X[30], ra$2, rb$2, rc$1, rd$0, re);
              }
             case 7:
              var
               record = param$0[1],
               _K_ = caml_call2(Helper$0[2], [0, of_typerep], record);
              return caml_call1(X[31], _K_);
             case 8:
              var
               variant = param$0[1],
               _L_ = caml_call2(Helper$0[1], [0, of_typerep], variant);
              return caml_call1(X[32], _L_);
             default:
              var
               match$16 = param$0[1],
               content = match$16[2],
               named = match$16[1],
               typename = caml_call1(Typerep_lib_Std_internal[1][1][2], named),
               match$17 = caml_call2(Memo[4], memo_table, typename);
              if(match$17){
               var shared = match$17[1];
               return caml_call1(X[33][3], shared);
              }
              switch(named[0]){
                case 0:
                 var
                  rep$5 = named[1],
                  match =
                    find(table0, caml_call1(Typerep_lib_Typename[9], rep$5[2]));
                 if(match)
                  var
                   rep = match[1],
                   witness =
                     caml_call2(Typerep_lib_Typename[5], rep[2], rep$5[1]),
                   L = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _h_ = rep[3],
                   _i_ = caml_call1(L[1], witness),
                   match$5 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _i_, _h_)];
                 else
                  var match$5 = 0;
                 if(match$5)
                  var custom = match$5[1], match$18 = [0, custom];
                 else
                  var match$18 = 0;
                 break;
                case 1:
                 var
                  rep$6 = named[1],
                  match$0 =
                    find(table1, caml_call1(Typerep_lib_Typename[9], rep$6[3]));
                 if(match$0)
                  var
                   rep$0 = match$0[1],
                   typename_of_t = rep$6[2],
                   Conv =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[18], [0, rep$0[2]]),
                       [0, typename_of_t]),
                   L$0 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _j_ = rep$0[3],
                   _k_ = caml_call1(L$0[1], Conv[1][1]),
                   match$6 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _k_, _j_)];
                 else
                  var match$6 = 0;
                 if(match$6)
                  var
                   custom$0 = match$6[1],
                   custom$1 = caml_call1(custom$0, of_typerep(rep$6[1])),
                   match$18 = [0, custom$1];
                 else
                  var match$18 = 0;
                 break;
                case 2:
                 var
                  rep$7 = named[1],
                  match$1 =
                    find(table2, caml_call1(Typerep_lib_Typename[9], rep$7[4]));
                 if(match$1)
                  var
                   rep$1 = match$1[1],
                   typename_of_t$0 = rep$7[3],
                   Conv$0 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[19], [0, rep$1[2]]),
                       [0, typename_of_t$0]),
                   L$1 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _l_ = rep$1[3],
                   _m_ = caml_call1(L$1[1], Conv$0[1][1]),
                   match$7 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _m_, _l_)];
                 else
                  var match$7 = 0;
                 if(match$7)
                  var
                   custom$2 = match$7[1],
                   _t_ = of_typerep(rep$7[2]),
                   custom$3 = caml_call2(custom$2, of_typerep(rep$7[1]), _t_),
                   match$18 = [0, custom$3];
                 else
                  var match$18 = 0;
                 break;
                case 3:
                 var
                  rep$8 = named[1],
                  match$2 =
                    find(table3, caml_call1(Typerep_lib_Typename[9], rep$8[5]));
                 if(match$2)
                  var
                   rep$2 = match$2[1],
                   typename_of_t$1 = rep$8[4],
                   Conv$1 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[20], [0, rep$2[2]]),
                       [0, typename_of_t$1]),
                   L$2 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _n_ = rep$2[3],
                   _o_ = caml_call1(L$2[1], Conv$1[1][1]),
                   match$8 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _o_, _n_)];
                 else
                  var match$8 = 0;
                 if(match$8)
                  var
                   custom$4 = match$8[1],
                   _u_ = of_typerep(rep$8[3]),
                   _v_ = of_typerep(rep$8[2]),
                   custom$5 =
                     caml_call3(custom$4, of_typerep(rep$8[1]), _v_, _u_),
                   match$18 = [0, custom$5];
                 else
                  var match$18 = 0;
                 break;
                case 4:
                 var
                  rep$9 = named[1],
                  match$3 =
                    find(table4, caml_call1(Typerep_lib_Typename[9], rep$9[6]));
                 if(match$3)
                  var
                   rep$3 = match$3[1],
                   typename_of_t$2 = rep$9[5],
                   Conv$2 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[21], [0, rep$3[2]]),
                       [0, typename_of_t$2]),
                   L$3 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _p_ = rep$3[3],
                   _q_ = caml_call1(L$3[1], Conv$2[1][1]),
                   match$9 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _q_, _p_)];
                 else
                  var match$9 = 0;
                 if(match$9)
                  var
                   custom$6 = match$9[1],
                   _w_ = of_typerep(rep$9[4]),
                   _x_ = of_typerep(rep$9[3]),
                   _y_ = of_typerep(rep$9[2]),
                   custom$7 =
                     caml_call4(custom$6, of_typerep(rep$9[1]), _y_, _x_, _w_),
                   match$18 = [0, custom$7];
                 else
                  var match$18 = 0;
                 break;
                default:
                 var
                  rep$10 = named[1],
                  match$4 =
                    find(table5, caml_call1(Typerep_lib_Typename[9], rep$10[7]));
                 if(match$4)
                  var
                   rep$4 = match$4[1],
                   typename_of_t$3 = rep$10[6],
                   Conv$3 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[22], [0, rep$4[2]]),
                       [0, typename_of_t$3]),
                   L$4 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _r_ = rep$4[3],
                   _s_ = caml_call1(L$4[1], Conv$3[1][1]),
                   match$10 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _s_, _r_)];
                 else
                  var match$10 = 0;
                 if(match$10)
                  var
                   custom$8 = match$10[1],
                   _z_ = of_typerep(rep$10[5]),
                   _A_ = of_typerep(rep$10[4]),
                   _B_ = of_typerep(rep$10[3]),
                   _C_ = of_typerep(rep$10[2]),
                   custom$9 =
                     caml_call5
                      (custom$8, of_typerep(rep$10[1]), _C_, _B_, _A_, _z_),
                   match$18 = [0, custom$9];
                 else
                  var match$18 = 0;
              }
              if(match$18){var computation = match$18[1]; return computation;}
              if(! content){
               var
                _O_ = caml_call1(Typerep_lib_Typename[9], typename),
                string = caml_call1(Typerep_lib_Typename[8][4], _O_);
               throw caml_maybe_attach_backtrace
                      ([0, Not_implemented, name, string], 1);
              }
              var _M_ = content[1], _N_ = caml_obj_tag(_M_);
              a:
              if(250 === _N_)
               var content$0 = _M_[1];
              else{
               if(246 !== _N_ && 244 !== _N_){var content$0 = _M_; break a;}
               var content$0 = caml_call1(CamlinternalLazy[2], _M_);
              }
              if(caml_call1(X[33][5], content$0)){
               var shared$0 = caml_call2(X[33][2], context, typename);
               caml_call3(Memo[3], memo_table, typename, shared$0);
               var computation$0 = of_typerep(content$0);
               return caml_call2(X[33][4], shared$0, computation$0);
              }
              param$0 = content$0;
           }
          }
         }
         var computation = of_typerep(rep);
         return [0, 911962647, computation];
        }
        return [0,
                ident,
                Not_implemented,
                register0,
                register1,
                register2,
                register3,
                register4,
                register5,
                register,
                of_typerep,
                [0,
                 X[3],
                 X[4],
                 X[5],
                 X[6],
                 X[7],
                 X[8],
                 X[9],
                 X[10],
                 X[11],
                 X[12],
                 X[13],
                 X[14],
                 X[15],
                 X[16],
                 X[17],
                 X[18],
                 X[19],
                 X[20],
                 X[21],
                 X[22],
                 X[23],
                 X[24],
                 X[25],
                 X[26],
                 X[27],
                 X[28],
                 X[29],
                 X[30],
                 X[31],
                 X[32],
                 X[33]]];
       }];
   runtime.caml_register_global
    (20, Typerep_lib_Type_generic, "Typerep_lib__Type_generic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Make_typename
//# unitInfo: Requires: Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Make_typename =
      [0,
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[11], X),
         typename_of_t = Name_of_x[1],
         typename_of_named = Name_of_x[1],
         witness = Typerep_lib_Type_equal[2],
         named = [0, [0, typename_of_named, typename_of_t, witness]];
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[12], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1){
         var
          _o_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call1(Name_of_x[1], _o_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [1, [0, of_p1, typename_of_named, typename_of_t, witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[13], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2){
         var
          _m_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _n_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call2(Name_of_x[1], _n_, _m_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [2,
                 [0, of_p1, of_p2, typename_of_named, typename_of_t, witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[14], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3){
         var
          _j_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          _k_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _l_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call3(Name_of_x[1], _l_, _k_, _j_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [3,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[15], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3, of_p4){
         var
          _f_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
          _g_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          _h_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _i_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call4(Name_of_x[1], _i_, _h_, _g_, _f_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [4,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  of_p4,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[16], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3, of_p4, of_p5){
         var
          _a_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p5),
          _b_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
          _c_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          _d_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _e_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call5(Name_of_x[1], _e_, _d_, _c_, _b_, _a_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [5,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  of_p4,
                  of_p5,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       }];
   runtime.caml_register_global
    (3, Typerep_lib_Make_typename, "Typerep_lib__Make_typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_abstract
//# unitInfo: Requires: Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename;
   function Make0(X){
    var
     M = caml_call1(Typerep_lib_Make_typename[1], X),
     typerep_of_t = [9, [0, M[1], 0]],
     typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make1(X){
    var M = caml_call1(Typerep_lib_Make_typename[2], X);
    function typerep_of_t(of_p1){return [9, [0, caml_call1(M[1], of_p1), 0]];}
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make2(X){
    var M = caml_call1(Typerep_lib_Make_typename[3], X);
    function typerep_of_t(of_p1, of_p2){
     return [9, [0, caml_call2(M[1], of_p1, of_p2), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make3(X){
    var M = caml_call1(Typerep_lib_Make_typename[4], X);
    function typerep_of_t(of_p1, of_p2, of_p3){
     return [9, [0, caml_call3(M[1], of_p1, of_p2, of_p3), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make4(X){
    var M = caml_call1(Typerep_lib_Make_typename[5], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4){
     return [9, [0, caml_call4(M[1], of_p1, of_p2, of_p3, of_p4), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make5(X){
    var M = caml_call1(Typerep_lib_Make_typename[6], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4, of_p5){
     return [9, [0, caml_call5(M[1], of_p1, of_p2, of_p3, of_p4, of_p5), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   var
    Typerep_lib_Type_abstract = [0, Make0, Make1, Make2, Make3, Make4, Make5];
   runtime.caml_register_global
    (1, Typerep_lib_Type_abstract, "Typerep_lib__Type_abstract");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std
//# unitInfo: Requires: Typerep_lib__Std_internal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep = Typerep_lib_Std_internal[1],
    typerep_of_int = Typerep_lib_Std_internal[2],
    typerep_of_int32 = Typerep_lib_Std_internal[3],
    typerep_of_int64 = Typerep_lib_Std_internal[4],
    typerep_of_nativeint = Typerep_lib_Std_internal[5],
    typerep_of_int63 = Typerep_lib_Std_internal[6],
    typerep_of_char = Typerep_lib_Std_internal[7],
    typerep_of_float = Typerep_lib_Std_internal[8],
    typerep_of_string = Typerep_lib_Std_internal[9],
    typerep_of_bytes = Typerep_lib_Std_internal[10],
    typerep_of_bool = Typerep_lib_Std_internal[11],
    typerep_of_unit = Typerep_lib_Std_internal[12],
    value_tuple0 = Typerep_lib_Std_internal[13],
    typerep_of_option = Typerep_lib_Std_internal[14],
    typerep_of_list = Typerep_lib_Std_internal[15],
    typerep_of_array = Typerep_lib_Std_internal[16],
    typerep_of_lazy_t = Typerep_lib_Std_internal[17],
    typerep_of_ref = Typerep_lib_Std_internal[18],
    typerep_of_function = Typerep_lib_Std_internal[19],
    typerep_of_tuple0 = Typerep_lib_Std_internal[20],
    typerep_of_tuple2 = Typerep_lib_Std_internal[21],
    typerep_of_tuple3 = Typerep_lib_Std_internal[22],
    typerep_of_tuple4 = Typerep_lib_Std_internal[23],
    typerep_of_tuple5 = Typerep_lib_Std_internal[24],
    typename_of_int = Typerep_lib_Std_internal[25],
    typename_of_int32 = Typerep_lib_Std_internal[26],
    typename_of_int64 = Typerep_lib_Std_internal[27],
    typename_of_nativeint = Typerep_lib_Std_internal[28],
    typename_of_int63 = Typerep_lib_Std_internal[29],
    typename_of_char = Typerep_lib_Std_internal[30],
    typename_of_float = Typerep_lib_Std_internal[31],
    typename_of_string = Typerep_lib_Std_internal[32],
    typename_of_bytes = Typerep_lib_Std_internal[33],
    typename_of_bool = Typerep_lib_Std_internal[34],
    typename_of_unit = Typerep_lib_Std_internal[35],
    typename_of_option = Typerep_lib_Std_internal[36],
    typename_of_list = Typerep_lib_Std_internal[37],
    typename_of_array = Typerep_lib_Std_internal[38],
    typename_of_lazy_t = Typerep_lib_Std_internal[39],
    typename_of_ref = Typerep_lib_Std_internal[40],
    typename_of_function = Typerep_lib_Std_internal[41],
    typename_of_tuple0 = Typerep_lib_Std_internal[42],
    typename_of_tuple2 = Typerep_lib_Std_internal[43],
    typename_of_tuple3 = Typerep_lib_Std_internal[44],
    typename_of_tuple4 = Typerep_lib_Std_internal[45],
    typename_of_tuple5 = Typerep_lib_Std_internal[46],
    Typerep_lib_Std =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global(1, Typerep_lib_Std, "Typerep_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXJlcF9saWIuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJUeXBlcmVwX2xpYiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsY0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJUeXBlcmVwX2xpYl9OYW1lZF9pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyx5QkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjb252IiwicGFyYW0iLCJ4IiwiTGlmdCIsIlgiLCJsaWZ0IiwiVHlwZXJlcF9saWJfVHlwZV9lcXVhbCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi90eXBlcmVwL3R5cGVfZXF1YWwubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsS0FBQUMsT0FBQUMsR0NJcUQsU0FBQztBQUFBLFlBQUFDLEtBQUFDLFlBQUFDLEtBQUFKLE9BTUksU0FBQyxFRFYzRDtBQUFBLE9BQUFLLHlCQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJ0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBCYXNlLlR5cGVfZXF1YWwudCA9IFQgOiAoJ2EsICdhKSB0XG50eXBlICgnYSwgJ2IpIGVxdWFsID0gKCdhLCAnYikgdFxuXG5sZXQgcmVmbCA9IFRcbmxldCBjb252IDogdHlwZSBhIGIuIChhLCBiKSB0IC0+IGEgLT4gYiA9IGZ1biBUIHggLT4geFxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGEgWC50LCBiIFgudCkgdCA9IFRcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiVHlwZXJlcF9saWJfVHlwZV9lcXVhbCIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWIiLCJCYXNlIiwiU3RkbGliX0hhc2h0YmwiLCJjb21wYXJlIiwiYSIsImIiLCJlcXVhbCIsInVpZCIsIm5leHQiLCJuYW1lIiwiY29kZSIsImhhc2giLCJzdGF0aWMiLCJrMSIsImsyIiwiY21wIiwieXMiLCJ5IiwieHMiLCJ4IiwibiIsImNzdF9UeXBlbmFtZV9jcmVhdGUiLCJjc3RfVHlwZW5hbWVfc2FtZV93aXRuZXNzX2V4biIsImtleSIsInQiLCJjcmVhdGUiLCJvcHQiLCJwYXJhbSIsInNhbWUiLCJubTEiLCJubTIiLCJzYW1lX3dpdG5lc3MiLCJzYW1lX3dpdG5lc3NfZXhuIiwiS2V5X3RhYmxlIiwiVGFibGUiLCJYIiwiaW50IiwibWVtIiwidGFibGUiLCJzZXQiLCJkYXRhIiwiZmluZCIsIm1hdGNoIiwiZmFpbCIsInVpZF9hIiwidWlkX2IiLCJtc2ciLCJTYW1lX3dpdG5lc3NfZXhuXzEiLCJBIiwiQiIsIndpdG5lc3MiLCJTYW1lX3dpdG5lc3NfZXhuXzIiLCJTYW1lX3dpdG5lc3NfZXhuXzMiLCJTYW1lX3dpdG5lc3NfZXhuXzQiLCJTYW1lX3dpdG5lc3NfZXhuXzUiLCJUeXBlcmVwX2xpYl9UeXBlbmFtZSIsInR5cGVuYW1lX29mX3QiLCJjIiwiZCIsImUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvdHlwZXJlcC90eXBlbmFtZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFB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ZjtBQUFBLGlCQUFBaUQsY0FBQXBELEdBQUFDLEdBQUFvRCxHQUFBQyxHQUFBQztBQUFBQSxTQUNvQjtBQUFBLFFBQXVDO0FBQUEsUUFENUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBMUhDO0FBQUE7QUFBQTtBQUFBLEVEN0M1QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogdGhpcyBsaWIgc2hvdWxkIG5vdCBkZXBlbmQgb24gY29yZSAqKVxubW9kdWxlIExpc3QgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBMaXN0XG5cbiAgbGV0IGNvbXBhcmUgY21wIGEgYiA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiA9XG4gICAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICAgIHwgW10sIFtdIC0+IDBcbiAgICAgIHwgW10sIF8gLT4gLTFcbiAgICAgIHwgXywgW10gLT4gMVxuICAgICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICAgIGxldCBuID0gY21wIHggeSBpblxuICAgICAgICBpZiBuID0gMCB0aGVuIGxvb3AgeHMgeXMgZWxzZSBuXG4gICAgaW5cbiAgICBsb29wIGEgYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBVaWQgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gIHZhbCBuZXh0IDogc3RyaW5nIC0+IHRcbiAgdmFsIGhhc2ggOiB0IC0+IGludFxuICB2YWwgbmFtZSA6IHQgLT4gc3RyaW5nXG4gIHZhbCBzdGF0aWMgOiB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGNvZGUgOiBpbnRcbiAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICB9XG5cbiAgbGV0IGNvbXBhcmUgYSBiID0gY29tcGFyZSAoYS5jb2RlIDogaW50KSBiLmNvZGVcbiAgbGV0IGVxdWFsIGEgYiA9IChhLmNvZGUgOiBpbnQpID0gYi5jb2RlXG4gIGxldCB1aWQgPSByZWYgMFxuXG4gIGxldCBuZXh0IG5hbWUgPVxuICAgIGxldCBjb2RlID0gIXVpZCBpblxuICAgIGluY3IgdWlkO1xuICAgIHsgY29kZTsgbmFtZSB9XG4gIDs7XG5cbiAgbGV0IGhhc2ggYSA9IEhhc2h0YmwuaGFzaCBhLmNvZGVcbiAgbGV0IG5hbWUgYSA9IGEubmFtZVxuICBsZXQgc3RhdGljID0gbmV4dCBcInN0YXRpY1wiXG5lbmRcblxubW9kdWxlIEtleSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgdWlkIDogVWlkLnRcbiAgICA7IHBhcmFtcyA6IHQgbGlzdFxuICAgIH1cblxuICBsZXQgcmVjIGNvbXBhcmUgazEgazIgPVxuICAgIGlmIGsxID09IGsyXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY21wID0gVWlkLmNvbXBhcmUgazEudWlkIGsyLnVpZCBpblxuICAgICAgaWYgY21wIDw+IDAgdGhlbiBjbXAgZWxzZSBMaXN0LmNvbXBhcmUgY29tcGFyZSBrMS5wYXJhbXMgazIucGFyYW1zKVxuICA7O1xuXG4gIGxldCBlcXVhbCBhIGIgPSBjb21wYXJlIGEgYiA9IDBcbiAgbGV0IGhhc2ggPSAoSGFzaHRibC5oYXNoIDogdCAtPiBpbnQpXG4gIGxldCBzdGF0aWMgPSB7IHVpZCA9IFVpZC5zdGF0aWM7IHBhcmFtcyA9IFtdIH1cbmVuZFxuXG50eXBlICdhIHQgPSBLZXkudFxudHlwZSAnYSB0eXBlbmFtZSA9ICdhIHRcblxubGV0IGtleSB0ID0gdFxubGV0IHVpZCB0ID0gdC5LZXkudWlkXG5sZXQgbmFtZSB0ID0gVWlkLm5hbWUgdC5LZXkudWlkXG5sZXQgc3RhdGljID0gS2V5LnN0YXRpY1xubGV0IGNyZWF0ZSA/KG5hbWUgPSBcIlR5cGVuYW1lLmNyZWF0ZVwiKSAoKSA9IHsgS2V5LnVpZCA9IFVpZC5uZXh0IG5hbWU7IHBhcmFtcyA9IFtdIH1cblxuaW5jbHVkZSBzdHJ1Y3RcbiAgKCogVGhlIGFyZ3VtZW50IGZvciBPYmoubWFnaWMgaGVyZSBpcyB0aGUgc2FtZSBhcyB0aGUgb25lIGluIGNvcmUvdHlwZV9lcXVhbCAqKVxuXG4gIGxldCBzYW1lICh0eXBlIGEgYikgKG5tMSA6IGEgdCkgKG5tMiA6IGIgdCkgPSBLZXkuY29tcGFyZSBubTEgbm0yID0gMFxuXG4gIGxldCBzYW1lX3dpdG5lc3MgKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9XG4gICAgaWYgS2V5LmNvbXBhcmUgbm0xIG5tMiA9IDBcbiAgICB0aGVuIFNvbWUgKE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgOiAoYSwgYikgVHlwZV9lcXVhbC50KVxuICAgIGVsc2UgTm9uZVxuICA7O1xuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuICh0eXBlIGEgYikgKG5tMSA6IGEgdCkgKG5tMiA6IGIgdCkgPVxuICAgIGlmIEtleS5jb21wYXJlIG5tMSBubTIgPSAwXG4gICAgdGhlbiAoT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCA6IChhLCBiKSBUeXBlX2VxdWFsLnQpXG4gICAgZWxzZSBmYWlsd2l0aCBcIlR5cGVuYW1lLnNhbWVfd2l0bmVzc19leG5cIlxuICA7O1xuZW5kXG5cbm1vZHVsZSB0eXBlIFMwID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90IDogdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdHlwZW5hbWUgLT4gJ2EgdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdHlwZW5hbWUgLT4gJ2IgdHlwZW5hbWUgLT4gKCdhLCAnYikgdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMzID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHR5cGVuYW1lIC0+ICdiIHR5cGVuYW1lIC0+ICdjIHR5cGVuYW1lIC0+ICgnYSwgJ2IsICdjKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzQgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdFxuICAgIDogICdhIHR5cGVuYW1lXG4gICAgLT4gJ2IgdHlwZW5hbWVcbiAgICAtPiAnYyB0eXBlbmFtZVxuICAgIC0+ICdkIHR5cGVuYW1lXG4gICAgLT4gKCdhLCAnYiwgJ2MsICdkKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzUgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3RcbiAgICA6ICAnYSB0eXBlbmFtZVxuICAgIC0+ICdiIHR5cGVuYW1lXG4gICAgLT4gJ2MgdHlwZW5hbWVcbiAgICAtPiAnZCB0eXBlbmFtZVxuICAgIC0+ICdlIHR5cGVuYW1lXG4gICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoWCA6IE5hbWVkX2ludGYuUzApID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFtdIH1cbmVuZFxuXG5tb2R1bGUgTWFrZTEgKFggOiBOYW1lZF9pbnRmLlMxKSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90IGEgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFsgYSBdIH1cbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBOYW1lZF9pbnRmLlMyKSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90IGEgYiA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IE5hbWVkX2ludGYuUzMpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFsgYTsgYjsgYyBdIH1cbmVuZFxuXG5tb2R1bGUgTWFrZTQgKFggOiBOYW1lZF9pbnRmLlM0KSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90IGEgYiBjIGQgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFsgYTsgYjsgYzsgZCBdIH1cbmVuZFxuXG5tb2R1bGUgTWFrZTUgKFggOiBOYW1lZF9pbnRmLlM1KSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90IGEgYiBjIGQgZSA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjOyBkOyBlIF0gfVxuZW5kXG5cbm1vZHVsZSBLZXlfdGFibGUgPSBIYXNodGJsLk1ha2UgKEtleSlcblxubW9kdWxlIFRhYmxlIChYIDogc2lnXG4gICAgdHlwZSAnYSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgZGF0YSA9IERhdGEgOiAnYSB0ICogJ2EgWC50IC0+IGRhdGFcbiAgdHlwZSB0ID0gZGF0YSBLZXlfdGFibGUudFxuXG4gIGxldCBjcmVhdGUgaW50ID0gS2V5X3RhYmxlLmNyZWF0ZSBpbnRcbiAgbGV0IG1lbSB0YWJsZSBuYW1lID0gS2V5X3RhYmxlLm1lbSB0YWJsZSAoa2V5IG5hbWUpXG4gIGxldCBzZXQgdGFibGUgbmFtZSBkYXRhID0gS2V5X3RhYmxlLnJlcGxhY2UgdGFibGUgKGtleSBuYW1lKSAoRGF0YSAobmFtZSwgZGF0YSkpXG5cbiAgbGV0IGZpbmQgKHR5cGUgYSkgdGFibGUgKG5hbWUgOiBhIHR5cGVuYW1lKSA9XG4gICAgbGV0IGRhdGEgPVxuICAgICAgdHJ5IFNvbWUgKEtleV90YWJsZS5maW5kIHRhYmxlIChrZXkgbmFtZSkpIHdpdGhcbiAgICAgIHwgQmFzZS5Ob3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lXG4gICAgaW5cbiAgICBtYXRjaCBkYXRhIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSAoRGF0YSAobmFtZScsIGRhdGEpKSAtPlxuICAgICAgKGZ1biAodHlwZSBiKSAobmFtZScgOiBiIHR5cGVuYW1lKSAoZGF0YSA6IGIgWC50KSAtPlxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IChzYW1lX3dpdG5lc3NfZXhuIG5hbWUnIG5hbWUgOiAoYiwgYSkgVHlwZV9lcXVhbC50KSBpblxuICAgICAgICAgU29tZSAoZGF0YSA6IGEgWC50KSlcbiAgICAgICAgbmFtZSdcbiAgICAgICAgZGF0YVxuICA7O1xuZW5kXG5cbmxldCBmYWlsIHVpZF9hIHVpZF9iID1cbiAgbGV0IG1zZyA9XG4gICAgUHJpbnRmLnNwcmludGYgXCJUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuICVTICVTXCIgKFVpZC5uYW1lIHVpZF9hKSAoVWlkLm5hbWUgdWlkX2IpXG4gIGluXG4gIGZhaWx3aXRoIG1zZ1xuOztcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMSAoQSA6IFMxKSAoQiA6IFMxKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EuICgnYSBBLnQsICdhIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzIgKEEgOiBTMikgKEIgOiBTMikgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhICdiLiAoKCdhLCAnYikgQS50LCAoJ2EsICdiKSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzMgKEEgOiBTMykgKEIgOiBTMykgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhICdiICdjLiAoKCdhLCAnYiwgJ2MpIEEudCwgKCdhLCAnYiwgJ2MpIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgaWYgVWlkLmVxdWFsIHVpZF9hIHVpZF9iIHRoZW4geyBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl80IChBIDogUzQpIChCIDogUzQpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYSAnYiAnYyAnZC4gKCgnYSwgJ2IsICdjLCAnZCkgQS50LCAoJ2EsICdiLCAnYywgJ2QpIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzUgKEEgOiBTNSkgKEIgOiBTNSkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGVxIDpcbiAgICAgICAgJ2EgJ2IgJ2MgJ2QgJ2UuICgoJ2EsICdiLCAnYywgJ2QsICdlKSBBLnQsICgnYSwgJ2IsICdjLCAnZCwgJ2UpIEIudCkgVHlwZV9lcXVhbC50XG4gICAgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgaWYgVWlkLmVxdWFsIHVpZF9hIHVpZF9iIHRoZW4geyBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfY2FsbDMiLCJmIiwiYTAiLCJhMSIsImEyIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfQXJyYXkiLCJNIiwiWCIsIlRhZ19pbnRlcm5hbCIsImxhYmVsIiwidCIsImFyaXR5IiwiYXJnc19sYWJlbHMiLCJpbmRleCIsIm9jYW1sX3JlcHIiLCJjcmVhdGUiLCJ0eWlkIiwidHJhdmVyc2UiLCJpbnRlcm5hbF91c2Vfb25seSIsIlRhZyIsIlZhcmlhbnRfaW50ZXJuYWwiLCJ0eXBlbmFtZV9vZl90IiwibGVuZ3RoIiwidGFnIiwiaXNfcG9seW1vcnBoaWMiLCJ2YWx1ZSIsImZvbGQiLCJpbml0IiwiVmFyaWFudCIsIkZpZWxkX2ludGVybmFsIiwiZ2V0IiwiaXNfbXV0YWJsZSIsIkZpZWxkIiwiUmVjb3JkX2ludGVybmFsIiwiZmllbGQiLCJoYXNfZG91YmxlX2FycmF5X3RhZyIsIlJlY29yZCIsIlR5cGVyZXBfbGliX1ZhcmlhbnRfYW5kX3JlY29yZCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi90eXBlcmVwL3ZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxFQUFBQztBQUFBQSxRQUFBQyxlQUFBO0FBQUEsYUFBQUMsTUFBQUMsR0M0TmtCLFlBQU87QUFBQSxhQUFBQyxNQUFBRCxHQUNQLFlBQU87QUFBQSxhQUFBRSxZQUFBRixHQUNELFlBQWE7QUFBQSxhQUFBRyxNQUFBSCxHQUNuQixZQUFPO0FBQUEsYUFBQUksV0FBQUosR0FDRixZQUFZO0FBQUEsYUFBQUssT0FBQUwsR0FDaEIsWUFBUTtBQUFBLGFBQUFNLEtBQUFOLEdBQ1YsWUFBTTtBQUFBLGFBQUFPLFNBQUFQLEdBQ0YsWUFBSztBQUFBLGFBQUFRLGtCQUFBUixHQUNJLFNBQUM7QUFBQTtBQUFBLEtBQUFTO0FBQUFBLE9EcE8vQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUFDLG1CQUFBO0FBQUEsYUFBQUMsY0FBQVgsR0M4UzBCLFlBQVU7QUFBQSxhQUFBWSxPQUFBWixHQUNqQix1QkFBbUI7QUFBQSxhQUFBYSxJQUFBYixHQUFBRyxPQUNoQiwrQ0FBYztBQUFBLGFBQUFXLGVBQUFkLEdBQ1QsWUFBYTtBQUFBLGFBQUFlLE1BQUFmLEdBQ3RCLFlBQU87QUFBQSxhQUFBZ0IsS0FBQWhCLEdBQUFpQixNQUFBM0I7QUFBQUEsS0FDQyxrREFBNkI7QUFBQTtBQUFBLGFBQUFrQixvQkFBQVIsR0FDekIsU0FBQztBQUFBO0FBQUEsS0FBQWtCO0FBQUFBLE9EcFQvQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBQUMsaUJBQUE7QUFBQSxhQUFBcEIsUUFBQUMsR0NvWWtCLFlBQU87QUFBQSxhQUFBRyxRQUFBSCxHQUNQLFlBQU87QUFBQSxhQUFBb0IsSUFBQXBCLEdBQ1QsWUFBSztBQUFBLGFBQUFxQixXQUFBckIsR0FDRSxZQUFZO0FBQUEsYUFBQU0sT0FBQU4sR0FDbEIsWUFBTTtBQUFBLGFBQUFPLFdBQUFQLEdBQ0YsWUFBSztBQUFBLGFBQUFRLG9CQUFBUixHQUNJLFNBQUM7QUFBQTtBQUFBLEtBQUFzQjtBQUFBQSxPRDFZL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUFDLGtCQUFBO0FBQUEsYUFBQVosZ0JBQUFYLEdDMGQwQixZQUFVO0FBQUEsYUFBQVksU0FBQVosR0FDakIsdUJBQXFCO0FBQUEsYUFBQXdCLE1BQUF4QixHQUFBRyxPQUNoQiwrQ0FBZ0I7QUFBQSxhQUFBc0IscUJBQUF6QixHQUNQLFlBQXNCO0FBQUEsYUFBQUssU0FBQUwsR0FDcEMsWUFBUTtBQUFBLGFBQUFnQixPQUFBaEIsR0FBQWlCLE1BQUEzQjtBQUFBQSxLQUNELGtEQUErQjtBQUFBO0FBQUEsYUFBQWtCLG9CQUFBUixHQUMzQixTQUFDO0FBQUE7QUFBQSxLQUFBMEI7QUFBQUEsT0RoZS9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQzRDSztBQUFBLE9BQUFDLGlDRDVDTCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqXG4gICBQbGFjZSBob2xkZXIgZm9yIGNvbW1vbiBWYXJpYW50cyBhbmQgRmllbGRzIGludGVyZmFjZVxuKilcblxubW9kdWxlIE0gKFggOiBzaWdcbiAgICAoKipcbiAgICAgICBUaGlzIGZ1bmN0b3IgaXMgZXNzZW50aWFsbHkgdGhlcmUgYmVjYXVzZSB3ZSB1c2UgdGhpcyBzYW1lIGludGVyZmFjZSBpbiBkaWZmZXJlbnRcbiAgICAgICBjb250ZXh0cywgd2l0aCBkaWZmZXJlbnQgdHlwZXMgZm9yIFsnYSB0XS5cblxuICAgICAgIDEpIE9uZSB1c2UgY2FzZSBmb3IgaXQgaXMgd2hlcmUgWydhIFgudCA9ICdhIFR5cGVyZXAudF0uICBUaGVzZSBpbnRlcmZhY2VzIGFyZSB0aGVuXG4gICAgICAgcGFydCBvZiB0aGUgdHlwZSB3aXRuZXNzIGJ1aWx0IGZvciBhIHR5cGUgY29udGFpbmluZyBhIHJlY29yZCBvciBhIHZhcmlhbnQgaW4gaXRzXG4gICAgICAgc3RydWN0dXJlLiBbdHJhdmVyc2VdIHdpbGwgZ2l2ZSBhIHdheSBvZiBhY2Nlc3NpbmcgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZVxuICAgICAgIGFyZ3VtZW50cyBvZiBhIHZhcmlhbnQgb3IgcmVjb3JkIHR5cGUuXG5cbiAgICAgICAyKSBBbm90aGVyIHVzZSBjYXNlIGlzIGZvciBidWlsZGluZyBcInN0YWdlZCBnZW5lcmljIGNvbXB1dGF0aW9uc1wiLiBJbiB0aGF0IGNhc2UsIHRoZVxuICAgICAgIHR5cGUgWydhIFgudF0gaXMgdGhlIHR5cGUgb2YgdGhlIGNvbXB1dGF0aW9uIHRoYXQgaXMgYmVpbmcgYnVpbHQuICBbdHJhdmVyc2VdXG4gICAgICAgcmV0dXJucyB0aGUgY29tcHV0YXRpb24gYnVpbHQgZm9yIHRoZSBhcmd1bWVudC4gVGhlIGludGVyZmFjZSBubyBsb25nZXIgZXhwb3J0c1xuICAgICAgIHRoZSB0eXBlcmVwIG9mIHRoZSBhcmd1bWVudHMgaW4gaG9wZXMgb2YgZW5mb3JjaW5nIHRoYXQgbm8gdHlwZXJlcCB0cmF2ZXJzYWxcbiAgICAgICBoYXBwZW5zIGF0IHJ1bnRpbWUgaWYgdGhlIGNvbXB1dGF0aW9uIGhhcHBlbiB0byBiZSBhIGZ1bmN0aW9uLlxuICAgICopXG4gICAgdHlwZSAnYSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gICgqIFRoZSBmdW5jdGlvbnMgcHJlZml4ZWQgYnkgW2ludGVybmFsXSBhcyB3ZWxsIGFzIHRoZSBtb2R1bGUgc3VmZml4ZWQgYnkgW19pbnRlcm5hbF1cbiAgICAgYXJlIHVzZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIFt3aXRoIHR5cGVyZXBdIGFzIHdlbGwgYXMgc29tZVxuICAgICBpbnRlcm5hbHMgb2YgdGhlIHR5cGVyZXAgbGlicmFyeS4gRG8gbm90IGNvbnNpZGVyIHVzaW5nIHRoZXNlIHNvbWV3aGVyZSBlbHNlLiAgVGhleVxuICAgICBzaG91bGQgaWRlYWxseSBub3QgYmUgZXhwb3J0ZWQgb3V0c2lkZSB0aGUgdHlwZXJlcCBsaWJyYXJ5LCBidXQgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgIG5lZWRzIHNvbWVob3cgdG8gYWNjZXNzIHRoaXMsIGV2ZW4gb3V0c2lkZS4gKilcblxuICBtb2R1bGUgVGFnX2ludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGUgPVxuICAgICAgfCBBcmdzIG9mICgnYXJncyAtPiAndmFyaWFudClcbiAgICAgIHwgQ29uc3Qgb2YgJ3ZhcmlhbnRcblxuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgdCA9XG4gICAgICB7IGxhYmVsIDogc3RyaW5nXG4gICAgICA7IHJlcCA6ICdhcmdzIFgudFxuICAgICAgOyBhcml0eSA6IGludFxuICAgICAgOyBhcmdzX2xhYmVscyA6IHN0cmluZyBsaXN0XG4gICAgICA7IGluZGV4IDogaW50XG4gICAgICA7IG9jYW1sX3JlcHIgOiBpbnRcbiAgICAgIDsgdHlpZCA6ICdhcmdzIFR5cGVuYW1lLnRcbiAgICAgIDsgY3JlYXRlIDogKCd2YXJpYW50LCAnYXJncykgY3JlYXRlXG4gICAgICB9XG4gIGVuZFxuXG4gICgqKlxuICAgICBXaXRuZXNzIG9mIGEgdGFnLCB0aGF0IGlzIGFuIGl0ZW0gaW4gYSB2YXJpYW50IHR5cGUsIGFsc28gY2FsbGVkIGFuIFwiYXBwbGllZFxuICAgICB2YXJpYW50IENvbnN0cnVjdG9yXCJcblxuICAgICBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSB2YXJpYW50IHR5cGUsIHRoZSBzZWNvbmQgaXMgdGhlIHR5cGUgb2YgdGhlIHRhZ1xuICAgICBwYXJhbWV0ZXJzLiAgRXhhbXBsZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9XG4gICAgICAgICB8IEEgb2YgKGludCAqIHN0cmluZylcbiAgICAgICAgIHwgQiBvZiBzdHJpbmdcbiAgICAgICAgIHwgQyBvZiB7IHggOiBpbnQ7IHkgOiBzdHJpbmcgfVxuICAgICBdfVxuXG4gICAgIHRoaXMgdHlwZSBoYXMgdGhyZWUgY29uc3RydWN0b3JzLiBGb3IgZWFjaCBvZiB0aGVtIHdlJ2xsIGhhdmUgYSBjb3JyZXNwb25kaW5nXG4gICAgIFtUYWcudF06XG5cbiAgICAge1tcbiAgICAgICB2YWwgdGFnX0EgOiAodCwgKGludCAqIHN0cmluZykpIFRhZy50XG4gICAgICAgdmFsIHRhZ19CIDogKHQsIHN0cmluZyAgICAgICAgKSBUYWcudFxuICAgICAgIHZhbCB0YWdfQyA6ICh0LCAoaW50ICogc3RyaW5nKSkgVGFnLnRcbiAgICAgXX1cblxuICAgICBOb3RlLCBpbmxpbmUgcmVjb3JkIGluIHZhcmlhbnQgYXJlIHR5cGVkIGFzIGlmIHRoZWlyIGRlZmluaXRpb24gd2FzIHVzaW5nIHR1cGxlcyxcbiAgICAgd2l0aG91dCB0aGUgcGFyZW50aGVzaXMuICBUaGlzIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGVpciBydW50aW1lIHJlcHJlc2VudGF0aW9uLiAgQnV0XG4gICAgIHRoZSBkaXN0aW5jdGlvbiBpcyBjYXJyaWVkIGFuZCBhdmFpbGFibGUgZm9yIGludHJvc3BlY3Rpb24gYXMgcGFydCBvZiB0aGUgW1RhZy50XS5cbiAgICAgU2VlIFthcmdzX2xhYmVsc10uICopXG4gIG1vZHVsZSBUYWcgOiBzaWdcbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZSA9XG4gICAgICB8IEFyZ3Mgb2YgKCdhcmdzIC0+ICd2YXJpYW50KVxuICAgICAgfCBDb25zdCBvZiAndmFyaWFudFxuXG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSB0XG5cbiAgICAoKipcbiAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29uc3RydWN0b3IgYXMgaXQgaXMgZ2l2ZW4gaW4gdGhlIGNvbmNyZXRlIHN5bnRheFxuICAgICAgIEV4YW1wbGVzOlxuXG4gICAgICAge3ZcbiAgICAgICAgIENvbnN0cnVjdG9yICAgICAgICB8IGxhYmVsXG4gICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICB8IEEgb2YgaW50ICAgICAgICAgfCAgXCJBXCJcbiAgICAgICAgIHwgYGEgb2YgaW50ICAgICAgICB8ICBcImFcIlxuICAgICAgICAgfCBgQSBvZiBpbnQgICAgICAgIHwgIFwiQVwiXG4gICAgICAgICB8IEEgb2YgeyB4IDogaW50IH0gfCAgXCJBXCJcbiAgICAgICB2fVxuXG4gICAgICAgZm9yIHN0YW5kYXJkIHZhcmlhbnQsIHRoZSBvY2FtbCBzeW50YXggaW1wbGllcyB0aGF0IHRoaXMgbGFiZWwgd2lsbCBhbHdheXMgc3RhcnRzXG4gICAgICAgd2l0aCBhIGNhcGl0YWwgbGV0dGVyLiBGb3IgcG9seW1vcnBoaWMgdmFyaWFudHMsIHRoaXMgbWlnaHQgYmUgYSBsb3dlcmNhc2UgY2hhci5cbiAgICAgICBGb3IgcG9seW1vcnBoaWMgdmFyaWFudCwgdGhpcyBsYWJlbCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBbYF0gY2hhcmFjdGVyLlxuICAgICopXG4gICAgdmFsIGxhYmVsIDogKF8sIF8pIHQgLT4gc3RyaW5nXG5cbiAgICAoKipcbiAgICAgICBUaGUgc2l6ZSBvZiB0aGUgb2NhbWwgaGVhcCBibG9jayBjb250YWluaW5nIHRoZSBhcmd1bWVudHNcblxuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHt2XG4gICAgICAgICAgMDogfCBBIHwgJ0FcbiAgICAgICAgICAxOiB8IEEgb2YgaW50IHwgYEEgb2YgaW50IHwgQSBvZiAoaW50ICogaW50KSB8IGBBIG9mIChpbnQgKiBpbnQpXG4gICAgICAgICAgICAgfCBgQSBvZiBpbnQgKiBpbnRcbiAgICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50fVxuICAgICAgICAgIDI6IHwgQSBvZiBpbnQgKiBmbG9hdFxuICAgICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQ7IHkgOiBzdHJpbmcgfVxuICAgICAgICAgIGV0Yy5cbiAgICAgICB2fVxuICAgICopXG4gICAgdmFsIGFyaXR5IDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKiogVGhlIGxhYmVsIG9mIHRoZSBmaWVsZHMgZm9yIGlubGluZSByZWNvcmRzLiAgRm9yIG90aGVyIGZvcm1zIG9mIHRhZ3MsIHRoaXMgaXMgdGhlXG4gICAgICAgIGVtcHR5IGxpc3QuICBXaGVuIHRoaXMgcmV0dXJucyBhIG5vbiBlbXB0eSBsaXN0LCB0aGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBsaXN0XG4gICAgICAgIGlzIGVxdWFsIHRvIHRoZSBhcml0eS5cblxuICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgIHt2XG4gICAgICAgICAoMSkgRW1wdHk6XG5cbiAgICAgICAgICAgfCBBIHwgJ0FcbiAgICAgICAgICAgfCBBIG9mIGludCB8IGBBIG9mIGludCB8IEEgb2YgKGludCAqIGludCkgfCBgQSBvZiAoaW50ICogaW50KVxuICAgICAgICAgICB8IGBBIG9mIGludCAqIGludFxuICAgICAgICAgICB8IEEgb2YgaW50ICogZmxvYXRcblxuICAgICAgICAgKDIpIE5vbiBlbXB0eTpcblxuICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50IH0gICAgICAgICAgICAgICAtPiBbIFwieFwiIF1cbiAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9ICAgLT4gWyBcInhcIiA7IFwieVwiIF1cbiAgICAgICB2fVxuICAgICopXG4gICAgdmFsIGFyZ3NfbGFiZWxzIDogKF8sIF8pIHQgLT4gc3RyaW5nIGxpc3RcblxuICAgICgqKlxuICAgICAgIFRoZSBpbmRleCBvZiB0aGUgY29uc3RydWN0b3IgaW4gdGhlIGxpc3Qgb2YgYWxsIHRoZSB2YXJpYW50IHR5cGUncyBjb25zdHJ1Y3RvcnNcbiAgICAgICBFeGFtcGxlczpcbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICAgfCBBIG9mIGludCAgICAgICAgICAoKiAwICopXG4gICAgICAgICAgIHwgQiAgICAgICAgICAgICAgICAgKCogMSAqKVxuICAgICAgICAgICB8IEMgb2YgaW50ICAgICAgICAgICgqIDIgKilcbiAgICAgICAgICAgfCBEIG9mIGNoYXIgICAgICAgICAoKiAzICopXG4gICAgICAgICAgIHwgRSBvZiB7IHggOiBpbnQgfSAgKCogNCAqKVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgaW5kZXggOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKlxuICAgICAgIG9jYW1sX3JlcHIgaXMgcmVsYXRlZCB0byB0aGUgcnVudGltZSBvZiBvYmplY3RzLiB0aGlzIGlzIGVzc2VudGlhbGx5IGEgd2F5IG9mXG4gICAgICAgZ2l2aW5nIG9uZSB0aGUgYWJpbGl0eSB0byByZWJ1aWxkIGR5bmFtaWNhbGx5IGFuIFtPYmoudF0gcmVwcmVzZW50aW5nIGEgdGFnLlxuXG4gICAgICAgUG9seW1vcnBoaWMgdmFyaWFudHM6XG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICBbb2NhbWxfcmVwcl0gaXMgdGhlIGhhc2ggb2YgdGhlIGxhYmVsLCBhcyBkb25lIGJ5IHRoZSBjb21waWxlci5cbiAgICAgICBFeGFtcGxlOlxuICAgICAgIHByaW50X2ludCAoT2JqLm1hZ2ljIGBiYXIpICAoKiA0ODk1MTg3ICopXG4gICAgICAgcHJpbnRfaW50IChPYmoubWFnaWMgJ2ZvbykgICgqIDUwOTcyMjIgKilcblxuICAgICAgIFN0YW5kYXJkcyB2YXJpYW50czpcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICBbb2NhbWxfcmVwcl0gaXMgdGhlIHRhZyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjb25zdHJ1Y3RvciB3aXRoaW4gdGhlIHR5cGUuXG4gICAgICAgdGhlIHdheSBpdCB3b3JrcyBpbiB0aGUgb2NhbWwgcnVudGltZSBpcyBieSBwYXJ0aXRpb25pbmcgdGhlIGNvbnN0cnVjdG9ycyByZWdhcmRpbmdcbiAgICAgICBpZiB0aGV5IGhhdmUgc29tZSBhcmd1bWVudHMgb3Igbm90LCBwcmVzZXJ2aW5nIHRoZSBvcmRlciwgdGhlbiBhc3NpZ24gaW5jcmVhc2luZ1xuICAgICAgIGluZGV4IHdpdGhpbmcgZWFjaCBwYXJ0aXRpb24uXG4gICAgICAgRXhhbXBsZTpcblxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPSAgICAgICAgICAgICAgICAgICgqIG5vIGFyZyAqKSAgKCogYXJncyAqKVxuICAgICAgICAgICB8IEEgICAgICAgICAgICAgICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBCIG9mIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBDICAgICAgICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgRCBvZiAoZmxvYXQgKiBzdHJpbmcpICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgRSAgICAgICAgICAgICAgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEYgICAgICAgICAgICAgICAgICAgICAgICgqIDMgKilcbiAgICAgICAgICAgfCBHIG9mIHN0cmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIDIgKilcbiAgICAgICAgICAgfCBIIG9mIHsgeCA6IGludCB9ICAgICAgICAgICAgICAgICAgICAgICgqIDMgKilcbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIG9jYW1sX3JlcHIgOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKlxuICAgICAgIEdpdmUgYmFjayBhIHdheSBvZiBjb25zdHJ1Y3RpbmcgYSB2YWx1ZSBvZiB0aGF0IGNvbnN0cnVjdG9yIGZyb20gaXRzIGFyZ3VtZW50cy5cblxuICAgICAgIEV4YW1wbGVzOlxuXG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9XG4gICAgICAgICAgIHwgQSBvZiAoaW50ICogc3RyaW5nKVxuICAgICAgICAgICB8IEIgb2YgaW50ICogZmxvYXRcbiAgICAgICAgICAgfCBDXG4gICAgICAgICAgIHwgRCBvZiB7IHggOiBpbnQ7IHkgOiBzdHJpbmcgfVxuICAgICAgIF19XG5cbiAgICAgICBbY3JlYXRlXSB3aWxsIHJldHVybiBzb21ldGhpbmcgZXF1aXZhbGVudCB0bzpcbiAgICAgICB0YWdfQSA6IFtBcmdzIChmdW4gKGQgOiAoaW50ICogc3RyaW5nKSAtPiBBIGQpXVxuICAgICAgIHRhZ19CIDogW0FyZ3MgKGZ1biAoaSwgZikgLT4gQiAoaSwgZikpXVxuICAgICAgIHRhZ19DIDogW0NvbnN0IENdXG4gICAgICAgdGFnX0QgOiBbQXJncyAoZnVuICh4LCB5KSAtPiBEIHsgeDsgeSB9KV1cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiAoJ3ZhcmlhbnQsICdhcmdzKSB0IC0+ICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZVxuXG4gICAgKCoqIHJldHVybiB0aGUgdHlwZV9uYW1lIG9mIHRoZSBhcmd1bWVudHMuIG1pZ2h0IGJlIHVzZWQgdG8gcGVyZm9ybSBzb21lIGxvb2t1cCBiYXNlZFxuICAgICAgICBvbiBpdCB3aGlsZSBidWlsZGluZyBhIGNvbXB1dGF0aW9uIGZvciBleGFtcGxlICopXG4gICAgdmFsIHR5aWQgOiAoXywgJ2FyZ3MpIHQgLT4gJ2FyZ3MgVHlwZW5hbWUudFxuXG4gICAgKCoqIGdldCB0aGUgcmVwcmVzZW50YXRpb24vY29tcHV0YXRpb24gb2YgdGhlIGFyZ3VtZW50cyAqKVxuICAgIHZhbCB0cmF2ZXJzZSA6IChfLCAnYXJncykgdCAtPiAnYXJncyBYLnRcblxuICAgICgqIHVzZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gdG8gYnVpbGQgdHlwZSB3aXRuZXNzZXMsIG9yIGJ5IHNvbWUgaW50ZXJuYWwgcGFydHMgb2ZcbiAgICAgICB0eXBlcmVwLiB5b3Ugc2hvdWxkIGZlZWwgYmFkIGlmIHlvdSBuZWVkIHRvIHVzZSBpdCBpbiBzb21lIHVzZXIgY29kZSAqKVxuICAgIHZhbCBpbnRlcm5hbF91c2Vfb25seSA6ICgnYSwgJ2IpIFRhZ19pbnRlcm5hbC50IC0+ICgnYSwgJ2IpIHRcbiAgZW5kID0gc3RydWN0XG4gICAgaW5jbHVkZSBUYWdfaW50ZXJuYWxcblxuICAgIGxldCBsYWJlbCB0ID0gdC5sYWJlbFxuICAgIGxldCBhcml0eSB0ID0gdC5hcml0eVxuICAgIGxldCBhcmdzX2xhYmVscyB0ID0gdC5hcmdzX2xhYmVsc1xuICAgIGxldCBpbmRleCB0ID0gdC5pbmRleFxuICAgIGxldCBvY2FtbF9yZXByIHQgPSB0Lm9jYW1sX3JlcHJcbiAgICBsZXQgY3JlYXRlIHQgPSB0LmNyZWF0ZVxuICAgIGxldCB0eWlkIHQgPSB0LnR5aWRcbiAgICBsZXQgdHJhdmVyc2UgdCA9IHQucmVwXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBWYXJpYW50X2ludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSBfIHRhZyA9IFRhZyA6ICgndmFyaWFudCwgJ2EpIFRhZy50IC0+ICd2YXJpYW50IHRhZ1xuICAgIHR5cGUgXyB2YWx1ZSA9IFZhbHVlIDogKCd2YXJpYW50LCAnYSkgVGFnLnQgKiAnYSAtPiAndmFyaWFudCB2YWx1ZVxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgdHlwZW5hbWUgOiAnYSBUeXBlbmFtZS50XG4gICAgICA7IHRhZ3MgOiAnYSB0YWcgYXJyYXlcbiAgICAgIDsgcG9seW1vcnBoaWMgOiBib29sXG4gICAgICA7IHZhbHVlIDogJ2EgLT4gJ2EgdmFsdWVcbiAgICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIFZhcmlhbnQgOiBzaWdcbiAgICAoKipcbiAgICAgICBBbiBleGlzdGVudGlhbCB0eXBlIHVzZWQgdG8gZ2F0aGVyIGFsbCB0aGUgdGFncyBjb25zdGl0dWluZyBhIHZhcmlhbnRcbiAgICAgICB0eXBlLiB0aGUgWyd2YXJpYW50XSBwYXJhbWV0ZXIgaXMgdGhlIHZhcmlhbnQgdHlwZSwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCB0aGVcbiAgICAgICBjb25zdHJ1Y3RvcnMgb2YgdGhhdCB2YXJpYW50IHR5cGUuIFRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIG1pZ2h0IGJlIGRpZmZlcmVudFxuICAgICAgIGZvciBlYWNoIGNvbnN0cnVjdG9yIGFuZCBpcyB0aHVzIGV4aXN0ZW50aWFsXG4gICAgKilcbiAgICB0eXBlIF8gdGFnID0gVGFnIDogKCd2YXJpYW50LCAnYXJncykgVGFnLnQgLT4gJ3ZhcmlhbnQgdGFnXG5cbiAgICAoKipcbiAgICAgICBBIHNpbWlsYXIgZXhpc3RlbnRpYWwgY29uc3RydWN0b3IgdG8gW18gdGFnXSBidXQgdGhpcyBvbmUgaG9sZHMgYSB2YWx1ZSB3aG9zZSB0eXBlXG4gICAgICAgaXMgdGhlIGFyZ3VtZW50cyBvZiB0aGUgdGFnIGNvbnN0cnVjdG9yLiAgQSB2YWx1ZSBvZiB0eXBlIFsnYSB2YWx1ZV0gaXMgYSBwYWlyIG9mXG4gICAgICAgKDEpIGEgdmFsdWUgb2YgdmFyaWFudCB0eXBlIFsnYV0gYWxvbmcgd2l0aCAoMikgc29tZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgICAgICBjb25zdHJ1Y3RvciB3aXRoaW4gdGhlIHR5cGUgWydhXVxuICAgICopXG4gICAgdHlwZSBfIHZhbHVlID0gVmFsdWUgOiAoJ3ZhcmlhbnQsICdhcmdzKSBUYWcudCAqICdhcmdzIC0+ICd2YXJpYW50IHZhbHVlXG5cbiAgICAoKipcbiAgICAgICBXaXRuZXNzIG9mIGEgdmFyaWFudCB0eXBlLiBUaGUgcGFyYW1ldGVyIGlzIHRoZSB0eXBlIG9mIHRoZSB2YXJpYW50IHR5cGUgd2l0bmVzc2VkLlxuICAgICopXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuXG4gICAgKCoqXG4gICAgICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRhZ3Mgb2YgdGhpcyB2YXJpYW50IHR5cGUgZGVmaW5pdGlvbi5cbiAgICAqKVxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2V0IHRoZSBudGggdGFnIG9mIHRoaXMgdmFyaWFudCB0eXBlLCBpbmRleGVkIGZyb20gMC5cbiAgICAqKVxuICAgIHZhbCB0YWcgOiAnYSB0IC0+IGludCAtPiAnYSB0YWdcblxuICAgICgqKlxuICAgICAgIERpc3Rpbmd1aXNoIHBvbHltb3JwaGljIHZhcmlhbnRzIGFuZCBzdGFuZGFyZCB2YXJpYW50cy4gVHlwaWNhbGx5LCBwb2x5bW9ycGhpY1xuICAgICAgIHZhcmlhbnRzIHRhZ3Mgc3RhcnRzIHdpdGggdGhlIFtgXSBjaGFyYWN0ZXIuXG4gICAgICAgRXhhbXBsZVxuICAgICAgIHBvbHltb3JwaGljIHZhcmlhbnQ6IHR5cGUgdCA9IFsgYEEgfCBgQiBdXG4gICAgICAgc3RhbmRhcmQgdmFyaWFudDogICAgdHlwZSB0ID0gQSB8IEJcbiAgICAqKVxuICAgIHZhbCBpc19wb2x5bW9ycGhpYyA6IF8gdCAtPiBib29sXG5cbiAgICAoKipcbiAgICAgICBQYXR0ZXJuIG1hdGNoaW5nIG9uIGEgdmFsdWUgb2YgdGhpcyB2YXJpYW50IHR5cGUuXG4gICAgKilcbiAgICB2YWwgdmFsdWUgOiAnYSB0IC0+ICdhIC0+ICdhIHZhbHVlXG5cbiAgICAoKipcbiAgICAgICBmb2xkaW5nIGFsb25nIHRoZSB0YWdzIG9mIHRoZSB2YXJpYW50IHR5cGVcbiAgICAqKVxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiAnYSB0YWcgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogJ2EgVmFyaWFudF9pbnRlcm5hbC50IC0+ICdhIHRcbiAgZW5kID0gc3RydWN0XG4gICAgaW5jbHVkZSBWYXJpYW50X2ludGVybmFsXG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCB0ID0gdC50eXBlbmFtZVxuICAgIGxldCBsZW5ndGggdCA9IEFycmF5Lmxlbmd0aCB0LnRhZ3NcbiAgICBsZXQgdGFnIHQgaW5kZXggPSB0LnRhZ3MuKGluZGV4KVxuICAgIGxldCBpc19wb2x5bW9ycGhpYyB0ID0gdC5wb2x5bW9ycGhpY1xuICAgIGxldCB2YWx1ZSB0ID0gdC52YWx1ZVxuICAgIGxldCBmb2xkIHQgfmluaXQgfmYgPSBBcnJheS5mb2xkX2xlZnQgZiBpbml0IHQudGFnc1xuICAgIGxldCBpbnRlcm5hbF91c2Vfb25seSB0ID0gdFxuICBlbmRcblxuICBtb2R1bGUgRmllbGRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlICgncmVjb3JkLCAnZmllbGQpIHQgPVxuICAgICAgeyBsYWJlbCA6IHN0cmluZ1xuICAgICAgOyByZXAgOiAnZmllbGQgWC50XG4gICAgICA7IGluZGV4IDogaW50XG4gICAgICA7IHR5aWQgOiAnZmllbGQgVHlwZW5hbWUudFxuICAgICAgOyBnZXQgOiAncmVjb3JkIC0+ICdmaWVsZFxuICAgICAgOyAoKiBzZXQgOiAoJ3JlY29yZCAtPiAnZmllbGQgLT4gdW5pdCkgb3B0aW9uOyAoXFwqIG11dGFibGUgZmllbGQgKlxcKSAqKVxuICAgICAgICBpc19tdXRhYmxlIDogYm9vbFxuICAgICAgfVxuICBlbmRcblxuICAoKipcbiAgICAgV2l0bmVzcyBvZiBhIGZpZWxkLCB0aGF0IGlzIGFuIGl0ZW0gaW4gYSByZWNvcmQgdHlwZS5cbiAgICAgVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmVjb3JkIHR5cGUsIHRoZSBzZWNvbmQgaXMgdGhlIHR5cGUgb2YgdGhlIGZpZWxkLlxuICAgICBFeGFtcGxlOlxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludCA7IHkgOiBzdHJpbmcgfVxuICAgICBdfVxuICAgICBUaGlzIHR5cGUgaGFzIHR3byBmaWVsZHMuIGZvciBlYWNoIG9mIHRoZW0gd2UnbGwgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgW0ZpZWxkLnRdXG5cbiAgICAgdmFsIGZpZWxkX3ggOiAodCwgaW50KSBGaWVsZC50XG4gICAgIHZhbCBmaWVsZF95IDogKHQsIHN0cmluZykgRmllbGQudFxuICAqKVxuICBtb2R1bGUgRmllbGQgOiBzaWdcbiAgICB0eXBlICgncmVjb3JkLCAnZmllbGQpIHRcblxuXG4gICAgKCoqXG4gICAgICAgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIGFzIGl0IGlzIGdpdmVuIGluIHRoZSBjb25jcmV0ZSBzeW50YXhcbiAgICAgICBFeGFtcGxlczpcbiAgICAgICB7W1xuICAgICAgICAgeyB4ICAgOiBpbnQ7ICAgICAoKiBcInhcIiAqKVxuICAgICAgICAgICBmb28gOiBzdHJpbmc7ICAoKiBcImZvb1wiICopXG4gICAgICAgICAgIGJhciA6IGZsb2F0OyAgICgqIFwiYmFyXCIgKilcbiAgICAgICAgIH1cbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIGxhYmVsIDogKF8sIF8pIHQgLT4gc3RyaW5nXG5cbiAgICAoKipcbiAgICAgICBUaGUgMC1iYXNlZCBpbmRleCBvZiB0aGUgZmllbGQgaW4gdGhlIGxpc3Qgb2YgYWxsIGZpZWxkcyBmb3IgdGhpcyByZWNvcmQgdHlwZS5cbiAgICAgICBFeGFtcGxlOlxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPSB7XG4gICAgICAgICAgIHggICA6IGludDsgICAgICgqIDAgKilcbiAgICAgICAgICAgZm9vIDogc3RyaW5nOyAgKCogMSAqKVxuICAgICAgICAgICBiYXIgOiBzdHJpbmc7ICAoKiAyICopXG4gICAgICAgICB9XG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBpbmRleCA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgRmllbGQgYWNjZXNzb3JzLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBkb3Qgb3BlcmF0aW9uLlxuICAgICAgIFtGaWVsZC5nZXQgYmFyX2ZpZWxkIHRdIHJldHVybnMgdGhlIGZpZWxkIFtiYXJdIG9mIHRoZSByZWNvcmQgdmFsdWUgW3RdLCBqdXN0IHRoZVxuICAgICAgIHNhbWUgYXMgW3QuYmFyXVxuICAgICopXG4gICAgdmFsIGdldCA6ICgncmVjb3JkLCAnZmllbGQpIHQgLT4gJ3JlY29yZCAtPiAnZmllbGRcblxuICAgICgqKiByZXR1cm4gd2hldGhlciB0aGUgZmllbGQgaXMgbXV0YWJsZSwgaS5lLiB3aGV0aGVyIGl0cyBkZWNsYXJhdGlvbiBpcyBwcmVmaXhlZCB3aXRoXG4gICAgICAgIHRoZSBrZXl3b3JkIFttdXRhYmxlXSAqKVxuICAgIHZhbCBpc19tdXRhYmxlIDogKF8sIF8pIHQgLT4gYm9vbFxuXG4gICAgKCoqIHJldHVybiB0aGUgdHlwZV9uYW1lIG9mIHRoZSBhcmd1bWVudHMuICBNaWdodCBiZSB1c2VkIHRvIHBlcmZvcm0gc29tZSBsb29rdXAgYmFzZWRcbiAgICAgICAgb24gaXQgKilcbiAgICB2YWwgdHlpZCA6IChfLCAnZmllbGQpIHQgLT4gJ2ZpZWxkIFR5cGVuYW1lLnRcblxuICAgICgqKiBnZXQgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBhcmd1bWVudHMgKilcbiAgICB2YWwgdHJhdmVyc2UgOiAoXywgJ2ZpZWxkKSB0IC0+ICdmaWVsZCBYLnRcblxuICAgICgqIHVzZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gdG8gYnVpbGQgdHlwZSB3aXRuZXNzZXMsIG9yIGJ5IHNvbWUgaW50ZXJuYWwgcGFydHMgb2ZcbiAgICAgICB0eXBlcmVwLiB5b3Ugc2hvdWxkIGZlZWwgYmFkIGlmIHlvdSBuZWVkIHRvIHVzZSBpdCBpbiBzb21lIHVzZXIgY29kZSAqKVxuICAgIHZhbCBpbnRlcm5hbF91c2Vfb25seSA6ICgnYSwgJ2IpIEZpZWxkX2ludGVybmFsLnQgLT4gKCdhLCAnYikgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEZpZWxkX2ludGVybmFsXG5cbiAgICBsZXQgbGFiZWwgdCA9IHQubGFiZWxcbiAgICBsZXQgaW5kZXggdCA9IHQuaW5kZXhcbiAgICBsZXQgZ2V0IHQgPSB0LmdldFxuICAgIGxldCBpc19tdXRhYmxlIHQgPSB0LmlzX211dGFibGVcbiAgICBsZXQgdHlpZCB0ID0gdC50eWlkXG4gICAgbGV0IHRyYXZlcnNlIHQgPSB0LnJlcFxuICAgIGxldCBpbnRlcm5hbF91c2Vfb25seSB0ID0gdFxuICBlbmRcblxuICBtb2R1bGUgUmVjb3JkX2ludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSBfIGZpZWxkID0gRmllbGQgOiAoJ3JlY29yZCwgJ2EpIEZpZWxkLnQgLT4gJ3JlY29yZCBmaWVsZFxuICAgIHR5cGUgJ3JlY29yZCBmaWVsZHMgPSB7IGdldCA6ICdmaWVsZC4gKCdyZWNvcmQsICdmaWVsZCkgRmllbGQudCAtPiAnZmllbGQgfVxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgdHlwZW5hbWUgOiAnYSBUeXBlbmFtZS50XG4gICAgICA7IGZpZWxkcyA6ICdhIGZpZWxkIGFycmF5XG4gICAgICA7IGhhc19kb3VibGVfYXJyYXlfdGFnIDogYm9vbFxuICAgICAgOyBjcmVhdGUgOiAnYSBmaWVsZHMgLT4gJ2FcbiAgICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIFJlY29yZCA6IHNpZ1xuICAgICgqKlxuICAgICAgIEFuIGV4aXN0ZW50aWFsIHR5cGUgdXNlZCB0byBnYXRoZXIgYWxsIHRoZSBmaWVsZHMgY29uc3RpdHVpbmcgYSByZWNvcmQgdHlwZS4gdGhlXG4gICAgICAgWydyZWNvcmRdIHBhcmFtZXRlciBpcyB0aGUgcmVjb3JkIHR5cGUsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgdGhlIGZpZWxkIG9mIHRoYXRcbiAgICAgICByZWNvcmQgdHlwZS4gVGhlIHR5cGUgb2YgdGhlIGZpZWxkcyBtaWdodCBiZSBkaWZmZXJlbnQgZm9yIGVhY2ggZmllbGQgYW5kIGlzIHRodXNcbiAgICAgICBleGlzdGVudGlhbC5cbiAgICAqKVxuICAgIHR5cGUgXyBmaWVsZCA9IEZpZWxkIDogKCdyZWNvcmQsICdhKSBGaWVsZC50IC0+ICdyZWNvcmQgZmllbGRcblxuICAgICgqKlxuICAgICAgIFsncmVjb3JkIGZpZWxkc10gaXMgYSB0eXBlIGlzb21vcnBoaWMgdG8gWydyZWNvcmRdLiAgVGhpcyBnaXZlcyBhIHdheSB0byBnZXQgdGhlXG4gICAgICAgZmllbGQgdmFsdWUgZm9yIGVhY2ggZmllbGQgb2YgdGhlIHJlY29yZC4gIFRoZSBhZHZhbnRhZ2Ugb2YgdGhpcyByZXByZXNlbnRhdGlvbiBpc1xuICAgICAgIHRoYXQgaXQgaXMgY29udmVuaWVudCBmb3Igd3JpdGluZyBnZW5lcmljIGNvbXB1dGF0aW9ucy5cbiAgICAqKVxuICAgIHR5cGUgJ3JlY29yZCBmaWVsZHMgPSB7IGdldCA6ICdmaWVsZC4gKCdyZWNvcmQsICdmaWVsZCkgRmllbGQudCAtPiAnZmllbGQgfVxuXG4gICAgKCoqXG4gICAgICAgV2l0bmVzcyBvZiBhIHJlY29yZCB0eXBlLiBUaGUgcGFyYW1ldGVyIGlzIHRoZSB0eXBlIG9mIHRoZSByZWNvcmQgdHlwZSB3aXRuZXNzZWQuXG4gICAgKilcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG5cbiAgICAoKipcbiAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZmllbGRzIG9mIHRoaXMgcmVjb3JkIHR5cGUgZGVmaW5pdGlvbi5cbiAgICAqKVxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2V0IHRoZSBudGggZmllbGQgb2YgdGhpcyByZWNvcmQgdHlwZSwgaW5kZXhlZCBmcm9tIDAuXG4gICAgKilcbiAgICB2YWwgZmllbGQgOiAnYSB0IC0+IGludCAtPiAnYSBmaWVsZFxuXG4gICAgKCoqXG4gICAgICAgVGhpcyBpcyBhIGxvdyBsZXZlbCBtZXRhZGF0YSByZWdhcmRpbmcgdGhlIHdheSB0aGUgb2NhbWwgY29tcGlsZXIgcmVwcmVzZW50IHRoZVxuICAgICAgIGFycmF5IHVuZGVybmVhdGggdGhhdCBpcyB0aGUgcnVudGltZSB2YWx1ZSBvZiBhIHJlY29yZCBvZiB0eXBlIFsnYV0gZ2l2ZW4gYSB3aXRuZXNzXG4gICAgICAgb2YgdHlwZSBbJ2EgdF0uIFtoYXNfZG91YmxlX2FycmF5X3RhZyB3XSByZXR1cm5zIFt0cnVlXSBpZiB0aGUgYXJyYXkgdGhhdFxuICAgICAgIHJlcHJlc2VudHMgcnVudGltZSB2YWx1ZXMgb2YgdGhpcyB0eXBlIGlzIGFuIG9wdGltaXplZCBvY2FtbCBmbG9hdCBhcnJheS5cbiAgICAgICBUeXBpY2FsbHksIHRoaXMgd2lsbCBiZSB0cnVlIGZvciByZWNvcmQgd2hlcmUgYWxsIGZpZWxkcyBhcmUgc3RhdGljYWxseSBrbm93biBhcyB0b1xuICAgICAgIGJlIFtmbG9hdHNdLlxuXG4gICAgICAgTm90ZSB0aGF0IHlvdSBjYW4ndCBnZXQgdGhpcyBpbmZvcm1hdGlvbiBkeW5hbWljYWxseSBieSBpbnNwZWN0aW5nIHRoZSB0eXBlcmVwIG9uY2VcbiAgICAgICBpdCBpcyBhcHBsaWVkLCBiZWNhdXNlIHRoZXJlIGlzIGF0IHRoaXMgcG9pbnQgbm8gd2F5IHRvIHRlbGwgd2hldGhlciBvbmUgb2YgdGhlXG4gICAgICAgZmllbGQgaXMgcG9seW1vcnBoaWMgaW4gdGhlIHR5cGUgZGVmaW5pdGlvbi5cbiAgICAqKVxuICAgIHZhbCBoYXNfZG91YmxlX2FycmF5X3RhZyA6IF8gdCAtPiBib29sXG5cbiAgICAoKipcbiAgICAgICBFeHBvc2Ugb25lIGRpcmVjdGlvbiBvZiB0aGUgaXNvbW9ycGhpc20gYmV0d2VlbiBhIHZhbHVlIG9mIHR5cGUgWydhXSBhbmQgYSB2YWx1ZSBvZlxuICAgICAgIHR5cGUgWydhIGZpZWxkc10uIEJhc2ljYWxseSwgZ2l2ZW4gYW4gZW5jb2Rpbmcgd2F5IG9mIGFjY2Vzc2luZyB0aGUgdmFsdWUgb2YgYWxsXG4gICAgICAgdGhlIGZpZWxkcyBvZiBhIHJlY29yZCwgY3JlYXRlIHRoYXQgcmVjb3JkIGFuZCByZXR1cm4gaXQuXG4gICAgKilcbiAgICB2YWwgY3JlYXRlIDogJ2EgdCAtPiAnYSBmaWVsZHMgLT4gJ2FcblxuICAgICgqKlxuICAgICAgIGZvbGRpbmcgYWxvbmcgdGhlIHRhZ3Mgb2YgdGhlIHZhcmlhbnQgdHlwZVxuICAgICopXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIGZpZWxkIC0+ICdhY2MpIC0+ICdhY2NcblxuICAgICgqIHVzZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gdG8gYnVpbGQgdHlwZSB3aXRuZXNzZXMsIG9yIGJ5IHNvbWUgaW50ZXJuYWwgcGFydHMgb2ZcbiAgICAgICB0eXBlcmVwLiB5b3Ugc2hvdWxkIGZlZWwgYmFkIGlmIHlvdSBuZWVkIHRvIHVzZSBpdCBpbiBzb21lIHVzZXIgY29kZSAqKVxuICAgIHZhbCBpbnRlcm5hbF91c2Vfb25seSA6ICdhIFJlY29yZF9pbnRlcm5hbC50IC0+ICdhIHRcbiAgZW5kID0gc3RydWN0XG4gICAgaW5jbHVkZSBSZWNvcmRfaW50ZXJuYWxcblxuICAgIGxldCB0eXBlbmFtZV9vZl90IHQgPSB0LnR5cGVuYW1lXG4gICAgbGV0IGxlbmd0aCB0ID0gQXJyYXkubGVuZ3RoIHQuZmllbGRzXG4gICAgbGV0IGZpZWxkIHQgaW5kZXggPSB0LmZpZWxkcy4oaW5kZXgpXG4gICAgbGV0IGhhc19kb3VibGVfYXJyYXlfdGFnIHQgPSB0Lmhhc19kb3VibGVfYXJyYXlfdGFnXG4gICAgbGV0IGNyZWF0ZSB0ID0gdC5jcmVhdGVcbiAgICBsZXQgZm9sZCB0IH5pbml0IH5mID0gQXJyYXkuZm9sZF9sZWZ0IGYgaW5pdCB0LmZpZWxkc1xuICAgIGxldCBpbnRlcm5hbF91c2Vfb25seSB0ID0gdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgTSAoc3RydWN0XG4gICAgICB0eXBlICdhIHJlcCA9ICdhIHRcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIHJlcFxuICAgIGVuZClcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2xpYl9zdGRfaW50ZXJuYWxfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJuYW1lIiwiVHlwZXJlcF9saWJfVHlwZW5hbWUiLCJDYW1saW50ZXJuYWxMYXp5IiwiQXNzZXJ0X2ZhaWx1cmUiLCJDYW1saW50ZXJuYWxNb2QiLCJUeXBlcmVwX2xpYl9WYXJpYW50X2FuZF9yZWNvcmQiLCJCYXNlX0ludDYzIiwidHlwZW5hbWVfb2ZfaW50IiwidHlwZW5hbWVfb2ZfaW50MzIiLCJ0eXBlbmFtZV9vZl9pbnQ2NCIsInR5cGVuYW1lX29mX25hdGl2ZWludCIsInR5cGVuYW1lX29mX2NoYXIiLCJ0eXBlbmFtZV9vZl9mbG9hdCIsInR5cGVuYW1lX29mX3N0cmluZyIsInR5cGVuYW1lX29mX2J5dGVzIiwidHlwZW5hbWVfb2ZfYm9vbCIsInR5cGVuYW1lX29mX3VuaXQiLCJNX29wdGlvbiIsInR5cGVuYW1lX29mX29wdGlvbiIsIk1fbGlzdCIsInR5cGVuYW1lX29mX2xpc3QiLCJNX2FycmF5IiwidHlwZW5hbWVfb2ZfYXJyYXkiLCJNX2xhenlfdCIsInR5cGVuYW1lX29mX2xhenlfdCIsIk1fcmVmIiwidHlwZW5hbWVfb2ZfcmVmIiwiTV9mdW5jdGlvbiIsInR5cGVuYW1lX29mX2Z1bmN0aW9uIiwiTV90dXBsZTAiLCJ0eXBlbmFtZV9vZl90dXBsZTAiLCJNX3R1cGxlMiIsInR5cGVuYW1lX29mX3R1cGxlMiIsIk1fdHVwbGUzIiwidHlwZW5hbWVfb2ZfdHVwbGUzIiwiTV90dXBsZTQiLCJ0eXBlbmFtZV9vZl90dXBsZTQiLCJNX3R1cGxlNSIsInR5cGVuYW1lX29mX3R1cGxlNSIsIlR5cGVyZXAiLCJhcml0eSIsInBhcmFtIiwidHlwZW5hbWVfb2ZfdCIsInJlcCIsIk5hbWVkIiwibWF0Y2giLCJiIiwiYSIsImMiLCJkIiwiZSIsIlR1cGxlIiwiaW5jbHVkZSIsIlRhZ19pbnRlcm5hbCIsIlRhZyIsIlZhcmlhbnRfaW50ZXJuYWwiLCJWYXJpYW50IiwiRmllbGRfaW50ZXJuYWwiLCJGaWVsZCIsIlJlY29yZF9pbnRlcm5hbCIsIlJlY29yZCIsInJuZyIsImRvbSIsInNhbWVfd2l0bmVzcyIsInQxIiwidDIiLCJyMSIsInIyIiwieCIsInJuZzEiLCJkb20xIiwicm5nMiIsImRvbTIiLCJiMiIsImIxIiwiYzIiLCJjMSIsImQyIiwiZDEiLCJlMiIsImUxIiwibmFtZTEiLCJuYW1lMiIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwicHJvb2YiLCJoZWFkIiwidCIsInR5cGVyZXBfb2ZfaW50IiwidHlwZXJlcF9vZl9pbnQ2NCIsInR5cGVyZXBfb2Zfb3B0aW9uIiwidHlwZXJlcF9vZl9saXN0IiwidHlwZXJlcF9vZl9hcnJheSIsInR5cGVyZXBfb2ZfbGF6eV90IiwidHlwZXJlcF9vZl9yZWYiLCJ0eXBlcmVwX29mX2Z1bmN0aW9uIiwidHlwZXJlcF9vZl90dXBsZTIiLCJ0eXBlcmVwX29mX3R1cGxlMyIsInR5cGVyZXBfb2ZfdHVwbGU0IiwidHlwZXJlcF9vZl90dXBsZTUiLCJ0eXBlcmVwX29mX2ludDMyIiwidHlwZXJlcF9vZl9uYXRpdmVpbnQiLCJ0eXBlcmVwX29mX2NoYXIiLCJ0eXBlcmVwX29mX2Zsb2F0IiwidHlwZXJlcF9vZl9zdHJpbmciLCJ0eXBlcmVwX29mX2J5dGVzIiwidHlwZXJlcF9vZl9ib29sIiwidHlwZXJlcF9vZl91bml0IiwidHlwZXJlcF9vZl90dXBsZTAiLCJ2YWx1ZV90dXBsZTAiLCJ0eXBlbmFtZV9vZl9pbnQ2MyIsInR5cGVyZXBfb2ZfaW50NjMiLCJUeXBlcmVwX2xpYl9TdGRfaW50ZXJuYWwiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvdHlwZXJlcC9zdGRfaW50ZXJuYWwubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFBLFVBQUE7QUFBQSxJQUFBQSxVQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFBLFVBQUE7QUFBQSxJQUFBQSxVQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFBLFVBQUE7QUFBQSxJQUFBQSxVQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLG9C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QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQWhFO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUEsSUFBQWlFLG9CQU1zRDtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQzMEI1RCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIE5hbWVfb2YgPSBzdHJ1Y3RcbiAgbGV0IHR5cGVuYW1lX29mX2ludCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50XG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImludFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfaW50MzIgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGludDMyXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImludDMyXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9pbnQ2NCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50NjRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50NjRcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX25hdGl2ZWludCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gbmF0aXZlaW50XG5cbiAgICAgICAgbGV0IG5hbWUgPSBcIm5hdGl2ZWludFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfY2hhciA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gY2hhclxuXG4gICAgICAgIGxldCBuYW1lID0gXCJjaGFyXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9mbG9hdCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gZmxvYXRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiZmxvYXRcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3N0cmluZyA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcInN0cmluZ1wiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfYnl0ZXMgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGJ5dGVzXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9ib29sID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBib29sXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImJvb2xcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3VuaXQgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IHVuaXRcblxuICAgICAgICBsZXQgbmFtZSA9IFwidW5pdFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBtb2R1bGUgTV9vcHRpb24gPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICAgICAgbGV0IG5hbWUgPSBcIm9wdGlvblwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9vcHRpb24gPSBNX29wdGlvbi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fbGlzdCA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgbGV0IG5hbWUgPSBcImxpc3RcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfbGlzdCA9IE1fbGlzdC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fYXJyYXkgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBhcnJheVxuXG4gICAgICBsZXQgbmFtZSA9IFwiYXJyYXlcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfYXJyYXkgPSBNX2FycmF5LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9sYXp5X3QgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuICAgICAgbGV0IG5hbWUgPSBcImxhenlfdFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9sYXp5X3QgPSBNX2xhenlfdC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fcmVmID0gVHlwZW5hbWUuTWFrZTEgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgcmVmXG5cbiAgICAgIGxldCBuYW1lID0gXCJyZWZcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfcmVmID0gTV9yZWYudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX2Z1bmN0aW9uID0gVHlwZW5hbWUuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgLT4gJ2JcblxuICAgICAgbGV0IG5hbWUgPSBcImZ1bmN0aW9uXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX2Z1bmN0aW9uID0gTV9mdW5jdGlvbi50eXBlbmFtZV9vZl90XG5cbiAgdHlwZSB0dXBsZTAgPSB1bml0XG5cbiAgbW9kdWxlIE1fdHVwbGUwID0gVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gdHVwbGUwXG5cbiAgICAgIGxldCBuYW1lID0gXCJ0dXBsZTBcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGUwID0gTV90dXBsZTAudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlMiA9IFR5cGVuYW1lLk1ha2UyIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhICogJ2JcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlMlwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTIgPSBNX3R1cGxlMi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGUzID0gVHlwZW5hbWUuTWFrZTMgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdhICogJ2IgKiAnY1xuXG4gICAgICBsZXQgbmFtZSA9IFwidHVwbGUzXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlMyA9IE1fdHVwbGUzLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV90dXBsZTQgPSBUeXBlbmFtZS5NYWtlNCAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA9ICdhICogJ2IgKiAnYyAqICdkXG5cbiAgICAgIGxldCBuYW1lID0gXCJ0dXBsZTRcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGU0ID0gTV90dXBsZTQudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlNSA9IFR5cGVuYW1lLk1ha2U1IChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA9ICdhICogJ2IgKiAnYyAqICdkICogJ2VcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlNVwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTUgPSBNX3R1cGxlNS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIHJlYyBUeXBlcmVwIDogc2lnXG4gIHR5cGUgXyB0ID1cbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgTmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgICB8IENoYXIgOiBjaGFyIHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgU3RyaW5nIDogc3RyaW5nIHRcbiAgICB8IEJ5dGVzIDogYnl0ZXMgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgVW5pdCA6IHVuaXQgdFxuICAgIHwgT3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICAgIHwgTGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gICAgfCBBcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICAgIHwgTGF6eSA6ICdhIHQgLT4gJ2EgbGF6eV90IHRcbiAgICB8IFJlZiA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgICB8IEZ1bmN0aW9uIDogKCdkb20gdCAqICdybmcgdCkgLT4gKCdkb20gLT4gJ3JuZykgdFxuICAgIHwgVHVwbGUgOiAnYSBUeXBlcmVwLlR1cGxlLnQgLT4gJ2EgdFxuICAgIHwgUmVjb3JkIDogJ2EgVHlwZXJlcC5SZWNvcmQudCAtPiAnYSB0XG4gICAgfCBWYXJpYW50IDogJ2EgVHlwZXJlcC5WYXJpYW50LnQgLT4gJ2EgdFxuICAgIHwgTmFtZWQgOiAoJ2EgVHlwZXJlcC5OYW1lZC50ICogJ2EgdCBsYXp5X3Qgb3B0aW9uKSAtPiAnYSB0XG5cbiAgdHlwZSBwYWNrZWQgPSBUIDogJ2EgdCAtPiBwYWNrZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBUMCA9IHNpZ1xuICAgICAgdHlwZSBuYW1lZFxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6IG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMSA9IHNpZ1xuICAgICAgdHlwZSAnYSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2EgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIGEgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDIgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdiIFR5cGVuYW1lLnQgLT4gKCdhLCAnYikgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMyA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNCA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDUgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZVxuXG4gICAgICB2YWwgZSA6IGUgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkLCBlKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICAoKiB0aGVyZSB0aGUgbW9kdWxlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIGEgdHlwZSBbdF0gd2l0aFxuICAgICAgIHBhcmFtZXRlcnMgd2hvc2Uga2luZCBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHR5cGUgdmFyaWFibGU6IFsnYSAndF0sIGV2ZW4gd2l0aFxuICAgICAgIGEgZ2FkdC4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBUMCBvZiAobW9kdWxlIFQwIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQxIG9mIChtb2R1bGUgVDEgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDIgb2YgKG1vZHVsZSBUMiB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMyBvZiAobW9kdWxlIFQzIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ0IG9mIChtb2R1bGUgVDQgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDUgb2YgKG1vZHVsZSBUNSB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgdmFsIGFyaXR5IDogXyB0IC0+IGludFxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG4gICAgdmFsIG5hbWUgOiBfIHQgLT4gc3RyaW5nXG4gIGVuZFxuXG4gIG1vZHVsZSBUdXBsZSA6IHNpZ1xuICAgICgqIHRoZXNlIGNvbnN0cnVjdG9ycyBjb3VsZCBiZSBwbHVuZ2VkIGF0IHRvcGxldmVsIG9mIFR5cGVyZXAudCwgaG93ZXZlciBpdCBpcyBsZXNzXG4gICAgICAgdmVyYm9zZSB0aGF0IHdheSAqKVxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgVDIgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYikgdFxuICAgICAgfCBUMyA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQpIC0+ICgnYSAqICdiICogJ2MpIHRcbiAgICAgIHwgVDQgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkKSB0XG4gICAgICB8IFQ1IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50ICogJ2UgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG5cbiAgICB2YWwgYXJpdHkgOiBfIHQgLT4gaW50XG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgZW5kXG5cbiAgaW5jbHVkZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TIHdpdGggdHlwZSAnYSB0IDo9ICdhIFR5cGVyZXAudFxuXG4gIHZhbCBzYW1lIDogXyB0IC0+IF8gdCAtPiBib29sXG4gIHZhbCBzYW1lX3dpdG5lc3MgOiAnYSB0IC0+ICdiIHQgLT4gKCdhLCAnYikgVHlwZV9lcXVhbC50IG9wdGlvblxuICB2YWwgc2FtZV93aXRuZXNzX2V4biA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnRcbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgdmFsIGhlYWQgOiAnYSB0IC0+ICdhIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIF8gdCA9XG4gICAgfCBJbnQgOiBpbnQgdFxuICAgIHwgSW50MzIgOiBpbnQzMiB0XG4gICAgfCBJbnQ2NCA6IGludDY0IHRcbiAgICB8IE5hdGl2ZWludCA6IG5hdGl2ZWludCB0XG4gICAgfCBDaGFyIDogY2hhciB0XG4gICAgfCBGbG9hdCA6IGZsb2F0IHRcbiAgICB8IFN0cmluZyA6IHN0cmluZyB0XG4gICAgfCBCeXRlcyA6IGJ5dGVzIHRcbiAgICB8IEJvb2wgOiBib29sIHRcbiAgICB8IFVuaXQgOiB1bml0IHRcbiAgICB8IE9wdGlvbiA6ICdhIHQgLT4gJ2Egb3B0aW9uIHRcbiAgICB8IExpc3QgOiAnYSB0IC0+ICdhIGxpc3QgdFxuICAgIHwgQXJyYXkgOiAnYSB0IC0+ICdhIGFycmF5IHRcbiAgICB8IExhenkgOiAnYSB0IC0+ICdhIGxhenlfdCB0XG4gICAgfCBSZWYgOiAnYSB0IC0+ICdhIHJlZiB0XG4gICAgfCBGdW5jdGlvbiA6ICgnZG9tIHQgKiAncm5nIHQpIC0+ICgnZG9tIC0+ICdybmcpIHRcbiAgICB8IFR1cGxlIDogJ2EgVHlwZXJlcC5UdXBsZS50IC0+ICdhIHRcbiAgICB8IFJlY29yZCA6ICdhIFR5cGVyZXAuUmVjb3JkLnQgLT4gJ2EgdFxuICAgIHwgVmFyaWFudCA6ICdhIFR5cGVyZXAuVmFyaWFudC50IC0+ICdhIHRcbiAgICB8IE5hbWVkIDogKCdhIFR5cGVyZXAuTmFtZWQudCAqICdhIHQgbGF6eV90IG9wdGlvbikgLT4gJ2EgdFxuXG4gIHR5cGUgcGFja2VkID0gVCA6ICdhIHQgLT4gcGFja2VkXG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgbW9kdWxlIHR5cGUgVDAgPSBzaWdcbiAgICAgIHR5cGUgbmFtZWRcbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDEgPSBzaWdcbiAgICAgIHR5cGUgJ2EgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdhIG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBhIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQyID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogJ2EgVHlwZW5hbWUudCAtPiAnYiBUeXBlbmFtZS50IC0+ICgnYSwgJ2IpIG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYikgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDMgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYykgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDQgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBkXG5cbiAgICAgIHZhbCBkIDogZCBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZCBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMsIGQpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQ1ID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGVcblxuICAgICAgdmFsIGUgOiBlIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2UgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCwgZSkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgKCogdGhlcmUgdGhlIG1vZHVsZSBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBhIHR5cGUgW3RdIHdpdGhcbiAgICAgICBwYXJhbWV0ZXJzIHdob3NlIGtpbmQgaXMgbm90IHJlcHJlc2VudGFibGUgYXMgYSB0eXBlIHZhcmlhYmxlOiBbJ2EgJ3RdLCBldmVuIHdpdGhcbiAgICAgICBhIGdhZHQuICopXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHwgVDAgb2YgKG1vZHVsZSBUMCB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMSBvZiAobW9kdWxlIFQxIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQyIG9mIChtb2R1bGUgVDIgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDMgb2YgKG1vZHVsZSBUMyB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUNCBvZiAobW9kdWxlIFQ0IHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ1IG9mIChtb2R1bGUgVDUgd2l0aCB0eXBlIHQgPSAnYSlcblxuICAgIGxldCBhcml0eSA9IGZ1bmN0aW9uXG4gICAgICB8IFQwIF8gLT4gMFxuICAgICAgfCBUMSBfIC0+IDFcbiAgICAgIHwgVDIgXyAtPiAyXG4gICAgICB8IFQzIF8gLT4gM1xuICAgICAgfCBUNCBfIC0+IDRcbiAgICAgIHwgVDUgXyAtPiA1XG4gICAgOztcblxuICAgIGxldCB0eXBlbmFtZV9vZl90ICh0eXBlIGEpID0gZnVuY3Rpb25cbiAgICAgIHwgVDAgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDAgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDEgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDEgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDIgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDIgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDMgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDQgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDQgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDUgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IG5hbWUgcmVwID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCAodHlwZW5hbWVfb2ZfdCByZXApKVxuICBlbmRcblxuICBtb2R1bGUgVHVwbGUgPSBzdHJ1Y3RcbiAgICAoKiB0aGVzZSBjb25zdHJ1Y3RvcnMgY291bGQgYmUgcGx1bmdlZCBhdCB0b3BsZXZlbCBvZiBUeXBlcmVwLnQsIGhvd2V2ZXIgaXQgaXMgbGVzc1xuICAgICAgIHZlcmJvc2UgdGhpcyB3YXkgKilcbiAgICB0eXBlIF8gdCA9XG4gICAgICB8IFQyIDogKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCkgLT4gKCdhICogJ2IpIHRcbiAgICAgIHwgVDMgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYiAqICdjKSB0XG4gICAgICB8IFQ0IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCkgdFxuICAgICAgfCBUNSA6XG4gICAgICAgICAgKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCAqICdkIFR5cGVyZXAudCAqICdlIFR5cGVyZXAudClcbiAgICAgICAgICAtPiAoJ2EgKiAnYiAqICdjICogJ2QgKiAnZSkgdFxuXG4gICAgbGV0IGFyaXR5IDogdHlwZSBhLiBhIHQgLT4gaW50ID0gZnVuY3Rpb25cbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UMiBfIC0+IDJcbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UMyBfIC0+IDNcbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UNCBfIC0+IDRcbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UNSBfIC0+IDVcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgOiB0eXBlIGEuIGEgdCAtPiBhIFR5cGVuYW1lLnQgPSBmdW5jdGlvblxuICAgICAgfCBUMiAoYSwgYikgLT5cbiAgICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl90dXBsZTIgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKSAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICB8IFQzIChhLCBiLCBjKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlM1xuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgfCBUNCAoYSwgYiwgYywgZCkgLT5cbiAgICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl90dXBsZTRcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGEpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBiKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYylcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGQpXG4gICAgICB8IFQ1IChhLCBiLCBjLCBkLCBlKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlNVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZClcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGUpXG4gICAgOztcbiAgZW5kXG5cbiAgaW5jbHVkZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5NIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgcmVwID0gJ2EgdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgcmVwXG4gICAgZW5kKVxuXG4gIGxldCByZWMgdHlwZW5hbWVfb2ZfdCA6IHR5cGUgYS4gYSB0IC0+IGEgVHlwZW5hbWUudCA9IGZ1bmN0aW9uXG4gICAgfCBJbnQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnRcbiAgICB8IEludDMyIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfaW50MzJcbiAgICB8IEludDY0IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfaW50NjRcbiAgICB8IE5hdGl2ZWludCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX25hdGl2ZWludFxuICAgIHwgQ2hhciAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2NoYXJcbiAgICB8IEZsb2F0IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfZmxvYXRcbiAgICB8IFN0cmluZyAtPiBOYW1lX29mLnR5cGVuYW1lX29mX3N0cmluZ1xuICAgIHwgQnl0ZXMgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9ieXRlc1xuICAgIHwgQm9vbCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2Jvb2xcbiAgICB8IFVuaXQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl91bml0XG4gICAgfCBPcHRpb24gcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2Zfb3B0aW9uICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IExpc3QgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbGlzdCAodHlwZW5hbWVfb2ZfdCByZXApXG4gICAgfCBBcnJheSByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9hcnJheSAodHlwZW5hbWVfb2ZfdCByZXApXG4gICAgfCBMYXp5IHJlcCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2xhenlfdCAodHlwZW5hbWVfb2ZfdCByZXApXG4gICAgfCBSZWYgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfcmVmICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IEZ1bmN0aW9uIChkb20sIHJuZykgLT5cbiAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfZnVuY3Rpb24gKHR5cGVuYW1lX29mX3QgZG9tKSAodHlwZW5hbWVfb2ZfdCBybmcpXG4gICAgfCBUdXBsZSByZXAgLT4gVHlwZXJlcC5UdXBsZS50eXBlbmFtZV9vZl90IHJlcFxuICAgIHwgUmVjb3JkIHJlcCAtPiBUeXBlcmVwLlJlY29yZC50eXBlbmFtZV9vZl90IHJlcFxuICAgIHwgVmFyaWFudCByZXAgLT4gVHlwZXJlcC5WYXJpYW50LnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBOYW1lZCAobmFtZSwgXykgLT4gTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lXG4gIDs7XG5cbiAgbGV0IHJlYyBzYW1lX3dpdG5lc3MgOiB0eXBlIGEgYi4gYSB0IC0+IGIgdCAtPiAoYSwgYikgVHlwZV9lcXVhbC50IG9wdGlvbiA9XG4gICAgZnVuIHQxIHQyIC0+XG4gICAgICBsZXQgbW9kdWxlIEUgPSBUeXBlX2VxdWFsIGluXG4gICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgfCBOYW1lZCAobmFtZTEsIHIxKSwgTmFtZWQgKG5hbWUyLCByMikgLT5cbiAgICAgICAgKG1hdGNoXG4gICAgICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzcyAoTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lMSkgKE5hbWVkLnR5cGVuYW1lX29mX3QgbmFtZTIpXG4gICAgICAgICB3aXRoXG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geFxuICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgIChtYXRjaCByMSwgcjIgd2l0aFxuICAgICAgICAgICAgfCBTb21lIChsYXp5IHQxKSwgU29tZSAobGF6eSB0MikgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICAgICB8IFNvbWUgKGxhenkgdDEpLCBOb25lIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgICAgICAgfCBOb25lLCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lKSlcbiAgICAgIHwgTmFtZWQgKF8sIHIxKSwgdDIgLT5cbiAgICAgICAgKG1hdGNoIHIxIHdpdGhcbiAgICAgICAgIHwgU29tZSAobGF6eSB0MSkgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgdDEsIE5hbWVkIChfLCByMikgLT5cbiAgICAgICAgKG1hdGNoIHIyIHdpdGhcbiAgICAgICAgIHwgU29tZSAobGF6eSB0MikgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgSW50LCBJbnQgLT4gU29tZSBFLlRcbiAgICAgIHwgSW50MzIsIEludDMyIC0+IFNvbWUgRS5UXG4gICAgICB8IEludDY0LCBJbnQ2NCAtPiBTb21lIEUuVFxuICAgICAgfCBOYXRpdmVpbnQsIE5hdGl2ZWludCAtPiBTb21lIEUuVFxuICAgICAgfCBDaGFyLCBDaGFyIC0+IFNvbWUgRS5UXG4gICAgICB8IEZsb2F0LCBGbG9hdCAtPiBTb21lIEUuVFxuICAgICAgfCBTdHJpbmcsIFN0cmluZyAtPiBTb21lIEUuVFxuICAgICAgfCBCeXRlcywgQnl0ZXMgLT4gU29tZSBFLlRcbiAgICAgIHwgQm9vbCwgQm9vbCAtPiBTb21lIEUuVFxuICAgICAgfCBVbml0LCBVbml0IC0+IFNvbWUgRS5UXG4gICAgICB8IE9wdGlvbiByMSwgT3B0aW9uIHIyIC0+XG4gICAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgcjEgcjIgd2l0aFxuICAgICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgICAgfCBTb21lIEUuVCBhcyB4IC0+IHgpXG4gICAgICB8IExpc3QgcjEsIExpc3QgcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgQXJyYXkgcjEsIEFycmF5IHIyIC0+XG4gICAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgcjEgcjIgd2l0aFxuICAgICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgICAgfCBTb21lIEUuVCBhcyB4IC0+IHgpXG4gICAgICB8IExhenkgcjEsIExhenkgcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgUmVmIHIxLCBSZWYgcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgRnVuY3Rpb24gKGRvbTEsIHJuZzEpLCBGdW5jdGlvbiAoZG9tMiwgcm5nMikgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyBkb20xIGRvbTIsIHNhbWVfd2l0bmVzcyBybmcxIHJuZzIgd2l0aFxuICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQgLT4gU29tZSBFLlRcbiAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgVHVwbGUgdDEsIFR1cGxlIHQyIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9IFR5cGVyZXAuVHVwbGUgaW5cbiAgICAgICAgKG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgICB8IFQuVDIgKGExLCBiMSksIFQuVDIgKGEyLCBiMikgLT5cbiAgICAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgICB8IFQuVDMgKGExLCBiMSwgYzEpLCBULlQzIChhMiwgYjIsIGMyKSAtPlxuICAgICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIsIHNhbWVfd2l0bmVzcyBjMSBjMiB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQgLT4gU29tZSBFLlRcbiAgICAgICAgICAgIHwgTm9uZSwgXywgXyB8IF8sIE5vbmUsIF8gfCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgICB8IFQuVDQgKGExLCBiMSwgYzEsIGQxKSwgVC5UNCAoYTIsIGIyLCBjMiwgZDIpIC0+XG4gICAgICAgICAgIChtYXRjaFxuICAgICAgICAgICAgICBzYW1lX3dpdG5lc3MgYTEgYTIsIHNhbWVfd2l0bmVzcyBiMSBiMiwgc2FtZV93aXRuZXNzIGMxIGMyLCBzYW1lX3dpdG5lc3MgZDEgZDJcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQgLT4gU29tZSBFLlRcbiAgICAgICAgICAgIHwgTm9uZSwgXywgXywgXyB8IF8sIE5vbmUsIF8sIF8gfCBfLCBfLCBOb25lLCBfIHwgXywgXywgXywgTm9uZSAtPiBOb25lKVxuICAgICAgICAgfCBULlQ1IChhMSwgYjEsIGMxLCBkMSwgZTEpLCBULlQ1IChhMiwgYjIsIGMyLCBkMiwgZTIpIC0+XG4gICAgICAgICAgIChtYXRjaFxuICAgICAgICAgICAgICAoIHNhbWVfd2l0bmVzcyBhMSBhMlxuICAgICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBiMSBiMlxuICAgICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBjMSBjMlxuICAgICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBkMSBkMlxuICAgICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBlMSBlMiApXG4gICAgICAgICAgICB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgICAgfCBOb25lLCBfLCBfLCBfLCBfXG4gICAgICAgICAgICB8IF8sIE5vbmUsIF8sIF8sIF9cbiAgICAgICAgICAgIHwgXywgXywgTm9uZSwgXywgX1xuICAgICAgICAgICAgfCBfLCBfLCBfLCBOb25lLCBfXG4gICAgICAgICAgICB8IF8sIF8sIF8sIF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgIHwgVC5UMiBfLCBfIC0+IE5vbmVcbiAgICAgICAgIHwgVC5UMyBfLCBfIC0+IE5vbmVcbiAgICAgICAgIHwgVC5UNCBfLCBfIC0+IE5vbmVcbiAgICAgICAgIHwgVC5UNSBfLCBfIC0+IE5vbmUpXG4gICAgICB8IFJlY29yZCByMSwgUmVjb3JkIHIyIC0+XG4gICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc1xuICAgICAgICAgIChUeXBlcmVwLlJlY29yZC50eXBlbmFtZV9vZl90IHIxKVxuICAgICAgICAgIChUeXBlcmVwLlJlY29yZC50eXBlbmFtZV9vZl90IHIyKVxuICAgICAgfCBWYXJpYW50IHIxLCBWYXJpYW50IHIyIC0+XG4gICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc1xuICAgICAgICAgIChUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByMSlcbiAgICAgICAgICAoVHlwZXJlcC5WYXJpYW50LnR5cGVuYW1lX29mX3QgcjIpXG4gICAgICB8IEludCwgXyAtPiBOb25lXG4gICAgICB8IEludDMyLCBfIC0+IE5vbmVcbiAgICAgIHwgSW50NjQsIF8gLT4gTm9uZVxuICAgICAgfCBOYXRpdmVpbnQsIF8gLT4gTm9uZVxuICAgICAgfCBDaGFyLCBfIC0+IE5vbmVcbiAgICAgIHwgRmxvYXQsIF8gLT4gTm9uZVxuICAgICAgfCBTdHJpbmcsIF8gLT4gTm9uZVxuICAgICAgfCBCeXRlcywgXyAtPiBOb25lXG4gICAgICB8IEJvb2wsIF8gLT4gTm9uZVxuICAgICAgfCBVbml0LCBfIC0+IE5vbmVcbiAgICAgIHwgT3B0aW9uIF8sIF8gLT4gTm9uZVxuICAgICAgfCBMaXN0IF8sIF8gLT4gTm9uZVxuICAgICAgfCBBcnJheSBfLCBfIC0+IE5vbmVcbiAgICAgIHwgTGF6eSBfLCBfIC0+IE5vbmVcbiAgICAgIHwgUmVmIF8sIF8gLT4gTm9uZVxuICAgICAgfCBGdW5jdGlvbiBfLCBfIC0+IE5vbmVcbiAgICAgIHwgVHVwbGUgXywgXyAtPiBOb25lXG4gICAgICB8IFJlY29yZCBfLCBfIC0+IE5vbmVcbiAgICAgIHwgVmFyaWFudCBfLCBfIC0+IE5vbmVcbiAgOztcblxuICBsZXQgc2FtZSBhIGIgPSBzYW1lX3dpdG5lc3MgYSBiIDw+IE5vbmVcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biBhIGIgPVxuICAgIG1hdGNoIHNhbWVfd2l0bmVzcyBhIGIgd2l0aFxuICAgIHwgU29tZSBwcm9vZiAtPiBwcm9vZlxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgcmVjIGhlYWQgPSBmdW5jdGlvblxuICAgIHwgVHlwZXJlcC5OYW1lZCAoXywgU29tZSAobGF6eSB0KSkgLT4gaGVhZCB0XG4gICAgfCB0IC0+IHRcbiAgOztcbmVuZFxuXG5sZXQgdHlwZXJlcF9vZl9pbnQgPSBUeXBlcmVwLkludFxubGV0IHR5cGVyZXBfb2ZfaW50MzIgPSBUeXBlcmVwLkludDMyXG5sZXQgdHlwZXJlcF9vZl9pbnQ2NCA9IFR5cGVyZXAuSW50NjRcbmxldCB0eXBlcmVwX29mX25hdGl2ZWludCA9IFR5cGVyZXAuTmF0aXZlaW50XG5sZXQgdHlwZXJlcF9vZl9jaGFyID0gVHlwZXJlcC5DaGFyXG5sZXQgdHlwZXJlcF9vZl9mbG9hdCA9IFR5cGVyZXAuRmxvYXRcbmxldCB0eXBlcmVwX29mX3N0cmluZyA9IFR5cGVyZXAuU3RyaW5nXG5sZXQgdHlwZXJlcF9vZl9ieXRlcyA9IFR5cGVyZXAuQnl0ZXNcbmxldCB0eXBlcmVwX29mX2Jvb2wgPSBUeXBlcmVwLkJvb2xcbmxldCB0eXBlcmVwX29mX3VuaXQgPSBUeXBlcmVwLlVuaXRcbmxldCB0eXBlcmVwX29mX29wdGlvbiByZXAgPSBUeXBlcmVwLk9wdGlvbiByZXBcbmxldCB0eXBlcmVwX29mX2xpc3QgcmVwID0gVHlwZXJlcC5MaXN0IHJlcFxubGV0IHR5cGVyZXBfb2ZfYXJyYXkgcmVwID0gVHlwZXJlcC5BcnJheSByZXBcbmxldCB0eXBlcmVwX29mX2xhenlfdCByZXAgPSBUeXBlcmVwLkxhenkgcmVwXG5sZXQgdHlwZXJlcF9vZl9yZWYgcmVwID0gVHlwZXJlcC5SZWYgcmVwXG5sZXQgdHlwZXJlcF9vZl9mdW5jdGlvbiBkb20gcm5nID0gVHlwZXJlcC5GdW5jdGlvbiAoZG9tLCBybmcpXG5sZXQgdHlwZXJlcF9vZl90dXBsZTAgPSBUeXBlcmVwLlVuaXRcbmxldCB0eXBlcmVwX29mX3R1cGxlMiBhIGIgPSBUeXBlcmVwLlR1cGxlIChUeXBlcmVwLlR1cGxlLlQyIChhLCBiKSlcbmxldCB0eXBlcmVwX29mX3R1cGxlMyBhIGIgYyA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDMgKGEsIGIsIGMpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGU0IGEgYiBjIGQgPSBUeXBlcmVwLlR1cGxlIChUeXBlcmVwLlR1cGxlLlQ0IChhLCBiLCBjLCBkKSlcbmxldCB0eXBlcmVwX29mX3R1cGxlNSBhIGIgYyBkIGUgPSBUeXBlcmVwLlR1cGxlIChUeXBlcmVwLlR1cGxlLlQ1IChhLCBiLCBjLCBkLCBlKSlcblxuaW5jbHVkZSBOYW1lX29mXG5cbmxldCB2YWx1ZV90dXBsZTAgPSAoKVxuXG5sZXQgdHlwZXJlcF9vZl9pbnQ2MywgdHlwZW5hbWVfb2ZfaW50NjMgPVxuICBsZXQgdHlwZXJlcF9hbmRfdHlwZW5hbWVfb2ZfaW50NjNfcmVwclxuICAgIDogdHlwZSBhIGIuIChhLCBiKSBCYXNlLkludDYzLlByaXZhdGUuUmVwci50IC0+IGEgVHlwZXJlcC50ICogYSBUeXBlbmFtZS50XG4gICAgPSBmdW5jdGlvblxuICAgICAgfCBCYXNlLkludDYzLlByaXZhdGUuUmVwci5JbnQgLT4gdHlwZXJlcF9vZl9pbnQsIHR5cGVuYW1lX29mX2ludFxuICAgICAgfCBCYXNlLkludDYzLlByaXZhdGUuUmVwci5JbnQ2NCAtPiB0eXBlcmVwX29mX2ludDY0LCB0eXBlbmFtZV9vZl9pbnQ2NFxuICBpblxuICB0eXBlcmVwX2FuZF90eXBlbmFtZV9vZl9pbnQ2M19yZXByIEJhc2UuSW50NjMuUHJpdmF0ZS5yZXByXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExOTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXJlcF9saWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIlR5cGVyZXBfbGliX1R5cGVyZXBhYmxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQywwQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyMDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXJlcF9saWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9saWJfdHlwZXJlcF9vYmpfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9PYmoiLCJBc3NlcnRfZmFpbHVyZSIsInJlcHJfb2ZfcG9seV92YXJpYW50IiwidmFyaWFudCIsInNpemUiLCJyZXByIiwiaGFzaF92YXJpYW50IiwicyIsImFjY3UiLCJpIiwiY3N0X3plcm8iLCJkb3VibGVfYXJyYXlfdmFsdWUiLCJwYXJhbSIsImhhc19kb3VibGVfYXJyYXlfdGFnIiwiYSIsImRvdWJsZSIsInNpbXBsZSIsIlR5cGVyZXBfbGliX1R5cGVyZXBfb2JqIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3R5cGVyZXAvdHlwZXJlcF9vYmoubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMscUJBQUFDO0FBQUFBLElDSUUsZ0NBQ0s7QUFBQSxRQUFBQyxPQUNBO0FBQUEsSUFFSDtBQUFBO0FBQUEsUUFBQUMsT0FDVztBQUFBLElBQ1gsNkJBQ0E7QUFBQSxJQURBO0FBQUEsR0FDYTtBQUFBLFlBQUFDLGFBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLE9BSWY7QUFBQSxXQUNBO0FBQUE7QUFBQTtBQUFBLFNBQUFDLElBQUE7QUFBQTtBQUFBLGdCQUNvQztBQUFBLE1BQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFHekM7QUFBQSxJQUVBLGdFQUF3RDtBQUFBO0FBQUE7QUFBQSxVQUtIO0FBQUEsVUFBdEM7QUFBQSxJQUFBQyxXQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFtQztBQUFBLGFBQ047QUFBQSxHQUE3QjtBQUFBLElBQTBCO0FBQUEsWUFBQUMsbUJBQUFDLE9BQ0EsVUFBa0M7QUFBQSxZQUFBQyxxQkFBQUM7QUFBQUEsUUFBQSxNQUN6QjtBQUFBLElBQW9CO0FBQUE7QUFBQSxPQUFBQyxXQWM1QixlQUFBQyxTQUNBO0FBQUEsR0FHbkM7QUFBQSxJQUErQjtBQUFBLEdBQzFCO0FBQUEsSUFBK0I7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEakQ3QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogdXNpbmcgdGhlIGhhc2hfdmFyaWFudCBvZiBwYV90eXBlX2NvbnYgYXQgY29tcGlsZSB0aW1lICopXG5sZXQgcmVwcl9vZl9wb2x5X3ZhcmlhbnQgOiBbPiBdIC0+IGludCA9XG4gIGZ1biB2YXJpYW50IC0+XG4gIGxldCBvYmogPSBPYmoucmVwciB2YXJpYW50IGluXG4gIGlmIE9iai5pc19pbnQgb2JqXG4gIHRoZW4gT2JqLm9iaiBvYmpcbiAgZWxzZSAoXG4gICAgbGV0IHNpemUgPSBPYmouc2l6ZSBvYmogaW5cbiAgICBhc3NlcnQgKHNpemUgPSAyKTtcbiAgICBsZXQgcmVwciA9IE9iai5maWVsZCBvYmogMCBpblxuICAgIGFzc2VydCAoT2JqLmlzX2ludCByZXByKTtcbiAgICBPYmoub2JqIHJlcHIpXG47O1xuXG5sZXQgaGFzaF92YXJpYW50IHMgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAoMjIzICogIWFjY3UpICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoKDEgbHNsIDMxKSAtIDEpO1xuICAoKiBtYWtlIGl0IHNpZ25lZCBmb3IgNjQgYml0cyBhcmNoaXRlY3R1cmVzICopXG4gIGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1XG47O1xuXG4oKiBhIGZldyB1bml0IHRlc3RzIG9mIGNhc2VzIHRoYXQgaGF2ZSB0cmlnZ2VyZWQgZGlmZnMgaW4gdGhlIHBhc3Qgb2YgdGhpc1xuICAgbGliICopXG5sZXQgKCkgPSBhc3NlcnQgKHJlcHJfb2ZfcG9seV92YXJpYW50IGBMYXRlbmN5X3N0YXRzID0gaGFzaF92YXJpYW50IFwiTGF0ZW5jeV9zdGF0c1wiKVxubGV0ICgpID0gYXNzZXJ0IChyZXByX29mX3BvbHlfdmFyaWFudCBgemVybyA9IGhhc2hfdmFyaWFudCBcInplcm9cIilcbmxldFtAaW5saW5lIG5ldmVyXSBkb3VibGVfYXJyYXlfdmFsdWUgKCkgPSBTeXMub3BhcXVlX2lkZW50aXR5IChPYmoubWFnaWMgMC4pXG5sZXQgaGFzX2RvdWJsZV9hcnJheV90YWcgYSA9IE9iai5kb3VibGVfYXJyYXlfdGFnID0gT2JqLnRhZyAoT2JqLnJlcHIgYSlcblxubGV0ICgpID1cbiAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgdHlwZSBkb3VibGUgPVxuICAgICAgeyBhIDogZmxvYXRcbiAgICAgIDsgYiA6IGZsb2F0XG4gICAgICB9XG5cbiAgICB0eXBlIHNpbXBsZSA9XG4gICAgICB7IGMgOiBmbG9hdFxuICAgICAgOyBkIDogaW50XG4gICAgICB9XG5cbiAgICBsZXQgZG91YmxlID0geyBhID0gZG91YmxlX2FycmF5X3ZhbHVlICgpOyBiID0gZG91YmxlX2FycmF5X3ZhbHVlICgpIH1cbiAgICBsZXQgc2ltcGxlID0geyBjID0gZG91YmxlX2FycmF5X3ZhbHVlICgpOyBkID0gZG91YmxlX2FycmF5X3ZhbHVlICgpIH1cbiAgZW5kXG4gIGluXG4gIGFzc2VydCAoaGFzX2RvdWJsZV9hcnJheV90YWcgTS5kb3VibGUpO1xuICBhc3NlcnQgKG5vdCAoaGFzX2RvdWJsZV9hcnJheV90YWcgTS5zaW1wbGUpKVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJNIiwiWCIsIlR5cGVyZXBfbGliX1R5cGVfZ2VuZXJpY19pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3R5cGVyZXAvdHlwZV9nZW5lcmljX2ludGYubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsRUFBQUMsR0FBQSxXQ3lERztBQUFBLE9BQUFDLGdDRHpESCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIE0gKFggOiBzaWdcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBjb21wdXRlIDogdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2EgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICgnYSwgJ2IpIHQgWC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wdXRlIDogJ2EgWC50IC0+ICdiIFgudCAtPiAnYyBYLnQgLT4gKCdhLCAnYiwgJ2MpIHQgWC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFM0ID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzQgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA6PSAoJ2EsICdiLCAnYywgJ2QpIHRcblxuICAgIHZhbCBjb21wdXRlIDogJ2EgWC50IC0+ICdiIFgudCAtPiAnYyBYLnQgLT4gJ2QgWC50IC0+ICgnYSwgJ2IsICdjLCAnZCkgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzUgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzUgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogICdhIFgudFxuICAgICAgLT4gJ2IgWC50XG4gICAgICAtPiAnYyBYLnRcbiAgICAgIC0+ICdkIFgudFxuICAgICAgLT4gJ2UgWC50XG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IFgudFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgTSAoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgY29tcHV0YXRpb25cbiAgICBlbmQpXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjk1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfbGliX3R5cGVfZ2VuZXJpY19tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIlR5cGVyZXBfbGliX1N0ZF9pbnRlcm5hbCIsIkNhbWxpbnRlcm5hbExhenkiLCJUeXBlcmVwX2xpYl9UeXBlbmFtZSIsIlR5cGVyZXBfbGliX1R5cGVfZXF1YWwiLCJTdGRsaWJfTGF6eSIsIkJhc2UiLCJTdGRsaWIiLCJUeXBlcmVwX2xpYl9UeXBlX2dlbmVyaWNfaW50ZiIsIlN0ZGxpYl9IYXNodGJsIiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYl9MaXN0IiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfQXJyYXkiLCJUeXBlcmVwX2xpYl9WYXJpYW50X2FuZF9yZWNvcmQiLCJIZWxwZXIiLCJBIiwiQiIsIm1hcF92YXJpYW50IiwicGFyYW0iLCJ2YXJpYW50IiwibWFwIiwidHlwZW5hbWUiLCJwb2x5bW9ycGhpYyIsInRhZ3MiLCJpbmRleCIsInRhZyIsImxhYmVsIiwicmVwIiwiYXJpdHkiLCJhcmdzX2xhYmVscyIsIm9jYW1sX3JlcHIiLCJ0eWlkIiwiZmN0IiwiY3JlYXRlIiwiayIsInZhbHVlIiwiYSIsIm1hdGNoIiwiYXRhZyIsImJ0YWciLCJtYXBfcmVjb3JkIiwicmVjb3JkIiwiaGFzX2RvdWJsZV9hcnJheV90YWciLCJmaWVsZHMiLCJmaWVsZCIsImlzX211dGFibGUiLCJnZXQiLCJhZmllbGQiLCJiZmllbGQiLCJCcm9rZW5fZGVwZW5kZW5jeSIsImNzdF9UeXBlcmVwX2xpYl9UeXBlX2dlbmVyaWNfTSIsImR1bW15IiwiVHlwZXJlcF9saWJfVHlwZV9nZW5lcmljIiwiQ29udGV4dCIsIlVuZGVmaW5lZCIsImluaXQiLCJuYW1lIiwicGF0aCIsInIiLCJpbnB1dCIsImdldF93aXBfY29tcHV0YXRpb24iLCJzaGFyZWQiLCJjbG9zIiwic2V0X2ZpbmFsX2NvbXB1dGF0aW9uIiwiY29tcHV0YXRpb24iLCJjb21waWxldGltZV9kZXJlZmVyZW5jZSIsInNoYXJlIiwiWCIsInJlcXVpcmVkIiwiaW5jbHVkZSIsInJlcGxhY2UiLCJtZW0iLCJmaW5kIiwidGFibGUiLCJrZXkiLCJjaGVja19kZXBlbmRlbmNpZXMiLCJ1aWQiLCJpbXBsZW1lbnRzIiwibWVzc2FnZSIsInNpemUiLCJ0YWJsZTAiLCJ0YWJsZTEiLCJ0YWJsZTIiLCJ0YWJsZTMiLCJ0YWJsZTQiLCJ0YWJsZTUiLCJpc19yZWdpc3RlcmVkIiwiaWRlbnQiLCJ1bml0IiwicmVnaXN0ZXIwIiwiY29tcHV0ZSIsInJlZ2lzdGVyMSIsInJlZ2lzdGVyMiIsInJlZ2lzdGVyMyIsInJlZ2lzdGVyNCIsInJlZ2lzdGVyNSIsInJlZ2lzdGVyIiwidHlwZXJlcF9vZl9hIiwidHlwZW5hbWVfb2ZfdCIsIk5vdF9pbXBsZW1lbnRlZCIsIk1lbW8iLCJvZl90eXBlcmVwIiwiY29udGV4dCIsIm1lbW9fdGFibGUiLCJybmciLCJkb20iLCJ0dXBsZSIsImIiLCJyYSIsInJiIiwiYyIsInJjIiwiZCIsInJkIiwiZSIsInJlIiwiY29udGVudCIsIm5hbWVkIiwid2l0bmVzcyIsIkwiLCJjdXN0b20iLCJDb252Iiwic3RyaW5nIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL3R5cGVyZXAvdHlwZV9nZW5lcmljLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7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Q2xCLG9EQUN3QjtBQUFBO0FBQUEsY0FBckI7QUFBQTtBQUFBO0FBQUEsU0FBcUI7QUFBQSxhQUFBQSxjQUVyQjtBQUFBLFNBQ2xCO0FBQUEsUUFBb0I7QUFBQSxRQXRjK0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdEM1h2RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBTdGRfaW50ZXJuYWxcbm1vZHVsZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50ZiA9IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmXG5cbm1vZHVsZSBIZWxwZXIgKEEgOiBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TKSAoQiA6IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMpID0gc3RydWN0XG4gIHR5cGUgbWFwID0geyBtYXAgOiAnYS4gJ2EgQS50IC0+ICdhIEIudCB9XG5cbiAgbGV0IG1hcF92YXJpYW50ICh0eXBlIHZhcmlhbnQpIHsgbWFwIH0gKHZhcmlhbnQgOiB2YXJpYW50IEEuVmFyaWFudC50KSA9XG4gICAgbGV0IG1hcF9jcmVhdGUgPSBmdW5jdGlvblxuICAgICAgfCBBLlRhZy5BcmdzIGZjdCAtPiBCLlRhZ19pbnRlcm5hbC5BcmdzIGZjdFxuICAgICAgfCBBLlRhZy5Db25zdCBrIC0+IEIuVGFnX2ludGVybmFsLkNvbnN0IGtcbiAgICBpblxuICAgIGxldCBtYXBfdGFnIHRhZyA9XG4gICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVGFnIHRhZyAtPlxuICAgICAgICBsZXQgbGFiZWwgPSBBLlRhZy5sYWJlbCB0YWcgaW5cbiAgICAgICAgbGV0IHJlcCA9IG1hcCAoQS5UYWcudHJhdmVyc2UgdGFnKSBpblxuICAgICAgICBsZXQgYXJpdHkgPSBBLlRhZy5hcml0eSB0YWcgaW5cbiAgICAgICAgbGV0IGFyZ3NfbGFiZWxzID0gQS5UYWcuYXJnc19sYWJlbHMgdGFnIGluXG4gICAgICAgIGxldCBpbmRleCA9IEEuVGFnLmluZGV4IHRhZyBpblxuICAgICAgICBsZXQgb2NhbWxfcmVwciA9IEEuVGFnLm9jYW1sX3JlcHIgdGFnIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5UYWcudHlpZCB0YWcgaW5cbiAgICAgICAgbGV0IGNyZWF0ZSA9IG1hcF9jcmVhdGUgKEEuVGFnLmNyZWF0ZSB0YWcpIGluXG4gICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5UYWdcbiAgICAgICAgICAoQi5UYWcuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgICAgICAgICB7IEIuVGFnX2ludGVybmFsLmxhYmVsXG4gICAgICAgICAgICAgOyByZXBcbiAgICAgICAgICAgICA7IGFyaXR5XG4gICAgICAgICAgICAgOyBhcmdzX2xhYmVsc1xuICAgICAgICAgICAgIDsgaW5kZXhcbiAgICAgICAgICAgICA7IG9jYW1sX3JlcHJcbiAgICAgICAgICAgICA7IHR5aWRcbiAgICAgICAgICAgICA7IGNyZWF0ZVxuICAgICAgICAgICAgIH0pXG4gICAgaW5cbiAgICBsZXQgdHlwZW5hbWUgPSBBLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCB2YXJpYW50IGluXG4gICAgbGV0IHBvbHltb3JwaGljID0gQS5WYXJpYW50LmlzX3BvbHltb3JwaGljIHZhcmlhbnQgaW5cbiAgICBsZXQgdGFncyA9XG4gICAgICBBcnJheS5pbml0IChBLlZhcmlhbnQubGVuZ3RoIHZhcmlhbnQpIChmdW4gaW5kZXggLT5cbiAgICAgICAgbWFwX3RhZyAoQS5WYXJpYW50LnRhZyB2YXJpYW50IGluZGV4KSlcbiAgICBpblxuICAgIGxldCB2YWx1ZSAoYSA6IHZhcmlhbnQpID1cbiAgICAgIG1hdGNoIEEuVmFyaWFudC52YWx1ZSB2YXJpYW50IGEgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVmFsdWUgKGF0YWcsIGEpIC0+XG4gICAgICAgIChmdW4gKHR5cGUgYXJncykgKGF0YWcgOiAodmFyaWFudCwgYXJncykgQS5UYWcudCkgKGEgOiBhcmdzKSAtPlxuICAgICAgICAgICBsZXQgKEIuVmFyaWFudF9pbnRlcm5hbC5UYWcgYnRhZykgPSB0YWdzLihBLlRhZy5pbmRleCBhdGFnKSBpblxuICAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYnRhZyA6ICh2YXJpYW50LCBleCkgQi5UYWcudCkgLT5cbiAgICAgICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biAoQS5UYWcudHlpZCBhdGFnKSAoQi5UYWcudHlpZCBidGFnKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYnRhZyA9IChidGFnIDogKHZhcmlhbnQsIGFyZ3MpIEIuVGFnLnQpIGluXG4gICAgICAgICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5WYWx1ZSAoYnRhZywgYSkpXG4gICAgICAgICAgICAgYnRhZylcbiAgICAgICAgICBhdGFnXG4gICAgICAgICAgYVxuICAgIGluXG4gICAgQi5WYXJpYW50LmludGVybmFsX3VzZV9vbmx5IHsgQi5WYXJpYW50X2ludGVybmFsLnR5cGVuYW1lOyB0YWdzOyBwb2x5bW9ycGhpYzsgdmFsdWUgfVxuICA7O1xuXG4gIGxldCBtYXBfcmVjb3JkICh0eXBlIHJlY29yZCkgeyBtYXAgfSAocmVjb3JkIDogcmVjb3JkIEEuUmVjb3JkLnQpID1cbiAgICBsZXQgbWFwX2ZpZWxkIGZpZWxkID1cbiAgICAgIG1hdGNoIGZpZWxkIHdpdGhcbiAgICAgIHwgQS5SZWNvcmQuRmllbGQgZmllbGQgLT5cbiAgICAgICAgbGV0IGxhYmVsID0gQS5GaWVsZC5sYWJlbCBmaWVsZCBpblxuICAgICAgICBsZXQgcmVwID0gbWFwIChBLkZpZWxkLnRyYXZlcnNlIGZpZWxkKSBpblxuICAgICAgICBsZXQgaW5kZXggPSBBLkZpZWxkLmluZGV4IGZpZWxkIGluXG4gICAgICAgIGxldCBpc19tdXRhYmxlID0gQS5GaWVsZC5pc19tdXRhYmxlIGZpZWxkIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5GaWVsZC50eWlkIGZpZWxkIGluXG4gICAgICAgIGxldCBnZXQgPSBBLkZpZWxkLmdldCBmaWVsZCBpblxuICAgICAgICBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZFxuICAgICAgICAgIChCLkZpZWxkLmludGVybmFsX3VzZV9vbmx5XG4gICAgICAgICAgICAgeyBCLkZpZWxkX2ludGVybmFsLmxhYmVsOyByZXA7IGluZGV4OyBpc19tdXRhYmxlOyB0eWlkOyBnZXQgfSlcbiAgICBpblxuICAgIGxldCB0eXBlbmFtZSA9IEEuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVjb3JkIGluXG4gICAgbGV0IGhhc19kb3VibGVfYXJyYXlfdGFnID0gQS5SZWNvcmQuaGFzX2RvdWJsZV9hcnJheV90YWcgcmVjb3JkIGluXG4gICAgbGV0IGZpZWxkcyA9XG4gICAgICBBcnJheS5pbml0IChBLlJlY29yZC5sZW5ndGggcmVjb3JkKSAoZnVuIGluZGV4IC0+XG4gICAgICAgIG1hcF9maWVsZCAoQS5SZWNvcmQuZmllbGQgcmVjb3JkIGluZGV4KSlcbiAgICBpblxuICAgIGxldCBjcmVhdGUgeyBCLlJlY29yZF9pbnRlcm5hbC5nZXQgfSA9XG4gICAgICBsZXQgZ2V0ICh0eXBlIGEpIChhZmllbGQgOiAoXywgYSkgQS5GaWVsZC50KSA9XG4gICAgICAgIG1hdGNoIGZpZWxkcy4oQS5GaWVsZC5pbmRleCBhZmllbGQpIHdpdGhcbiAgICAgICAgfCBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZCBiZmllbGQgLT5cbiAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYmZpZWxkIDogKHJlY29yZCwgZXgpIEIuRmllbGQudCkgLT5cbiAgICAgICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc19leG4gKEEuRmllbGQudHlpZCBhZmllbGQpIChCLkZpZWxkLnR5aWQgYmZpZWxkKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgbGV0IGJmaWVsZCA9IChiZmllbGQgOiAocmVjb3JkLCBhKSBCLkZpZWxkLnQpIGluXG4gICAgICAgICAgICAgZ2V0IGJmaWVsZClcbiAgICAgICAgICAgIGJmaWVsZFxuICAgICAgaW5cbiAgICAgIEEuUmVjb3JkLmNyZWF0ZSByZWNvcmQgeyBBLlJlY29yZC5nZXQgfVxuICAgIGluXG4gICAgQi5SZWNvcmQuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgIHsgQi5SZWNvcmRfaW50ZXJuYWwudHlwZW5hbWU7IGZpZWxkczsgaGFzX2RvdWJsZV9hcnJheV90YWc7IGNyZWF0ZSB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgTmFtZWQgPSBzaWdcbiAgdHlwZSAnYSBjb21wdXRhdGlvblxuXG4gIG1vZHVsZSBDb250ZXh0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY3JlYXRlIDogdW5pdCAtPiB0XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBpbml0IDogQ29udGV4dC50IC0+ICdhIFR5cGVuYW1lLnQgLT4gJ2EgdFxuICB2YWwgZ2V0X3dpcF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNldF9maW5hbF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNoYXJlIDogXyBUeXBlcmVwLnQgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXB1dGF0aW9uID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgVmFyaWFudF9hbmRfcmVjb3JkX2ludGYuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIGludCA6IGludCB0XG4gIHZhbCBpbnQzMiA6IGludDMyIHRcbiAgdmFsIGludDY0IDogaW50NjQgdFxuICB2YWwgbmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgdmFsIGNoYXIgOiBjaGFyIHRcbiAgdmFsIGZsb2F0IDogZmxvYXQgdFxuICB2YWwgc3RyaW5nIDogc3RyaW5nIHRcbiAgdmFsIGJ5dGVzIDogYnl0ZXMgdFxuICB2YWwgYm9vbCA6IGJvb2wgdFxuICB2YWwgdW5pdCA6IHVuaXQgdFxuICB2YWwgb3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICB2YWwgbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBhcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICB2YWwgbGF6eV90IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICB2YWwgcmVmXyA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgdmFsIGZ1bmN0aW9uXyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgLT4gJ2IpIHRcbiAgdmFsIHR1cGxlMiA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgdHVwbGUzIDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gKCdhICogJ2IgKiAnYykgdFxuICB2YWwgdHVwbGU0IDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gJ2QgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgdmFsIHR1cGxlNSA6ICdhIHQgLT4gJ2IgdCAtPiAnYyB0IC0+ICdkIHQgLT4gJ2UgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QgKiAnZSkgdFxuICB2YWwgcmVjb3JkIDogJ2EgUmVjb3JkLnQgLT4gJ2EgdFxuICB2YWwgdmFyaWFudCA6ICdhIFZhcmlhbnQudCAtPiAnYSB0XG5cbiAgbW9kdWxlIE5hbWVkIDogTmFtZWQgd2l0aCB0eXBlICdhIGNvbXB1dGF0aW9uIDo9ICdhIHRcbmVuZFxuXG4oKiBzcGVjaWFsIGZ1bmN0b3IgYXBwbGljYXRpb24gZm9yIGNvbXB1dGF0aW9uIGFzIGNsb3N1cmUgb2YgdGhlIGZvcm0gW2EgLT4gYl0gKilcbm1vZHVsZSBNYWtlX25hbWVkX2Zvcl9jbG9zdXJlIChYIDogc2lnXG4gICAgdHlwZSAnYSBpbnB1dFxuICAgIHR5cGUgJ2Egb3V0cHV0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaW5wdXQgLT4gJ2Egb3V0cHV0XG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb250ZXh0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgbGV0IGNyZWF0ZSA9IGlnbm9yZVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgcnVudGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudFxuICAgIDsgcnVudGltZV9yZWZlcmVuY2UgOiAnYSBYLnQgcmVmXG4gICAgOyBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudCBvcHRpb24gcmVmXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBVbmRlZmluZWQgb2Ygc3RyaW5nXG5cbiAgbGV0IGluaXQgKCkgbmFtZSA9XG4gICAgbGV0IHBhdGggPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIG5hbWUpIGluXG4gICAgbGV0IHIgPSByZWYgKGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWQgcGF0aCkpIGluXG4gICAgeyBydW50aW1lX2RlcmVmZXJlbmNlID0gKGZ1biBpbnB1dCAtPiAhciBpbnB1dClcbiAgICA7IHJ1bnRpbWVfcmVmZXJlbmNlID0gclxuICAgIDsgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSByZWYgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWQgPVxuICAgIG1hdGNoIHNoYXJlZC5jb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIGNsb3MgLT4gY2xvc1xuICAgIHwgTm9uZSAtPiBzaGFyZWQucnVudGltZV9kZXJlZmVyZW5jZVxuICA7O1xuXG4gIGxldCBzZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uID1cbiAgICBsZXQgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSBzaGFyZWQuY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgaW5cbiAgICBtYXRjaCBjb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBOb25lIC0+XG4gICAgICBpZiBCYXNlLnBoeXNfZXF1YWwgc2hhcmVkLnJ1bnRpbWVfZGVyZWZlcmVuY2UgY29tcHV0YXRpb24gdGhlbiBhc3NlcnQgZmFsc2U7XG4gICAgICBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6PSBTb21lIGNvbXB1dGF0aW9uO1xuICAgICAgc2hhcmVkLnJ1bnRpbWVfcmVmZXJlbmNlIDo9IGNvbXB1dGF0aW9uO1xuICAgICAgY29tcHV0YXRpb25cbiAgOztcblxuICBsZXQgc2hhcmUgXyA9IHRydWVcbmVuZFxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGltcGxlbWVudHMgOiBUeXBlbmFtZS5VaWQudCAtPiBib29sXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBCcm9rZW5fZGVwZW5kZW5jeSBvZiBzdHJpbmdcblxuICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzIG5hbWUgcmVxdWlyZWQgPVxuICAgIG1hdGNoIHJlcXVpcmVkIHdpdGhcbiAgICB8IFtdIC0+IGZ1biBfIC0+ICgpXG4gICAgfCBfIC0+XG4gICAgICBmdW4gdWlkIC0+XG4gICAgICAgIExpc3QuaXRlclxuICAgICAgICAgIChmdW4geyBuYW1lID0gbmFtZSc7IGltcGxlbWVudHMgfSAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoaW1wbGVtZW50cyB1aWQpXG4gICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAoKiBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgc2V0IHVwLCB0aGlzIGlzIGFuIGVycm9yIGR1cmluZyB0aGVcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uIG9mIHRoZSBwcm9ncmFtLCB3ZSByYXRoZXIgZmFpbCB3aXRoIGEgaHVtYW5cbiAgICAgICAgICAgICAgICAgIHJlYWRhYmxlIG91dHB1dCAqKVxuICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgIFwiVHlwZV9nZW5lcmljICVTIHJlcXVpcmVzICVTIGZvciB1aWQgJVNcXG5cIlxuICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICBuYW1lJ1xuICAgICAgICAgICAgICAgICAgIChUeXBlbmFtZS5VaWQubmFtZSB1aWQpXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgcHJlcnJfZW5kbGluZSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgcmFpc2UgKEJyb2tlbl9kZXBlbmRlbmN5IG1lc3NhZ2UpKSlcbiAgICAgICAgICByZXF1aXJlZFxuICA7O1xuZW5kXG5cbigqIEV4dGVuZGluZyBhbiBleGlzdGluZyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBFeHRlbmRpbmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG5cbiAgdmFsIGlkZW50IDogSWRlbnQudFxuXG4gICgqIGdlbmVyaWNfaWRlbnQgKiB0eXBlbmFtZSBvciBpbmZvICopXG4gIGV4Y2VwdGlvbiBOb3RfaW1wbGVtZW50ZWQgb2Ygc3RyaW5nICogc3RyaW5nXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBjb21wdXRlIDogdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIGNvbXB1dGF0aW9uIC0+ICdhIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBjb21wdXRhdGlvbiAtPiAnYiBjb21wdXRhdGlvbiAtPiAoJ2EsICdiKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICAnYSBjb21wdXRhdGlvblxuICAgICAgLT4gJ2IgY29tcHV0YXRpb25cbiAgICAgIC0+ICdjIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICdlIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIHZhbCByZWdpc3RlcjAgOiAobW9kdWxlIFMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMSA6IChtb2R1bGUgUzEpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMiA6IChtb2R1bGUgUzIpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMyA6IChtb2R1bGUgUzMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNCA6IChtb2R1bGUgUzQpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNSA6IChtb2R1bGUgUzUpIC0+IHVuaXRcblxuICAoKiBzcGVjaWFsIGxlc3Mgc2NhcnkgdHlwZSB3aGVuIHRoZSB0eXBlIGhhcyBubyBwYXJhbWV0ZXJzICopXG4gIHZhbCByZWdpc3RlciA6ICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiAtPiB1bml0XG5cbiAgKCpcbiAgICAgRXNzZW50aWFsbHkgYmVjYXVzZSB3ZSBjYW5ub3QgdGFsayBhYm91dCBhIHZhcmlhYmxlIG9mIGtpbmQgKiAtPiBrXG4gICAgIHZhbCByZWdpc3RlcjEgOiAnYSAndCBUeXBlcmVwLnQgLT4gKCdhIGNvbXB1dGF0aW9uIC0+ICdhICd0IGNvbXB1dGF0aW9uKSAtPiB1bml0XG4gICAgIC4uLlxuICAqKVxuZW5kXG5cbigqIEltcGxlbWVudGluZyBhIG5ldyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBTX2ltcGxlbWVudGF0aW9uID0gc2lnXG4gIGluY2x1ZGUgRXh0ZW5kaW5nXG5cbiAgKCogcmFpc2UgdXNpbmcgdGhlIGN1cnJlbnQgaWRlbnQgKilcbiAgdmFsIHJhaXNlX25vdF9pbXBsZW1lbnRlZCA6IHN0cmluZyAtPiAnYVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICAoKlxuICAgICBTdGFuZGFyZCBjYXNlLCBmaW5kIGEgZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24sIG9yIGxvb2sgaW4gdGhlIGNvbnRlbnRcbiAgKilcbiAgdmFsIF91c2luZ19leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgVHlwZXJlcC50IGxhenlfdCBvcHRpb25cbiAgICAtPiAnYSBjb21wdXRhdGlvblxuXG4gICgqXG4gICAgIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSBtb3JlIGNvbnRyb2wgb24gd2hhdCB5b3Ugd2FudCB0byBkb1xuICAqKVxuICB2YWwgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgY29tcHV0YXRpb24gb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEV4dGVuZGluZ1xuXG4gIHZhbCBvZl90eXBlcmVwIDogJ2EgVHlwZXJlcC50IC0+IFsgYGdlbmVyaWMgb2YgJ2EgY29tcHV0YXRpb24gXVxuXG4gIG1vZHVsZSBDb21wdXRhdGlvbiA6IENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFggOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gICAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG4gIGVuZCkgOiBTX2ltcGxlbWVudGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFgudFxuICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuXG4gIGluY2x1ZGUgVHlwZV9nZW5lcmljX2ludGYuTSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgIGVuZClcblxuICAoKiB3ZSBkbyBub3QgdXNlIGNvcmUgc2luY2Ugd2UgYXJlIGVhcmxpZXIgaW4gdGhlIGRlcGVuZGVuY2llcyBncmFwaCAqKVxuICBtb2R1bGUgVWlkX3RhYmxlID0gc3RydWN0XG4gICAgaW5jbHVkZSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLlVpZClcblxuICAgIGxldCBmaW5kIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgdHJ5IFNvbWUgKGZpbmQgdGFibGUga2V5KSB3aXRoXG4gICAgICAgIHwgQmFzZS5Ob3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lKVxuICAgICAgZWxzZSBOb25lXG4gICAgOztcblxuICAgIGxldCBjaGVja19kZXBlbmRlbmNpZXMgPSBJZGVudC5jaGVja19kZXBlbmRlbmNpZXMgWC5uYW1lIFgucmVxdWlyZWRcblxuICAgIGxldCByZXBsYWNlIHRhYmxlIGtleSB2YWx1ZSA9XG4gICAgICBjaGVja19kZXBlbmRlbmNpZXMga2V5O1xuICAgICAgcmVwbGFjZSAoTGF6eS5mb3JjZSB0YWJsZSkga2V5IHZhbHVlXG4gICAgOztcblxuICAgIGxldCBtZW0gdGFibGUga2V5ID1cbiAgICAgIGlmIExhenkuaXNfdmFsIHRhYmxlXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRhYmxlID0gTGF6eS5mb3JjZSB0YWJsZSBpblxuICAgICAgICBtZW0gdGFibGUga2V5KVxuICAgICAgZWxzZSBmYWxzZVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBzaXplID0gMjU2XG4gIGxldCB0YWJsZTAgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTEgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTIgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTMgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTQgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTUgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG5cbiAgbGV0IGlzX3JlZ2lzdGVyZWQgdWlkID1cbiAgICBVaWRfdGFibGUubWVtIHRhYmxlMCB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMSB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMiB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMyB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlNCB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlNSB1aWRcbiAgOztcblxuICBsZXQgaWRlbnQgPSB7IElkZW50Lm5hbWUgPSBYLm5hbWU7IGltcGxlbWVudHMgPSBpc19yZWdpc3RlcmVkIH1cblxuICBtb2R1bGUgRmluZDAgKFQgOiBUeXBlcmVwLk5hbWVkLlQwKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlIDogdW5pdCAtPiBULm5hbWVkIGNvbXB1dGF0aW9uIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTAgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUyA9ICh2YWwgcmVwIDogUykgaW5cbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlbmFtZS5zYW1lX3dpdG5lc3NfZXhuIFMudHlwZW5hbWVfb2ZfdCBULnR5cGVuYW1lX29mX25hbWVkIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCB3aXRuZXNzKSBTLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQxIChUIDogVHlwZXJlcC5OYW1lZC5UMSkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZSA6IHVuaXQgLT4gKFQuYSBjb21wdXRhdGlvbiAtPiBULmEgVC5uYW1lZCBjb21wdXRhdGlvbikgb3B0aW9uXG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBjb21wdXRlICgpID1cbiAgICAgIG1hdGNoIFVpZF90YWJsZS5maW5kIHRhYmxlMSAoVHlwZW5hbWUudWlkIFQudHlwZW5hbWVfb2ZfdCkgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBTMSA9ICh2YWwgcmVwIDogUzEpIGluXG4gICAgICAgIGxldCBtb2R1bGUgQ29udiA9XG4gICAgICAgICAgVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4bl8xXG4gICAgICAgICAgICAoUzEpXG4gICAgICAgICAgICAoc3RydWN0XG4gICAgICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID0gVC5hIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzEuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDIgKFQgOiBUeXBlcmVwLk5hbWVkLlQyKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiAoVC5hLCBULmIpIFQubmFtZWQgY29tcHV0YXRpb24pIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTIgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzIgPSAodmFsIHJlcCA6IFMyKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fMlxuICAgICAgICAgICAgKFMyKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9IFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMi5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kMyAoVCA6IFR5cGVyZXAuTmFtZWQuVDMpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYykgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgICAgb3B0aW9uXG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBjb21wdXRlICgpID1cbiAgICAgIG1hdGNoIFVpZF90YWJsZS5maW5kIHRhYmxlMyAoVHlwZW5hbWUudWlkIFQudHlwZW5hbWVfb2ZfdCkgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBTMyA9ICh2YWwgcmVwIDogUzMpIGluXG4gICAgICAgIGxldCBtb2R1bGUgQ29udiA9XG4gICAgICAgICAgVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4bl8zXG4gICAgICAgICAgICAoUzMpXG4gICAgICAgICAgICAoc3RydWN0XG4gICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPVxuICAgICAgICAgICAgICBULmEgY29tcHV0YXRpb24gLT4gVC5iIGNvbXB1dGF0aW9uIC0+IFQuYyBjb21wdXRhdGlvbiAtPiAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgQ29udi4od2l0bmVzcy5lcSkpIFMzLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQ0IChUIDogVHlwZXJlcC5OYW1lZC5UNCkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgdW5pdFxuICAgICAgLT4gKFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuYiBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IChULmEsIFQuYiwgVC5jLCBULmQpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTQgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzQgPSAodmFsIHJlcCA6IFM0KSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fNFxuICAgICAgICAgICAgKFM0KVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA9ICgnYSwgJ2IsICdjLCAnZCkgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPVxuICAgICAgICAgICAgICBULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTNC5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kNSAoVCA6IFR5cGVyZXAuTmFtZWQuVDUpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmUgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYywgVC5kLCBULmUpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTUgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzUgPSAodmFsIHJlcCA6IFM1KSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fNVxuICAgICAgICAgICAgKFM1KVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgPSAoJ2EsICdiLCAnYywgJ2QsICdlKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgICAgICAgIFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmUgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTNS5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB1bml0ID0gVHlwZW5hbWUuc3RhdGljXG5cbiAgbGV0IHJlZ2lzdGVyMCBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFMgPSAodmFsIGNvbXB1dGUgOiBTKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgUy50eXBlbmFtZV9vZl90IGluXG4gICAgVWlkX3RhYmxlLnJlcGxhY2UgdGFibGUwIHVpZCBjb21wdXRlXG4gIDs7XG5cbiAgbGV0IHJlZ2lzdGVyMSBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFMxID0gKHZhbCBjb21wdXRlIDogUzEpIGluXG4gICAgbGV0IHVpZCA9IFR5cGVuYW1lLnVpZCAoUzEudHlwZW5hbWVfb2ZfdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMSB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjIgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMiA9ICh2YWwgY29tcHV0ZSA6IFMyKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMyLnR5cGVuYW1lX29mX3QgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMiB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjMgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMyA9ICh2YWwgY29tcHV0ZSA6IFMzKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMzLnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQpIGluXG4gICAgVWlkX3RhYmxlLnJlcGxhY2UgdGFibGUzIHVpZCBjb21wdXRlXG4gIDs7XG5cbiAgbGV0IHJlZ2lzdGVyNCBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFM0ID0gKHZhbCBjb21wdXRlIDogUzQpIGluXG4gICAgbGV0IHVpZCA9IFR5cGVuYW1lLnVpZCAoUzQudHlwZW5hbWVfb2ZfdCB1bml0IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlNCB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjUgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTNSA9ICh2YWwgY29tcHV0ZSA6IFM1KSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFM1LnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlNSB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlciAodHlwZSBhKSB0eXBlcmVwX29mX2EgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTID0gc3RydWN0XG4gICAgICB0eXBlIHQgPSBhXG5cbiAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVHlwZXJlcC50eXBlbmFtZV9vZl90IHR5cGVyZXBfb2ZfYVxuICAgICAgbGV0IHR5cGVyZXBfb2ZfdCA9IHR5cGVyZXBfb2ZfYVxuICAgICAgbGV0IGNvbXB1dGUgPSBjb21wdXRlXG4gICAgZW5kXG4gICAgaW5cbiAgICByZWdpc3RlcjAgKG1vZHVsZSBTIDogUylcbiAgOztcblxuICAoKiBJTVBMRU1FTlRBVElPTiAqKVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICBsZXQgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiAodHlwZSBhKSBhdXggPSBmdW5jdGlvblxuICAgIHwgVHlwZXJlcC5OYW1lZC5UMCByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQwIChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gVC53aXRuZXNzIGluXG4gICAgICAgICBTb21lIChjdXN0b20gOiBhIGNvbXB1dGF0aW9uKVxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgVHlwZXJlcC5OYW1lZC5UMSByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQxIChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgY3VzdG9tID0gKGN1c3RvbSAoYXV4LmdlbmVyaWMgVC5hKSA6IFQuYSBULm5hbWVkIGNvbXB1dGF0aW9uKSBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDIgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDIgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMiAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgKGF1eC5nZW5lcmljIFQuYikgOiAoVC5hLCBULmIpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDMgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMyAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgKGF1eC5nZW5lcmljIFQuYikgKGF1eC5nZW5lcmljIFQuYylcbiAgICAgICAgICAgIDogKFQuYSwgVC5iLCBULmMpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDQgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDQgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kNCAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgKGF1eC5nZW5lcmljIFQuYikgKGF1eC5nZW5lcmljIFQuYykgKGF1eC5nZW5lcmljIFQuZClcbiAgICAgICAgICAgIDogKFQuYSwgVC5iLCBULmMsIFQuZCkgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gVC53aXRuZXNzIGluXG4gICAgICAgICBTb21lIChjdXN0b20gOiBhIGNvbXB1dGF0aW9uKVxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgVHlwZXJlcC5OYW1lZC5UNSByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UNSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQ1IChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgY3VzdG9tID1cbiAgICAgICAgICAgKGN1c3RvbVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5hKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5iKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5jKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5kKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5lKVxuICAgICAgICAgICAgOiAoVC5hLCBULmIsIFQuYywgVC5kLCBULmUpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgOztcblxuICBleGNlcHRpb24gTm90X2ltcGxlbWVudGVkIG9mIHN0cmluZyAqIHN0cmluZ1xuXG4gIGxldCByYWlzZV9ub3RfaW1wbGVtZW50ZWQgc3RyaW5nID0gcmFpc2UgKE5vdF9pbXBsZW1lbnRlZCAoWC5uYW1lLCBzdHJpbmcpKVxuXG4gIGxldCBfdXNpbmdfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24gYXV4IHJlcCBjb250ZW50ID1cbiAgICBtYXRjaCBmaW5kX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIGF1eCByZXAgd2l0aFxuICAgIHwgU29tZSBjb21wdXRhdGlvbiAtPiBjb21wdXRhdGlvblxuICAgIHwgTm9uZSAtPlxuICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPiBhdXguZ2VuZXJpYyBjb250ZW50XG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBsZXQgdHlwZW5hbWUgPSBUeXBlcmVwLk5hbWVkLnR5cGVuYW1lX29mX3QgcmVwIGluXG4gICAgICAgICBsZXQgbmFtZSA9IFR5cGVuYW1lLlVpZC5uYW1lIChUeXBlbmFtZS51aWQgdHlwZW5hbWUpIGluXG4gICAgICAgICByYWlzZV9ub3RfaW1wbGVtZW50ZWQgbmFtZSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgXyA9IEhhc2h0YmwuTWFrZSAoVHlwZW5hbWUuS2V5KVxuXG5tb2R1bGUgTWFrZSAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgICB2YWwgcmVxdWlyZWQgOiBJZGVudC50IGxpc3RcblxuICAgIGluY2x1ZGUgQ29tcHV0YXRpb24gd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgQ29tcHV0YXRpb24gPSBYXG4gIGluY2x1ZGUgTWFrZV9TX2ltcGxlbWVudGF0aW9uIChYKVxuXG4gIG1vZHVsZSBNZW1vID0gVHlwZW5hbWUuVGFibGUgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgWC5OYW1lZC50XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBIZWxwZXIgPSBIZWxwZXIgKFR5cGVyZXApIChDb21wdXRhdGlvbilcblxuICBsZXQgb2ZfdHlwZXJlcCByZXAgPVxuICAgIGxldCBjb250ZXh0ID0gWC5OYW1lZC5Db250ZXh0LmNyZWF0ZSAoKSBpblxuICAgIGxldCBtZW1vX3RhYmxlID0gTWVtby5jcmVhdGUgMzIgaW5cbiAgICBsZXQgcmVjIG9mX3R5cGVyZXAgOiB0eXBlIGEuIGEgVHlwZXJlcC50IC0+IGEgdCA9IGZ1bmN0aW9uXG4gICAgICB8IFR5cGVyZXAuSW50IC0+IFguaW50XG4gICAgICB8IFR5cGVyZXAuSW50MzIgLT4gWC5pbnQzMlxuICAgICAgfCBUeXBlcmVwLkludDY0IC0+IFguaW50NjRcbiAgICAgIHwgVHlwZXJlcC5OYXRpdmVpbnQgLT4gWC5uYXRpdmVpbnRcbiAgICAgIHwgVHlwZXJlcC5DaGFyIC0+IFguY2hhclxuICAgICAgfCBUeXBlcmVwLkZsb2F0IC0+IFguZmxvYXRcbiAgICAgIHwgVHlwZXJlcC5TdHJpbmcgLT4gWC5zdHJpbmdcbiAgICAgIHwgVHlwZXJlcC5CeXRlcyAtPiBYLmJ5dGVzXG4gICAgICB8IFR5cGVyZXAuQm9vbCAtPiBYLmJvb2xcbiAgICAgIHwgVHlwZXJlcC5Vbml0IC0+IFgudW5pdFxuICAgICAgfCBUeXBlcmVwLk9wdGlvbiByZXAgLT4gWC5vcHRpb24gKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkxpc3QgcmVwIC0+IFgubGlzdCAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuQXJyYXkgcmVwIC0+IFguYXJyYXkgKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkxhenkgcmVwIC0+IFgubGF6eV90IChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5SZWYgcmVwIC0+IFgucmVmXyAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuRnVuY3Rpb24gKGRvbSwgcm5nKSAtPiBYLmZ1bmN0aW9uXyAob2ZfdHlwZXJlcCBkb20pIChvZl90eXBlcmVwIHJuZylcbiAgICAgIHwgVHlwZXJlcC5UdXBsZSB0dXBsZSAtPlxuICAgICAgICAoKiBkbyBOT1Qgd3JpdGUgW1gudHVwbGUyIChvZl90eXBlcmVwIGEpIChvZl90eXBlcmVwIGIpXVxuICAgICAgICAgICBiZWNhdXNlIG9mX3R5cGVyZXAgY2FuIGNvbnRhaW4gYSBzaWRlIGVmZmVjdCBhbmQgW2FdIHNob3VsZCBiZSBleGVjdXRlZFxuICAgICAgICAgICBiZWZvcmUgW2JdICopXG4gICAgICAgIChtYXRjaCB0dXBsZSB3aXRoXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDIgKGEsIGIpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgWC50dXBsZTIgcmEgcmJcbiAgICAgICAgIHwgVHlwZXJlcC5UdXBsZS5UMyAoYSwgYiwgYykgLT5cbiAgICAgICAgICAgbGV0IHJhID0gb2ZfdHlwZXJlcCBhIGluXG4gICAgICAgICAgIGxldCByYiA9IG9mX3R5cGVyZXAgYiBpblxuICAgICAgICAgICBsZXQgcmMgPSBvZl90eXBlcmVwIGMgaW5cbiAgICAgICAgICAgWC50dXBsZTMgcmEgcmIgcmNcbiAgICAgICAgIHwgVHlwZXJlcC5UdXBsZS5UNCAoYSwgYiwgYywgZCkgLT5cbiAgICAgICAgICAgbGV0IHJhID0gb2ZfdHlwZXJlcCBhIGluXG4gICAgICAgICAgIGxldCByYiA9IG9mX3R5cGVyZXAgYiBpblxuICAgICAgICAgICBsZXQgcmMgPSBvZl90eXBlcmVwIGMgaW5cbiAgICAgICAgICAgbGV0IHJkID0gb2ZfdHlwZXJlcCBkIGluXG4gICAgICAgICAgIFgudHVwbGU0IHJhIHJiIHJjIHJkXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDUgKGEsIGIsIGMsIGQsIGUpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIGxldCByZCA9IG9mX3R5cGVyZXAgZCBpblxuICAgICAgICAgICBsZXQgcmUgPSBvZl90eXBlcmVwIGUgaW5cbiAgICAgICAgICAgWC50dXBsZTUgcmEgcmIgcmMgcmQgcmUpXG4gICAgICB8IFR5cGVyZXAuUmVjb3JkIHJlY29yZCAtPlxuICAgICAgICBYLnJlY29yZCAoSGVscGVyLm1hcF9yZWNvcmQgeyBIZWxwZXIubWFwID0gb2ZfdHlwZXJlcCB9IHJlY29yZClcbiAgICAgIHwgVHlwZXJlcC5WYXJpYW50IHZhcmlhbnQgLT5cbiAgICAgICAgWC52YXJpYW50IChIZWxwZXIubWFwX3ZhcmlhbnQgeyBIZWxwZXIubWFwID0gb2ZfdHlwZXJlcCB9IHZhcmlhbnQpXG4gICAgICB8IFR5cGVyZXAuTmFtZWQgKG5hbWVkLCBjb250ZW50KSAtPlxuICAgICAgICBsZXQgdHlwZW5hbWUgPSBUeXBlcmVwLk5hbWVkLnR5cGVuYW1lX29mX3QgbmFtZWQgaW5cbiAgICAgICAgKG1hdGNoIE1lbW8uZmluZCBtZW1vX3RhYmxlIHR5cGVuYW1lIHdpdGhcbiAgICAgICAgIHwgU29tZSBzaGFyZWQgLT4gWC5OYW1lZC5nZXRfd2lwX2NvbXB1dGF0aW9uIHNoYXJlZFxuICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgIChtYXRjaCBmaW5kX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIHsgZ2VuZXJpYyA9IG9mX3R5cGVyZXAgfSBuYW1lZCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgY29tcHV0YXRpb24gLT4gY29tcHV0YXRpb25cbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAobWF0Y2ggY29udGVudCB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIHR5cGVuYW1lKSBpblxuICAgICAgICAgICAgICAgICByYWlzZV9ub3RfaW1wbGVtZW50ZWQgbmFtZVxuICAgICAgICAgICAgICAgfCBTb21lIChsYXp5IGNvbnRlbnQpIC0+XG4gICAgICAgICAgICAgICAgIGlmIFguTmFtZWQuc2hhcmUgY29udGVudFxuICAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgICBsZXQgc2hhcmVkID0gWC5OYW1lZC5pbml0IGNvbnRleHQgdHlwZW5hbWUgaW5cbiAgICAgICAgICAgICAgICAgICBNZW1vLnNldCBtZW1vX3RhYmxlIHR5cGVuYW1lIHNoYXJlZDtcbiAgICAgICAgICAgICAgICAgICBsZXQgY29tcHV0YXRpb24gPSBvZl90eXBlcmVwIGNvbnRlbnQgaW5cbiAgICAgICAgICAgICAgICAgICBYLk5hbWVkLnNldF9maW5hbF9jb21wdXRhdGlvbiBzaGFyZWQgY29tcHV0YXRpb24pXG4gICAgICAgICAgICAgICAgIGVsc2Ugb2ZfdHlwZXJlcCBjb250ZW50KSkpXG4gICAgaW5cbiAgICBsZXQgY29tcHV0YXRpb24gPSBvZl90eXBlcmVwIHJlcCBpblxuICAgIGBnZW5lcmljIGNvbXB1dGF0aW9uXG4gIDs7XG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMDYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJUeXBlcmVwX2xpYl9TdGRfaW50ZXJuYWwiLCJUeXBlcmVwX2xpYl9UeXBlX2VxdWFsIiwiVHlwZXJlcF9saWJfVHlwZW5hbWUiLCJUeXBlcmVwX2xpYl9NYWtlX3R5cGVuYW1lIiwiWCIsIk5hbWVfb2ZfeCIsInR5cGVuYW1lX29mX3QiLCJ0eXBlbmFtZV9vZl9uYW1lZCIsIndpdG5lc3MiLCJuYW1lZCIsIm9mX3AxIiwib2ZfcDIiLCJvZl9wMyIsIm9mX3A0Iiwib2ZfcDUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvdHlwZXJlcC9tYWtlX3R5cGVuYW1lLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLGdCQUFBQztBQUFBQTtBQUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsZ0JBQUE7QUFBQSxTQUFBQyxvQkFBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBQyxRQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBTDtBQUFBQTtBQUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsZ0JBQUE7QUFBQSxpQkFBQUcsTUFBQUM7QUFBQUE7QUFBQUEsVUFBQSxNQzJCZ0Q7QUFBQSxVQUFBSixnQkFBeEI7QUFBQSxVQUFBQyxvQkFDcEI7QUFBQSxVQUFBQyxVQUFBO0FBQUE7QUFBQSxRQWF5QjtBQUFBLFFEekM3QjtBQUFBO0FBQUEsZ0JBQUFKO0FBQUFBO0FBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxnQkFBQTtBQUFBLGlCQUFBRyxNQUFBQyxPQUFBQztBQUFBQTtBQUFBQSxVQUFBLE1Db0Q0RDtBQUFBLGdCQUE5QjtBQUFBLFVBQUFMLGdCQUF4QjtBQUFBLFVBQUFDLG9CQUVGO0FBQUEsVUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQSxRQWlCK0I7QUFBQSxRRHZFbkM7QUFBQTtBQUFBLGdCQUFBSjtBQUFBQTtBQUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsZ0JBQUE7QUFBQSxpQkFBQUcsTUFBQUMsT0FBQUMsT0FBQUM7QUFBQUE7QUFBQUEsVUFBQSxNQ3FGUTtBQUFBLGdCQURBO0FBQUEsZ0JBREE7QUFBQSxVQUFBTixnQkFERjtBQUFBLFVBQUFDLG9CQUtGO0FBQUEsVUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQXFCbUM7QUFBQSxRRDVHdkM7QUFBQTtBQUFBLGdCQUFBSjtBQUFBQTtBQUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsZ0JBQUE7QUFBQSxpQkFBQUcsTUFBQUMsT0FBQUMsT0FBQUMsT0FBQUM7QUFBQUE7QUFBQUEsVUFBQSxNQzJIUTtBQUFBLGdCQURBO0FBQUEsZ0JBREE7QUFBQSxnQkFEQTtBQUFBLFVBQUFQLGdCQURGO0FBQUEsVUFBQUMsb0JBTUY7QUFBQSxVQUFBQyxVQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUF5QnVDO0FBQUEsUUR0SjNDO0FBQUE7QUFBQSxnQkFBQUo7QUFBQUE7QUFBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLGdCQUFBO0FBQUEsaUJBQUFHLE1BQUFDLE9BQUFDLE9BQUFDLE9BQUFDLE9BQUFDO0FBQUFBO0FBQUFBLFVBQUEsTUNzS1E7QUFBQSxnQkFEQTtBQUFBLGdCQURBO0FBQUEsZ0JBREE7QUFBQSxnQkFEQTtBQUFBLFVBQUFSLGdCQURGO0FBQUEsVUFBQUMsb0JBT0Y7QUFBQSxVQUFBQyxVQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQTZCMkM7QUFBQSxRRHJNL0MiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4gU3RkX2ludGVybmFsXG5cbm1vZHVsZSBNYWtlMCAoWCA6IE5hbWVkX2ludGYuUzApID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlMCAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkID1cbiAgICBUeXBlcmVwLk5hbWVkLlQwXG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlIG5hbWVkID0gWC50XG4gICAgICAgIHR5cGUgdCA9IFgudFxuXG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl9uYW1lZCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gdHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgd2l0bmVzcyA9IFR5cGVfZXF1YWwucmVmbFxuICAgICAgZW5kIDogVHlwZXJlcC5OYW1lZC5UMFxuICAgICAgICB3aXRoIHR5cGUgdCA9IFgudClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTEgKFggOiBOYW1lZF9pbnRmLlMxKSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTEgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCAodHlwZSBwMSkgb2ZfcDEgPVxuICAgIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3QgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSkgaW5cbiAgICBUeXBlcmVwLk5hbWVkLlQxXG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlICdhIG5hbWVkID0gJ2EgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgdCA9IHAxIFgudFxuXG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl9uYW1lZCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gdHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgd2l0bmVzcyA9IFR5cGVfZXF1YWwucmVmbFxuICAgICAgZW5kIDogVHlwZXJlcC5OYW1lZC5UMVxuICAgICAgICB3aXRoIHR5cGUgdCA9IHAxIFgudClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBOYW1lZF9pbnRmLlMyKSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTIgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCAodHlwZSBwMSBwMikgb2ZfcDEgb2ZfcDIgPVxuICAgIGxldCB0eXBlbmFtZV9vZl90ID1cbiAgICAgIE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90IChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDIpXG4gICAgaW5cbiAgICBUeXBlcmVwLk5hbWVkLlQyXG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlICgnYSwgJ2IpIG5hbWVkID0gKCdhLCAnYikgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIpIFgudFxuXG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl9uYW1lZCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gdHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgd2l0bmVzcyA9IFR5cGVfZXF1YWwucmVmbFxuICAgICAgZW5kIDogVHlwZXJlcC5OYW1lZC5UMlxuICAgICAgICB3aXRoIHR5cGUgdCA9IChwMSwgcDIpIFgudClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTMgKFggOiBOYW1lZF9pbnRmLlMzKSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTMgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCAodHlwZSBwMSBwMiBwMykgb2ZfcDEgb2ZfcDIgb2ZfcDMgPVxuICAgIGxldCB0eXBlbmFtZV9vZl90ID1cbiAgICAgIE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDIpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDMpXG4gICAgaW5cbiAgICBUeXBlcmVwLk5hbWVkLlQzXG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSBuYW1lZCA9ICgnYSwgJ2IsICdjKSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSBiID0gcDJcblxuICAgICAgICBsZXQgYiA9IG9mX3AyXG5cbiAgICAgICAgdHlwZSBjID0gcDNcblxuICAgICAgICBsZXQgYyA9IG9mX3AzXG5cbiAgICAgICAgdHlwZSB0ID0gKHAxLCBwMiwgcDMpIFgudFxuXG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl9uYW1lZCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gdHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgd2l0bmVzcyA9IFR5cGVfZXF1YWwucmVmbFxuICAgICAgZW5kIDogVHlwZXJlcC5OYW1lZC5UM1xuICAgICAgICB3aXRoIHR5cGUgdCA9IChwMSwgcDIsIHAzKSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2U0IChYIDogTmFtZWRfaW50Zi5TNCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2U0IChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMgcDQpIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0ID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A0KVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UNFxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkID0gKCdhLCAnYiwgJ2MsICdkKSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSBiID0gcDJcblxuICAgICAgICBsZXQgYiA9IG9mX3AyXG5cbiAgICAgICAgdHlwZSBjID0gcDNcblxuICAgICAgICBsZXQgYyA9IG9mX3AzXG5cbiAgICAgICAgdHlwZSBkID0gcDRcblxuICAgICAgICBsZXQgZCA9IG9mX3A0XG5cbiAgICAgICAgdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0KSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDRcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQpIFgudClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTUgKFggOiBOYW1lZF9pbnRmLlM1KSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTUgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCAodHlwZSBwMSBwMiBwMyBwNCBwNSkgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgb2ZfcDUgPVxuICAgIGxldCB0eXBlbmFtZV9vZl90ID1cbiAgICAgIE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDIpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDMpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDQpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDUpXG4gICAgaW5cbiAgICBUeXBlcmVwLk5hbWVkLlQ1XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkID0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgZCA9IHA0XG5cbiAgICAgICAgbGV0IGQgPSBvZl9wNFxuXG4gICAgICAgIHR5cGUgZSA9IHA1XG5cbiAgICAgICAgbGV0IGUgPSBvZl9wNVxuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCwgcDUpIFgudFxuXG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl9uYW1lZCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gdHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgd2l0bmVzcyA9IFR5cGVfZXF1YWwucmVmbFxuICAgICAgZW5kIDogVHlwZXJlcC5OYW1lZC5UNVxuICAgICAgICB3aXRoIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCwgcDUpIFgudClcbiAgOztcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXJlcF9saWIuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIlR5cGVyZXBfbGliX01ha2VfdHlwZW5hbWUiLCJNYWtlMCIsIlgiLCJNIiwidHlwZXJlcF9vZl90IiwidHlwZW5hbWVfb2ZfdCIsIk1ha2UxIiwib2ZfcDEiLCJNYWtlMiIsIm9mX3AyIiwiTWFrZTMiLCJvZl9wMyIsIk1ha2U0Iiwib2ZfcDQiLCJNYWtlNSIsIm9mX3A1IiwiVHlwZXJlcF9saWJfVHlwZV9hYnN0cmFjdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi90eXBlcmVwL3R5cGVfYWJzdHJhY3QubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLFlBQUFDLE1BQUFDO0FBQUFBO0FBQUFBLEtBQUFDLElBQUE7QUFBQSxLQUFBQyxlQUFBO0FBQUEsS0FBQUMsZ0JBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsTUFBQUo7QUFBQUEsUUFBQUMsSUFBQTtBQUFBLGFBQUFDLGFBQUFHLE9DWTBDLDJDQUFhLENBQU87QUFBQSxRQUFBRixnQkRaOUQ7QUFBQTtBQUFBO0FBQUEsWUFBQUcsTUFBQU47QUFBQUEsUUFBQUMsSUFBQTtBQUFBLGFBQUFDLGFBQUFHLE9BQUFFO0FBQUFBLEtDb0JnRCxrREFBbUI7QUFBQSxJQUFPO0FBQUEsUUFBQUosZ0JEcEIxRTtBQUFBO0FBQUE7QUFBQSxZQUFBSyxNQUFBUjtBQUFBQSxRQUFBQyxJQUFBO0FBQUEsYUFBQUMsYUFBQUcsT0FBQUUsT0FBQUU7QUFBQUEsS0M0QnNELHlEQUF5QjtBQUFBLElBQU87QUFBQSxRQUFBTixnQkQ1QnRGO0FBQUE7QUFBQTtBQUFBLFlBQUFPLE1BQUFWO0FBQUFBLFFBQUFDLElBQUE7QUFBQSxhQUFBQyxhQUFBRyxPQUFBRSxPQUFBRSxPQUFBRTtBQUFBQSxLQ3FDbUIsZ0VBQStCO0FBQUEsSUFBTztBQUFBLFFBQUFSLGdCRHJDekQ7QUFBQTtBQUFBO0FBQUEsWUFBQVMsTUFBQVo7QUFBQUEsUUFBQUMsSUFBQTtBQUFBLGFBQUFDLGFBQUFHLE9BQUFFLE9BQUFFLE9BQUFFLE9BQUFFO0FBQUFBLEtDZ0RtQix1RUFBcUM7QUFBQSxJQUFPO0FBQUEsUUFBQVYsZ0JEaEQvRDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFXLDRCQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuIFN0ZF9pbnRlcm5hbFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA6IFR5cGVyZXBhYmxlLlMgd2l0aCB0eXBlIHQgOj0gWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMCAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90ID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCwgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTEgKFggOiBOYW1lZF9pbnRmLlMxKSA6IFR5cGVyZXBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTEgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgOiBUeXBlcmVwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBYLnQgPVxuc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMiAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiwgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTMgKFggOiBOYW1lZF9pbnRmLlMzKSA6XG4gIFR5cGVyZXBhYmxlLlMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMyAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyIG9mX3AzID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiBvZl9wMywgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTQgKFggOiBOYW1lZF9pbnRmLlM0KSA6XG4gIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2U0IChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgPVxuICAgIFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQsIE5vbmUpXG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTUgKFggOiBOYW1lZF9pbnRmLlM1KSA6XG4gIFR5cGVyZXBhYmxlLlM1IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTUgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCBvZl9wNSA9XG4gICAgVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCBvZl9wNSwgTm9uZSlcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjMwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJUeXBlcmVwX2xpYl9TdGRfaW50ZXJuYWwiLCJUeXBlcmVwIiwidHlwZXJlcF9vZl9pbnQiLCJ0eXBlcmVwX29mX2ludDMyIiwidHlwZXJlcF9vZl9pbnQ2NCIsInR5cGVyZXBfb2ZfbmF0aXZlaW50IiwidHlwZXJlcF9vZl9pbnQ2MyIsInR5cGVyZXBfb2ZfY2hhciIsInR5cGVyZXBfb2ZfZmxvYXQiLCJ0eXBlcmVwX29mX3N0cmluZyIsInR5cGVyZXBfb2ZfYnl0ZXMiLCJ0eXBlcmVwX29mX2Jvb2wiLCJ0eXBlcmVwX29mX3VuaXQiLCJ2YWx1ZV90dXBsZTAiLCJ0eXBlcmVwX29mX29wdGlvbiIsInR5cGVyZXBfb2ZfbGlzdCIsInR5cGVyZXBfb2ZfYXJyYXkiLCJ0eXBlcmVwX29mX2xhenlfdCIsInR5cGVyZXBfb2ZfcmVmIiwidHlwZXJlcF9vZl9mdW5jdGlvbiIsInR5cGVyZXBfb2ZfdHVwbGUwIiwidHlwZXJlcF9vZl90dXBsZTIiLCJ0eXBlcmVwX29mX3R1cGxlMyIsInR5cGVyZXBfb2ZfdHVwbGU0IiwidHlwZXJlcF9vZl90dXBsZTUiLCJ0eXBlbmFtZV9vZl9pbnQiLCJ0eXBlbmFtZV9vZl9pbnQzMiIsInR5cGVuYW1lX29mX2ludDY0IiwidHlwZW5hbWVfb2ZfbmF0aXZlaW50IiwidHlwZW5hbWVfb2ZfaW50NjMiLCJ0eXBlbmFtZV9vZl9jaGFyIiwidHlwZW5hbWVfb2ZfZmxvYXQiLCJ0eXBlbmFtZV9vZl9zdHJpbmciLCJ0eXBlbmFtZV9vZl9ieXRlcyIsInR5cGVuYW1lX29mX2Jvb2wiLCJ0eXBlbmFtZV9vZl91bml0IiwidHlwZW5hbWVfb2Zfb3B0aW9uIiwidHlwZW5hbWVfb2ZfbGlzdCIsInR5cGVuYW1lX29mX2FycmF5IiwidHlwZW5hbWVfb2ZfbGF6eV90IiwidHlwZW5hbWVfb2ZfcmVmIiwidHlwZW5hbWVfb2ZfZnVuY3Rpb24iLCJ0eXBlbmFtZV9vZl90dXBsZTAiLCJ0eXBlbmFtZV9vZl90dXBsZTIiLCJ0eXBlbmFtZV9vZl90dXBsZTMiLCJ0eXBlbmFtZV9vZl90dXBsZTQiLCJ0eXBlbmFtZV9vZl90dXBsZTUiLCJUeXBlcmVwX2xpYl9TdGQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
