// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Univ_map__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Univ_map = [0];
   runtime.caml_register_global(0, Univ_map, "Univ_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Univ_map__Univ_map_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Univ_map_Univ_map_intf = "Univ_map__Univ_map_intf",
    cst_univ_map = "univ_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Univ_map_Univ_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_univ_map);
   caml_call1(Expect_test_collector[6][1], "univ_map/src/univ_map_intf.ml");
   caml_call2(Ppx_inline_test_lib[5], cst_univ_map, "univ_map_intf.ml");
   caml_call1(Ppx_inline_test_lib[6], cst_univ_map);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Univ_map_Univ_map_intf);
   var Univ_map_Univ_map_intf = [0];
   runtime.caml_register_global
    (11, Univ_map_Univ_map_intf, cst_Univ_map_Univ_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Univ_map
//# unitInfo: Requires: Base, Base__Invariant, Base__List, Base__Map, Base__Option, Base__Printf, Base__String, Base__Type_equal, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Univ_map__Univ_map_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Univ_map = "Univ_map",
    cst = "_",
    cst_univ_map = "univ_map",
    cst_univ_map_src_univ_map_ml = "univ_map/src/univ_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Option = global_data.Base__Option,
    Base_Type_equal = global_data.Base__Type_equal,
    Base_Map = global_data.Base__Map,
    Base = global_data.Base,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector;
   caml_call1(Ppx_module_timer_runtime[4], cst_Univ_map);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_univ_map);
   caml_call1(Expect_test_collector[6][1], cst_univ_map_src_univ_map_ml);
   caml_call2(Ppx_inline_test_lib[5], cst_univ_map, "univ_map.ml");
   var
    _a_ = [0, "<uid>"],
    _b_ = [0, "uid"],
    _c_ = [0, "name"],
    _d_ = [0, "type_id2"],
    _e_ = [0, "type_id1"],
    _f_ = [0, cst],
    _g_ = [0, "key"],
    cst_Key_type_id_must_not_provi =
      "[Key.type_id] must not provide different type ids when called on the same input",
    _h_ = [0, cst_univ_map_src_univ_map_ml, 82, 40],
    _i_ = [0, cst],
    _j_ = [0, cst_univ_map_src_univ_map_ml, 81, 2467, 2491],
    _k_ =
      [0,
       [11, "Univ_map.find_exn on unknown key ", [2, 0, 0]],
       "Univ_map.find_exn on unknown key %s"],
    _l_ =
      [0,
       [11, "Univ_map.add_exn on existing key ", [2, 0, 0]],
       "Univ_map.add_exn on existing key %s"],
    _m_ =
      [0,
       [11, "Univ_map.change_exn on unknown key ", [2, 0, 0]],
       "Univ_map.change_exn on unknown key %s"];
   function Make1(Key, Data){
    var sexp_of_t = Key[1];
    function sexp_of_type_id(type_id){
     var _an_ = 0, _ao_ = 0;
     if(Ppx_inline_test_lib[1])
      var _ap_ = _a_;
     else
      var
       _as_ = caml_call1(Base_Type_equal[12][3], type_id),
       _ap_ = caml_call1(Base_Type_equal[12][2][4], _as_);
     var
      _aq_ =
        [0, [1, [0, _b_, [0, caml_call1(Base[85][4], _ap_), _ao_]]], _an_],
      _ar_ = caml_call1(Base_Type_equal[12][6], type_id);
     return [1, [0, [1, [0, _c_, [0, caml_call1(Base[177], _ar_), 0]]], _aq_]];
    }
    function type_id(x_003){
     var
      type_id1 = caml_call1(Key[2], x_003),
      type_id2 = caml_call1(Key[2], x_003);
     if(caml_call2(Base_Type_equal[12][9], type_id1, type_id2))
      return type_id1;
     var
      _aj_ = [0, [1, [0, _d_, [0, sexp_of_type_id(type_id2), 0]]], 0],
      _ak_ = [0, [1, [0, _e_, [0, sexp_of_type_id(type_id1), 0]]], _aj_],
      _al_ =
        [0,
         [1,
          [0,
           _g_,
           [0, caml_call2(Key[1], function(param){return _f_;}, x_003), 0]]],
         _ak_],
      _am_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Key_type_id_must_not_provi),
          _al_]];
     return caml_call1(Base[217], _am_);
    }
    var Key$0 = [0, sexp_of_t, , type_id];
    function name_of_key(key){
     var _ai_ = Key$0[3].call(null, key);
     return caml_call1(Base_Type_equal[12][6], _ai_);
    }
    function uid_of_key(key){
     var _ah_ = Key$0[3].call(null, key);
     return caml_call1(Base_Type_equal[12][3], _ah_);
    }
    function sexp_of_t$0(sexp_of_a, param){
     var
      data = param[2],
      key = param[1],
      _af_ = Key$0[3].call(null, key),
      _ag_ = caml_call1(Base_Type_equal[12][7], _af_);
     return caml_call3(Data[1], sexp_of_a, _ag_, data);
    }
    function type_id_name(param){var key = param[1]; return name_of_key(key);}
    function type_id_uid(param){var key = param[1]; return uid_of_key(key);}
    function compare(t1, t2){
     var
      _ab_ = type_id_name(t2),
      _ac_ = type_id_name(t1),
      c = caml_call2(Base_String[51], _ac_, _ab_);
     if(0 !== c) return c;
     var _ad_ = type_id_uid(t2), _ae_ = type_id_uid(t1);
     return caml_call2(Base_Type_equal[12][2][14], _ae_, _ad_);
    }
    var Packed = [0, sexp_of_t$0, type_id_name, type_id_uid, compare];
    function to_alist(t){
     var _$_ = Packed[4], _aa_ = caml_call1(Base_Map[71], t);
     return caml_call2(Base_List[81], _aa_, _$_);
    }
    function sexp_of_t$1(sexp_of_a, t){
     var
      ___ = to_alist(t),
      x_008 =
        caml_call2
         (Base_List[52],
          ___,
          function(packed){return [0, Packed[2].call(null, packed), packed];});
     return caml_call2
             (Base[148],
              function(param){
               var
                arg1_005 = param[2],
                arg0_004 = param[1],
                res0_006 = caml_call1(Base[177], arg0_004),
                res1_007 = Packed[1].call(null, sexp_of_a, arg1_005);
               return [1, [0, res0_006, [0, res1_007, 0]]];
              },
              x_008);
    }
    function invariant(t){
     return caml_call4
             (Base_Invariant[1],
              _j_,
              t,
              function(x_009){
               return sexp_of_t$1(function(param){return _i_;}, x_009);
              },
              function(param){
               return caml_call2
                       (Base_Map[46],
                        t,
                        function(key, data){
                         var _Z_ = Packed[3].call(null, data);
                         if(caml_call2(Base_Type_equal[12][2][13], key, _Z_))
                          return 0;
                         throw caml_maybe_attach_backtrace
                                ([0, Assert_failure, _h_], 1);
                        });
              });
    }
    function set(t, key, data){
     var _Y_ = uid_of_key(key);
     return caml_call3(Base_Map[32], t, _Y_, [0, key, data]);
    }
    function mem_by_id(t, id){return caml_call2(Base_Map[43], t, id);}
    function mem(t, key){return mem_by_id(t, uid_of_key(key));}
    function remove_by_id(t, id){return caml_call2(Base_Map[42], t, id);}
    function remove(t, key){return remove_by_id(t, uid_of_key(key));}
    var empty = caml_call1(Base_Map[6], [0, Base_Type_equal[12][2][22]]);
    function singleton(key, data){
     var _X_ = uid_of_key(key);
     return caml_call3
             (Base_Map[7],
              [0, Base_Type_equal[12][2][22]],
              _X_,
              [0, key, data]);
    }
    var is_empty = Base_Map[30];
    function find(t, key){
     var _U_ = uid_of_key(key), match = caml_call2(Base_Map[40], t, _U_);
     if(! match) return 0;
     var
      match$0 = match[1],
      value = match$0[2],
      key$0 = match$0[1],
      _V_ = Key$0[3].call(null, key$0),
      _W_ = Key$0[3].call(null, key);
     caml_call2(Base_Type_equal[12][11], _W_, _V_);
     return [0, value];
    }
    function find_exn(t, key){
     var match = find(t, key);
     if(match){var data = match[1]; return data;}
     var _T_ = name_of_key(key);
     return caml_call3(Base_Printf[6], _k_, _T_, 0);
    }
    function add(t, key, data){
     return mem(t, key) ? -1024851605 : [0, 17724, set(t, key, data)];
    }
    function add_exn(t, key, data){
     var match = add(t, key, data);
     if(typeof match === "number"){
      var _S_ = name_of_key(key);
      return caml_call3(Base_Printf[6], _l_, _S_, 0);
     }
     var t$0 = match[2];
     return t$0;
    }
    function change_exn(t, key, update){
     var match = find(t, key);
     if(match){
      var data = match[1];
      return set(t, key, caml_call1(update, data));
     }
     var _R_ = name_of_key(key);
     return caml_call3(Base_Printf[6], _m_, _R_, 0);
    }
    function change(t, key, update){
     var orig = find(t, key), next = caml_call1(update, orig);
     if(! next) return caml_call1(Base_Option[50], orig) ? t : remove(t, key);
     var data = next[1];
     return set(t, key, data);
    }
    function update(t, key, f){
     return change(t, key, function(data){return [0, caml_call1(f, data)];});
    }
    function of_alist_exn(t){
     var
      _Q_ =
        caml_call2
         (Base_List[52],
          t,
          function(p){return [0, Packed[3].call(null, p), p];});
     return caml_call2(Base_Map[10], [0, Base_Type_equal[12][2][22]], _Q_);
    }
    return [0,
            Key$0,
            ,
            ,
            ,
            to_alist,
            sexp_of_t$1,
            invariant,
            set,
            mem_by_id,
            mem,
            remove_by_id,
            remove,
            empty,
            singleton,
            is_empty,
            find,
            find_exn,
            add,
            add_exn,
            change_exn,
            change,
            update,
            of_alist_exn,
            0];
   }
   function Make(Key, Data){
    function sexp_of_t(of_a_011, of_a_012, x_013){return caml_call2(Data[1], of_a_012, x_013);
    }
    var M = Make1(Key, [0, sexp_of_t]);
    function sexp_of_t$0(x_014){return M[6].call(null, Base[191], x_014);}
    var
     invariant = M[7],
     empty = M[13],
     singleton = M[14],
     is_empty = M[15],
     set = M[8],
     mem = M[10],
     mem_by_id = M[9],
     find = M[16],
     find_exn = M[17],
     add = M[18],
     add_exn = M[19],
     change = M[21],
     change_exn = M[20],
     update = M[22],
     remove = M[12],
     remove_by_id = M[11],
     Packed = [0],
     to_alist = M[5],
     of_alist_exn = M[23];
    return [0,
            ,
            sexp_of_t$0,
            Key,
            invariant,
            empty,
            singleton,
            is_empty,
            set,
            mem,
            mem_by_id,
            find,
            find_exn,
            add,
            add_exn,
            change,
            change_exn,
            update,
            remove,
            remove_by_id,
            Packed,
            to_alist,
            of_alist_exn,
            0];
   }
   var sexp_of_t = Base_Type_equal[12][1];
   function type_id(_P_){return _P_;}
   var Type_id_key = [0, sexp_of_t, type_id];
   function sexp_of_t$0(of_a_017){return of_a_017;}
   var
    _n_ = Make(Type_id_key, [0, sexp_of_t$0]),
    type_equal = _n_[23],
    of_alist_exn = _n_[22],
    to_alist = _n_[21],
    Packed = _n_[20],
    remove_by_id = _n_[19],
    remove = _n_[18],
    update = _n_[17],
    change_exn = _n_[16],
    change = _n_[15],
    add_exn = _n_[14],
    add = _n_[13],
    find_exn = _n_[12],
    find = _n_[11],
    mem_by_id = _n_[10],
    mem = _n_[9],
    set = _n_[8],
    is_empty = _n_[7],
    singleton = _n_[6],
    empty = _n_[5],
    invariant = _n_[4],
    sexp_of_t$1 = _n_[2];
   function create(default$0, name, sexp_of){
    return [0, caml_call2(Base_Type_equal[12][4], name, sexp_of), default$0];
   }
   function id(t){return t[1];}
   var Key = [0, create, id];
   function find$0(t, param){
    var default$0 = param[2], key = param[1], _O_ = find(t, key);
    return caml_call2(Base_Option[28], _O_, default$0);
   }
   function set$0(t, param, data){
    var key = param[1];
    return set(t, key, data);
   }
   function change$0(t, key, update){
    return set$0(t, key, caml_call1(update, find$0(t, key)));
   }
   function create$0(init, f, name, sexp_of){
    return [0, caml_call3(Key[1], init, name, sexp_of), f];
   }
   function id$0(t){return caml_call1(Key[2], t[1]);}
   var Key$0 = [0, create$0, id$0];
   function find$1(t, param){var key = param[1]; return find$0(t, key);}
   function set$1(t, param, data){
    var key = param[1];
    return set$0(t, key, data);
   }
   function change$1(t, param, update){
    var key = param[1];
    return change$0(t, key, update);
   }
   function add$0(t, param, data){
    var f = param[2], key = param[1];
    return change$0(t, key, function(acc){return caml_call2(f, acc, data);});
   }
   function create$1(name, sexp_of){
    var _N_ = caml_call1(Base_List[5], sexp_of);
    return caml_call4
            (Key$0[1], 0, function(xs, x){return [0, x, xs];}, name, _N_);
   }
   var
    id$1 = Key$0[2],
    Key$1 = [0, create$1, id$1],
    Multi = [0, Key$1, set$1, find$1, add$0, change$1];
   caml_call1(Ppx_inline_test_lib[6], cst_univ_map);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Univ_map);
   var
    Univ_map =
      [0,
       Type_id_key,
       sexp_of_t$1,
       invariant,
       empty,
       singleton,
       is_empty,
       set,
       mem,
       mem_by_id,
       find,
       find_exn,
       add,
       add_exn,
       change,
       change_exn,
       update,
       remove,
       remove_by_id,
       Packed,
       to_alist,
       of_alist_exn,
       type_equal,
       function(_L_, _K_){
        var _M_ = Make(_L_, _K_);
        return [0,
                _M_[2],
                _M_[3],
                _M_[4],
                _M_[5],
                _M_[6],
                _M_[7],
                _M_[8],
                _M_[9],
                _M_[10],
                _M_[11],
                _M_[12],
                _M_[13],
                _M_[14],
                _M_[15],
                _M_[16],
                _M_[17],
                _M_[18],
                _M_[19],
                _M_[20],
                _M_[21],
                _M_[22],
                _M_[23]];
       },
       function(_H_, _G_){
        var _I_ = Make1(_H_, _G_), _J_ = _I_[1];
        return [0,
                _I_[6],
                [0, _J_[1], _J_[3]],
                _I_[7],
                _I_[13],
                _I_[14],
                _I_[15],
                _I_[8],
                _I_[10],
                _I_[9],
                _I_[16],
                _I_[17],
                _I_[18],
                _I_[19],
                _I_[21],
                _I_[20],
                _I_[22],
                _I_[12],
                _I_[11],
                [0],
                _I_[5],
                _I_[23],
                _I_[24]];
       },
       function(Key, _y_, _x_, Output_data){
        Make(Key, Output_data);
        function merge(t1, t2, param){
         var f = param[1];
         function f$0(key, merge_result){
          var _F_ = caml_call2(f, key, merge_result);
          return caml_call2
                  (Base_Option[22],
                   _F_,
                   function(data){return [0, key, data];});
         }
         return caml_call3
                 (Base_Map[73],
                  t1,
                  t2,
                  function(_z_, param){
                   var _A_ = param[1];
                   if(737457313 === _A_){
                    var
                     _B_ = param[2],
                     _C_ = _B_[2],
                     right_data = _C_[2],
                     right_key = _C_[1],
                     match = _B_[1],
                     left_data = match[2],
                     left_key = match[1],
                     _D_ = caml_call1(Key[2], right_key),
                     _E_ = caml_call1(Key[2], left_key);
                    caml_call2(Base_Type_equal[12][11], _E_, _D_);
                    return f$0
                            (left_key, [0, 737457313, [0, left_data, right_data]]);
                   }
                   if(847852583 <= _A_){
                    var match$0 = param[2], data = match$0[2], key = match$0[1];
                    return f$0(key, [0, 847852583, data]);
                   }
                   var
                    match$1 = param[2],
                    data$0 = match$1[2],
                    key$0 = match$1[1];
                   return f$0(key$0, [0, -57574468, data$0]);
                  });
        }
        return [0, merge];
       },
       function(Key, _p_, _o_, Output_data){
        Make1(Key, Output_data);
        function merge(t1, t2, param){
         var f = param[1];
         function f$0(key, merge_result){
          var _w_ = caml_call2(f, key, merge_result);
          return caml_call2
                  (Base_Option[22],
                   _w_,
                   function(data){return [0, key, data];});
         }
         return caml_call3
                 (Base_Map[73],
                  t1,
                  t2,
                  function(_q_, param){
                   var _r_ = param[1];
                   if(737457313 === _r_){
                    var
                     _s_ = param[2],
                     _t_ = _s_[2],
                     right_data = _t_[2],
                     right_key = _t_[1],
                     match = _s_[1],
                     left_data = match[2],
                     left_key = match[1],
                     _u_ = caml_call1(Key[2], right_key),
                     _v_ = caml_call1(Key[2], left_key);
                    caml_call2(Base_Type_equal[12][11], _v_, _u_);
                    return f$0
                            (left_key, [0, 737457313, [0, left_data, right_data]]);
                   }
                   if(847852583 <= _r_){
                    var match$0 = param[2], data = match$0[2], key = match$0[1];
                    return f$0(key, [0, 847852583, data]);
                   }
                   var
                    match$1 = param[2],
                    data$0 = match$1[2],
                    key$0 = match$1[1];
                   return f$0(key$0, [0, -57574468, data$0]);
                  });
        }
        return [0, merge];
       },
       [0, Key, set$0, find$0, change$0],
       [0, Key$0, set$1, find$1, add$0, change$1],
       Multi];
   runtime.caml_register_global(35, Univ_map, cst_Univ_map);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdl9tYXAuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InVuaXZfbWFwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJVbml2X21hcCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InVuaXZfbWFwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfVW5pdl9tYXBfVW5pdl9tYXBfaW50ZiIsImNzdF91bml2X21hcCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlBweF9tb2R1bGVfdGltZXJfcnVudGltZSIsIlBweF9iZW5jaF9saWJfQmVuY2htYXJrX2FjY3VtdSIsIkV4cGVjdF90ZXN0X2NvbGxlY3RvciIsIlBweF9pbmxpbmVfdGVzdF9saWIiLCJVbml2X21hcF9Vbml2X21hcF9pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2NvcmUvdW5pdl9tYXAvdW5pdl9tYXBfaW50Zi5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxHQ1VBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0F1Tkc7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyx5QkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEak9IIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiogVW5pdmVyc2FsL2hldGVyb2dlbmVvdXMgbWFwcywgdXNlZnVsIGZvciBzdG9yaW5nIHZhbHVlcyBvZiBhcmJpdHJhcnkgdHlwZSBpbiBhIHNpbmdsZVxuICAgIG1hcC5cblxuICAgIEluIG9yZGVyIHRvIHJlY292ZXIgYSB2YWx1ZSwgaXQgbXVzdCBiZSBsb29rZWQgdXAgd2l0aCBleGFjdGx5IHRoZSBbS2V5LnRdIGl0IHdhc1xuICAgIHN0b3JlZCBpbi4gSW4gb3RoZXIgd29yZHMsIGdpdmVuIGRpZmZlcmVudCBbS2V5LnRdcyBmcm9tIHRoZSBzYW1lIFtzdHJpbmddLCBvbmUgd2lsbFxuICAgIG5vdCBiZSBhYmxlIHRvIHJlY292ZXIgdGhlIGtleSBzdG9yZWQgaW4gdGhlIG90aGVyIG9uZS5cblxuICAgIFRoaXMgaXMgc2ltaWxhciB0byBbVW5pdl0gaW4gc3Bpcml0LlxuKilcblxub3BlbiEgQmFzZVxuXG5tb2R1bGUgdHlwZSBLZXkgPSBzaWdcbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgKCoqIEZvciBjb3JyZWN0IGJlaGF2aW9yIG9mIHRoZSBtYXAsIFt0eXBlX2lkXSBtdXN0IHJldHVybiB0aGUgc2FtZSBbVHlwZV9lcXVhbC5JZF0gb25cbiAgICAgIGRpZmZlcmVudCBjYWxscyBvbiB0aGUgc2FtZSBpbnB1dC4gKilcbiAgdmFsIHR5cGVfaWQgOiAnYSB0IC0+ICdhIFR5cGVfZXF1YWwuSWQudFxuZW5kXG5cbm1vZHVsZSB0eXBlIERhdGEgPSBzaWdcbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIHR5cGUgRGF0YTEgPSBzaWdcbiAgdHlwZSAoJ3MsICdhKSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgKCoqIFRoZSBbJ3NdIHBhcmFtZXRlciBpcyBzaGFyZWQgYWNyb3NzIGFsbCB2YWx1ZXMgc3RvcmVkIGluIHRoZSBtYXAuICopXG4gIHR5cGUgJ3MgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIG1vZHVsZSBLZXkgOiBLZXlcblxuICB0eXBlICgncywgJ2EpIGRhdGFcblxuICB2YWwgaW52YXJpYW50IDogXyB0IC0+IHVuaXRcbiAgdmFsIGVtcHR5IDogXyB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSBLZXkudCAtPiAoJ3MsICdhKSBkYXRhIC0+ICdzIHRcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIHNldCA6ICdzIHQgLT4ga2V5OidhIEtleS50IC0+IGRhdGE6KCdzLCAnYSkgZGF0YSAtPiAncyB0XG4gIHZhbCBtZW0gOiBfIHQgLT4gXyBLZXkudCAtPiBib29sXG4gIHZhbCBtZW1fYnlfaWQgOiBfIHQgLT4gVHlwZV9lcXVhbC5JZC5VaWQudCAtPiBib29sXG4gIHZhbCBmaW5kIDogJ3MgdCAtPiAnYSBLZXkudCAtPiAoJ3MsICdhKSBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiAncyB0IC0+ICdhIEtleS50IC0+ICgncywgJ2EpIGRhdGFcbiAgdmFsIGFkZCA6ICdzIHQgLT4ga2V5OidhIEtleS50IC0+IGRhdGE6KCdzLCAnYSkgZGF0YSAtPiBbIGBPayBvZiAncyB0IHwgYER1cGxpY2F0ZSBdXG4gIHZhbCBhZGRfZXhuIDogJ3MgdCAtPiBrZXk6J2EgS2V5LnQgLT4gZGF0YTooJ3MsICdhKSBkYXRhIC0+ICdzIHRcblxuICB2YWwgY2hhbmdlXG4gICAgOiAgJ3MgdFxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZjooKCdzLCAnYSkgZGF0YSBvcHRpb24gLT4gKCdzLCAnYSkgZGF0YSBvcHRpb24pXG4gICAgLT4gJ3MgdFxuXG4gIHZhbCBjaGFuZ2VfZXhuIDogJ3MgdCAtPiAnYSBLZXkudCAtPiBmOigoJ3MsICdhKSBkYXRhIC0+ICgncywgJ2EpIGRhdGEpIC0+ICdzIHRcbiAgdmFsIHVwZGF0ZSA6ICdzIHQgLT4gJ2EgS2V5LnQgLT4gZjooKCdzLCAnYSkgZGF0YSBvcHRpb24gLT4gKCdzLCAnYSkgZGF0YSkgLT4gJ3MgdFxuICB2YWwgcmVtb3ZlIDogJ3MgdCAtPiAnYSBLZXkudCAtPiAncyB0XG4gIHZhbCByZW1vdmVfYnlfaWQgOiAncyB0IC0+IFR5cGVfZXF1YWwuSWQuVWlkLnQgLT4gJ3MgdFxuXG4gIG1vZHVsZSBQYWNrZWQgOiBzaWdcbiAgICB0eXBlICdzIHQgPSBUIDogJ2EgS2V5LnQgKiAoJ3MsICdhKSBkYXRhIC0+ICdzIHRcbiAgZW5kXG5cbiAgdmFsIHRvX2FsaXN0IDogJ3MgdCAtPiAncyBQYWNrZWQudCBsaXN0XG4gIHZhbCBvZl9hbGlzdF9leG4gOiAncyBQYWNrZWQudCBsaXN0IC0+ICdzIHRcbiAgdmFsIHR5cGVfZXF1YWwgOiAoJ3MgdCwgJ3MgUGFja2VkLnQgTWFwLk0oVHlwZV9lcXVhbC5JZC5VaWQpLnQpIFR5cGVfZXF1YWwudFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbW9kdWxlIEtleSA6IEtleVxuXG4gIHR5cGUgJ2EgZGF0YVxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBlbXB0eSA6IHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIEtleS50IC0+ICdhIGRhdGEgLT4gdFxuICB2YWwgaXNfZW1wdHkgOiB0IC0+IGJvb2xcbiAgdmFsIHNldCA6IHQgLT4ga2V5OidhIEtleS50IC0+IGRhdGE6J2EgZGF0YSAtPiB0XG4gIHZhbCBtZW0gOiB0IC0+ICdhIEtleS50IC0+IGJvb2xcbiAgdmFsIG1lbV9ieV9pZCA6IHQgLT4gVHlwZV9lcXVhbC5JZC5VaWQudCAtPiBib29sXG4gIHZhbCBmaW5kIDogdCAtPiAnYSBLZXkudCAtPiAnYSBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiB0IC0+ICdhIEtleS50IC0+ICdhIGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4ga2V5OidhIEtleS50IC0+IGRhdGE6J2EgZGF0YSAtPiBbIGBPayBvZiB0IHwgYER1cGxpY2F0ZSBdXG4gIHZhbCBhZGRfZXhuIDogdCAtPiBrZXk6J2EgS2V5LnQgLT4gZGF0YTonYSBkYXRhIC0+IHRcbiAgdmFsIGNoYW5nZSA6IHQgLT4gJ2EgS2V5LnQgLT4gZjooJ2EgZGF0YSBvcHRpb24gLT4gJ2EgZGF0YSBvcHRpb24pIC0+IHRcbiAgdmFsIGNoYW5nZV9leG4gOiB0IC0+ICdhIEtleS50IC0+IGY6KCdhIGRhdGEgLT4gJ2EgZGF0YSkgLT4gdFxuICB2YWwgdXBkYXRlIDogdCAtPiAnYSBLZXkudCAtPiBmOignYSBkYXRhIG9wdGlvbiAtPiAnYSBkYXRhKSAtPiB0XG4gIHZhbCByZW1vdmUgOiB0IC0+ICdhIEtleS50IC0+IHRcbiAgdmFsIHJlbW92ZV9ieV9pZCA6IHQgLT4gVHlwZV9lcXVhbC5JZC5VaWQudCAtPiB0XG5cbiAgbW9kdWxlIFBhY2tlZCA6IHNpZ1xuICAgIHR5cGUgJ3MgdDEgPSBUIDogJ2EgS2V5LnQgKiAnYSBkYXRhIC0+ICdzIHQxXG4gICAgdHlwZSB0ID0gdW5pdCB0MVxuICBlbmRcblxuICAoKiogW3RvX2FsaXN0IHRdIHJldHVybnMgYWxsIHZhbHVlcyBpbiBbdF0sIGluIGluY3JlYXNpbmcgb3JkZXIgb2Yga2V5IHR5cGUtaWQgbmFtZS4gKilcbiAgdmFsIHRvX2FsaXN0IDogdCAtPiBQYWNrZWQudCBsaXN0XG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6IFBhY2tlZC50IGxpc3QgLT4gdFxuICB2YWwgdHlwZV9lcXVhbCA6ICh0LCBQYWNrZWQudCBNYXAuTShUeXBlX2VxdWFsLklkLlVpZCkudCkgVHlwZV9lcXVhbC50XG5lbmRcblxubW9kdWxlIHR5cGUgVW5pdl9tYXAgPSBzaWdcbiAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgbW9kdWxlIHR5cGUgUzEgPSBTMVxuICBtb2R1bGUgdHlwZSBLZXkgPSBLZXlcbiAgbW9kdWxlIHR5cGUgRGF0YSA9IERhdGFcblxuICBtb2R1bGUgVHlwZV9pZF9rZXkgOiBLZXkgd2l0aCB0eXBlICdhIHQgPSAnYSBUeXBlX2VxdWFsLklkLnRcbiAgaW5jbHVkZSBTIHdpdGggdHlwZSAnYSBkYXRhID0gJ2EgYW5kIG1vZHVsZSBLZXkgOj0gVHlwZV9pZF9rZXlcblxuICAoKiogVGhpcyBiaW5kaW5nIGlzIGNvbnZlbmllbnQgYmVjYXVzZSBleGlzdGluZyBjYWxsIHNpdGVzIG9mdGVuIHJlZmVyIHRvXG4gICAgICBbVW5pdl9tYXAuS2V5LmNyZWF0ZV0uXG4gICopXG4gIG1vZHVsZSBLZXkgPSBUeXBlX2VxdWFsLklkXG5cbiAgbW9kdWxlIE1ha2UgKEtleSA6IEtleSkgKERhdGEgOiBEYXRhKSA6XG4gICAgUyB3aXRoIHR5cGUgJ2EgZGF0YSA9ICdhIERhdGEudCBhbmQgbW9kdWxlIEtleSA9IEtleVxuXG4gIG1vZHVsZSBNYWtlMSAoS2V5IDogS2V5KSAoRGF0YSA6IERhdGExKSA6XG4gICAgUzEgd2l0aCB0eXBlICgncywgJ2EpIGRhdGEgPSAoJ3MsICdhKSBEYXRhLnQgYW5kIG1vZHVsZSBLZXkgPSBLZXlcblxuICBtb2R1bGUgTWVyZ2UgKEtleSA6IEtleSkgKElucHV0MV9kYXRhIDogRGF0YSkgKElucHV0Ml9kYXRhIDogRGF0YSkgKE91dHB1dF9kYXRhIDogRGF0YSkgOiBzaWdcbiAgICB0eXBlIGYgPVxuICAgICAgeyBmIDpcbiAgICAgICAgICAnYS5cbiAgICAgICAgICAgIGtleTonYSBLZXkudFxuICAgICAgICAgIC0+IFsgYExlZnQgb2YgJ2EgSW5wdXQxX2RhdGEudFxuICAgICAgICAgICAgIHwgYFJpZ2h0IG9mICdhIElucHV0Ml9kYXRhLnRcbiAgICAgICAgICAgICB8IGBCb3RoIG9mICdhIElucHV0MV9kYXRhLnQgKiAnYSBJbnB1dDJfZGF0YS50XG4gICAgICAgICAgICAgXVxuICAgICAgICAgIC0+ICdhIE91dHB1dF9kYXRhLnQgb3B0aW9uXG4gICAgICB9XG5cbiAgICAoKiogVGhlIGFuYWxvZ3VlIG9mIHRoZSBub3JtYWwgW01hcC5tZXJnZV0gZnVuY3Rpb24uICAqKVxuICAgIHZhbCBtZXJnZVxuICAgICAgOiAgTWFrZShLZXkpKElucHV0MV9kYXRhKS50XG4gICAgICAtPiBNYWtlKEtleSkoSW5wdXQyX2RhdGEpLnRcbiAgICAgIC0+IGY6ZlxuICAgICAgLT4gTWFrZShLZXkpKE91dHB1dF9kYXRhKS50XG4gIGVuZFxuXG4gIG1vZHVsZSBNZXJnZTFcbiAgICAgIChLZXkgOiBLZXkpXG4gICAgICAoSW5wdXQxX2RhdGEgOiBEYXRhMSlcbiAgICAgIChJbnB1dDJfZGF0YSA6IERhdGExKVxuICAgICAgKE91dHB1dF9kYXRhIDogRGF0YTEpIDogc2lnXG4gICAgdHlwZSAoJ3MxLCAnczIsICdzMykgZiA9XG4gICAgICB7IGYgOlxuICAgICAgICAgICdhLlxuICAgICAgICAgICAga2V5OidhIEtleS50XG4gICAgICAgICAgLT4gWyBgTGVmdCBvZiAoJ3MxLCAnYSkgSW5wdXQxX2RhdGEudFxuICAgICAgICAgICAgIHwgYFJpZ2h0IG9mICgnczIsICdhKSBJbnB1dDJfZGF0YS50XG4gICAgICAgICAgICAgfCBgQm90aCBvZiAoJ3MxLCAnYSkgSW5wdXQxX2RhdGEudCAqICgnczIsICdhKSBJbnB1dDJfZGF0YS50XG4gICAgICAgICAgICAgXVxuICAgICAgICAgIC0+ICgnczMsICdhKSBPdXRwdXRfZGF0YS50IG9wdGlvblxuICAgICAgfVxuXG4gICAgKCoqIFRoZSBhbmFsb2d1ZSBvZiB0aGUgbm9ybWFsIFtNYXAubWVyZ2VdIGZ1bmN0aW9uLiAgKilcbiAgICB2YWwgbWVyZ2VcbiAgICAgIDogICdzMSBNYWtlMShLZXkpKElucHV0MV9kYXRhKS50XG4gICAgICAtPiAnczIgTWFrZTEoS2V5KShJbnB1dDJfZGF0YSkudFxuICAgICAgLT4gZjooJ3MxLCAnczIsICdzMykgZlxuICAgICAgLT4gJ3MzIE1ha2UxKEtleSkoT3V0cHV0X2RhdGEpLnRcbiAgZW5kXG5cbiAgKCoqIGtleXMgd2l0aCBhc3NvY2lhdGVkIGRlZmF1bHQgdmFsdWVzLCBzbyB0aGF0IFtmaW5kXSBpcyBubyBsb25nZXIgcGFydGlhbCAqKVxuICBtb2R1bGUgV2l0aF9kZWZhdWx0IDogc2lnXG4gICAgbW9kdWxlIEtleSA6IHNpZ1xuICAgICAgdHlwZSAnYSB0XG5cbiAgICAgIHZhbCBjcmVhdGUgOiBkZWZhdWx0OidhIC0+IG5hbWU6c3RyaW5nIC0+ICgnYSAtPiBTZXhwLnQpIC0+ICdhIHRcbiAgICAgIHZhbCBpZCA6ICdhIHQgLT4gJ2EgVHlwZV9lcXVhbC5JZC50XG4gICAgZW5kXG5cbiAgICB2YWwgc2V0IDogdCAtPiBrZXk6J2EgS2V5LnQgLT4gZGF0YTonYSAtPiB0XG4gICAgdmFsIGZpbmQgOiB0IC0+ICdhIEtleS50IC0+ICdhXG4gICAgdmFsIGNoYW5nZSA6IHQgLT4gJ2EgS2V5LnQgLT4gZjooJ2EgLT4gJ2EpIC0+IHRcbiAgZW5kXG5cbiAgKCoqIGtleXMgdGhhdCBtYXAgdG8gYW4gYWNjdW11bGF0b3IgdmFsdWUgd2l0aCBhbiBhc3NvY2lhdGVkIGZvbGQgb3BlcmF0aW9uICopXG4gIG1vZHVsZSBXaXRoX2ZvbGQgOiBzaWdcbiAgICBtb2R1bGUgS2V5IDogc2lnXG4gICAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgICAgdmFsIGNyZWF0ZVxuICAgICAgICA6ICBpbml0OidiXG4gICAgICAgIC0+IGY6KCdiIC0+ICdhIC0+ICdiKVxuICAgICAgICAtPiBuYW1lOnN0cmluZ1xuICAgICAgICAtPiAoJ2IgLT4gU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdiKSB0XG5cbiAgICAgIHZhbCBpZCA6ICgnYSwgJ2IpIHQgLT4gJ2IgVHlwZV9lcXVhbC5JZC50XG4gICAgZW5kXG5cbiAgICAoKiogcmVzZXQgdGhlIGFjY3VtdWxhdG9yICopXG4gICAgdmFsIHNldCA6IHQgLT4ga2V5OignYSwgJ2IpIEtleS50IC0+IGRhdGE6J2IgLT4gdFxuXG4gICAgKCoqIHRoZSBjdXJyZW50IGFjY3VtdWxhdG9yICopXG4gICAgdmFsIGZpbmQgOiB0IC0+ICgnYSwgJ2IpIEtleS50IC0+ICdiXG5cbiAgICAoKiogZm9sZCB2YWx1ZSBpbnRvIGFjY3VtdWxhdG9yICopXG4gICAgdmFsIGFkZCA6IHQgLT4ga2V5OignYSwgJ2IpIEtleS50IC0+IGRhdGE6J2EgLT4gdFxuXG4gICAgKCoqIGFjY3VtdWxhdG9yIHVwZGF0ZSAqKVxuICAgIHZhbCBjaGFuZ2UgOiB0IC0+ICgnYSwgJ2IpIEtleS50IC0+IGY6KCdiIC0+ICdiKSAtPiB0XG4gIGVuZFxuXG4gICgqKiBsaXN0LWFjY3VtdWxhdGluZyBrZXlzIHdpdGggYSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBlbXB0eSBsaXN0ICopXG4gIG1vZHVsZSBNdWx0aSA6IHNpZ1xuICAgIG1vZHVsZSBLZXkgOiBzaWdcbiAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICB2YWwgY3JlYXRlIDogbmFtZTpzdHJpbmcgLT4gKCdhIC0+IFNleHAudCkgLT4gJ2EgdFxuICAgICAgdmFsIGlkIDogJ2EgdCAtPiAnYSBsaXN0IFR5cGVfZXF1YWwuSWQudFxuICAgIGVuZFxuXG4gICAgdmFsIHNldCA6IHQgLT4ga2V5OidhIEtleS50IC0+IGRhdGE6J2EgbGlzdCAtPiB0XG4gICAgdmFsIGZpbmQgOiB0IC0+ICdhIEtleS50IC0+ICdhIGxpc3RcbiAgICB2YWwgYWRkIDogdCAtPiBrZXk6J2EgS2V5LnQgLT4gZGF0YTonYSAtPiB0XG4gICAgdmFsIGNoYW5nZSA6IHQgLT4gJ2EgS2V5LnQgLT4gZjooJ2EgbGlzdCAtPiAnYSBsaXN0KSAtPiB0XG4gIGVuZFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdl9tYXAuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9Vbml2X21hcCIsImNzdCIsImNzdF91bml2X21hcCIsImNzdF91bml2X21hcF9zcmNfdW5pdl9tYXBfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIkJhc2VfTGlzdCIsIkJhc2VfT3B0aW9uIiwiQmFzZV9UeXBlX2VxdWFsIiwiQmFzZV9NYXAiLCJCYXNlIiwiQmFzZV9QcmludGYiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfSW52YXJpYW50IiwiQmFzZV9TdHJpbmciLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiUHB4X21vZHVsZV90aW1lcl9ydW50aW1lIiwiUHB4X2JlbmNoX2xpYl9CZW5jaG1hcmtfYWNjdW11IiwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yIiwiY3N0X0tleV90eXBlX2lkX211c3Rfbm90X3Byb3ZpIiwiTWFrZTEiLCJLZXkiLCJEYXRhIiwic2V4cF9vZl90Iiwic2V4cF9vZl90eXBlX2lkIiwidHlwZV9pZCIsInhfMDAzIiwidHlwZV9pZDEiLCJ0eXBlX2lkMiIsInBhcmFtIiwibmFtZV9vZl9rZXkiLCJrZXkiLCJ1aWRfb2Zfa2V5Iiwic2V4cF9vZl9hIiwiZGF0YSIsInR5cGVfaWRfbmFtZSIsInR5cGVfaWRfdWlkIiwiY29tcGFyZSIsInQxIiwidDIiLCJjIiwiUGFja2VkIiwidG9fYWxpc3QiLCJ0IiwieF8wMDgiLCJwYWNrZWQiLCJhcmcxXzAwNSIsImFyZzBfMDA0IiwicmVzMF8wMDYiLCJyZXMxXzAwNyIsImludmFyaWFudCIsInhfMDA5Iiwic2V0IiwibWVtX2J5X2lkIiwiaWQiLCJtZW0iLCJyZW1vdmVfYnlfaWQiLCJyZW1vdmUiLCJlbXB0eSIsInNpbmdsZXRvbiIsImlzX2VtcHR5IiwiZmluZCIsIm1hdGNoIiwidmFsdWUiLCJmaW5kX2V4biIsImFkZCIsImFkZF9leG4iLCJjaGFuZ2VfZXhuIiwidXBkYXRlIiwiY2hhbmdlIiwib3JpZyIsIm5leHQiLCJvZl9hbGlzdF9leG4iLCJwIiwiTWFrZSIsIm9mX2FfMDExIiwib2ZfYV8wMTIiLCJ4XzAxMyIsIk0iLCJ4XzAxNCIsIlR5cGVfaWRfa2V5Iiwib2ZfYV8wMTciLCJ0eXBlX2VxdWFsIiwiY3JlYXRlIiwiZGVmYXVsdCIsIm5hbWUiLCJzZXhwX29mIiwiaW5pdCIsImFjYyIsInhzIiwieCIsIk11bHRpIiwiVW5pdl9tYXAiLCJPdXRwdXRfZGF0YSIsIm1lcmdlIiwibWVyZ2VfcmVzdWx0IiwicmlnaHRfZGF0YSIsInJpZ2h0X2tleSIsImxlZnRfZGF0YSIsImxlZnRfa2V5Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2NvcmUvdW5pdl9tYXAvdW5pdl9tYXAubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsK0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElB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QSxnQ0FBQUw7QUFBQUEsdUJBQUEsTUFBbUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUFBbUUsYUFBQTtBQUFBLHFCQUFBQyxZQUFBO0FBQUEscUJBQUFuQyxRQUFBO0FBQUEscUJBQUFvQyxZQUFBO0FBQUEscUJBQUFDLFdBQUE7QUFBQSwyQkFNeUM7QUFBQSwyQkFBdkI7QUFBQSxvQkFBL0I7QUFBQSxvQkFFRjtBQUFBLGtGQUFnRDtBQUFBO0FBQUEsbUJBUmpDO0FBQUEsd0JBQUFyQyxVQUFBLFVBQUE1QixPQUFBLFlBQUFILE1BQUE7QUFBQSxvQkFDVSxxQ0FPdUI7QUFBQTtBQUFBO0FBQUEsb0JBQUErQixVQVJqQztBQUFBLG9CQUFBNUIsU0FBQTtBQUFBLG9CQUFBSCxRQUFBO0FBQUEsbUJBRVcseUNBTXNCO0FBQUE7QUFBQTtBQUFBLFFEclF4RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0NvVkc7QUFBQTtBQUFBLEVEcFZIIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5pbmNsdWRlIFVuaXZfbWFwX2ludGZcbm1vZHVsZSBVaWQgPSBUeXBlX2VxdWFsLklkLlVpZFxuXG5tb2R1bGUgTWFrZTFcbiAgICAoS2V5IDogS2V5KSAoRGF0YSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgIHR5cGUgKCdzLCAnYSkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgICAgICAgICAgICAgICBlbmQpID1cbnN0cnVjdFxuICAoKiBBIHdyYXBwZXIgZm9yIHRoZSBbS2V5XSBtb2R1bGUgdGhhdCBhZGRzIGEgZHluYW1pYyBjaGVjayB0byBbS2V5LnR5cGVfaWRdLlxuXG4gICAgIEl0J3MgYSBidWcgaWYgdGhlIHVzZXItcHJvdmlkZWQgW0tleS50eXBlX2lkXSBnaXZlcyBkaWZmZXJlbnQgdHlwZSBpZHMgb24gZGlmZmVyZW50XG4gICAgIGNhbGxzLiAgQmVjYXVzZSB0aGlzIGNoZWNrIHNob3VsZCBiZSBmYWlybHkgY2hlYXAsIHdlIGRvIGl0IGR5bmFtaWNhbGx5IHRvIGF2b2lkXG4gICAgIHN1YnRsZXIgcHJvYmxlbXMgbGF0ZXIuXG5cbiAgICAgT2YgY291cnNlLCB3ZSdyZSBub3QgY2hlY2tpbmcgdHJ1bHkgcGF0aG9sb2dpY2FsIHRoaW5ncyBsaWtlIHRoZSBwcm92aWRlZFxuICAgICBbS2V5LnR5cGVfaWRdIG9ubHkgY2hhbmdlcyB0aGUgdmFsdWUgaXQgcmV0dXJucyBvbiBldmVyeSB0aGlyZCBjYWxsLi4uICopXG4gIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBLZXkudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgKCogdGVzdC1mcmllbmRseSBzZXhwIGNvbnZlcnNpb24gKilcbiAgICBsZXQgc2V4cF9vZl90eXBlX2lkIHR5cGVfaWQgPVxuICAgICAgWyVzZXhwXG4gICAgICAgIHsgbmFtZSA9IChUeXBlX2VxdWFsLklkLm5hbWUgdHlwZV9pZCA6IHN0cmluZylcbiAgICAgICAgOyB1aWQgPVxuICAgICAgICAgICAgKGlmIFBweF9pbmxpbmVfdGVzdF9saWIuYW1fcnVubmluZ1xuICAgICAgICAgICAgIHRoZW4gU2V4cC5BdG9tIFwiPHVpZD5cIlxuICAgICAgICAgICAgIGVsc2UgVHlwZV9lcXVhbC5JZC5VaWQuc2V4cF9vZl90IChUeXBlX2VxdWFsLklkLnVpZCB0eXBlX2lkKVxuICAgICAgICAgICAgICAgICAgOiBTZXhwLnQpXG4gICAgICAgIH1dXG4gICAgOztcblxuICAgIGxldCB0eXBlX2lkIGtleSA9XG4gICAgICBsZXQgdHlwZV9pZDEgPSBLZXkudHlwZV9pZCBrZXkgaW5cbiAgICAgIGxldCB0eXBlX2lkMiA9IEtleS50eXBlX2lkIGtleSBpblxuICAgICAgaWYgVHlwZV9lcXVhbC5JZC5zYW1lIHR5cGVfaWQxIHR5cGVfaWQyXG4gICAgICB0aGVuIHR5cGVfaWQxXG4gICAgICBlbHNlXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiW0tleS50eXBlX2lkXSBtdXN0IG5vdCBwcm92aWRlIGRpZmZlcmVudCB0eXBlIGlkcyB3aGVuIGNhbGxlZCBvbiB0aGUgc2FtZSBcXFxuICAgICAgICAgICAgIGlucHV0XCJcbiAgICAgICAgICAgICAgKGtleSA6IF8gS2V5LnQpXG4gICAgICAgICAgICAgICh0eXBlX2lkMSA6IHR5cGVfaWQpXG4gICAgICAgICAgICAgICh0eXBlX2lkMiA6IHR5cGVfaWQpXVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgKCdzLCAnYSkgZGF0YSA9ICgncywgJ2EpIERhdGEudFxuXG4gIGxldCBuYW1lX29mX2tleSBrZXkgPSBUeXBlX2VxdWFsLklkLm5hbWUgKEtleS50eXBlX2lkIGtleSlcbiAgbGV0IHVpZF9vZl9rZXkga2V5ID0gVHlwZV9lcXVhbC5JZC51aWQgKEtleS50eXBlX2lkIGtleSlcblxuICBtb2R1bGUgUGFja2VkID0gc3RydWN0XG4gICAgdHlwZSAncyB0ID0gVCA6ICdhIEtleS50ICogKCdzLCAnYSkgRGF0YS50IC0+ICdzIHRcblxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIChUIChrZXksIGRhdGEpKSA9XG4gICAgICBEYXRhLnNleHBfb2ZfdCBzZXhwX29mX2EgKFR5cGVfZXF1YWwuSWQudG9fc2V4cCAoS2V5LnR5cGVfaWQga2V5KSkgZGF0YVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZV9pZF9uYW1lIChUIChrZXksIF8pKSA9IG5hbWVfb2Zfa2V5IGtleVxuICAgIGxldCB0eXBlX2lkX3VpZCAoVCAoa2V5LCBfKSkgPSB1aWRfb2Zfa2V5IGtleVxuXG4gICAgbGV0IGNvbXBhcmUgdDEgdDIgPVxuICAgICAgbGV0IGMgPSBTdHJpbmcuY29tcGFyZSAodHlwZV9pZF9uYW1lIHQxKSAodHlwZV9pZF9uYW1lIHQyKSBpblxuICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIFVpZC5jb21wYXJlICh0eXBlX2lkX3VpZCB0MSkgKHR5cGVfaWRfdWlkIHQyKVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgJ3MgdCA9ICdzIFBhY2tlZC50IE1hcC5NKFVpZCkudFxuXG4gIGxldCB0b19hbGlzdCB0ID0gTWFwLmRhdGEgdCB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6UGFja2VkLmNvbXBhcmVcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICB0b19hbGlzdCB0XG4gICAgfD4gTGlzdC5tYXAgfmY6KGZ1biBwYWNrZWQgLT4gUGFja2VkLnR5cGVfaWRfbmFtZSBwYWNrZWQsIHBhY2tlZClcbiAgICB8PiBbJXNleHBfb2Y6IChzdHJpbmcgKiBhIFBhY2tlZC50KSBsaXN0XVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgKHQgOiBfIHQpID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgICAgTWFwLml0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGFzc2VydCAoVWlkLmVxdWFsIGtleSAoUGFja2VkLnR5cGVfaWRfdWlkIGRhdGEpKSkpXG4gIDs7XG5cbiAgbGV0IHNldCB0IH5rZXkgfmRhdGEgPSBNYXAuc2V0IHQgfmtleToodWlkX29mX2tleSBrZXkpIH5kYXRhOihQYWNrZWQuVCAoa2V5LCBkYXRhKSlcbiAgbGV0IG1lbV9ieV9pZCB0IGlkID0gTWFwLm1lbSB0IGlkXG4gIGxldCBtZW0gdCBrZXkgPSBtZW1fYnlfaWQgdCAodWlkX29mX2tleSBrZXkpXG4gIGxldCByZW1vdmVfYnlfaWQgdCBpZCA9IE1hcC5yZW1vdmUgdCBpZFxuICBsZXQgcmVtb3ZlIHQga2V5ID0gcmVtb3ZlX2J5X2lkIHQgKHVpZF9vZl9rZXkga2V5KVxuICBsZXQgZW1wdHkgPSBNYXAuZW1wdHkgKG1vZHVsZSBVaWQpXG5cbiAgbGV0IHNpbmdsZXRvbiBrZXkgZGF0YSA9XG4gICAgTWFwLnNpbmdsZXRvbiAobW9kdWxlIFVpZCkgKHVpZF9vZl9rZXkga2V5KSAoUGFja2VkLlQgKGtleSwgZGF0YSkpXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5ID0gTWFwLmlzX2VtcHR5XG5cbiAgbGV0IGZpbmQgKHR5cGUgYikgdCAoa2V5IDogYiBLZXkudCkgPVxuICAgIG1hdGNoIE1hcC5maW5kIHQgKHVpZF9vZl9rZXkga2V5KSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKFBhY2tlZC5UIChrZXknLCB2YWx1ZSkpIC0+XG4gICAgICAoKiBjYW5ub3QgcmFpc2UgLS0gc2VlIFtpbnZhcmlhbnRdICopXG4gICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgVHlwZV9lcXVhbC5JZC5zYW1lX3dpdG5lc3NfZXhuIChLZXkudHlwZV9pZCBrZXkpIChLZXkudHlwZV9pZCBrZXknKVxuICAgICAgaW5cbiAgICAgIFNvbWUgKHZhbHVlIDogKF8sIGIpIERhdGEudClcbiAgOztcblxuICBsZXQgZmluZF9leG4gdCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICAgIHwgU29tZSBkYXRhIC0+IGRhdGFcbiAgICB8IE5vbmUgLT4gUHJpbnRmLmZhaWx3aXRoZiBcIlVuaXZfbWFwLmZpbmRfZXhuIG9uIHVua25vd24ga2V5ICVzXCIgKG5hbWVfb2Zfa2V5IGtleSkgKClcbiAgOztcblxuICBsZXQgYWRkIHQgfmtleSB+ZGF0YSA9IGlmIG1lbSB0IGtleSB0aGVuIGBEdXBsaWNhdGUgZWxzZSBgT2sgKHNldCB0IH5rZXkgfmRhdGEpXG5cbiAgbGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgICBtYXRjaCBhZGQgdCB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IGBPayB0IC0+IHRcbiAgICB8IGBEdXBsaWNhdGUgLT5cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCJVbml2X21hcC5hZGRfZXhuIG9uIGV4aXN0aW5nIGtleSAlc1wiIChuYW1lX29mX2tleSBrZXkpICgpXG4gIDs7XG5cbiAgbGV0IGNoYW5nZV9leG4gdCBrZXkgfmY6dXBkYXRlID1cbiAgICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgICB8IFNvbWUgZGF0YSAtPiBzZXQgdCB+a2V5IH5kYXRhOih1cGRhdGUgZGF0YSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCJVbml2X21hcC5jaGFuZ2VfZXhuIG9uIHVua25vd24ga2V5ICVzXCIgKG5hbWVfb2Zfa2V5IGtleSkgKClcbiAgOztcblxuICBsZXQgY2hhbmdlIHQga2V5IH5mOnVwZGF0ZSA9XG4gICAgbGV0IG9yaWcgPSBmaW5kIHQga2V5IGluXG4gICAgbGV0IG5leHQgPSB1cGRhdGUgb3JpZyBpblxuICAgIG1hdGNoIG5leHQgd2l0aFxuICAgIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXkgfmRhdGFcbiAgICB8IE5vbmUgLT4gaWYgT3B0aW9uLmlzX25vbmUgb3JpZyB0aGVuIHQgZWxzZSByZW1vdmUgdCBrZXlcbiAgOztcblxuICBsZXQgdXBkYXRlIHQga2V5IH5mID0gY2hhbmdlIHQga2V5IH5mOihmdW4gZGF0YSAtPiBTb21lIChmIGRhdGEpKVxuXG4gIGxldCBvZl9hbGlzdF9leG4gdCA9XG4gICAgTWFwLm9mX2FsaXN0X2V4biAobW9kdWxlIFVpZCkgKExpc3QubWFwIHQgfmY6KGZ1biBwIC0+IFBhY2tlZC50eXBlX2lkX3VpZCBwLCBwKSlcbiAgOztcblxuICBsZXQgdHlwZV9lcXVhbCA6ICgncyB0LCAncyBQYWNrZWQudCBNYXAuTShUeXBlX2VxdWFsLklkLlVpZCkudCkgVHlwZV9lcXVhbC50ID0gVFxuZW5kXG5cbm1vZHVsZSBNYWtlXG4gICAgKEtleSA6IEtleSkgKERhdGEgOiBzaWdcbiAgICAgICAgICAgICAgICAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICAgICAgICAgICAgICAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIE0gPVxuICAgIE1ha2UxXG4gICAgICAoS2V5KVxuICAgICAgKHN0cnVjdFxuICAgICAgICB0eXBlIChfLCAnYSkgdCA9ICdhIERhdGEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgICAgZW5kKVxuXG4gIHR5cGUgdCA9IHVuaXQgTS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbW9kdWxlIEtleSA9IEtleVxuXG4gIHR5cGUgJ2EgZGF0YSA9ICdhIERhdGEudFxuXG4gIGxldCBpbnZhcmlhbnQgPSBNLmludmFyaWFudFxuICBsZXQgZW1wdHkgPSBNLmVtcHR5XG4gIGxldCBzaW5nbGV0b24gPSBNLnNpbmdsZXRvblxuICBsZXQgaXNfZW1wdHkgPSBNLmlzX2VtcHR5XG4gIGxldCBzZXQgPSBNLnNldFxuICBsZXQgbWVtID0gTS5tZW1cbiAgbGV0IG1lbV9ieV9pZCA9IE0ubWVtX2J5X2lkXG4gIGxldCBmaW5kID0gTS5maW5kXG4gIGxldCBmaW5kX2V4biA9IE0uZmluZF9leG5cbiAgbGV0IGFkZCA9IE0uYWRkXG4gIGxldCBhZGRfZXhuID0gTS5hZGRfZXhuXG4gIGxldCBjaGFuZ2UgPSBNLmNoYW5nZVxuICBsZXQgY2hhbmdlX2V4biA9IE0uY2hhbmdlX2V4blxuICBsZXQgdXBkYXRlID0gTS51cGRhdGVcbiAgbGV0IHJlbW92ZSA9IE0ucmVtb3ZlXG4gIGxldCByZW1vdmVfYnlfaWQgPSBNLnJlbW92ZV9ieV9pZFxuXG4gIG1vZHVsZSBQYWNrZWQgPSBzdHJ1Y3RcbiAgICB0eXBlICdzIHQxID0gJ3MgTS5QYWNrZWQudCA9IFQgOiAnYSBLZXkudCAqICdhIERhdGEudCAtPiAncyB0MVxuICAgIHR5cGUgdCA9IHVuaXQgdDFcbiAgZW5kXG5cbiAgbGV0IHRvX2FsaXN0ID0gTS50b19hbGlzdFxuICBsZXQgb2ZfYWxpc3RfZXhuID0gTS5vZl9hbGlzdF9leG5cbiAgbGV0IHR5cGVfZXF1YWwgOiAodCwgUGFja2VkLnQgTWFwLk0oVHlwZV9lcXVhbC5JZC5VaWQpLnQpIFR5cGVfZXF1YWwudCA9IFRcbmVuZFxuXG5tb2R1bGUgTWVyZ2UgKEtleSA6IEtleSkgKElucHV0MV9kYXRhIDogRGF0YSkgKElucHV0Ml9kYXRhIDogRGF0YSkgKE91dHB1dF9kYXRhIDogRGF0YSkgPVxuc3RydWN0XG4gIHR5cGUgZiA9XG4gICAgeyBmIDpcbiAgICAgICAgJ2EuXG4gICAgICAgICAga2V5OidhIEtleS50XG4gICAgICAgIC0+IFsgYExlZnQgb2YgJ2EgSW5wdXQxX2RhdGEudFxuICAgICAgICAgICB8IGBSaWdodCBvZiAnYSBJbnB1dDJfZGF0YS50XG4gICAgICAgICAgIHwgYEJvdGggb2YgJ2EgSW5wdXQxX2RhdGEudCAqICdhIElucHV0Ml9kYXRhLnRcbiAgICAgICAgICAgXVxuICAgICAgICAtPiAnYSBPdXRwdXRfZGF0YS50IG9wdGlvblxuICAgIH1cblxuICBtb2R1bGUgT3V0cHV0ID0gTWFrZSAoS2V5KSAoT3V0cHV0X2RhdGEpXG5cbiAgbGV0IG1lcmdlICh0MSA6IE1ha2UoS2V5KShJbnB1dDFfZGF0YSkudCkgKHQyIDogTWFrZShLZXkpKElucHV0Ml9kYXRhKS50KSB+Zjp7IGYgfVxuICAgIDogTWFrZShLZXkpKE91dHB1dF9kYXRhKS50XG4gICAgPVxuICAgIGxldCBmIH5rZXkgbWVyZ2VfcmVzdWx0ID1cbiAgICAgIE9wdGlvbi5tYXAgKGYgfmtleSBtZXJnZV9yZXN1bHQpIH5mOihmdW4gZGF0YSAtPiBPdXRwdXQuTS5QYWNrZWQuVCAoa2V5LCBkYXRhKSlcbiAgICBpblxuICAgIE1hcC5tZXJnZSB0MSB0MiB+ZjooZnVuIH5rZXk6XyAtPiBmdW5jdGlvblxuICAgICAgfCBgTGVmdCAoVCAoa2V5LCBkYXRhKSkgLT4gZiB+a2V5IChgTGVmdCBkYXRhKVxuICAgICAgfCBgUmlnaHQgKFQgKGtleSwgZGF0YSkpIC0+IGYgfmtleSAoYFJpZ2h0IGRhdGEpXG4gICAgICB8IGBCb3RoIChUIChsZWZ0X2tleSwgbGVmdF9kYXRhKSwgVCAocmlnaHRfa2V5LCByaWdodF9kYXRhKSkgLT5cbiAgICAgICAgKCogQ2FuJ3QgcmFpc2UgZHVlIHRvIHRoZSBpbnZhcmlhbnQgKilcbiAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5JZC5zYW1lX3dpdG5lc3NfZXhuIChLZXkudHlwZV9pZCBsZWZ0X2tleSkgKEtleS50eXBlX2lkIHJpZ2h0X2tleSlcbiAgICAgICAgaW5cbiAgICAgICAgZiB+a2V5OmxlZnRfa2V5IChgQm90aCAobGVmdF9kYXRhLCByaWdodF9kYXRhKSkpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1lcmdlMVxuICAgIChLZXkgOiBLZXkpXG4gICAgKElucHV0MV9kYXRhIDogRGF0YTEpXG4gICAgKElucHV0Ml9kYXRhIDogRGF0YTEpXG4gICAgKE91dHB1dF9kYXRhIDogRGF0YTEpID1cbnN0cnVjdFxuICB0eXBlICgnczEsICdzMiwgJ3MzKSBmID1cbiAgICB7IGYgOlxuICAgICAgICAnYS5cbiAgICAgICAgICBrZXk6J2EgS2V5LnRcbiAgICAgICAgLT4gWyBgTGVmdCBvZiAoJ3MxLCAnYSkgSW5wdXQxX2RhdGEudFxuICAgICAgICAgICB8IGBSaWdodCBvZiAoJ3MyLCAnYSkgSW5wdXQyX2RhdGEudFxuICAgICAgICAgICB8IGBCb3RoIG9mICgnczEsICdhKSBJbnB1dDFfZGF0YS50ICogKCdzMiwgJ2EpIElucHV0Ml9kYXRhLnRcbiAgICAgICAgICAgXVxuICAgICAgICAtPiAoJ3MzLCAnYSkgT3V0cHV0X2RhdGEudCBvcHRpb25cbiAgICB9XG5cbiAgbW9kdWxlIE91dHB1dCA9IE1ha2UxIChLZXkpIChPdXRwdXRfZGF0YSlcblxuICBsZXQgbWVyZ2VcbiAgICAgICAgKHR5cGUgczEgczIpXG4gICAgICAgICh0MSA6IHMxIE1ha2UxKEtleSkoSW5wdXQxX2RhdGEpLnQpXG4gICAgICAgICh0MiA6IHMyIE1ha2UxKEtleSkoSW5wdXQyX2RhdGEpLnQpXG4gICAgICAgIH5mOnsgZiB9XG4gICAgPVxuICAgIGxldCBmIH5rZXkgbWVyZ2VfcmVzdWx0ID1cbiAgICAgIE9wdGlvbi5tYXAgKGYgfmtleSBtZXJnZV9yZXN1bHQpIH5mOihmdW4gZGF0YSAtPiBPdXRwdXQuUGFja2VkLlQgKGtleSwgZGF0YSkpXG4gICAgaW5cbiAgICBNYXAubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5Ol8gLT4gZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgKFQgKGtleSwgZGF0YSkpIC0+IGYgfmtleSAoYExlZnQgZGF0YSlcbiAgICAgIHwgYFJpZ2h0IChUIChrZXksIGRhdGEpKSAtPiBmIH5rZXkgKGBSaWdodCBkYXRhKVxuICAgICAgfCBgQm90aCAoVCAobGVmdF9rZXksIGxlZnRfZGF0YSksIFQgKHJpZ2h0X2tleSwgcmlnaHRfZGF0YSkpIC0+XG4gICAgICAgICgqIENhbid0IHJhaXNlIGR1ZSB0byB0aGUgaW52YXJpYW50ICopXG4gICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biAoS2V5LnR5cGVfaWQgbGVmdF9rZXkpIChLZXkudHlwZV9pZCByaWdodF9rZXkpXG4gICAgICAgIGluXG4gICAgICAgIGYgfmtleTpsZWZ0X2tleSAoYEJvdGggKGxlZnRfZGF0YSwgcmlnaHRfZGF0YSkpKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBUeXBlX2lkX2tleSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBUeXBlX2VxdWFsLklkLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgdHlwZV9pZCA9IEZuLmlkXG5lbmRcblxuaW5jbHVkZSAoXG4gIE1ha2VcbiAgICAoVHlwZV9pZF9rZXkpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmQpIDpcbiAgICBTIHdpdGggdHlwZSAnYSBkYXRhID0gJ2EgYW5kIG1vZHVsZSBLZXkgOj0gVHlwZV9pZF9rZXkpXG5cbm1vZHVsZSBLZXkgPSBUeXBlX2VxdWFsLklkXG5cbm1vZHVsZSBXaXRoX2RlZmF1bHQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEtleSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IGtleSA6ICdhIFR5cGVfZXF1YWwuSWQudFxuICAgICAgOyBkZWZhdWx0IDogJ2FcbiAgICAgIH1cblxuICAgIGxldCBjcmVhdGUgfmRlZmF1bHQgfm5hbWUgc2V4cF9vZiA9XG4gICAgICB7IGRlZmF1bHQ7IGtleSA9IFR5cGVfZXF1YWwuSWQuY3JlYXRlIH5uYW1lIHNleHBfb2YgfVxuICAgIDs7XG5cbiAgICBsZXQgaWQgdCA9IHQua2V5XG4gIGVuZFxuXG4gIGxldCBmaW5kIHQgeyBLZXkua2V5OyBkZWZhdWx0IH0gPSBPcHRpb24udmFsdWUgfmRlZmF1bHQgKGZpbmQgdCBrZXkpXG4gIGxldCBzZXQgdCB+a2V5OnsgS2V5LmtleTsgZGVmYXVsdCA9IF8gfSB+ZGF0YSA9IHNldCB0IH5rZXkgfmRhdGFcbiAgbGV0IGNoYW5nZSB0IGtleSB+Zjp1cGRhdGUgPSBzZXQgdCB+a2V5IH5kYXRhOih1cGRhdGUgKGZpbmQgdCBrZXkpKVxuZW5kXG5cbm1vZHVsZSBXaXRoX2ZvbGQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEtleSA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgICB7IGtleSA6ICdiIFdpdGhfZGVmYXVsdC5LZXkudFxuICAgICAgOyBmIDogJ2IgLT4gJ2EgLT4gJ2JcbiAgICAgIH1cblxuICAgIGxldCBjcmVhdGUgfmluaXQgfmYgfm5hbWUgc2V4cF9vZiA9XG4gICAgICB7IGY7IGtleSA9IFdpdGhfZGVmYXVsdC5LZXkuY3JlYXRlIH5kZWZhdWx0OmluaXQgfm5hbWUgc2V4cF9vZiB9XG4gICAgOztcblxuICAgIGxldCBpZCB0ID0gV2l0aF9kZWZhdWx0LktleS5pZCB0LmtleVxuICBlbmRcblxuICBsZXQgZmluZCB0IHsgS2V5LmtleTsgZiA9IF8gfSA9IFdpdGhfZGVmYXVsdC5maW5kIHQga2V5XG4gIGxldCBzZXQgdCB+a2V5OnsgS2V5LmtleTsgZiA9IF8gfSB+ZGF0YSA9IFdpdGhfZGVmYXVsdC5zZXQgdCB+a2V5IH5kYXRhXG4gIGxldCBjaGFuZ2UgdCB7IEtleS5rZXk7IGYgPSBfIH0gfmY6dXBkYXRlID0gV2l0aF9kZWZhdWx0LmNoYW5nZSB0IGtleSB+Zjp1cGRhdGVcblxuICBsZXQgYWRkIHQgfmtleTp7IEtleS5rZXk7IGYgfSB+ZGF0YSA9XG4gICAgV2l0aF9kZWZhdWx0LmNoYW5nZSB0IGtleSB+ZjooZnVuIGFjYyAtPiBmIGFjYyBkYXRhKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNdWx0aSA9IHN0cnVjdFxuICBvcGVuIFdpdGhfZm9sZFxuXG4gIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAoJ2EsICdhIGxpc3QpIEtleS50XG5cbiAgICBsZXQgY3JlYXRlIH5uYW1lIHNleHBfb2YgPVxuICAgICAgS2V5LmNyZWF0ZSB+aW5pdDpbXSB+ZjooZnVuIHhzIHggLT4geCA6OiB4cykgfm5hbWUgKExpc3Quc2V4cF9vZl90IHNleHBfb2YpXG4gICAgOztcblxuICAgIGxldCBpZCA9IFdpdGhfZm9sZC5LZXkuaWRcbiAgZW5kXG5cbiAgbGV0IHNldCA9IHNldFxuICBsZXQgZmluZCA9IGZpbmRcbiAgbGV0IGFkZCA9IGFkZFxuICBsZXQgY2hhbmdlID0gY2hhbmdlXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fV19
