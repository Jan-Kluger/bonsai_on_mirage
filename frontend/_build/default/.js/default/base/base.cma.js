// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Base__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0];
   runtime.caml_register_global(0, Base, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Bool0 = [0];
   runtime.caml_register_global(0, Base_Bool0, "Base__Bool0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Globalize
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_dup = runtime.caml_obj_dup;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function globalize_bool(b){return b;}
   function globalize_char(c){return c;}
   function globalize_unit(u){return u;}
   function globalize_array(param, a){return a.slice();}
   function globalize_list(f, param){
    if(! param) return 0;
    var xs = param[2], x = param[1], _b_ = globalize_list(f, xs);
    return [0, caml_call1(f, x), _b_];
   }
   function globalize_option(f, param){
    if(! param) return 0;
    var x = param[1];
    return [0, caml_call1(f, x)];
   }
   function globalize_result(globalize_a, globalize_b, t){
    if(0 === t[0]){var a = t[1]; return [0, caml_call1(globalize_a, a)];}
    var b = t[1];
    return [1, caml_call1(globalize_b, b)];
   }
   function globalize_ref(param, r){return [0, r[1]];}
   var
    Base_Globalize =
      [0,
       globalize_bool,
       globalize_char,
       caml_obj_dup,
       function(_a_){return _a_;},
       caml_obj_dup,
       caml_obj_dup,
       caml_obj_dup,
       caml_obj_dup,
       caml_obj_dup,
       globalize_unit,
       globalize_array,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref];
   runtime.caml_register_global(0, Base_Globalize, "Base__Globalize");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Base__Bool0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_compare = runtime.caml_compare;
   function descending(x, y){return caml_compare(y, x);}
   function max(x, y){
    return runtime.caml_csel_value(runtime.caml_greaterequal(x, y), x, y);
   }
   function min(x, y){
    return runtime.caml_csel_value(runtime.caml_lessequal(x, y), x, y);
   }
   var Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(0, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Bool0, Base__Poly0, Shadow_stdlib, Stdlib, Stdlib__MoreLabels, Stdlib__StdLabels, Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Stdlib = global_data.Stdlib,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    invalid_arg = Stdlib[1],
    failwith = Stdlib[2],
    Exit$0 = Stdlib[3],
    Match_failure = Stdlib[4],
    Assert_failure = Stdlib[5],
    Invalid_argument = Stdlib[6],
    Failure = Stdlib[7],
    Not_found$0 = Stdlib[8],
    Out_of_memory = Stdlib[9],
    Stack_overflow = Stdlib[10],
    Sys_error = Stdlib[11],
    End_of_file = Stdlib[12],
    Division_by_zero = Stdlib[13],
    Sys_blocked_io = Stdlib[14],
    Undefined_recursive_module = Stdlib[15],
    min = Stdlib[16],
    max = Stdlib[17],
    abs = Stdlib[18],
    max_int$0 = Stdlib[19],
    min_int$0 = Stdlib[20],
    lnot = Stdlib[21],
    infinity$0 = Stdlib[22],
    neg_infinity$0 = Stdlib[23],
    nan$0 = Stdlib[24],
    max_float$0 = Stdlib[25],
    min_float$0 = Stdlib[26],
    epsilon_float$0 = Stdlib[27],
    symbol_concat = Stdlib[28],
    char_of_int$0 = Stdlib[29],
    string_of_bool$0 = Stdlib[30],
    bool_of_string_opt$0 = Stdlib[31],
    bool_of_string$0 = Stdlib[32],
    string_of_int$0 = Stdlib[33],
    int_of_string_opt$0 = Stdlib[34],
    string_of_float$0 = Stdlib[35],
    float_of_string_opt$0 = Stdlib[36],
    symbol$0 = Stdlib[37],
    stdin$0 = Stdlib[38],
    stdout$0 = Stdlib[39],
    stderr$0 = Stdlib[40],
    print_char$0 = Stdlib[41],
    print_string$0 = Stdlib[42],
    print_bytes$0 = Stdlib[43],
    print_int$0 = Stdlib[44],
    print_float$0 = Stdlib[45],
    print_endline$0 = Stdlib[46],
    print_newline$0 = Stdlib[47],
    prerr_char$0 = Stdlib[48],
    prerr_string$0 = Stdlib[49],
    prerr_bytes$0 = Stdlib[50],
    prerr_int$0 = Stdlib[51],
    prerr_float$0 = Stdlib[52],
    prerr_endline$0 = Stdlib[53],
    prerr_newline$0 = Stdlib[54],
    read_line$0 = Stdlib[55],
    read_int_opt$0 = Stdlib[56],
    read_int$0 = Stdlib[57],
    read_float_opt$0 = Stdlib[58],
    read_float$0 = Stdlib[59],
    open_out$0 = Stdlib[60],
    open_out_bin$0 = Stdlib[61],
    open_out_gen$0 = Stdlib[62],
    flush$0 = Stdlib[63],
    flush_all$0 = Stdlib[64],
    output_char$0 = Stdlib[65],
    output_string$0 = Stdlib[66],
    output_bytes$0 = Stdlib[67],
    output$0 = Stdlib[68],
    output_substring$0 = Stdlib[69],
    output_byte$0 = Stdlib[70],
    output_binary_int$0 = Stdlib[71],
    output_value$0 = Stdlib[72],
    seek_out$0 = Stdlib[73],
    pos_out$0 = Stdlib[74],
    out_channel_length$0 = Stdlib[75],
    close_out$0 = Stdlib[76],
    close_out_noerr$0 = Stdlib[77],
    set_binary_mode_out$0 = Stdlib[78],
    open_in$0 = Stdlib[79],
    open_in_bin$0 = Stdlib[80],
    open_in_gen$0 = Stdlib[81],
    input_char$0 = Stdlib[82],
    input_line$0 = Stdlib[83],
    input$0 = Stdlib[84],
    really_input$0 = Stdlib[85],
    really_input_string$0 = Stdlib[86],
    input_byte$0 = Stdlib[87],
    input_binary_int$0 = Stdlib[88],
    input_value$0 = Stdlib[89],
    seek_in$0 = Stdlib[90],
    pos_in$0 = Stdlib[91],
    in_channel_length$0 = Stdlib[92],
    close_in$0 = Stdlib[93],
    close_in_noerr$0 = Stdlib[94],
    set_binary_mode_in$0 = Stdlib[95],
    LargeFile = Stdlib[96],
    string_of_format$0 = Stdlib[97],
    symbol$1 = Stdlib[98],
    exit$0 = Stdlib[99],
    at_exit$0 = Stdlib[100],
    valid_float_lexem$0 = Stdlib[101],
    unsafe_really_input$0 = Stdlib[102],
    do_at_exit$0 = Stdlib[103],
    do_domain_local_at_exit$0 = Stdlib[104],
    Hashtbl = Stdlib_MoreLabels[1],
    Map = Stdlib_MoreLabels[2],
    Set = Stdlib_MoreLabels[3],
    Stdlib$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found$0,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol_concat,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$0,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$1,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       do_domain_local_at_exit$0,
       Hashtbl,
       Map,
       Set];
   function bool_to_int(x){return x;}
   function symbol$2(_T_, _S_){return _T_ !== _S_ ? 1 : 0;}
   var symbol$3 = runtime.caml_mul;
   function symbol$4(_R_, _Q_){return Math.pow(_R_, _Q_);}
   function symbol$5(_P_, _O_){return _P_ * _O_;}
   function symbol$6(_N_, _M_){return _N_ + _M_ | 0;}
   function symbol$7(_L_, _K_){return _L_ + _K_;}
   function symbol$8(_J_, _I_){return _J_ - _I_ | 0;}
   function symbol$9(_H_, _G_){return _H_ - _G_;}
   var symbol$10 = runtime.caml_div;
   function symbol$11(_F_, _E_){return _F_ / _E_;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$0(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    ascending$0 = Int_replace_polymorphic_compar[1],
    descending$0 = Int_replace_polymorphic_compar[2],
    max$1 = Int_replace_polymorphic_compar[3],
    min$1 = Int_replace_polymorphic_compar[4],
    symbol$12 = caml_lessthan,
    symbol$13 = caml_lessequal,
    symbol$14 = caml_notequal,
    symbol$15 = caml_equal,
    symbol$16 = caml_greaterthan,
    symbol$17 = caml_greaterequal;
   function ascending$1(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$1(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare = caml_int_compare, equal = caml_equal;
   function max$2(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$2(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       ascending$1,
       descending$1,
       compare,
       equal,
       max$2,
       min$2];
   function ascending$2(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$2(x, y){return caml_call2(Base_Poly0[2], x, y);}
   function max$3(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$3(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$2, descending$2, max$3, min$3],
    symbol$18 = caml_lessthan,
    symbol$19 = caml_lessequal,
    symbol$20 = caml_notequal,
    symbol$21 = caml_equal,
    symbol$22 = caml_greaterthan,
    symbol$23 = caml_greaterequal;
   function ascending$3(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$3(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare, equal$0 = caml_equal;
   function max$4(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$4(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$18,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$3,
       descending$3,
       compare$0,
       equal$0,
       max$4,
       min$4];
   function symbol$24(x, y){return x < y ? 1 : 0;}
   function symbol$25(x, y){return x <= y ? 1 : 0;}
   function symbol$26(x, y){return x !== y ? 1 : 0;}
   function symbol$27(x, y){return x === y ? 1 : 0;}
   function symbol$28(x, y){return y < x ? 1 : 0;}
   function symbol$29(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$4(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$5(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       ascending$4,
       descending$4,
       compare$1,
       equal$1,
       max$5,
       min$5];
   function symbol$30(x, y){return x < y ? 1 : 0;}
   function symbol$31(x, y){return x <= y ? 1 : 0;}
   function symbol$32(x, y){return x !== y ? 1 : 0;}
   function symbol$33(x, y){return x === y ? 1 : 0;}
   function symbol$34(x, y){return y < x ? 1 : 0;}
   function symbol$35(x, y){return y <= x ? 1 : 0;}
   function ascending$5(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$5(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$6(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$30,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       ascending$5,
       descending$5,
       compare$2,
       equal$2,
       max$6,
       min$6];
   function i(x){return caml_call1(Stdlib_Uchar[10], x);}
   function symbol$36(x, y){var _D_ = i(y); return i(x) < _D_ ? 1 : 0;}
   function symbol$37(x, y){var _C_ = i(y); return i(x) <= _C_ ? 1 : 0;}
   function symbol$38(x, y){var _B_ = i(y); return i(x) !== _B_ ? 1 : 0;}
   function symbol$39(x, y){var _A_ = i(y); return i(x) === _A_ ? 1 : 0;}
   function symbol$40(x, y){var _z_ = i(y); return _z_ < i(x) ? 1 : 0;}
   function symbol$41(x, y){var _y_ = i(y); return _y_ <= i(x) ? 1 : 0;}
   function ascending$6(x, y){
    var _w_ = i(y), _x_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[1], _x_, _w_);
   }
   function descending$6(x, y){
    var _u_ = i(y), _v_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[2], _v_, _u_);
   }
   function compare$3(x, y){
    var _t_ = i(y);
    return caml_int_compare(i(x), _t_);
   }
   function equal$3(x, y){var _s_ = i(y); return i(x) === _s_ ? 1 : 0;}
   function max$7(x, y){
    return runtime.caml_csel_value(symbol$41(x, y), x, y);
   }
   function min$7(x, y){
    return runtime.caml_csel_value(symbol$37(x, y), x, y);
   }
   var
    Uchar_replace_polymorphic_comp =
      [0,
       i,
       symbol$36,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       max$7,
       min$7];
   function symbol$42(x, y){return x < y ? 1 : 0;}
   function symbol$43(x, y){return x <= y ? 1 : 0;}
   function symbol$44(x, y){return x !== y ? 1 : 0;}
   function symbol$45(x, y){return x === y ? 1 : 0;}
   function symbol$46(x, y){return y < x ? 1 : 0;}
   function symbol$47(x, y){return y <= x ? 1 : 0;}
   function ascending$7(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$7(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$4 = runtime.caml_float_compare;
   function equal$4(x, y){return x === y ? 1 : 0;}
   function max$8(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$8(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Float_replace_polymorphic_comp =
      [0,
       symbol$42,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       ascending$7,
       descending$7,
       compare$4,
       equal$4,
       max$8,
       min$8],
    symbol$48 = runtime.caml_string_lessthan,
    symbol$49 = caml_string_lessequal,
    symbol$50 = runtime.caml_string_notequal,
    symbol$51 = caml_string_equal,
    symbol$52 = runtime.caml_string_greaterthan,
    symbol$53 = caml_string_greaterequal;
   function ascending$8(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$8(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$5 = runtime.caml_string_compare, equal$5 = caml_string_equal;
   function max$9(x, y){
    return runtime.caml_csel_value(caml_string_greaterequal(x, y), x, y);
   }
   function min$9(x, y){
    return runtime.caml_csel_value(caml_string_lessequal(x, y), x, y);
   }
   var
    String_replace_polymorphic_com =
      [0,
       symbol$48,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       ascending$8,
       descending$8,
       compare$5,
       equal$5,
       max$9,
       min$9],
    symbol$54 = runtime.caml_bytes_lessthan,
    symbol$55 = caml_bytes_lessequal,
    symbol$56 = runtime.caml_bytes_notequal,
    symbol$57 = caml_bytes_equal,
    symbol$58 = runtime.caml_bytes_greaterthan,
    symbol$59 = caml_bytes_greaterequal;
   function ascending$9(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$9(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$6 = runtime.caml_bytes_compare, equal$6 = caml_bytes_equal;
   function max$10(x, y){
    return runtime.caml_csel_value(caml_bytes_greaterequal(x, y), x, y);
   }
   function min$10(x, y){
    return runtime.caml_csel_value(caml_bytes_lessequal(x, y), x, y);
   }
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$54,
       symbol$55,
       symbol$56,
       symbol$57,
       symbol$58,
       symbol$59,
       ascending$9,
       descending$9,
       compare$6,
       equal$6,
       max$10,
       min$10],
    symbol$60 = Stdlib$0[37],
    symbol_concat$0 = Stdlib$0[28];
   function symbol$61(_r_){return - _r_ | 0;}
   function symbol$62(_q_){return - _q_;}
   function asr(_p_, _o_){return _p_ >> _o_;}
   function land(_n_, _m_){return _n_ & _m_;}
   var lnot$0 = Stdlib$0[21];
   function lor(_l_, _k_){return _l_ | _k_;}
   function lsl(_j_, _i_){return _j_ << _i_;}
   function lsr(_h_, _g_){return _h_ >>> _g_ | 0;}
   function lxor(_f_, _e_){return _f_ ^ _e_;}
   var mod = runtime.caml_mod, abs$0 = Stdlib$0[18], failwith$0 = Stdlib$0[2];
   function fst(_d_){return _d_[1];}
   var invalid_arg$0 = Stdlib$0[1];
   function snd(_c_){return _c_[2];}
   function phys_equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib$0,
       bool_to_int,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       Int_replace_polymorphic_compar,
       ascending$0,
       descending$0,
       max$1,
       min$1,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$60,
       symbol_concat$0,
       symbol$61,
       symbol$62,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       fst,
       invalid_arg$0,
       snd,
       phys_equal,
       float_of_string,
       am_testing];
   runtime.caml_register_global(5, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    to_string = Stdlib[33],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib[34];
   function to_float(_d_){return _d_;}
   function of_float(_c_){return _c_ | 0;}
   var max_value = Stdlib[19], min_value = Stdlib[20];
   function succ(_b_){return _b_ + 1 | 0;}
   function pred(_a_){return _a_ - 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       of_string_opt,
       to_float,
       of_float,
       max_value,
       min_value,
       succ,
       pred];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[124], s);},
             fmt);
   }
   function invalid_argf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[126], s);},
             fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0);
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[49],
    runtime_warnings_enabled = Stdlib_Sys[50],
    _a_ =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function getenv_exn(var$0){
    try{var _e_ = caml_sys_getenv(var$0); return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Base_Import0[85][8])
      return caml_call3(Base_Printf[6], _a_, var$0, 0);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function getenv(var$0){
    try{var x = caml_sys_getenv(var$0);}
    catch(_c_){
     var _b_ = caml_wrap_exception(_c_);
     if(_b_ === Base_Import0[85][8]) return 0;
     throw caml_maybe_attach_backtrace(_b_, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Import0, Base__Int0, Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels,
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11];
   function create(len, x){return caml_make_vect(len, x);}
   function create_local(len, x){return caml_make_vect(len, x);}
   function create_float_uninitialized(len){
    return runtime.caml_make_float_vect(len);
   }
   var
    append = Stdlib_ArrayLabels[4],
    blit = Stdlib_ArrayLabels[9],
    concat = Stdlib_ArrayLabels[5],
    copy = Stdlib_ArrayLabels[7],
    fill = Stdlib_ArrayLabels[8],
    cst_Array_init = "Array.init";
   function init(len, f){
    if(0 === len) return [0];
    if(0 > len) return caml_call1(Base_Import0[126], cst_Array_init);
    var
     x = caml_call1(f, 0),
     res = caml_make_vect(len, x),
     _s_ = caml_call1(Base_Int0[9], len),
     _r_ = 1;
    if(_s_ >= 1){
     var i = _r_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _t_ = i + 1 | 0;
      if(_s_ === i) break;
      i = _t_;
     }
    }
    return res;
   }
   var
    make_matrix = Stdlib_ArrayLabels[2],
    of_list = Stdlib_ArrayLabels[11],
    sub = Stdlib_ArrayLabels[6],
    to_list = Stdlib_ArrayLabels[10];
   function fold(t, init, f){
    var
     r = [0, init],
     _p_ = caml_call2(Base_Import0[93], t.length - 1, 1),
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      i = _q_;
     }
    }
    return r[1];
   }
   function fold_right(t, f, init){
    var r = [0, init], _m_ = caml_call2(Base_Import0[93], t.length - 1, 1);
    if(_m_ >= 0){
     var i = _m_;
     for(;;){
      r[1] = caml_call2(f, t[1 + i], r[1]);
      var _n_ = i - 1 | 0;
      if(0 === i) break;
      i = _n_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _k_ = caml_call2(Base_Import0[93], t.length - 1, 1), _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      caml_call1(f, t[1 + i]);
      var _l_ = i + 1 | 0;
      if(_k_ === i) break;
      i = _l_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var _h_ = caml_call2(Base_Import0[93], t.length - 1, 1), _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      caml_call2(f, i, t[1 + i]);
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      i = _i_;
     }
    }
    return 0;
   }
   function map(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     x = caml_call1(f, t[1]),
     r = caml_make_vect(len, x),
     _e_ = caml_call2(Base_Import0[93], len, 1),
     _d_ = 1;
    if(_e_ >= 1){
     var i = _d_;
     for(;;){
      r[1 + i] = caml_call1(f, t[1 + i]);
      var _f_ = i + 1 | 0;
      if(_e_ === i) break;
      i = _f_;
     }
    }
    return r;
   }
   function mapi(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     x = caml_call2(f, 0, t[1]),
     r = caml_make_vect(len, x),
     _b_ = caml_call2(Base_Import0[93], len, 1),
     _a_ = 1;
    if(_b_ >= 1){
     var i = _a_;
     for(;;){
      r[1 + i] = caml_call2(f, i, t[1 + i]);
      var _c_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _c_;
     }
    }
    return r;
   }
   function stable_sort(t, compare){
    return caml_call2(Stdlib_ArrayLabels[36], compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[1 + i],
     elt_j = caml_check_bound(t, j)[1 + j];
    t[1 + i] = elt_j;
    t[1 + j] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(10, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[3];
   function to_int(_e_){return _e_;}
   function unsafe_of_int(_d_){return _d_;}
   var uppercase = Stdlib_Char[4];
   function int_is_ok(i){
    var _b_ = 0 <= i ? 1 : 0, _c_ = _b_ ? i <= 255 ? 1 : 0 : _b_;
    return _c_;
   }
   var
    _a_ =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call3(failwithf, _a_, i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       0,
       255,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Base__Import0, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[6],
    length = Stdlib_ListLabels[1],
    rev_append = Stdlib_ListLabels[13],
    tl_exn = Stdlib_ListLabels[7],
    unzip = Stdlib_ListLabels[57],
    cst_List_exists2 = "List.exists2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_iter2 = "List.iter2",
    cst_List_rev_map2 = "List.rev_map2";
   function exists(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var xs = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return 1;
     t$0 = xs;
    }
   }
   function exists2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _c_ = caml_call2(f, a1, a2);
       if(_c_) return _c_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Base_Import0[126], cst_List_exists2);
    }
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(! t$0) return init$0;
     var l = t$0[2], a = t$0[1], init$1 = caml_call2(f, init$0, a);
     t$0 = l;
     init$0 = init$1;
    }
   }
   function fold2_ok(l1, l2, init, f){
    var l1$0 = l1, l2$0 = l2, init$0 = init;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        init$1 = caml_call3(f, init$0, a1, a2);
       l1$0 = l1$1;
       l2$0 = l2$1;
       init$0 = init$1;
       continue;
      }
     }
     else if(! l2$0) return init$0;
     return caml_call1(Base_Import0[126], cst_List_fold_left2);
    }
   }
   function for_all(t, f){
    return 1 - exists(t, function(x){return 1 - caml_call1(f, x);});
   }
   function for_all2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _b_ = caml_call2(f, a1, a2);
       if(! _b_) return _b_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Base_Import0[126], cst_List_for_all2);
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], a = t$0[1];
     caml_call1(f, a);
     t$0 = l;
    }
   }
   function iter2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Base_Import0[126], cst_List_iter2);
    }
   }
   function nontail_map(t, f){
    if(! t) return 0;
    var xs = t[2], x = t[1], y = caml_call1(f, x);
    return [0, y, nontail_map(xs, f)];
   }
   function nontail_mapi(t, f){
    return caml_call2(Stdlib_ListLabels[21], f, t);
   }
   function partition(t, f){return caml_call2(Stdlib_ListLabels[47], f, t);}
   function rev_map(l$0, f){
    var accu = 0, param = l$0;
    for(;;){
     if(! param) return accu;
     var l = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l;
    }
   }
   function rev_map2_ok(l1$1, l2$1, f){
    var accu = 0, l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return accu;
     return caml_call1(Base_Import0[126], cst_List_rev_map2);
    }
   }
   function sort(l, compare){
    return caml_call2(Stdlib_ListLabels[59], compare, l);
   }
   function stable_sort(l, compare){
    return caml_call2(Stdlib_ListLabels[60], compare, l);
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return caml_call2(rev_append, rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    return l
            ? fold(rev(l), init, function(a, b){return caml_call2(f, b, a);})
            : init;
   }
   function fold_right2_ok(l1, l2, f, init){
    if(! l1 && ! l2) return init;
    var _a_ = rev(l2);
    return fold2_ok
            (rev(l1),
             _a_,
             init,
             function(a, b, c){return caml_call3(f, b, c, a);});
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right,
       fold_right2_ok];
   runtime.caml_register_global(7, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function as_int(f, s, x){
     return caml_call2(hash_fold_int, s, caml_call1(f, x));
    }
    function _H_(_ah_){return _ah_;}
    function hash_fold_int32(_af_, _ag_){return as_int(_H_, _af_, _ag_);}
    var _I_ = Base_Char0[4];
    function hash_fold_char(_ad_, _ae_){return as_int(_I_, _ad_, _ae_);}
    function _J_(param){return param ? 1 : 0;}
    function hash_fold_bool(_ab_, _ac_){return as_int(_J_, _ab_, _ac_);}
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, caml_call1(Base_List0[2], list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x);
      s = s$0;
      list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var _$_ = runtime.caml_obj_tag(x);
     a:
     if(250 === _$_)
      var _aa_ = x[1];
     else{
      if(246 !== _$_ && 244 !== _$_){var _aa_ = x; break a;}
      var _aa_ = caml_call1(CamlinternalLazy[2], x);
     }
     return caml_call2(hash_fold_elem, s, _aa_);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[1 + i],
       i$0 = caml_call2(Base_Import0[91], i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e);
      s = s$0;
      i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      _Z_ = caml_call1(Hash[6], 0),
      ___ = hash_fold_nativeint(caml_call2(Hash[7], 0, _Z_), x);
     return caml_call1(Hash[8], ___);
    }
    function hash_int64(x){
     var
      _X_ = caml_call1(Hash[6], 0),
      _Y_ = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, _X_), x);
     return caml_call1(Hash[8], _Y_);
    }
    function hash_int32(x){
     var
      _V_ = caml_call1(Hash[6], 0),
      _W_ = as_int(_H_, caml_call2(Hash[7], 0, _V_), x);
     return caml_call1(Hash[8], _W_);
    }
    function hash_char(x){
     var
      _T_ = caml_call1(Hash[6], 0),
      _U_ = as_int(_I_, caml_call2(Hash[7], 0, _T_), x);
     return caml_call1(Hash[8], _U_);
    }
    function hash_int(x){
     var
      _R_ = caml_call1(Hash[6], 0),
      _S_ = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, _R_), x);
     return caml_call1(Hash[8], _S_);
    }
    function hash_bool(x){
     var
      _P_ = caml_call1(Hash[6], 0),
      _Q_ = as_int(_J_, caml_call2(Hash[7], 0, _P_), x);
     return caml_call1(Hash[8], _Q_);
    }
    function hash_string(x){
     var
      _N_ = caml_call1(Hash[6], 0),
      _O_ = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, _N_), x);
     return caml_call1(Hash[8], _O_);
    }
    function hash_float(x){
     var
      _L_ = caml_call1(Hash[6], 0),
      _M_ = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, _L_), x);
     return caml_call1(Hash[8], _M_);
    }
    function hash_unit(x){
     var _K_ = caml_call1(Hash[6], 0), s = caml_call2(Hash[7], 0, _K_);
     return caml_call1(Hash[8], s);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      _F_ = caml_call1(Hash[6], 0),
      _G_ = caml_call2(folder, caml_call2(Hash[7], seed, _F_), x);
     return caml_call1(Hash[8], _G_);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){var seed = opt ? opt[1] : 0; return seed;}
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return caml_call1(Base_Int0[1], state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(_E_, _D_){
          return runtime.Base_internalhash_fold_int(_E_, _D_);
         },
         function(_C_, _B_){
          return runtime.Base_internalhash_fold_int64(_C_, _B_);
         },
         function(_A_, _z_){
          return runtime.Base_internalhash_fold_float(_A_, _z_);
         },
         function(_y_, _x_){
          return runtime.Base_internalhash_fold_string(_y_, _x_);
         },
         alloc,
         reset,
         function(_w_){return runtime.Base_internalhash_get_hash_value(_w_);},
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     _k_ = caml_call2(Base_Import0[119], t, 21),
     _l_ = caml_call1(Base_Import0[117], t),
     t$0 = caml_call2(Base_Import0[91], _l_, _k_),
     _m_ = caml_call2(Base_Import0[120], t$0, 24),
     t$1 = caml_call2(Base_Import0[121], t$0, _m_),
     _n_ = caml_call2(Base_Import0[119], t$1, 8),
     _o_ = caml_call2(Base_Import0[119], t$1, 3),
     _p_ = caml_call2(Base_Import0[91], t$1, _o_),
     t$2 = caml_call2(Base_Import0[91], _p_, _n_),
     _q_ = caml_call2(Base_Import0[120], t$2, 14),
     t$3 = caml_call2(Base_Import0[121], t$2, _q_),
     _r_ = caml_call2(Base_Import0[119], t$3, 4),
     _s_ = caml_call2(Base_Import0[119], t$3, 2),
     _t_ = caml_call2(Base_Import0[91], t$3, _s_),
     t$4 = caml_call2(Base_Import0[91], _t_, _r_),
     _u_ = caml_call2(Base_Import0[120], t$4, 28),
     t$5 = caml_call2(Base_Import0[121], t$4, _u_),
     _v_ = caml_call2(Base_Import0[119], t$5, 31);
    return caml_call2(Base_Import0[91], t$5, _v_);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    Base_Hash =
      [0,
       F,
       description,
       function(_j_, _i_){
        return runtime.Base_internalhash_fold_int(_j_, _i_);
       },
       function(_h_, _g_){
        return runtime.Base_internalhash_fold_int64(_h_, _g_);
       },
       function(_f_, _e_){
        return runtime.Base_internalhash_fold_float(_f_, _e_);
       },
       function(_d_, _c_){
        return runtime.Base_internalhash_fold_string(_d_, _c_);
       },
       alloc,
       reset,
       function(_b_){return runtime.Base_internalhash_get_hash_value(_b_);},
       For_tests,
       create,
       of_fold,
       [0,
        hash_fold_nativeint,
        hash_fold_int64,
        hash_fold_int32,
        hash_fold_char,
        hash_fold_int,
        hash_fold_bool,
        hash_fold_string,
        hash_fold_float,
        hash_fold_unit,
        hash_fold_option,
        hash_fold_list,
        hash_fold_lazy_t,
        hash_fold_ref_frozen,
        hash_fold_array_frozen,
        hash_nativeint,
        hash_int64,
        hash_int32,
        hash_char,
        hash_int,
        hash_bool,
        hash_string,
        function(_a_){return runtime.Base_hash_double(_a_);},
        hash_unit],
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int_compare = runtime.caml_int_compare;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    _a_ =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."],
    _b_ =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, _u_, param){
    return caml_call3(Base_Printf[4], Base_Import0[124], _a_, type_name);
   }
   function equal_abstract(type_name, _t_, param){
    return caml_call3(Base_Printf[4], Base_Import0[124], _b_, type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_char = caml_int_compare,
    compare_float = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int32 = caml_int_compare;
   function compare_int64(_s_, _r_){
    return runtime.caml_int64_compare(_s_, _r_);
   }
   var
    compare_nativeint = caml_int_compare,
    compare_string = runtime.caml_string_compare,
    compare_unit = caml_int_compare;
   function compare_array(compare_elt, a, b){
    if(caml_call2(Base_Import0[128], a, b)) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[1 + i], r = b[1 + i], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import0[91], i, 1);
     i = i$0;
    }
   }
   function compare_list(compare_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     a$0 = xs;
     b$0 = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(_q_, _p_){return _q_ === _p_ ? 1 : 0;}
   function equal_char(_o_, _n_){return _o_ === _n_ ? 1 : 0;}
   function equal_int(_m_, _l_){return _m_ === _l_ ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int64 = caml_equal,
    equal_nativeint = caml_equal,
    equal_string = runtime.caml_string_equal;
   function equal_unit(_k_, _j_){return _k_ === _j_ ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_array(equal_elt, a, b){
    var _d_ = caml_call2(Base_Import0[128], a, b);
    if(_d_)
     var _e_ = _d_;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      _f_ = len_a === len_b ? 1 : 0;
     if(_f_){
      var i = 0;
      for(;;){
       var _g_ = i === len_a ? 1 : 0;
       if(_g_)
        var _h_ = _g_;
       else{
        var l = a[1 + i], r = b[1 + i], _i_ = caml_call2(equal_elt, l, r);
        if(_i_){
         var i$0 = caml_call2(Base_Import0[91], i, 1);
         i = i$0;
         continue;
        }
        var _h_ = _i_;
       }
       return _h_;
      }
     }
     var _e_ = _f_;
    }
    return _e_;
   }
   function equal_list(equal_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _c_ = caml_call2(equal_elt, x, y);
       if(! _c_) return _c_;
       a$0 = xs;
       b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare(a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[5][8], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3(Base_Ppx_compare_lib[5][11], compare, a_005, b_006);
   }
   var letrec_function_context = [];
   function hash_fold_t(hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(Base_Hash[13][7], hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
   }
   function hash(x){return caml_call1(letrec_function_context[1], x);}
   function func(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _a_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _a_);
   }
   runtime.caml_update_dummy(letrec_function_context, [0, func]);
   var t_sexp_grammar = Sexplib0_Sexp_conv[61];
   function invariant(param){return 0;}
   var
    Base_Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       t_sexp_grammar,
       invariant,
       0];
   runtime.caml_register_global(4, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Globalize = global_data.Base__Globalize,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    do_domain_local_at_exit = Base_Import0[84],
    Stdlib = Base_Import0[85],
    bool_to_int = Base_Import0[86],
    symbol$0 = Base_Import0[87],
    symbol$1 = Base_Import0[88],
    symbol$2 = Base_Import0[89],
    symbol$3 = Base_Import0[90],
    symbol$4 = Base_Import0[91],
    symbol$5 = Base_Import0[92],
    symbol$6 = Base_Import0[93],
    symbol$7 = Base_Import0[94],
    symbol$8 = Base_Import0[95],
    symbol$9 = Base_Import0[96],
    Int_replace_polymorphic_compar = Base_Import0[97],
    ascending = Base_Import0[98],
    descending = Base_Import0[99],
    max = Base_Import0[100],
    min = Base_Import0[101],
    Int32_replace_polymorphic_comp = Base_Import0[102],
    Int64_replace_polymorphic_comp = Base_Import0[103],
    Nativeint_replace_polymorphic_ = Base_Import0[104],
    Bool_replace_polymorphic_compa = Base_Import0[105],
    Char_replace_polymorphic_compa = Base_Import0[106],
    Uchar_replace_polymorphic_comp = Base_Import0[107],
    Float_replace_polymorphic_comp = Base_Import0[108],
    String_replace_polymorphic_com = Base_Import0[109],
    Bytes_replace_polymorphic_comp = Base_Import0[110],
    symbol$10 = Base_Import0[111],
    symbol_concat = Base_Import0[112],
    symbol$11 = Base_Import0[113],
    symbol$12 = Base_Import0[114],
    asr = Base_Import0[115],
    land = Base_Import0[116],
    lnot = Base_Import0[117],
    lor = Base_Import0[118],
    lsl = Base_Import0[119],
    lsr = Base_Import0[120],
    lxor = Base_Import0[121],
    mod = Base_Import0[122],
    abs = Base_Import0[123],
    failwith = Base_Import0[124],
    fst = Base_Import0[125],
    invalid_arg = Base_Import0[126],
    snd = Base_Import0[127],
    phys_equal = Base_Import0[128],
    float_of_string = Base_Import0[129],
    am_testing = Base_Import0[130],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    sexp_grammar_with_tags = Sexplib0_Sexp_conv[49],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv[50],
    unit_sexp_grammar = Sexplib0_Sexp_conv[51],
    bool_sexp_grammar = Sexplib0_Sexp_conv[52],
    string_sexp_grammar = Sexplib0_Sexp_conv[53],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[54],
    char_sexp_grammar = Sexplib0_Sexp_conv[55],
    int_sexp_grammar = Sexplib0_Sexp_conv[56],
    float_sexp_grammar = Sexplib0_Sexp_conv[57],
    int32_sexp_grammar = Sexplib0_Sexp_conv[58],
    int64_sexp_grammar = Sexplib0_Sexp_conv[59],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[60],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    ref_sexp_grammar = Sexplib0_Sexp_conv[62],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[63],
    option_sexp_grammar = Sexplib0_Sexp_conv[64],
    list_sexp_grammar = Sexplib0_Sexp_conv[65],
    array_sexp_grammar = Sexplib0_Sexp_conv[66],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[67],
    fun_sexp_grammar = Sexplib0_Sexp_conv[68],
    sexp_of_exn = Sexplib0_Sexp_conv[69],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[70],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[71],
    Exn_converter = Sexplib0_Sexp_conv[72],
    _a_ = Base_Hash[13],
    hash_fold_nativeint = _a_[1],
    hash_fold_int64 = _a_[2],
    hash_fold_int32 = _a_[3],
    hash_fold_char = _a_[4],
    hash_fold_int = _a_[5],
    hash_fold_bool = _a_[6],
    hash_fold_string = _a_[7],
    hash_fold_float = _a_[8],
    hash_fold_unit = _a_[9],
    hash_fold_option = _a_[10],
    hash_fold_list = _a_[11],
    hash_fold_lazy_t = _a_[12],
    hash_fold_ref_frozen = _a_[13],
    hash_fold_array_frozen = _a_[14],
    hash_nativeint = _a_[15],
    hash_int64 = _a_[16],
    hash_int32 = _a_[17],
    hash_char = _a_[18],
    hash_int = _a_[19],
    hash_bool = _a_[20],
    hash_string = _a_[21],
    hash_float = _a_[22],
    hash_unit = _a_[23],
    _b_ = Base_Ppx_compare_lib[5],
    compare_bool = _b_[1],
    compare_char = _b_[2],
    compare_float = _b_[3],
    compare_int = _b_[4],
    compare_int32 = _b_[5],
    compare_int64 = _b_[6],
    compare_nativeint = _b_[7],
    compare_string = _b_[8],
    compare_unit = _b_[9],
    compare_array = _b_[10],
    compare_list = _b_[11],
    compare_option = _b_[12],
    compare_ref = _b_[13],
    equal_bool = _b_[14],
    equal_char = _b_[15],
    equal_float = _b_[16],
    equal_int = _b_[17],
    equal_int32 = _b_[18],
    equal_int64 = _b_[19],
    equal_nativeint = _b_[20],
    equal_string = _b_[21],
    equal_unit = _b_[22],
    equal_array = _b_[23],
    equal_list = _b_[24],
    equal_option = _b_[25],
    equal_ref = _b_[26],
    globalize_bool = Base_Globalize[1],
    globalize_char = Base_Globalize[2],
    globalize_float = Base_Globalize[3],
    globalize_int = Base_Globalize[4],
    globalize_int32 = Base_Globalize[5],
    globalize_int64 = Base_Globalize[6],
    globalize_nativeint = Base_Globalize[7],
    globalize_bytes = Base_Globalize[8],
    globalize_string = Base_Globalize[9],
    globalize_unit = Base_Globalize[10],
    globalize_array = Base_Globalize[11],
    globalize_list = Base_Globalize[12],
    globalize_option = Base_Globalize[13],
    globalize_result = Base_Globalize[14],
    globalize_ref = Base_Globalize[15],
    Not_found_s = Base_Sexp[7],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol_concat,
       symbol$11,
       symbol$12,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       phys_equal,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       globalize_bool,
       globalize_char,
       globalize_float,
       globalize_int,
       globalize_int32,
       globalize_int64,
       globalize_nativeint,
       globalize_bytes,
       globalize_string,
       globalize_unit,
       globalize_array,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref,
       Not_found_s];
   runtime.caml_register_global(6, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    _a_ = [0, "W64"],
    _b_ = [0, "W32"];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function num_bits(param){return param ? 64 : 32;}
   var
    _c_ = Base_Sys0[7],
    cst_unknown_word_size = "unknown word size",
    word_size =
      32 === _c_
       ? 0
       : 64 === _c_ ? 1 : caml_call1(Base_Import[124], cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1];
    register(caml_call2(Base_Import[112], M[2], cst_pp));
    return [0, pp];
   }
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var _b_ = caml_call1(M[2], t);
         return caml_call2(Stdlib_Format[13], formatter, _b_);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       function(_a_){return [0, Register_pp(_a_)[1]];},
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[199],
    exit = Base_Import[85][99],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    _a_ = [0, "exn.ml.Finally"],
    _b_ = [0, cst_src_exn_ml, 19, 11];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Finally,
     function(param){
      if(param[1] !== Finally)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      var
       arg1_002 = param[3],
       arg0_001 = param[2],
       res0_003 = caml_call1(sexp_of_t, arg0_001),
       res1_004 = caml_call1(sexp_of_t, arg1_002);
      return [1, [0, _a_, [0, res0_003, [0, res1_004, 0]]]];
     });
   var
    Reraised = [248, "Base__Exn.Reraised", caml_fresh_oo_id(0)],
    _c_ = [0, "exn.ml.Reraised"],
    _d_ = [0, cst_src_exn_ml, 32, 11];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Reraised,
     function(param){
      if(param[1] !== Reraised)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var
       arg1_006 = param[3],
       arg0_005 = param[2],
       res0_007 = caml_call1(Base_Import[137], arg0_005),
       res1_008 = caml_call1(sexp_of_t, arg1_006);
      return [1, [0, _c_, [0, res0_007, [0, res1_008, 0]]]];
     });
   var
    Sexp = [248, "Base__Exn.Sexp", caml_fresh_oo_id(0)],
    _e_ = [0, cst_src_exn_ml, 53, 6];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Sexp,
     function(param){
      if(param[1] !== Sexp)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var t = param[2];
      return t;
     });
   var _f_ = [0, 2];
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = caml_call1(Stdlib_Printexc[12], 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    return caml_call2
            (Base_Printf[4],
             function(str, param){return reraise(exc, str);},
             format);
   }
   function to_string(exc){
    var _u_ = caml_call1(Base_Import[199], exc);
    return caml_call2(Base_Sexp[15], _f_, _u_);
   }
   function to_string_mach(exc){
    var _t_ = caml_call1(Base_Import[199], exc);
    return caml_call1(Base_Sexp[16], _t_);
   }
   var sexp_of_t$0 = Base_Import[199];
   function protectx(f, x, finally$0){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     try{caml_call1(finally$0, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$0, x);
    return res;
   }
   function protect(f, finally$0){return protectx(f, 0, finally$0);}
   function does_raise(f){
    try{caml_call1(f, 0); var _r_ = 0; return _r_;}catch(_s_){return 1;}
   }
   function pp(ppf, t){
    var match = caml_call1(Base_Import[201], t);
    if(match){
     var sexp = match[1];
     return caml_call2(Base_Sexp[11], ppf, sexp);
    }
    var _q_ = caml_call1(Stdlib_Printexc[1], t);
    return caml_call2(Stdlib_Format[13], ppf, _q_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    _g_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    _h_ =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call3(Stdlib_Format[141], _g_, pp$0, exc);
    if(caml_call1(Stdlib_Printexc[8], 0))
     caml_call2(Stdlib_Printexc[13], Base_Import[85][40], raw_backtrace);
    return caml_call1(Base_Import[85][63], Base_Import[85][40]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var _m_ = caml_call1(f, 0); return _m_;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
     if(do_at_exit) try{caml_call1(Base_Import[85][103], 0);}catch(_p_){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(_n_){try{caml_call1(Stdlib_Printf[3], _h_);}catch(_o_){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(_l_){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var _k_ = caml_call1(func, 0); return _k_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return caml_call1(Stdlib_Printexc[16], print_with_backtrace);
   }
   function clear_backtrace(_j_){
    return runtime.Base_clear_caml_backtrace_pos(_j_);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_i_){return runtime.Base_caml_exn_is_most_recent_exn(_i_);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_Return = "Return",
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$0(a){
     if(1 - is_alive[1])
      caml_call1(Base_Import[124], cst_use_of_return_from_a_with_);
     return caml_call1(Base_Exn[6], [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$0); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     if(exn[1] !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$0){
              caml_call1(f, function(a){return caml_call1(return$0, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$0(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n, f, x){
    var n$0 = n, x$0 = x;
    for(;;){
     if(0 >= n$0) return x$0;
     var x$1 = caml_call1(f, x$0), n$1 = caml_call2(Base_Import[93], n$0, 1);
     n$0 = n$1;
     x$0 = x$1;
    }
   }
   var Base_Fn = [0, const$0, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(_A_){
    var bind = _A_[1], return$0 = _A_[3];
    function map_via_bind(ma, f){
     return caml_call2
             (_A_[1],
              ma,
              function(a){
               var _B_ = caml_call1(f, a);
               return caml_call1(_A_[3], _B_);
              });
    }
    var match = _A_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     return caml_call2
             (symbol_bind$1,
              a,
              function(a){
               return caml_call2
                       (symbol_map$1, b, function(b){return [0, a, b];});
              });
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(t){return t;});
    }
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[21], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _z_ = Make_general([0, bind, map, return$0]);
    return [0,
            _z_[6],
            _z_[7],
            _z_[8],
            _z_[5],
            _z_[1],
            _z_[2],
            _z_[4],
            _z_[9],
            _z_[10],
            _z_[11],
            _z_[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _y_ = Make_general([0, bind, map, return$0]);
    return [0,
            _y_[6],
            _y_[7],
            _y_[8],
            _y_[5],
            _y_[1],
            _y_[2],
            _y_[4],
            _y_[9],
            _y_[10],
            _y_[11],
            _y_[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _x_ = Make_general([0, bind, map, return$0]);
    return [0,
            _x_[6],
            _x_[7],
            _x_[8],
            _x_[5],
            _x_[1],
            _x_[2],
            _x_[4],
            _x_[9],
            _x_[10],
            _x_[11],
            _x_[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _w_ = Make_general([0, bind, map, return$0]);
    return [0,
            _w_[6],
            _w_[7],
            _w_[5],
            _w_[1],
            _w_[2],
            _w_[4],
            _w_[9],
            _w_[10],
            _w_[11],
            _w_[12],
            _w_[8]];
   }
   function Make2_local(_t_){
    var bind = _t_[1], return$0 = _t_[3];
    function map_via_bind(ma, f){
     var
      res =
        caml_call2
         (_t_[1],
          ma,
          function(a){
           var _v_ = caml_call1(f, a);
           return caml_call1(_t_[3], _v_);
          });
     return res;
    }
    var match = _t_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     var
      res =
        caml_call2
         (bind,
          a,
          function(a){
           var res = caml_call2(map, b, function(b){return [0, a, b];});
           return res;
          });
     return res;
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(_u_){return _u_;});
    }
    function ignore_m(t){
     var res = caml_call2(map, t, function(param){return 0;});
     return res;
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[21], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_local(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _s_ = Make2_local([0, bind, map, return$0]);
    return [0,
            _s_[6],
            _s_[7],
            _s_[5],
            _s_[1],
            _s_[2],
            _s_[4],
            _s_[9],
            _s_[10],
            _s_[11],
            _s_[12],
            _s_[8]];
   }
   function Of_monad_general(Monad, M){
    function return$0(a){
     var _r_ = caml_call1(Monad[3], a);
     return caml_call1(M[2], _r_);
    }
    function bind(t, f){
     var
      _o_ = caml_call1(M[1], t),
      _p_ =
        caml_call2
         (Monad[1],
          _o_,
          function(a){
           var _q_ = caml_call1(f, a);
           return caml_call1(M[1], _q_);
          });
     return caml_call1(M[2], _p_);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var _m_ = caml_call1(M[1], t), _n_ = caml_call2(Monad[2], _m_, f);
         return caml_call1(M[2], _n_);
        }];
    return Make_general([0, bind, map, return$0]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function map(a, f){return caml_call1(f, a);}
   function symbol_map(a, f){return caml_call1(f, a);}
   function symbol_bind(a, f){return caml_call1(f, a);}
   function return$0(_l_){return _l_;}
   function both(a, b){return [0, a, b];}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       Make_local,
       function(_j_){
        var _k_ = Make2_local(_j_);
        return [0,
                _k_[6],
                _k_[7],
                _k_[8],
                _k_[5],
                _k_[1],
                _k_[2],
                _k_[4],
                _k_[9],
                _k_[10],
                _k_[11],
                _k_[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[4],
         return$0 = Monad[5],
         map = Monad[6],
         _i_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _i_[6],
                _i_[7],
                _i_[5],
                _i_[1],
                _i_[2],
                _i_[4],
                _i_[9],
                _i_[10],
                _i_[11],
                _i_[12],
                _i_[8]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _h_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _h_[6],
                _h_[7],
                _h_[8],
                _h_[5],
                _h_[1],
                _h_[2],
                _h_[4],
                _h_[9],
                _h_[10],
                _h_[11],
                _h_[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _g_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _g_[6],
                _g_[7],
                _g_[8],
                _g_[5],
                _g_[1],
                _g_[2],
                _g_[4],
                _g_[9],
                _g_[10],
                _g_[11],
                _g_[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _f_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _f_[6],
                _f_[7],
                _f_[8],
                _f_[5],
                _f_[1],
                _f_[2],
                _f_[4],
                _f_[9],
                _f_[10],
                _f_[11],
                _f_[12]];
       },
       [0,
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        bind,
        function(_e_){return _e_;},
        map,
        function(_d_){return _d_;},
        function(_c_){return 0;},
        function(_b_){return _b_;},
        function(_a_){return 0;},
        [0, return$0, symbol_bind, symbol_map, Let_syntax]]];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(T, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(T, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S(T1, T2, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(_N_){
    var return$0 = _N_[1], symbol = _N_[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$0, f), t);
    }
    var match = _N_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     function _Q_(x, xs){return [0, x, xs];}
     var _P_ = caml_call1(return$0, 0);
     return caml_call3
             (Base_List0[22],
              ts,
              function(_R_){
               return function(_S_){return map2(_R_, _S_, _Q_);};
              },
              _P_);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(param, y){return y;}),
                u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(x, param){return x;}),
                u),
              v);
    }
    function all_unit(ts){
     var _O_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _O_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make3([0, return$0, apply, map]);
   }
   function Make(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make2([0, return$0, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$0 = X[1],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$1 = X[1],
     map = X[2],
     both = X[3],
     Let_syntax = [0, return$1, map, both, , , , , Impl],
     Let_syntax$0 =
       [0, return$0, , , symbol, symbol$0, symbol$1, symbol_map, Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(_G_){
    var return$0 = _G_[1], map2 = _G_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$0, f), t);}
    var match = _G_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     return caml_call3
             (map2,
              caml_call3(map2, ta, tb, f),
              tc,
              function(fab, c){return caml_call1(fab, c);});
    }
    function all(ts){
     function _J_(x, xs){return [0, x, xs];}
     var _I_ = caml_call1(return$0, 0);
     return caml_call3
             (Base_List0[22],
              ts,
              function(_K_){
               var _L_ = caml_call1(map2, _K_);
               return function(_M_){return caml_call2(_L_, _M_, _J_);};
              },
              _I_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _H_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _H_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$0, map2, map]);
   }
   function Make_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$0, map2, map]);
   }
   function Make3_using_map2_local(_z_){
    var return$0 = _z_[1], map2 = _z_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){
     return caml_call3
             (map2, caml_call1(return$0, 0), t, function(param){return f;});
    }
    var match = _z_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var map$0 = match[2], map = map$0;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     var
      res =
        caml_call3
         (map2,
          both(ta, tb),
          tc,
          function(param, c){
           var b = param[2], a = param[1];
           return caml_call3(f, a, b, c);
          });
     return res;
    }
    function all(ts){
     function _C_(x, xs){return [0, x, xs];}
     var _B_ = caml_call1(return$0, 0);
     return caml_call3
             (Base_List0[22],
              ts,
              function(_D_){
               var _E_ = caml_call1(map2, _D_);
               return function(_F_){return caml_call2(_E_, _F_, _C_);};
              },
              _B_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _A_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _A_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2_local(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2_local([0, return$0, map2, map]);
   }
   function Make_using_map2_local(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2_local([0, return$0, map2, map]);
   }
   function Of_monad2(M){
    var return$0 = M[6];
    function apply(mf, mx){
     return caml_call2(M[5], mf, function(f){return caml_call2(M[7], mx, f);});
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$0, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$0 = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$0(a){
     var _y_ = caml_call1(F[1], a);
     return caml_call1(G[1], _y_);
    }
    function apply(tf, tx){
     var _x_ = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], _x_, tx);
    }
    function custom_map(t, f){
     var _v_ = F[2];
     return caml_call2
             (G[2], t, function(_w_){return caml_call2(_v_, _w_, f);});
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$0(a){
     var _u_ = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), _u_];
    }
    function apply(tf, tx){
     var
      _p_ = caml_call1(Base_Import[127], tx),
      _q_ = caml_call1(Base_Import[127], tf),
      _r_ = caml_call2(G[8], _q_, _p_),
      _s_ = caml_call1(Base_Import[125], tx),
      _t_ = caml_call1(Base_Import[125], tf);
     return [0, caml_call2(F[8], _t_, _s_), _r_];
    }
    function custom_map(t, f){
     var
      _m_ = caml_call1(Base_Import[127], t),
      _n_ = caml_call2(G[2], _m_, f),
      _o_ = caml_call1(Base_Import[125], t);
     return [0, caml_call2(F[2], _o_, f), _n_];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   var
    Base_Applicative =
      [0,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S3_to_S,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$0 = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         _k_ =
           Make_let_syntax2
             ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         _l_ = _k_[8];
        return [0,
                [0,
                 _k_[1],
                 _k_[4],
                 _k_[5],
                 _k_[6],
                 _k_[7],
                 [0, _l_[1], _l_[2], _l_[3], _l_[8]]]];
       },
       function(_h_, _g_, _f_){
        var _i_ = Make_let_syntax2(_h_, _g_, _f_)[1], _j_ = _i_[8];
        return [0,
                [0,
                 _i_[1],
                 _i_[4],
                 _i_[5],
                 _i_[6],
                 _i_[7],
                 [0, _j_[1], _j_[2], _j_[3], _j_[8]]]];
       },
       function(_c_, _b_, _a_){
        var _d_ = Make_let_syntax3(_c_, _b_, _a_)[1], _e_ = _d_[8];
        return [0,
                [0,
                 _d_[1],
                 _d_[4],
                 _d_[5],
                 _d_[6],
                 _d_[7],
                 [0, _e_[1], _e_[2], _e_[3], _e_[8]]]];
       },
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Make_using_map2_local,
       Make2_using_map2_local,
       Make3_using_map2_local,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0];
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare, _a_ = [0, "_"];
   function sexp_of_t(param){return _a_;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var _e_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _e_];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var _d_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _d_];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var _c_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _c_];
    }
    return [0, comparator];
   }
   function Derived2_phantom(M){
    function comparator(a, b){
     var _b_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _b_];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom,
       Derived2_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_011 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    _a_ = [0, cst_First$0],
    _b_ = [0, cst_Second$0],
    cst_Second = cst_Second$0,
    cst_First = cst_First$0;
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_007, of_s_008, sexp_013){
    a:
    {
     if(0 === sexp_013[0]){
      var _c_ = sexp_013[1];
      b:
      if(_c_ !== cst_First$0){
       if(_c_ !== cst_Second$0){
        if(_c_ === cst_first) break b;
        if(_c_ !== cst_second) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
     }
     var _d_ = sexp_013[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_011, sexp_013);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_011, sexp_013);
     var tag_014 = _e_[1];
     b:
     if(tag_014 !== cst_First$0){
      if(tag_014 !== cst_Second$0){
       if(tag_014 === cst_first) break b;
       if(tag_014 !== cst_second) break a;
      }
      var sexp_args_020 = _d_[2];
      if(sexp_args_020 && ! sexp_args_020[2]){
       var
        arg0_021 = sexp_args_020[1],
        res0_022 = caml_call1(of_s_008, arg0_021);
       return [1, res0_022];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_011,
               tag_014,
               sexp_013);
     }
     var sexp_args_015 = _d_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_f_007, arg0_016);
      return [0, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_011,
              tag_014,
              sexp_013);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_011, sexp_013);
   }
   function sexp_of_t(of_f_025, of_s_026, param){
    if(0 === param[0]){
     var arg0_027 = param[1], res0_028 = caml_call1(of_f_025, arg0_027);
     return [1, [0, _a_, [0, res0_028, 0]]];
    }
    var arg0_029 = param[1], res0_030 = caml_call1(of_s_026, arg0_029);
    return [1, [0, _b_, [0, res0_030, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t, t_sexp_grammar];
   runtime.caml_register_global(15, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(_b_){return _b_;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var _a_ = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, _a_);
   }
   function updater(field){
    var match = field[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(field[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Import0, Base__Sys0, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Base_Import0 = global_data.Base__Import0,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Sys0 = global_data.Base__Sys0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol_concat = Base_Import0[112],
    capitalize = Stdlib_StringLabels[28],
    compare = Stdlib_StringLabels[10],
    escaped = Stdlib_StringLabels[25],
    lowercase = Stdlib_StringLabels[27],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[16],
    uncapitalize = Stdlib_StringLabels[29],
    unsafe_blit = runtime.caml_blit_string,
    uppercase = Stdlib_StringLabels[26],
    split_on_char = Stdlib_StringLabels[17];
   function concat(opt, l){
    var sep = opt ? opt[1] : cst$0;
    if(! l) return cst;
    if(l[2]) return caml_call2(Stdlib_StringLabels[7], sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){
    var
     _b_ = caml_call2(Base_Import0[93], runtime.caml_ml_string_length(t), 1),
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      caml_call1(f, runtime.caml_string_unsafe_get(t, i));
      var _c_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _c_;
     }
    }
    return 0;
   }
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol_concat,
       capitalize,
       compare,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       unsafe_blit,
       uppercase,
       split_on_char,
       concat,
       iter];
   runtime.caml_register_global(5, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__String0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Comparator = global_data.Base__Comparator,
    _a_ = [0, "pos_cnum"],
    _b_ = [0, "pos_bol"],
    _c_ = [0, "pos_lnum"],
    _d_ = [0, "pos_fname"];
   function compare(a_001, b_002){
    if(a_001 === b_002) return 0;
    var n = caml_call2(Base_Import[233], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[229], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[229], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[229], a_001[4], b_002[4]) : n$1;
   }
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[209], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[207], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[207], hsv$1, arg[3]);
    return caml_call2(Base_Import[207], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = caml_call1(Base_Import[140], pos_cnum_010),
     bnds_003 = [0, [1, [0, _a_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Base_Import[140], pos_bol_008),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_003],
     arg_007 = caml_call1(Base_Import[140], pos_lnum_006),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = caml_call1(Base_Import[137], pos_fname_004),
     bnds_003$2 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare, hash_fold_t, hash, sexp_of_t],
    compare$0 = T[1],
    hash_fold_t$0 = T[2],
    hash$0 = T[3],
    include = caml_call1(Base_Comparator[5], [0, T[1], T[4]]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     _e_ = caml_call2(Base_Import[93], pos_cnum, pos_bol),
     _f_ = [0, cst, [0, caml_call1(Base_Int0[1], _e_), 0]],
     _g_ =
       [0,
        pos_fname,
        [0, cst$0, [0, caml_call1(Base_Int0[1], pos_lnum), _f_]]];
    return caml_call2(Base_String0[14], 0, _g_);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare$0,
       hash_fold_t$0,
       hash$0,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (11, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    length = Base_List0[2],
    rev_append = Base_List0[3],
    tl_exn = Base_List0[4],
    unzip = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    sort = Base_List0[19],
    stable_sort = Base_List0[20],
    rev = Base_List0[21],
    fold_right = Base_List0[22],
    fold_right2_ok = Base_List0[23];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){
      var _a_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _a_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0]){
      var y = match[1], fst$0 = [0, y, fst];
      t$0 = t$1;
      fst = fst$0;
     }
     else{var y$0 = match[1], snd$0 = [0, y$0, snd]; t$0 = t$1; snd = snd$0;}
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right,
       fold_right2_ok,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Printf, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    _a_ = [0, cst_Ok$0],
    _b_ = [0, cst_Error$0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0;
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _e_ = sexp_007[1];
      b:
      if(_e_ !== cst_Error$0){
       if(_e_ !== cst_Ok$0){
        if(_e_ === cst_error) break b;
        if(_e_ !== cst_ok) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
     }
     var _f_ = sexp_007[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_007);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_007);
     var tag_008 = _g_[1];
     b:
     if(tag_008 !== cst_Error$0){
      if(tag_008 !== cst_Ok$0){
       if(tag_008 === cst_error) break b;
       if(tag_008 !== cst_ok) break a;
      }
      var sexp_args_009 = _f_[2];
      if(sexp_args_009 && ! sexp_args_009[2]){
       var
        arg0_010 = sexp_args_009[1],
        res0_011 = caml_call1(of_a_001, arg0_010);
       return [0, res0_011];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_005,
               tag_008,
               sexp_007);
     }
     var sexp_args_014 = _f_[2];
     if(sexp_args_014 && ! sexp_args_014[2]){
      var
       arg0_015 = sexp_args_014[1],
       res0_016 = caml_call1(of_b_002, arg0_015);
      return [1, res0_016];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_005,
              tag_008,
              sexp_007);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, _a_, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, _b_, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(a_027 === b_028) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(a_033 === b_034) return 1;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return 0;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 0;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   var globalize = Base_Import[265];
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$0(x){return [0, x];}
   var
    include = caml_call1(Base_Monad[6], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$2(e){return [1, e];}
   var
    Error = caml_call1(Base_Monad[6], [0, bind$1, map$1, return$2]),
    _c_ = [0, 0];
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? _c_ : [1, error];}
   function try_with(f){
    try{var _d_ = [0, caml_call1(f, 0)]; return _d_;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return caml_call1(Base_Import[124], str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = caml_call2(Base_List1[25], l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    return caml_call2(map$0, combine_errors(l), function(param){return 0;});
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       equal,
       globalize,
       hash_fold_t,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       to_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(20, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Continue_or_stop$0 = Export[1],
    Base_Container_intf = [0, Export, Continue_or_stop$0];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_List0 = global_data.Base__List0,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? caml_call2(Base_Import[91], n, 1) : n;
             });
   }
   function sum(fold, M, t, f){
    return caml_call3
            (fold,
             t,
             M[1],
             function(n, a){
              var _n_ = caml_call1(f, a);
              return caml_call2(M[2], n, _n_);
             });
   }
   function fold_result(fold, init, f, t){
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return caml_call1
            (with_return,
             function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return caml_call2(Base_Import[91], acc, 1);});
   }
   function is_empty(iter, c){
    return caml_call1
            (with_return,
             function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function mem(iter, c, x, equal){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(y){
                 var _m_ = caml_call2(equal, x, y);
                 return _m_ ? caml_call1(r, 1) : _m_;
                });
              return 0;
             });
   }
   function exists(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _l_ = caml_call1(f, x);
                 return _l_ ? caml_call1(r, 1) : _l_;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _k_ = 1 - caml_call1(f, x);
                 return _k_ ? caml_call1(r, 0) : _k_;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _j_ = caml_call1(f, x);
                 return _j_ ? caml_call1(r, [0, x]) : _j_;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var _i_ = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return caml_call1(Base_List0[21], _i_);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var _g_ = caml_call1(length, c);
        array[1] = caml_call2(Base_Array0[4], _g_, x);
       }
       var _h_ = i[1];
       runtime.caml_check_bound(array[1], _h_)[1 + _h_] = x;
       i[1]++;
       return 0;
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function mem$0(t, x, equal){return mem(iter$0, t, x, equal);}
    function sum$0(m, t){return function(_f_){return sum(fold, m, t, _f_);};}
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            mem$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   function Make_gen_with_creators(T){
    var
     include = Make_gen([0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list = T[4],
     of_array = T[5],
     concat = T[6],
     concat_of_array = T[7];
    function append(a, b){
     return caml_call1(concat, caml_call1(concat_of_array, [0, a, b]));
    }
    function concat_map(t, f){
     var _e_ = caml_call1(to_array, t);
     return caml_call1
             (concat,
              caml_call1(concat_of_array, caml_call2(Base_Array0[21], _e_, f)));
    }
    function filter_map(t, f){
     return concat_map
             (t,
              function(x){
               var match = caml_call1(f, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function map(t, f){
     return filter_map(t, function(x){return [0, caml_call1(f, x)];});
    }
    function filter(t, f){
     return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
    }
    function partition_map(t, f){
     var
      _c_ = caml_call1(to_array, t),
      array = caml_call2(Base_Array0[21], _c_, f),
      xs =
        caml_call3
         (Base_Array0[18],
          array,
          function(either, acc){
           if(0 !== either[0]) return acc;
           var x = either[1];
           return [0, x, acc];
          },
          0),
      ys =
        caml_call3
         (Base_Array0[18],
          array,
          function(either, acc){
           if(0 === either[0]) return acc;
           var x = either[1];
           return [0, x, acc];
          },
          0),
      _d_ = caml_call1(of_list, ys);
     return [0, caml_call1(of_list, xs), _d_];
    }
    function partition_tf(t, f){
     return partition_map
             (t, function(x){return caml_call1(f, x) ? [0, x] : [1, x];});
    }
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       mem,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         _b_ = include[3];
        function mem(t, x){return caml_call3(_b_, t, x, T[1][1]);}
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       Make_gen,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         of_list = T[4],
         of_array = T[5],
         concat = T[6],
         include =
           Make_gen_with_creators
            ([0, fold, iter, length, of_list, of_array, concat, of_array]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         of_list$0 = include[18],
         of_array$0 = include[19],
         append = include[20],
         concat$0 = include[21],
         map = include[22],
         filter = include[23],
         filter_map = include[24],
         concat_map = include[25],
         partition_tf = include[26],
         partition_map = include[27];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         of_list = T[5],
         of_array = T[6],
         concat = T[7],
         concat_of_array = Base_Array0[16],
         include =
           Make_gen_with_creators
            ([0,
              fold,
              iter,
              length,
              of_list,
              of_array,
              concat,
              concat_of_array]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         of_list$0 = include[18],
         of_array$0 = include[19],
         append = include[20],
         concat$0 = include[21],
         map = include[22],
         filter = include[23],
         filter_map = include[24],
         concat_map = include[25],
         partition_tf = include[26],
         partition_map = include[27],
         _a_ = include[3];
        function mem(t, x){return caml_call3(_a_, t, x, T[1][1]);}
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map];
       },
       Make_gen_with_creators];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Array0, Base__Container, Base__Import, Base__Indexed_container_intf, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Container = global_data.Base__Container,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold,
      t,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[91], i, 1);
      });
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){
              return caml_call2(f, i, a)
                      ? caml_call2(Base_Import[91], n, 1)
                      : n;
             });
   }
   function existsi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _h_ = caml_call2(f, i, x);
                 return _h_ ? caml_call1(r, 1) : _h_;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _g_ = 1 - caml_call2(f, i, x);
                 return _g_ ? caml_call1(r, 0) : _g_;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _f_ = caml_call2(f, i, x);
                 return _f_ ? caml_call1(r, [0, [0, i, x]]) : _f_;
                });
              return 0;
             });
   }
   function Make_gen_with_container(T, _e_){
    var
     length = _e_[1],
     is_empty = _e_[2],
     mem = _e_[3],
     iter = _e_[4],
     fold = _e_[5],
     fold_result = _e_[6],
     fold_until = _e_[7],
     exists = _e_[8],
     for_all = _e_[9],
     count = _e_[10],
     sum = _e_[11],
     find = _e_[12],
     find_map = _e_[13],
     to_list = _e_[14],
     to_array = _e_[15],
     min_elt = _e_[16],
     max_elt = _e_[17],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   function Make_gen(T){
    var
     C = caml_call1(Base_Container[19], [0, T[1], T[2], T[3]]),
     include = Make_gen_with_container(T, C),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   function Make_gen_with_creators(T){
    var
     C =
       caml_call1
        (Base_Container[22], [0, T[5], T[6], T[7], T[2], T[3], T[4], T[1]]),
     of_list = C[18],
     of_array = C[19],
     append = C[20],
     concat = C[21],
     map = C[22],
     filter = C[23],
     filter_map = C[24],
     concat_map = C[25],
     partition_tf = C[26],
     partition_map = C[27],
     include =
       Make_gen_with_container
        ([0, T[5], T[6], T[7], T[8], T[9]],
         [0,
          C[1],
          C[2],
          C[3],
          C[4],
          C[5],
          C[6],
          C[7],
          C[8],
          C[9],
          C[10],
          C[11],
          C[12],
          C[13],
          C[14],
          C[15],
          C[16],
          C[17]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    function derived_init(n, f){
     return caml_call1(of_array, caml_call2(Base_Array0[12], n, f));
    }
    var match = T[10];
    if(typeof match === "number")
     var derived_init$0 = derived_init;
    else
     var init = match[2], derived_init$0 = init;
    function derived_concat_mapi(t, f){
     var
      _c_ = caml_call1(to_array, t),
      _d_ = caml_call2(Base_Array0[22], _c_, f);
     return caml_call1(concat, caml_call1(T[1], _d_));
    }
    var match$0 = T[11];
    if(typeof match$0 === "number")
     var concat_mapi = derived_concat_mapi;
    else
     var concat_mapi$0 = match$0[2], concat_mapi = concat_mapi$0;
    function filter_mapi(t, f){
     return caml_call2
             (concat_mapi,
              t,
              function(i, x){
               var match = caml_call2(f, i, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function mapi(t, f){
     return filter_mapi(t, function(i, x){return [0, caml_call2(f, i, x)];});
    }
    function filteri(t, f){
     return filter_mapi
             (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
    }
    return [0,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            derived_init$0,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         foldi$0 = include[18],
         iteri$0 = include[19],
         existsi = include[20],
         for_alli = include[21],
         counti = include[22],
         findi = include[23],
         find_mapi = include[24];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         iteri = T[5],
         foldi = T[6],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         foldi$0 = include[18],
         iteri$0 = include[19],
         existsi = include[20],
         for_alli = include[21],
         counti = include[22],
         findi = include[23],
         find_mapi = include[24],
         _b_ = include[3];
        function mem(t, x){return caml_call3(_b_, t, x, T[1][1]);}
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       Make_gen,
       function(T){
        var
         of_list = T[1],
         of_array = T[2],
         concat = T[3],
         fold = T[4],
         iter = T[5],
         length = T[6],
         iteri = T[7],
         foldi = T[8],
         init = T[9],
         concat_mapi = T[10],
         include =
           Make_gen_with_creators
            ([0,
              of_array,
              of_list,
              of_array,
              concat,
              fold,
              iter,
              length,
              iteri,
              foldi,
              init,
              concat_mapi]),
         of_list$0 = include[1],
         of_array$0 = include[2],
         append = include[3],
         concat$0 = include[4],
         map = include[5],
         filter = include[6],
         filter_map = include[7],
         concat_map = include[8],
         partition_tf = include[9],
         partition_map = include[10],
         length$0 = include[11],
         is_empty = include[12],
         mem = include[13],
         iter$0 = include[14],
         fold$0 = include[15],
         fold_result = include[16],
         fold_until = include[17],
         exists = include[18],
         for_all = include[19],
         count = include[20],
         sum = include[21],
         find = include[22],
         find_map = include[23],
         to_list = include[24],
         to_array = include[25],
         min_elt = include[26],
         max_elt = include[27],
         foldi$0 = include[28],
         iteri$0 = include[29],
         existsi = include[30],
         for_alli = include[31],
         counti = include[32],
         findi = include[33],
         find_mapi = include[34],
         init$0 = include[35],
         mapi = include[36],
         filteri = include[37],
         filter_mapi = include[38],
         concat_mapi$0 = include[39];
        return [0,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi,
                init$0,
                mapi,
                filteri,
                filter_mapi,
                concat_mapi$0];
       },
       function(T){
        var
         of_list = T[2],
         of_array = T[3],
         concat = T[4],
         fold = T[5],
         iter = T[6],
         length = T[7],
         iteri = T[8],
         foldi = T[9],
         init = T[10],
         concat_mapi = T[11],
         concat_of_array = Base_Array0[16],
         include =
           Make_gen_with_creators
            ([0,
              concat_of_array,
              of_list,
              of_array,
              concat,
              fold,
              iter,
              length,
              iteri,
              foldi,
              init,
              concat_mapi]),
         of_list$0 = include[1],
         of_array$0 = include[2],
         append = include[3],
         concat$0 = include[4],
         map = include[5],
         filter = include[6],
         filter_map = include[7],
         concat_map = include[8],
         partition_tf = include[9],
         partition_map = include[10],
         length$0 = include[11],
         is_empty = include[12],
         iter$0 = include[14],
         fold$0 = include[15],
         fold_result = include[16],
         fold_until = include[17],
         exists = include[18],
         for_all = include[19],
         count = include[20],
         sum = include[21],
         find = include[22],
         find_map = include[23],
         to_list = include[24],
         to_array = include[25],
         min_elt = include[26],
         max_elt = include[27],
         foldi$0 = include[28],
         iteri$0 = include[29],
         existsi = include[30],
         for_alli = include[31],
         counti = include[32],
         findi = include[33],
         find_mapi = include[34],
         init$0 = include[35],
         mapi = include[36],
         filteri = include[37],
         filter_mapi = include[38],
         concat_mapi$0 = include[39],
         _a_ = include[13];
        function mem(t, x){return caml_call3(_a_, t, x, T[1][1]);}
        return [0,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi,
                init$0,
                mapi,
                filteri,
                filter_mapi,
                concat_mapi$0];
       },
       Make_gen_with_creators];
   runtime.caml_register_global
    (4, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[193], a_sexp_grammar);
   }
   function compare(compare_a, t1, t2){
    if(caml_call2(Base_Import[128], t1, t2)) return 0;
    var _q_ = caml_obj_tag(t2);
    a:
    if(250 === _q_)
     var _r_ = t2[1];
    else{
     if(246 !== _q_ && 244 !== _q_){var _r_ = t2; break a;}
     var _r_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _s_ = caml_obj_tag(t1);
    a:
    if(250 === _s_)
     var _t_ = t1[1];
    else{
     if(246 !== _s_ && 244 !== _s_){var _t_ = t1; break a;}
     var _t_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(compare_a, _t_, _r_);
   }
   function equal(equal_a, t1, t2){
    if(caml_call2(Base_Import[128], t1, t2)) return 1;
    var _m_ = caml_obj_tag(t2);
    a:
    if(250 === _m_)
     var _n_ = t2[1];
    else{
     if(246 !== _m_ && 244 !== _m_){var _n_ = t2; break a;}
     var _n_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _o_ = caml_obj_tag(t1);
    a:
    if(250 === _o_)
     var _p_ = t1[1];
    else{
     if(246 !== _o_ && 244 !== _o_){var _p_ = t1; break a;}
     var _p_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(equal_a, _p_, _n_);
   }
   var hash_fold_t = Base_Hash[13][12];
   function peek(t){
    if(! caml_call1(is_val, t)) return 0;
    var _k_ = caml_obj_tag(t);
    a:
    if(250 === _k_)
     var _l_ = t[1];
    else{
     if(246 !== _k_ && 244 !== _k_){var _l_ = t; break a;}
     var _l_ = caml_call1(CamlinternalLazy[2], t);
    }
    return [0, _l_];
   }
   function return$0(x){return caml_call1(from_val, x);}
   function bind(t, f){
    return [246,
            function(_f_){
             var _g_ = caml_obj_tag(t);
             a:
             if(250 === _g_)
              var _h_ = t[1];
             else{
              if(246 !== _g_ && 244 !== _g_){var _h_ = t; break a;}
              var _h_ = caml_call1(CamlinternalLazy[2], t);
             }
             var _i_ = caml_call1(f, _h_), _j_ = caml_obj_tag(_i_);
             if(250 === _j_) return _i_[1];
             if(246 !== _j_ && 244 !== _j_) return _i_;
             return caml_call1(CamlinternalLazy[2], _i_);
            }];
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return [246,
                function(_c_){
                 var _d_ = caml_obj_tag(t);
                 a:
                 if(250 === _d_)
                  var _e_ = t[1];
                 else{
                  if(246 !== _d_ && 244 !== _d_){var _e_ = t; break a;}
                  var _e_ = caml_call1(CamlinternalLazy[2], t);
                 }
                 return caml_call1(f, _e_);
                }];
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_unforced_lazy = "<unforced lazy>";
   function sexp_of_t$0(sexp_of_a, t){
    if(! caml_call1(is_val, t))
     return caml_call1(Base_Import[137], cst_unforced_lazy);
    var _a_ = caml_obj_tag(t);
    a:
    if(250 === _a_)
     var _b_ = t[1];
    else{
     if(246 !== _a_ && 244 !== _a_){var _b_ = t; break a;}
     var _b_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(sexp_of_a, _b_);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       peek,
       T_unforcing];
   runtime.caml_register_global(6, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    _b_ =
      [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    _c_ =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call3(invalid_argf, _a_, pos, 0);
    if(len < 0) caml_call3(invalid_argf, _b_, len, 0);
    var _h_ = caml_call2(Base_Import[93], total_length, len) < pos ? 1 : 0;
    return _h_
            ? caml_call5(invalid_argf, _c_, pos, len, total_length, 0)
            : _h_;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = caml_call2(Base_Import[91], pos, len),
     _d_ = caml_call2(Base_Import[93], total_length, stop),
     _e_ = caml_call2(Base_Import[118], pos, len),
     _f_ = caml_call2(Base_Import[118], _e_, stop),
     _g_ = caml_call2(Base_Import[118], _f_, _d_) < 0 ? 1 : 0;
    return _g_ ? slow_check_pos_len_exn(pos, len, total_length) : _g_;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    var pos = opt ? opt[1] : 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: CamlinternalLazy, Stdlib__Bigarray, Stdlib__Domain, Stdlib__Lazy, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy;
   function of_state(_e_){return _e_;}
   var Repr = [0, of_state];
   function assign(dst, src){
    var _a_ = caml_obj_tag(dst);
    a:
    if(250 === _a_)
     var _b_ = dst[1];
    else{
     if(246 !== _a_ && 244 !== _a_){var _b_ = dst; break a;}
     var _b_ = caml_call1(CamlinternalLazy[2], dst);
    }
    var dst$0 = caml_call1(Repr[1], _b_), _c_ = caml_obj_tag(src);
    a:
    if(250 === _c_)
     var _d_ = src[1];
    else{
     if(246 !== _c_ && 244 !== _c_){var _d_ = src; break a;}
     var _d_ = caml_call1(CamlinternalLazy[2], src);
    }
    var src$0 = caml_call1(Repr[1], _d_);
    return runtime.caml_ba_blit(src$0, dst$0);
   }
   function make_default(default$0){
    function split_from_parent(v){
     return caml_call2(Stdlib_Lazy[5], Stdlib_Random[19][19], v);
    }
    return caml_call2
            (Stdlib_Domain[10][1],
             [0, split_from_parent],
             function(param){return default$0;});
   }
   function get_state(random_key){
    return caml_call1(Stdlib_Domain[10][2], random_key);
   }
   var Base_Random_repr = [0, Repr, assign, make_default, get_state];
   runtime.caml_register_global(4, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Lazy, Base__Printf, Base__Random_repr, Base__Word_size, CamlinternalLazy, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Lazy = global_data.Base__Lazy,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests",
    dummy = 0;
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var _M_ = Base_Import[130];
    if(! _M_) return _M_;
    if(allow_in_tests && allow_in_tests[1]) return;
    return caml_call1(Base_Import[124], cst_initializing_Random_with_a);
   }
   function bits(t){
    var _K_ = caml_obj_tag(t);
    a:
    if(250 === _K_)
     var _L_ = t[1];
    else{
     if(246 !== _K_ && 244 !== _K_){var _L_ = t; break a;}
     var _L_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(Stdlib_Random[19][4], _L_);
   }
   function bool(t){
    var _I_ = caml_obj_tag(t);
    a:
    if(250 === _I_)
     var _J_ = t[1];
    else{
     if(246 !== _I_ && 244 !== _I_){var _J_ = t; break a;}
     var _J_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(Stdlib_Random[19][15], _J_);
   }
   function int$0(t, x){
    var _G_ = caml_obj_tag(t);
    a:
    if(250 === _G_)
     var _H_ = t[1];
    else{
     if(246 !== _G_ && 244 !== _G_){var _H_ = t; break a;}
     var _H_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[19][5], _H_, x);
   }
   function int32(t, x){
    var _E_ = caml_obj_tag(t);
    a:
    if(250 === _E_)
     var _F_ = t[1];
    else{
     if(246 !== _E_ && 244 !== _E_){var _F_ = t; break a;}
     var _F_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[19][8], _F_, x);
   }
   function int64(t, x){
    var _C_ = caml_obj_tag(t);
    a:
    if(250 === _C_)
     var _D_ = t[1];
    else{
     if(246 !== _C_ && 244 !== _C_){var _D_ = t; break a;}
     var _D_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[19][12], _D_, x);
   }
   function nativeint(t, x){
    var _A_ = caml_obj_tag(t);
    a:
    if(250 === _A_)
     var _B_ = t[1];
    else{
     if(246 !== _A_ && 244 !== _A_){var _B_ = t; break a;}
     var _B_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[19][10], _B_, x);
   }
   function make(seed){
    var _z_ = caml_call1(Stdlib_Random[19][1], seed);
    return caml_call1(Base_Lazy[21], _z_);
   }
   function copy(t){
    var _w_ = caml_obj_tag(t);
    a:
    if(250 === _w_)
     var _x_ = t[1];
    else{
     if(246 !== _w_ && 244 !== _w_){var _x_ = t; break a;}
     var _x_ = caml_call1(CamlinternalLazy[2], t);
    }
    var _y_ = caml_call1(Stdlib_Random[19][3], _x_);
    return caml_call1(Base_Lazy[21], _y_);
   }
   function char$0(t){
    var _v_ = int$0(t, 256);
    return caml_call1(Base_Char0[5], _v_);
   }
   function ascii(t){
    var _u_ = int$0(t, 128);
    return caml_call1(Base_Char0[5], _u_);
   }
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    var _t_ = caml_call1(Stdlib_Random[19][2], 0);
    return caml_call1(Base_Lazy[21], _t_);
   }
   var
    assign = Base_Random_repr[2],
    cst_float = "float",
    cst_int64 = "int64",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    _a_ =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"];
   if(Base_Import[130]){
    var t = caml_call1(Stdlib_Random[20], 0);
    caml_call1(Stdlib_Random[1], 137);
    var default$0 = caml_call1(Base_Lazy[21], t);
   }
   else
    var
     default$0 =
       [246,
        function(param){
         var _r_ = make_self_init(0, 0), _s_ = caml_obj_tag(_r_);
         if(250 === _s_) return _r_[1];
         if(246 !== _s_ && 244 !== _s_) return _r_;
         return caml_call1(CamlinternalLazy[2], _r_);
        }];
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int$0(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int$0(t, bound);
   }
   var int$1 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     _p_ = caml_int64_shift_left(bits$0(state), 60),
     _q_ = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), _p_);
    return caml_int64_xor(bits$0(state), _q_);
   }
   function full_range_int32(state){
    var _o_ = bits(state) << 30;
    return bits(state) ^ _o_;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int_on_64bits$0 =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     _m_ = caml_call1(string_of_bound, upper_bound),
     _n_ = caml_call1(string_of_bound, lower_bound);
    return caml_call5(Base_Printf[6], _a_, name, _n_, _m_, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = caml_call2(Base_Import[93], hi, lo);
    if(diff === Base_Int0[6]){
     var
      _i_ = Base_Int0[6],
      _j_ = full_range_int_on_64bits$0(state),
      _k_ = caml_call2(Base_Import[116], _j_, _i_);
     return caml_call2(Base_Import[91], lo, _k_);
    }
    if(0 <= diff){
     var _l_ = int$1(state, caml_call1(Base_Int0[8], diff));
     return caml_call2(Base_Import[91], lo, _l_);
    }
    for(;;){
     var int$0 = full_range_int_on_64bits$0(state);
     if(lo <= int$0 && int$0 <= hi) return int$0;
    }
   }
   function int32_incl(state, lo, hi){
    if(caml_call2(Base_Import[102][5], lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[102][4], diff, Stdlib_Int32[9])){
     var _h_ = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & _h_) | 0;
    }
    if(caml_call2(Base_Import[102][6], diff, 0))
     return lo + int32(state, caml_call1(Stdlib_Int32[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_int32(state);
     if
      (caml_call2(Base_Import[102][6], int$0, lo)
       && caml_call2(Base_Import[102][2], int$0, hi))
      return int$0;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(caml_call2(Base_Import[104][5], lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[104][4], diff, Stdlib_Nativeint[10])){
     var _g_ = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & _g_) | 0;
    }
    if(caml_call2(Base_Import[104][6], diff, 0))
     return lo + nativeint(state, caml_call1(Stdlib_Nativeint[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_nativeint(state);
     if
      (caml_call2(Base_Import[104][6], int$0, lo)
       && caml_call2(Base_Import[104][2], int$0, hi))
      return int$0;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var _f_ = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), _f_));
    }
    if(caml_greaterequal(diff, _b_))
     return caml_int64_add
             (lo, int64(state, caml_call1(Stdlib_Int64[6], diff)));
    for(;;){
     var int$0 = full_range_int64(state);
     if(caml_greaterequal(int$0, lo) && runtime.caml_lessequal(int$0, hi))
      return int$0;
    }
   }
   function float$0(state, hi){
    for(;;){
     var
      scale = 9.313225746154785e-10,
      r1 = bits(state),
      r2 = bits(state),
      _d_ = caml_call2(Base_Import[90], r1, scale),
      _e_ = caml_call2(Base_Import[92], _d_, r2),
      result = caml_call2(Base_Import[90], _e_, scale);
     if(caml_call2(Base_Import[108][1], result, 1.))
      return caml_call2(Base_Import[90], result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(caml_call2(Base_Import[108][5], lo, hi))
     raise_crossed_bounds(cst_float, lo, hi, Base_Import[85][35]);
    var _c_ = float$0(state, caml_call2(Base_Import[94], hi, lo));
    return caml_call2(Base_Import[92], lo, _c_);
   }
   var default$1 = caml_call1(Base_Random_repr[3], default$0);
   function bits$1(param){
    return bits(caml_call1(Base_Random_repr[4], default$1));
   }
   function int$2(x){
    return int$1(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int32$0(x){
    return int32(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function nativeint$0(x){
    return nativeint(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int64$0(x){
    return int64(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function float$1(x){
    return float$0(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int_incl$0(x, y){
    return int_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int32_incl$0(x, y){
    return int32_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function nativeint_incl$0(x, y){
    return nativeint_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int64_incl$0(x, y){
    return int64_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function float_range$0(x, y){
    return float_range(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function bool$0(param){
    return bool(caml_call1(Base_Random_repr[4], default$1));
   }
   function char$1(param){
    return char$0(caml_call1(Base_Random_repr[4], default$1));
   }
   function ascii$0(param){
    return ascii(caml_call1(Base_Random_repr[4], default$1));
   }
   function full_init(seed){
    var t = caml_call1(Base_Random_repr[4], default$1);
    return caml_call2(assign, t, make(seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return caml_call2(assign, caml_call1(Base_Random_repr[4], default$1), s);
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$1,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       [0,
        default$0,
        make,
        make_self_init,
        copy,
        bits,
        int$1,
        int32,
        nativeint,
        int64,
        float$0,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char$0,
        ascii],
       set_state];
   runtime.caml_register_global(24, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    blit = Base_Array0[8],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24];
   function permute(_a_, opt, len, t){
    var
     random_state = _a_ ? _a_[1] : Base_Random[18][1],
     pos = opt ? opt[1] : 0,
     total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    caml_call3(Base_Ordered_collection_common[2], pos, len$0, total_length);
    var num_swaps = caml_call2(Base_Import[93], len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = caml_call2(Base_Import[91], pos, i),
       _b_ = caml_call2(Base_Import[91], i, 1),
       _c_ = caml_call2(Base_Random[18][6], random_state, _b_),
       random_i = caml_call2(Base_Import[91], pos, _c_);
      caml_call3(swap, t, this_i, random_i);
      var _d_ = i - 1 | 0;
      if(1 === i) break;
      i = _d_;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare = caml_int_compare,
    _a_ = [0, cst_Less],
    _b_ = [0, cst_Equal],
    _c_ = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _d_ = sexp_006[1];
      b:
      if(_d_ !== cst_Equal){
       c:
       if(_d_ !== cst_Greater){
        if(_d_ !== cst_Less){
         if(_d_ === cst_equal) break b;
         if(_d_ === cst_greater) break c;
         if(_d_ !== cst_less) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var _e_ = sexp_006[1];
     if(! _e_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     var _f_ = _e_[1];
     if(0 !== _f_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_006);
     var _g_ = _f_[1];
     b:
     if(_g_ !== cst_Equal){
      c:
      if(_g_ !== cst_Greater){
       if(_g_ !== cst_Less){
        if(_g_ === cst_equal) break b;
        if(_g_ === cst_greater) break c;
        if(_g_ !== cst_less) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[19],
    getenv = Base_Sys0[20],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Printf, Base__Random, Base__Result, Base__Sys, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    error_source_032 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Sys = global_data.Base__Sys,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    length = Base_List1[2],
    rev_append = Base_List1[3],
    tl_exn = Base_List1[4],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold_left = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    nontail_map = Base_List1[14],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    sort = Base_List1[19],
    stable_sort = Base_List1[20],
    rev = Base_List1[21],
    fold_right = Base_List1[22],
    fold_right2_ok = Base_List1[23],
    is_empty = Base_List1[24],
    partition_map = Base_List1[25],
    invalid_argf = Base_Printf[7],
    globalize = Base_Import[263],
    t_of_sexp = Base_Import[174],
    sexp_of_t = Base_Import[150],
    _a_ = [0, "Ok"],
    _b_ = [0, "Unequal_lengths"];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[195], a_sexp_grammar);
   }
   function compare(cmp_a, a_010, b_011){
    if(a_010 === b_011) return 0;
    if(! a_010) return b_011 ? 1 : 0;
    var a_012 = a_010[1];
    if(! b_011) return -1;
    var b_013 = b_011[1];
    return caml_call2(cmp_a, a_012, b_013);
   }
   function sexp_of_t$0(of_a_014, param){
    if(! param) return _b_;
    var arg0_015 = param[1], res0_016 = caml_call1(of_a_014, arg0_015);
    return [1, [0, _a_, [0, res0_016, 0]]];
   }
   var
    Or_unequal_lengths = [0, compare, sexp_of_t$0],
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    cst_List_range_stride_function$0 =
      "List.range': stride function cannot change direction",
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    _c_ =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    _d_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _e_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    cst_iter2_exn = "iter2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_fold_right2_exn = "fold_right2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_exists2_exn = "exists2_exn";
   function invariant(f, t){return caml_call2(iter, t, f);}
   function of_list(t){return t;}
   function range(compare, stride, _aT_, opt, start_i, stop_i){
    var
     start = _aT_ ? _aT_[1] : 104758188,
     stop = opt ? opt[1] : -160346914,
     next_i = caml_call1(stride, start_i);
    function order(x, y){
     var _aV_ = caml_call2(compare, x, y);
     return caml_call1(Base_Ordering[9], _aV_);
    }
    function raise_stride_cannot_return_sam(param){
     return caml_call1(Base_Import[126], cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i = start_i$0,
     accum = 0;
    for(;;){
     var i_to_stop_order = order(i, stop_i);
     a:
     {
      b:
      {
       switch(i_to_stop_order){
         case 0:
          if(847855481 > initial_stride_order) break b; break;
         case 1:
          if(104758188 <= stop){var _aU_ = [0, i, accum]; break a;}
          var _aU_ = accum;
          break a;
         default: if(847855481 <= initial_stride_order) break b;
       }
       var next_i$0 = caml_call1(stride, i);
       c:
       {
        switch(order(i, next_i$0)){
          case 0:
           if(847855481 > initial_stride_order) break c; break;
          case 1:
           var _aU_ = raise_stride_cannot_return_sam(0); break a;
          default: if(847855481 <= initial_stride_order) break c;
        }
        var accum$0 = [0, i, accum];
        i = next_i$0;
        accum = accum$0;
        continue;
       }
       var
        _aU_ = caml_call1(Base_Import[126], cst_List_range_stride_function$0);
       break a;
      }
      var _aU_ = accum;
     }
     return caml_call1(rev, _aU_);
    }
   }
   function range$0(_aS_, _aR_, opt, start_i, stop_i){
    var
     stride = _aS_ ? _aS_[1] : 1,
     start = _aR_ ? _aR_[1] : 104758188,
     stop = opt ? opt[1] : -160346914;
    if(0 === stride)
     caml_call1(Base_Import[126], cst_List_range_stride_must_be_);
    return range
            (runtime.caml_int_compare,
             function(x){return caml_call2(Base_Import[91], x, stride);},
             [0, start],
             [0, stop],
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = caml_call2(Base_Import[93], n$0, 1);
     t$0 = t$1;
     n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(! match)
     return caml_call4(invalid_argf, _c_, n, caml_call1(length, t), 0);
    var a = match[1];
    return a;
   }
   function unordered_append(l1, l2){
    if(l1){
     if(l2) return caml_call2(rev_append, l1, l2);
     var l = l1;
    }
    else
     var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1);
       a = a$0;
       b = b$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aO_ = caml_call1(length, tail_of_b),
     _aP_ = caml_call2(Base_Import[91], shared_length, _aO_),
     _aQ_ = caml_call1(length, tail_of_a);
    return caml_call5
            (invalid_argf,
             _d_,
             name,
             caml_call2(Base_Import[91], shared_length, _aQ_),
             _aP_,
             0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1);
       a = a$0;
       b = b$0;
       c = c$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aL_ = caml_call1(length, tail_of_a),
     n1 = caml_call2(Base_Import[91], shared_length, _aL_),
     _aM_ = caml_call1(length, tail_of_b),
     n2 = caml_call2(Base_Import[91], shared_length, _aM_),
     _aN_ = caml_call1(length, tail_of_c),
     n3 = caml_call2(Base_Import[91], shared_length, _aN_);
    return caml_call7(invalid_argf, _e_, name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aI_){
              var _aJ_ = caml_call1(iter2_ok, _aI_);
              return function(_aK_){return caml_call2(_aJ_, _aK_, f);};
             });
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return caml_call3(iter2_ok, l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aF_){
              var _aG_ = caml_call1(rev_map2_ok, _aF_);
              return function(_aH_){return caml_call2(_aG_, _aH_, f);};
             });
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return caml_call3(rev_map2_ok, l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(_aC_){
              var _aD_ = caml_call1(fold2_ok, _aC_);
              return function(_aE_){return caml_call3(_aD_, _aE_, init, f);};
             });
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return caml_call4(fold2_ok, l1, l2, init, f);
   }
   function fold_right2(l1, l2, f, init){
    return check_length2
            (l1,
             l2,
             function(_az_){
              var _aA_ = caml_call1(fold_right2_ok, _az_);
              return function(_aB_){return caml_call3(_aA_, _aB_, f, init);};
             });
   }
   function fold_right2_exn(l1, l2, f, init){
    check_length2_exn(cst_fold_right2_exn, l1, l2);
    return caml_call4(fold_right2_ok, l1, l2, f, init);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aw_){
              var _ax_ = caml_call1(for_all2_ok, _aw_);
              return function(_ay_){return caml_call2(_ax_, _ay_, f);};
             });
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return caml_call3(for_all2_ok, l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_at_){
              var _au_ = caml_call1(exists2_ok, _at_);
              return function(_av_){return caml_call2(_au_, _av_, f);};
             });
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return caml_call3(exists2_ok, l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], _as_ = caml_call2(equal, a, b);
     if(_as_) return _as_;
     param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)){
      var accu$0 = [0, x, accu];
      accu = accu$0;
      param = l;
     }
     else
      param = l;
    }
   }
   function filter(t, f){return caml_call1(rev, rev_filter(t, f));}
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     param = l;
    }
   }
   var not_found = [0, Base_Import[267], [0, "List.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     param = l;
    }
   }
   var not_found$0 = [0, Base_Import[267], [0, "List.find_exn: not found"]];
   function find_exn(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$1 = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return x;
     t$0 = t$1;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[267], [0, "List.findi_exn: not found"]];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var
    not_found$2 = [0, Base_Import[267], [0, "List.find_mapi_exn: not found"]];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], _ar_ = caml_call2(f, i, hd);
     if(! _ar_) return _ar_;
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], _aq_ = caml_call2(f, i, hd);
     if(_aq_) return _aq_;
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   var of_array = Base_Array0[16], to_array = Base_Array0[14];
   function to_list(t){return t;}
   var
    cst_List_last = "List.last",
    _q_ = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    _r_ = [0, cst_src_list_ml, 1387, 13],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list",
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list",
    _p_ =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_sub = "List.sub",
    _n_ = [0, cst_src_list_ml, 1127, 12],
    _m_ = [1, 0],
    _l_ = [1, 0],
    _k_ = [1, 0],
    _j_ = [0, cst_src_list_ml, 951, 4],
    _i_ = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn",
    _h_ = [0, cst_src_list_ml, 678, 14],
    cst_List_reduce_exn = "List.reduce_exn",
    _g_ =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_map3_exn = "map3_exn",
    cst_rev_map3_exn = "rev_map3_exn",
    _f_ = [0, cst_src_list_ml, 545, 11],
    cst_map2_exn = "map2_exn",
    _o_ = [0, "List.Assoc.find_exn: not found"],
    cst_Base_List_Transpose_got_li =
      "Base__List.Transpose_got_lists_of_different_lengths",
    max_non_tailcall = typeof Base_Sys[8] === "number" ? 1000 : 50;
   function count_append(l1, l2, count){
    if(! l2) return l1;
    if(! l1) return l2;
    var _am_ = l1[2], x1 = l1[1];
    if(! _am_) return [0, x1, l2];
    var _an_ = _am_[2], x2 = _am_[1];
    if(! _an_) return [0, x1, [0, x2, l2]];
    var _ao_ = _an_[2], x3 = _an_[1];
    if(! _ao_) return [0, x1, [0, x2, [0, x3, l2]]];
    var match = _ao_[2], x4 = _ao_[1];
    if(! match) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match[2],
     x5 = match[1],
     _ap_ =
       max_non_tailcall < count
        ? caml_call2(rev_append, caml_call1(rev, tl), l2)
        : count_append(tl, l2, caml_call2(Base_Import[91], count, 1));
    return [0, x1, [0, x2, [0, x3, [0, x4, [0, x5, _ap_]]]]];
   }
   function append(l1, l2){return count_append(l1, l2, 0);}
   function count_map(f, l, ctr){
    if(! l) return 0;
    var _ai_ = l[2], x1$0 = l[1];
    if(! _ai_){var f1$3 = caml_call1(f, x1$0); return [0, f1$3, 0];}
    var _aj_ = _ai_[2], x2$0 = _ai_[1];
    if(! _aj_){
     var f1$2 = caml_call1(f, x1$0), f2$2 = caml_call1(f, x2$0);
     return [0, f1$2, [0, f2$2, 0]];
    }
    var _ak_ = _aj_[2], x3$0 = _aj_[1];
    if(! _ak_){
     var
      f1$1 = caml_call1(f, x1$0),
      f2$1 = caml_call1(f, x2$0),
      f3$1 = caml_call1(f, x3$0);
     return [0, f1$1, [0, f2$1, [0, f3$1, 0]]];
    }
    var match$1 = _ak_[2], x4$0 = _ak_[1];
    if(! match$1){
     var
      f1$0 = caml_call1(f, x1$0),
      f2$0 = caml_call1(f, x2$0),
      f3$0 = caml_call1(f, x3$0),
      f4$0 = caml_call1(f, x4$0);
     return [0, f1$0, [0, f2$0, [0, f3$0, [0, f4$0, 0]]]];
    }
    var
     tl = match$1[2],
     x5$0 = match$1[1],
     f1 = caml_call1(f, x1$0),
     f2 = caml_call1(f, x2$0),
     f3 = caml_call1(f, x3$0),
     f4 = caml_call1(f, x4$0),
     f5 = caml_call1(f, x5$0);
    if(max_non_tailcall < ctr){
     a:
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            var bs$0 = 0, xs = tl;
            for(;;){
             if(! xs) break a;
             var _ab_ = xs[2];
             if(! _ab_) break;
             var _ac_ = _ab_[2];
             if(! _ac_) break h;
             var _ad_ = _ac_[2];
             if(! _ad_) break g;
             var _ae_ = _ad_[2];
             if(! _ae_) break f;
             var _af_ = _ae_[2];
             if(! _af_) break e;
             var _ag_ = _af_[2];
             if(! _ag_) break d;
             var _ah_ = _ag_[2];
             if(! _ah_) break c;
             var match$0 = _ah_[2];
             if(! match$0) break b;
             var
              xs$0 = match$0[2],
              x8 = match$0[1],
              x7 = _ah_[1],
              x6 = _ag_[1],
              x5 = _af_[1],
              x4 = _ae_[1],
              x3 = _ad_[1],
              x2 = _ac_[1],
              x1 = _ab_[1],
              x0 = xs[1],
              y0$0 = caml_call1(f, x0),
              y1$0 = caml_call1(f, x1),
              y2$0 = caml_call1(f, x2),
              y3$0 = caml_call1(f, x3),
              y4$0 = caml_call1(f, x4),
              y5$0 = caml_call1(f, x5),
              y6$0 = caml_call1(f, x6),
              y7$0 = caml_call1(f, x7),
              y8$0 = caml_call1(f, x8),
              bs$1 =
                [0,
                 [0, y0$0, y1$0, y2$0, y3$0, y4$0, y5$0, y6$0, y7$0, y8$0],
                 bs$0];
             bs$0 = bs$1;
             xs = xs$0;
            }
            break a;
           }
           break a;
          }
          break a;
         }
         break a;
        }
        break a;
       }
       break a;
      }
      break a;
     }
     var ys$0 = caml_call2(nontail_map, xs, f), res = ys$0, param = bs$0;
     for(;;){
      if(! param){var _al_ = res; break;}
      var
       bs = param[2],
       match = param[1],
       y8 = match[9],
       y7 = match[8],
       y6 = match[7],
       y5 = match[6],
       y4 = match[5],
       y3 = match[4],
       y2 = match[3],
       y1 = match[2],
       y0 = match[1],
       ys =
         [0,
          y0,
          [0,
           y1,
           [0, y2, [0, y3, [0, y4, [0, y5, [0, y6, [0, y7, [0, y8, res]]]]]]]]];
      res = ys;
      param = bs;
     }
    }
    else
     var _al_ = count_map(f, tl, caml_call2(Base_Import[91], ctr, 1));
    return [0, f1, [0, f2, [0, f3, [0, f4, [0, f5, _al_]]]]];
   }
   function map(l, f){return count_map(f, l, 0);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    return caml_call1(rev, caml_call3(rev_map2_ok, l1, l2, f));
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_$_){
              return function(_aa_){return map2_ok(_$_, _aa_, f);};
             });
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f, x1, x2, x3), ac];
       l1$0 = l1$1;
       l2$0 = l2$1;
       l3$0 = l3$1;
       ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_Y_){
              return function(_Z_){
               return function(___){return rev_map3_ok(_Y_, _Z_, ___, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    return caml_call1(rev, rev_map3_ok(l1, l2, l3, f));
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_V_){
              return function(_W_){
               return function(_X_){return map3_ok(_V_, _W_, _X_, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], h = l1$0[1], l2$1 = [0, caml_call1(f, h), l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function unzip(list){
    var list$2 = caml_call1(rev, list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function unzip3(list){
    var
     list$2 = caml_call1(rev, list),
     list$0 = list$2,
     l1 = 0,
     l2 = 0,
     l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
     l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{
     var _T_ = map2_ok(l1, l2, function(a, b){return [0, a, b];});
     return _T_;
    }
    catch(_U_){
     var _S_ = caml_call1(length, l2);
     return caml_call4(invalid_argf, _g_, caml_call1(length, l1), _S_, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     acc = acc$0;
     param = t;
    }
   }
   function mapi(l, f){return caml_call1(rev, rev_mapi(l, f));}
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    caml_call3
     (fold_left,
      l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[91], i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     _Q_ =
       caml_call3
        (fold_left,
         t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], _R_ = caml_call3(f, i, acc, v);
          return [0, caml_call2(Base_Import[91], i, 1), _R_];
         });
    return caml_call1(Base_Import[127], _Q_);
   }
   function filteri(l, f){
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(pos, acc, x){
                return caml_call2(f, pos, x) ? [0, x, acc] : acc;
               }));
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, caml_call3(fold_left, tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return caml_call1(Base_Import[126], cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num, acc, x){
     var num$0 = num, acc$0 = acc, x$0 = x;
     for(;;){
      if(0 === caml_call2(Base_Import[116], num$0, 1)) return [0, x$0, acc$0];
      if(! acc$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      var
       acc$1 = acc$0[2],
       y = acc$0[1],
       x$1 = caml_call2(f, y, x$0),
       num$1 = caml_call2(Base_Import[115], num$0, 1);
      num$0 = num$1;
      acc$0 = acc$1;
      x$0 = x$1;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0,
            caml_call3
             (fold_left, xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return caml_call1(Base_Import[126], cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$0){
    var
     groups =
       foldi
        (l,
         0,
         function(i, acc, x){
          if(! acc) return [0, [0, x, 0], 0];
          var tl = acc[2], current_group = acc[1];
          return caml_call3(break$0, i, caml_call1(hd_exn, current_group), x)
                  ? [0, [0, x, 0], [0, current_group, tl]]
                  : [0, [0, x, current_group], tl];
         });
    return groups ? caml_call2(rev_map, groups, rev) : 0;
   }
   function group(l, break$0){
    return groupi(l, function(param, x, y){return caml_call2(break$0, x, y);});
   }
   function sort_and_group(l, compare){
    return group
            (caml_call2(stable_sort, l, compare),
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function concat_map(l, f){
    var acc = 0, param = l;
    for(;;){
     if(! param){var res = caml_call1(rev, acc); return res;}
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call1(f, hd), acc);
     acc = acc$0;
     param = tl;
    }
   }
   function concat_mapi(l, f){
    var cont = 0, acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call2(f, cont, hd), acc),
      cont$0 = caml_call2(Base_Import[91], cont, 1);
     cont = cont$0;
     acc = acc$0;
     param = tl;
    }
   }
   function merge(l1, l2, compare){
    var acc = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return caml_call2(rev_append, acc, l2$0);
     if(! l2$0) return caml_call2(rev_append, acc, l1$0);
     var t2 = l2$0[2], h2 = l2$0[1], t1 = l1$0[2], h1 = l1$0[1];
     if(0 < caml_call2(compare, h1, h2)){
      var acc$0 = [0, h2, acc];
      acc = acc$0;
      l2$0 = t2;
     }
     else{var acc$1 = [0, h1, acc]; acc = acc$1; l1$0 = t1;}
    }
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function return$0(x){return [0, x, 0];}
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      caml_call1(Base_Applicative[12], [0, return$0, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = caml_call1(Base_Monad[1], [0, concat_map, return$0, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, return$0, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map];
   function last_exn(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return caml_call1(Base_Import[126], cst_List_last);
     var x = list$0[1];
     if(! list$0[2]) return x;
     var list$1 = list$0[2];
     list$0 = list$1;
    }
   }
   function last(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return 0;
     var x = list$0[1];
     if(! list$0[2]) return [0, x];
     var list$1 = list$0[2];
     list$0 = list$1;
    }
   }
   function is_prefix(list, prefix, equal){
    var list$0 = list, prefix$0 = prefix;
    for(;;){
     if(! prefix$0) return 1;
     var prefix$1 = prefix$0[2], hd = prefix$0[1];
     if(! list$0) return 0;
     var
      list$1 = list$0[2],
      hd$0 = list$0[1],
      _P_ = caml_call2(equal, hd, hd$0);
     if(! _P_) return _P_;
     list$0 = list$1;
     prefix$0 = prefix$1;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     a1$0 = a2;
     t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    var which_to_keep = opt ? opt[1] : 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$2 = list[1],
     to_keep = to_keep$2,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return caml_call1(rev, [0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep)){
      var to_keep$1 = 847656566 <= which_to_keep ? to_keep$0 : to_keep;
      to_keep = to_keep$1;
      param = tl;
     }
     else{
      var accum$0 = [0, to_keep, accum];
      to_keep = to_keep$0;
      accum = accum$0;
      param = tl;
     }
    }
   }
   function dedup_and_sort(list, compare){
    if(list && list[2]){
     var
      equal =
        function(x$0, x){return 0 === caml_call2(compare, x$0, x) ? 1 : 0;},
      sorted = caml_call2(sort, list, compare);
     return remove_consecutive_duplicates(0, sorted, equal);
    }
    return list;
   }
   function find_a_dup(l, compare){
    var sorted = caml_call2(sort, l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    function compare$0(a, b){return caml_call2(compare, b, a);}
    var sorted = caml_call2(sort, l, compare$0);
    if(! sorted) return 0;
    var
     sorted$2 = sorted[2],
     prev$1 = sorted[1],
     sorted$0 = sorted$2,
     prev = prev$1,
     already_recorded = 0,
     acc = 0;
    for(;;){
     if(! sorted$0) return acc;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 === caml_call2(compare, prev$0, prev))
      if(already_recorded){
       sorted$0 = sorted$1;
       prev = prev$0;
       already_recorded = 1;
      }
      else{
       var acc$0 = [0, prev$0, acc];
       sorted$0 = sorted$1;
       prev = prev$0;
       already_recorded = 1;
       acc = acc$0;
      }
     else{sorted$0 = sorted$1; prev = prev$0; already_recorded = 0;}
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], _N_ = caml_call2(equal, x, x$0);
      if(_N_){t = xs; continue;}
      var _O_ = _N_;
     }
     else
      var _O_ = 1;
     return _O_ ? [0, x$0] : 0;
    }
   }
   function count(t, f){
    return caml_call3(Base_Container[2], fold_left, t, f);
   }
   function sum(m, t, f){
    return caml_call4(Base_Container[7], fold_left, m, t, f);
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold_left, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold_left, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[91], count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _i_, n, 0);
    var i = n, accum = 0;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     if(0 === i) return accum;
     var
      accum$0 = [0, caml_call1(f, caml_call2(Base_Import[93], i, 1)), accum],
      i$0 = caml_call2(Base_Import[93], i, 1);
     i = i$0;
     accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match){
      var x = match[1], accum$0 = [0, x, accum];
      l$0 = tl;
      accum = accum$0;
     }
     else
      l$0 = tl;
    }
   }
   function filter_map(l, f){return caml_call1(rev, rev_filter_map(l, f));}
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match){
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = caml_call2(Base_Import[91], i, 1);
      i = i$0;
      l$0 = tl;
      accum = accum$0;
     }
     else{var i$1 = caml_call2(Base_Import[91], i, 1); i = i$1; l$0 = tl;}
    }
   }
   function filter_mapi(l, f){return caml_call1(rev, rev_filter_mapi(l, f));}
   function filter_opt(l){return filter_map(l, function(_M_){return _M_;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){
      var _K_ = caml_call1(rev, trd), _L_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _L_, _K_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x), _J_ = match[1];
     if(4152137 === _J_){
      var y = match[2], snd$0 = [0, y, snd];
      t$0 = t$1;
      snd = snd$0;
     }
     else if(4202758 <= _J_){
      var y$0 = match[2], trd$0 = [0, y$0, trd];
      t$0 = t$1;
      trd = trd$0;
     }
     else{var y$1 = match[2], fst$0 = [0, y$1, fst]; t$0 = t$1; fst = fst$0;}
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return caml_call2(partition_map, t, f$0);
   }
   function partition_result(t){
    return caml_call2(partition_map, t, Base_Result[36]);
   }
   function t_of_sexp$0(of_a_024, of_b_025, x_033){
    return caml_call2
            (Base_Import[174],
             function(sexp_031){
              if(1 === sexp_031[0]){
               var _H_ = sexp_031[1];
               if(_H_){
                var _I_ = _H_[2];
                if(_I_ && ! _I_[2]){
                 var
                  arg1_028 = _I_[1],
                  arg0_027 = _H_[1],
                  res0_029 = caml_call1(of_a_024, arg0_027),
                  res1_030 = caml_call1(of_b_025, arg1_028);
                 return [0, res0_029, res1_030];
                }
               }
              }
              return caml_call3
                      (Sexplib0_Sexp_conv_error[2], error_source_032, 2, sexp_031);
             },
             x_033);
   }
   function sexp_of_t$1(of_a_034, of_b_035, x_040){
    return caml_call2
            (Base_Import[150],
             function(param){
              var
               arg1_037 = param[2],
               arg0_036 = param[1],
               res0_038 = caml_call1(of_a_034, arg0_036),
               res1_039 = caml_call1(of_b_035, arg1_037);
              return [1, [0, res0_038, [0, res1_039, 0]]];
             },
             x_040);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    var
     _G_ =
       caml_call1
        (Base_Import[195],
         [2,
          [0,
           [5, [0, Sexplib0_Sexp_grammar[6], _k_, a_sexp_grammar]],
           [0, [5, [0, Sexplib0_Sexp_grammar[7], _l_, b_sexp_grammar]], 0]]]);
    return [5, [0, Sexplib0_Sexp_grammar[5], _m_, _G_]];
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[127])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(_F_, param){
                var y = param[1], x = _F_[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(_E_, param){
                var y = param[1], x = _E_[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var
     match =
       find
        (t,
         function(param){
          var key$0 = param[1];
          return caml_call2(equal, key, key$0);
         });
    if(! match) return 0;
    var x = match[1];
    return [0, caml_call1(Base_Import[127], x)];
   }
   var not_found$3 = [0, Base_Import[267], _o_];
   function find_exn$0(t, equal, key){
    var match = find$0(t, equal, key);
    if(! match) throw caml_maybe_attach_backtrace(not_found$3, 1);
    var value = match[1];
    return value;
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var _A_ = pos < 0 ? 1 : 0;
    if(_A_)
     var _B_ = _A_;
    else{
     var _C_ = len < 0 ? 1 : 0;
     if(_C_)
      var _B_ = _C_;
     else
      var
       _D_ = caml_call1(length, l),
       _B_ = caml_call2(Base_Import[93], _D_, len) < pos ? 1 : 0;
    }
    if(_B_) caml_call1(Base_Import[126], cst_List_sub);
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(i, acc, el){
                if(pos <= i && i < caml_call2(Base_Import[91], pos, len))
                 return [0, el, acc];
                return acc;
               }));
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return [0, caml_call1(rev, accum), t];
     if(! t) return [0, t_orig, 0];
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return caml_call1(rev, accum);
     if(! t) return t_orig;
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function drop(t, n){
    var t$0 = t, n$0 = n;
    for(;;){
     if(t$0){
      var tl = t$0[2];
      if(0 < n$0){
       var n$1 = caml_call2(Base_Import[93], n$0, 1);
       t$0 = tl;
       n$0 = n$1;
       continue;
      }
     }
     return t$0;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call3(invalid_argf, _p_, length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return caml_call1(rev, acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc];
     acc = acc$0;
     l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       t = tl;
       continue;
      }
     }
     return [0, caml_call1(rev, acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       param = tl;
       continue;
      }
     }
     return caml_call1(rev, acc);
    }
   }
   function drop_while(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var tl = t$0[2], hd = t$0[1];
      if(caml_call1(f, hd)){t$0 = tl; continue;}
     }
     return t$0;
    }
   }
   function drop_last(t){
    var match = caml_call1(rev, t);
    if(! match) return 0;
    var lst = match[2];
    return [0, caml_call1(rev, lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return caml_call1(Base_Import[124], cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(caml_call1(is_empty, list2)) return 0;
    var l1 = list1, accum = 0;
    for(;;){
     if(! l1) return caml_call1(rev, accum);
     var tl = l1[2], hd = l1[1];
     let hd$0 = hd;
     var
      accum$0 =
        caml_call2
         (rev_append, map(list2, function(x){return [0, hd$0, x];}), accum);
     l1 = tl;
     accum = accum$0;
    }
   }
   function concat(l){return caml_call3(fold_right, l, append, 0);}
   function concat_no_order(l){
    return caml_call3
            (fold_left,
             l,
             0,
             function(acc, l){return caml_call2(rev_append, l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _z_ = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! _z_) return _z_;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _y_ = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! _y_) return _y_;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var Infix = [0, append];
   function permute(opt, list){
    var random_state = opt ? opt[1] : Base_Random[18][1];
    if(list){
     var _x_ = list[2];
     if(_x_){
      if(_x_[2]){
       var arr = caml_call1(Base_Array0[14], list);
       caml_call4(Base_Array_permute[25], [0, random_state], 0, 0, arr);
       return caml_call1(Base_Array0[16], arr);
      }
      var y = _x_[1], x = list[1];
      return caml_call1(Base_Random[18][16], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    var random_state = opt ? opt[1] : Base_Random[18][1];
    if(caml_call1(is_empty, list))
     return caml_call1(Base_Import[124], cst_List_random_element_exn_em);
    var _w_ = caml_call1(length, list);
    return nth_exn(list, caml_call2(Base_Random[18][6], random_state, _w_));
   }
   function random_element(opt, list){
    var random_state = opt ? opt[1] : Base_Random[18][1];
    try{
     var _u_ = [0, random_element_exn([0, random_state], list)];
     return _u_;
    }
    catch(_v_){return 0;}
   }
   function compare$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     a$0 = xs;
     b$0 = ys;
    }
   }
   var hash_fold_t = Base_Import[213];
   function equal_local(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _t_ = caml_call2(equal, x1, x2);
       if(! _t_) return _t_;
       t1$0 = t1$1;
       t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function equal(f, x, y){return equal_local(f, x, y);}
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t) break;
      var match = t[1];
      if(match){
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc];
       t = tl;
       column_acc = column_acc$0;
       trimmed_rows = trimmed;
      }
      else{var tl$0 = t[2]; t = tl$0; found_empty = 1;}
     }
     if(! column_acc && ! trimmed_rows) return [0, caml_call1(rev, columns)];
     if(found_empty) return 0;
     var
      column = do_rev ? caml_call1(rev, column_acc) : column_acc,
      do_rev$0 = 1 - do_rev,
      columns$0 = [0, column, columns];
     rows = trimmed_rows;
     columns = columns$0;
     do_rev = do_rev$0;
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248, cst_Base_List_Transpose_got_li, runtime.caml_fresh_oo_id(0)];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Transpose_got_lists_of_differe,
     function(param){
      if(param[1] !== Transpose_got_lists_of_differe)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
      var
       arg0_041 = param[2],
       res0_042 = caml_call2(Base_Import[150], Base_Import[140], arg0_041);
      return [1, [0, _q_, [0, res0_042, 0]]];
     });
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1];
    return [0,
            x,
            caml_call3
             (fold_right,
              xs,
              function(y, acc){return [0, sep, [0, y, acc]];},
              0)];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold_left, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold_left, init, f, finish, t);
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = caml_call1(length, list),
     suffix_len = caml_call1(length, suffix),
     _s_ = suffix_len <= list_len ? 1 : 0;
    return _s_
            ? equal_local
              (equal_elt,
               drop(list, caml_call2(Base_Import[93], list_len, suffix_len)),
               suffix)
            : _s_;
   }
   var
    Base_List =
      [0,
       compare$0,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       of_list,
       of_array,
       append,
       concat,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       length,
       is_empty,
       iter,
       fold_left,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        return$0,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, return$0, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       Or_unequal_lengths,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       fold_right2_exn,
       fold_right2,
       for_all2_exn,
       for_all2,
       exists2_exn,
       exists2,
       rev_filter,
       partition3_map,
       partition_result,
       split_n,
       sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi_exn,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold_left,
       unzip,
       unzip3,
       zip,
       zip_exn,
       rev_mapi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       range$0,
       range,
       rev_filter_map,
       rev_filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(58, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Base__Char0, Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__Lazy, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = ": ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = "",
    cst$3 = "; ",
    cst = cst$5,
    cst$0 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Lazy = global_data.Base__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Char0 = global_data.Base__Char0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    _a_ = [0, "Could_not_construct"],
    _b_ = [0, "String"],
    _c_ = [0, "Exn"],
    _d_ = [0, "Sexp"],
    _e_ = [0, "Tag_sexp"],
    _f_ = [0, "Tag_t"],
    _g_ = [0, "Tag_arg"],
    _h_ = [0, "Of_list"],
    _i_ = [0, "With_backtrace"],
    cst_could_not_construct_info = "could not construct info: ",
    _j_ =
      [0,
       [11, "and ", [4, 0, 0, 0, [11, " more info", 0]]],
       "and %d more info"],
    cst_Backtrace = "\nBacktrace:\n";
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = caml_call1(Base_Sexp[4], arg0_001);
       return [1, [0, _a_, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = caml_call1(Base_Import[137], arg0_003);
       return [1, [0, _b_, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = caml_call1(Base_Import[199], arg0_005);
       return [1, [0, _c_, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = caml_call1(Base_Sexp[4], arg0_007);
       return [1, [0, _d_, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = caml_call1(Base_Import[137], arg0_009),
        res1_013 = caml_call1(Base_Sexp[4], arg1_010),
        res2_014 =
          caml_call2
           (Base_Import[147], Base_Source_code_position0[8], arg2_011);
       return [1, [0, _e_, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = caml_call1(Base_Import[137], arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, _f_, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = caml_call1(Base_Import[137], arg0_019),
        res1_023 = caml_call1(Base_Sexp[4], arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, _g_, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = caml_call2(Base_Import[147], Base_Import[140], arg0_025),
        res1_028 = caml_call2(Base_Import[150], sexp_of_t, arg1_026);
       return [1, [0, _h_, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = caml_call1(Base_Import[137], arg1_030);
       return [1, [0, _i_, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_strings_hum(t, ac){
    var t$0 = t, ac$0 = ac;
    for(;;)
     switch(t$0[0]){
       case 0:
        var sexp = t$0[1];
        return [0,
                cst_could_not_construct_info,
                [0, caml_call1(Base_Sexp[16], sexp), ac$0]];
       case 1:
        var string = t$0[1]; return [0, string, ac$0];
       case 2:
        var exn = t$0[1], _U_ = caml_call1(Base_Exn[1], exn);
        return [0, caml_call1(Base_Sexp[16], _U_), ac$0];
       case 3:
        var sexp$0 = t$0[1];
        return [0, caml_call1(Base_Sexp[16], sexp$0), ac$0];
       case 4:
        var sexp$1 = t$0[2], tag = t$0[1];
        return [0,
                tag,
                [0, cst, [0, caml_call1(Base_Sexp[16], sexp$1), ac$0]]];
       case 5:
        var t$1 = t$0[2], tag$0 = t$0[1];
        return [0, tag$0, [0, cst$0, to_strings_hum(t$1, ac$0)]];
       case 6:
        var
         t$2 = t$0[3],
         sexp$2 = t$0[2],
         tag$1 = t$0[1],
         _V_ = [0, cst$1, to_strings_hum(t$2, ac$0)],
         body = [0, caml_call1(Base_Sexp[16], sexp$2), _V_];
        return 0 === caml_ml_string_length(tag$1)
                ? body
                : [0, tag$1, [0, cst$2, body]];
       case 7:
        var ts = t$0[2], trunc_after = t$0[1];
        if(trunc_after){
         var max = trunc_after[1], n = caml_call1(Base_List[17], ts);
         if(n <= max)
          var ts$0 = ts;
         else
          var
           _X_ = caml_call2(Base_Import[93], n, max),
           _Y_ = [0, [1, caml_call2(Base_Printf[2], _j_, _X_)], 0],
           _Z_ = caml_call2(Base_List[136], ts, max),
           ts$0 = caml_call2(Base_Import[111], _Z_, _Y_);
         var ts$1 = ts$0;
        }
        else
         var ts$1 = ts;
        var _W_ = caml_call1(Base_List[61], ts$1);
        return caml_call3
                (Base_List[20],
                 _W_,
                 ac$0,
                 function(ac, t){
                  var
                   ac$0 = caml_call1(Base_List[18], ac) ? ac : [0, cst$3, ac];
                  return to_strings_hum(t, ac$0);
                 });
       default:
        var
         backtrace = t$0[2],
         t$3 = t$0[1],
         ac$1 = [0, cst_Backtrace, [0, backtrace, ac$0]];
        t$0 = t$3;
        ac$0 = ac$1;
     }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string$0 = t[1]; return [0, [0, string$0], ac];
      case 2:
       var exn = t[1]; return [0, caml_call1(Base_Exn[1], exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         _Q_ = [0, caml_call1(Base_Source_code_position0[8], here$0), 0];
       else
        var _Q_ = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, _Q_]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var ts = t[2], _R_ = caml_call1(Base_List[61], ts);
       return caml_call3
               (Base_List[20],
                _R_,
                ac,
                function(ac, t){return to_sexps_hum(t, ac);});
      default:
       var
        backtrace = t[2],
        t$2 = t[1],
        len = caml_ml_string_length(backtrace);
       a:
       {
        var _S_ = 0;
        if(0 < len){
         var
          _N_ =
            runtime.caml_string_get
             (backtrace, caml_call2(Base_Import[93], len, 1));
         if(caml_call2(Base_Char0[12], 10, _N_)){
          var
           _O_ = caml_call2(Base_Import[93], len, 1),
           string = caml_call3(Base_String0[9], backtrace, 0, _O_);
          break a;
         }
        }
        var string = backtrace;
       }
       var
        _P_ = caml_call2(Base_String0[13], 10, string),
        _T_ = [0, caml_call2(Base_Import[150], Base_Import[137], _P_), _S_];
       return [0, [1, [0, to_sexp_hum(t$2), _T_]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function protect(f){
    try{var _M_ = caml_call1(f, 0); return _M_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [0, caml_call1(Base_Exn[1], exn)];
    }
   }
   function to_message(info){
    return protect
            (function(param){
              var _L_ = caml_obj_tag(info);
              if(250 === _L_) return info[1];
              if(246 !== _L_ && 244 !== _L_) return info;
              return caml_call1(CamlinternalLazy[2], info);
             });
   }
   function of_message(t){return [250, t];}
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return [246, function(_K_){return [3, sexp];}];}
   function compare(t1, t2){
    var _I_ = sexp_of_t$0(t2), _J_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[6], _J_, _I_);
   }
   function equal(t1, t2){
    var _G_ = sexp_of_t$0(t2), _H_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[5], _H_, _G_);
   }
   function hash_fold_t(state, t){
    var _F_ = sexp_of_t$0(t);
    return caml_call2(Base_Sexp[1], state, _F_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var _E_ = to_sexp_hum(message);
    return caml_call2(Base_Sexp[15], 0, _E_);
   }
   function to_string_hum_deprecated(t){
    var t$0 = to_message(t), _D_ = to_strings_hum(t$0, 0);
    return caml_call2(Base_String0[14], 0, _D_);
   }
   function to_string_mach(t){
    var _C_ = sexp_of_t$0(t);
    return caml_call1(Base_Sexp[16], _C_);
   }
   function of_lazy(l){
    return [246,
            function(_z_){
             return protect
                     (function(param){
                       var _A_ = caml_obj_tag(l);
                       a:
                       if(250 === _A_)
                        var _B_ = l[1];
                       else{
                        if(246 !== _A_ && 244 !== _A_){var _B_ = l; break a;}
                        var _B_ = caml_call1(CamlinternalLazy[2], l);
                       }
                       return [1, _B_];
                      });
            }];
   }
   function of_lazy_sexp(l){
    return [246,
            function(_w_){
             return protect
                     (function(param){
                       var _x_ = caml_obj_tag(l);
                       a:
                       if(250 === _x_)
                        var _y_ = l[1];
                       else{
                        if(246 !== _x_ && 244 !== _x_){var _y_ = l; break a;}
                        var _y_ = caml_call1(CamlinternalLazy[2], l);
                       }
                       return [3, _y_];
                      });
            }];
   }
   function of_lazy_t(lazy_t){return caml_call1(Base_Lazy[13], lazy_t);}
   function of_string(message){
    return caml_call1(Base_Lazy[21], [1, message]);
   }
   function createf(format){
    return caml_call2(Base_Printf[4], of_string, format);
   }
   function of_thunk(f){
    return [246,
            function(_v_){
             return protect(function(param){return [1, caml_call1(f, 0)];});
            }];
   }
   function create(here, strict, tag, x, sexp_of_x){
    if(! strict)
     return [246,
             function(_u_){
              return protect
                      (function(param){
                        return [4, tag, caml_call1(sexp_of_x, x), here];
                       });
             }];
    var t = [4, tag, caml_call1(sexp_of_x, x), here];
    return [250, t];
   }
   function create_s(sexp){return caml_call1(Base_Lazy[21], [3, sexp]);}
   function tag(t, tag){
    return [246, function(param){return [5, tag, to_message(t)];}];
   }
   function tag_s_lazy(t, tag){
    return [246,
            function(_q_){
             return protect
                     (function(param){
                       var _r_ = to_message(t), _s_ = caml_obj_tag(tag);
                       a:
                       if(250 === _s_)
                        var _t_ = tag[1];
                       else{
                        if(246 !== _s_ && 244 !== _s_){var _t_ = tag; break a;}
                        var _t_ = caml_call1(CamlinternalLazy[2], tag);
                       }
                       return [6, cst$4, _t_, _r_];
                      });
            }];
   }
   function tag_s(t, tag){
    return tag_s_lazy(t, caml_call1(Base_Lazy[21], tag));
   }
   function tag_arg(t, tag, x, sexp_of_x){
    return [246,
            function(_o_){
             return protect
                     (function(param){
                       var _p_ = to_message(t);
                       return [6, tag, caml_call1(sexp_of_x, x), _p_];
                      });
            }];
   }
   function of_list(trunc_after, ts){
    return [246,
            function(param){
             return [7,
                     trunc_after,
                     caml_call2(Base_List[52], ts, to_message)];
            }];
   }
   var
    Exn = [248, "Base__Info.Exn", runtime.caml_fresh_oo_id(0)],
    _k_ = [0, "src/info.ml", 219, 6];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Exn,
     function(param){
      if(param[1] !== Exn)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
      var t = param[2];
      return sexp_of_t$0(t);
     });
   function to_exn(t){
    if(! caml_call1(Base_Lazy[22], t)) return [0, Exn, t];
    var _n_ = caml_obj_tag(t);
    a:
    if(250 === _n_)
     var match = t[1];
    else{
     if(246 !== _n_ && 244 !== _n_){var match = t; break a;}
     var match = caml_call1(CamlinternalLazy[2], t);
    }
    if(2 !== match[0]) return [0, Exn, t];
    var exn = match[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var _m_ = [0, caml_call1(Stdlib_Printexc[6], 0)];
     else
      var s = match[2], _m_ = [0, s];
     var backtrace$0 = _m_;
    }
    else
     var backtrace$0 = 0;
    if(exn[1] === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return [246, function(param){return [8, to_message(t), backtrace$1];}];
    }
    if(! backtrace$0) return caml_call1(Base_Lazy[21], [2, exn]);
    var backtrace$2 = backtrace$0[1];
    return [246,
            function(param){
             return [8, [3, caml_call1(Base_Exn[1], exn)], backtrace$2];
            }];
   }
   function pp(ppf, t){
    var _l_ = to_string_hum(t);
    return caml_call2(Stdlib_Format[13], ppf, _l_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(38, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    equal = Base_Info[2],
    hash_fold_t = Base_Info[3],
    hash = Base_Info[4],
    t_of_sexp = Base_Info[5],
    sexp_of_t = Base_Info[6],
    invariant = Base_Info[8],
    to_string_hum = Base_Info[9],
    to_string_mach = Base_Info[10],
    to_string_hum_deprecated = Base_Info[11],
    of_string = Base_Info[12],
    of_lazy = Base_Info[13],
    of_lazy_sexp = Base_Info[14],
    of_thunk = Base_Info[15],
    of_lazy_t = Base_Info[16],
    create = Base_Info[17],
    create_s = Base_Info[18],
    createf = Base_Info[19],
    tag = Base_Info[20],
    tag_s = Base_Info[21],
    tag_s_lazy = Base_Info[22],
    tag_arg = Base_Info[23],
    of_list = Base_Info[24],
    of_exn = Base_Info[25],
    to_exn = Base_Info[26],
    pp = Base_Info[27],
    Internal_repr = Base_Info[28];
   function raise(t){
    throw caml_maybe_attach_backtrace(caml_call1(to_exn, t), 1);
   }
   function raise_s(sexp){return raise(caml_call1(create_s, sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30],
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed",
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field";
   function invariant(here, t, sexp_of_t, f){
    try{var _h_ = caml_call1(f, 0); return _h_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e_ = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      _f_ = [0, [0, cst_exn, caml_call1(Base_Import[199], exn)], _e_],
      _g_ =
        [0, [0, cst$0, caml_call1(Base_Source_code_position0[8], here)], _f_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_invariant_failed, _g_));
    }
   }
   function check_field(t, f, field){
    try{
     var _d_ = caml_call1(f, caml_call2(Base_Field[3], field, t));
     return _d_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _a_ = [0, [0, cst_exn$0, caml_call1(Base_Import[199], exn)], 0],
      _b_ = caml_call1(Base_Field[2], field),
      _c_ = [0, [0, cst_field, caml_call1(Base_Import[137], _b_)], _a_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_problem_with_field, _c_));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative;
   function compare(cmp_a, a_001, b_002){
    return caml_call4(Base_Result[4], cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal(cmp_a, a_007, b_008){
    return caml_call4(Base_Result[5], cmp_a, Base_Error[2], a_007, b_008);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return caml_call4(Base_Result[7], hash_fold_a, Base_Error[3], hsv, arg);
   }
   function t_of_sexp(of_a_013, x_015){
    return caml_call3(Base_Result[1], of_a_013, Base_Error[5], x_015);
   }
   function sexp_of_t(of_a_016, x_017){
    return caml_call3(Base_Result[2], of_a_016, Base_Error[6], x_017);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call2(Base_Result[3], a_sexp_grammar, Base_Error[7]);
   }
   var
    symbol_bind = Base_Result[8],
    symbol_map = Base_Result[9],
    bind = Base_Result[12],
    ignore_m = Base_Result[15],
    join = Base_Result[14],
    map = Base_Result[31],
    return$0 = Base_Result[13];
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return caml_call1(Base_Error[8], error);
   }
   function map2(a, b, f){
    if(0 === a[0]){
     var x = a[1];
     if(0 === b[0]){var y = b[1]; return [0, caml_call2(f, x, y)];}
     var e = b;
    }
    else{
     var e1 = a[1];
     if(0 !== b[0]){
      var e2 = b[1];
      return [1, caml_call2(Base_Error[24], 0, [0, e1, [0, e2, 0]])];
     }
     var e = a;
    }
    return e;
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[15], [0, return$0, map2, map$0]),
    symbol = For_applicative[6],
    symbol$0 = For_applicative[5],
    symbol$1 = For_applicative[4],
    apply = For_applicative[8],
    both = For_applicative[3],
    map3 = For_applicative[10],
    include = Base_Result[11],
    symbol_bind$0 = include[1],
    symbol_map$0 = include[2],
    Open_on_rhs = [0],
    ok = Base_Result[24],
    is_ok = Base_Result[22],
    is_error = Base_Result[23],
    _a_ = [0, 3553398],
    cst_unimplemented = "unimplemented",
    _b_ = [0, "src/or_error.ml", 174, 22];
   function try_with(opt, f){
    var backtrace = opt ? opt[1] : 0;
    try{var _n_ = [0, caml_call1(f, 0)]; return _n_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), _m_ = backtrace ? _a_ : 0;
     return [1, caml_call2(Base_Error[25], _m_, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return caml_call1(Base_Error[29], err);
   }
   function of_exn(backtrace, exn){
    return [1, caml_call2(Base_Error[25], backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   function error(here, strict, message, a, sexp_of_a){
    return [1,
            caml_call5(Base_Error[17], here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, caml_call1(Base_Error[18], sexp)];}
   function error_string(message){
    return [1, caml_call1(Base_Error[12], message)];
   }
   function errorf(format){
    return caml_call2(Base_Printf[4], error_string, format);
   }
   function tag(t, tag){
    var _k_ = Base_Error[20];
    return caml_call2
            (Base_Result[32],
             t,
             function(_l_){return caml_call2(_k_, _l_, tag);});
   }
   function tag_s(t, tag){
    var _i_ = Base_Error[21];
    return caml_call2
            (Base_Result[32],
             t,
             function(_j_){return caml_call2(_i_, _j_, tag);});
   }
   function tag_s_lazy(t, tag){
    var _g_ = Base_Error[22];
    return caml_call2
            (Base_Result[32],
             t,
             function(_h_){return caml_call2(_g_, _h_, tag);});
   }
   function tag_arg(t, message, a, sexp_of_a){
    return caml_call2
            (Base_Result[32],
             t,
             function(e){
              return caml_call4(Base_Error[23], e, message, a, sexp_of_a);
             });
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[137]);
   }
   function combine_internal(list, on_ok, on_error){
    var match = caml_call1(Base_Result[34], list);
    if(0 === match[0]){var x = match[1]; return [0, caml_call1(on_ok, x)];}
    var errs = match[1];
    return [1, caml_call1(on_error, errs)];
   }
   function ignore_unit_list(param){return 0;}
   function error_of_list_if_necessary(list){
    if(list && ! list[2]){var e = list[1]; return e;}
    return caml_call2(Base_Error[24], 0, list);
   }
   function all(list){
    return combine_internal
            (list, function(_f_){return _f_;}, error_of_list_if_necessary);
   }
   function all_unit(list){
    return combine_internal
            (list, ignore_unit_list, error_of_list_if_necessary);
   }
   function combine_errors(list){
    var arg = Base_Error[24];
    return combine_internal
            (list,
             function(_e_){return _e_;},
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function combine_errors_unit(list){
    var arg = Base_Error[24];
    return combine_internal
            (list,
             ignore_unit_list,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function filter_ok_at_least_one(l){
    var
     match = caml_call2(Base_List[15], l, Base_Result[36]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, caml_call2(Base_Error[24], 0, errs)];
   }
   function find_ok(l){
    var match = caml_call2(Base_List[28], l, Base_Result[24]);
    if(match){var x = match[1]; return [0, x];}
    var
     _d_ =
       caml_call2
        (Base_List[52],
         l,
         function(param){
          if(0 === param[0])
           throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
          var err = param[1];
          return err;
         });
    return [1, caml_call2(Base_Error[24], 0, _d_)];
   }
   function find_map_ok(l, f){
    return caml_call1
            (Base_With_return[1],
             function(param){
              var
               _c_ =
                 caml_call2
                  (Base_List[52],
                   l,
                   function(elt){
                    var x = caml_call1(f, elt);
                    if(0 === x[0]) return caml_call1(param, x);
                    var err = x[1];
                    return err;
                   });
              return [1, caml_call2(Base_Error[24], 0, _c_)];
             });
   }
   var
    map$1 = Base_Result[31],
    iter = Base_Result[29],
    iter_error = Base_Result[30],
    Base_Or_error =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol$1,
       symbol$0,
       symbol,
       apply,
       map2,
       map3,
       For_applicative[13],
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[11],
       bind,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$0,
        symbol_bind$0,
        symbol_map$0,
        [0, return$0, bind, map, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _e_ = sexp_004[1];
      b:
      if(_e_ !== cst_Neg){
       c:
       if(_e_ !== cst_Pos){
        if(_e_ !== cst_Zero){
         if(_e_ === cst_neg) break b;
         if(_e_ === cst_pos) break c;
         if(_e_ !== cst_zero) break a;
        }
        return 1;
       }
       return 2;
      }
      return 0;
     }
     var _f_ = sexp_004[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _h_ = _g_[1];
     b:
     if(_h_ !== cst_Neg){
      c:
      if(_h_ !== cst_Pos){
       if(_h_ !== cst_Zero){
        if(_h_ === cst_neg) break b;
        if(_h_ === cst_pos) break c;
        if(_h_ !== cst_zero) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       max,
       min];
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[137], s));}
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base_Import[161], _d_);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    _a_ = [0, cst_src_comparable_ml, 47, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    _b_ = [0, cst_src_comparable_ml, 135, 4],
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1;
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Comparisons(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Comparisons([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var _r_ = caml_call2(symbol$0, low, t);
     return _r_ ? caml_call2(symbol$0, t, high) : _r_;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      _o_ = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      _p_ = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], _o_],
      _q_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max$0, _p_);
     return caml_call1(Base_Or_error[35], _q_);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = caml_call1(Base_Comparator[5], T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var _m_ = caml_call1(T[2], t), _n_ = caml_call1(T[2], t$0);
     return caml_call2(C[1], _n_, _m_);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var _l_ = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), _l_);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   function compare_reversed(cmp, x, y){return caml_call2(cmp, y, x);}
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       compare_reversed,
       equal,
       max,
       min,
       Infix,
       Comparisons,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var
          _j_ = caml_lessequal(low, t),
          _k_ = _j_ ? caml_lessequal(t, high) : _j_;
         return _k_;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          _g_ = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          _h_ = [0, [0, cst_min, caml_call1(T[1], min)], _g_],
          _i_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _h_);
         return caml_call1(Base_Or_error[35], _i_);
        }
        var
         include =
           caml_call1(Base_Comparator[5], [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       function(_c_){
        var _d_ = _c_[3], _e_ = _c_[1];
        function is_positive(t){return 0 < caml_call2(_e_, t, _d_) ? 1 : 0;}
        function is_non_negative(t){
         return 0 <= caml_call2(_e_, t, _d_) ? 1 : 0;
        }
        function is_negative(t){return caml_call2(_e_, t, _d_) < 0 ? 1 : 0;}
        function is_non_positive(t){
         return caml_call2(_e_, t, _d_) <= 0 ? 1 : 0;
        }
        function sign(t){
         var _f_ = caml_call2(_e_, t, _d_);
         return caml_call1(Base_Sign0[13], _f_);
        }
        return [0,
                is_positive,
                is_non_negative,
                is_negative,
                is_non_positive,
                sign];
       }];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function equal(a, b){
    var _b_ = caml_call2(Base_Import[128], a, b);
    if(_b_)
     var _c_ = _b_;
    else{
     var _d_ = caml_call2(Base_Import[128], a[1], b[1]);
     if(_d_){
      var _e_ = caml_call2(Base_Import[128], a[2], b[2]);
      if(_e_) return caml_call2(Base_Import[128], a[3], b[3]);
      var _c_ = _e_;
     }
     else
      var _c_ = _d_;
    }
    return _c_;
   }
   var
    hash_param = Base_Import[85][105][30],
    hash = Base_Import[85][105][28],
    _a_ = [0, "_"],
    poly = [0, hash, runtime.caml_compare, function(param){return _a_;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    equal$0 = Hashable[1],
    hash_param$0 = Hashable[2],
    hash$0 = Hashable[3],
    poly$0 = Hashable[4],
    of_key$0 = Hashable[5],
    to_key$0 = Hashable[6],
    Base_Hashable_intf =
      [0, Hashable, equal$0, hash_param$0, hash$0, poly$0, of_key$0, to_key$0];
   runtime.caml_register_global(2, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _b_ = caml_call1(Base_Comparable[11], [0, T[1], T[5]]),
         symbol = _b_[1],
         symbol$0 = _b_[2],
         symbol$1 = _b_[3],
         symbol$2 = _b_[4],
         symbol$3 = _b_[5],
         symbol$4 = _b_[6],
         equal = _b_[7],
         compare = _b_[8],
         min = _b_[9],
         max = _b_[10],
         ascending = _b_[11],
         descending = _b_[12],
         between = _b_[13],
         clamp_exn = _b_[14],
         clamp = _b_[15],
         comparator = _b_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _a_ = caml_call1(Base_Comparable[12], [0, T[5], T[9]]),
         symbol = _a_[1],
         symbol$0 = _a_[2],
         symbol$1 = _a_[3],
         symbol$2 = _a_[4],
         symbol$3 = _a_[5],
         symbol$4 = _a_[6],
         equal = _a_[7],
         compare = _a_[8],
         min = _a_[9],
         max = _a_[10],
         ascending = _a_[11],
         descending = _a_[12],
         between = _a_[13],
         clamp_exn = _a_[14],
         clamp = _a_[15],
         comparator = _a_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       }];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    globalize = Base_Import[261],
    hash_fold_t = Base_Import[211],
    func = Base_Import[225];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[159],
    sexp_of_t = Base_Import[135],
    t_sexp_grammar = Base_Import[181],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function compare(_a_, param){return 0;}
   function of_string(param){
    return param !== cst$0
            ? caml_call1(Base_Import[124], cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Or_error, Base__Ordered_collection_common0, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Or_error = global_data.Base__Or_error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{
     var _a_ = [0, caml_call4(get_pos_len_exn, pos, len, 0, total_length)];
     return _a_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return caml_call1(Base_Or_error[36], s);
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     _e_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _e_),
     len$0 = match[2],
     pos$0 = match[1],
     _f_ = caml_call2(Base_Import[91], pos$0, len$0),
     hi$0 = caml_call2(Base_Import[93], _f_, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 >= caml_call2(Base_Import[93], hi, lo$1)) break;
     var
      _c_ = caml_call2(Base_Import[93], hi, lo$1),
      _d_ = caml_call2(Base_Import[95], _c_, 2),
      mid = caml_call2(Base_Import[91], lo$1, _d_);
     if(caml_call1(pred, caml_call2(get, t, mid)))
      hi = mid;
     else{var lo$2 = caml_call2(Base_Import[91], mid, 1); lo$1 = lo$2;}
    }
    var lo = lo$1;
    for(;;){
     if(hi < lo) return 0;
     if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
     var lo$0 = caml_call2(Base_Import[91], lo, 1);
     lo = lo$0;
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     _a_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _a_),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0],
         [0, len$0],
         t,
         get,
         length,
         function(x){return 1 - caml_call1(pred, x);});
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, caml_call2(Base_Import[93], i, 1)];
    }
    var _b_ = caml_call2(Base_Import[91], pos$0, len$0);
    return [0, caml_call2(Base_Import[93], _b_, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(2, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) === 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return caml_call8
             (Base_Binary_search[1],
              pos,
              len,
              t,
              length,
              get,
              compare,
              how,
              v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return caml_call7
             (Base_Binary_search[2],
              pos,
              len,
              t,
              length,
              get,
              segment_of,
              how);
    }
    return [0, , , binary_search, binary_search_segmented];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], _b_ = Make_gen([0, get, length]);
        return [0, _b_[3], _b_[4]];
       },
       function(T){
        var get = T[1], length = T[2], _a_ = Make_gen([0, get, length]);
        return [0, _a_[3], _a_[4]];
       }];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Import0, Base__Sys0, Stdlib__BytesLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Sys0 = global_data.Base__Sys0,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[40],
    copy = Stdlib_BytesLabels[4],
    create = caml_create_bytes,
    cst_Bytes_create_local = "Bytes.create_local";
   function create_local(len){
    if(Base_Sys0[10] < len)
     caml_call1(Base_Import0[126], cst_Bytes_create_local);
    return runtime.Base_unsafe_create_local_bytes(len);
   }
   var fill = Stdlib_BytesLabels[10], make = Stdlib_BytesLabels[1];
   function map(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     _e_ = caml_call2(Base_Import0[93], l, 1),
     _d_ = 0;
    if(_e_ >= 0){
     var i = _d_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(t, i)));
      var _f_ = i + 1 | 0;
      if(_e_ === i) break;
      i = _f_;
     }
    }
    return r;
   }
   function mapi(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     _b_ = caml_call2(Base_Import0[93], l, 1),
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(t, i)));
      var _c_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _c_;
     }
    }
    return r;
   }
   var
    sub = Stdlib_BytesLabels[7],
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       create_local,
       fill,
       make,
       map,
       mapi,
       sub,
       to_string,
       of_string];
   runtime.caml_register_global(4, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var _l_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], src_pos, len, _l_);
     var _m_ = caml_call1(Dst[1], dst);
     caml_call3(Base_Ordered_collection_common[2], dst_pos, len, _m_);
     var _n_ = 0 < len ? 1 : 0;
     return _n_
             ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len)
             : _n_;
    }
    function blito(src, _j_, _i_, dst, opt, param){
     var src_pos = _j_ ? _j_[1] : 0;
     if(_i_)
      var src_len = _i_[1];
     else
      var
       _k_ = caml_call1(Src[1], src),
       src_len = caml_call2(Base_Import[93], _k_, src_pos);
     var dst_pos = opt ? opt[1] : 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var _h_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], pos, len, _h_);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     var pos = opt ? opt[1] : 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       _g_ = caml_call1(Src[1], src),
       i$0 = caml_call2(Base_Import[93], _g_, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     return caml_string_of_bytes(caml_call3(To_bytes[4], src, pos, len));
    }
    function subo(pos, len, src){
     return caml_string_of_bytes(caml_call3(To_bytes[5], pos, len, src));
    }
    return [0, sub, subo];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       function(Src, Dst){
        var length = Dst[1];
        function create_like(len, param){return caml_call1(Dst[2], len);}
        var
         unsafe_blit = Dst[3],
         length$0 = Src[1],
         _f_ = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
        return [0, _f_[2], _f_[3], _f_[1], _f_[4], _f_[5]];
       },
       Make_to_string,
       function(_c_){
        var
         _d_ = [0, _c_[2], _c_[1], _c_[3]],
         _e_ = Make_gen([0, _d_[1]], _d_);
        return [0, _e_[2], _e_[3], _e_[1], _e_[4], _e_[5]];
       },
       function(_a_){
        var _b_ = Make_gen([0, _a_[2]], [0, _a_[2], _a_[1], _a_[3]]);
        return [0, _b_[2], _b_[3], _b_[1], _b_[4], _b_[5]];
       }];
   runtime.caml_register_global(2, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare = Base_Either0[1],
    hash_fold_t = Base_Either0[2],
    t_of_sexp = Base_Either0[3],
    sexp_of_t = Base_Either0[4],
    t_sexp_grammar = Base_Either0[5];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$0 = M[1],
     other = M[2],
     focus = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         var
          res =
            caml_call2
             (bind,
              t,
              function(x){return caml_call1(return$0, caml_call1(f, x));});
         return res;
        }],
     include = caml_call1(Base_Monad[6], [0, bind, map, return$0]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$1 = include[6],
     join = include[8],
     ignore_m = include[9],
     map$0 = [0, -198771759, include[7]];
    function map2(t1, t2, f){
     return caml_call2
             (bind$0,
              t1,
              function(x){
               return caml_call2
                       (bind$0,
                        t2,
                        function(y){
                         return caml_call1(return$1, caml_call2(f, x, y));
                        });
              });
    }
    var
     App = caml_call1(Base_Applicative[16], [0, return$1, map2, map$0]),
     return$2 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply = App[8],
     map2$0 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function combine_all(ts$1, f){
     var acc$1 = 0, param$0 = ts$1;
     for(;;){
      if(! param$0)
       return caml_call1(return$2, caml_call1(Base_List0[21], acc$1));
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      var acc$2 = [0, match$0[1], acc$1];
      acc$1 = acc$2;
      param$0 = ts$0;
     }
     var acc$3 = match$0[1], acc = acc$3, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       param = ts;
      else{var acc$0 = caml_call2(f, acc, match[1]); acc = acc$0; param = ts;}
     }
    }
    function combine_all_unit(ts$1, f){
     var param$0 = ts$1;
     for(;;){
      if(! param$0) return caml_call1(return$2, 0);
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      param$0 = ts$0;
     }
     var acc$1 = match$0[1], acc = acc$1, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       param = ts;
      else{var acc$0 = caml_call2(f, acc, match[1]); acc = acc$0; param = ts;}
     }
    }
    function to_option(t){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? [0, match[1]] : 0;
    }
    function value(t, default$0){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? match[1] : default$0;
    }
    function with_return(f){
     return caml_call1
             (Base_With_return[1],
              function(ret){
               return caml_call1
                       (other,
                        caml_call1
                         (f, caml_call2(Base_With_return[3], ret, return$2)));
              });
    }
    return [0,
            ,
            ,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            ,
            return$2,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2$0,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function focus(t){
    if(0 === t[0]){var x = t[1]; return [0, x];}
    var y = t[1];
    return [1, y];
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, focus, combine, bind]);
   function focus$0(t){
    if(0 === t[0]){var y = t[1]; return [1, y];}
    var x = t[1];
    return [0, x];
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, focus$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(5, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Container, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Container = global_data.Base__Container,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare = Base_Import[237],
    globalize = Base_Import[264],
    hash_fold_t = Base_Import[212],
    t_of_sexp = Base_Import[171],
    sexp_of_t = Base_Import[147],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[194], a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$0, f){
    if(! o) return default$0;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$0){
    if(! t) return default$0;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       _c_ =
         caml_call2
          (Base_Import[148], Base_Error[6], Base_Source_code_position0[8]),
       _d_ = value(message, cst),
       _e_ = caml_call5(Base_Error[17], 0, 0, _d_, [0, e, p], _c_);
     else if(message)
      var
       m = message[1],
       _e_ =
         caml_call5(Base_Error[17], 0, 0, m, p, Base_Source_code_position0[8]);
     else
      var
       _e_ =
         caml_call5
          (Base_Error[17],
           0,
           0,
           cst_Option_value_exn,
           p,
           Base_Source_code_position0[8]);
     var error$0 = _e_;
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], _f_ = caml_call2(Base_Error[20], e$0, m$0);
     else
      var _f_ = e$0;
     var error$0 = _f_;
    }
    else if(message)
     var m$1 = message[1], error$0 = caml_call1(Base_Error[12], m$1);
    else
     var error$0 = caml_call1(Base_Error[12], cst_Option_value_exn_None);
    return caml_call1(Base_Error[29], error$0);
   }
   function value_or_thunk(o, default$0){
    if(! o) return caml_call1(default$0, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function min_elt(t, param){return t;}
   function max_elt(t, param){return t;}
   function sum(M, t, f){return value_map(t, M[1], f);}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function count(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a) ? 1 : 0;
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(_b_){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(_a_){return 0;}
   }
   function return$0(x){return [0, x];}
   var
    map =
      [0,
       -198771759,
       function(t, f){
        if(! t) return 0;
        var a = t[1];
        return [0, caml_call1(f, a)];
       }];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    include = caml_call1(Base_Monad[5], [0, bind, return$0, map]),
    symbol_bind = include[1],
    Monad_infix = include[3],
    bind$0 = include[4],
    join = include[7],
    ignore_m = include[8],
    Let_syntax = include[11];
   function return$1(x){return [0, x];}
   var map$0 = [0, -198771759, include[6]];
   function map2(x, y, f){
    if(x && y){
     var y$0 = y[1], x$0 = x[1];
     return [0, caml_call2(f, x$0, y$0)];
    }
    return 0;
   }
   var
    include$0 = caml_call1(Base_Applicative[15], [0, return$1, map2, map$0]),
    return$2 = include$0[1],
    map$1 = include$0[2],
    both = include$0[3],
    symbol = include$0[4],
    symbol$0 = include$0[5],
    symbol$1 = include$0[6],
    symbol_map = include$0[7],
    apply = include$0[8],
    map2$0 = include$0[9],
    map3 = include$0[10],
    all = include$0[11],
    all_unit = include$0[12],
    Applicative_infix = include$0[13];
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   var
    Base_Option =
      [0,
       compare,
       globalize,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2$0,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$2,
       map$1,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some,
       is_none,
       fold_result,
       fold_until,
       min_elt,
       max_elt,
       count,
       sum];
   runtime.caml_register_global(9, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Base__Bool0, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[226],
    globalize = Base_Import[252],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[160],
    sexp_of_t = Base_Import[136],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t],
    _a_ =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"];
   function of_string(s){
    return s !== "false"
            ? s !== "true" ? caml_call3(invalid_argf, _a_, s, 0) : 1
            : 0;
   }
   var
    to_string = Base_Import[85][30],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$0[1],
    _b_ = [0, cst_src_bool_ml, 59, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[105][2], low, t);
    return _k_ ? caml_call2(Base_Import[105][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[105][1], t, min)
            ? min
            : caml_call2(Base_Import[105][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[105][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[105][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function to_int(x){return caml_call1(Base_Import[86], x);}
   function symbol(a, b){
    var
     _f_ = to_int(b),
     _g_ = to_int(a),
     x = caml_call2(Base_Import[118], _g_, _f_);
    return x;
   }
   function symbol$0(a, b){
    var
     _d_ = to_int(b),
     _e_ = to_int(a),
     x = caml_call2(Base_Import[116], _e_, _d_);
    return x;
   }
   var _c_ = [0, cst_src_bool_ml, 86, 9];
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[105],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     equal = include$1[10],
     max = include$1[11],
     min = include$1[12],
     Base_Bool =
       [0,
        all,
        globalize,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Base__Array0, Base__Bool, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Result, Base__With_return, CamlinternalLazy, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    cst_state = "state",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_027 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_With_return = global_data.Base__With_return,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Base_Bool = global_data.Base__Bool,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    _a_ = [0, "Done"],
    _b_ = [0, cst_state],
    _c_ = [0, "Skip"],
    _d_ = [0, cst_state],
    _e_ = [0, "value"],
    _f_ = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return _a_;
    if(0 === param[0]){
     var
      state_004 = param[1],
      arg_005 = caml_call1(of_s_002, state_004),
      bnds_003 = [0, [1, [0, _b_, [0, arg_005, 0]]], 0];
     return [1, [0, _c_, bnds_003]];
    }
    var
     state_009 = param[2],
     value_007 = param[1],
     arg_010 = caml_call1(of_s_002, state_009),
     bnds_006 = [0, [1, [0, _d_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(of_a_001, value_007),
     bnds_006$0 = [0, [1, [0, _e_, [0, arg_008, 0]]], bnds_006];
    return [1, [0, _f_, bnds_006$0]];
   }
   var Step = [0, sexp_of_t];
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f,
               acc,
               0,
               function(_R_){return loop(s$0, next, finish, f, _R_);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(_Q_){return loop(s$1, next, finish, f, _Q_);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   var
    Expert = [0, next_step, delayed_fold_step],
    _h_ = [0, 0, 0],
    _i_ = [0, "src/sequence.ml", 299, 14];
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    function f$0(s){
     var match = caml_call1(f, s);
     if(! match) return 0;
     var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
     return [1, a, s$0];
    }
    return [0, init, f$0];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             if(301075099 <= state[1]){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(init){
    function f(param){
     if(! param) return 0;
     var l = param[2], x = param[1];
     return [1, x, l];
    }
    return [0, init, f];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1], v$0 = caml_call2(f, v, a);
      seed = seed$1;
      v = v$0;
     }
    }
   }
   function to_list_rev(t){
    return fold(t, 0, function(l, x){return [0, x, l];});
   }
   function to_list(param){
    var next = param[2], s = param[1];
    function to_list(s, next, i){
     var s$0 = s;
     for(;;){
      if(0 === i){
       var t = [0, s$0, next], _P_ = to_list_rev(t);
       return caml_call1(Base_List1[21], _P_);
      }
      var match = caml_call1(next, s$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s$2 = match[2], a = match[1];
       return [0, a, to_list(s$2, next, caml_call2(Base_Import[93], i, 1))];
      }
      var s$1 = match[1];
      s$0 = s$1;
     }
    }
    return to_list(s, next, 500);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var _O_ = to_list(t);
    return caml_call2(Base_Import[150], sexp_of_a, _O_);
   }
   function range(_N_, _M_, opt, start_v, stop_v){
    var
     stride = _N_ ? _N_[1] : 1,
     start = _M_ ? _M_[1] : 104758188,
     stop = opt ? opt[1] : -160346914,
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : caml_call2(Base_Import[91], start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    function f(t_lazy){
     var _L_ = caml_obj_tag(t_lazy);
     a:
     if(250 === _L_)
      var match = t_lazy[1];
     else{
      if(246 !== _L_ && 244 !== _L_){var match = t_lazy; break a;}
      var match = caml_call1(CamlinternalLazy[2], t_lazy);
     }
     var next = match[2], s = match[1], match$0 = caml_call1(next, s);
     if(typeof match$0 === "number") return 0;
     if(0 === match$0[0]){
      var s$0 = match$0[1], v = [0, s$0, next];
      return [0, v];
     }
     var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
     return [1, x, v$0];
    }
    return [0, t_lazy, f];
   }
   function _g_(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              _K_ = [0, caml_call2(Base_Import[91], i, 1), s$1];
             return [1, caml_call2(f, i, a), _K_];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, caml_call2(Base_Import[91], i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var _J_ = Base_Import[127];
    return _g_
            (filter
              (mapi(t, function(i, s){return [0, i, s];}),
               function(param){
                var s = param[2], i = param[1];
                return caml_call2(f, i, s);
               }),
             _J_);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], i$0 = caml_call2(Base_Import[91], i, 1);
      i = i$0;
      s = s$1;
     }
    }
   }
   function to_array(t){
    var
     match =
       fold
        (t,
         _h_,
         function(param, x){
          var i = param[2], l = param[1];
          return [0, [0, x, l], caml_call2(Base_Import[91], i, 1)];
         }),
     len = match[2],
     l = match[1];
    if(! l) return [0];
    var
     l$0 = l[2],
     x = l[1],
     a = caml_call2(Base_Array0[4], len, x),
     i$1 = caml_call2(Base_Import[93], len, 2),
     i = i$1,
     l$1 = l$0;
    for(;;){
     if(! l$1){
      if(-1 === i) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     var l$2 = l$1[2], x$0 = l$1[1];
     runtime.caml_check_bound(a, i)[1 + i] = x$0;
     var i$0 = caml_call2(Base_Import[93], i, 1);
     i = i$0;
     l$1 = l$2;
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call1(f, a)) return [0, a];
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
      if(some_b) return some_b;
      s = s$1;
     }
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
      if(some_b) return some_b;
      var i$0 = caml_call2(Base_Import[91], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(! caml_call1(f, a)) return 0;
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(! caml_call2(f, i, a)) return 0;
      var s$1 = match[2], i$0 = caml_call2(Base_Import[91], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return 1;
      var s$1 = match[2], i$0 = caml_call2(Base_Import[91], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1];
      caml_call1(f, a);
      seed = seed$1;
     }
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1];
     s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    function f$0(param){
     var
      rest = param[2],
      match = param[1],
      next = match[2],
      seed = match[1],
      match$0 = caml_call1(next, seed);
     if(typeof match$0 === "number"){
      var
       next$0 = rest[2],
       seed$0 = rest[1],
       match$1 = caml_call1(next$0, seed$0);
      if(typeof match$1 === "number") return 0;
      if(0 === match$1[0]){
       var s = match$1[1];
       return [0, [0, empty, [0, s, next$0]]];
      }
      var s$0 = match$1[2], a = match$1[1];
      return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
     }
     if(0 === match$0[0]){
      var s$1 = match$0[1];
      return [0, [0, [0, s$1, next], rest]];
     }
     var s$2 = match$0[2], a$0 = match$0[1];
     return [1, a$0, [0, [0, s$2, next], rest]];
    }
    var init = [0, empty, t];
    return [0, init, f$0];
   }
   function return$0(x){
    function f(param){
     if(! param) return 0;
     var x = param[1];
     return [1, x, 0];
    }
    var init = [0, x];
    return [0, init, f];
   }
   var
    map = [0, -198771759, _g_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_Sequence_nth = cst_Sequence_nth$1,
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    _j_ = [0, cst_Left$0],
    _k_ = [0, cst_Right$0],
    _l_ = [0, cst_Both$0],
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0;
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(caml_call2(Base_Import[128], i, 0)) return [0, a];
      var i$0 = caml_call2(Base_Import[93], i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function nth_exn(s, n){
    if(0 > n) return caml_call1(Base_Import[126], cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare(cmp_a, cmp_b, a_013, b_014){
    if(a_013 === b_014) return 0;
    switch(a_013[0]){
      case 0:
       var a_015 = a_013[1];
       if(0 !== b_014[0]) return -1;
       var b_016 = b_014[1];
       return caml_call2(cmp_a, a_015, b_016);
      case 1:
       var a_017 = a_013[1];
       switch(b_014[0]){
         case 0: break;
         case 1:
          var b_018 = b_014[1]; return caml_call2(cmp_b, a_017, b_018);
         default: return -1;
       }
       break;
      default:
       var a_021 = a_013[2], a_019 = a_013[1];
       switch(b_014[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_022 = b_014[2],
           b_020 = b_014[1],
           n = caml_call2(cmp_a, a_019, b_020);
          return 0 === n ? caml_call2(cmp_b, a_021, b_022) : n;
       }
    }
    return 1;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = caml_call2(Base_Hash[3], hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_023, of_b_024, sexp_029){
    a:
    {
     if(0 === sexp_029[0]){
      var _F_ = sexp_029[1];
      b:
      if(_F_ !== cst_Both$0){
       c:
       if(_F_ !== cst_Left$0){
        if(_F_ !== cst_Right$0){
         if(_F_ === cst_both) break b;
         if(_F_ === cst_left) break c;
         if(_F_ !== cst_right) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_027, sexp_029);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_027, sexp_029);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_027, sexp_029);
     }
     var _G_ = sexp_029[1];
     if(! _G_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_027, sexp_029);
     var _H_ = _G_[1];
     if(0 !== _H_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_027, sexp_029);
     var tag_030 = _H_[1];
     b:
     if(tag_030 !== cst_Both$0){
      c:
      if(tag_030 !== cst_Left$0){
       if(tag_030 !== cst_Right$0){
        if(tag_030 === cst_both) break b;
        if(tag_030 === cst_left) break c;
        if(tag_030 !== cst_right) break a;
       }
       var sexp_args_036 = _G_[2];
       if(sexp_args_036 && ! sexp_args_036[2]){
        var
         arg0_037 = sexp_args_036[1],
         res0_038 = caml_call1(of_b_024, arg0_037);
        return [1, res0_038];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_027,
                tag_030,
                sexp_029);
      }
      var sexp_args_031 = _G_[2];
      if(sexp_args_031 && ! sexp_args_031[2]){
       var
        arg0_032 = sexp_args_031[1],
        res0_033 = caml_call1(of_a_023, arg0_032);
       return [0, res0_033];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_027,
               tag_030,
               sexp_029);
     }
     var sexp_args_041 = _G_[2];
     if(sexp_args_041){
      var _I_ = sexp_args_041[2];
      if(_I_ && ! _I_[2]){
       var
        arg1_043 = _I_[1],
        arg0_042 = sexp_args_041[1],
        res0_044 = caml_call1(of_a_023, arg0_042),
        res1_045 = caml_call1(of_b_024, arg1_043);
       return [2, res0_044, res1_045];
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_027,
              tag_030,
              sexp_029);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_027, sexp_029);
   }
   function sexp_of_t$1(of_a_048, of_b_049, param){
    switch(param[0]){
      case 0:
       var arg0_050 = param[1], res0_051 = caml_call1(of_a_048, arg0_050);
       return [1, [0, _j_, [0, res0_051, 0]]];
      case 1:
       var arg0_052 = param[1], res0_053 = caml_call1(of_b_049, arg0_052);
       return [1, [0, _k_, [0, res0_053, 0]]];
      default:
       var
        arg1_055 = param[2],
        arg0_054 = param[1],
        res0_056 = caml_call1(of_a_048, arg0_054),
        res1_057 = caml_call1(of_b_049, arg1_055);
       return [1, [0, _l_, [0, res0_056, [0, res1_057, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   var
    Merge_with_duplicates_element =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t$1, t_sexp_grammar],
    cst_hd_exn = "hd_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_drop = "Sequence.drop";
   function merge_with_duplicates(_E_, param, compare){
    var next2 = param[2], s2 = param[1], next1 = _E_[2], s1 = _E_[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    return caml_call2
            (map$0,
             merge_with_duplicates(s1, s2, compare),
             function(param){var x = param[1]; return x;});
   }
   function merge_sorted(_D_, param, compare){
    var next2 = param[2], s2 = param[1], next1 = _D_[2], s1 = _D_[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){var a = match[1]; return [0, a];}
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return caml_call1(Base_Import[124], cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1]; s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){
      var s$2 = match[2], a = match[1];
      return [0, [0, a, [0, s$2, next]]];
     }
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    return filter_map
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, caml_call1(Base_List1[21], accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, caml_call1(Base_List1[21], accum), empty];
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var
       s$2 = match[2],
       a = match[1],
       accum$0 = [0, a, accum],
       i$0 = caml_call2(Base_Import[93], i, 1);
      s$0 = s$2;
      i = i$0;
      accum = accum$0;
     }
    }
   }
   function chunks_exn(init, n){
    if(0 >= n) return caml_call1(Base_Import[126], cst_Sequence_chunks_exn);
    function f(t){
     var match = split_n(t, n), xs = match[1];
     if(! xs) return 0;
     var t$0 = match[2];
     return [1, xs, t$0];
    }
    return [0, init, f];
   }
   function findi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return [0, [0, i, a]];
      var s$0 = match[2];
     }
     var i$0 = caml_call2(Base_Import[91], i, 1);
     s = s$0;
     i = i$0;
    }
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             if(472258093 <= param[1]){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){
    function f(_C_){return _C_;}
    return caml_call2(bind$0, s, f);
   }
   function concat_mapi(s, f){
    function f$0(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    var s$0 = mapi(s, function(i, s){return [0, i, s];});
    return caml_call2(bind$0, s$0, f$0);
   }
   function zip(_A_, param){
    var next2 = param[2], s2 = param[1], next1 = _A_[2], s1 = _A_[1];
    function next(param){
     var _B_ = param[1];
     if(typeof _B_ !== "number"){
      if(1 === _B_[0]){
       var match = param[2], s1$0 = _B_[2], a = _B_[1];
       if(typeof match !== "number"){
        if(0 === match[0]){
         var s2$0 = param[2][1];
         return [0, [0, _B_, caml_call1(next2, s2$0)]];
        }
        var s2$1 = match[2], b = match[1];
        return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
       }
      }
      if(typeof param[2] !== "number"){
       var s2 = param[2], s1 = _B_[1];
       return [0, [0, caml_call1(next1, s1), s2]];
      }
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(_z_, param){
    var next2 = param[2], s2 = param[1], next1 = _z_[2], s1 = _z_[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0]){
      var seed$1 = match[1];
      seed$0 = seed$1;
     }
     else{
      var seed$2 = match[2], i$0 = caml_call2(Base_Import[91], i, 1);
      i = i$0;
      seed$0 = seed$2;
     }
    }
   }
   function length_is_bounded_by(opt, max, t){
    var min = opt ? opt[1] : -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number" && 16394 === match$0[1]){var len = match$0[2]; if(min <= len) return 1;}
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], acc$0 = caml_call2(Base_Import[91], acc, 1);
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function iteri(s, f){
    return iter
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function foldi(s, init, f){
    return fold
            (mapi(s, function(i, s){return [0, i, s];}),
             init,
             function(acc, param){
              var s = param[2], i = param[1];
              return caml_call3(f, i, acc, s);
             });
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$0){
    var next = param[2], s = param[1];
    function f(param){
     if(! param) return 0;
     var
      match = param[1],
      s = match[2],
      acc = match[1],
      match$0 = caml_call1(next, s);
     if(typeof match$0 !== "number" && 0 === match$0[0]){
      var s$2 = match$0[1];
      return [0, [0, [0, acc, s$2]]];
     }
     if(acc){
      if(typeof match$0 === "number")
       return [1, caml_call1(Base_List1[21], acc), 0];
      var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
      return caml_call2(break$0, prev, cur)
              ? [1,
                caml_call1(Base_List1[21], acc),
                [0, [0, [0, cur, 0], s$0]]]
              : [0, [0, [0, [0, cur, acc], s$0]]];
     }
     if(typeof match$0 === "number") return 0;
     var s$1 = match$0[2], cur$0 = match$0[1];
     return [0, [0, [0, [0, cur$0, 0], s$1]]];
    }
    var init = [0, [0, 0, s]];
    return [0, init, f];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(last_elt){
       var b = last_elt[1];
       if(caml_call2(equal, a, b)) return [0, [0, b, a]];
      }
      var last_elt$0 = [0, a];
      last_elt = last_elt$0;
      s$0 = s$2;
     }
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){
    return fold
            (s,
             0,
             function(acc, elt){
              var
               _x_ = caml_call1(f, elt),
               _y_ = caml_call1(Base_Bool[29], _x_);
              return caml_call2(Base_Import[91], acc, _y_);
             });
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(i, acc, elt){
              var
               _v_ = caml_call2(f, i, elt),
               _w_ = caml_call1(Base_Bool[29], _v_);
              return caml_call2(Base_Import[91], acc, _w_);
             });
   }
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function init(n, f){
    function f$0(i){
     if(n <= i) return 0;
     var _u_ = caml_call2(Base_Import[91], i, 1);
     return [1, caml_call1(f, i), _u_];
    }
    return [0, 0, f$0];
   }
   function sub(s, pos, len){
    var _s_ = pos < 0 ? 1 : 0, _t_ = _s_ || (len < 0 ? 1 : 0);
    if(_t_) caml_call1(Base_Import[124], cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= caml_call2(Base_Import[93], i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var
    Infix = [0, append],
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn";
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var _r_ = param[1];
             if(815032112 === _r_){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > _r_){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(init){
    function f(x){return [1, x, x];}
    return [0, init, f];
   }
   function cycle_list_exn(xs){
    if(caml_call1(Base_List1[24], xs))
     caml_call1(Base_Import[126], cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function f(param){return s;}
    var s$0 = repeat(0);
    return caml_call2(bind$0, s$0, f);
   }
   function cartesian_product(sa, sb){
    function f(a){return zip(repeat(a), sb);}
    return caml_call2(bind$0, sa, f);
   }
   function singleton(x){return caml_call1(return$1, x);}
   function delayed_fold(s, init, f, finish){
    return caml_call4
            (Expert[2],
             s,
             init,
             function(acc, option, k){
              if(! option) return caml_call1(k, acc);
              var a = option[1];
              return caml_call3(f, acc, a, k);
             },
             finish);
   }
   function fold_m(bind, return$0, t, init, f){
    return caml_call4
            (Expert[2],
             t,
             init,
             function(acc, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, acc), k);
              var a = option[1];
              return caml_call2(bind, caml_call2(f, acc, a), k);
             },
             return$0);
   }
   function iter_m(bind, return$0, t, f){
    return caml_call4
            (Expert[2],
             t,
             0,
             function(param, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, 0), k);
              var a = option[1];
              return caml_call2(bind, caml_call1(f, a), k);
             },
             return$0);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
      if(0 !== match$0[0]){var x = match$0[1]; return x;}
      var acc$0 = match$0[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[13], acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
      if(0 !== e[0]) return e;
      var acc$0 = e[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(_q_){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 !== match[0]){
                 var s$2 = match[2], a = match[1];
                 return [1, a, memoize(s$2)];
                }
                var s$1 = match[1];
                s$0 = s$1;
               }
              }]];
    }
    return [0,
            memoize(s),
            function(param){
             var l = param[1], _p_ = caml_obj_tag(l);
             if(250 === _p_) return l[1];
             if(246 !== _p_ && 244 !== _p_) return l;
             return caml_call1(CamlinternalLazy[2], l);
            }];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], i$0 = caml_call2(Base_Import[91], i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], x = match[1];
      if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
      s$0 = s$2;
     }
    }
   }
   function compare$0(compare_a, t1, t2){
    return caml_call1
            (Base_With_return[1],
             function(r){
              iter
               (zip_full(t1, t2),
                function(param){
                 var _n_ = param[1];
                 if(737457313 !== _n_)
                  return 847852583 <= _n_
                          ? caml_call1(r, 1)
                          : caml_call1(r, -1);
                 var
                  match = param[2],
                  v2 = match[2],
                  v1 = match[1],
                  c = caml_call2(compare_a, v1, v2),
                  _o_ = 0 !== c ? 1 : 0;
                 return _o_ ? caml_call1(r, c) : _o_;
                });
              return 0;
             });
   }
   function equal(equal_a, t1, t2){
    return for_all
            (zip_full(t1, t2),
             function(param){
              if(737457313 !== param[1]) return 0;
              var match = param[2], a2 = match[2], a1 = match[1];
              return caml_call2(equal_a, a1, a2);
             });
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return caml_call1(Base_List1[24], done_stack)
              ? 0
              : [0, [0, caml_call1(Base_List1[21], done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, caml_call1(Base_List1[21], [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(init){
    function f(seq){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var tl = match[2], hd = match[1];
     return [1, hd, tl];
    }
    return [0, init, f];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state){
     var state$0 = state;
     for(;;){
      var match = caml_call1(next, state$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var state$2 = match[2], hd = match[1];
       return [0, hd, function(param){return loop(state$2);}];
      }
      var state$1 = match[1];
      state$0 = state$1;
     }
    }
    return function(param){return loop(state);};
   }
   function return$2(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$3 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11],
    _m_ = [0, 0];
   function yield$0(e, k){return [0, [1, e, k]];}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$3);
   }
   function run(t){
    function init(param){return caml_call1(t, function(param){return _m_;});}
    function f(thunk){var step = caml_call1(thunk, 0)[1]; return step;}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       sexp_of_t$0,
       equal,
       compare$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_deduped_and_sorted,
       merge_sorted,
       Merge_with_duplicates_element,
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$3,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$0,
        of_sequence,
        run],
       Expert];
   runtime.caml_register_global(51, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexp_grammar, Sexplib0__Sexpable
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var _i_ = caml_call1(M[2], s); return _i_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[158], exn, sexp);
     }
    }
    function sexp_of_t(t){
     var _h_ = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], _h_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var _g_ = caml_call1(M[2], s); return _g_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[158], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var _f_ = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, _f_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var _e_ = caml_call1(M[2], s); return _e_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[158], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var _d_ = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, _d_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var _c_ = caml_call1(M[2], s); return _c_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[158], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var _b_ = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, _b_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return caml_call2
              (Base_Import[157], cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var _a_ = caml_call1(M[1], s); return _a_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[158], exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    var
     t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_Import[183]);
    return [0, t_sexp_grammar, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(3, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24],
    compare = Base_Import[235],
    globalize = Base_Import[262],
    t_of_sexp = Base_Import[175],
    sexp_of_t = Base_Import[151];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[196], a_sexp_grammar);
   }
   function Sorter(S){
    var get = S[1], set = S[2], length = S[3];
    function swap(arr, i, j){
     var tmp = caml_call2(get, arr, i);
     caml_call3(set, arr, i, caml_call2(get, arr, j));
     return caml_call3(set, arr, j, tmp);
    }
    function sort(arr, compare, left, right){
     var _aD_ = caml_call2(Base_Import[91], left, 1);
     if(right >= _aD_){
      var pos = _aD_;
      for(;;){
       var v = caml_call2(get, arr, pos), final_pos = pos;
       for(;;){
        var i_next = caml_call2(Base_Import[93], final_pos, 1);
        if(left > i_next) break;
        if(0 >= caml_call2(compare, caml_call2(get, arr, i_next), v)) break;
        caml_call3(set, arr, final_pos, caml_call2(get, arr, i_next));
        final_pos = i_next;
       }
       caml_call3(set, arr, final_pos, v);
       var _aE_ = pos + 1 | 0;
       if(right === pos) break;
       pos = _aE_;
      }
     }
     return 0;
    }
    var Insertion_sort = [0, sort];
    function heapify(arr, compare, root, left, right){
     var root$0 = root;
     for(;;){
      var
       relative_root = caml_call2(Base_Import[93], root$0, left),
       _aw_ = caml_call2(Base_Import[88], 2, relative_root),
       _ax_ = caml_call2(Base_Import[91], _aw_, left),
       left_child = caml_call2(Base_Import[91], _ax_, 1),
       _ay_ = caml_call2(Base_Import[88], 2, relative_root),
       _az_ = caml_call2(Base_Import[91], _ay_, left),
       right_child = caml_call2(Base_Import[91], _az_, 2);
      a:
      {
       if(left_child <= right){
        var _aA_ = caml_call2(get, arr, root$0);
        if(0 < caml_call2(compare, caml_call2(get, arr, left_child), _aA_)){var largest = left_child; break a;}
       }
       var largest = root$0;
      }
      a:
      {
       if(right_child <= right){
        var _aB_ = caml_call2(get, arr, largest);
        if(0 < caml_call2(compare, caml_call2(get, arr, right_child), _aB_)){var largest$0 = right_child; break a;}
       }
       var largest$0 = largest;
      }
      var _aC_ = largest$0 !== root$0 ? 1 : 0;
      if(! _aC_) return _aC_;
      swap(arr, root$0, largest$0);
      root$0 = largest$0;
     }
    }
    function sort$0(arr, compare, left, right){
     var
      _ar_ = caml_call2(Base_Import[91], left, right),
      _as_ = caml_call2(Base_Import[95], _ar_, 2);
     if(_as_ >= left){
      var i = _as_;
      for(;;){
       heapify(arr, compare, i, left, right);
       var _at_ = i - 1 | 0;
       if(left === i) break;
       i = _at_;
      }
     }
     var _au_ = caml_call2(Base_Import[91], left, 1);
     if(right >= _au_){
      var i$0 = right;
      for(;;){
       swap(arr, left, i$0);
       heapify(arr, compare, left, left, caml_call2(Base_Import[93], i$0, 1));
       var _av_ = i$0 - 1 | 0;
       if(_au_ === i$0) break;
       i$0 = _av_;
      }
     }
     return 0;
    }
    var Heap_sort = [0, sort$0];
    function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
     function compare_and_swap(i, j){
      var
       _ap_ = caml_call2(get, arr, j),
       _aq_ = 0 < caml_call2(compare, caml_call2(get, arr, i), _ap_) ? 1 : 0;
      return _aq_ ? swap(arr, i, j) : _aq_;
     }
     compare_and_swap(m1, m2);
     compare_and_swap(m4, m5);
     compare_and_swap(m1, m3);
     compare_and_swap(m2, m3);
     compare_and_swap(m1, m4);
     compare_and_swap(m3, m4);
     compare_and_swap(m2, m5);
     compare_and_swap(m2, m3);
     return compare_and_swap(m4, m5);
    }
    function intro_sort(arr, max_depth, compare, left, right){
     var max_depth$0 = max_depth, left$0 = left;
     for(;;){
      var
       _ao_ = caml_call2(Base_Import[93], right, left$0),
       len = caml_call2(Base_Import[91], _ao_, 1);
      if(32 >= len)
       return caml_call4(Insertion_sort[1], arr, compare, left$0, right);
      if(0 > max_depth$0)
       return caml_call4(Heap_sort[1], arr, compare, left$0, right);
      var
       max_depth$1 = caml_call2(Base_Import[93], max_depth$0, 1),
       _an_ = caml_call2(Base_Import[93], right, left$0),
       sixth = caml_call2(Base_Import[95], _an_, 6),
       m1 = caml_call2(Base_Import[91], left$0, sixth),
       m2 = caml_call2(Base_Import[91], m1, sixth),
       m3 = caml_call2(Base_Import[91], m2, sixth),
       m4 = caml_call2(Base_Import[91], m3, sixth),
       m5 = caml_call2(Base_Import[91], m4, sixth);
      five_element_sort(arr, compare, m1, m2, m3, m4, m5);
      var
       m2_val = caml_call2(get, arr, m2),
       m3_val = caml_call2(get, arr, m3),
       m4_val = caml_call2(get, arr, m4),
       match =
         0 === caml_call2(compare, m2_val, m3_val)
          ? [0, m2_val, m3_val, 1]
          : 0
            === caml_call2(compare, m3_val, m4_val)
            ? [0, m3_val, m4_val, 1]
            : [0, m2_val, m4_val, 0],
       middle_sorted = match[3],
       pivot2 = match[2],
       pivot1 = match[1],
       l$0 = left$0,
       p$1 = left$0,
       r$2 = right;
      for(;;){
       if(r$2 < p$1) break;
       var pv = caml_call2(get, arr, p$1);
       if(0 <= caml_call2(compare, pv, pivot1))
        if(0 < caml_call2(compare, pv, pivot2)){
         var r = r$2;
         for(;;){
          if(p$1 >= r) break;
          if(0 >= caml_call2(compare, caml_call2(get, arr, r), pivot2)) break;
          var r$0 = caml_call2(Base_Import[93], r, 1);
          r = r$0;
         }
         swap(arr, r, p$1);
         var r$1 = caml_call2(Base_Import[93], r, 1);
         r$2 = r$1;
        }
        else{var p = caml_call2(Base_Import[91], p$1, 1); p$1 = p;}
       else{
        swap(arr, p$1, l$0);
        var
         p$0 = caml_call2(Base_Import[91], p$1, 1),
         l = caml_call2(Base_Import[91], l$0, 1);
        l$0 = l;
        p$1 = p$0;
       }
      }
      intro_sort
       (arr,
        max_depth$1,
        compare,
        left$0,
        caml_call2(Base_Import[93], l$0, 1));
      if(1 - middle_sorted) intro_sort(arr, max_depth$1, compare, l$0, r$2);
      var left$1 = caml_call2(Base_Import[91], r$2, 1);
      max_depth$0 = max_depth$1;
      left$0 = left$1;
     }
    }
    function sort$1(arr, compare, left, right){
     return intro_sort(arr, 32, compare, left, right);
    }
    var Intro_sort = [0, sort$1, five_element_sort];
    function sort$2(pos, len, arr, compare){
     var
      _ak_ = caml_call1(length, arr),
      match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _ak_),
      len$0 = match[2],
      pos$0 = match[1],
      _al_ = caml_call2(Base_Import[91], pos$0, len$0),
      _am_ = caml_call2(Base_Import[93], _al_, 1);
     return caml_call4(Intro_sort[1], arr, compare, pos$0, _am_);
    }
    return [0, , , , , Insertion_sort, Heap_sort, Intro_sort, sort$2];
   }
   function get(_aj_, _ai_){return _aj_[1 + _ai_];}
   function set(_ah_, _ag_, _af_){_ah_[1 + _ag_] = _af_; return 0;}
   function length(_ae_){return _ae_.length - 1;}
   var
    Sort = Sorter([0, get, set, length]),
    sort = Sort[8],
    _a_ = [0, cst_src_array_ml, 456, 14],
    _b_ =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    cst_Array_iter2_exn = "Array.iter2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    _c_ = [0, "Array.findi_exn: not found"],
    _d_ = [0, "Array.find_exn: not found"];
   function of_array(t){return t;}
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return caml_call1(copy, a2);
    if(0 === l2) return caml_call1(copy, a1);
    var _$_ = a1[1 + caml_call2(Base_Import[93], l1, 1)];
    if(0 <= caml_call2(compare, a2[1], _$_))
     return caml_call2(append, a1, a2);
    var _aa_ = a2[1 + caml_call2(Base_Import[93], l2, 1)];
    if(0 < caml_call2(compare, a1[1], _aa_))
     return caml_call2(append, a2, a1);
    var
     len = caml_call2(Base_Import[91], l1, l2),
     merged = caml_call2(create, len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     _ac_ = caml_call2(Base_Import[93], len, 1),
     _ab_ = 0;
    if(_ac_ >= 0){
     var i = _ab_;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[1 + a1_index[1]], a2[1 + a2_index[1]])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[1 + i] = a1[1 + a1_index[1]];
       a1_index[1] = caml_call2(Base_Import[91], a1_index[1], 1);
      }
      else{
       merged[1 + i] = a2[1 + a2_index[1]];
       a2_index[1] = caml_call2(Base_Import[91], a2_index[1], 1);
      }
      var _ad_ = i + 1 | 0;
      if(_ac_ === i) break;
      i = _ad_;
     }
    }
    return merged;
   }
   function copy_matrix(___){return caml_call2(map, ___, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return caml_call2
            (map,
             t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (map,
         t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     _Y_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _X_ = 0;
    if(_Y_ >= 0){
     var i = _X_;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[1 + i]);
      var _Z_ = i + 1 | 0;
      if(_Y_ === i) break;
      i = _Z_;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return caml_call2
            (mapi,
             t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (mapi,
         t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[91], count, 1)
                      : count;
             });
   }
   function concat_map(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(map, t, f)));
   }
   function concat_mapi(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(mapi, t, f)));
   }
   function rev_inplace(t){
    var i = [0, 0], j = [0, caml_call2(Base_Import[93], t.length - 1, 1)];
    for(;;){
     if(i[1] >= j[1]) return 0;
     caml_call3(swap, t, i[1], j[1]);
     i[1]++;
     j[1]--;
    }
   }
   function rev(t){
    var t$0 = caml_call1(copy, t);
    rev_inplace(t$0);
    return t$0;
   }
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a = l[1],
     _U_ = caml_call1(Base_List[17], l$0),
     len = caml_call2(Base_Import[91], 1, _U_),
     t = caml_call2(create, len, a),
     r = [0, l$0],
     _V_ = caml_call2(Base_Import[93], len, 2);
    if(_V_ >= 0){
     var i = _V_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var l$1 = match[2], a$0 = match[1];
      caml_check_bound(t, i)[1 + i] = a$0;
      r[1] = l$1;
      var _W_ = i - 1 | 0;
      if(0 === i) break;
      i = _W_;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _S_ = caml_call1(f, hd),
     _T_ = caml_call1(Base_List[17], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, _T_), _S_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call1(f, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _Q_ = caml_call2(f, 0, hd),
     _R_ = caml_call1(Base_List[17], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, _R_), _Q_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call2(f, i, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     _O_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _N_ = 0;
    if(_O_ >= 0){
     var i = _N_;
     for(;;){
      var match = caml_call2(f, i, t[1 + i]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = caml_call2(create, t.length - 1, a);
       r[1][1 + k[1]] = a;
       k[1]++;
      }
      var _P_ = i + 1 | 0;
      if(_O_ === i) break;
      i = _P_;
     }
    }
    return k[1] === t.length - 1
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(_M_){return _M_;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, _L_ = n1 !== n2 ? 1 : 0;
    return _L_ ? caml_call5(invalid_argf, _b_, name, n1, n2, 0) : _L_;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return caml_call2
            (iteri, t1, function(i, x1){return caml_call2(f, x1, t2[1 + i]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return caml_call2
            (init,
             t1.length - 1,
             function(i){return caml_call2(f, t1[1 + i], t2[1 + i]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[1 + i]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[1 + i[1]])){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[1 + i[1]])){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, caml_call2(Base_Import[93], length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function equal(equal, t1, t2){
    var _K_ = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return _K_ ? for_all2_exn(t1, t2, equal) : _K_;
   }
   function map_inplace(t, f){
    var _I_ = caml_call2(Base_Import[93], t.length - 1, 1), _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      t[1 + i] = caml_call1(f, t[1 + i]);
      var _J_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _J_;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[1 + i[1]];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
      }
      else
       i[1]++;
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, [0, i, value]];},
             function(param){return 0;});
   }
   function findi_exn(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, i, value];},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[267], _c_], 1);
             });
   }
   function find_exn(t, f){
    return findi_internal
            (t,
             function(i, x){return caml_call1(f, x);},
             function(param, value){return value;},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[267], _d_], 1);
             });
   }
   function find(t, f){
    var _G_ = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2
            (Base_Option[22],
             _G_,
             function(param){var x = param[2]; return x;});
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[50], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call1(f, value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found = [0, Base_Import[267], [0, "Array.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[50], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call2(f, i[1], value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found$0 = [0, Base_Import[267], [0, "Array.find_mapi_exn: not found"]],
    cst_Array_reduce_exn = "Array.reduce_exn";
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[1 + i[1]];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; i[1]++;}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var
     r = [0, t[1]],
     _E_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _D_ = 1;
    if(_E_ >= 1){
     var i = _D_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _F_ = i + 1 | 0;
      if(_E_ === i) break;
      i = _F_;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return caml_call1(Base_Import[126], cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var
    permute = Base_Array_permute[25],
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_transpose_exn = "Array.transpose_exn";
   function random_element_exn(opt, t){
    var random_state = opt ? opt[1] : Base_Random[18][1];
    if(is_empty(t))
     return caml_call1(Base_Import[124], cst_Array_random_element_exn_e);
    var _C_ = caml_call2(Base_Random[18][6], random_state, t.length - 1);
    return caml_check_bound(t, _C_)[1 + _C_];
   }
   function random_element(opt, t){
    var random_state = opt ? opt[1] : Base_Random[18][1];
    try{var _A_ = [0, random_element_exn([0, random_state], t)]; return _A_;}
    catch(_B_){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? caml_call1(Base_Import[124], cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = caml_call2(create, n, x),
     res2 = caml_call2(create, n, y),
     _y_ = caml_call2(Base_Import[93], n, 1),
     _x_ = 1;
    if(_y_ >= 1){
     var i = _x_;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[1 + i],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[1 + i] = x$0;
      caml_check_bound(res2, i)[1 + i] = y$0;
      var _z_ = i + 1 | 0;
      if(_y_ === i) break;
      i = _z_;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = caml_call1(copy, t);
    sort(0, 0, t1, compare);
    return t1;
   }
   function partition_mapi(t, f){
    var
     both = caml_call2(mapi, t, f),
     firsts =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     seconds =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, firsts, seconds];
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];});
   }
   function partition_map(t, f){
    return partition_mapi(t, function(param, x){return caml_call1(f, x);});
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(param, x){return caml_call1(f, x);});
   }
   function last(t){
    var _w_ = caml_call2(Base_Import[93], t.length - 1, 1);
    return caml_check_bound(t, _w_)[1 + _w_];
   }
   function to_sequence_mutable(t){
    return caml_call2
            (Base_Sequence[41],
             0,
             function(i){
              if(t.length - 1 <= i) return 0;
              var _v_ = caml_call2(Base_Import[91], i, 1);
              return [1, caml_check_bound(t, i)[1 + i], _v_];
             });
   }
   function to_sequence(t){return to_sequence_mutable(caml_call1(copy, t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      _k_ = caml_check_bound(t2, 0)[1],
      _l_ = [0, caml_check_bound(t1, 0)[1], _k_],
      t = caml_call2(create, caml_call2(Base_Import[88], n1, n2), _l_),
      r = [0, 0],
      _n_ = caml_call2(Base_Import[93], n1, 1),
      _m_ = 0;
     if(_n_ >= 0){
      var i1 = _m_;
      for(;;){
       var _p_ = caml_call2(Base_Import[93], n2, 1), _o_ = 0;
       if(_p_ >= 0){
        var i2 = _o_;
        for(;;){
         var
          _r_ = caml_check_bound(t2, i2)[1 + i2],
          _s_ = [0, caml_check_bound(t1, i1)[1 + i1], _r_],
          _t_ = r[1];
         caml_check_bound(t, _t_)[1 + _t_] = _s_;
         r[1]++;
         var _u_ = i2 + 1 | 0;
         if(_p_ === i2) break;
         i2 = _u_;
        }
       }
       var _q_ = i1 + 1 | 0;
       if(_n_ === i1) break;
       i1 = _q_;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              caml_call2
               (init,
                depth,
                function(d){
                 return caml_call2
                         (init,
                          width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[1 + w], d)
                                   [1 + d];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return caml_call1(Base_Import[126], cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(_j_, _i_){return caml_check_bound(_j_, _i_)[1 + _i_];}
   function length$0(_h_){return _h_.length - 1;}
   var
    include = caml_call1(Base_Binary_searchable[2], [0, get$0, length$0]),
    binary_search = include[1],
    binary_search_segmented = include[2],
    _e_ = [0, cst_src_array_ml, 887, 8];
   function length$1(_g_){return _g_.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1)
     return caml_call2(create, len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length$1, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){
    return caml_call2(iter, t, invariant_a);
   }
   var
    Base_Array =
      [0,
       compare,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       of_list,
       of_array,
       append,
       map,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       invariant,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       make_matrix,
       copy_matrix,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       fold_right,
       sort,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi_exn,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       to_sequence,
       to_sequence_mutable,
       [0,
        [0, Sort[5], Sort[6], Sort[7]],
        function(_f_){return [0, Sorter(_f_)[8]];}]];
   runtime.caml_register_global(28, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_local
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Obj_local = [0];
   runtime.caml_register_global(0, Base_Obj_local, "Base__Obj_local");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    _a_ = [0, "src/obj_array.ml", 12, 2],
    _b_ = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    _c_ = [0, ""];
   function invariant(t){
    var _t_ = Stdlib_Obj[17];
    if(caml_obj_tag(t) !== _t_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function length(_s_){return _s_.length - 1;}
   function sexp_of_t(t){
    var
     _r_ =
       [0,
        cst_Obj_array_t_of_length,
        [0, caml_call1(Base_Int0[1], t.length - 1), _b_]];
    return [0, caml_call2(Base_String0[14], _c_, _r_)];
   }
   var zero_obj = 0;
   function create_zero(len){
    return caml_call2(Base_Array0[4], len, zero_obj);
   }
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[1 + i];}
   function unsafe_get(t, i){return t[1 + i];}
   function unsafe_set_with_caml_modify(t, i, obj){t[1 + i] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[1 + i] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int$0){t[1 + i] = int$0; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _q_ = 1 - caml_call2(Base_Import[128], old_obj, obj);
    return _q_ ? unsafe_set_with_caml_modify(t, i, obj) : _q_;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _p_ = 1 - caml_call2(Base_Import[128], old_obj, obj);
    return _p_ ? unsafe_set_with_caml_modify(t, i, obj) : _p_;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    if(typeof x !== "number"){
     var _l_ = Stdlib_Obj[16];
     if(caml_obj_tag(x) === _l_){
      var
       t = create_zero(len),
       _n_ = caml_call2(Base_Import[93], len, 1),
       _m_ = 0;
      if(_n_ >= 0){
       var i = _m_;
       for(;;){
        unsafe_set_with_caml_modify(t, i, x);
        var _o_ = i + 1 | 0;
        if(_n_ === i) break;
        i = _o_;
       }
      }
      return t;
     }
    }
    return caml_call2(Base_Array0[4], len, x);
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int$0){
    var old_obj = t[1 + i];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int$0)
            : unsafe_set_with_caml_modify(t, i, int$0);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[1 + i], _k_ = 1 - (typeof old_obj === "number" ? 1 : 0);
    return _k_ ? unsafe_set_with_caml_modify(t, i, 0) : _k_;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var _e_ = caml_call2(Base_Import[93], len, 1), _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var i$0 = caml_call2(Base_Import[91], src_pos, i), _i_ = src[1 + i$0];
       unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i), _i_);
       var _f_ = i + 1 | 0;
       if(_e_ === i) break;
       i = _f_;
      }
     }
     return 0;
    }
    var _g_ = caml_call2(Base_Import[93], len, 1);
    if(_g_ >= 0){
     var i$1 = _g_;
     for(;;){
      var i$2 = caml_call2(Base_Import[91], src_pos, i$1), _j_ = src[1 + i$2];
      unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i$1), _j_);
      var _h_ = i$1 - 1 | 0;
      if(0 === i$1) break;
      i$1 = _h_;
     }
    }
    return 0;
   }
   var
    include = caml_call1(Base_Blit[1], [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    sub = include[4],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Container, Base__Import, Base__List, Base__Obj_array, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    empty = Base_Obj_array[12];
   function unsafe_create_uninitialized(len){
    return caml_call1(Base_Obj_array[9], len);
   }
   function create_obj_array(len){return caml_call1(Base_Obj_array[9], len);}
   function create(len, x){return caml_call2(Base_Obj_array[8], len, x);}
   function singleton(x){return caml_call1(Base_Obj_array[11], x);}
   function swap(t, i, j){return caml_call3(Base_Obj_array[18], t, i, j);}
   function get(arr, i){return caml_call2(Base_Obj_array[14], arr, i);}
   function set(arr, i, x){return caml_call3(Base_Obj_array[16], arr, i, x);}
   function unsafe_get(arr, i){return caml_call2(Base_Obj_array[15], arr, i);}
   function unsafe_set(arr, i, x){
    return caml_call3(Base_Obj_array[17], arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return caml_call3(Base_Obj_array[22], arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return caml_call3(Base_Obj_array[21], arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return caml_call3(Base_Obj_array[20], arr, i, x);
   }
   var
    length = Base_Obj_array[13],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[10];
   function unsafe_set_omit_phys_equal_che(t, i, x){return caml_call3(Base_Obj_array[23], t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[24], t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[19], t, i, x);
   }
   var
    unsafe_clear_if_pointer = Base_Obj_array[25],
    _a_ = [0, cst_src_uniform_array_ml, 72, 2],
    cst_Uniform_array_init = "Uniform_array.init",
    cst_Array_map2_exn = "Array.map2_exn";
   function invariant(t){
    var _H_ = Stdlib_Obj[17];
    if(runtime.caml_obj_tag(t) !== _H_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function init(l, f){
    if(0 > l) return caml_call1(Base_Import[126], cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     _F_ = caml_call2(Base_Import[93], l, 1),
     _E_ = 0;
    if(_F_ >= 0){
     var i = _E_;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var _G_ = i + 1 | 0;
      if(_F_ === i) break;
      i = _G_;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(_D_){return arr[1 + _D_];});
   }
   function map(a, f){
    return init
            (caml_call1(length, a),
             function(i){return caml_call1(f, unsafe_get(a, i));});
   }
   function mapi(a, f){
    return init
            (caml_call1(length, a),
             function(i){return caml_call2(f, i, unsafe_get(a, i));});
   }
   function iter(a, f){
    var
     _A_ = caml_call1(length, a),
     _B_ = caml_call2(Base_Import[93], _A_, 1),
     _z_ = 0;
    if(_B_ >= 0){
     var i = _z_;
     for(;;){
      caml_call1(f, unsafe_get(a, i));
      var _C_ = i + 1 | 0;
      if(_B_ === i) break;
      i = _C_;
     }
    }
    return 0;
   }
   function iteri(a, f){
    var
     _w_ = caml_call1(length, a),
     _x_ = caml_call2(Base_Import[93], _w_, 1),
     _v_ = 0;
    if(_x_ >= 0){
     var i = _v_;
     for(;;){
      caml_call2(f, i, unsafe_get(a, i));
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      i = _y_;
     }
    }
    return 0;
   }
   function foldi(a, init, f){
    var
     acc = [0, init],
     _r_ = caml_call1(length, a),
     _s_ = caml_call2(Base_Import[93], _r_, 1),
     _q_ = 0;
    if(_s_ >= 0){
     var i = _q_;
     for(;;){
      var _t_ = unsafe_get(a, i);
      acc[1] = caml_call3(f, i, acc[1], _t_);
      var _u_ = i + 1 | 0;
      if(_s_ === i) break;
      i = _u_;
     }
    }
    return acc[1];
   }
   function to_list(t){
    var _o_ = caml_call1(length, t);
    return caml_call2(Base_List[40], _o_, function(_p_){return get(t, _p_);});
   }
   function of_list(l){
    var
     len = caml_call1(Base_List[17], l),
     res = unsafe_create_uninitialized(len);
    caml_call2(Base_List[34], l, function(i, x){return set(res, i, x);});
    return res;
   }
   function to_array(t){
    var _n_ = caml_call1(length, t);
    return caml_call2
            (Base_Array[40], _n_, function(i){return unsafe_get(t, i);});
   }
   function exists(t, f){
    var
     _m_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[93], _m_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 0;
     var _l_ = caml_call1(f, unsafe_get(t, i));
     if(_l_) return _l_;
     var i$0 = caml_call2(Base_Import[93], i, 1);
     i = i$0;
    }
   }
   function for_all(t, f){
    var
     _k_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[93], _k_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 1;
     var _j_ = caml_call1(f, unsafe_get(t, i));
     if(! _j_) return _j_;
     var i$0 = caml_call2(Base_Import[93], i, 1);
     i = i$0;
    }
   }
   function map2_exn(t1, t2, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[126], cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var _i_ = unsafe_get(t2, i);
              return caml_call2(f, unsafe_get(t1, i), _i_);
             });
   }
   function t_sexp_grammar(grammar){
    var _h_ = caml_call1(Base_Array[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _h_);
   }
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Array[3], Base_Array[4]]),
        [0, to_array, of_array]),
    t_of_sexp = include[1],
    sexp_of_t = include[2],
    _b_ = [0, cst_src_uniform_array_ml, 166, 8];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < caml_call1(length, t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub = include$0[4],
    subo = include$0[5];
   function fold(t, init, f){
    var
     r = [0, init],
     _d_ = caml_call1(length, t),
     _e_ = caml_call2(Base_Import[93], _d_, 1),
     _c_ = 0;
    if(_e_ >= 0){
     var i = _c_;
     for(;;){
      var _f_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _f_);
      var _g_ = i + 1 | 0;
      if(_e_ === i) break;
      i = _g_;
     }
    }
    return r[1];
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function compare(compare_elt, a, b){
    if(caml_call2(Base_Import[128], a, b)) return 0;
    var
     len_a = caml_call1(length, a),
     len_b = caml_call1(length, b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get(a, i),
      r = unsafe_get(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
    }
   }
   var
    Sort = caml_call1(Base_Array[107][2], [0, unsafe_get, unsafe_set, length]),
    sort = Sort[1],
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       foldi,
       of_array,
       to_array,
       of_list,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer,
       exists,
       for_all,
       map2_exn,
       min_elt,
       max_elt,
       sort];
   runtime.caml_register_global(14, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Base__Import, Base__Import0, Base__Option, Base__Printf, Stdlib__Float, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float;
   function ceil(_p_){return Math.ceil(_p_);}
   function floor(_o_){return Math.floor(_o_);}
   function mod_float(_n_, _m_){return _n_ % _m_;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    float_of_string_opt = Base_Import[85][36],
    nan = Base_Import[85][24],
    infinity = Base_Import[85][22],
    neg_infinity = Base_Import[85][23],
    max_finite_value = Base_Import[85][25],
    epsilon_float = Base_Import[85][27],
    classify_float = runtime.caml_classify_float;
   function abs_float(_l_){return Math.abs(_l_);}
   var
    is_integer = Stdlib_Float[18],
    _a_ =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function symbol(_k_, _j_){return Math.pow(_k_, _j_);}
   function symbol$0(a, b){
    if(caml_call2(Base_Import[108][1], b, 0.))
     caml_call4(Base_Printf[7], _a_, a, b, 0);
    var m = a % b;
    return caml_call2(Base_Import[108][1], m, 0.)
            ? caml_call2(Base_Import[92], m, b)
            : m;
   }
   var
    frexp = runtime.caml_frexp_float,
    ldexp = runtime.caml_ldexp_float,
    _b_ = [0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _f_ = [0, cst_src_float0_ml, 184, 4],
    _g_ = [0, cst_src_float0_ml, 180, 4];
   function is_nan(x){return caml_call2(Base_Import[108][3], x, x);}
   function to_int64_preserve_order(t){
    return is_nan(t)
            ? 0
            : caml_call2
               (Base_Import[108][4], t, 0.)
              ? _b_
              : caml_call2
                 (Base_Import[108][5], t, 0.)
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(caml_call1(Base_Import[114], t)))];
   }
   function to_int64_preserve_order_exn(x){
    var _i_ = to_int64_preserve_order(x);
    return caml_call4(Base_Option[29], 0, 0, 0, _i_);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, _c_)
            ? caml_int64_float_of_bits(x)
            : caml_call1
              (Base_Import[114], caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[85][24];
    var x = match[1], _h_ = 759637122 <= dir ? _d_ : _e_;
    return of_int64_preserve_order(runtime.caml_int64_add(x, _h_));
   }
   function upper_bound_for_int(num_bits){
    var exp = caml_call2(Base_Import[93], num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(caml_call2(Base_Import[94], x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = caml_call2(Base_Import[93], num_bits, 1),
     min_int_as_float = caml_call1(Base_Import[114], Math.pow(2., exp));
    if(53 <= caml_call2(Base_Import[93], num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, caml_call2(Base_Import[94], min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[108][1], t, min)
            ? min
            : caml_call2(Base_Import[108][1], max, t) ? max : t;
   }
   var x = 0.;
   function box(f){return caml_call2(Base_Import[92], f, x);}
   var
    include = Base_Import[108],
    symbol$1 = include[1],
    symbol$2 = include[2],
    symbol$3 = include[3],
    symbol$4 = include[4],
    symbol$5 = include[5],
    symbol$6 = include[6],
    ascending = include[7],
    descending = include[8],
    compare = include[9],
    equal = include[10],
    max = include[11],
    min = include[12],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       float_of_string_opt,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       clamp_unchecked,
       box,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       ascending,
       descending,
       compare,
       equal,
       max,
       min];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[227],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[253],
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[185],
    _a_ = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function to_string(t){return caml_call2(Base_String0[8], 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call3(failwithf, _a_, s, 0);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24],
    _b_ = [0, [1, 0], "%C"];
   function pp(fmt, c){return caml_call3(Stdlib_Format[139], fmt, _b_, c);}
   function invariant(param){return 0;}
   var
    _c_ = caml_call2(Base_Array0[12], 256, unsafe_of_int),
    all = caml_call1(Base_Array0[16], _c_),
    _d_ =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit";
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    a:
    {
     if(14 <= param){if(32 === param) break a;} else if(9 <= param) break a;
     return 0;
    }
    return 1;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    a:
    {
     if(91 <= param){
      if(25 < param - 97 >>> 0) break a;
     }
     else if(65 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_alphanum(param){
    var _u_ = param - 48 | 0;
    a:
    {
     if(42 < _u_ >>> 0){
      if(25 < _u_ - 49 >>> 0) break a;
     }
     else if(6 >= _u_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function get_digit_unsafe(t){
    var _s_ = caml_call1(to_int, 48), _t_ = caml_call1(to_int, t);
    return caml_call2(Base_Import[93], _t_, _s_);
   }
   function get_digit_exn(t){
    return is_digit(t)
            ? get_digit_unsafe(t)
            : caml_call3(failwithf, _d_, t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var _r_ = param - 48 | 0;
    a:
    {
     if(22 < _r_ >>> 0){
      if(5 < _r_ - 49 >>> 0) break a;
     }
     else if(6 >= _r_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_lower(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 97 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_upper(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 65 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        _j_ = caml_call1(to_int, 97),
        _k_ = caml_call1(to_int, t),
        _l_ = caml_call2(Base_Import[93], _k_, _j_);
       return caml_call2(Base_Import[91], _l_, 10);
      }
     }
     else if(71 > t){
      var
       _m_ = caml_call1(to_int, 65),
       _n_ = caml_call1(to_int, t),
       _o_ = caml_call2(Base_Import[93], _n_, _m_);
      return caml_call2(Base_Import[91], _o_, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var _p_ = caml_call1(to_int, 48), _q_ = caml_call1(to_int, t);
     return caml_call2(Base_Import[93], _q_, _p_);
    }
    var
     _h_ = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     _i_ = caml_call2(Base_Sexp[9], cst_Char_get_hex_digit_exn_not, _h_);
    return caml_call1(Base_Error[30], _i_);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[106][6],
    symbol$0 = Base_Import[106][2],
    symbol$1 = Base_Import[106][4],
    symbol$2 = Base_Import[106][5],
    symbol$3 = Base_Import[106][1],
    symbol$4 = Base_Import[106][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[163],
    sexp_of_t$1 = Base_Import[139],
    t_sexp_grammar$0 = Base_Import[185];
   function compare$0(c1, c2){
    var _f_ = caml_call1(lowercase, c2), _g_ = caml_call1(lowercase, c1);
    return caml_call2(Base_Import[106][9], _g_, _f_);
   }
   function hash_fold_t$1(state, t){
    var _e_ = caml_call1(lowercase, t);
    return caml_call2(Base_Import[206], state, _e_);
   }
   function hash$1(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$1, t);}
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16],
    include$1 = Base_Import[106],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$0 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_Char =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = caml_call1(Base_Bytes0[7], 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, caml_call1(Base_Char[32], i$3));
     var _j_ = i$3 + 1 | 0;
     if(255 === i$3) break;
     i$3 = _j_;
    }
    var
     _b_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement))
       - 1
       | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i$2 = _a_;
     for(;;){
      var
       index$0 =
         caml_call1(Base_Char[30], caml_string_unsafe_get(target, i$2));
      caml_bytes_unsafe_set
       (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
      var _i_ = i$2 + 1 | 0;
      if(_b_ === i$2) break;
      i$2 = _i_;
     }
    }
    var
     last_replacement =
       caml_string_unsafe_get
        (replacement, caml_ml_string_length(replacement) - 1 | 0),
     _c_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement)),
     _d_ = caml_ml_string_length(target) - 1 | 0;
    if(_d_ >= _c_){
     var i$1 = _c_;
     for(;;){
      var
       index = caml_call1(Base_Char[30], caml_string_unsafe_get(target, i$1));
      caml_bytes_unsafe_set(tr_map, index, last_replacement);
      var _h_ = i$1 + 1 | 0;
      if(_d_ === i$1) break;
      i$1 = _h_;
     }
    }
    var
     first_target = runtime.caml_string_get(target, 0),
     _f_ =
       caml_bytes_unsafe_get(tr_map, caml_call1(Base_Char[30], first_target));
    if(! caml_call2(Base_Char[15], _f_, first_target)){
     var i = 0;
     for(;;){
      if(256 === i)
       var _g_ = 0;
      else{
       var _e_ = caml_call1(Base_Char[32], i);
       if(! caml_call2(Base_Char[15], caml_bytes_unsafe_get(tr_map, i), _e_)){var i$0 = i + 1 | 0; i = i$0; continue;}
       var _g_ = 1;
      }
      if(_g_) break;
      return 0;
     }
    }
    return [0, runtime.caml_string_of_bytes(tr_map)];
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(_b_){return _b_;}
   function unstage(_a_){return _a_;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Import, Base__Indexed_container, Base__Int0, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Printf, Base__Sexp, Base__Staged, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$1 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$12 = cst$13,
    cst$11 = cst$13,
    cst$10 = cst$13,
    cst$8 = cst$13,
    cst$9 = cst$13,
    cst$6 = cst$13,
    cst$7 = cst$13,
    cst$5 = cst$13,
    cst$4 = cst$13,
    cst$3 = cst$13,
    cst$2 = cst$13,
    cst$1 = cst$13,
    cst$0 = cst$13,
    cst = cst$13,
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol_concat = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    escaped = Base_String0[6],
    lowercase = Base_String0[7],
    make = Base_String0[8],
    uncapitalize = Base_String0[10],
    uppercase = Base_String0[12],
    concat = Base_String0[14],
    iter = Base_String0[15],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[30],
    stage = Base_Staged[1],
    globalize = Base_Import[260],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[183],
    hashable = [0, hash, compare, sexp_of_t],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function unsafe_sub(src, pos, len){
    if(0 === len) return cst;
    var dst = caml_call1(Base_Bytes0[7], len);
    caml_blit_string(src, pos, dst, 0, len);
    return caml_string_of_bytes(dst);
   }
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    caml_call3
     (Base_Ordered_collection_common[2], pos, len, caml_ml_string_length(src));
    return unsafe_sub(src, pos, len);
   }
   function subo(opt, len, src){
    var pos = opt ? opt[1] : 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = caml_call2(Base_Import[93], caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char$0){
    var
     pos$1 = opt ? opt[1] : 0,
     total_length = caml_ml_string_length(t),
     _dq_ = caml_call2(Base_Import[93], total_length, pos$1),
     len$0 = caml_call2(Base_Option[28], len, _dq_);
    caml_call3(Base_Ordered_collection_common[2], pos$1, len$0, total_length);
    var end = caml_call2(Base_Import[91], pos$1, len$0), pos = pos$1;
    for(;;){
     var _dn_ = pos < end ? 1 : 0;
     if(_dn_){
      var
       _do_ =
         caml_call2(Base_Char[16], caml_string_unsafe_get(t, pos), char$0);
      if(! _do_){
       var pos$0 = caml_call2(Base_Import[91], pos, 1);
       pos = pos$0;
       continue;
      }
      var _dp_ = _do_;
     }
     else
      var _dp_ = _dn_;
     return _dp_;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(len <= pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[16], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[91], pos$0, 1);
     pos$0 = pos$1;
    }
   }
   function index_exn_internal(t, not_found, char$0){
    return index_from_exn_internal
            (t, 0, caml_ml_string_length(t), not_found, char$0);
   }
   var not_found = [0, Base_Import[267], [0, "String.index_exn: not found"]];
   function index_exn(t, char$0){
    return index_exn_internal(t, not_found, char$0);
   }
   var
    not_found$0 =
      [0, Base_Import[267], [0, "String.index_from_exn: not found"]],
    cst_String_index_from_exn = "String.index_from_exn";
   function index_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(0 <= pos && len >= pos)
     return index_from_exn_internal(t, pos, len, not_found$0, char$0);
    return caml_call1(Base_Import[126], cst_String_index_from_exn);
   }
   function rindex_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[16], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[93], pos$0, 1);
     pos$0 = pos$1;
    }
   }
   function rindex_exn_internal(t, not_found, char$0){
    var len = caml_ml_string_length(t);
    return rindex_from_exn_internal
            (t, caml_call2(Base_Import[93], len, 1), len, not_found, char$0);
   }
   var
    not_found$1 = [0, Base_Import[267], [0, "String.rindex_exn: not found"]];
   function rindex_exn(t, char$0){
    return rindex_exn_internal(t, not_found$1, char$0);
   }
   var
    not_found$2 =
      [0, Base_Import[267], [0, "String.rindex_from_exn: not found"]],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    _a_ = [0, cst_case_sensitive],
    _b_ = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    _c_ = [0, "kmp_array"],
    _d_ = [0, cst_case_sensitive],
    _e_ = [0, cst_pattern];
   function rindex_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(-1 <= pos && len > pos)
     return rindex_from_exn_internal(t, pos, len, not_found$2, char$0);
    return caml_call1(Base_Import[126], cst_String_rindex_from_exn);
   }
   function index(t, char$0){
    try{var _dl_ = [0, index_exn_internal(t, not_found, char$0)]; return _dl_;
    }
    catch(_dm_){
     var _dk_ = caml_wrap_exception(_dm_);
     if(_dk_[1] !== Base_Import[267] && _dk_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_dk_, 0);
     return 0;
    }
   }
   function rindex(t, char$0){
    try{
     var _di_ = [0, rindex_exn_internal(t, not_found$1, char$0)];
     return _di_;
    }
    catch(_dj_){
     var _dh_ = caml_wrap_exception(_dj_);
     if(_dh_[1] !== Base_Import[267] && _dh_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_dh_, 0);
     return 0;
    }
   }
   function index_from(t, pos, char$0){
    try{var _df_ = [0, index_from_exn(t, pos, char$0)]; return _df_;}
    catch(_dg_){
     var _de_ = caml_wrap_exception(_dg_);
     if(_de_[1] !== Base_Import[267] && _de_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_de_, 0);
     return 0;
    }
   }
   function rindex_from(t, pos, char$0){
    try{var _dc_ = [0, rindex_from_exn(t, pos, char$0)]; return _dc_;}
    catch(_dd_){
     var _db_ = caml_wrap_exception(_dd_);
     if(_db_[1] !== Base_Import[267] && _db_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_db_, 0);
     return 0;
    }
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     _da_ =
       [0,
        [1, [0, _a_, [0, caml_call1(Base_Import[136], case_sensitive), 0]]],
        0];
    return [1,
            [0,
             [1, [0, _b_, [0, caml_call1(Base_Import[137], pattern), 0]]],
             _da_]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[1 + caml_call2(Base_Import[93], matched_chars$0[1], 1)];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = caml_call2(Base_Import[91], matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[16] : Base_Char[53][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = caml_call2(Base_Array0[4], n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var
      matched_chars = [0, 0],
      _c__ = caml_call2(Base_Import[93], n, 1),
      _c9_ = 1;
     if(_c__ >= 1){
      var i = _c9_;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[1 + i] = matched_chars[1];
       var _c$_ = i + 1 | 0;
       if(_c__ === i) break;
       i = _c$_;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param, text){
    var
     pos = opt ? opt[1] : 0,
     kmp_array = param[3],
     case_sensitive = param[2],
     pattern = param[1];
    if
     (0 <= pos
      &&
       caml_call2
        (Base_Import[93],
         caml_ml_string_length(text),
         caml_ml_string_length(pattern))
       >= pos){
     var
      char_equal = get_char_equal(case_sensitive),
      j = [0, pos],
      matched_chars = [0, 0],
      k = caml_ml_string_length(pattern),
      n = caml_ml_string_length(text);
     for(;;){
      if(j[1] < n && matched_chars[1] < k){
       var next_text_char = caml_string_unsafe_get(text, j[1]);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
       j[1] = caml_call2(Base_Import[91], j[1], 1);
       continue;
      }
      return matched_chars[1] === k
              ? caml_call2(Base_Import[93], j[1], k)
              : -1;
     }
    }
    return -1;
   }
   function matches(t, str){return 0 <= index_internal(0, t, str) ? 1 : 0;}
   function index$0(pos, t, in$0){
    var p = index_internal(pos, t, in$0);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$0){
    var p = index_internal(pos, t, in$0);
    if(0 <= p) return p;
    var _c8_ = [0, [0, cst_substring, caml_call1(Base_Import[137], t[1])], 0];
    return caml_call1
            (raise_s, caml_call2(Base_Sexp[9], cst_Substring_not_found, _c8_));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var _c3_ = caml_call2(Base_Import[91], 1, caml_ml_string_length(text));
     return caml_call2(Base_List[40], _c3_, function(_c7_){return _c7_;});
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     _c4_ = 0;
    if(n >= 0){
     var j = _c4_;
     for(;;){
      if(matched_chars[1] === k){
       var _c5_ = found[1];
       found[1] = [0, caml_call2(Base_Import[93], j, k), _c5_];
       matched_chars[1] =
        may_overlap ? kmp_array[1 + caml_call2(Base_Import[93], k, 1)] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var _c6_ = j + 1 | 0;
      if(n === j) break;
      j = _c6_;
     }
    }
    return caml_call1(Base_List[61], found[1]);
   }
   function replace_first(pos, t, s, with$0){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     _cX_ = caml_call2(Base_Import[91], len_s, len_with),
     _cY_ = caml_call2(Base_Import[93], _cX_, len_t),
     dst = caml_call1(Base_Bytes0[7], _cY_);
    caml_call5(Base_Bytes0[4], s, 0, dst, 0, i);
    caml_call5(Base_Bytes0[4], with$0, 0, dst, i, len_with);
    var
     _cZ_ = caml_call2(Base_Import[93], len_s, i),
     _c0_ = caml_call2(Base_Import[93], _cZ_, len_t),
     _c1_ = caml_call2(Base_Import[91], i, len_with),
     _c2_ = caml_call2(Base_Import[91], i, len_t);
    caml_call5(Base_Bytes0[4], s, _c2_, dst, _c1_, _c0_);
    return caml_string_of_bytes(dst);
   }
   function replace_all(t, s, with$0){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     num_matches = caml_call1(Base_List[17], matches),
     _cQ_ = caml_call2(Base_Import[93], len_with, len_t),
     _cR_ = caml_call2(Base_Import[88], _cQ_, num_matches),
     _cS_ = caml_call2(Base_Import[91], len_s, _cR_),
     dst = caml_call1(Base_Bytes0[7], _cS_),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    caml_call2
     (Base_List[19],
      matches,
      function(i){
       var len = caml_call2(Base_Import[93], i, next_src_pos[1]);
       caml_call5
        (Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], len);
       var _cU_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
       caml_call5(Base_Bytes0[4], with$0, 0, dst, _cU_, len_with);
       var _cV_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
       next_dst_pos[1] = caml_call2(Base_Import[91], _cV_, len_with);
       var _cW_ = caml_call2(Base_Import[91], next_src_pos[1], len);
       next_src_pos[1] = caml_call2(Base_Import[91], _cW_, len_t);
       return 0;
      });
    var _cT_ = caml_call2(Base_Import[93], len_s, next_src_pos[1]);
    caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], _cT_);
    return caml_string_of_bytes(dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s),
     _cM_ =
       caml_call2(Base_Import[111], matches, [0, caml_ml_string_length(s), 0]),
     _cN_ = [0, caml_call1(Base_Import[113], pattern_len), matches];
    return caml_call3
            (Base_List[96],
             _cN_,
             _cM_,
             function(i, j){
              var
               _cO_ = caml_call2(Base_Import[93], j, i),
               _cP_ = caml_call2(Base_Import[93], _cO_, pattern_len);
              return sub(s, caml_call2(Base_Import[91], i, pattern_len), _cP_);
             });
   }
   function equal(a_003, b_004){
    if(a_003 === b_004) return 1;
    var _cJ_ = caml_call2(Base_Import[246], a_003[1], b_004[1]);
    if(_cJ_){
     var _cK_ = caml_call2(Base_Import[239], a_003[2], b_004[2]);
     if(_cK_)
      return caml_call3
              (Base_Import[248], Base_Import[242], a_003[3], b_004[3]);
     var _cL_ = _cK_;
    }
    else
     var _cL_ = _cJ_;
    return _cL_;
   }
   function sexp_of_t$1(param){
    var
     kmp_array_012 = param[3],
     case_sensitive_010 = param[2],
     pattern_008 = param[1],
     arg_013 = caml_call2(Base_Import[151], Base_Import[140], kmp_array_012),
     bnds_007 = [0, [1, [0, _c_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Base_Import[136], case_sensitive_010),
     bnds_007$0 = [0, [1, [0, _d_, [0, arg_011, 0]]], bnds_007],
     arg_009 = caml_call1(Base_Import[137], pattern_008),
     bnds_007$1 = [0, [1, [0, _e_, [0, arg_009, 0]]], bnds_007$0];
    return [1, bnds_007$1];
   }
   function representation(_cI_){return _cI_;}
   var Private = [0, equal, sexp_of_t$1, representation];
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var _cG_ = create(pattern, case_sensitive);
    return function(_cH_){return replace_first(pos, _cG_, t, _cH_);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var _cE_ = create(pattern, case_sensitive);
    return function(_cF_){return replace_all(_cE_, t, _cF_);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var _cD_ = substr_index_gen(case_sensitive, 0, t, substring);
    return caml_call1(Base_Option[51], _cD_);
   }
   var _f_ = 1;
   function substr_index(_cA_, _cB_, _cC_){
    return substr_index_gen(_f_, _cA_, _cB_, _cC_);
   }
   var _g_ = 1;
   function substr_index_exn(_cx_, _cy_, _cz_){
    return substr_index_exn_gen(_g_, _cx_, _cy_, _cz_);
   }
   var _h_ = 1;
   function substr_index_all(_cu_, _cv_, _cw_){
    return substr_index_all_gen(_h_, _cu_, _cv_, _cw_);
   }
   var _i_ = 1;
   function substr_replace_first(_cr_, _cs_, _ct_){
    return substr_replace_first_gen(_i_, _cr_, _cs_, _ct_);
   }
   var _j_ = 1;
   function substr_replace_all(_cp_, _cq_){
    return substr_replace_all_gen(_j_, _cp_, _cq_);
   }
   var
    _k_ = 1,
    _l_ =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"];
   function is_substring(_cn_, _co_){
    return is_substring_gen(_k_, _cn_, _co_);
   }
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     _ck_ = str_pos$1 < 0 ? 1 : 0,
     _cl_ = _ck_ || (str_len < str_pos$1 ? 1 : 0);
    if(_cl_) caml_call4(invalid_argf, _l_, str_pos$1, str_len, 0);
    var
     _cm_ = caml_call2(Base_Import[91], str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! _cm_) return _cm_;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = caml_call2(Base_Import[91], sub_pos, 1),
      str_pos$0 = caml_call2(Base_Import[91], str_pos, 1);
     str_pos = str_pos$0;
     sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     _cj_ = suffix_len <= string_len ? 1 : 0;
    return _cj_
            ? is_substring_at_gen
              (string,
               caml_call2(Base_Import[93], string_len, suffix_len),
               suffix,
               char_equal)
            : _cj_;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     _ci_ = prefix_len <= string_len ? 1 : 0;
    return _ci_ ? is_substring_at_gen(string, 0, prefix, char_equal) : _ci_;
   }
   var
    t_of_sexp$0 = Base_Import[161],
    sexp_of_t$2 = Base_Import[137],
    t_sexp_grammar$0 = Base_Import[183];
   function compare$0(string1, string2){
    if(caml_call2(Base_Import[128], string1, string2)) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      _cg_ = caml_call1(Base_Char[35], c2),
      _ch_ = caml_call1(Base_Char[35], c1),
      c = caml_call2(Base_Char[17], _ch_, _cg_);
     if(0 !== c) return c;
     var pos$0 = caml_call2(Base_Import[91], pos, 1);
     pos = pos$0;
    }
   }
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[207], state, len)],
     _cd_ = caml_call2(Base_Import[93], len, 1),
     _cc_ = 0;
    if(_cd_ >= 0){
     var pos = _cc_;
     for(;;){
      var _ce_ = caml_call1(Base_Char[35], caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[206], state$0[1], _ce_);
      var _cf_ = pos + 1 | 0;
      if(_cd_ === pos) break;
      pos = _cf_;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[53][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[53][12]);
   }
   var _m_ = 0;
   function substr_index$0(_b$_, _ca_, _cb_){
    return substr_index_gen(_m_, _b$_, _ca_, _cb_);
   }
   var _n_ = 0;
   function substr_index_exn$0(_b8_, _b9_, _b__){
    return substr_index_exn_gen(_n_, _b8_, _b9_, _b__);
   }
   var _o_ = 0;
   function substr_index_all$0(_b5_, _b6_, _b7_){
    return substr_index_all_gen(_o_, _b5_, _b6_, _b7_);
   }
   var _p_ = 0;
   function substr_replace_first$0(_b2_, _b3_, _b4_){
    return substr_replace_first_gen(_p_, _b2_, _b3_, _b4_);
   }
   var _q_ = 0;
   function substr_replace_all$0(_b0_, _b1_){
    return substr_replace_all_gen(_q_, _b0_, _b1_);
   }
   var _r_ = 0;
   function is_substring$0(_bY_, _bZ_){
    return is_substring_gen(_r_, _bY_, _bZ_);
   }
   var _s_ = Base_Char[53][12];
   function is_substring_at(_bV_){
    return function(_bW_){
     return function(_bX_){
      return is_substring_at_gen(_bV_, _bW_, _bX_, _s_);};};
   }
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare$0, sexp_of_t$2]),
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16],
    _t_ = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"];
   function of_string(_bU_){return _bU_;}
   function to_string(_bT_){return _bT_;}
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _t_, n, 0);
    var
     t = caml_call1(Base_Bytes0[7], n),
     _bR_ = caml_call2(Base_Import[93], n, 1),
     _bQ_ = 0;
    if(_bR_ >= 0){
     var i = _bQ_;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var _bS_ = i + 1 | 0;
      if(_bR_ === i) break;
      i = _bS_;
     }
    }
    return caml_string_of_bytes(t);
   }
   function to_list(s){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = caml_call2(Base_Import[93], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = caml_call2(Base_Import[91], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = caml_call1(Base_Bytes0[7], len),
     _bN_ = caml_call2(Base_Import[93], len, 1),
     _bM_ = 0;
    if(_bN_ >= 0){
     var i = _bM_;
     for(;;){
      var _bO_ = caml_call2(Base_Import[93], len, 1);
      caml_bytes_unsafe_set
       (res,
        i,
        caml_string_unsafe_get(t, caml_call2(Base_Import[93], _bO_, i)));
      var _bP_ = i + 1 | 0;
      if(_bN_ === i) break;
      i = _bP_;
     }
    }
    return caml_string_of_bytes(res);
   }
   var
    not_found$3 = [0, Base_Import[267], [0, "String.lsplit2_exn: not found"]];
   function lsplit2_exn(line, delim){
    var
     pos = index_exn_internal(line, not_found$3, delim),
     _bJ_ = caml_call2(Base_Import[93], caml_ml_string_length(line), pos),
     _bK_ = caml_call2(Base_Import[93], _bJ_, 1),
     _bL_ = sub(line, caml_call2(Base_Import[91], pos, 1), _bK_);
    return [0, sub(line, 0, pos), _bL_];
   }
   var
    not_found$4 = [0, Base_Import[267], [0, "String.rsplit2_exn: not found"]],
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    cst_drop_prefix = "drop_prefix",
    cst_drop_suffix = "drop_suffix",
    cst_prefix = "prefix",
    cst_suffix = "suffix",
    _u_ = [0, cst_src_string_ml, 773, 17],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    _v_ = [0, cst_src_string_ml, 937, 4],
    _w_ =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    _x_ =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    _y_ = [0, [3, 0, 0], "%S"],
    _z_ = [0, cst$13, cst$13],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    _A_ = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_is_char_escaping = "is_char_escaping",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_literal = "is_char_literal",
    cst_index_from = "index_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$1,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$1,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    _B_ = [0, cst_src_string_ml, 1833, 19],
    _C_ = [0, cst_src_string_ml, 1847, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    dummy = 0;
   function rsplit2_exn(line, delim){
    var
     pos = rindex_exn_internal(line, not_found$4, delim),
     _bG_ = caml_call2(Base_Import[93], caml_ml_string_length(line), pos),
     _bH_ = caml_call2(Base_Import[93], _bG_, 1),
     _bI_ = sub(line, caml_call2(Base_Import[91], pos, 1), _bH_);
    return [0, sub(line, 0, pos), _bI_];
   }
   function lsplit2(line, on){
    try{var _bE_ = [0, lsplit2_exn(line, on)]; return _bE_;}
    catch(_bF_){
     var _bD_ = caml_wrap_exception(_bF_);
     if(_bD_[1] !== Base_Import[267] && _bD_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_bD_, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var _bB_ = [0, rsplit2_exn(line, on)]; return _bB_;}
    catch(_bC_){
     var _bA_ = caml_wrap_exception(_bC_);
     if(_bA_[1] !== Base_Import[267] && _bA_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_bA_, 0);
     return 0;
    }
   }
   function char_list_mem(l, c){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], _bz_ = caml_call2(Base_Char[16], hd, c);
     if(_bz_) return _bz_;
     l$0 = tl;
    }
   }
   function split_gen(str, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[16], c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     pos$1 = caml_call2(Base_Import[93], last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = pos$1;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0))){
      var
       pos1 = caml_call2(Base_Import[91], last_pos$0, 1),
       sub_str = sub(str, pos1, caml_call2(Base_Import[93], last_pos$1, pos1)),
       pos = caml_call2(Base_Import[93], last_pos$0, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      last_pos$1 = last_pos$0;
      last_pos$0 = pos;
     }
     else{
      var pos$0 = caml_call2(Base_Import[93], last_pos$0, 1);
      last_pos$0 = pos$0;
     }
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function back_up_at_newline(t, pos, eol){
    a:
    {
     if(0 < pos[1]){
      var _bx_ = caml_string_get(t, caml_call2(Base_Import[93], pos[1], 1));
      if(caml_call2(Base_Char[16], _bx_, 13)){var _by_ = 2; break a;}
     }
     var _by_ = 1;
    }
    pos[1] = caml_call2(Base_Import[93], pos[1], _by_);
    eol[1] = caml_call2(Base_Import[91], pos[1], 1);
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, caml_call2(Base_Import[93], n, 1)],
     eol = [0, n],
     ac = [0, 0],
     _bt_ = caml_string_get(t, pos[1]);
    if(caml_call2(Base_Char[16], _bt_, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){var _bw_ = ac[1]; return [0, sub(t, 0, eol[1]), _bw_];}
     var _bu_ = caml_string_get(t, pos[1]);
     if(caml_call2(Base_Char[15], _bu_, 10))
      pos[1]--;
     else{
      var start = caml_call2(Base_Import[91], pos[1], 1), _bv_ = ac[1];
      ac[1] =
       [0, sub(t, start, caml_call2(Base_Import[93], eol[1], start)), _bv_];
      back_up_at_newline(t, pos, eol);
     }
    }
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[16]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[16]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[16]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var _bq_ = sub(t, pos, len); return _bq_;}
     catch(_bs_){return on_error;}
    var
     _br_ = caml_call2(symbol_concat, name, cst_expecting_nonnegative_argu);
    return caml_call1(Base_Import[126], _br_);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    var pos = opt ? opt[1] : 0, n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], pos$1 = pos$0;
    else
     var pos$1 = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    var i = pos$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[93], i, 1);
     i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    var drop = opt ? opt[1] : Base_Char[43], match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    var drop = opt ? opt[1] : Base_Char[43], match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    var
     drop = opt ? opt[1] : Base_Char[43],
     length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop(drop, t);
     if(! match) return cst$4;
     var first = match[1], match$0 = last_non_drop(drop, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
     var last = match$0[1], _bp_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _bp_, 1));
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bn_ = caml_call2(Base_Import[93], l, 1),
     _bm_ = 0;
    if(_bn_ >= 0){
     var i = _bm_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var _bo_ = i + 1 | 0;
      if(_bn_ === i) break;
      i = _bo_;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bk_ = caml_call2(Base_Import[93], l, 1),
     _bj_ = 0;
    if(_bk_ >= 0){
     var i = _bj_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var _bl_ = i + 1 | 0;
      if(_bk_ === i) break;
      i = _bl_;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function to_array(s){
    return caml_call2
            (Base_Array0[12],
             caml_ml_string_length(s),
             function(i){return caml_string_get(s, i);});
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _bg_ = i < len ? 1 : 0;
     if(_bg_){
      var _bh_ = caml_call1(f, caml_string_get(s, i));
      if(! _bh_){
       var i$0 = caml_call2(Base_Import[91], i, 1);
       i = i$0;
       continue;
      }
      var _bi_ = _bh_;
     }
     else
      var _bi_ = _bg_;
     return _bi_;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _bd_ = i === len ? 1 : 0;
     if(_bd_)
      var _be_ = _bd_;
     else{
      var _bf_ = caml_call1(f, caml_string_get(s, i));
      if(_bf_){
       var i$0 = caml_call2(Base_Import[91], i, 1);
       i = i$0;
       continue;
      }
      var _be_ = _bf_;
     }
     return _be_;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function iteri(t, f){
    var
     _bb_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1),
     _ba_ = 0;
    if(_bb_ >= 0){
     var i = _ba_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var _bc_ = i + 1 | 0;
      if(_bb_ === i) break;
      i = _bc_;
     }
    }
    return 0;
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t){return caml_call2(Base_Container[3], fold, t);}
   function max_elt(t){return caml_call2(Base_Container[4], fold, t);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function find_mapi(t, f){
    return caml_call3(Base_Indexed_container[7], iteri, t, f);
   }
   function findi(t, f){
    return caml_call3(Base_Indexed_container[6], iteri, t, f);
   }
   function counti(t, f){
    return caml_call3(Base_Indexed_container[3], foldi, t, f);
   }
   function for_alli(t, f){
    return caml_call3(Base_Indexed_container[5], iteri, t, f);
   }
   function existsi(t, f){
    return caml_call3(Base_Indexed_container[4], iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var _a9_ = i < len ? 1 : 0;
     if(_a9_){
      var _a__ = caml_call2(Base_Char[16], c, caml_string_unsafe_get(t, i));
      if(! _a__){
       var i$0 = caml_call2(Base_Import[91], i, 1);
       i = i$0;
       continue;
      }
      var _a$_ = _a__;
     }
     else
      var _a$_ = _a9_;
     return _a$_;
    }
   }
   function tr(target, replacement, s){
    return caml_call2(Base_Char[16], target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return caml_call2(Base_Char[16], c, target)
                          ? replacement
                          : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target))
     return caml_call1(stage, function(_a8_){return _a8_;});
    if(is_empty(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_em);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_a7_){return _a7_;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              return exists
                       (s,
                        function(c){
                         var
                          _a6_ =
                            caml_string_unsafe_get(tr_map, caml_call1(Base_Char[30], c));
                         return caml_call2(Base_Char[15], c, _a6_);
                        })
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, caml_call1(Base_Char[30], c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return caml_call2(concat, sep, caml_call1(Base_Array0[16], ar));
   }
   function concat_map(sep, s, f){
    var _a5_ = to_array(s);
    return concat_array(sep, caml_call2(Base_Array0[21], _a5_, f));
   }
   function concat_mapi(sep, t, f){
    var _a4_ = to_array(t);
    return concat_array(sep, caml_call2(Base_Array0[22], _a4_, f));
   }
   function concat_lines(opt, lines$3){
    var
     crlf = opt ? opt[1] : 0,
     newline_len = crlf ? 2 : 1,
     lines = lines$3,
     sum = 0;
    for(;;){
     if(! lines) break;
     var
      lines$0 = lines[2],
      line = lines[1],
      _a3_ = caml_call2(Base_Import[91], sum, caml_ml_string_length(line)),
      sum$0 = caml_call2(Base_Import[91], _a3_, newline_len);
     lines = lines$0;
     sum = sum$0;
    }
    var buf = caml_call1(Base_Bytes0[7], sum), lines$1 = lines$3, written = 0;
    for(;;){
     if(! lines$1){
      if(written === sum) return caml_string_of_bytes(buf);
      throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
     var lines$2 = lines$1[2], line$0 = lines$1[1];
     caml_blit_string(line$0, 0, buf, written, caml_ml_string_length(line$0));
     var
      pos =
        caml_call2(Base_Import[91], written, caml_ml_string_length(line$0)),
      pos$0 =
        crlf
         ? (caml_bytes_unsafe_set
            (buf, pos, 13),
           caml_call2(Base_Import[91], pos, 1))
         : pos;
     caml_bytes_unsafe_set(buf, pos$0, 10);
     var pos$1 = caml_call2(Base_Import[91], pos$0, 1);
     lines$1 = lines$2;
     written = pos$1;
    }
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     if(! caml_call1(f, caml_string_get(t, i[1]))) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     _a1_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _a1_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       _a2_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _a2_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call1(f, c)){caml_bytes_set(out, out_pos[1], c); out_pos[1]++;}
     i[1]++;
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     var _aY_ = caml_string_get(t, i[1]);
     if(! caml_call2(f, i[1], _aY_)) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     _aZ_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _aZ_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       _a0_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _a0_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call2(f, i[1], c)){
      caml_bytes_set(out, out_pos[1], c);
      out_pos[1]++;
     }
     i[1]++;
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call4(invalid_argf, _w_, s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call4(invalid_argf, _x_, s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return caml_call3(Base_List[20], rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var _aX_ = caml_call2(Base_Import[93], caml_ml_string_length(t), i);
    return caml_call2(Base_Import[93], _aX_, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far){
    var len_so_far$0 = len_so_far;
    for(;;){
     if(max_len <= len_so_far$0) return max_len;
     var
      _aV_ = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far$0)),
      _aW_ = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far$0));
     if(! caml_call2(Base_Char[16], _aW_, _aV_)) return len_so_far$0;
     var len_so_far$1 = caml_call2(Base_Import[91], len_so_far$0, 1);
     len_so_far$0 = len_so_far$1;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       caml_call2
        (Base_Import[101], caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first, list, get_pos, max_len){
    var first$0 = first, list$0 = list, max_len$0 = max_len;
    for(;;){
     if(! list$0) return max_len$0;
     var
      rest = list$0[2],
      second = list$0[1],
      max_len$1 =
        common_generic2_length_loop(first$0, second, get_pos, max_len$0, 0);
     first$0 = second;
     list$0 = rest;
     max_len$0 = max_len$1;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call3(Stdlib_Format[139], ppf, _y_, string);
   }
   function of_char(c){return caml_call2(make, 1, c);}
   function of_char_list(l){
    var
     _aU_ = caml_call1(Base_List[17], l),
     t = caml_call1(Base_Bytes0[7], _aU_);
    caml_call2
     (Base_List[34], l, function(i, c){return caml_bytes_set(t, i, c);});
    return caml_string_of_bytes(t);
   }
   function of_array(a){
    return init
            (a.length - 1,
             function(_aT_){return caml_check_bound(a, _aT_)[1 + _aT_];});
   }
   function pad_right(opt, s, len){
    var char$0 = opt ? opt[1] : 32, src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var res = caml_call1(Base_Bytes0[7], len);
    caml_call5(Base_Bytes0[4], s, 0, res, 0, src_len);
    var _aS_ = caml_call2(Base_Import[93], len, src_len);
    caml_call4(Base_Bytes0[9], res, src_len, _aS_, char$0);
    return caml_string_of_bytes(res);
   }
   function pad_left(opt, s, len){
    var char$0 = opt ? opt[1] : 32, src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var
     res = caml_call1(Base_Bytes0[7], len),
     _aQ_ = caml_call2(Base_Import[93], len, src_len);
    caml_call5(Base_Bytes0[4], s, 0, res, _aQ_, src_len);
    var _aR_ = caml_call2(Base_Import[93], len, src_len);
    caml_call4(Base_Bytes0[9], res, 0, _aR_, char$0);
    return caml_string_of_bytes(res);
   }
   function local_copy_prefix(src, prefix_len, buffer_len){
    var dst = caml_call1(Base_Bytes0[8], buffer_len);
    caml_blit_string(src, 0, dst, 0, prefix_len);
    return dst;
   }
   function local_copy_to_string(buf, pos){
    var str = caml_string_of_bytes(buf);
    return unsafe_sub(str, 0, pos);
   }
   function filter_mapi(src, f){
    var src_len = caml_ml_string_length(src);
    a:
    {
     var pos = 0;
     for(;;){
      if(pos === src_len) return src;
      var
       c1 = caml_string_unsafe_get(src, pos),
       src_pos$0 = caml_call1(Base_Int0[8], pos),
       option = caml_call2(f, pos, c1);
      if(! option) break a;
      var c2 = option[1];
      if(! caml_call2(Base_Char[16], c1, c2)) break;
      pos = src_pos$0;
     }
    }
    var copy = local_copy_prefix(src, pos, src_len);
    if(option){
     var c$0 = option[1];
     caml_bytes_unsafe_set(copy, pos, c$0);
     var dst_pos$0 = src_pos$0;
    }
    else
     var dst_pos$0 = pos;
    var
     dst_pos = [0, dst_pos$0],
     _aO_ = caml_call2(Base_Import[93], src_len, 1);
    if(_aO_ >= src_pos$0){
     var src_pos = src_pos$0;
     for(;;){
      var
       match = caml_call2(f, src_pos, caml_string_unsafe_get(src, src_pos));
      if(match){
       var c = match[1];
       caml_bytes_unsafe_set(copy, dst_pos[1], c);
       dst_pos[1]++;
      }
      var _aP_ = src_pos + 1 | 0;
      if(_aO_ === src_pos) break;
      src_pos = _aP_;
     }
    }
    return local_copy_to_string(copy, dst_pos[1]);
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, c){return caml_call1(f, c);});
   }
   function partition_map_difference
   (src, f, len, src_pos$0, fst_pos$0, snd_pos$0, either){
    var
     fsts = local_copy_prefix(src, fst_pos$0, len),
     snds = local_copy_prefix(src, snd_pos$0, len);
    if(0 === either[0]){
     var c$1 = either[1];
     caml_bytes_unsafe_set(fsts, fst_pos$0, c$1);
     var
      snd_pos$1 = snd_pos$0,
      fst_pos$1 = caml_call2(Base_Import[91], fst_pos$0, 1);
    }
    else{
     var c$2 = either[1];
     caml_bytes_unsafe_set(snds, snd_pos$0, c$2);
     var
      snd_pos$2 = caml_call2(Base_Import[91], snd_pos$0, 1),
      snd_pos$1 = snd_pos$2,
      fst_pos$1 = fst_pos$0;
    }
    var
     src_pos$1 = caml_call2(Base_Import[91], src_pos$0, 1),
     fst_pos = [0, fst_pos$1],
     snd_pos = [0, snd_pos$1],
     _aL_ = caml_call2(Base_Import[93], len, 1);
    if(_aL_ >= src_pos$1){
     var src_pos = src_pos$1;
     for(;;){
      var match = caml_call1(f, caml_string_unsafe_get(src, src_pos));
      if(0 === match[0]){
       var c = match[1];
       caml_bytes_unsafe_set(fsts, fst_pos[1], c);
       fst_pos[1]++;
      }
      else{
       var c$0 = match[1];
       caml_bytes_unsafe_set(snds, snd_pos[1], c$0);
       snd_pos[1]++;
      }
      var _aN_ = src_pos + 1 | 0;
      if(_aL_ === src_pos) break;
      src_pos = _aN_;
     }
    }
    var _aM_ = local_copy_to_string(snds, snd_pos[1]);
    return [0, local_copy_to_string(fsts, fst_pos[1]), _aM_];
   }
   function partition_map(src, f){
    var len = caml_ml_string_length(src);
    if(0 === len) return _z_;
    var c1$1 = caml_string_unsafe_get(src, 0), either$1 = caml_call1(f, c1$1);
    if(0 === either$1[0]){
     var c2$1 = either$1[1];
     if(caml_call2(Base_Char[16], c1$1, c2$1)){
      var pos = 1;
      for(;;){
       if(pos === len) return [0, src, cst$8];
       var c1 = caml_string_unsafe_get(src, pos), either = caml_call1(f, c1);
       if(0 === either[0]){
        var c2 = either[1];
        if(caml_call2(Base_Char[16], c1, c2)){
         var pos$0 = caml_call2(Base_Import[91], pos, 1);
         pos = pos$0;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos, pos, 0, either);
      }
     }
    }
    else{
     var c2$2 = either$1[1];
     if(caml_call2(Base_Char[16], c1$1, c2$2)){
      var pos$1 = 1;
      for(;;){
       if(pos$1 === len) return [0, cst$9, src];
       var
        c1$0 = caml_string_unsafe_get(src, pos$1),
        either$0 = caml_call1(f, c1$0);
       if(1 === either$0[0]){
        var c2$0 = either$0[1];
        if(caml_call2(Base_Char[16], c1$0, c2$0)){
         var pos$2 = caml_call2(Base_Import[91], pos$1, 1);
         pos$1 = pos$2;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos$1, 0, pos$1, either$0);
      }
     }
    }
    return partition_map_difference(src, f, len, 0, 0, 0, either$1);
   }
   function partition_tf(t, f){
    return partition_map
            (t, function(c){return caml_call1(f, c) ? [0, c] : [1, c];});
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[134][7], escapeworthy_map, Base_Char[16], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = caml_call2(Base_Array0[4], 256, -1),
     vals = caml_call2(Base_Array0[4], 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = caml_call1(Base_Char[30], c_to);
     else
      var k$0 = caml_call1(Base_Char[30], c_from), v = c_to, k = k$0;
     if(-1 !== caml_check_bound(arr, k)[1 + k]) break;
     var _aD_ = caml_call1(Base_Char[30], v);
     if(caml_check_bound(vals, _aD_)[1 + _aD_]) break;
     var _aJ_ = caml_call1(Base_Char[30], v);
     caml_check_bound(arr, k)[1 + k] = _aJ_;
     var _aK_ = caml_call1(Base_Char[30], v);
     caml_check_bound(vals, _aK_)[1 + _aK_] = 1;
     param = l;
    }
    var
     _aE_ = caml_call2(Base_Import[148], Base_Import[139], Base_Import[139]),
     _aF_ =
       [0,
        [0,
         cst_escapeworthy_map,
         caml_call2(Base_Import[150], _aE_, escapeworthy_map$0)],
        0],
     _aG_ = [0, [0, cst_c_to, caml_call1(Base_Import[139], c_to)], _aF_],
     _aH_ = [0, [0, cst_c_from, caml_call1(Base_Import[139], c_from)], _aG_],
     _aI_ = caml_call2(Base_Sexp[9], cst_escapeworthy_map_not_one_t, _aH_);
    return caml_call1(Base_Or_error[35], _aI_);
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              to_escape =
                foldi
                 (src,
                  0,
                  function(i, acc, c){
                   var
                    _aC_ = caml_call1(Base_Char[30], c),
                    n = caml_check_bound(escapeworthy, _aC_)[1 + _aC_];
                   return -1 === n
                           ? acc
                           : (to_escape_len
                              [1]++,
                             [0, [0, i, caml_call1(Base_Char[33], n)], acc]);
                  });
             if(! to_escape) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                caml_call2(Base_Import[91], last_idx, to_escape_len[1]),
              dst = caml_call1(Base_Bytes0[7], last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape;
             for(;;){
              if(! param){
               caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               return caml_string_of_bytes(dst);
              }
              var
               to_escape$0 = param[2],
               match = param[1],
               escaped_char = match[2],
               last_idx$1 = match[1],
               _aA_ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
               len = caml_call2(Base_Import[93], _aA_, 1),
               dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
               _aB_ = caml_call2(Base_Import[91], last_idx$1, 1);
              caml_call5(Base_Bytes0[4], src, _aB_, dst, dst_pos, len);
              var last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 2);
              caml_bytes_set(dst, last_dst_pos$1, escape_char);
              caml_bytes_set
               (dst,
                caml_call2(Base_Import[91], last_dst_pos$1, 1),
                escaped_char);
              last_idx$0 = last_idx$1;
              last_dst_pos$0 = last_dst_pos$1;
              param = to_escape$0;
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var _az_ = escape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _az_));
   }
   function escape(escapeworthy, escape_char){
    var
     _ay_ = caml_call2(Base_List[124], escapeworthy, Base_Char[17]),
     escapeworthy_map =
       caml_call2(Base_List[52], _ay_, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i) break;
              if(-512962225 <= status)
               var
                _aq_ = caml_string_get(src, i),
                status$0 =
                  caml_call2(Base_Char[16], _aq_, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = caml_call2(Base_Import[91], i, 1);
              i = i$0;
              status = status$0;
              to_unescape = acc;
             }
             if(! to_unescape) return src;
             var
              to_unescape$0 = to_unescape[2],
              idx = to_unescape[1],
              _ar_ = caml_call1(Base_List[17], to_unescape),
              _as_ =
                caml_call2(Base_Import[93], caml_ml_string_length(src), _ar_),
              dst = caml_call1(Base_Bytes0[7], _as_);
             function loop(last_idx, last_dst_pos, param){
              var
               last_idx$0 = last_idx,
               last_dst_pos$0 = last_dst_pos,
               param$0 = param;
              for(;;){
               if(! param$0)
                return caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               var
                to_unescape = param$0[2],
                last_idx$1 = param$0[1],
                _at_ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
                len = caml_call2(Base_Import[93], _at_, 2),
                dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
                _au_ = caml_call2(Base_Import[91], last_idx$1, 2);
               caml_call5(Base_Bytes0[4], src, _au_, dst, dst_pos, len);
               var
                last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 1),
                _av_ =
                  caml_string_get
                   (src, caml_call2(Base_Import[91], last_idx$1, 1)),
                _aw_ = caml_call1(Base_Char[30], _av_),
                n = caml_check_bound(escapeworthy, _aw_)[1 + _aw_],
                _ax_ =
                  -1 === n
                   ? caml_string_get
                     (src, caml_call2(Base_Import[91], last_idx$1, 1))
                   : caml_call1(Base_Char[33], n);
               caml_bytes_set(dst, last_dst_pos$1, _ax_);
               last_idx$0 = last_idx$1;
               last_dst_pos$0 = last_dst_pos$1;
               param$0 = to_unescape;
              }
             }
             if
              (idx
               < caml_call2(Base_Import[93], caml_ml_string_length(src), 1))
              loop
               (caml_ml_string_length(src),
                caml_ml_bytes_length(dst),
                to_unescape);
             else
              loop
               (caml_call2(Base_Import[93], caml_ml_string_length(src), 1),
                caml_ml_bytes_length(dst),
                to_unescape$0);
             return caml_string_of_bytes(dst);
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var _ap_ = unescape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _ap_));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = caml_call2(Base_Import[93], pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var _ao_ = caml_string_get(str, p);
      if(! caml_call2(Base_Char[15], _ao_, escape_char)){
       var
        cnt$0 = caml_call2(Base_Import[91], cnt, 1),
        p$0 = caml_call2(Base_Import[93], p, 1);
       p = p$0;
       cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var _an_ = caml_string_get(str, i);
    return caml_call2(Base_Char[16], _an_, escape_char)
            ? -767030498
            : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     _al_ = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === caml_call2(Base_Import[122], _al_, 2) ? 1 : 0,
     _am_ = caml_string_get(str, pos),
     match = caml_call2(Base_Char[16], _am_, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     _aj_ = caml_ml_string_length(str) <= pos ? 1 : 0,
     _ak_ = _aj_ || (pos < 0 ? 1 : 0);
    return _ak_ ? caml_call3(invalid_argf, _A_, function_name, 0) : _ak_;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var _ah_ = -512962225 === status ? 1 : 0;
      if(_ah_){
       var _ai_ = caml_string_get(str, i);
       if(caml_call2(Base_Char[16], _ai_, char$0)) return [0, i];
      }
     }
     var i$0 = caml_call2(Base_Import[91], i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var status$0 = update_escape_status(str, escape_char, i$0, status);
     i = i$0;
     status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char$0){
    var match = index_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _ad_ = [0, [0, cst_char, caml_call1(Base_Import[139], char$0)], 0],
     _ae_ = [0, [0, cst_pos, caml_call1(Base_Import[140], pos)], _ad_],
     _af_ =
       [0,
        [0, cst_escape_char, caml_call1(Base_Import[139], escape_char)],
        _ae_],
     _ag_ = [0, [0, cst_str, caml_call1(sexp_of_t, str)], _af_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_index_from_exn_not_found, _ag_));
   }
   function index$1(str, escape_char, char$0){
    return index_from$0(str, escape_char, 0, char$0);
   }
   function index_exn$1(str, escape_char, char$0){
    return index_from_exn$0(str, escape_char, 0, char$0);
   }
   function rindex_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_rindex_from);
    if(caml_call2(Base_Char[16], char$0, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === caml_call2(Base_Import[122], escape_chars, 2)){
      var _ab_ = caml_string_get(str, pos$0);
      if(caml_call2(Base_Char[16], _ab_, char$0)) return [0, pos$0];
     }
     var
      _ac_ = caml_call2(Base_Import[93], pos$0, escape_chars),
      pos$1 = caml_call2(Base_Import[93], _ac_, 1);
     pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char$0){
    var match = rindex_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _Z_ = [0, [0, cst_char$0, caml_call1(Base_Import[139], char$0)], 0],
     ___ = [0, [0, cst_pos$0, caml_call1(Base_Import[140], pos)], _Z_],
     _$_ =
       [0,
        [0, cst_escape_char$0, caml_call1(Base_Import[139], escape_char)],
        ___],
     _aa_ = [0, [0, cst_str$0, caml_call1(sexp_of_t, str)], _$_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_rindex_from_exn_not_found, _aa_));
   }
   function rindex$0(str, escape_char, char$0){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
               char$0);
   }
   function rindex_exn$0(str, escape_char, char$0){
    return rindex_from_exn$0
            (str,
             escape_char,
             caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
             char$0);
   }
   function split_gen$0(str, escape_char, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[16], c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       _X_ =
         [0,
          sub(str, last_pos, caml_call2(Base_Import[93], len, last_pos)),
          acc];
      return caml_call1(Base_List[61], _X_);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      _Y_ = -512962225 === status$0 ? 1 : 0;
     if(_Y_ && is_delim(caml_string_get(str, pos))){
      var
       sub_str =
         sub(str, last_pos, caml_call2(Base_Import[93], pos, last_pos)),
       pos$0 = caml_call2(Base_Import[91], pos, 1),
       last_pos$0 = caml_call2(Base_Import[91], pos, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      status = status$0;
      last_pos = last_pos$0;
      pos = pos$0;
      continue;
     }
     var pos$1 = caml_call2(Base_Import[91], pos, 1);
     status = status$0;
     pos = pos$1;
    }
   }
   function split$0(str, on){
    var _V_ = [0, -1044422954, on];
    return function(_W_){return split_gen$0(str, _W_, _V_);};
   }
   function split_on_chars$0(str, chars){
    var _T_ = [0, 552554919, chars];
    return function(_U_){return split_gen$0(str, _U_, _T_);};
   }
   function split_at(str, pos){
    var
     _Q_ = caml_call2(Base_Import[93], caml_ml_string_length(str), pos),
     _R_ = caml_call2(Base_Import[93], _Q_, 1),
     _S_ = sub(str, caml_call2(Base_Import[91], pos, 1), _R_);
    return [0, sub(str, 0, pos), _S_];
   }
   function lsplit2$0(str, on, escape_char){
    var _P_ = index$1(str, escape_char, on);
    return caml_call2
            (Base_Option[22], _P_, function(x){return split_at(str, x);});
   }
   function rsplit2$0(str, on, escape_char){
    var _O_ = rindex$0(str, escape_char, on);
    return caml_call2
            (Base_Option[22], _O_, function(x){return split_at(str, x);});
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var _L_ = 1 - caml_call1(drop, c);
              if(_L_)
               var _M_ = _L_;
              else{
               var _N_ = is_char_escaping(t, escape_char, i);
               if(! _N_) return is_char_escaped(t, escape_char, i);
               var _M_ = _N_;
              }
              return _M_;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var _I_ = 1 - caml_call1(drop, c);
              if(_I_)
               var _J_ = _I_;
              else{
               var _K_ = is_char_escaping(t, escape_char, i);
               if(! _K_) return is_char_escaped(t, escape_char, i);
               var _J_ = _K_;
              }
              return _J_;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    var
     drop = opt ? opt[1] : Base_Char[43],
     match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$10;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    var
     drop = opt ? opt[1] : Base_Char[43],
     match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$11;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    var
     drop = opt ? opt[1] : Base_Char[43],
     length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop_literal(drop, escape_char, t);
     if(! match) return cst$12;
     var
      first = match[1],
      match$0 = last_non_drop_literal(drop, escape_char, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
     var last = match$0[1], _H_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _H_, 1));
    }
    return t;
   }
   function between$0(t, low, high){
    var _G_ = caml_call2(Base_Import[109][2], low, t);
    return _G_ ? caml_call2(Base_Import[109][2], t, high) : _G_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[109][1], t, min)
            ? min
            : caml_call2(Base_Import[109][2], t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(caml_call2(Base_Import[109][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
   }
   function clamp$0(t, min, max){
    if(! caml_call2(Base_Import[109][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _D_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _E_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _D_],
     _F_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _E_);
    return caml_call1(Base_Or_error[35], _F_);
   }
   function create$0(opt, pattern){
    var case_sensitive = opt ? opt[1] : 1;
    return create(pattern, case_sensitive);
   }
   var
    include$1 = Base_Import[109],
    symbol$5 = include$1[1],
    symbol$6 = include$1[2],
    symbol$7 = include$1[3],
    symbol$8 = include$1[4],
    symbol$9 = include$1[5],
    symbol$10 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$1 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_String =
      [0,
       globalize,
       t_sexp_grammar,
       sub,
       unsafe_sub,
       subo,
       of_char_list,
       of_array,
       symbol_concat,
       map,
       filter,
       filter_map,
       partition_tf,
       partition_map,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$10,
       symbol$6,
       symbol$8,
       symbol$9,
       symbol$5,
       symbol$7,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       invariant,
       max_length,
       mem,
       make,
       symbol_concat,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        Private],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       concat_map,
       concat_mapi,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       concat_lines,
       equal$1,
       of_char,
       of_char_list,
       pad_left,
       pad_right,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal]];
   runtime.caml_register_global(90, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    globalize = Base_Import[259],
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[184],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    create_local = Base_Bytes0[8],
    fill = Base_Bytes0[9],
    make = Base_Bytes0[10],
    map = Base_Bytes0[11],
    mapi = Base_Bytes0[12],
    to_string = Base_Bytes0[14],
    of_string = Base_Bytes0[15],
    _a_ = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var _w_ = caml_call1(to_string, t);
    return caml_call3(Stdlib_Format[139], fmt, _a_, _w_);
   }
   function create$0(len){return caml_call1(create, len);}
   var
    To_bytes =
      caml_call1
       (Base_Blit[1],
        [0, caml_ml_bytes_length, create$0, runtime.caml_blit_bytes]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes);
   function create$1(len){return caml_call1(create, len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$0 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length$0]),
        [0, length, create$1, unsafe_blit$0]),
    _b_ = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    _c_ = [0, "src/bytes.ml", 129, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call3(Base_Printf[7], _b_, n, 0);
    var
     t = caml_call1(create, n),
     _u_ = caml_call2(Base_Import[93], n, 1),
     _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = caml_call1(create, caml_call1(Base_List[17], l));
    caml_call2
     (Base_List[34],
      l,
      function(i, c){return runtime.caml_bytes_set(t, i, c);});
    return t;
   }
   function to_list(t){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = caml_call2(Base_Import[93], i, 1);
     i = i$0;
     acc = acc$0;
    }
   }
   function to_array(t){
    return caml_call2
            (Base_Array0[12],
             caml_ml_bytes_length(t),
             function(i){return caml_bytes_unsafe_get(t, i);});
   }
   function map$0(t, f){return caml_call2(map, t, f);}
   function mapi$0(t, f){return caml_call2(mapi, t, f);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var
     _r_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      if(caml_call2(Base_Char[16], caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      i = _s_;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return caml_call1(stage, function(_p_){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_th);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_o_){return 0;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              var
               _m_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
               _l_ = 0;
              if(_m_ >= 0){
               var i = _l_;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    caml_call1(Base_Char[30], caml_bytes_unsafe_get(s, i))));
                var _n_ = i + 1 | 0;
                if(_m_ === i) break;
                i = _n_;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[110][2], low, t);
    return _k_ ? caml_call2(Base_Import[110][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[110][1], t, min)
            ? min
            : caml_call2(Base_Import[110][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[110][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[110][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function contains(pos, len, t, char$0){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1],
         pos,
         len,
         0,
         caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = caml_call2(Base_Import[91], pos$0, len$0),
     i = pos$0;
    for(;;){
     var _d_ = i < last ? 1 : 0;
     if(_d_){
      var
       _e_ = caml_bytes_get(t, i),
       _f_ = caml_call2(Base_Char[16], _e_, char$0);
      if(! _f_){
       var i$0 = caml_call2(Base_Import[91], i, 1);
       i = i$0;
       continue;
      }
      var _g_ = _f_;
     }
     else
      var _g_ = _d_;
     return _g_;
    }
   }
   var
    include$0 = Base_Import[110],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    equal = include$0[10],
    max = include$0[11],
    min = include$0[12],
    Base_Bytes =
      [0,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       create_local,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Int0, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Base__Sys0, Base__Word_size, Stdlib__Int32, Stdlib__Int64, Stdlib__Lexing, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Printf = global_data.Base__Printf,
    Base_Import = global_data.Base__Import,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    Base_Sexp = global_data.Base__Sexp,
    _a_ =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"];
   function convert_failure(x, a, b, to_string){
    var _O_ = caml_call1(to_string, x);
    return caml_call5(Base_Printf[6], _a_, a, b, _O_, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    _g_ =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0x = "-0x",
    cst_0x$0 = "0x",
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    _l_ = [0, cst_src_int_conversions_ml, 19, 9],
    _k_ = [0, cst_src_int_conversions_ml, 75, 9],
    _j_ = [0, cst_src_int_conversions_ml, 96, 9],
    _i_ = [0, cst_src_int_conversions_ml, 148, 9],
    _h_ = [0, cst_src_int_conversions_ml, 176, 9],
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15];
   function int32_to_int_trunc(_N_){return _N_;}
   function int_to_int32_trunc(_M_){return _M_;}
   var
    _b_ = Base_Import[85][33],
    _c_ = Stdlib_Int32[14],
    int_is_representable_as_int32 =
      num_bits_int <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _K_ = caml_call2(Base_Import[229], min_int32, x) <= 0 ? 1 : 0,
          _L_ =
            _K_
             ? caml_call2(Base_Import[229], x, max_int32) <= 0 ? 1 : 0
             : _K_;
         return _L_;
        };
   if(32 <= num_bits_int)
    var _d_ = function(param){return 1;};
   else
    var
     min$1 = Base_Int0[7],
     max$1 = Base_Int0[6],
     _d_ =
       function(x){
        var
         _I_ = caml_call2(Base_Import[230], min$1, x) <= 0 ? 1 : 0,
         _J_ = _I_ ? caml_call2(Base_Import[230], x, max$1) <= 0 ? 1 : 0 : _I_;
        return _J_;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){return _d_(x) ? [0, x] : 0;}
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, _b_);
   }
   function int32_to_int_exn(x){
    return _d_(x) ? x : convert_failure(x, cst_int32$0, cst_int$0, _c_);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min$4 = caml_int64_of_int32(Base_Int0[7]),
    max$4 = caml_int64_of_int32(Base_Int0[6]);
   function int64_is_representable_as_int(x){
    var
     _G_ = caml_call2(Base_Import[231], min$4, x) <= 0 ? 1 : 0,
     _H_ = _G_ ? caml_call2(Base_Import[231], x, max$4) <= 0 ? 1 : 0 : _G_;
    return _H_;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64, cst_int$1, int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   function int_to_nativeint(_F_){return _F_;}
   function nativeint_to_int_trunc(_E_){return _E_;}
   if(num_bits_nativeint <= num_bits_int)
    var _e_ = function(param){return 1;};
   else
    var
     min$0 = Base_Int0[7],
     max$0 = Base_Int0[6],
     _e_ =
       function(x){
        var
         _C_ = caml_call2(Base_Import[232], min$0, x) <= 0 ? 1 : 0,
         _D_ = _C_ ? caml_call2(Base_Import[232], x, max$0) <= 0 ? 1 : 0 : _C_;
        return _D_;
       };
   function nativeint_to_int(x){return _e_(x) ? [0, x] : 0;}
   function nativeint_to_int_exn(x){
    return _e_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$3 = caml_int64_of_int32(min_int32),
    max$3 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     _A_ = caml_call2(Base_Import[231], min$3, x) <= 0 ? 1 : 0,
     _B_ = _A_ ? caml_call2(Base_Import[231], x, max$3) <= 0 ? 1 : 0 : _A_;
    return _B_;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   function int32_to_nativeint(_z_){return _z_;}
   function nativeint_to_int32_trunc(_y_){return _y_;}
   var
    _f_ =
      num_bits_nativeint <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _w_ = caml_call2(Base_Import[232], min_int32, x) <= 0 ? 1 : 0,
          _x_ =
            _w_
             ? caml_call2(Base_Import[232], x, max_int32) <= 0 ? 1 : 0
             : _w_;
         return _x_;
        };
   function nativeint_to_int32(x){return _f_(x) ? [0, x] : 0;}
   function nativeint_to_int32_exn(x){
    return _f_(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$2 = caml_int64_of_int32(min_nativeint),
     max$2 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         _u_ = caml_call2(Base_Import[231], min$2, x) <= 0 ? 1 : 0,
         _v_ = _u_ ? caml_call2(Base_Import[231], x, max$2) <= 0 ? 1 : 0 : _u_;
        return _v_;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min = caml_int64_shift_right(min_int64, 1),
    max = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     _s_ = caml_call2(Base_Import[231], min, x) <= 0 ? 1 : 0,
     _t_ = _s_ ? caml_call2(Base_Import[231], x, max) <= 0 ? 1 : 0 : _s_;
    return _t_;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0);
    a:
    {
     if(43 !== match && 45 !== match){var has_sign = 0; break a;}
     var has_sign = 1;
    }
    var
     num_digits =
       has_sign ? caml_call2(Base_Import[93], input_length, 1) : input_length,
     _q_ = caml_call2(Base_Import[93], num_digits, 1),
     num_delimiters = caml_call2(Base_Import[95], _q_, chars_per_delimiter),
     output_length = caml_call2(Base_Import[91], input_length, num_delimiters),
     output = caml_call1(Base_Bytes[32], output_length),
     input_pos = [0, caml_call2(Base_Import[93], input_length, 1)],
     output_pos = [0, caml_call2(Base_Import[93], output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos > input_pos[1]){
      if(has_sign) caml_bytes_set(output, 0, caml_string_get(input, 0));
      return runtime.caml_string_of_bytes(output);
     }
     if(0 === num_chars_until_delimiter[1]){
      caml_bytes_set(output, output_pos[1], delimiter);
      output_pos[1]--;
      num_chars_until_delimiter[1] = chars_per_delimiter;
     }
     var _r_ = caml_string_get(input, input_pos[1]);
     caml_bytes_set(output, output_pos[1], _r_);
     input_pos[1]--;
     output_pos[1]--;
     num_chars_until_delimiter[1]--;
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var
    sexp_of_int_style = Base_Sexp[19],
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         var delimiter = opt ? opt[1] : 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       function(I){
        var compare = I[1], hash_fold_t = I[2], func = I[3];
        function hash(x){return caml_call1(func, x);}
        var chars_per_delimiter = 4;
        function to_string(delimiter, t){
         if(delimiter)
          var
           delimiter$0 = delimiter[1],
           make_suffix =
             function(t){
              return insert_delimiter_every
                      (caml_call1(I[4], t), delimiter$0, chars_per_delimiter);
             };
         else
          var make_suffix = I[4];
         if(caml_call2(I[7], t, I[6])){
          var _o_ = caml_call1(make_suffix, caml_call1(I[8], t));
          return caml_call2(Base_Import[112], cst_0x, _o_);
         }
         var _p_ = caml_call1(make_suffix, t);
         return caml_call2(Base_Import[112], cst_0x$0, _p_);
        }
        function to_string$0(t){return to_string(0, t);}
        function to_string_hum(opt, t){
         var delimiter = opt ? opt[1] : 95;
         return to_string([0, delimiter], t);
        }
        function invalid(str){
         return caml_call4(Base_Printf[6], _g_, I[9], str, 0);
        }
        function of_string_with_delimiter(str){
         var
          _n_ =
            caml_call2
             (Base_String[10],
              str,
              function(c){return caml_call2(Base_Char[15], c, 95);});
         return caml_call1(I[5], _n_);
        }
        function of_string(str){
         var
          lex = caml_call2(Stdlib_Lexing[3], 0, str),
          result =
            caml_call1
             (Base_Option[45],
              function(param){return caml_call1(Base_Hex_lexer[1], lex);});
         if(lex[6] !== lex[3]) return invalid(str);
         if(! result) return invalid(str);
         var match = result[1];
         if(0 === match[0]){
          var body = match[1], _m_ = of_string_with_delimiter(body);
          return caml_call1(I[8], _m_);
         }
         var body$0 = match[1];
         return of_string_with_delimiter(body$0);
        }
        var
         include = caml_call1(Base_Sexpable[5], [0, of_string, to_string$0]),
         t_sexp_grammar = include[1],
         t_of_sexp = include[2],
         sexp_of_t = include[3];
        return [0,
                [0,
                 t_of_sexp,
                 sexp_of_t,
                 t_sexp_grammar,
                 compare,
                 hash_fold_t,
                 hash,
                 of_string,
                 to_string$0,
                 to_string_hum]];
       },
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (43, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Int_conversions
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      [0,
        2147483647,
        2147483647,
        46340,
        1290,
        215,
        73,
        35,
        21,
        14,
        10,
        8,
        7,
        5,
        5,
        4,
        4,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1].slice
       (),
    overflow_bound_max_int_value = caml_call2(Base_Import[120], -1, 1),
    switcher = Base_Int_conversions[29] - 31 | 0,
    _g_ = [0, "src/pow_overflow_bounds.ml", 218, 9],
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _c_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _h_ =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    _d_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
       runtime.caml_int64_create_lo_mi_hi(1664510, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(46340, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5404, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1290, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(463, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(215, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(118, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(73, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(49, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(35, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(27, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(21, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(17, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(14, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(12, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(10, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _e_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(324403, 181, 0),
       runtime.caml_int64_create_lo_mi_hi(2097151, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(55108, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6208, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1448, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(511, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(234, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(127, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(78, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(52, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(38, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(28, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(22, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(18, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(15, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(13, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(11, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _f_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       runtime.caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     int_positive_overflow_bounds =
       [0,
        caml_int64_to_int32(_c_),
        caml_int64_to_int32(_b_),
        caml_int64_to_int32(_a_),
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else
    var
     int_positive_overflow_bounds =
       switcher
        ? caml_call2
          (Base_Array0[21],
           int32_positive_overflow_bounds,
           function(_i_){return _i_;})
        : _h_.slice();
   var
    int63_on_int64_positive_overfl = _d_.slice(),
    int64_positive_overflow_bounds = _e_.slice(),
    int64_negative_overflow_bounds = _f_.slice(),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati],
    _b_ =
      [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow];
   function negative_exponent(param){
    return caml_call2(Base_Printf[7], _a_, 0);
   }
   function overflow(param){return caml_call2(Base_Printf[7], _b_, 0);}
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var _J_ = 1 < caml_call1(Base_Import[123], base) ? 1 : 0;
    if(_J_){
     var _K_ = 63 < exponent ? 1 : 0;
     if(_K_)
      var _L_ = _K_;
     else
      var
       _M_ =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[1 + exponent],
       _L_ = _M_ < caml_call1(Base_Import[123], base) ? 1 : 0;
    }
    else
     var _L_ = _J_;
    if(_L_) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var
    abs = Stdlib_Int64[8],
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0);
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, _c_)) negative_exponent(0);
    var
     _A_ = caml_greaterthan(base, _d_),
     _B_ = _A_ || caml_lessthan(base, _h_);
    if(_B_){
     var _C_ = caml_greaterthan(exponent, _e_);
     if(_C_)
      var _D_ = _C_;
     else{
      var _E_ = runtime.caml_greaterequal(base, _f_);
      if(_E_)
       var
        _F_ = caml_int64_to_int32(exponent),
        _G_ =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], _F_)[1 + _F_]);
      else
       var _G_ = _E_;
      if(_G_)
       var _D_ = _G_;
      else{
       var _H_ = caml_lessthan(base, _g_);
       if(_H_)
        var
         _I_ = caml_int64_to_int32(exponent),
         _D_ =
           caml_lessthan
            (base,
             caml_check_bound(Base_Pow_overflow_bounds[9], _I_)[1 + _I_]);
       else
        var _D_ = _H_;
      }
     }
    }
    else
     var _D_ = _B_;
    if(_D_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, _i_)) negative_exponent(0);
    var _v_ = caml_greaterthan(caml_call1(abs, base), _j_);
    if(_v_){
     var _w_ = caml_greaterthan(exponent, _k_);
     if(_w_)
      var _x_ = _w_;
     else
      var
       _y_ = caml_int64_to_int32(exponent),
       _z_ = caml_check_bound(Base_Pow_overflow_bounds[6], _y_)[1 + _y_],
       _x_ = caml_greaterthan(caml_call1(abs, base), _z_);
    }
    else
     var _x_ = _v_;
    if(_x_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    _l_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _m_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _u_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _l_, caml_call1(X[4], x), _u_, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _r_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _m_, caml_call1(X[4], x), _r_, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var _s_ = caml_call2(X[5], x, one), _t_ = caml_call2(X[8], _s_, y);
         return caml_call2(X[6], _t_, one);
        }
        function symbol$1(x, y){
         var _p_ = caml_call1(X[2], y), _q_ = caml_call1(X[2], x);
         return caml_call2(Base_Import[96], _q_, _p_);
        }
        function round_down(i, modulus){
         var _o_ = symbol(i, modulus);
         return caml_call2(X[6], i, _o_);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var _n_ = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], _n_, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         var dir = opt ? opt[1] : 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = runtime.caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = runtime.caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = runtime.caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = runtime.caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure;
   function int64_popcount(x$1){
    var
     x$0 =
       runtime.caml_int64_sub
        (x$1, caml_int64_and(caml_int64_shift_right_unsigne(x$1, 1), m1)),
     x =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x, caml_int64_shift_right_unsigne(x, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var _a_ = Stdlib_Nativeint[9], _b_ = [0, "src/popcount.ml", 45, 9];
   if(32 === _a_)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(_c_){return runtime.Base_int_math_int_popcount(_c_);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    all = Base_Sign0[6],
    Replace_polymorphic_compare = Base_Sign0[7],
    to_int = Base_Sign0[10],
    of_int = Base_Sign0[13],
    _a_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         Base_Sign0[4],
         Base_Sign0[5],
         Base_Sign0[11],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[8],
         Base_Sign0[9],
         Base_Sign0[12]]),
    hash_fold_t = _a_[1],
    hash = _a_[2],
    t_of_sexp = _a_[3],
    sexp_of_t = _a_[4],
    of_string = _a_[5],
    to_string = _a_[6],
    between = _a_[19],
    clamp_exn = _a_[20],
    clamp = _a_[21],
    comparator = _a_[22],
    pp = _a_[23],
    hashable = _a_[24],
    cst_negative = "negative",
    cst_zero = "zero",
    cst_positive = "positive";
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      default: return cst_positive;
    }
   }
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var _b_ = caml_call1(to_int, t), _c_ = caml_call1(to_int, t$0);
    return caml_call1(of_int, caml_call2(Base_Import[88], _c_, _b_));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    max = Replace_polymorphic_compare[11],
    min = Replace_polymorphic_compare[12],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       to_string_hum,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(9, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    of_string_opt = Base_Int0[3],
    globalize = Base_Import[255],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare,
    _a_ = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function of_string$0(s){
    try{var _an_ = caml_call1(of_string, s); return _an_;}
    catch(_ao_){return caml_call3(Base_Printf[6], _a_, s, 0);}
   }
   var
    num_bits = Base_Int_conversions[29],
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits),
    _b_ =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"];
   function to_float(_am_){return _am_;}
   function of_float_unchecked(_al_){return _al_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return f | 0;
    var _ak_ = caml_call1(Base_Float0[28], f);
    return caml_call3(Base_Printf[7], _b_, _ak_, 0);
   }
   var
    zero = 0,
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    _c_ = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, zero]),
    is_positive = _c_[1],
    is_non_negative = _c_[2],
    is_negative = _c_[3],
    is_non_positive = _c_[4],
    include = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare$0 = Base_Import[229],
    hash_fold_t$0 = Base_Import[207],
    func$0 = Base_Import[221];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    neg = Base_Import[113],
    _d_ = [0, [4, 6, 0, 0, 0], cst_x],
    _e_ = [0, [4, 6, 0, 0, 0], cst_x];
   function symbol(_aj_, _ai_){return _aj_ < _ai_ ? 1 : 0;}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$1(s){
    return caml_call3(Stdlib_Scanf[5], s, _e_, function(_ah_){return _ah_;});
   }
   var
    include$0 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$1[1],
    _f_ = [0, "src/int.ml", 110, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var _af_ = low <= t ? 1 : 0, _ag_ = _af_ ? t <= high ? 1 : 0 : _af_;
    return _ag_;
   }
   function clamp_unchecked(t, min, max){
    return t < min ? min : t <= max ? t : max;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     _ac_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _ad_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _ac_],
     _ae_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _ad_);
    return caml_call1(Base_Or_error[35], _ae_);
   }
   function pred(i){return caml_call2(Base_Import[93], i, 1);}
   function succ(i){return caml_call2(Base_Import[91], i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[85][19],
    min_value = Base_Import[85][20],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[11],
    of_int64_exn = Base_Int_conversions[12],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[22],
    of_nativeint_exn = Base_Int_conversions[23],
    to_nativeint = Base_Int_conversions[5];
   function abs(x){return caml_call1(Base_Import[123], x);}
   function rem(a, b){return caml_call2(Base_Import[122], a, b);}
   function incr(_ab_){_ab_[1]++; return 0;}
   function decr(_aa_){_aa_[1]--; return 0;}
   function shift_right(a, b){return caml_call2(Base_Import[115], a, b);}
   function shift_right_logical(a, b){
    return caml_call2(Base_Import[120], a, b);
   }
   function shift_left(a, b){return caml_call2(Base_Import[119], a, b);}
   function bit_not(a){return caml_call1(Base_Import[117], a);}
   function bit_or(a, b){return caml_call2(Base_Import[118], a, b);}
   function bit_and(a, b){return caml_call2(Base_Import[116], a, b);}
   function bit_xor(a, b){return caml_call2(Base_Import[121], a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return caml_call2(pow, b, e);}
   var
    raise_s = Base_Error[30],
    _g_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _g_, 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = caml_call2(Base_Import[93], x, 1),
     _W_ = caml_call2(Base_Import[120], x$0, 1),
     x$1 = caml_call2(Base_Import[118], x$0, _W_),
     _X_ = caml_call2(Base_Import[120], x$1, 2),
     x$2 = caml_call2(Base_Import[118], x$1, _X_),
     _Y_ = caml_call2(Base_Import[120], x$2, 4),
     x$3 = caml_call2(Base_Import[118], x$2, _Y_),
     _Z_ = caml_call2(Base_Import[120], x$3, 8),
     x$4 = caml_call2(Base_Import[118], x$3, _Z_),
     ___ = caml_call2(Base_Import[120], x$4, 16),
     x$5 = caml_call2(Base_Import[118], x$4, ___),
     _$_ = caml_call2(Base_Import[120], x$5, 32),
     x$6 = caml_call2(Base_Import[118], x$5, _$_);
    return caml_call2(Base_Import[91], x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     _P_ = caml_call2(Base_Import[120], x, 1),
     x$0 = caml_call2(Base_Import[118], x, _P_),
     _Q_ = caml_call2(Base_Import[120], x$0, 2),
     x$1 = caml_call2(Base_Import[118], x$0, _Q_),
     _R_ = caml_call2(Base_Import[120], x$1, 4),
     x$2 = caml_call2(Base_Import[118], x$1, _R_),
     _S_ = caml_call2(Base_Import[120], x$2, 8),
     x$3 = caml_call2(Base_Import[118], x$2, _S_),
     _T_ = caml_call2(Base_Import[120], x$3, 16),
     x$4 = caml_call2(Base_Import[118], x$3, _T_),
     _U_ = caml_call2(Base_Import[120], x$4, 32),
     x$5 = caml_call2(Base_Import[118], x$4, _U_),
     _V_ = caml_call2(Base_Import[120], x$5, 1);
    return caml_call2(Base_Import[93], x$5, _V_);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var _O_ = caml_call2(Base_Import[93], x, 1);
    return 0 === caml_call2(Base_Import[116], x, _O_) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var _L_ = [0, [0, cst, caml_call1(Base_Import[140], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _L_));
    }
    var
     _M_ = runtime.Base_int_math_int_clz(i),
     _N_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _N_, _M_);
   }
   function ceil_log2(i){
    if(i <= 0){
     var _J_ = [0, [0, cst$0, caml_call1(Base_Import[140], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_ceil_log2_got_invalid_, _J_));
    }
    if(1 === i) return 0;
    var
     _K_ = runtime.Base_int_math_int_clz(caml_call2(Base_Import[93], i, 1));
    return caml_call2(Base_Import[93], num_bits, _K_);
   }
   var
    sign = Base_Sign[28],
    popcount = Base_Popcount[1],
    F =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string$0,
         to_string,
         function(_I_, _H_){return _I_ + _H_ | 0;},
         function(_G_, _F_){return _G_ - _F_ | 0;},
         runtime.caml_mul,
         caml_div,
         function(_E_){return - _E_ | 0;},
         function(_D_, _C_){return _C_ <= _D_ ? 1 : 0;},
         function(_B_, _A_){return _B_ <= _A_ ? 1 : 0;},
         function(_z_, _y_){return _z_ === _y_ ? 1 : 0;},
         function(_x_, _w_){return _w_ < _x_ ? 1 : 0;},
         function(_v_, _u_){return _v_ < _u_ ? 1 : 0;},
         function(_t_, _s_){return _t_ !== _s_ ? 1 : 0;},
         abs,
         function(_r_){return - _r_ | 0;},
         zero,
         of_int_exn,
         rem]),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8],
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _i_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"];
   function symbol$1(x, y){
    if(y <= 0){
     var _p_ = caml_call1(to_string, y), _q_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _h_, _q_, _p_, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var _n_ = caml_call1(to_string, y), _o_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _i_, _o_, _n_, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return caml_call2(Base_Import[96], x, y);}
   var
    lnot = Base_Import[117],
    include$2 = Base_Import[97],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    Base_Int =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(_m_, _l_){return _m_ === _l_ ? 1 : 0;},
       caml_int_compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       of_string_opt,
       to_string_hum,
       1,
       -1,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_k_){return runtime.Base_int_math_int_clz(_k_);},
       function(_j_){return runtime.Base_int_math_int_ctz(_j_);},
       [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       1073741823,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       [0, [0, F[1], F[2], F[3]]]];
   runtime.caml_register_global(33, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Comparable, Base__Hash, Base__Import, Base__Pretty_printer, Base__Printf, Base__String, Base__Uchar0, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    _a_ = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    _b_ = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed";
   function hash_fold_t(state, t){
    var _s_ = caml_call1(to_int, t);
    return caml_call2(Base_Hash[3], state, _s_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string(t){
    var _r_ = caml_call1(to_int, t);
    return caml_call2(Base_Printf[2], _a_, _r_);
   }
   function sexp_of_t(t){return [0, to_string(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Base_Import[157], cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      _p_ =
        caml_call3
         (Stdlib_Scanf[5],
          s,
          _b_,
          function(i){return caml_call1(Base_Uchar0[7], i);});
     return _p_;
    }
    catch(_q_){
     return caml_call2(Base_Import[157], cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[2]),
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name, to_string])[1],
    _c_ = caml_call1(Base_Comparable[11], [0, compare, sexp_of_t]),
    between = _c_[13],
    clamp_exn = _c_[14],
    clamp = _c_[15],
    comparator = _c_[16],
    _d_ = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    _e_ = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    _f_ =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    _g_ =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"];
   function invariant(param){return 0;}
   function succ_exn(c){
    try{var _o_ = caml_call1(Base_Uchar0[1], c); return _o_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _d_, msg, 0);
    }
   }
   function succ(c){
    try{var _m_ = [0, caml_call1(Base_Uchar0[1], c)]; return _m_;}
    catch(_n_){
     var _l_ = caml_wrap_exception(_n_);
     if(_l_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_l_, 0);
    }
   }
   function pred_exn(c){
    try{var _k_ = caml_call1(Base_Uchar0[2], c); return _k_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _e_, msg, 0);
    }
   }
   function pred(c){
    try{var _i_ = [0, caml_call1(Base_Uchar0[2], c)]; return _i_;}
    catch(_j_){
     var _h_ = caml_wrap_exception(_j_);
     if(_h_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_h_, 0);
    }
   }
   function of_scalar(i){
    return caml_call1(is_valid, i) ? [0, caml_call1(unsafe_of_int, i)] : 0;
   }
   function of_scalar_exn(i){
    return caml_call1(is_valid, i)
            ? caml_call1(unsafe_of_int, i)
            : caml_call3(failwithf, _f_, i, 0);
   }
   function to_scalar(t){return caml_call1(Base_Uchar0[8], t);}
   function to_char(c){
    return caml_call1(is_char, c) ? [0, caml_call1(unsafe_to_char, c)] : 0;
   }
   function to_char_exn(c){
    return caml_call1(is_char, c)
            ? caml_call1(unsafe_to_char, c)
            : caml_call3(failwithf, _g_, caml_call1(to_int, c), 0);
   }
   function utf8_byte_length(uchar){
    var codepoint = to_scalar(uchar);
    return 128 <= codepoint
            ? 2048 <= codepoint ? 65536 <= codepoint ? 4 : 3 : 2
            : 1;
   }
   var
    include = Base_Import[107],
    symbol = include[2],
    symbol$0 = include[3],
    symbol$1 = include[4],
    symbol$2 = include[5],
    symbol$3 = include[6],
    symbol$4 = include[7],
    ascending = include[8],
    descending = include[9],
    compare$0 = include[10],
    equal = include[11],
    max = include[12],
    min = include[13],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf8_byte_length,
       min_value,
       max_value];
   runtime.caml_register_global(19, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Error, Base__Import, Base__Int, Base__Option, Base__Sexp, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    some_t = [0, 0],
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Int = global_data.Base__Int,
    _a_ = [0, "T"];
   function sexp_of_t(of_a_001, of_b_002, param){return _a_;}
   var
    _b_ = [0, 0, 0],
    _c_ = [0, "type_witness"],
    cst_Key = "Key",
    _d_ = [0, "witness"],
    _e_ = [0, "name"],
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids";
   function sym(param){return 0;}
   function trans(_H_, param){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(_G_, param){return 0;} return [0, lift];}
   function Lift3(X){
    function lift(_F_, _E_, param){return 0;}
    return [0, lift];
   }
   function detuple2(param){return _b_;}
   function tuple2(_D_, param){return 0;}
   function Composition_preserves_injectiv(M1, M2){
    function strip(e){
     var _C_ = caml_call1(M2[1], e);
     return caml_call1(M1[1], _C_);
    }
    return [0, strip];
   }
   function sexp_of_t$0(_B_, param){
    var name = param[2], witness = param[1];
    if(Base_Import[130]) return [0, name];
    var
     t = witness[1],
     _A_ = caml_call1(Stdlib_Obj[22][1], t),
     v_005 = caml_call1(Stdlib_Obj[22][3], _A_);
    return [1,
            [0,
             [1, [0, _e_, [0, [0, name], 0]]],
             [0,
              [1,
               [0,
                _d_,
                [0,
                 [1, [0, _c_, [0, caml_call1(Base_Import[140], v_005), 0]]],
                 0]]],
              0]]];
   }
   function to_sexp(t){return t[3];}
   function name(t){return t[2];}
   function create(name, to_sexp){
    var Key = [248, cst_Key, runtime.caml_fresh_oo_id(0)];
    return [0, [0, Key], name, to_sexp];
   }
   function uid(t){
    var M = t[1], _z_ = caml_call1(Stdlib_Obj[22][1], M[1]);
    return caml_call1(Stdlib_Obj[22][3], _z_);
   }
   function hash(t){return uid(t);}
   function hash_fold_t(s, t){
    var _y_ = uid(t);
    return caml_call2(Base_Import[207], s, _y_);
   }
   function same_witness(t1, t2){
    var b = t2[1], a = t1[1];
    return a[1] === b[1] ? some_t : 0;
   }
   function same(t1, t2){
    var _x_ = same_witness(t1, t2);
    return caml_call1(Base_Option[51], _x_);
   }
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var w = match[1]; return w;}
    var
     _r_ = Base_Import[153],
     _s_ = Base_Import[153],
     _t_ =
       [0,
        [0,
         cst,
         caml_call3
          (Base_Import[148],
           function(_w_){return sexp_of_t$0(_s_, _w_);},
           function(_v_){return sexp_of_t$0(_r_, _v_);},
           [0, t1, t2])],
        0],
     _u_ = caml_call2(Base_Sexp[9], cst_Type_equal_Id_same_witness, _t_);
    return caml_call1(Base_Error[30], _u_);
   }
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       0,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       Composition_preserves_injectiv,
       [0,
        sexp_of_t$0,
        [0,
         Base_Int[7],
         Base_Int[8],
         Base_Int[9],
         Base_Int[10],
         Base_Int[11],
         Base_Int[12],
         function(_q_, _p_){return _p_ <= _q_ ? 1 : 0;},
         function(_o_, _n_){return _o_ <= _n_ ? 1 : 0;},
         function(_m_, _l_){return _m_ === _l_ ? 1 : 0;},
         function(_k_, _j_){return _j_ < _k_ ? 1 : 0;},
         function(_i_, _h_){return _i_ < _h_ ? 1 : 0;},
         function(_g_, _f_){return _g_ !== _f_ ? 1 : 0;},
         Base_Int[13],
         Base_Int[14],
         Base_Int[15],
         Base_Int[16],
         Base_Int[17],
         Base_Int[18],
         Base_Int[19],
         Base_Int[20],
         Base_Int[21],
         Base_Int[22],
         Base_Int[23],
         Base_Int[24]],
        uid,
        create,
        hash,
        name,
        to_sexp,
        hash_fold_t,
        same,
        same_witness,
        same_witness_exn]];
   runtime.caml_register_global(15, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[14], 1),
    none = 24791911,
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]";
   function is_none(x){return caml_call2(Base_Import[128], x, none);}
   function is_some(x){return 1 - caml_call2(Base_Import[128], x, none);}
   function some(x){
    return caml_call2(Base_Import[128], x, none) ? none_substitute : x;
   }
   function value_unsafe(x){
    return caml_call2(Base_Import[128], x, none_substitute) ? none : x;
   }
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : caml_call1(Base_Import[124], cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Option[7], Base_Option[8]]),
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function t_of_sexp$0(of_a_001, x_003){
    var _w_ = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], _w_, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var _v_ = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], _v_, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     _t_ = caml_call1(Base_Option[4], a_sexp_grammar),
     _u_ = caml_call1(Sexplib0_Sexp_grammar[1], _t_);
    return caml_call1(Base_Uniform_array[3], _u_);
   }
   var empty = Base_Uniform_array[6];
   function create(len){return caml_call2(Base_Uniform_array[7], len, none);}
   function init(n, f){
    return caml_call2
            (Base_Uniform_array[9],
             n,
             function(i){return of_sexpable(caml_call1(f, i));});
   }
   function init_some(n, f){
    return caml_call2
            (Base_Uniform_array[9],
             n,
             function(i){return some(caml_call1(f, i));});
   }
   var _a_ = Base_Uniform_array[10];
   function get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[11], t, i));
   }
   function get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_none$0(t, i){
    return is_none(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_some$0(t, i){
    return is_some(caml_call2(Base_Uniform_array[11], t, i));
   }
   function set(t, i, x){
    var _s_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[13], t, i, _s_);
   }
   function set_some(t, i, x){
    var _r_ = some(x);
    return caml_call3(Base_Uniform_array[13], t, i, _r_);
   }
   function set_none(t, i){
    return caml_call3(Base_Uniform_array[13], t, i, none);
   }
   function swap(t, i, j){return caml_call3(Base_Uniform_array[15], t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_set(t, i, x){
    var _q_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[14], t, i, _q_);
   }
   function unsafe_set_some(t, i, x){
    var _p_ = some(x);
    return caml_call3(Base_Uniform_array[14], t, i, _p_);
   }
   function unsafe_set_none(t, i){
    return caml_call3(Base_Uniform_array[14], t, i, none);
   }
   function clear(t){
    var
     _m_ = caml_call1(_a_, t),
     _n_ = caml_call2(Base_Import[93], _m_, 1),
     _l_ = 0;
    if(_n_ >= 0){
     var i = _l_;
     for(;;){
      unsafe_set_none(t, i);
      var _o_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _o_;
     }
    }
    return 0;
   }
   function _b_(input, f){
    var
     _i_ = caml_call1(_a_, input),
     _j_ = caml_call2(Base_Import[93], _i_, 1),
     _h_ = 0;
    if(_j_ >= 0){
     var i = _h_;
     for(;;){
      caml_call2(f, i, unsafe_get(input, i));
      var _k_ = i + 1 | 0;
      if(_j_ === i) break;
      i = _k_;
     }
    }
    return 0;
   }
   function _c_(input, init, f){
    var acc = [0, init];
    _b_
     (input,
      function(i, elem){acc[1] = caml_call3(f, i, acc[1], elem); return 0;});
    return acc[1];
   }
   function fold(input, init, f){
    return _c_
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, _c_],
    iter =
      [0,
       -198771759,
       function(input, f){
        return _b_(input, function(param, x){return caml_call1(f, x);});
       }],
    iteri = [0, -198771759, _b_],
    length = [0, -198771759, _a_],
    include$0 =
      caml_call1
       (Base_Indexed_container[10], [0, fold, iter, length, iteri, foldi]),
    is_empty = include$0[2],
    mem = include$0[3],
    iter$0 = include$0[4],
    fold$0 = include$0[5],
    fold_result = include$0[6],
    fold_until = include$0[7],
    exists = include$0[8],
    for_all = include$0[9],
    count = include$0[10],
    sum = include$0[11],
    find = include$0[12],
    find_map = include$0[13],
    to_list = include$0[14],
    min_elt = include$0[16],
    max_elt = include$0[17],
    foldi$0 = include$0[18],
    iteri$0 = include$0[19],
    existsi = include$0[20],
    for_alli = include$0[21],
    counti = include$0[22],
    findi = include$0[23],
    find_mapi = include$0[24],
    length$0 = Base_Uniform_array[10];
   function map(input, f){
    var output = create(caml_call1(length$0, input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = caml_call1(length$0, input),
     output = create(len),
     _f_ = caml_call2(Base_Import[93], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      var opt = caml_call2(Base_Uniform_array[12], input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[1 + i];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[1 + i];});
   }
   function to_array(t){
    var _d_ = caml_call1(length$0, t);
    return caml_call2
            (Base_Array[40], _d_, function(i){return unsafe_get(t, i);});
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[30],
    include$1 =
      caml_call1(Base_Blit[5], [0, create_like, length$0, unsafe_blit]),
    blit = include$1[1],
    blito = include$1[2],
    unsafe_blit$0 = include$1[3],
    sub = include$1[4],
    subo = include$1[5],
    copy = Base_Uniform_array[33],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       is_empty,
       mem,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       length$0,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Exn = global_data.Base__Exn,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[30],
    _a_ = [0, "elts"],
    _b_ = [0, "length"],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    _c_ = [0, cst_src_stack_ml, 48, 6],
    _d_ = [0, cst_src_stack_ml, 41, 4];
   function capacity(t){return caml_call1(Base_Option_array[28], t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= caml_call1(Base_Option_array[28], elts)){
      var _N_ = caml_call2(Base_Import[93], length, 1), _M_ = 0;
      if(_N_ >= 0){
       var i$0 = _M_;
       for(;;){
        caml_call1(invariant_a, caml_call2(Base_Option_array[35], elts, i$0));
        var _S_ = i$0 + 1 | 0;
        if(_N_ === i$0) break;
        i$0 = _S_;
       }
      }
      var
       _O_ = caml_call1(Base_Option_array[28], elts),
       _P_ = caml_call2(Base_Import[93], _O_, 1);
      if(_P_ >= length){
       var i = length;
       for(;;){
        if(caml_call2(Base_Option_array[37], elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var _R_ = i + 1 | 0;
        if(_P_ === i) break;
        i = _R_;
       }
      }
      var _Q_ = 0;
      return _Q_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[153],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = caml_call2(Base_Option_array[2], of_a_001, elts_005),
      bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Base_Import[140], length_003),
      bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002],
      _L_ =
        [0,
         [0, cst_exn, caml_call1(Base_Exn[1], exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Stack_invariant_failed, _L_));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], _I_ = caml_call2(Base_Import[93], t[1], 1);
    if(_I_ >= 0){
     var i = _I_;
     for(;;){
      var _J_ = caml_call2(Base_Option_array[35], t[2], i);
      r[1] = caml_call2(f, r[1], _J_);
      var _K_ = i - 1 | 0;
      if(0 === i) break;
      i = _K_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _G_ = caml_call2(Base_Import[93], t[1], 1);
    if(_G_ >= 0){
     var i = _G_;
     for(;;){
      caml_call1(f, caml_call2(Base_Option_array[35], t[2], i));
      var _H_ = i - 1 | 0;
      if(0 === i) break;
      i = _H_;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[17], [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7],
    _e_ = [0, cst_src_stack_ml, 109, 14];
   function of_list(l){
    if(caml_call1(Base_List[18], l)) return create(0);
    var
     length = caml_call1(Base_List[17], l),
     _D_ = caml_call2(Base_Import[88], 2, length),
     elts = caml_call1(Base_Option_array[5], _D_),
     r = [0, l],
     _E_ = caml_call2(Base_Import[93], length, 1);
    if(_E_ >= 0){
     var i = _E_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var l$0 = match[2], a = match[1];
      caml_call3(Base_Option_array[43], elts, i, a);
      r[1] = l$0;
      var _F_ = i - 1 | 0;
      if(0 === i) break;
      i = _F_;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var _C_ = caml_call1(to_list, t);
    return caml_call2(Base_List[5], sexp_of_a, _C_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[4], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _B_ = caml_call1(Base_List[6], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _B_);
   }
   function resize(t, size){
    var arr = caml_call1(Base_Option_array[5], size);
    caml_call5(Base_Option_array[52], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = caml_call2(Base_Import[100], new_capacity, t[1]),
     _A_ = new_capacity$0 !== capacity(t) ? 1 : 0;
    return _A_ ? resize(t, new_capacity$0) : _A_;
   }
   function push(t, a){
    var _y_ = caml_call1(Base_Option_array[28], t[2]);
    if(t[1] === _y_){
     var _z_ = caml_call2(Base_Import[91], t[1], 1);
     resize(t, caml_call2(Base_Import[88], 2, _z_));
    }
    caml_call3(Base_Option_array[43], t[2], t[1], a);
    t[1] = caml_call2(Base_Import[91], t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = caml_call2(Base_Import[93], t[1], 1),
     result = caml_call2(Base_Option_array[35], t[2], i);
    caml_call2(Base_Option_array[44], t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = caml_call1(Base_Error[12], "Stack.pop of empty stack");
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var _x_ = caml_call2(Base_Import[93], t[1], 1);
    return caml_call2(Base_Option_array[35], t[2], _x_);
   }
   var top_error = caml_call1(Base_Error[12], "Stack.top of empty stack");
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, caml_call1(Base_Option_array[57], elts)];
   }
   function clear(t){
    var _s_ = 0 < t[1] ? 1 : 0;
    if(_s_){
     var _u_ = caml_call2(Base_Import[93], t[1], 1), _t_ = 0;
     if(_u_ >= 0){
      var i = _t_;
      for(;;){
       caml_call2(Base_Option_array[44], t[2], i);
       var _w_ = i + 1 | 0;
       if(_u_ === i) break;
       i = _w_;
      }
     }
     t[1] = 0;
     var _v_ = 0;
    }
    else
     var _v_ = _s_;
    return _v_;
   }
   function until_empty(t, f){
    for(;;){
     var _r_ = 0 < t[1] ? 1 : 0;
     if(! _r_) return _r_;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function filter_map(t, f){
    var
     t_result = create(0),
     _p_ = caml_call2(Base_Import[93], t[1], 1),
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      var match = caml_call1(f, caml_call2(Base_Option_array[35], t[2], i));
      if(match){var x = match[1]; push(t_result, x);}
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      i = _q_;
     }
    }
    return t_result;
   }
   function filter(t, f){
    var
     t_result = create(0),
     _m_ = caml_call2(Base_Import[93], t[1], 1),
     _l_ = 0;
    if(_m_ >= 0){
     var i = _l_;
     for(;;){
      var x = caml_call2(Base_Option_array[35], t[2], i);
      if(caml_call1(f, x)) push(t_result, x);
      var _n_ = i + 1 | 0;
      if(_m_ === i) break;
      i = _n_;
     }
    }
    return t_result;
   }
   function filter_inplace(t, f){
    var write_index = [0, 0];
    return caml_call2
            (Base_Exn[13],
             function(param){
              var _j_ = caml_call2(Base_Import[93], t[1], 1), _i_ = 0;
              if(_j_ >= 0){
               var read_index = _i_;
               for(;;){
                var x = caml_call2(Base_Option_array[40], t[2], read_index);
                if(caml_call1(f, x)){
                 if(write_index[1] < read_index)
                  caml_call3(Base_Option_array[50], t[2], write_index[1], x);
                 write_index[1]++;
                }
                var _k_ = read_index + 1 | 0;
                if(_j_ === read_index) break;
                read_index = _k_;
               }
              }
              return 0;
             },
             function(param){
              var
               _f_ = write_index[1],
               _g_ = caml_call2(Base_Import[93], t[1], 1);
              if(_g_ >= _f_){
               var i = _f_;
               for(;;){
                caml_call2(Base_Option_array[51], t[2], i);
                var _h_ = i + 1 | 0;
                if(_g_ === i) break;
                i = _h_;
               }
              }
              t[1] = write_index[1];
              return 0;
             });
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       filter_map,
       filter,
       filter_inplace,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Int = global_data.Base__Int,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     _a_ = caml_call1(Base_Int[8], pos_cnum),
     _b_ = caml_call1(Base_Int[8], pos_bol),
     _c_ = caml_call1(Base_Int[8], pos_lnum),
     _d_ = runtime.Base_hash_string(pos_fname),
     _e_ = caml_call2(Base_Import[121], _d_, _c_),
     _f_ = caml_call2(Base_Import[121], _e_, _b_);
    return caml_call2(Base_Import[121], _f_, _a_);
   }
   var
    hash_fold_t = Base_Source_code_position0[3],
    comparator = Base_Source_code_position0[5],
    to_string = Base_Source_code_position0[7],
    sexp_of_t = Base_Source_code_position0[8],
    include = caml_call1(Base_Comparable[12], [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero$0 = "zero",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos],
    _d_ = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _k_ = sexp_004[1];
      b:
      if(_k_ !== cst_Nan){
       c:
       if(_k_ !== cst_Neg){
        d:
        if(_k_ !== cst_Pos){
         if(_k_ !== cst_Zero){
          if(_k_ === cst_nan) break b;
          if(_k_ === cst_neg) break c;
          if(_k_ === cst_pos) break d;
          if(_k_ !== cst_zero$0) break a;
         }
         return 1;
        }
        return 2;
       }
       return 0;
      }
      return 3;
     }
     var _l_ = sexp_004[1];
     if(! _l_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _m_ = _l_[1];
     if(0 !== _m_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _n_ = _m_[1];
     b:
     if(_n_ !== cst_Nan){
      c:
      if(_n_ !== cst_Neg){
       d:
       if(_n_ !== cst_Pos){
        if(_n_ !== cst_Zero){
         if(_n_ === cst_nan) break b;
         if(_n_ === cst_neg) break c;
         if(_n_ === cst_pos) break d;
         if(_n_ !== cst_zero$0) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      case 2:
       return caml_call2(Base_Hash[3], hsv, 2);
      default: return caml_call2(Base_Hash[3], hsv, 3);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _j_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _j_);
   }
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[137], s));}
   function to_string(t){
    var _i_ = sexp_of_t(t);
    return caml_call1(Base_Import[161], _i_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    _e_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = _e_[1],
    hash$0 = _e_[2],
    t_of_sexp$0 = _e_[3],
    sexp_of_t$0 = _e_[4],
    of_string$0 = _e_[5],
    to_string$0 = _e_[6],
    between = _e_[19],
    clamp_exn = _e_[20],
    clamp = _e_[21],
    comparator = _e_[22],
    pp = _e_[23],
    hashable = _e_[24],
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan",
    cst_negative = "negative",
    cst_zero = cst_zero$0,
    cst_positive = "positive",
    cst_not_a_number = "not-a-number";
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return caml_call1(Base_Import[126], cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(caml_call1(Base_Sign[28], n));}
   function to_int_exn(t){
    var _h_ = to_sign_exn(t);
    return caml_call1(Base_Sign[29], _h_);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var _f_ = to_sign_exn(t), _g_ = to_sign_exn(t$0);
     return of_sign(caml_call2(Base_Sign[32], _g_, _f_));
    }
    return 3;
   }
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      case 2:
       return cst_positive;
      default: return cst_not_a_number;
    }
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       to_string_hum,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(35, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    hash_fold_t = Base_Sexp[1],
    hash = Base_Sexp[2],
    t_of_sexp = Base_Sexp[3],
    sexp_of_t = Base_Sexp[4],
    Not_found_s = Base_Sexp[7],
    Of_sexp_error = Base_Sexp[8],
    message = Base_Sexp[9],
    default_indent = Base_Sexp[10],
    pp_hum = Base_Sexp[11],
    pp_hum_indent = Base_Sexp[12],
    pp_mach = Base_Sexp[13],
    pp = Base_Sexp[14],
    to_string_hum = Base_Sexp[15],
    to_string_mach = Base_Sexp[16],
    to_string = Base_Sexp[17],
    of_float_style = Base_Sexp[18],
    of_int_style = Base_Sexp[19],
    t_sexp_grammar = Base_Sexp[21],
    invariant = Base_Sexp[22],
    of_string = Base_Sexp[23],
    include = caml_call1(Base_Comparable[11], [0, Base_Sexp[6], Base_Sexp[4]]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator = include[16],
    Base_Sexp_with_comparable =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_027 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    _a_ = [0, 0, 0],
    _b_ = [0, cst_Unbounded],
    _c_ = [0, cst_Incl$0],
    _d_ = [0, cst_Excl$0],
    _e_ = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    _f_ = [0, cst_Below_lower_bound],
    _g_ = [0, cst_In_range],
    _h_ = [0, cst_Above_upper_bound];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(! l) break;
     var
      l$0 = l[2],
      enumerate_002 = l[1],
      acc$0 = [0, [1, enumerate_002], acc];
     l = l$0;
     acc = acc$0;
    }
    var
     _q_ = caml_call1(Base_List[61], acc),
     l$1 = all_of_a,
     acc$1 = 0,
     _r_ = caml_call2(Base_List[9], _q_, _a_);
    for(;;){
     if(! l$1){
      var _s_ = caml_call1(Base_List[61], acc$1);
      return caml_call2(Base_List[9], _s_, _r_);
     }
     var
      l$2 = l$1[2],
      enumerate_001 = l$1[1],
      acc$2 = [0, [0, enumerate_001], acc$1];
     l$1 = l$2;
     acc$1 = acc$2;
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _n_ = sexp_008[1];
      b:
      if(_n_ !== cst_Excl$0){
       c:
       if(_n_ !== cst_Incl$0){
        if(_n_ !== cst_Unbounded){
         if(_n_ === cst_excl) break b;
         if(_n_ === cst_incl) break c;
         if(_n_ !== cst_unbounded) break a;
        }
        return 0;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
     }
     var _o_ = sexp_008[1];
     if(! _o_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_008);
     var _p_ = _o_[1];
     if(0 !== _p_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_008);
     var tag_009 = _p_[1];
     b:
     if(tag_009 !== cst_Excl$0){
      c:
      if(tag_009 !== cst_Incl$0){
       if(tag_009 !== cst_Unbounded){
        if(tag_009 === cst_excl) break b;
        if(tag_009 === cst_incl) break c;
        if(tag_009 !== cst_unbounded) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_008);
      }
      var sexp_args_010 = _o_[2];
      if(sexp_args_010 && ! sexp_args_010[2]){
       var
        arg0_011 = sexp_args_010[1],
        res0_012 = caml_call1(of_a_003, arg0_011);
       return [0, res0_012];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_006,
               tag_009,
               sexp_008);
     }
     var sexp_args_015 = _o_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_a_003, arg0_016);
      return [1, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_006,
              tag_009,
              sexp_008);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return _b_;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, _c_, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, _d_, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], _e_]]]];
   }
   function interval_comparison_of_sexp(sexp_028){
    a:
    {
     if(0 === sexp_028[0]){
      var _j_ = sexp_028[1];
      b:
      if(_j_ !== cst_Above_upper_bound){
       c:
       if(_j_ !== cst_Below_lower_bound){
        if(_j_ !== cst_In_range){
         if(_j_ === cst_above_upper_bound) break b;
         if(_j_ === cst_below_lower_bound) break c;
         if(_j_ !== cst_in_range) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _k_ = sexp_028[1];
     if(! _k_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_027, sexp_028);
     var _l_ = _k_[1];
     if(0 !== _l_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_027, sexp_028);
     var _m_ = _l_[1];
     b:
     if(_m_ !== cst_Above_upper_bound){
      c:
      if(_m_ !== cst_Below_lower_bound){
       if(_m_ !== cst_In_range){
        if(_m_ === cst_above_upper_bound) break b;
        if(_m_ === cst_below_lower_bound) break c;
        if(_m_ !== cst_in_range) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_027, sexp_028);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return _f_;case 1: return _g_;default: return _h_;
    }
   }
   var
    compare_interval_comparison = runtime.caml_int_compare,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound";
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash_interval_comparison(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _i_ = hash_fold_interval_comparison(hsv, arg);
    return caml_call1(Base_Hash[9], _i_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     caml_call1(Base_Import[124], cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, "Duplicate"],
    _b_ = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && -1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 17724 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(a_005 === b_006) return 1;
    if(typeof a_005 === "number"){
     if(typeof b_006 === "number" && -1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number" && 17724 === b_006[1]){
     var right_008 = b_006[2], left_007 = a_005[2];
     return caml_call2(cmp_a, left_007, right_008);
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return _a_;
    var v_010 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0],
    _c_ = [0, cst_Left$0],
    _d_ = [0, cst_Unequal$0],
    _e_ = [0, cst_Right$0],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0;
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(t_014 === t_016) return 0;
    var _O_ = t_014[1];
    if(847852583 === _O_){
     if(typeof t_016 !== "number" && 847852583 === t_016[1]){
      var right_018 = t_016[2], left_017 = t_014[2];
      return caml_call2(cmp_v, left_017, right_018);
     }
    }
    else
     if(1013247643 <= _O_){
      if(typeof t_016 !== "number" && 1013247643 === t_016[1]){
       var
        right_022 = t_016[2],
        left_021 = t_014[2],
        t_024 = left_021[2],
        t_023 = left_021[1],
        t_026 = right_022[2],
        t_025 = right_022[1],
        n$0 = caml_call2(cmp_v, t_023, t_025);
       return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
      }
     }
     else if(typeof t_016 !== "number" && -57574468 === t_016[1]){
      var right_020 = t_016[2], left_019 = t_014[2];
      return caml_call2(cmp_v, left_019, right_020);
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     _K_ = caml_call2(cmp_k, t_029, t_031);
    if(_K_){
     if(t_030 === t_032) return 1;
     var _L_ = t_030[1];
     if(847852583 === _L_){
      if(typeof t_032 !== "number" && 847852583 === t_032[1]){
       var right_034 = t_032[2], left_033 = t_030[2];
       return caml_call2(cmp_v, left_033, right_034);
      }
     }
     else
      if(1013247643 <= _L_){
       if(typeof t_032 !== "number" && 1013247643 === t_032[1]){
        var
         right_038 = t_032[2],
         left_037 = t_030[2],
         t_040 = left_037[2],
         t_039 = left_037[1],
         t_042 = right_038[2],
         t_041 = right_038[1],
         _N_ = caml_call2(cmp_v, t_039, t_041);
        return _N_ ? caml_call2(cmp_v, t_040, t_042) : _N_;
       }
      }
      else if(typeof t_032 !== "number" && -57574468 === t_032[1]){
       var right_036 = t_032[2], left_035 = t_030[2];
       return caml_call2(cmp_v, left_035, right_036);
      }
     var _M_ = caml_equal(t_030, t_032);
    }
    else
     var _M_ = _K_;
    return _M_;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(1 === sexp_071[0]){
     var _v_ = sexp_071[1];
     if(_v_){
      var _w_ = _v_[2];
      if(_w_ && ! _w_[2]){
       var
        arg1_068 = _w_[1],
        arg0_067 = _v_[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          _y_ =
            atom_047 !== cst_Left$0
             ? atom_047
               !== cst_Right$0
               ? atom_047
                 !== cst_Unequal$0
                 ? caml_call1(Sexplib0_Sexp_conv_error[19], 0)
                 : caml_call2
                   (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
             : caml_call2
               (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068),
          _z_ = _y_;
        else{
         var _A_ = arg1_068[1];
         if(_A_){
          var match = _A_[1];
          if(0 === match[0]){
           var sexp_args_050 = _A_[2], atom_047$0 = match[1];
           if(atom_047$0 !== cst_Left$0)
            if(atom_047$0 !== cst_Right$0)
             if(atom_047$0 !== cst_Unequal$0)
              var _B_ = caml_call1(Sexplib0_Sexp_conv_error[19], 0);
             else{
              a:
              {
               if(sexp_args_050 && ! sexp_args_050[2]){
                var arg0_058 = sexp_args_050[1];
                b:
                {
                 if(1 === arg0_058[0]){
                  var _F_ = arg0_058[1];
                  if(_F_){
                   var _G_ = _F_[2];
                   if(_G_ && ! _G_[2]){
                    var
                     arg1_053 = _G_[1],
                     arg0_052 = _F_[1],
                     res0_054 = caml_call1(of_v_044, arg0_052),
                     res1_055 = caml_call1(of_v_044, arg1_053),
                     res0_059 = [0, res0_054, res1_055];
                    break b;
                   }
                  }
                 }
                 var
                  res0_059 =
                    caml_call3
                     (Sexplib0_Sexp_conv_error[2], error_source_057, 2, arg0_058);
                }
                var _E_ = [0, 1013247643, res0_059];
                break a;
               }
               var
                _E_ =
                  caml_call3
                   (Sexplib0_Sexp_conv_error[22],
                    error_source_057,
                    atom_047$0,
                    arg1_068);
              }
              var _B_ = _E_;
             }
            else{
             a:
             {
              if(sexp_args_050 && ! sexp_args_050[2]){
               var
                arg0_061 = sexp_args_050[1],
                res0_062 = caml_call1(of_v_044, arg0_061),
                _H_ = [0, -57574468, res0_062];
               break a;
              }
              var
               _H_ =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[22],
                   error_source_057,
                   atom_047$0,
                   arg1_068);
             }
             var _B_ = _H_;
            }
           else{
            a:
            {
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_064 = sexp_args_050[1],
               res0_065 = caml_call1(of_v_044, arg0_064),
               _I_ = [0, 847852583, res0_065];
              break a;
             }
             var
              _I_ =
                caml_call3
                 (Sexplib0_Sexp_conv_error[22],
                  error_source_057,
                  atom_047$0,
                  arg1_068);
            }
            var _B_ = _I_;
           }
           var _C_ = _B_;
          }
          else
           var
            _C_ =
              caml_call2
               (Sexplib0_Sexp_conv_error[24], error_source_057, arg1_068);
          var _D_ = _C_;
         }
         else
          var
           _D_ =
             caml_call2
              (Sexplib0_Sexp_conv_error[25], error_source_057, arg1_068);
         var _z_ = _D_;
        }
        var res1_070 = _z_;
       }
       catch(_J_){
        var _x_ = caml_wrap_exception(_J_);
        if(_x_ !== Sexplib0_Sexp_conv_error[18])
         throw caml_maybe_attach_backtrace(_x_, 0);
        var
         res1_070 =
           caml_call2
            (Sexplib0_Sexp_conv_error[20], error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[2], error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     _u_ = arg1_082[1];
    if(847852583 === _u_)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, _c_, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= _u_)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, _d_, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, _e_, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar],
    _f_ = [0, "Both"],
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(a_085 === b_086) return 0;
    var _t_ = a_085[1];
    if(737457313 === _t_){
     if(typeof b_086 !== "number" && 737457313 === b_086[1]){
      var
       right_092 = b_086[2],
       left_091 = a_085[2],
       t_094 = left_091[2],
       t_093 = left_091[1],
       t_096 = right_092[2],
       t_095 = right_092[1],
       n = caml_call2(cmp_left, t_093, t_095);
      return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
     }
    }
    else
     if(847852583 <= _t_){
      if(typeof b_086 !== "number" && 847852583 === b_086[1]){
       var right_088 = b_086[2], left_087 = a_085[2];
       return caml_call2(cmp_left, left_087, right_088);
      }
     }
     else if(typeof b_086 !== "number" && -57574468 === b_086[1]){
      var right_090 = b_086[2], left_089 = a_085[2];
      return caml_call2(cmp_right, left_089, right_090);
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(a_097 === b_098) return 1;
    var _r_ = a_097[1];
    if(737457313 === _r_){
     if(typeof b_098 !== "number" && 737457313 === b_098[1]){
      var
       right_104 = b_098[2],
       left_103 = a_097[2],
       t_106 = left_103[2],
       t_105 = left_103[1],
       t_108 = right_104[2],
       t_107 = right_104[1],
       _s_ = caml_call2(cmp_left, t_105, t_107);
      return _s_ ? caml_call2(cmp_right, t_106, t_108) : _s_;
     }
    }
    else
     if(847852583 <= _r_){
      if(typeof b_098 !== "number" && 847852583 === b_098[1]){
       var right_100 = b_098[2], left_099 = a_097[2];
       return caml_call2(cmp_left, left_099, right_100);
      }
     }
     else if(typeof b_098 !== "number" && -57574468 === b_098[1]){
      var right_102 = b_098[2], left_101 = a_097[2];
      return caml_call2(cmp_right, left_101, right_102);
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var _q_ = param[1];
    if(737457313 === _q_){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, _f_, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= _q_){
     var v_111 = param[2];
     return [1, [0, _g_, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, _h_, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare,
    _i_ = [0, "Stop"],
    _j_ = [0, "Continue"];
   function equal$2(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   function sexp_of_t$2(param){return param ? _i_ : _j_;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare,
    _k_ = [0, "Unfinished"],
    _l_ = [0, "Finished"];
   function equal$3(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function sexp_of_t$3(param){return param ? _k_ : _l_;}
   var
    Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3],
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished];
   runtime.caml_register_global(25, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Named = [0],
    Base_Set_intf = [0, Named];
   runtime.caml_register_global(0, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Base__Array, Base__Comparator, Base__Container, Base__Exn, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    with_return = Base_With_return[1],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    _a_ = [0, cst_src_set_ml, 198, 17],
    _b_ = [0, cst_src_set_ml, 199, 18],
    _c_ = [0, cst_src_set_ml, 205, 21],
    _d_ = [0, cst_src_set_ml, 207, 12],
    _e_ = [0, cst_src_set_ml, 213, 17],
    _f_ = [0, cst_src_set_ml, 214, 18],
    _g_ = [0, cst_src_set_ml, 220, 21],
    _h_ = [0, cst_src_set_ml, 222, 12];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      _bA_ = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var _bA_ = 1;
    if(_bA_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var _bB_ = 1;
    }
    else
     var _bB_ = _bA_;
    return _bB_;
   }
   function loop(lower, upper, compare_elt, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var v = t$0[1];
      return in_range(lower$0, upper, compare_elt, v);
     }
     var
      n = t$0[5],
      h = t$0[4],
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _bp_ = caml_call2(Base_Import[93], hl, hr),
      _bq_ = caml_call1(Base_Import[123], _bp_) <= 2 ? 1 : 0;
     if(_bq_){
      var
       _br_ = caml_call2(Base_Import[100], hl, hr),
       _bs_ = h === caml_call2(Base_Import[91], _br_, 1) ? 1 : 0;
      if(_bs_){
       var
        _bt_ = length(r),
        _bu_ = length(l),
        _bv_ = caml_call2(Base_Import[91], _bu_, _bt_),
        _bw_ = n === caml_call2(Base_Import[91], _bv_, 1) ? 1 : 0;
       if(_bw_){
        var _bx_ = in_range(lower$0, upper, compare_elt, v$0);
        if(_bx_){
         var _by_ = loop(lower$0, [0, v$0], compare_elt, l);
         if(_by_){
          var lower$1 = [0, v$0];
          lower$0 = lower$1;
          t$0 = r;
          continue;
         }
         var _bz_ = _by_;
        }
        else
         var _bz_ = _bx_;
       }
       else
        var _bz_ = _bw_;
      }
      else
       var _bz_ = _bs_;
     }
     else
      var _bz_ = _bq_;
     return _bz_;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    if(1 === h) return [0, v];
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    var _bo_ = caml_call2(Base_Import[91], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[91], _bo_, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, caml_call2(Base_Import[91], i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          kr = caml_call1(f, caml_call2(Base_Import[91], i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _bm_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _bm_, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      _bn_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _bn_, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var _bj_ = caml_check_bound(array, 1)[2];
      if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bj_)){
       var
        next =
          function(i){
           var
            _bk_ = caml_call2(Base_Import[93], array_length, 1),
            _bl_ = caml_call2(Base_Import[93], _bk_, i);
           return caml_check_bound(array, _bl_)[1 + _bl_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _bd_ = caml_check_bound(array, 1)[2],
                i =
                  caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bd_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _bf_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _be_ = 1;
               if(_bf_ >= 1){
                var i$0 = _be_;
                for(;;){
                 var
                  _bg_ = caml_call2(Base_Import[91], i$0, 1),
                  _bh_ = caml_check_bound(array, _bg_)[1 + _bg_],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[1 + i$0], _bh_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _bi_ = i$0 + 1 | 0;
                 if(_bf_ === i$0) break;
                 i$0 = _bi_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var lr = l[3], lv = l[2], ll = l[1], _a8_ = height(lr);
     if(_a8_ <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], _a__ = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, _a__);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var _a9_ = create(0, v, r);
     return create(create(ll, lv, 0), lrv, _a9_);
    }
    if(caml_call2(Base_Import[91], hl, 2) < hr){
     if(typeof r === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     if(0 === r[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     var rr = r[3], rv = r[2], rl = r[1], _a$_ = height(rl);
     if(_a$_ <= height(rr)) return create(create(l, v, rl), rv, rr);
     if(typeof rl === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     if(0 !== rl[0]){
      var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], _bb_ = create(rlr, rv, rr);
      return create(create(l, v, rll), rlv$0, _bb_);
     }
     var rlv = rl[1];
     if(! is_empty(rr))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var _ba_ = create(0, rv, rr);
     return create(create(l, v, 0), rlv, _ba_);
    }
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    if(1 === h) return [0, v];
    var _bc_ = caml_call2(Base_Import[91], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[91], _bc_, 1)];
   }
   var Same = [248, "Base__Set.Tree0.Same", caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? caml_call1(Base_Exn[6], Same)
              : 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     return 0 === c$0
             ? caml_call1(Base_Exn[6], Same)
             : 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _a6_ = aux(t); return _a6_;}
    catch(_a7_){
     var _a5_ = caml_wrap_exception(_a7_);
     if(_a5_ === Same) return t;
     throw caml_maybe_attach_backtrace(_a5_, 0);
    }
   }
   function add_min(x, t){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, 0, x, t, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(add_min(x, l), v, r);
   }
   function add_max(t, x){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, t, x, 0, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(l, v, add_max(r, x));
   }
   function join(l, v, r){
    if(typeof l === "number") return add_min(v, r);
    if(1 === l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){var rv = r[1]; return add_max(add_max(l, v), rv);}
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[91], rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r))
              : caml_call2
                 (Base_Import[91], lh, 2)
                < rh
                ? bal(join(l, v, rl), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add_max(l, v);
    var lv = l[1];
    return add_min(lv, add_min(v, r));
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      var l = param$0[1];
      if(typeof l !== "number"){param$0 = l; continue;}
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    _i_ = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    _j_ = [0, cst_src_set_ml, 315, 15];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Set_min_elt_exn_of_empty_set,
     function(param){
      if(param === Set_min_elt_exn_of_empty_set) return _i_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     });
   var
    Set_max_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    _k_ = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    _l_ = [0, cst_src_set_ml, 328, 15];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Set_max_elt_exn_of_empty_set,
     function(param){
      if(param === Set_max_elt_exn_of_empty_set) return _k_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     });
   var
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    _m_ = [0, 0, 0, 0],
    _n_ = [0, 0, 0],
    _o_ = [0, 0, 0];
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t, acc){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var value = t$0[1];
       return caml_call2(f, acc$0, value);
      }
      var
       right = t$0[3],
       value$0 = t$0[2],
       left = t$0[1],
       x = fold_until_helper(f, left, acc$0);
      if(0 !== x[0]) return x;
      var acc$1 = x[1], x$0 = caml_call2(f, acc$1, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$2 = x$0[1];
      t$0 = right;
      acc$0 = acc$2;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      if(typeof param$0[3] !== "number"){
       var r = param$0[3];
       param$0 = r;
       continue;
      }
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return caml_call1(Base_Import[126], cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var _a4_ = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), _a4_);
   }
   function concat(t1, t2){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var _a3_ = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), _a3_);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return _m_;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r)];
    }
    return split(t);
   }
   function split_le_gt(t, x, compare_elt){
    if(typeof t === "number") return _n_;
    if(0 === t[0]){
     var v = t[1];
     return 0 <= caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, add_max(l, v$0), r];
    if(0 <= c){
     var match = split_le_gt(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_le_gt(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   function split_lt_ge(t, x, compare_elt){
    if(typeof t === "number") return _o_;
    if(0 === t[0]){
     var v = t[1];
     return 0 < caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, l, add_min(v$0, r)];
    if(0 <= c){
     var match = split_lt_ge(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_lt_ge(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   var empty_without_value_restrictio = 0, _p_ = [0, 0, 0];
   function mem(t, x, compare_elt){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      _a2_ = 0 === c$0 ? 1 : 0;
     if(_a2_) return _a2_;
     var r$0 = 0 <= c$0 ? r : l;
     t$0 = r$0;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Same);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_elt, x, v)
              ? 0
              : caml_call1(Base_Exn[6], Same);
     }
     var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
     return 0 === c
             ? merge(l, r)
             : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _a0_ = aux(t); return _a0_;}
    catch(_a1_){
     var _aZ_ = caml_wrap_exception(_a1_);
     if(_aZ_ === Same) return t;
     throw caml_maybe_attach_backtrace(_aZ_, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Same);
     if(0 === t[0]) return 0 === i ? 0 : caml_call1(Base_Exn[6], Same);
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var _aY_ = caml_call2(Base_Import[93], i, l_size);
     return bal(l, v, aux(r, caml_call2(Base_Import[93], _aY_, 1)));
    }
    try{var _aW_ = aux(t, i); return _aW_;}
    catch(_aX_){
     var _aV_ = caml_wrap_exception(_aX_);
     if(_aV_ === Same) return t;
     throw caml_maybe_attach_backtrace(_aV_, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(caml_call2(Base_Import[128], s1$0, s2$0)) return s1$0;
      if(typeof s1$0 === "number")
       var t = s2$0;
      else{
       if(1 === s1$0[0]){
        var h1 = s1$0[4], r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
        if(typeof s2$0 !== "number"){
         if(0 === s2$0[0]){
          var v2 = s2$0[1], s2$1 = [1, 0, v2, 0, 1, 1];
          s2$0 = s2$1;
          continue;
         }
         var h2 = s2$0[4], r2 = s2$0[3], v2$0 = s2$0[2], l2 = s2$0[1];
         if(h2 <= h1){
          if(1 === h2) return add(s1$0, v2$0, compare_elt);
          var
           match = split(s2$0, v1$0, compare_elt),
           r2$0 = match[3],
           l2$0 = match[1],
           _aT_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1$0, _aT_);
         }
         if(1 === h1) return add(s2$0, v1$0, compare_elt);
         var
          match$0 = split(s1$0, v2$0, compare_elt),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _aU_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2$0, _aU_);
        }
       }
       if(typeof s2$0 !== "number"){
        var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1];
        s1$0 = s1$1;
        continue;
       }
       var t = s1$0;
      }
      return t;
     }
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    return caml_call3
            (Base_List[20],
             xs,
             empty_without_value_restrictio,
             function(ac, x){
              return union(ac, caml_call1(to_tree, x), compare_elt);
             });
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(caml_call2(Base_Import[128], s1, s2)) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _aQ_ = split(s2, v1, compare_elt),
          match = _aQ_[2],
          l2 = _aQ_[1];
         if(match){
          var r2 = _aQ_[3], v1$0 = match[1], _aR_ = inter(r1, r2);
          return join(inter(l1, l2), v1$0, _aR_);
         }
         var r2$0 = _aQ_[3], _aS_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _aS_);
        }
        var other_set = s1, singleton = s2, elt = s2[1];
        break a;
       }
       var other_set = s2, singleton = s1, elt = s1[1];
      }
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1, s2){
     var s1$0 = s1;
     for(;;){
      if(caml_call2(Base_Import[128], s1$0, s2)) return 0;
      if(typeof s1$0 === "number") return 0;
      if(typeof s2 === "number") return s1$0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       var
        r1 = s1$0[3],
        v1$0 = s1$0[2],
        l1 = s1$0[1],
        _aN_ = split(s2, v1$0, compare_elt),
        l2 = _aN_[1];
       if(_aN_[2]){
        var r2 = _aN_[3], _aO_ = diff(r1, r2);
        return concat(diff(l1, l2), _aO_);
       }
       var r2$0 = _aN_[3], _aP_ = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, _aP_);
      }
      var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1];
      s1$0 = s1$1;
     }
    }
    return diff(s1, s2);
   }
   function cons(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var r = s$0[3], v$0 = s$0[2], l = s$0[1], e$1 = [0, v$0, r, e$0];
     s$0 = l;
     e$0 = e$1;
    }
   }
   function cons_right(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var r = s$0[3], v$0 = s$0[2], l = s$0[1], e$1 = [0, v$0, l, e$0];
     s$0 = r;
     e$0 = e$1;
    }
   }
   function of_set(s){return cons(s, 0);}
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = cons(tree, enum$0);
    }
   }
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree, enum$0)]];
     }
     var right = state[2], enum1 = left[3], tree1 = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[128], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _aM_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _aM_];
     return [0, next_state];
    }
    var _aK_ = of_set(t2), _aL_ = [0, of_set(t1), _aK_];
    return caml_call2(Base_Sequence[41], _aL_, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    var order = opt ? opt[1] : 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      _aE_ = Base_Import[125],
      t$4 =
        caml_call3
         (Base_Option[32],
          less_or_equal_to,
          t$3,
          function(_aI_, _aJ_){return inclusive_bound(_aE_, _aI_, _aJ_);}),
      next =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[3], t = enum$0[2], k = enum$0[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t === "number"){var init = e; break;}
       if(0 === t[0]){
        var v = t[1], t$0 = [1, 0, v, 0, 1, 1];
        t = t$0;
       }
       else{
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key)){
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e];
         t = l;
         e = e$0;
        }
        else
         t = r;
       }
      }
     }
     else
      var init = of_set(t$4);
     return caml_call2(Base_Sequence[41], init, next);
    }
    var
     _aF_ = Base_Import[127],
     t$5 =
       caml_call3
        (Base_Option[32],
         greater_or_equal_to,
         t$3,
         function(_aG_, _aH_){return inclusive_bound(_aF_, _aG_, _aH_);});
    function next$0(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[3], t = enum$0[2], k = enum$0[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 === "number"){var init$0 = e$1; break;}
      if(0 === t$1[0]){
       var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1];
       t$1 = t$2;
      }
      else{
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0))
        t$1 = l$0;
       else{
        var r$1 = t$1[3], v$4 = t$1[2], e$2 = [0, v$4, l$0, e$1];
        t$1 = r$1;
        e$1 = e$2;
       }
      }
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return caml_call2(Base_Sequence[41], init$0, next$0);
   }
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    var
     order = opt ? opt[1] : 608542111,
     _aB_ =
       608542111 <= order
        ? comparator[1]
        : caml_call1(Base_Fn[6], comparator[1]),
     _aC_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     _aD_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return caml_call3(Base_Sequence[56], _aD_, _aC_, _aB_);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(caml_call2(Base_Import[128], r1, r2)){e1 = e1$0; e2 = e2$0;}
     else{
      var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0);
      e1 = e1$1;
      e2 = e2$1;
     }
    }
   }
   function iter2(s1, s2, compare_elt, f){
    var t2$2 = of_set(s2), t1$2 = of_set(s1);
    a:
    {
     var t1 = t1$2, t2 = t2$2;
     for(;;){
      if(! t1) break;
      if(! t2) break a;
      var
       enum2 = t2[3],
       tree2 = t2[2],
       a2 = t2[1],
       enum1 = t1[3],
       tree1 = t1[2],
       a1 = t1[1],
       compare_result = caml_call2(compare_elt, a1, a2);
      if(0 === compare_result){
       caml_call1(f, [0, 737457313, [0, a1, a2]]);
       var t2$0 = cons(tree2, enum2), t1$0 = cons(tree1, enum1);
       t1 = t1$0;
       t2 = t2$0;
      }
      else if(0 <= compare_result){
       caml_call1(f, [0, -57574468, a2]);
       var t2$1 = cons(tree2, enum2);
       t2 = t2$1;
      }
      else{
       caml_call1(f, [0, 847852583, a1]);
       var t1$1 = cons(tree1, enum1);
       t1 = t1$1;
      }
     }
     return t2
             ? iter(function(a){return caml_call1(f, [0, -57574468, a]);}, t2)
             : 0;
    }
    return iter(function(a){return caml_call1(f, [0, 847852583, a]);}, t1);
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(typeof s1$0 === "number") return 1;
      if(1 === s1$0[0]){
       var r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2$0[3],
         v2$0 = s2$0[2],
         l2 = s2$0[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var _az_ = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! _az_) return _az_;
          s1$0 = l1;
          continue;
         }
         var _aA_ = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! _aA_) return _aA_;
         s1$0 = r1;
         continue;
        }
        var _aw_ = caml_call2(Base_Import[128], s1$0, s2$0);
        if(_aw_)
         var _ax_ = _aw_;
        else{
         var _ay_ = is_subset(l1, l2);
         if(_ay_){s1$0 = r1; s2$0 = r2; continue;}
         var _ax_ = _ay_;
        }
        return _ax_;
       }
      }
      if(typeof s2$0 === "number") return 0;
      var v1 = s1$0[1];
      return mem(s2$0, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1, s2, compare_elt){
    var s1$0 = s1, s2$0 = s2;
    for(;;){
     if(typeof s1$0 !== "number" && typeof s2$0 !== "number"){
      a:
      {
       if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
        if(typeof s2$0 !== "number" && 0 !== s2$0[0]){
         var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
         if(caml_call2(Base_Import[128], s1$0, s2$0)) return 0;
         var _au_ = split(s2$0, v1, compare_elt), l2 = _au_[1];
         if(_au_[2]) return 0;
         var r2 = _au_[3], _av_ = are_disjoint(l1, l2, compare_elt);
         if(! _av_) return _av_;
         s1$0 = r1;
         s2$0 = r2;
         continue;
        }
        var other_set = s1$0, elt = s2$0[1];
        break a;
       }
       var other_set = s2$0, elt = s1$0[1];
      }
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter$0(t, f){
    function iter(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){var v = param$0[1]; return caml_call1(f, v);}
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      iter(l);
      caml_call1(f, v$0);
      param$0 = r;
     }
    }
    return iter(t);
   }
   function fold(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, accu$0, v);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, fold(l, accu$0, f), v$0);
     s$0 = r;
     accu$0 = accu$1;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function fold_right(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, v, accu$0);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, v$0, fold_right(r, accu$0, f));
     s$0 = l;
     accu$0 = accu$1;
    }
   }
   function for_all(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _ar_ = caml_call1(p, v$0);
     if(_ar_){
      var _as_ = for_all(l, p);
      if(_as_){t$0 = r; continue;}
      var _at_ = _as_;
     }
     else
      var _at_ = _ar_;
     return _at_;
    }
   }
   function exists(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _ao_ = caml_call1(p, v$0);
     if(_ao_)
      var _ap_ = _ao_;
     else{
      var _aq_ = exists(l, p);
      if(! _aq_){t$0 = r; continue;}
      var _ap_ = _aq_;
     }
     return _ap_;
    }
   }
   function filter(s, p){
    function filt(t){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(p, v) ? t : 0;}
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      l$0 = filt(l),
      keep_v = caml_call1(p, v$0),
      r$0 = filt(r);
     if
      (keep_v
       &&
        caml_call2(Base_Import[128], l, l$0)
        && caml_call2(Base_Import[128], r, r$0))
      return t;
     return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
    }
    return filt(s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1], match = caml_call1(p, v);
       if(! match) return accu$0;
       var v$0 = match[1];
       return add(accu$0, v$0, compare_elt);
      }
      var
       r = param$0[3],
       v$1 = param$0[2],
       l = param$0[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], _an_ = add(accu$0, v$2, compare_elt);
      else
       var _an_ = accu$0;
      var accu$1 = filt(_an_, l);
      accu$0 = accu$1;
      param$0 = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p){
    function loop(t){
     if(typeof t === "number") return _p_;
     if(0 === t[0]){
      var v = t[1];
      return caml_call1(p, v) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l),
      l_f = match[2],
      l_t = match[1],
      keep_v_t = caml_call1(p, v$0),
      match$0 = loop(r),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(keep_v, l$0, r$0){
      if
       (keep_v
        &&
         caml_call2(Base_Import[128], l, l$0)
         && caml_call2(Base_Import[128], r, r$0))
       return t;
      return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
     }
     var _am_ = mk(1 - keep_v_t, l_f, r_f);
     return [0, mk(keep_v_t, l_t, r_t), _am_];
    }
    return loop(s);
   }
   function elements_aux(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return accu$0;
     if(0 === param$0[0]){var v = param$0[1]; return [0, v, accu$0];}
     var
      r = param$0[3],
      v$0 = param$0[2],
      l = param$0[1],
      accu$1 = [0, v$0, elements_aux(accu$0, r)];
     accu$0 = accu$1;
     param$0 = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var
    not_found = [0, Base_Import[267], [0, "Set.choose_exn: empty set"]],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    _q_ = [0, cst_src_set_ml, 1128, 8],
    _r_ = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ";
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    return caml_call3
            (Base_List[20],
             lst,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_sequence(sequence, compare_elt){
    return caml_call3
            (Base_Sequence[8],
             sequence,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_array(a, compare_elt){
    return caml_call3
            (Base_Array[20],
             a,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = caml_call2(Base_Array[47], s, v$0),
     pos_ref = [0, 0];
    function loop(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return;
      if(0 === param$0[0]){
       var v = param$0[1], _ak_ = pos_ref[1];
       caml_check_bound(res, _ak_)[1 + _ak_] = v;
       pos_ref[1]++;
       return;
      }
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      loop(l);
      var _al_ = pos_ref[1];
      caml_check_bound(res, _al_)[1 + _al_] = v$0;
      pos_ref[1]++;
      param$0 = r;
     }
    }
    loop(l);
    pos_ref[1]++;
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var x = choose_exn(set$0);
     let x$0 = x;
     var
      match =
        partition_tf
         (set$0,
          function(elt){
           var _aj_ = caml_call2(Base_Import[128], x$0, elt);
           return _aj_ ? _aj_ : caml_call2(equiv, x$0, elt);
          }),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes];
     set$0 = not_equiv_x;
     equiv_classes = equiv_classes$0;
    }
   }
   function find(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     t$0 = r;
    }
   }
   function find_map(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     t$0 = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return caml_call1(Base_Import[124], cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t, i){
    var t$0 = t, i$0 = i;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return 0 === i$0 ? [0, v] : 0;}
     var s = t$0[5], r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(s <= i$0) return 0;
     var l_size = length(l), c = caml_int_compare(i$0, l_size);
     if(0 <= c){
      if(0 === c) return [0, v$0];
      var
       _ai_ = caml_call2(Base_Import[93], i$0, l_size),
       i$1 = caml_call2(Base_Import[93], _ai_, 1);
      t$0 = r;
      i$0 = i$1;
     }
     else
      t$0 = l;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return caml_call1(Base_List[61], leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt))
      xs$0 = tl;
     else{
      var
       already_seen$0 = add(already_seen, hd, compare_elt),
       leftovers$0 = [0, hd, leftovers];
      xs$0 = tl;
      leftovers = leftovers$0;
      already_seen = already_seen$0;
     }
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return caml_call2(Base_Import[157], cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = caml_call2(Base_List[52], lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     _ah_ = caml_call1(Base_List[17], lst);
    if(length(set) === _ah_) return set;
    var set$0 = [0, empty_without_value_restrictio];
    caml_call3
     (Base_List[65],
      lst,
      elt_lst,
      function(el_sexp, el){
       return mem(set$0[1], el, compare_elt)
               ? caml_call2
                 (Base_Import[157], cst_Set_t_of_sexp_duplicate_el, el_sexp)
               : (set$0[1] = add(set$0[1], el, compare_elt), 0);
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return _r_;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     _ae_ = caml_call2(Base_Import[112], cst_is_not_a_subset_of, superset[2]),
     _af_ = caml_call2(Base_Import[112], subset[2], _ae_),
     _ag_ =
       caml_call2
        (Base_Sexp[9],
         _af_,
         [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return caml_call1(Base_Or_error[35], _ag_);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function like_maybe_no_op(old_t, tree){
    var old_tree = old_t[2], comparator = old_t[1];
    return caml_call2(Base_Import[128], old_tree, tree)
            ? old_t
            : [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function invariants$0(t){
    var _ad_ = compare_elt(t);
    return invariants(t[2], _ad_);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list(t){var s = t[2]; return elements(s);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold$0, init, f, t);
   }
   function iter$1(t, f){return iter$0(t[2], f);}
   function iter2$0(a, b, f){
    var _ac_ = compare_elt(a);
    return iter2(a[2], b[2], _ac_, f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var _ab_ = compare_elt(t); return mem(t[2], a, _ab_);}
   function filter$0(t, f){return like_maybe_no_op(t, filter(t[2], f));}
   function add$0(t, a){
    var _aa_ = compare_elt(t);
    return like(t, add(t[2], a, _aa_));
   }
   function remove$0(t, a){
    var _$_ = compare_elt(t);
    return like(t, remove(t[2], a, _$_));
   }
   function union$0(t1, t2){
    var ___ = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], ___));
   }
   function inter$0(t1, t2){
    var _Z_ = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], _Z_));
   }
   function diff$0(t1, t2){
    var _Y_ = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], _Y_));
   }
   function symmetric_diff$0(t1, t2){
    var _X_ = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], _X_);
   }
   function compare_direct(t1, t2){
    var _V_ = t2[2], _W_ = t1[2];
    return compare(compare_elt(t1), _W_, _V_);
   }
   function equal$0(t1, t2){
    var _U_ = compare_elt(t1);
    return equal(t1[2], t2[2], _U_);
   }
   function is_subset$1(t, of){
    var _T_ = compare_elt(t);
    return is_subset(t[2], of[2], _T_);
   }
   function are_disjoint$0(t1, t2){
    var _S_ = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], _S_);
   }
   function to_named_tree(named){return [0, named[1][2], named[2]];}
   function is_subset$2(subset, superset){
    var
     _P_ = compare_elt(subset[1]),
     _Q_ = subset[1][1][2],
     _R_ = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), _R_, _Q_, _P_);
   }
   function equal$1(t1, t2){
    var
     _N_ = [0, is_subset$2(t2, t1), 0],
     _O_ = [0, is_subset$2(t1, t2), _N_];
    return caml_call1(Base_Or_error[47], _O_);
   }
   function partition_tf$0(t, f){
    var
     match = partition_tf(t[2], f),
     tree_f = match[2],
     tree_t = match[1],
     _M_ = like_maybe_no_op(t, tree_f);
    return [0, like_maybe_no_op(t, tree_t), _M_];
   }
   function split$0(t, a){
    var
     _K_ = compare_elt(t),
     match = split(t[2], a, _K_),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     _L_ = like(t, tree2);
    return [0, like(t, tree1), b, _L_];
   }
   function split_le_gt$0(t, a){
    var
     _I_ = compare_elt(t),
     match = split_le_gt(t[2], a, _I_),
     tree2 = match[2],
     tree1 = match[1],
     _J_ = like(t, tree2);
    return [0, like(t, tree1), _J_];
   }
   function split_lt_ge$0(t, a){
    var
     _G_ = compare_elt(t),
     match = split_lt_ge(t[2], a, _G_),
     tree2 = match[2],
     tree1 = match[1],
     _H_ = like(t, tree2);
    return [0, like(t, tree1), _H_];
   }
   function group_by$0(t, equiv){
    var _E_ = group_by(t[2], equiv);
    return caml_call2(Base_List[52], _E_, function(_F_){return like(t, _F_);});
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var _D_ = compare_elt(t);
    return like(t, remove_index(t[2], i, _D_));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], _C_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[207], state, _C_), hash_fold_elem);
   }
   function compare$0(_B_, param, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$0(t){return elements(t);}
   function to_array$1(t){return to_array(t);}
   function iter$2(t, f){return iter$0(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(t, f){return filter(t, f);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function iter2$1(comparator, a, b, f){
    return iter2(a, b, comparator[1], f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(_A_){return _A_;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(t, equiv){return group_by(t, equiv);}
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function split_le_gt$1(comparator, t, a){
    return split_le_gt(t, a, comparator[1]);
   }
   function split_lt_ge$1(comparator, t, a){
    return split_lt_ge(t, a, comparator[1]);
   }
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return caml_call4(Base_Container[8], fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     _y_ = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     _z_ = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), _y_];
    return caml_call1(Base_Or_error[47], _z_);
   }
   var Named = [0, is_subset$4, equal$3], _s_ = [0, "_"];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    var tree = t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
    return [0, comparator, tree];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    var tree = union_list(comparator, to_tree$0, l);
    return [0, comparator, tree];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    var tree = of_increasing_iterator_uncheck(len, f);
    return [0, comparator, tree];
   }
   function of_sorted_array$1(comparator, array){
    var _x_ = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[18][2],
             _x_,
             function(tree){return [0, comparator, tree];});
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   function empty$1(m){
    var comparator = m[1];
    return [0, comparator, empty_without_value_restrictio];
   }
   function singleton$1(m, a){return singleton$0(m[1], a);}
   function union_list$2(m, a){return union_list$1(m[1], a);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_list$2(m, a){return of_list$1(m[1], a);}
   function of_sequence$2(m, a){return of_sequence$1(m[1], a);}
   function of_array$2(m, a){return of_array$1(m[1], a);}
   function stable_dedup_list$2(m, a){return stable_dedup_list$1(m[1], a);}
   function map$2(m, a, f){return map$1(m[1], a, f);}
   function filter_map$2(m, a, f){return filter_map$1(m[1], a, f);}
   function of_tree$1(m, tree){
    var comparator = m[1];
    return [0, comparator, tree];
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t){
    return sexp_of_t$0(Elt[1], function(param){return _s_;}, t);
   }
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var _w_ = caml_call1(Base_Import[195], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _w_);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt, state){
    var _u_ = Elt[1];
    return function(_v_){return hash_fold_direct(_u_, state, _v_);};
   }
   function hash_m_t(folder, t){
    var state = hash_fold_m_t(folder, caml_call2(Base_Hash[11], 0, 0))(t);
    return caml_call1(Base_Hash[9], state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$2(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    _t_ = Base_Sequence[55],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$1,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       split_le_gt$0,
       split_lt_ge$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, _t_[1], _t_[3], _t_[4]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$2],
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         length$1,
         is_empty$1,
         iter$2,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$0,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         Named,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         split_le_gt$1,
         split_lt_ge$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator_s,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       to_tree$0,
       of_tree$1];
   runtime.caml_register_global(48, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare = Base_Import[238],
    equal = Base_Import[251],
    globalize = Base_Import[266],
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[192], a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    return caml_call2
            (Base_Exn[13], f, function(param){t[1] = restore_to; return 0;});
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return caml_call2(Base_List[19], ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = caml_call2(Base_List[52], and_values, snapshot);
    sets(and_values);
    return caml_call2
            (Base_Exn[13], f, function(param){return sets(restore_to);});
   }
   var
    Base_Ref =
      [0,
       compare,
       equal,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    _a_ = [0, "elts"],
    _b_ = [0, cst_length$2],
    _c_ = [0, "mask"],
    _d_ = [0, "front"],
    _e_ = [0, "num_mutations"],
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    _f_ = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    _g_ = [0, cst_src_queue_ml, 170, 9],
    _h_ = [0, cst_src_queue_ml, 164, 2],
    _i_ = [0, cst_src_queue_ml, 163, 2],
    _j_ = [0, cst_src_queue_ml, 162, 2],
    _k_ = [0, cst_src_queue_ml, 161, 2],
    _l_ = [0, cst_src_queue_ml, 160, 2],
    _m_ = [0, cst_src_queue_ml, 158, 2],
    _n_ = [0, cst_src_queue_ml, 157, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    _o_ = [0, cst_src_queue_ml, 198, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length",
    dummy = 0;
   function inc_num_mutations(t){t[1] = caml_call2(Base_Import[91], t[1], 1);}
   function capacity(t){return caml_call2(Base_Import[91], t[3], 1);}
   function elts_index(t, i){
    var _aX_ = t[3], _aY_ = caml_call2(Base_Import[91], t[2], i);
    return caml_call2(Base_Import[116], _aY_, _aX_);
   }
   function unsafe_get(t, i){
    var _aW_ = elts_index(t, i);
    return caml_call2(Base_Option_array[39], t[5], _aW_);
   }
   function unsafe_set(t, i, a){
    var _aV_ = elts_index(t, i);
    return caml_call3(Base_Option_array[50], t[5], _aV_, a);
   }
   function check_index_exn(t, i){
    var _aQ_ = i < 0 ? 1 : 0, _aR_ = _aQ_ || (t[4] <= i ? 1 : 0);
    if(! _aR_) return _aR_;
    var
     _aS_ = [0, [0, cst_length, caml_call1(Base_Int[10], t[4])], 0],
     _aT_ = [0, [0, cst_index, caml_call1(Base_Int[10], i)], _aS_],
     _aU_ = caml_call2(Base_Sexp[9], cst_Queue_index_out_of_bounds, _aT_);
    return caml_call1(Base_Error[30], _aU_);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var _aO_ = t[1] !== num_mutations ? 1 : 0;
    if(! _aO_) return _aO_;
    function of_a_001(param){return _f_;}
    var
     num_mutations_003 = t[1],
     front_005 = t[2],
     mask_007 = t[3],
     length_009 = t[4],
     elts_011 = t[5],
     arg_012 = caml_call2(Base_Option_array[2], of_a_001, elts_011),
     bnds_002 = [0, [1, [0, _a_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[140], length_009),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(Base_Import[140], mask_007),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Base_Import[140], front_005),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call1(Base_Import[140], num_mutations_003),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$2],
     _aP_ =
       caml_call2
        (Base_Sexp[9],
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], 0]);
    return caml_call1(Base_Error[30], _aP_);
   }
   function compare(compare_elt, t1, t2){
    if(caml_call2(Base_Import[128], t1, t2)) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      _aN_ = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), _aN_);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = caml_call2(Base_Import[91], pos, 1);
     pos = pos$0;
    }
   }
   function equal(equal_elt, t1, t2){
    var _aK_ = caml_call2(Base_Import[128], t1, t2);
    if(_aK_)
     var _aL_ = _aK_;
    else{
     var len1 = t1[4], len2 = t2[4], _aM_ = len1 === len2 ? 1 : 0;
     if(_aM_){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var _aH_ = pos === len1 ? 1 : 0;
       if(_aH_)
        var _aI_ = _aH_;
       else{
        var
         _aJ_ = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), _aJ_);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = caml_call2(Base_Import[91], pos, 1);
         pos = pos$0;
         continue;
        }
        var _aI_ = b;
       }
       return _aI_;
      }
     }
     var _aL_ = _aM_;
    }
    return _aL_;
   }
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== caml_call1(Base_Option_array[28], elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(! caml_call1(Base_Int[69], capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _aF_ = caml_call2(Base_Import[93], capacity$0, 1), _aE_ = 0;
    if(_aF_ >= 0){
     var i = _aE_;
     for(;;){
      if(i < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var _aD_ = elts_index(t, i);
       if(caml_call2(Base_Option_array[41], t[5], _aD_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      var _aG_ = i + 1 | 0;
      if(_aF_ === i) break;
      i = _aG_;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var _az_ = 0 === capacity$0 ? 1 : caml_call1(Base_Int[65], capacity$0);
     else
      var
       _aB_ = [0, [0, cst_capacity, caml_call1(Base_Int[10], capacity$0)], 0],
       _aC_ = caml_call2(Base_Sexp[9], cst_cannot_have_queue_with_neg, _aB_),
       _az_ = caml_call1(Base_Error[30], _aC_);
     var capacity$1 = _az_;
    }
    else
     var capacity$1 = 2;
    var _aA_ = caml_call1(Base_Option_array[5], capacity$1);
    return [0, 0, 0, caml_call2(Base_Import[93], capacity$1, 1), 0, _aA_];
   }
   function blit_to_array(src, dst){
    var _av_ = caml_call1(Base_Option_array[28], dst);
    if(src[4] > _av_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var
     _aw_ = src[2],
     _ax_ = capacity(src),
     _ay_ = caml_call2(Base_Import[93], _ax_, _aw_),
     front_len = caml_call2(Base_Int[15], src[4], _ay_),
     rest_len = caml_call2(Base_Import[93], src[4], front_len);
    caml_call5(Base_Option_array[52], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[52], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity_internal(t, new_capacity){
    var dst = caml_call1(Base_Option_array[5], new_capacity);
    blit_to_array(t, dst);
    t[2] = 0;
    t[3] = caml_call2(Base_Import[93], new_capacity, 1);
    t[5] = dst;
    return 0;
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     _as_ = caml_call2(Base_Import[100], desired_capacity, t[4]),
     _at_ = caml_call2(Base_Import[100], 1, _as_),
     new_capacity = caml_call1(Base_Int[65], _at_),
     _au_ = new_capacity !== capacity(t) ? 1 : 0;
    return _au_ ? set_capacity_internal(t, new_capacity) : _au_;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var _ar_ = capacity(t);
    if(t[4] === _ar_)
     set_capacity_internal(t, caml_call2(Base_Import[88], 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = caml_call2(Base_Import[91], t[4], 1);
    return 0;
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = caml_call2(Base_Option_array[35], elts, front);
    caml_call2(Base_Option_array[44], elts, front);
    t[2] = elts_index(t, 1);
    t[4] = caml_call2(Base_Import[93], t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function dequeue_and_ignore_exn(t){dequeue_exn(t); return 0;}
   function front_nonempty(t){
    return caml_call2(Base_Option_array[39], t[5], t[2]);
   }
   function last_nonempty(t){
    return unsafe_get(t, caml_call2(Base_Import[93], t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function clear(t){
    inc_num_mutations(t);
    var _am_ = 0 < t[4] ? 1 : 0;
    if(_am_){
     var _ao_ = caml_call2(Base_Import[93], t[4], 1), _an_ = 0;
     if(_ao_ >= 0){
      var i = _an_;
      for(;;){
       var _al_ = elts_index(t, i);
       caml_call2(Base_Option_array[51], t[5], _al_);
       var _aq_ = i + 1 | 0;
       if(_ao_ === i) break;
       i = _aq_;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var _ap_ = 0;
    }
    else
     var _ap_ = _am_;
    return _ap_;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       _X_ = [0, [0, cst_length$0, caml_call1(Base_Int[10], len$0)], 0],
       _Y_ = caml_call2(Base_Sexp[9], cst_Queue_blit_transfer_negati, _X_);
      caml_call1(Base_Error[30], _Y_);
     }
     var len$1 = caml_call2(Base_Import[101], len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var _Z_ = 0 < len$1 ? 1 : 0;
    if(_Z_){
     var
      ___ = caml_call2(Base_Import[91], dst[4], len$1),
      _$_ = capacity(dst);
     set_capacity(dst, caml_call2(Base_Import[100], _$_, ___));
     var
      dst_start = caml_call2(Base_Import[91], dst[2], dst[4]),
      _ab_ = caml_call2(Base_Import[93], len$1, 1),
      _aa_ = 0;
     if(_ab_ >= 0){
      var i = _aa_;
      for(;;){
       var
        _af_ = src[3],
        _ag_ = caml_call2(Base_Import[91], src[2], i),
        src_i = caml_call2(Base_Import[116], _ag_, _af_),
        _ah_ = dst[3],
        _ai_ = caml_call2(Base_Import[91], dst_start, i),
        dst_i = caml_call2(Base_Import[116], _ai_, _ah_),
        _aj_ = caml_call2(Base_Option_array[39], src[5], src_i);
       caml_call3(Base_Option_array[50], dst[5], dst_i, _aj_);
       caml_call2(Base_Option_array[51], src[5], src_i);
       var _ak_ = i + 1 | 0;
       if(_ab_ === i) break;
       i = _ak_;
      }
     }
     dst[4] = caml_call2(Base_Import[91], dst[4], len$1);
     var _ac_ = src[3], _ad_ = caml_call2(Base_Import[91], src[2], len$1);
     src[2] = caml_call2(Base_Import[116], _ad_, _ac_);
     src[4] = caml_call2(Base_Import[93], src[4], len$1);
     var _ae_ = 0;
    }
    else
     var _ae_ = _Z_;
    return _ae_;
   }
   function enqueue_all(t, l){
    var
     _U_ = caml_call1(Base_List[17], l),
     _V_ = caml_call2(Base_Import[91], t[4], _U_),
     _W_ = capacity(t);
    set_capacity(t, caml_call2(Base_Int[16], _W_, _V_));
    return caml_call2(Base_List[19], l, function(x){return enqueue(t, x);});
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     _R_ = caml_call2(Base_Import[93], t[4], 1),
     _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      var _S_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _S_);
      ensure_no_mutation(t, num_mutations);
      var _T_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _T_;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var
     num_mutations = t[1],
     _O_ = caml_call2(Base_Import[93], t[4], 1),
     _N_ = 0;
    if(_O_ >= 0){
     var i = _N_;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _P_ = i + 1 | 0;
      if(_O_ === i) break;
      i = _P_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var
     num_mutations = t[1],
     _L_ = caml_call2(Base_Import[93], t[4], 1),
     _K_ = 0;
    if(_L_ >= 0){
     var i = _K_;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _M_ = i + 1 | 0;
      if(_L_ === i) break;
      i = _M_;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], _H_ = caml_call2(Base_Import[93], t[4], 1);
    if(_H_ >= 0){
     var i = _H_;
     for(;;){
      var _I_ = result[1];
      result[1] = [0, unsafe_get(t, i), _I_];
      var _J_ = i - 1 | 0;
      if(0 === i) break;
      i = _J_;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21],
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    _p_ = [0, cst_src_queue_ml, 459, 2],
    _q_ = [0, 1];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _G_ = caml_call1(f, a);
       return caml_call2
               (Base_List[19], _G_, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _F_ = caml_call2(f, i, a);
       return caml_call2
               (Base_List[19], _F_, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _E_ = caml_call1(f, a);
       return _E_ ? enqueue(t_result, a) : _E_;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _D_ = caml_call2(f, i, a);
       return _D_ ? enqueue(t_result, a) : _D_;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, caml_call1(Base_List[17], l)], 0);
    caml_call2(Base_List[19], l, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      _x_ = [0, [0, cst_length$1, caml_call1(Base_Int[10], len)], 0],
      _y_ = caml_call2(Base_Sexp[9], cst_Queue_init_negative_length, _x_);
     caml_call1(Base_Error[30], _y_);
    }
    var t = create([0, len], 0);
    if(len > caml_call1(Base_Option_array[28], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _A_ = caml_call2(Base_Import[93], len, 1), _z_ = 0;
    if(_A_ >= 0){
     var i = _z_;
     for(;;){
      var _B_ = caml_call1(f, i);
      caml_call3(Base_Option_array[50], t[5], i, _B_);
      var _C_ = i + 1 | 0;
      if(_A_ === i) break;
      i = _C_;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(_w_){return a[1 + _w_];});
   }
   function to_array(t){
    return caml_call2
            (Base_Array[40], t[4], function(i){return unsafe_get(t, i);});
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var _u_ = caml_call2(Base_Import[93], ta[4], 1), _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      caml_call3(Base_Option_array[50], tb[5], i, b);
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(_q_, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var _s_ = to_list(t);
    return caml_call1(caml_call1(Base_List[5], sexp_of_a), _s_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[4], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _r_ = caml_call1(Base_List[6], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _r_);
   }
   var
    Base_Queue =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       invariant,
       create,
       last,
       last_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity];
   runtime.caml_register_global(39, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    _a_ = [0, "src/nothing.ml", 6, 25];
   function unreachable_code(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, _a_], 1);
   }
   var
    cst_Base_Nothing_t = "Base.Nothing.t",
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported";
   function hash_fold_t(param, t){return unreachable_code(t);}
   function compare(a, param){return unreachable_code(a);}
   function t_of_sexp(sexp){
    return caml_call2(Sexplib0_Sexp_conv_error[26], cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return caml_call1(Base_Import[124], cst_Base_Nothing_of_string_not);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24],
    Base_Nothing =
      [0,
       0,
       t_sexp_grammar,
       unreachable_code,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    include = Base_Import[104],
    compare = include[9],
    globalize = Base_Import[258],
    hash_fold_t = Base_Import[203],
    func = Base_Import[217];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[190],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[104][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Nativeint[14],
    comparator = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    _a_ = caml_call1(Base_Comparable[14], [0, compare$0, sexp_of_t, zero]),
    is_positive = _a_[1],
    is_non_negative = _a_[2],
    is_negative = _a_[3],
    is_non_positive = _a_[4],
    sign = _a_[5],
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare$1 = Base_Import[232],
    hash_fold_t$0 = Base_Import[203],
    func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(_Q_){return - _Q_ | 0;}
   var
    symbol = Base_Import[104][1],
    _b_ = [0, [6, 6, 0, 0, 0], cst_nx],
    _c_ = [0, [6, 6, 0, 0, 0], cst_nx];
   function to_string$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[5], s, _c_, function(_P_){return _P_;});
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$1,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits);
   function shift_right_logical(_O_, _N_){return _O_ >>> _N_ | 0;}
   function shift_right(_M_, _L_){return _M_ >> _L_;}
   function shift_left(_K_, _J_){return _K_ << _J_;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(_I_, _H_){return _I_ ^ _H_;}
   function bit_or(_G_, _F_){return _G_ | _F_;}
   function bit_and(_E_, _D_){return _E_ & _D_;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(_C_){return - _C_ | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1],
    _d_ =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"];
   function to_float(_B_){return _B_;}
   function of_float_unchecked(_A_){return _A_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return f | 0;
    var _z_ = caml_call1(Base_Float0[28], f);
    return caml_call3(Base_Printf[7], _d_, _z_, 0);
   }
   var
    raise_s = Base_Error[30],
    _e_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    _f_ = [0, "src/nativeint.ml", 207, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _e_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Nativeint[7], x),
     x$6 = x$0 | x$0 >>> 1 | 0,
     x$5 = x$6 | x$6 >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return caml_call1(Stdlib_Nativeint[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_call2(Base_Import[104][2], x$0, 0)) non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$5 = x | x >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var _y_ = x & caml_call1(Stdlib_Nativeint[7], x);
    return caml_call2(Base_Import[104][4], _y_, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _v_ = [0, [0, cst, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_floor_log2_got_i, _v_));
    }
    var
     _w_ = runtime.Base_int_math_nativeint_clz(i),
     _x_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _x_, _w_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _t_ = [0, [0, cst$0, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_ceil_log2_got_in, _t_));
    }
    if(caml_call2(Stdlib_Nativeint[18], i, Stdlib_Nativeint[2])) return 0;
    var
     _u_ =
       runtime.Base_int_math_nativeint_clz(caml_call1(Stdlib_Nativeint[7], i));
    return caml_call2(Base_Import[93], num_bits, _u_);
   }
   function between(t, low, high){
    var _s_ = caml_call2(Base_Import[104][2], low, t);
    return _s_ ? caml_call2(Base_Import[104][2], t, high) : _s_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[104][1], t, min)
            ? min
            : caml_call2(Base_Import[104][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[104][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[104][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _p_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _q_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _p_],
     _r_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _q_);
    return caml_call1(Base_Or_error[35], _r_);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(_o_, _n_){return _o_ - _n_ | 0;}
   function symbol$4(_m_, _l_){return _m_ + _l_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[22],
    to_int_exn = Base_Int_conversions[23],
    to_int_trunc = Base_Int_conversions[24],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[25],
    to_int32_exn = Base_Int_conversions[26],
    to_int32_trunc = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[17],
    of_int64_exn = Base_Int_conversions[18],
    of_int64_trunc = Base_Int_conversions[19],
    to_int64 = Base_Int_conversions[28];
   function pow(b, e){
    var _j_ = caml_call1(to_int_exn, e), _k_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _k_, _j_));
   }
   function symbol$5(b, e){return pow(b, e);}
   var
    _g_ = Base_Import[104],
    symbol$6 = _g_[3],
    symbol$7 = _g_[1],
    symbol$8 = _g_[5],
    symbol$9 = _g_[4],
    symbol$10 = _g_[2],
    symbol$11 = _g_[6],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[104],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$2 = include$4[9],
    equal = include$4[10],
    max = include$4[11],
    min = include$4[12],
    Base_Nativeint =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       of_string_opt,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_i_){return runtime.Base_int_math_nativeint_clz(_i_);},
       function(_h_){return runtime.Base_int_math_nativeint_ctz(_h_);},
       [0,
        symbol$4,
        symbol$3,
        symbol$2,
        symbol$1,
        symbol$0,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$0,
        zero$1,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       to_int32_trunc,
       of_int64_trunc,
       runtime.caml_int32_bswap];
   runtime.caml_register_global(34, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    empty = [0, 0],
    name = "alist",
    name$0 = "sequence",
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4];
   function of_continue_or_stop(_cR_){return _cR_;}
   function to_continue_or_stop(_cQ_){return _cQ_;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var _cP_ = param[1];
    if(737457313 === _cP_)
     var left = param[2][1];
    else{if(847852583 > _cP_) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var _cO_ = param[1];
    if(737457313 === _cO_)
     var right = param[2][2];
    else{if(847852583 <= _cO_) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$0){
    var _cN_ = t[1];
    if(737457313 === _cN_)
     var left = t[2][1];
    else{if(847852583 > _cN_) return default$0; var left = t[2];}
    return left;
   }
   function right_value(t, default$0){
    var _cM_ = t[1];
    if(737457313 === _cM_)
     var right = t[2][2];
    else{if(847852583 <= _cM_) return default$0; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var _cL_ = t[1];
    if(737457313 === _cL_){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= _cL_){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, "Base__Map.Duplicate", caml_fresh_oo_id(0)],
    _a_ = [0, "map.ml.Duplicate"],
    _b_ = [0, cst_src_map_ml, 67, 11];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Duplicate,
     function(param){
      if(param === Duplicate) return _a_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     });
   var
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_Map_bal = cst_Map_bal$3,
    _c_ = [0, cst_src_map_ml, 224, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    _d_ = [0, cst_src_map_ml, 238, 18],
    cst_Map_bal$2 = cst_Map_bal$3;
   function globalize(param){
    var length = param[2], tree = param[1];
    return [0, tree, length];
   }
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      _cJ_ = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var _cJ_ = 1;
    if(_cJ_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var _cK_ = 1;
    }
    else
     var _cK_ = _cJ_;
    return _cK_;
   }
   function loop(lower, upper, compare_key, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var k = t$0[1];
      return in_range(lower$0, upper, compare_key, k);
     }
     var
      h = t$0[5],
      r = t$0[4],
      k$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _cC_ = caml_call2(Base_Import[93], hl, hr),
      _cD_ = caml_call1(Base_Import[123], _cC_) <= 2 ? 1 : 0;
     if(_cD_){
      var
       _cE_ = caml_call2(Base_Import[100], hl, hr),
       _cF_ = h === caml_call2(Base_Import[91], _cE_, 1) ? 1 : 0;
      if(_cF_){
       var _cG_ = in_range(lower$0, upper, compare_key, k$0);
       if(_cG_){
        var _cH_ = loop(lower$0, [0, k$0], compare_key, l);
        if(_cH_){
         var lower$1 = [0, k$0];
         lower$0 = lower$1;
         t$0 = r;
         continue;
        }
        var _cI_ = _cH_;
       }
       else
        var _cI_ = _cG_;
      }
      else
       var _cI_ = _cF_;
     }
     else
      var _cI_ = _cD_;
     return _cI_;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     _cB_ =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    return [1, l, x, d, r, _cB_];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, caml_call2(Base_Import[91], i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _cz_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _cz_, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      v = match[2],
      k = match[1],
      _cA_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _cA_, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var
       k0 = caml_check_bound(array, 0)[1][1],
       k1 = caml_check_bound(array, 1)[2][1];
      if(caml_call2(compare_key, k0, k1) >= 0){
       var
        next =
          function(i){
           var
            _cx_ = caml_call2(Base_Import[93], array_length, 1),
            _cy_ = caml_call2(Base_Import[93], _cx_, i);
           return caml_check_bound(array, _cy_)[1 + _cy_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    var tree = of_increasing_iterator_uncheck(array_length, next);
    return [0, tree, array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _cn_ = caml_check_bound(array, 1)[2],
                _co_ = caml_call1(Base_Import[125], _cn_),
                _cp_ = caml_check_bound(array, 0)[1],
                i =
                  caml_call2
                   (compare_key, caml_call1(Base_Import[125], _cp_), _co_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _cr_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _cq_ = 1;
               if(_cr_ >= 1){
                var i$0 = _cq_;
                for(;;){
                 var
                  _cs_ = caml_call2(Base_Import[91], i$0, 1),
                  _ct_ = caml_check_bound(array, _cs_)[1 + _cs_],
                  _cu_ = caml_call1(Base_Import[125], _ct_),
                  _cv_ = caml_check_bound(array, i$0)[1 + i$0],
                  i$1 =
                    caml_call2
                     (compare_key, caml_call1(Base_Import[125], _cv_), _cu_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _cw_ = i$0 + 1 | 0;
                 if(_cr_ === i$0) break;
                 i$0 = _cw_;
                }
               }
               return [0,
                       globalize(of_sorted_array_unchecked(array, compare_key))];
              });
    return [0, globalize(of_sorted_array_unchecked(array, compare_key))];
   }
   function bal(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      return caml_call1(Base_Import[126], cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _ch_ = height(lr);
     if(_ch_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
     if(typeof lr === "number")
      return caml_call1(Base_Import[126], cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], _ci_ = create(0, x, d, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, _ci_);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      _cj_ = create(lrr, x, d, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, _cj_);
    }
    if(caml_call2(Base_Import[91], hl, 2) >= hr) return create(l, x, d, r);
    if(typeof r === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _ck_ = height(rl);
    if(_ck_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
    if(typeof rl === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], _cl_ = create(0, rv, rd, rr);
     return create(create(l, x, d, 0), rlv, rld, _cl_);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     _cm_ = create(rlr, rv, rd, rr);
    return create(create(l, x, d, rll), rlv$0, rld$0, _cm_);
   }
   var
    empty_without_value_restrictio = 0,
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    _e_ = [1, 0],
    cst_Map_singleton_to_tree_exn_ =
      "Map.singleton_to_tree_exn: not a singleton",
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    _f_ = [0, 0, 0, 0],
    _g_ = [0, cst_src_map_ml, 525, 4],
    _h_ = [0, "Map.find_exn: not found"];
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     _cf_ = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     _cg_ = caml_call2(Base_Sexp[9], cst_Map_add_exn_got_key_alread, _cf_);
    return caml_call1(Base_Error[30], _cg_);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number"){
     var
      length$0 = caml_call2(Base_Import[91], length, 1),
      tree = [0, x, data];
     return [0, tree, length$0];
    }
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return caml_call1(Base_Exn[6], Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: var tree$0 = [0, x, data]; return [0, tree$0, length];
      }
     if(0 <= c){
      var
       length$1 = caml_call2(Base_Import[91], length, 1),
       tree$1 = [1, 0, v, d, [0, x, data], 2];
      return [0, tree$1, length$1];
     }
     var
      length$2 = caml_call2(Base_Import[91], length, 1),
      tree$2 = [1, [0, x, data], v, d, 0, 2];
     return [0, tree$2, length$2];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return caml_call1(Base_Exn[6], Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default:
        var tree$3 = [1, l, x, data, r, h]; return [0, tree$3, length];
     }
    if(0 <= c$0){
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$3 = match[2],
      r$0 = match[1],
      tree$4 = bal(l, v$0, d$0, r$0);
     return [0, tree$4, length$3];
    }
    var
     match$0 =
       find_and_add_or_set
        (l, length, x, data, compare_key, sexp_of_key, add_or_set),
     length$4 = match$0[2],
     l$0 = match$0[1],
     tree$5 = bal(l$0, v$0, d$0, r);
    return [0, tree$5, length$4];
   }
   function set_min(key, data, t){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, [0, key, data], v, d, 0, 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = set_min(key, data, l);
    return bal(l$0, v$0, d$0, r);
   }
   function set_max(t, key, data){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, 0, v, d, [0, key, data], 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     r$0 = set_max(r, key, data);
    return bal(l, v$0, d$0, r$0);
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    return find_and_add_or_set
            (t,
             length,
             key,
             data,
             compare_key,
             function(param){return _e_;},
             2);
   }
   function singleton_to_tree_exn(param){
    if(typeof param[1] !== "number")
     return caml_call1(Base_Import[124], cst_Map_singleton_to_tree_exn_);
    var data = param[3], key = param[2];
    return [0, key, data];
   }
   function collapse(l, r){return create(l[1], l[2], l[3], r);}
   function join(l, r){
    var _cd_ = r[3], _ce_ = r[2];
    return [0, collapse(l, r[1]), _ce_, _cd_];
   }
   function go(t, x){
    switch(t[0]){
      case 0:
       return [1, t, x];
      case 1:
       var y = t[2], t$0 = t[1]; return [2, t$0, y, x];
      default:
       var y$0 = t[3], z = t[2], t$1 = t[1];
       return [1, go(t$1, join(z, y$0)), x];
    }
   }
   function add_unchecked(t, key, data){return go(t, [0, 0, key, data]);}
   function go$0(t, r){
    var t$0 = t, r$0 = r;
    for(;;)
     switch(t$0[0]){
       case 0:
        return r$0;
       case 1:
        var l = t$0[2], t$1 = t$0[1], r$1 = collapse(l, r$0);
        t$0 = t$1;
        r$0 = r$1;
        break;
       default:
        var
         l$0 = t$0[3],
         ll = t$0[2],
         t$2 = t$0[1],
         r$2 = collapse(join(ll, l$0), r$0);
        t$0 = t$2;
        r$0 = r$2;
     }
   }
   function to_tree_unchecked(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2], t = param[1];
       return go$0(t, singleton_to_tree_exn(r));
      default:
       var r$0 = param[3], l = param[2], t$0 = param[1];
       return go$0([1, t$0, l], singleton_to_tree_exn(r$0));
    }
   }
   function max_key(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2]; break;
      default: var r = param[3];
    }
    return [0, r[2]];
   }
   function of_increasing_sequence(seq, compare_key){
    return caml_call1
            (with_return,
             function(param){
              var
               match =
                 caml_call3
                  (Base_Sequence[8],
                   seq,
                   [0, empty, 0],
                   function(_cc_, param$0){
                    var
                     data = param$0[2],
                     key = param$0[1],
                     length = _cc_[2],
                     builder = _cc_[1],
                     match = max_key(builder);
                    if(match){
                     var prev_key = match[1];
                     if(0 <= caml_call2(compare_key, prev_key, key))
                      return caml_call1
                              (param,
                               caml_call1
                                (Base_Or_error[36], cst_of_increasing_sequence_non));
                    }
                    var
                     length$0 = caml_call2(Base_Import[91], length, 1),
                     tree = add_unchecked(builder, key, data);
                    return [0, tree, length$0];
                   }),
               length = match[2],
               builder = match[1],
               tree = to_tree_unchecked(builder);
              return [0, [0, tree, length]];
             });
   }
   function join$0(l, k, d, r){
    if(typeof l === "number") return set_min(k, d, r);
    if(1 === l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set_max(set_max(l, k, d), rk, rd);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[91], rh, 3) < lh
              ? bal(ll, lk$0, ld$0, join$0(lr, k, d, r))
              : caml_call2
                 (Base_Import[91], lh, 3)
                < rh
                ? bal(join$0(l, k, d, rl), rk$0, rd$0, rr)
                : bal(l, k, d, r);
     }
    }
    if(typeof r === "number") return set_max(l, k, d);
    var ld = l[2], lk = l[1];
    return set_min(lk, ld, set_min(k, d, r));
   }
   function split_gen(t, x, compare_key){
    if(typeof t === "number") return _f_;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call1(compare_key, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call1(compare_key, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split_gen(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join$0(l, k$0, d$0, rl), maybe, rr];
    }
    var
     match$0 = split_gen(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join$0(lr, k$0, d$0, r)];
   }
   function split(t, x, compare_key){
    return split_gen(t, x, function(y){return caml_call2(compare_key, x, y);});
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     _cb_ =
       847852583 <= into
        ? function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? 1 : res;
         }
        : function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? -1 : res;
         },
     match = split_gen(t, x, _cb_),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(caml_call1(Base_Option[50], boundary_opt)) return [0, left, right];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if(caml_call3(Base_Maybe_bound[9], lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      _b$_ = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = _b$_[2],
      left = _b$_[1];
    else
     var
      lb$2 = lower_bound[1],
      _ca_ = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = _ca_[2],
      left$0 = _ca_[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      _b9_ =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = _b9_[2],
      mid = _b9_[1];
    else
     var
      lb$0 = upper_bound[1],
      _b__ =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = _b__[2],
      mid$0 = _b__[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t, x, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     var r$0 = 0 <= c ? r : l;
     t$0 = r$0;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     _b8_ = find(t, key, compare_key),
     data$0 = [0, data, caml_call2(Base_Option[28], _b8_, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var _b7_ = [1, [0, _h_, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[267], _b7_], 1);
   }
   function find_exn(t, x, compare_key, sexp_of_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return if_not_found(x, sexp_of_key);
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     var r$0 = 0 <= c ? r : l;
     t$0 = r$0;
    }
   }
   function mem(t, x, compare_key){
    var _b6_ = find(t, x, compare_key);
    return caml_call1(Base_Option[51], _b6_);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     var l = param$0[1];
     if(typeof l === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     param$0 = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    _i_ = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    _j_ = [0, cst_src_map_ml, 610, 15];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Map_min_elt_exn_of_empty_map,
     function(param){
      if(param === Map_min_elt_exn_of_empty_map) return _i_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     });
   var
    Map_max_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_max_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    _k_ = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    _l_ = [0, cst_src_map_ml, 623, 15];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Map_max_elt_exn_of_empty_map,
     function(param){
      if(param === Map_max_elt_exn_of_empty_map) return _k_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     });
   var cst_Map_remove_min_elt = "Map.remove_min_elt";
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     if(typeof param$0[4] === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param$0[4];
     param$0 = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return caml_call1(Base_Import[126], cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var
     _b5_ = match$0[1],
     v = _b5_[2],
     min_upper = _b5_[1],
     max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0,
            17724,
            join$0(lower_part, min_upper, v, upper_part_without_min)];
   }
   function go$1(t, min, max, init, f, compare_key){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 === t$0[0]){
      var d = t$0[2], k = t$0[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init$0);
      return init$0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      k$0 = t$0[2],
      l = t$0[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 <= c_min)
      if(0 === c_min){
       var init$1 = caml_call3(f, k$0, d$0, init$0);
       t$0 = r;
       init$0 = init$1;
      }
      else{
       var
        z = go$1(l, min, max, init$0, f, compare_key),
        c_max = caml_call2(compare_key, k$0, max);
       if(0 < c_max) return z;
       var init$2 = caml_call3(f, k$0, d$0, z);
       if(0 === c_max) return init$2;
       t$0 = r;
       init$0 = init$2;
      }
     else
      t$0 = r;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go$1(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     _b4_ =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return caml_call1(Base_List0[21], _b4_);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   function concat_and_balance_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return join$0(t1, x, d, remove_min_elt(t2));
   }
   var
    Remove_no_op = [248, "Base__Map.Tree0.Remove_no_op", caml_fresh_oo_id(0)];
   function remove(tree, x, length, compare_key){
    function remove_loop(t, x, length, compare_key){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Remove_no_op);
     if(0 === t[0]){
      var v = t[1];
      if(0 !== caml_call2(compare_key, x, v))
       return caml_call1(Base_Exn[6], Remove_no_op);
      var length$0 = caml_call2(Base_Import[93], length, 1);
      return [0, 0, length$0];
     }
     var
      r = t[4],
      d = t[3],
      v$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c){
      var
       length$1 = caml_call2(Base_Import[93], length, 1),
       tree = concat_unchecked(l, r);
      return [0, tree, length$1];
     }
     if(0 <= c){
      var
       match = remove_loop(r, x, length, compare_key),
       length$2 = match[2],
       r$0 = match[1],
       tree$0 = bal(l, v$0, d, r$0);
      return [0, tree$0, length$2];
     }
     var
      match$0 = remove_loop(l, x, length, compare_key),
      length$3 = match$0[2],
      l$0 = match$0[1],
      tree$1 = bal(l$0, v$0, d, r);
     return [0, tree$1, length$3];
    }
    try{var _b2_ = remove_loop(tree, x, length, compare_key); return _b2_;}
    catch(_b3_){
     var _b1_ = caml_wrap_exception(_b3_);
     if(_b1_ === Remove_no_op) return [0, tree, length];
     throw caml_maybe_attach_backtrace(_b1_, 0);
    }
   }
   var
    Change_no_op = [248, "Base__Map.Tree0.Change_no_op", caml_fresh_oo_id(0)],
    _m_ = [0, 0, 0],
    _n_ = [0, cst_src_map_ml, 1087, 17],
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1;
   function change(tree, key, f, length, compare_key){
    function change_core(t, key, f){
     if(typeof t === "number"){
      var match = caml_call1(f, 0);
      if(! match) return caml_call1(Base_Exn[6], Change_no_op);
      var
       data = match[1],
       length$0 = caml_call2(Base_Import[91], length, 1),
       tree = [0, key, data];
      return [0, tree, length$0];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var match$0 = caml_call1(f, [0, d]);
       if(match$0){
        var d$0 = match$0[1], tree$0 = [0, v, d$0];
        return [0, tree$0, length];
       }
       var length$1 = caml_call2(Base_Import[93], length, 1);
       return [0, 0, length$1];
      }
      if(0 <= c){
       var
        match$1 = change_core(0, key, f),
        length$2 = match$1[2],
        r = match$1[1],
        tree$1 = bal(0, v, d, r);
       return [0, tree$1, length$2];
      }
      var
       match$2 = change_core(0, key, f),
       length$3 = match$2[2],
       l = match$2[1],
       tree$2 = bal(l, v, d, 0);
      return [0, tree$2, length$3];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var match$3 = caml_call1(f, [0, d$1]);
      if(match$3){
       var data$0 = match$3[1], tree$3 = [1, l$0, key, data$0, r$0, h];
       return [0, tree$3, length];
      }
      var
       length$4 = caml_call2(Base_Import[93], length, 1),
       tree$4 = concat_unchecked(l$0, r$0);
      return [0, tree$4, length$4];
     }
     if(0 <= c$0){
      var
       match$4 = change_core(r$0, key, f),
       length$5 = match$4[2],
       r$1 = match$4[1],
       tree$5 = bal(l$0, v$0, d$1, r$1);
      return [0, tree$5, length$5];
     }
     var
      match$5 = change_core(l$0, key, f),
      length$6 = match$5[2],
      l$1 = match$5[1],
      tree$6 = bal(l$1, v$0, d$1, r$0);
     return [0, tree$6, length$6];
    }
    try{var _bZ_ = change_core(tree, key, f); return _bZ_;}
    catch(_b0_){
     var _bY_ = caml_wrap_exception(_b0_);
     if(_bY_ === Change_no_op) return [0, tree, length];
     throw caml_maybe_attach_backtrace(_bY_, 0);
    }
   }
   function update(t, key, f, length, compare_key){
    function update_core(t, key, f){
     if(typeof t === "number"){
      var
       data = caml_call1(f, 0),
       length$0 = caml_call2(Base_Import[91], length, 1),
       tree = [0, key, data];
      return [0, tree, length$0];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var d$0 = caml_call1(f, [0, d]), tree$0 = [0, v, d$0];
       return [0, tree$0, length];
      }
      if(0 <= c){
       var
        match = update_core(0, key, f),
        length$1 = match[2],
        r = match[1],
        tree$1 = bal(0, v, d, r);
       return [0, tree$1, length$1];
      }
      var
       match$0 = update_core(0, key, f),
       length$2 = match$0[2],
       l = match$0[1],
       tree$2 = bal(l, v, d, 0);
      return [0, tree$2, length$2];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var
       data$0 = caml_call1(f, [0, d$1]),
       tree$3 = [1, l$0, key, data$0, r$0, h];
      return [0, tree$3, length];
     }
     if(0 <= c$0){
      var
       match$1 = update_core(r$0, key, f),
       length$3 = match$1[2],
       r$1 = match$1[1],
       tree$4 = bal(l$0, v$0, d$1, r$1);
      return [0, tree$4, length$3];
     }
     var
      match$2 = update_core(l$0, key, f),
      length$4 = match$2[2],
      l$1 = match$2[1],
      tree$5 = bal(l$1, v$0, d$1, r$0);
     return [0, tree$5, length$4];
    }
    return update_core(t, key, f);
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var _bX_ = param[1];
               if(_bX_){
                var non_empty_tail = _bX_[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[4], v$0 = t$0[2], l = t$0[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     t$0 = r;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2]; return caml_call1(f, d);}
     var r = t$0[4], d$0 = t$0[3], l = t$0[1];
     iter(l, f);
     caml_call1(f, d$0);
     t$0 = r;
    }
   }
   function iteri(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     t$0 = r;
    }
   }
   function iteri_until_loop(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     t$0 = r;
    }
   }
   function iteri_until(t, f){
    var _bW_ = iteri_until_loop(t, f);
    return caml_call1(Finished_or_unfinished[5], _bW_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold(l, accu$0, f));
     t$0 = r;
     accu$0 = accu$1;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t, acc, f){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var d = t$0[2], v = t$0[1];
       return caml_call3(f, v, d, acc$0);
      }
      var
       r = t$0[4],
       d$0 = t$0[3],
       v$0 = t$0[2],
       l = t$0[1],
       match = fold_until_loop(l, acc$0, f);
      if(0 !== match[0]){var final$1 = match[1]; return [1, final$1];}
      var acc$1 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$1);
      if(0 !== match$0[0]){var final$0 = match$0[1]; return [1, final$0];}
      var acc$2 = match$0[1];
      t$0 = r;
      acc$0 = acc$2;
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold_right(r, accu$0, f));
     t$0 = l;
     accu$0 = accu$1;
    }
   }
   function filter_mapi(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1], match = caml_call2(f, v, d);
     if(match){var new_data = match[1]; return [0, v, new_data];}
     len[1]--;
     return 0;
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filter_mapi(l, f, len),
     new_data$0 = caml_call2(f, v$0, d$0),
     r$0 = filter_mapi(r, f, len);
    if(new_data$0){
     var new_data$1 = new_data$0[1];
     return join$0(l$0, v$0, new_data$1, r$0);
    }
    len[1]--;
    return concat_and_balance_unchecked(l$0, r$0);
   }
   function filteri(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return caml_call2(f, v, d) ? t : (len[1]--, 0);
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filteri(l, f, len),
     keep_data = caml_call2(f, v$0, d$0),
     r$0 = filteri(r, f, len);
    if
     (caml_call2(Base_Import[128], l, l$0)
      && keep_data && caml_call2(Base_Import[128], r, r$0))
     return t;
    return keep_data
            ? join$0(l$0, v$0, d$0, r$0)
            : (len[1]--, concat_and_balance_unchecked(l$0, r$0));
   }
   function filter(t, f, len){
    return filteri(t, function(param, data){return caml_call1(f, data);}, len);
   }
   function filter_keys(t, f, len){
    return filteri(t, function(key, param){return caml_call1(f, key);}, len);
   }
   function filter_map(t, f, len){
    return filter_mapi
            (t, function(param, data){return caml_call1(f, data);}, len);
   }
   function partition_mapi(t, f){
    var
     match =
       fold
        (t,
         [0, empty, empty],
         function(key, data, param){
          var t2 = param[2], t1 = param[1], match = caml_call2(f, key, data);
          if(0 === match[0]){
           var x = match[1];
           return [0, add_unchecked(t1, key, x), t2];
          }
          var y = match[1];
          return [0, t1, add_unchecked(t2, key, y)];
         }),
     t2 = match[2],
     t1 = match[1],
     _bV_ = to_tree_unchecked(t2);
    return [0, to_tree_unchecked(t1), _bV_];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    function loop(t, f){
     if(typeof t === "number") return _m_;
     if(0 === t[0]){
      var d = t[2], v = t[1];
      return caml_call2(f, v, d) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l, f),
      l_f = match[2],
      l_t = match[1],
      keep_data_t = caml_call2(f, v$0, d$0),
      match$0 = loop(r, f),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(l$0, keep_data, r$0){
      if
       (caml_call2(Base_Import[128], l, l$0)
        && keep_data && caml_call2(Base_Import[128], r, r$0))
       return t;
      return keep_data
              ? join$0(l$0, v$0, d$0, r$0)
              : concat_and_balance_unchecked(l$0, r$0);
     }
     var _bU_ = mk(l_f, 1 - keep_data_t, r_f);
     return [0, mk(l_t, keep_data_t, r_t), _bU_];
    }
    return loop(t, f);
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function cons(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, r, e$0];
     t$0 = l;
     e$0 = e$1;
    }
   }
   function cons_right(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, l, e$0];
     t$0 = r;
     e$0 = e$1;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function step_deeper_exn(tree, e){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(0 === tree[0]){
     var d = tree[2], v = tree[1];
     return [0, 0, [0, v, d, 0, e]];
    }
    var r = tree[4], d$0 = tree[3], v$0 = tree[2], l = tree[1];
    return [0, l, [0, v$0, d$0, r, e]];
   }
   function drop_phys_equal_prefix(tree1, acc1, tree2, acc2){
    var tree1$0 = tree1, acc1$0 = acc1, tree2$0 = tree2, acc2$0 = acc2;
    for(;;){
     if(caml_call2(Base_Import[128], tree1$0, tree2$0))
      return [0, acc1$0, acc2$0];
     var h2 = height(tree2$0), h1 = height(tree1$0);
     if(h2 === h1){
      var
       match = step_deeper_exn(tree1$0, acc1$0),
       acc1$1 = match[2],
       tree1$1 = match[1],
       match$0 = step_deeper_exn(tree2$0, acc2$0),
       acc2$1 = match$0[2],
       tree2$1 = match$0[1];
      tree1$0 = tree1$1;
      acc1$0 = acc1$1;
      tree2$0 = tree2$1;
      acc2$0 = acc2$1;
     }
     else if(h1 < h2){
      var
       match$1 = step_deeper_exn(tree2$0, acc2$0),
       acc2$2 = match$1[2],
       tree2$2 = match$1[1];
      tree2$0 = tree2$2;
      acc2$0 = acc2$2;
     }
     else{
      var
       match$2 = step_deeper_exn(tree1$0, acc1$0),
       acc1$2 = match$2[2],
       tree1$2 = match$2[1];
      tree1$0 = tree1$2;
      acc1$0 = acc1$2;
     }
    }
   }
   function fold$0(init, f, param){
    var init$0 = init, param$0 = param;
    for(;;){
     if(! param$0) return init$0;
     var
      enum$0 = param$0[4],
      tree = param$0[3],
      data = param$0[2],
      key = param$0[1],
      next = caml_call3(f, key, data, init$0);
     init$0 = next;
     param$0 = cons(tree, enum$0);
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    a:
    {
     var t1$0 = t1, t2$0 = t2, curr = init;
     for(;;){
      if(! t1$0) break;
      if(! t2$0) break a;
      var
       enum2 = t2$0[4],
       tree2 = t2$0[3],
       v2 = t2$0[2],
       k2 = t2$0[1],
       enum1 = t1$0[4],
       tree1 = t1$0[3],
       v1 = t1$0[2],
       k1 = t1$0[1],
       compare_result = caml_call2(compare_key, k1, k2);
      if(0 === compare_result){
       var
        next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
        t2$1 = cons(tree2, enum2),
        t1$1 = cons(tree1, enum1);
       t1$0 = t1$1;
       t2$0 = t2$1;
       curr = next;
      }
      else if(0 <= compare_result){
       var
        next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
        t2$2 = cons(tree2, enum2);
       t2$0 = t2$2;
       curr = next$0;
      }
      else{
       var
        next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
        t1$2 = cons(tree1, enum1);
       t1$0 = t1$2;
       curr = next$1;
      }
     }
     return t2$0
             ? fold$0
               (curr,
                function(key, data, acc){
                 return caml_call3(f, key, [0, -57574468, data], acc);
                },
                t2$0)
             : curr;
    }
    return fold$0
            (curr,
             function(key, data, acc){
              return caml_call3(f, key, [0, 847852583, data], acc);
             },
             t1$0);
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(left){
      var
       right = state[2],
       enum1 = left[4],
       tree1 = left[3],
       data = left[2],
       key = left[1];
      if(! right)
       return [1, [0, key, [0, 847852583, data]], [0, cons(tree1, enum1), 0]];
      var
       enum2 = right[4],
       tree2 = right[3],
       v2 = right[2],
       k2 = right[1],
       compare_result = caml_call2(compare_key, key, k2);
      if(0 !== compare_result)
       return 0 <= compare_result
               ? [1,
                 [0, k2, [0, -57574468, v2]],
                 [0, left, cons(tree2, enum2)]]
               : [1,
                 [0, key, [0, 847852583, data]],
                 [0, cons(tree1, enum1), right]];
      var next_state = drop_phys_equal_prefix(tree1, enum1, tree2, enum2);
      return caml_call2(data_equal, data, v2)
              ? [0, next_state]
              : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
     }
     var match = state[2];
     if(! match) return 0;
     var
      enum$0 = match[4],
      tree = match[3],
      data$0 = match[2],
      key$0 = match[1];
     return [1,
             [0, key$0, [0, -57574468, data$0]],
             [0, 0, cons(tree, enum$0)]];
    }
    var _bT_ = drop_phys_equal_prefix(t1, 0, t2, 0);
    return caml_call2(Base_Sequence[41], _bT_, step);
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    var order = opt ? opt[1] : -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set(t$0, 0, key, data, compare_key)[1];
    }
    if(511974747 <= order){
     var
      _bN_ = Base_Import[127],
      tree =
        caml_call3
         (Base_Option[32],
          keys_greater_or_equal_to,
          t$3,
          function(_bR_, _bS_){return inclusive_bound(_bN_, _bR_, _bS_);}),
      next$0 =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 === "number"){var init$0 = e$1; break;}
       if(0 === t$1[0]){
        var d$1 = t$1[2], v$2 = t$1[1], t$2 = [1, 0, v$2, d$1, 0, 1];
        t$1 = t$2;
       }
       else{
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0))
         t$1 = l$0;
        else{
         var
          r$1 = t$1[4],
          d$2 = t$1[3],
          v$4 = t$1[2],
          e$2 = [0, v$4, d$2, l$0, e$1];
         t$1 = r$1;
         e$1 = e$2;
        }
       }
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return caml_call2(Base_Sequence[41], init$0, next$0);
    }
    var
     _bO_ = Base_Import[125],
     t$4 =
       caml_call3
        (Base_Option[32],
         keys_less_or_equal_to,
         t$3,
         function(_bP_, _bQ_){return inclusive_bound(_bO_, _bP_, _bQ_);});
    function next(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t === "number"){var init = e; break;}
      if(0 === t[0]){
       var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1];
       t = t$0;
      }
      else{
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key)){
        var r$0 = t[4], d$0 = t[3], v$1 = t[2], e$0 = [0, v$1, d$0, r$0, e];
        t = l;
        e = e$0;
       }
       else
        t = r;
      }
     }
    }
    else
     var init = of_tree(t$4);
    return caml_call2(Base_Sequence[41], init, next);
   }
   function compare$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     var
      match = drop_phys_equal_prefix(r1, e1, r2, e2),
      e2$0 = match[2],
      e1$0 = match[1];
     t1 = e1$0;
     t2 = e2$0;
    }
   }
   function equal$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        _bK_ = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(_bK_){
        var _bL_ = caml_call2(compare_data, d1, d2);
        if(_bL_){
         var
          match = drop_phys_equal_prefix(r1, e1, r2, e2),
          e2$0 = match[2],
          e1$0 = match[1];
         t1 = e1$0;
         t2 = e2$0;
         continue;
        }
        var _bM_ = _bL_;
       }
       else
        var _bM_ = _bK_;
       return _bM_;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    var _bJ_ = of_tree(t2);
    return fold2
            (compare_key,
             of_tree(t1),
             _bJ_,
             0,
             function(key, data, param){return caml_call2(f, key, data);});
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var _bI_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _bI_, init, f);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$0, t, acc$3){
     var t1 = t$0, t2 = t, init = acc$3;
     for(;;){
      if(caml_call2(Base_Import[128], t1, t2)) return init;
      if(typeof t1 === "number")
       return fold
               (t2,
                init,
                function(key, data, acc){return add(acc, key, data);});
      a:
      {
       if(0 === t1[0]){
        var v = t1[2], k = t1[1];
        if(typeof t2 === "number") break a;
        if(0 === t2[0]){
         var v$0 = t2[2], k$0 = t2[1], x = caml_call2(compare_key, k, k$0);
         if(0 === x) return delta(init, k, v, v$0);
         if(0 <= x){
          var acc$4 = add(init, k$0, v$0);
          return remove(acc$4, k, v);
         }
         var acc$5 = remove(init, k, v);
         return add(acc$5, k$0, v$0);
        }
       }
       else{
        var r = t1[4], v$1 = t1[3], k$1 = t1[2], l = t1[1];
        if(typeof t2 === "number") break a;
        if(0 !== t2[0]){
         var l$0 = t2[1], r$0 = t2[4], v$2 = t2[3], k$2 = t2[2];
         if(0 === caml_call2(compare_key, k$1, k$2)){
          var acc$6 = loop(l, l$0, init), acc$7 = delta(acc$6, k$1, v$1, v$2);
          t1 = r;
          t2 = r$0;
          init = acc$7;
          continue;
         }
        }
       }
       var
        add$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
          },
        remove$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
          },
        match$0 = drop_phys_equal_prefix(t1, 0, t2, 0),
        right$1 = match$0[2],
        left$1 = match$0[1];
       b:
       {
        var left = left$1, right = right$1, acc = init;
        for(;;){
         if(! left) break;
         if(! right) break b;
         var
          enum2 = right[4],
          tree2 = right[3],
          v2 = right[2],
          k2 = right[1],
          enum1 = left[4],
          tree1 = left[3],
          v1 = left[2],
          k1 = left[1],
          compare_result = caml_call2(compare_key, k1, k2);
         if(0 === compare_result){
          var
           acc$0 =
             caml_call2(data_equal, v1, v2)
              ? acc
              : caml_call2(f, acc, [0, k1, [0, 1013247643, [0, v1, v2]]]),
           match = drop_phys_equal_prefix(tree1, enum1, tree2, enum2),
           enum2$0 = match[2],
           enum1$0 = match[1];
          left = enum1$0;
          right = enum2$0;
          acc = acc$0;
         }
         else if(0 <= compare_result){
          var acc$1 = add$0(acc, k2, v2), right$0 = cons(tree2, enum2);
          right = right$0;
          acc = acc$1;
         }
         else{
          var acc$2 = remove$0(acc, k1, v1), left$0 = cons(tree1, enum1);
          left = left$0;
          acc = acc$2;
         }
        }
        return fold$0
                (acc,
                 function(key, data, acc){return add$0(acc, key, data);},
                 right);
       }
       return fold$0
               (acc,
                function(key, data, acc){return remove$0(acc, key, data);},
                left);
      }
      return fold
              (t1,
               init,
               function(key, data, acc){return remove(acc, key, data);});
     }
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     _bF_ = length(r),
     _bG_ = length(l),
     _bH_ = caml_call2(Base_Import[91], _bG_, _bF_);
    return caml_call2(Base_Import[91], _bH_, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function of_foldable(fold, foldable, init, f, compare_key){
    return caml_call3
            (fold,
             foldable,
             [0, empty_without_value_restrictio, 0],
             function(_bE_, param){
              var
               data = param[2],
               key = param[1],
               length = _bE_[2],
               accum = _bE_[1],
               match = find(accum, key, compare_key);
              if(match)
               var prev = match[1], prev_data = prev;
              else
               var prev_data = init;
              var data$0 = caml_call2(f, prev_data, data);
              return globalize(set(accum, length, key, data$0, compare_key));
             });
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     return of_foldable(M[2], foldable, init, f, compare_key);
    }
    function of_foldable_reduce(foldable, f, compare_key){
     return caml_call3
             (M[2],
              foldable,
              [0, empty_without_value_restrictio, 0],
              function(_bD_, param){
               var
                data = param[2],
                key = param[1],
                length = _bD_[2],
                accum = _bD_[1],
                match = find(accum, key, compare_key);
               if(match)
                var prev = match[1], new_data = caml_call2(f, prev, data);
               else
                var new_data = data;
               return globalize
                       (set(accum, length, key, new_data, compare_key));
              });
    }
    function of_foldable$0(foldable, compare_key){
     return caml_call1
             (with_return,
              function(r){
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    function(_bC_, param){
                     var
                      data = param[2],
                      key = param[1],
                      length = _bC_[2],
                      t = _bC_[1],
                      acc = set(t, length, key, data, compare_key),
                      length$0 = acc[2];
                     return length === length$0
                             ? caml_call1(r, [0, -1048878709, key])
                             : globalize(acc);
                    });
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return [0, x];}
     var
      key = match[2],
      _bz_ = comparator[2],
      _bA_ = caml_call2(Base_Import[112], M[1], cst_or_error_duplicate_key),
      _bB_ = caml_call2(Base_Import[112], cst_Map_of, _bA_);
     return caml_call5(Base_Or_error[34], 0, 0, _bB_, key, _bz_);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return x;}
     var
      key = match[2],
      _bv_ = comparator[2],
      _bw_ = caml_call2(Base_Import[112], M[1], cst_exn_duplicate_key),
      _bx_ = caml_call2(Base_Import[112], cst_Map_of$0, _bw_),
      _by_ = caml_call5(Base_Error[17], 0, 0, _bx_, key, _bv_);
     return caml_call1(Base_Error[29], _by_);
    }
    function of_foldable_multi(foldable, compare_key){
     var
      alist = caml_call3(M[2], foldable, 0, function(l, x){return [0, x, l];});
     return of_foldable
             (Base_List0[8],
              alist,
              0,
              function(l, x){return [0, x, l];},
              compare_key);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable$0,
            of_foldable_or_error,
            of_foldable_exn,
            of_foldable_multi];
   }
   var
    fold$1 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$1]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5],
    of_alist_multi = Of_alist[6],
    fold$2 = Base_Sequence[8],
    Of_sequence = Of_foldable([0, name$0, fold$2]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5],
    of_sequence_multi = Of_sequence[6],
    cst_Map_of_list_with_key_or_er =
      "Map.of_list_with_key_or_error: duplicate key",
    cst_Map_of_list_with_key_exn_d = "Map.of_list_with_key_exn: duplicate key",
    _o_ = [0, 0],
    _p_ = [0, 0],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    _q_ = [0, cst_src_map_ml, 1870, 6],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    _r_ = [0, "Map.Build_increasing.add: non-increasing key"],
    dummy = 0;
   function of_list_with_key(list, get_key, compare_key){
    return caml_call1
            (with_return,
             function(r){
              var
               map =
                 caml_call3
                  (Base_List0[8],
                   list,
                   [0, empty_without_value_restrictio, 0],
                   function(param, data){
                    var
                     length = param[2],
                     t = param[1],
                     key = caml_call1(get_key, data),
                     acc = set(t, length, key, data, compare_key),
                     new_length = acc[2];
                    return length === new_length
                            ? caml_call1(r, [0, -1048878709, key])
                            : globalize(acc);
                   });
              return [0, 17724, map];
             });
   }
   function of_list_with_key_or_error(list, get_key, comparator){
    var match = of_list_with_key(list, get_key, comparator[1]);
    if(17724 <= match[1]){var x = match[2]; return [0, x];}
    var key = match[2];
    return caml_call5
            (Base_Or_error[34],
             0,
             0,
             cst_Map_of_list_with_key_or_er,
             key,
             comparator[2]);
   }
   function of_list_with_key_exn(list, get_key, comparator){
    var match = of_list_with_key(list, get_key, comparator[1]);
    if(17724 <= match[1]){var x = match[2]; return x;}
    var
     key = match[2],
     _bu_ =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Map_of_list_with_key_exn_d,
         key,
         comparator[2]);
    return caml_call1(Base_Error[29], _bu_);
   }
   function of_list_with_key_multi(list, get_key, compare_key){
    var list$0 = caml_call1(Base_List0[21], list);
    return caml_call3
            (Base_List0[8],
             list$0,
             [0, empty_without_value_restrictio, 0],
             function(param, data){
              var
               length = param[2],
               t = param[1],
               key = caml_call1(get_key, data);
              return globalize
                      (update
                        (t,
                         key,
                         function(option){
                          var list = caml_call2(Base_Option[28], option, 0);
                          return [0, data, list];
                         },
                         length,
                         compare_key));
             });
   }
   function for_all(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _bt_ = 1 - caml_call1(f, data);
                 return _bt_ ? caml_call1(r, 0) : _bt_;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _bs_ = 1 - caml_call2(f, key, data);
                 return _bs_ ? caml_call1(r, 0) : _bs_;
                });
              return 1;
             });
   }
   function exists(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _br_ = caml_call1(f, data);
                 return _br_ ? caml_call1(r, 1) : _br_;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _bq_ = caml_call2(f, key, data);
                 return _bq_ ? caml_call1(r, 1) : _bq_;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function to_alist(opt, t){
    var key_order = opt ? opt[1] : 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     _bn_ = length(t2),
     _bo_ = length(t1),
     _bp_ = caml_call2(Base_Import[91], _bo_, _bn_),
     elts = caml_call1(Base_Uniform_array[34], _bp_),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       caml_call3(Base_Uniform_array[13], elts, i[1], [0, key, value]);
       i[1]++;
       return 0;
      },
      compare_key);
    var length$0 = i[1];
    function get(i){return caml_call2(Base_Uniform_array[11], elts, i);}
    var tree = of_increasing_iterator_uncheck(length$0, get);
    return [0, tree, length$0];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return globalize
                      (update
                        (t,
                         key,
                         function(param){
                          if(! param) return data;
                          var data$0 = param[1];
                          return caml_call4(call, combine, key, data$0, data);
                         },
                         length,
                         compare_key));
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]) break;
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       t = l;
       found_marker = 1;
       found_key = found_key$0;
       found_value = found_value$0;
       continue;
      }
      t = r;
      continue;
     }
     if(0 <= c$0)
      t = l;
     else{
      t = r;
      found_marker = 1;
      found_key = found_key$0;
      found_value = found_value$0;
     }
    }
    var
     v = t[2],
     k = t[1],
     c = caml_call2(compare_key, k, k$0),
     _bm_ =
       521507869 <= dir
        ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
        : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
    return _bm_
            ? [0, [0, k, v]]
            : repackage(found_marker, found_key, found_value);
   }
   function rank(t, k, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var k$0 = t$0[1];
      return 0 === caml_call2(compare_key, k$0, k) ? _o_ : 0;
     }
     var
      r = t$0[4],
      k$1 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, k$1, k);
     if(0 === c) return [0, length(l)];
     if(0 >= c){
      var _bj_ = rank(r, k, compare_key);
      return caml_call2
              (Base_Option[22],
               _bj_,
               function(rank){
                var
                 _bk_ = length(l),
                 _bl_ = caml_call2(Base_Import[91], rank, 1);
                return caml_call2(Base_Import[91], _bl_, _bk_);
               });
     }
     t$0 = l;
    }
   }
   function nth(num_to_search, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var v = param$0[2], k = param$0[1];
      return 0 === num_to_search[1] ? [0, [0, k, v]] : (num_to_search[1]--, 0);
     }
     var
      r = param$0[4],
      v$0 = param$0[3],
      k$0 = param$0[2],
      l = param$0[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     num_to_search[1]--;
     param$0 = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return _p_;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && caml_call1(Base_Option[50], acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = globalize(pair);
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     key = match[2],
     _bi_ =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Map_of_iteri_exn_duplicate,
         key,
         comparator[2]);
    return caml_call1(Base_Error[29], _bi_);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     _bb_ = caml_call2(Base_Import[172], key_of_sexp, value_of_sexp),
     alist = caml_call2(Base_Import[174], _bb_, sexp),
     compare_key = comparator[1],
     match = of_alist(alist, compare_key);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     k = match[2],
     _bc_ =
       caml_call2
        (Base_Import[172],
         function(_bh_){return _bh_;},
         function(_bg_){return _bg_;}),
     alist_sexps = caml_call2(Base_Import[174], _bc_, sexp),
     found_first_k = [0, 0];
    caml_call3
     (Base_List0[13],
      alist,
      alist_sexps,
      function(_bd_, param){
       var
        k2_sexp = param[1],
        k2 = _bd_[1],
        _be_ = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
       if(_be_){
        if(found_first_k[1])
         return caml_call2
                 (Base_Import[157], cst_Map_t_of_sexp_direct_dupli, k2_sexp);
        found_first_k[1] = 1;
        var _bf_ = 0;
       }
       else
        var _bf_ = _be_;
       return _bf_;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var _ba_ = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), _ba_]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, sexp_of_key){
    var
     match = partition_map(t, Base_Result[36]),
     errors = match[2],
     oks = match[1];
    if(is_empty(errors)) return [0, oks];
    var _a$_ = sexp_of_t$1(sexp_of_key, Base_Error[6], errors);
    return caml_call1(Base_Or_error[35], _a$_);
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           _a9_ =
                             globalize
                              (add_exn_internal
                                (t2, length, key$0, data, compare_key, sexp_of_key));
                          return _a9_;
                         }
                         catch(_a__){
                          var _a8_ = caml_wrap_exception(_a__);
                          if(_a8_ === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(_a8_, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator);
    if(17724 <= match[1]){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     _a6_ = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     _a7_ = caml_call2(Base_Sexp[9], cst_Map_map_keys_exn_duplicate, _a6_);
    return caml_call1(Base_Error[30], _a7_);
   }
   function transpose_keys(outer_comparator, inner_comparator, outer_t){
    return fold
            (outer_t,
             [0, empty_without_value_restrictio, 0],
             function(outer_key, inner_t, acc){
              return fold
                      (inner_t,
                       acc,
                       function(inner_key, data, param){
                        var acc_len = param[2], acc = param[1];
                        return globalize
                                (update
                                  (acc,
                                   inner_key,
                                   function(param){
                                    if(param){
                                     var match = param[1], elt_len = match[2], elt = match[1];
                                     return globalize
                                             (set(elt, elt_len, outer_key, data, outer_comparator[1]));
                                    }
                                    var tree = [0, outer_key, data];
                                    return [0, tree, 1];
                                   },
                                   acc_len,
                                   inner_comparator[1]));
                       });
             });
   }
   function Make_applicative_traversals(A){
    function mapi(t, f){
     if(typeof t === "number") return caml_call1(A[1], 0);
     if(0 === t[0]){
      var d = t[2], v = t[1], _a5_ = caml_call2(f, v, d);
      return caml_call2
              (A[2], _a5_, function(new_data){return [0, v, new_data];});
     }
     var
      h = t[5],
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      l$0 = caml_call1(A[14], function(param){return mapi(l, f);}),
      d$1 = caml_call2(f, v$0, d$0),
      r$0 = caml_call1(A[14], function(param){return mapi(r, f);});
     return caml_call4
             (A[10],
              l$0,
              d$1,
              r$0,
              function(l, d, r){return [1, l, v$0, d, r, h];});
    }
    function filter_mapi(t, f){
     function tree_filter_mapi(t, f){
      if(typeof t === "number") return caml_call1(A[1], [0, 0, 0]);
      if(0 === t[0]){
       var d = t[2], v = t[1], _aZ_ = caml_call2(f, v, d);
       return caml_call2
               (A[2],
                _aZ_,
                function(param){
                 if(! param) return [0, 0, 0];
                 var new_data = param[1], tree = [0, v, new_data];
                 return [0, tree, 1];
                });
      }
      var
       r = t[4],
       d$0 = t[3],
       v$0 = t[2],
       l = t[1],
       _a0_ =
         caml_call1(A[14], function(param){return tree_filter_mapi(r, f);}),
       _a1_ = caml_call2(f, v$0, d$0),
       _a2_ =
         caml_call1(A[14], function(param){return tree_filter_mapi(l, f);});
      return caml_call4
              (A[10],
               _a2_,
               _a1_,
               _a0_,
               function(_a3_, new_data, param){
                var
                 r_len = param[2],
                 r = param[1],
                 l_len = _a3_[2],
                 l = _a3_[1];
                if(new_data){
                 var
                  new_data$0 = new_data[1],
                  _a4_ = caml_call2(Base_Import[91], l_len, r_len),
                  length = caml_call2(Base_Import[91], _a4_, 1),
                  tree = join$0(l, v$0, new_data$0, r);
                 return [0, tree, length];
                }
                var
                 length$0 = caml_call2(Base_Import[91], l_len, r_len),
                 tree$0 = concat_and_balance_unchecked(l, r);
                return [0, tree$0, length$0];
               });
     }
     return tree_filter_mapi(t, f);
    }
    return [0, mapi, filter_mapi];
   }
   function compare_key(t){return t[1][1];}
   function like(_aY_, param){
    var length = param[2], tree = param[1], comparator = _aY_[1];
    return [0, comparator, tree, length];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return caml_call2(Base_Import[128], old_tree, tree)
            ? old_t
            : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_like_tree(t, tree){
    var _aX_ = length(tree);
    return [0, t[1], tree, _aX_];
   }
   function of_like_tree_maybe_no_op(t, tree){
    if(caml_call2(Base_Import[128], t[2], tree)) return t;
    var _aW_ = length(tree);
    return [0, t[1], tree, _aW_];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var _aS_ = compare_key(t), _aT_ = invariants(t[2], _aS_);
    if(_aT_)
     var _aU_ = t[3], _aV_ = length(t[2]) === _aU_ ? 1 : 0;
    else
     var _aV_ = _aT_;
    return _aV_;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$0(t, key, data){
    var _aR_ = compare_key(t);
    return like(t, set(t[2], t[3], key, data, _aR_));
   }
   function add_exn$0(t, key, data){
    var _aP_ = t[1][2], _aQ_ = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, _aQ_, _aP_));
   }
   function add(t, key, data){
    try{
     var
      _aL_ = t[1][2],
      _aM_ = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, _aM_, _aL_));
    }
    catch(_aO_){
     var _aN_ = caml_wrap_exception(_aO_);
     if(_aN_ === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(_aN_, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var _aK_ = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, _aK_));
   }
   function remove_multi$0(t, key){
    var _aJ_ = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], _aJ_));
   }
   function find_multi$0(t, key){
    var _aI_ = compare_key(t);
    return find_multi(t[2], key, _aI_);
   }
   function change$0(t, key, f){
    var _aH_ = compare_key(t);
    return like(t, change(t[2], key, f, t[3], _aH_));
   }
   function update$0(t, key, f){
    var _aG_ = compare_key(t);
    return like(t, update(t[2], key, f, t[3], _aG_));
   }
   function find_exn$0(t, key){
    var _aE_ = t[1][2], _aF_ = compare_key(t);
    return find_exn(t[2], key, _aF_, _aE_);
   }
   function find$0(t, key){
    var _aD_ = compare_key(t);
    return find(t[2], key, _aD_);
   }
   function remove$0(t, key){
    var _aC_ = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], _aC_));
   }
   function mem$0(t, key){
    var _aB_ = compare_key(t);
    return mem(t[2], key, _aB_);
   }
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until$0(t, f){return iteri_until(t[2], f);}
   function iter2$0(t1, t2, f){
    var _aA_ = compare_key(t1);
    return iter2(t1[2], t2[2], f, _aA_);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$3(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var _az_ = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, _az_);
   }
   function filter_keys$0(t, f){
    var len = [0, t[3]], tree = filter_keys(t[2], f, len), length = len[1];
    return like_maybe_no_op(t, [0, tree, length]);
   }
   function filter$0(t, f){
    var len = [0, t[3]], tree = filter(t[2], f, len), length = len[1];
    return like_maybe_no_op(t, [0, tree, length]);
   }
   function filteri$0(t, f){
    var len = [0, t[3]], tree = filteri(t[2], f, len), length = len[1];
    return like_maybe_no_op(t, [0, tree, length]);
   }
   function filter_map$0(t, f){
    var len = [0, t[3]], tree = filter_map(t[2], f, len), length = len[1];
    return like(t, [0, tree, length]);
   }
   function filter_mapi$0(t, f){
    var len = [0, t[3]], tree = filter_mapi(t[2], f, len), length = len[1];
    return like(t, [0, tree, length]);
   }
   function of_like_tree2(t, param){
    var t2 = param[2], t1 = param[1], _ay_ = of_like_tree(t, t2);
    return [0, of_like_tree(t, t1), _ay_];
   }
   function of_like_tree2_maybe_no_op(t, param){
    var t2 = param[2], t1 = param[1], _ax_ = of_like_tree_maybe_no_op(t, t2);
    return [0, of_like_tree_maybe_no_op(t, t1), _ax_];
   }
   function partition_mapi$0(t, f){
    return of_like_tree2(t, partition_mapi(t[2], f));
   }
   function partition_map$0(t, f){
    return of_like_tree2(t, partition_map(t[2], f));
   }
   function partitioni_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partitioni_tf(t[2], f));
   }
   function partition_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partition_tf(t[2], f));
   }
   function combine_errors$0(t){
    var _av_ = combine_errors(t[2], t[1][2]);
    return caml_call2
            (Base_Or_error[43],
             _av_,
             function(_aw_){return of_like_tree(t, _aw_);});
   }
   function compare_direct(compare_data, t1, t2){
    var _at_ = t2[2], _au_ = t1[2];
    return compare$1(compare_key(t1), compare_data, _au_, _at_);
   }
   function equal$2(compare_data, t1, t2){
    var _ar_ = t2[2], _as_ = t1[2];
    return equal$1(compare_key(t1), compare_data, _as_, _ar_);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var _aq_ = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], _aq_, data_equal);
   }
   function fold_symmetric_diff$0(t1, t2, data_equal, init, f){
    var _ap_ = compare_key(t1);
    return fold_symmetric_diff(t1[2], t2[2], _ap_, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var _ao_ = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, _ao_));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     _am_ = compare_key(t1),
     _an_ = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, _am_),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, _an_);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function split$0(t, k){
    var
     _ak_ = compare_key(t),
     match = split(t[2], k, _ak_),
     tree = match[3],
     maybe = match[2],
     tree$0 = match[1],
     comparator = t[1],
     both_len =
       caml_call1(Base_Option[51], maybe)
        ? caml_call2(Base_Import[93], t[3], 1)
        : t[3],
     _al_ = height(tree);
    if(height(tree$0) < _al_){
     var
      l = of_tree$0(comparator, tree$0),
      length = caml_call2(Base_Import[93], both_len, l[3]);
     return [0, l, maybe, [0, comparator, tree, length]];
    }
    var
     r = of_tree$0(comparator, tree),
     length$0 = caml_call2(Base_Import[93], both_len, r[3]);
    return [0, [0, comparator, tree$0, length$0], maybe, r];
   }
   function split_and_reinsert_boundary$0(t, into, k){
    var
     _ai_ = compare_key(t),
     match = split_and_reinsert_boundary(t[2], into, k, _ai_),
     tree = match[2],
     tree$0 = match[1],
     comparator = t[1],
     _aj_ = height(tree);
    if(height(tree$0) < _aj_){
     var
      l = of_tree$0(comparator, tree$0),
      length = caml_call2(Base_Import[93], t[3], l[3]);
     return [0, l, [0, comparator, tree, length]];
    }
    var
     r = of_tree$0(comparator, tree),
     length$0 = caml_call2(Base_Import[93], t[3], r[3]);
    return [0, [0, comparator, tree$0, length$0], r];
   }
   function split_le_gt(t, k){
    return split_and_reinsert_boundary$0(t, 847852583, k);
   }
   function split_lt_ge(t, k){
    return split_and_reinsert_boundary$0(t, -57574468, k);
   }
   function subrange(t, lower_bound, upper_bound){
    var
     _ae_ = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, _ae_),
     right = match[3],
     tree = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? caml_call2(Base_Import[91], h_l, 1)
        : caml_call2(Base_Import[100], h_l, h_r);
    if(outer_joined_height >= height(tree)) return of_tree$0(t[1], tree);
    var
     _af_ = length(right),
     _ag_ = length(left),
     _ah_ = caml_call2(Base_Import[91], _ag_, _af_),
     mid_length = caml_call2(Base_Import[93], t[3], _ah_),
     comparator = t[1];
    return [0, comparator, tree, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     _ad_ = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], _ad_);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     length = caml_call2(Base_Import[91], lower_part[3], upper_part[3]),
     comparator = lower_part[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var _ac_ = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, _ac_);
   }
   function range_to_alist$0(t, min, max){
    var _ab_ = compare_key(t);
    return range_to_alist(t[2], min, max, _ab_);
   }
   function closest_key$0(t, dir, key){
    var _aa_ = compare_key(t);
    return closest_key(t[2], dir, key, _aa_);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var _$_ = nth$1(t, n);
    return caml_call4(Base_Option[29], 0, 0, 0, _$_);
   }
   function rank$0(t, key){
    var ___ = compare_key(t);
    return rank(t[2], key, ___);
   }
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2], _Z_ = length(t$0);
    return fold
            (t$0,
             caml_call2(Base_Import[207], state, _Z_),
             function(key, data, state){
              return caml_call2
                      (hash_fold_data,
                       caml_call2(hash_fold_key, state, key),
                       data);
             });
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, [0, 0, 0]);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function Make_applicative_traversals$0(A){
    var Tree_traversals = Make_applicative_traversals(A);
    function mapi(t, f){
     var _Y_ = Tree_traversals[1].call(null, t[2], f);
     return caml_call2
             (A[2],
              _Y_,
              function(new_tree){return with_same_length(t, new_tree);});
    }
    function filter_mapi(t, f){
     var _X_ = Tree_traversals[2].call(null, t[2], f);
     return caml_call2
             (A[2],
              _X_,
              function(new_tree_with_length){
               return like(t, new_tree_with_length);
              });
    }
    return [0, , mapi, filter_mapi];
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, key, data){return [0, key, data];}
   function of_sorted_array_unchecked$0(comparator, array){
    return of_sorted_array_unchecked(array, comparator[1])[1];
   }
   function of_sorted_array$0(comparator, array){
    var _W_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[43], _W_, function(x){return x[1];});
   }
   function of_alist$0(comparator, alist){
    var d = of_alist(alist, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var _V_ = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Or_error[43], _V_, function(x){return x[1];});
   }
   function of_alist_exn$0(comparator, alist){
    return of_alist_exn(alist, comparator)[1];
   }
   function of_alist_multi$0(comparator, alist){
    return of_alist_multi(alist, comparator[1])[1];
   }
   function of_alist_fold$0(comparator, alist, init, f){
    return of_alist_fold(alist, init, f, comparator[1])[1];
   }
   function of_alist_reduce$0(comparator, alist, f){
    return of_alist_reduce(alist, f, comparator[1])[1];
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    return of_iteri_exn(iteri, comparator)[1];
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    var _U_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[43], _U_, function(x){return x[1];});
   }
   function of_sequence$0(comparator, seq){
    var d = of_sequence(seq, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var _T_ = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Or_error[43], _T_, function(x){return x[1];});
   }
   function of_sequence_exn$0(comparator, seq){
    return of_sequence_exn(seq, comparator)[1];
   }
   function of_sequence_multi$0(comparator, seq){
    return of_sequence_multi(seq, comparator[1])[1];
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    return of_sequence_fold(seq, init, f, comparator[1])[1];
   }
   function of_sequence_reduce$0(comparator, seq, f){
    return of_sequence_reduce(seq, f, comparator[1])[1];
   }
   function of_list_with_key$0(comparator, list, get_key){
    var d = of_list_with_key(list, get_key, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_list_with_key_or_error$0(comparator, list, get_key){
    var _S_ = of_list_with_key_or_error(list, get_key, comparator);
    return caml_call2(Base_Or_error[43], _S_, function(x){return x[1];});
   }
   function of_list_with_key_exn$0(comparator, list, get_key){
    return of_list_with_key_exn(list, get_key, comparator)[1];
   }
   function of_list_with_key_multi$0(comparator, list, get_key){
    return of_list_with_key_multi(list, get_key, comparator[1])[1];
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$1(comparator, t, key, data){
    return set(t, 0, key, data, comparator[1])[1];
   }
   function add_exn$1(comparator, t, key, data){
    return add_exn(t, 0, key, data, comparator[1], comparator[2])[1];
   }
   function add$0(comparator, t, key, data){
    try{
     var
      _Q_ =
        [0,
         17724,
         add_exn_internal(t, 0, key, data, comparator[1], comparator[2])[1]];
     return _Q_;
    }
    catch(_R_){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    return add_multi(t, 0, key, data, comparator[1])[1];
   }
   function remove_multi$1(comparator, t, key){
    return remove_multi(t, key, 0, comparator[1])[1];
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    return change(t, key, f, 0, comparator[1])[1];
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    return remove(t, key, 0, comparator[1])[1];
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$1(t, f){return iteri_until(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$4(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(t, f){return filter_keys(t, f, [0, 0]);}
   function filter$1(t, f){return filter(t, f, [0, 0]);}
   function filteri$1(t, f){return filteri(t, f, [0, 0]);}
   function filter_map$1(t, f){return filter_map(t, f, [0, 0]);}
   function filter_mapi$1(t, f){return filter_mapi(t, f, [0, 0]);}
   function partition_mapi$1(t, f){return partition_mapi(t, f);}
   function partition_map$1(t, f){return partition_map(t, f);}
   function partitioni_tf$1(t, f){return partitioni_tf(t, f);}
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function combine_errors$1(comparator, t){
    return combine_errors(t, comparator[2]);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$1(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    return merge(t1, t2, f, comparator[1])[1];
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var _O_ = comparator[1], _P_ = length(t2);
    return merge_skewed(t1, t2, length(t1), _P_, combine, _O_)[1];
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function split_le_gt$0(comparator, t, k){
    return split_and_reinsert_boundary(t, 847852583, k, comparator[1]);
   }
   function split_lt_ge$0(comparator, t, k){
    return split_and_reinsert_boundary(t, -57574468, k, comparator[1]);
   }
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var _N_ = nth$0(t, n);
    return caml_call4(Base_Option[29], 0, 0, 0, _N_);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    return t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator)[1];
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator);
    if(17724 > dup[1]) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    return map_keys_exn(t, f, comparator)[1];
   }
   function transpose_keys$0(outer_comparator, inner_comparator, t){
    var t$0 = transpose_keys(outer_comparator, inner_comparator, t)[1];
    function f(x){return x[1];}
    return map(t$0, f);
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return caml_call1(Base_Error[30], _r_);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var
    Build_increasing = [0, empty, add_exn$2, to_tree$1],
    _s_ = [0, "_"],
    _t_ = [1, 0],
    _u_ = [1, 0],
    _v_ = [1, 0];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, key, data){return [0, comparator, [0, key, data], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    var length$0 = length(tree);
    return of_tree0(comparator, [0, tree, length$0]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    var _M_ = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[43],
             _M_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist$1(comparator, alist){
    var z = of_alist(alist, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    var _L_ = of_alist_or_error(alist, comparator);
    return caml_call2
            (Base_Result[31],
             _L_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, of_alist_exn(alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0(comparator, of_alist_fold(alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0(comparator, of_alist_reduce(alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]);
    if(17724 > z[1]) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, length, f){
    var tree = of_increasing_iterator_uncheck(length, f);
    return of_tree0(comparator, [0, tree, length]);
   }
   function of_increasing_sequence$1(comparator, seq){
    var _K_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2
            (Base_Or_error[43],
             _K_,
             function(x){return of_tree0(comparator, x);});
   }
   function of_sequence$1(comparator, seq){
    var z = of_sequence(seq, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    var _J_ = of_sequence_or_error(seq, comparator);
    return caml_call2
            (Base_Result[31],
             _J_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, of_sequence_exn(seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0(comparator, of_sequence_fold(seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0(comparator, of_sequence_reduce(seq, f, comparator[1]));
   }
   function of_list_with_key$1(comparator, list, get_key){
    var z = of_list_with_key(list, get_key, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_list_with_key_or_error$1(comparator, list, get_key){
    var _I_ = of_list_with_key_or_error(list, get_key, comparator);
    return caml_call2
            (Base_Result[31],
             _I_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_list_with_key_exn$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_exn(list, get_key, comparator));
   }
   function of_list_with_key_multi$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_multi(list, get_key, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator);
    if(17724 > dup[1]) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function transpose_keys$1(inner_comparator, t){
    var outer_comparator = t[1];
    return map$0
            (of_tree0
              (inner_comparator,
               transpose_keys
                (outer_comparator, inner_comparator, map(t[2], to_tree))),
             function(x){return of_tree0(outer_comparator, x);});
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function of_tree$3(M, tree){return of_tree$0(M[1], tree);}
   function empty$2(m){return empty$1(m[1]);}
   function singleton$1(m, a){
    var _G_ = m[1];
    return function(_H_){return singleton$0(_G_, a, _H_);};
   }
   function of_alist$2(m, a){return of_alist$1(m[1], a);}
   function of_alist_or_error$2(m, a){return of_alist_or_error$1(m[1], a);}
   function of_alist_exn$2(m, a){return of_alist_exn$1(m[1], a);}
   function of_alist_multi$2(m, a){return of_alist_multi$1(m[1], a);}
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(m[1], a, init, f);
   }
   function of_alist_reduce$2(m, a, f){return of_alist_reduce$1(m[1], a, f);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_iteri$2(m, iteri){return of_iteri$1(m[1], iteri);}
   function of_iteri_exn$2(m, iteri){return of_iteri_exn$1(m[1], iteri);}
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(m[1], seq);
   }
   function of_sequence$2(m, s){return of_sequence$1(m[1], s);}
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(m[1], s);
   }
   function of_sequence_exn$2(m, s){return of_sequence_exn$1(m[1], s);}
   function of_sequence_multi$2(m, s){return of_sequence_multi$1(m[1], s);}
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(m[1], s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(m[1], s, f);
   }
   function of_list_with_key$2(m, l, get_key){
    return of_list_with_key$1(m[1], l, get_key);
   }
   function of_list_with_key_or_error$2(m, l, get_key){
    return of_list_with_key_or_error$1(m[1], l, get_key);
   }
   function of_list_with_key_exn$2(m, l, get_key){
    return of_list_with_key_exn$1(m[1], l, get_key);
   }
   function of_list_with_key_multi$2(m, l, get_key){
    return of_list_with_key_multi$1(m[1], l, get_key);
   }
   function map_keys$2(m, t, f){return map_keys$1(m[1], t, f);}
   function map_keys_exn$2(m, t, f){return map_keys_exn$1(m[1], t, f);}
   function transpose_keys$2(m, t){return transpose_keys$1(m[1], t);}
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t){
    return sexp_of_t$2(K[1], sexp_of_v, function(param){return _s_;}, t);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return [5,
            [0,
             Sexplib0_Sexp_grammar[5],
             _v_,
             [2,
              [1,
               [2,
                [0,
                 [5, [0, Sexplib0_Sexp_grammar[6], _u_, K[1]]],
                 [0, [5, [0, Sexplib0_Sexp_grammar[7], _t_, v_grammar]], 0]]]]]]];
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K, hash_fold_v, state){
    var _E_ = K[1];
    return function(_F_){
     return hash_fold_direct(_E_, hash_fold_v, state, _F_);};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(_D_){return singleton$0(comparator$0, a, _D_);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function of_list_with_key$3(l, get_key){
    return of_list_with_key$1(comparator$0, l, get_key);
   }
   function of_list_with_key_or_error$3(l, get_key){
    return of_list_with_key_or_error$1(comparator$0, l, get_key);
   }
   function of_list_with_key_exn$3(l, get_key){
    return of_list_with_key_exn$1(comparator$0, l, get_key);
   }
   function of_list_with_key_multi$3(l, get_key){
    return of_list_with_key_multi$1(comparator$0, l, get_key);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   function transpose_keys$3(t){return transpose_keys$1(comparator$0, t);}
   var
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       of_list_with_key$2,
       of_list_with_key_or_error$2,
       of_list_with_key_exn$2,
       of_list_with_key_multi$2,
       is_empty$0,
       length$0,
       set$0,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       transpose_keys$2,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       function(_B_){
        var _C_ = Make_applicative_traversals$0(_B_);
        return [0, _C_[2], _C_[3]];
       },
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       [0,
        sexp_of_t$2,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$3,
         t_of_sexp_direct$0,
         empty$0,
         singleton,
         map_keys$0,
         map_keys_exn$0,
         transpose_keys$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_increasing_sequence$0,
         of_sequence$0,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_list_with_key$0,
         of_list_with_key_or_error$0,
         of_list_with_key_exn$0,
         of_list_with_key_multi$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$1,
         invariants$1,
         is_empty$1,
         length$1,
         add$0,
         add_exn$1,
         set$1,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$1,
         find_exn$1,
         remove$1,
         mem$1,
         iter_keys$1,
         iter$1,
         iteri$1,
         iteri_until$1,
         iter2$1,
         map$1,
         mapi$1,
         fold$4,
         fold_until$1,
         fold_right$1,
         fold2$2,
         filter_keys$1,
         filter$1,
         filteri$1,
         filter_map$1,
         filter_mapi$1,
         partition_mapi$1,
         partition_map$1,
         partitioni_tf$1,
         partition_tf$1,
         combine_errors$1,
         compare_direct$0,
         equal$3,
         keys$1,
         data$1,
         to_alist$1,
         merge$1,
         merge_skewed$1,
         symmetric_diff$1,
         fold_symmetric_diff$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         for_all$1,
         for_alli$1,
         exists$1,
         existsi$1,
         count$1,
         counti$1,
         split$1,
         split_le_gt$0,
         split_lt_ge$0,
         append$1,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$2,
         nth_exn$0,
         rank$1,
         to_tree$0,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         binary_search_subrange$0,
         function(A){
          var Tree0_traversals = Make_applicative_traversals(A);
          function mapi(t, f){return Tree0_traversals[1].call(null, t, f);}
          function filter_mapi(t, f){
           var _A_ = Tree0_traversals[2].call(null, t, f);
           return caml_call2(A[2], _A_, function(x){return x[1];});
          }
          return [0, mapi, filter_mapi];
         },
         empty_without_value_restrictio,
         Build_increasing],
        empty$1,
        singleton$0,
        map_keys$1,
        map_keys_exn$1,
        transpose_keys$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_increasing_sequence$1,
        of_sequence$1,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_list_with_key$1,
        of_list_with_key_or_error$1,
        of_list_with_key_exn$1,
        of_list_with_key_multi$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$2,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$0,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        split_le_gt,
        split_lt_ge,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        function(_y_){
         var _z_ = Make_applicative_traversals$0(_y_);
         return [0, _z_[2], _z_[3]];
        },
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       [0,
        empty$3,
        singleton$2,
        map_keys$3,
        map_keys_exn$3,
        transpose_keys$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_increasing_sequence$3,
        of_sequence$3,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_list_with_key$3,
        of_list_with_key_or_error$3,
        of_list_with_key_exn$3,
        of_list_with_key_multi$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$4,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$0,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        split_le_gt,
        split_lt_ge,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        function(_w_){
         var _x_ = Make_applicative_traversals$0(_w_);
         return [0, _x_[2], _x_[3]];
        }],
       of_tree$3,
       to_tree];
   runtime.caml_register_global(69, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){
    var caml_iter = Stdlib_Queue[15];
    return caml_call2(caml_iter, f, t);
   }
   function fold(t, init, f){
    var caml_fold = Stdlib_Queue[16];
    return caml_call3(caml_fold, f, init, t);
   }
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return caml_call2(Base_Linked_queue0[8], x, t);}
   function dequeue(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[7], t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function dequeue_and_ignore_exn(t){caml_call1(dequeue_exn, t); return 0;}
   function peek(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[6], t)];
   }
   var
    peek_exn = Base_Linked_queue0[6],
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return caml_call2(Base_Linked_queue0[9], src, dst);
   }
   function concat_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _k_ = caml_call1(f, a);
       return caml_call2
               (Base_List[19], _k_, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _j_ = caml_call2(f, i, a);
       return caml_call2
               (Base_List[19], _j_, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function filter_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _i_ = caml_call1(f, a);
       return _i_ ? enqueue(res, a) : _i_;
      });
    return res;
   }
   function filteri(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _h_ = caml_call2(f, i, a);
       return _h_ ? enqueue(res, a) : _h_;
      });
    return res;
   }
   function map(t, f){
    var res = caml_call1(create, 0);
    caml_call2(iter, t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    return caml_call2(Base_List[19], list, function(x){return enqueue(t, x);});
   }
   function of_list(list){
    var t = caml_call1(create, 0);
    caml_call2(Base_List[19], list, function(x){return enqueue(t, x);});
    return t;
   }
   function of_array(array){
    var t = caml_call1(create, 0);
    caml_call2(Base_Array[19], array, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    var
     t = caml_call1(create, 0),
     _f_ = caml_call2(Base_Import[93], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    return t;
   }
   function to_array(t){
    var len = caml_call1(length, t);
    if(0 === len) return [0];
    var
     _c_ = caml_call1(peek_exn, t),
     arr = caml_call2(Base_Array[47], len, _c_),
     i = [0, 0];
    caml_call2
     (iter,
      t,
      function(v){
       var _d_ = i[1];
       runtime.caml_check_bound(arr, _d_)[1 + _d_] = v;
       i[1]++;
       return 0;
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_Import[174], a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var _b_ = caml_call1(to_list, t);
    return caml_call2(Base_Import[150], sexp_of_a, _b_);
   }
   function t_sexp_grammar(grammar){
    var _a_ = caml_call1(Base_List[6], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _a_);
   }
   function singleton(a){
    var t = caml_call1(create, 0);
    enqueue(t, a);
    return t;
   }
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[257],
    hash_fold_t = Base_Import[204],
    func = Base_Import[218];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(_y_, _x_){return caml_int64_compare(_y_, _x_);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    of_string_opt = Stdlib_Int64[13],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    num_bits = 64,
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits),
    float_of_bits = runtime.caml_int64_float_of_bits,
    bits_of_float = runtime.caml_int64_bits_of_float,
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    pow = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    _a_ =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return caml_int64_of_float(f);
    var _w_ = caml_call1(Base_Float0[28], f);
    return caml_call3(Base_Printf[7], _a_, _w_, 0);
   }
   function symbol(b, e){return caml_call2(pow, b, e);}
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    _b_ = [0, "src/int64.ml", 103, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var
     _u_ = caml_lessequal(low, t),
     _v_ = _u_ ? caml_lessequal(t, high) : _u_;
    return _v_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _r_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _s_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _r_],
     _t_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _s_);
    return caml_call1(Base_Or_error[35], _t_);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(_q_){return _q_;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[11],
    to_int_exn = Base_Int_conversions[12],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[14],
    to_int32_exn = Base_Int_conversions[15],
    of_nativeint = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[17],
    to_nativeint_exn = Base_Int_conversions[18],
    raise_s = Base_Error[30],
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int64[7], x),
     x$6 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x$6, caml_int64_shift_right_unsigne(x$6, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return caml_call1(Stdlib_Int64[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_lessequal(x$0, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return caml_int64_sub(x$1, caml_int64_shift_right_unsigne(x$1, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var _p_ = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, caml_call1(Stdlib_Int64[7], x)), _p_);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _m_ = [0, [0, cst, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_floor_log2_got_inval, _m_));
    }
    var
     _n_ = runtime.Base_int_math_int64_clz(i),
     _o_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _o_, _n_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _k_ = [0, [0, cst$0, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_ceil_log2_got_invali, _k_));
    }
    if(caml_call2(Stdlib_Int64[17], i, Stdlib_Int64[2])) return 0;
    var _l_ = runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7], i));
    return caml_call2(Base_Import[93], num_bits, _l_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare$0 = Base_Import[231],
    hash_fold_t$0 = Base_Import[204],
    func$0 = Base_Import[218];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    symbol$0 = caml_lessthan,
    _d_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    _e_ = [0, [7, 6, 0, 0, 0], cst_Lx];
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[5], s, _e_, function(_j_){return _j_;});
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$3[1],
    symbol$2 = include$3[2],
    symbol$3 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[103],
    ascending = include$4[1],
    descending = include$4[2],
    max = include$4[3],
    min = include$4[4],
    Base_Int64 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(_i_, _h_){return caml_int64_compare(_i_, _h_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       of_string_opt,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_g_){return runtime.Base_int_math_int64_clz(_g_);},
       function(_f_){return runtime.Base_int_math_int64_ctz(_f_);},
       [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       of_nativeint,
       to_nativeint,
       bits_of_float,
       float_of_bits,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(29, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    _c_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    mask = runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Import[231],
    globalize = Base_Import[257],
    hash_fold_t = Base_Import[204],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[189],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    _a_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _e_ = [0, cst_src_int63_emul_ml, 115, 20];
   function wrap_exn(x){
    caml_call1(Base_Int_conversions[20], x);
    return caml_int64_mul(x, _a_);
   }
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function invariant(t){
    if(caml_equal(caml_int64_and(t, mask), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return caml_call1(Stdlib_Int64[8], x);}
   var one = wrap_exn(runtime.caml_int64_create_lo_mi_hi(1, 0, 0));
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var
    x = Stdlib_Int64[10],
    min_value = caml_int64_and(x, mask),
    x$0 = Stdlib_Int64[9],
    max_value = caml_int64_and(x$0, mask);
   function bit_not(x){
    var x$0 = caml_call1(Stdlib_Int64[11], x);
    return caml_int64_and(x$0, mask);
   }
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){
    var x$0 = caml_int64_shift_right(x, i);
    return caml_int64_and(x$0, mask);
   }
   function shift_right_logical(x, i){
    var x$0 = caml_int64_shift_right_unsigne(x, i);
    return caml_int64_and(x$0, mask);
   }
   var
    f = Base_Int_math[2][3],
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function pow(a, b){
    return caml_int64_mul
            (caml_call2
              (f, caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)),
             _d_);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a, b){
    var x = runtime.caml_int64_div(a, b);
    return caml_int64_mul(x, _c_);
   }
   var
    rem = runtime.caml_int64_mod,
    _b_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function popcount(x){return caml_call1(Base_Popcount[3], x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return caml_call1(Base_Int_conversions[21], t)
            ? [0, caml_int64_mul(t, _b_)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return caml_int64_mul(t, _c_);}
   function t_of_sexp(x){return wrap_exn(caml_call1(Base_Import[167], x));}
   function sexp_of_t$0(x){
    return caml_call1(Base_Import[143], caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return caml_call2(compare, x, y);}
   function is_pow2(x){
    return caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1));
   }
   function clz(x){return caml_call1(Base_Int64[70], x);}
   function ctz(x){
    return caml_call1(Base_Int64[71], caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[66], caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[66], caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return caml_call1(Base_Int64[68], caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return caml_call1(Base_Int64[67], caml_int64_shift_right(x, 1));
   }
   function hash(x){return caml_call1(Base_Import[85][105][28], x);}
   var
    hashable = [0, hash, compare$0, sexp_of_t$0],
    _f_ =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0);
   function invalid_str(x){return caml_call3(Base_Printf[6], _f_, x, 0);}
   function to_string(x){
    return caml_call1(Stdlib_Int64[14], caml_int64_shift_right(x, 1));
   }
   function of_string_raw(str){
    var len = caml_ml_string_length(str);
    a:
    if(0 < len){
     var switcher = caml_string_get(str, 0) - 43 | 0;
     if(2 >= switcher >>> 0)
      switch(switcher){
        case 0:
         var sign = 4003188, pos = 1; break a;
        case 1: break;
        default: var sign = 3901488, pos = 1; break a;
      }
     var sign = 4003188, pos = 0;
    }
    else
     var sign = 4003188, pos = 0;
    if(caml_call2(Base_Import[91], pos, 2) < len)
     var
      c1 = caml_string_get(str, pos),
      c2 = caml_string_get(str, caml_call2(Base_Import[91], pos, 1)),
      match = 48 === c1 ? 9 < c2 - 48 >>> 0 ? [0, , 0] : [0, , 1] : [0, , 1];
    else
     var match = [0, , 1];
    var signedness = match[2];
    if(signedness){var t = caml_int64_of_string(str); return wrap_exn(t);}
    if(4003188 <= sign)
     var pos_str = str;
    else
     var
      _w_ = caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
      pos_str = caml_call3(Base_String[3], str, 1, _w_);
    var int64 = caml_int64_of_string(pos_str);
    if(caml_lessthan(int64, _g_)) invalid_str(str);
    var int63 = caml_int64_mul(int64, _c_);
    return 4003188 <= sign ? int63 : caml_int64_neg(int63);
   }
   function of_string(str){
    try{var _u_ = of_string_raw(str); return _u_;}
    catch(_v_){return invalid_str(str);}
   }
   function of_string_opt(str){
    try{var t = of_string_raw(str);}catch(_t_){return 0;}
    return [0, t];
   }
   function bswap16(t){
    var x = caml_call1(Base_Int64[86], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   function bswap32(t){
    var x = caml_call1(Base_Int64[87], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   function bswap48(t){
    var x = caml_call1(Base_Int64[88], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   var
    num_bits = 63,
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    _h_ =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"];
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){
    var x$0 = caml_int64_of_float(x);
    return caml_int64_mul(x$0, _c_);
   }
   function of_float(t){
    if
     (caml_call2(Base_Import[108][6], t, float_lower_bound)
      && caml_call2(Base_Import[108][2], t, float_upper_bound)){
     var x = caml_int64_of_float(t);
     return caml_int64_mul(x, _c_);
    }
    var _s_ = caml_call1(Base_Float0[28], t);
    return caml_call3(Base_Printf[7], _h_, _s_, 0);
   }
   var
    _i_ = caml_call1(Base_Comparable[14], [0, compare$0, sexp_of_t$0, zero]),
    is_positive = _i_[1],
    is_non_negative = _i_[2],
    is_negative = _i_[3],
    is_non_positive = _i_[4],
    sign = _i_[5],
    _j_ = [0, cst_src_int63_emul_ml, 328, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function between(t, low, high){
    var
     _q_ = caml_lessequal(low, t),
     _r_ = _q_ ? caml_lessequal(t, high) : _q_;
    return _r_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _n_ = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     _o_ = [0, [0, cst_min, sexp_of_t$0(min)], _n_],
     _p_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _o_);
    return caml_call1(Base_Or_error[35], _p_);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){var x = r[1]; r[1] = caml_int64_add(x, one$0); return 0;}
   function decr(r){var x = r[1]; r[1] = caml_int64_sub(x, one$0); return 0;}
   function of_int(x){
    return wrap_exn(caml_call1(Base_Int_conversions[4], x));
   }
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return caml_call1(Base_Int_conversions[11], caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return caml_call1(Base_Int_conversions[12], caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return caml_call1(Base_Int_conversions[13], caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(caml_call1(Base_Int_conversions[9], x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return caml_call1(Base_Int_conversions[14], caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return caml_call1(Base_Int_conversions[15], caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return caml_call1(Base_Int_conversions[16], caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_trunc(x){
    var t = caml_call1(Base_Int_conversions[28], x);
    return caml_int64_mul(t, _c_);
   }
   function to_nativeint(x){
    return caml_call1(Base_Int_conversions[17], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return caml_call1(Base_Int_conversions[18], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return caml_call1(Base_Int_conversions[19], caml_int64_shift_right(x, 1));
   }
   var
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$1 = include$0[2];
   function hash$0(x){return hash(x);}
   var
    symbol$5 = caml_lessthan,
    _k_ = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_0x = "0x";
   function to_string$0(i){
    return caml_call2
            (Base_Printf[2], _k_, caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(caml_call2(Base_Import[112], cst_0x, s));
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$1[1];
   function to_string$1(x){return to_string(x);}
   var
    pp =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$2 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    round = include$2[4],
    round_towards_zero = include$2[5],
    round_down = include$2[6],
    round_up = include$2[7],
    round_nearest = include$2[8],
    Repr = [0],
    include$3 = Base_Import[103],
    ascending = include$3[1],
    descending = include$3[2],
    max = include$3[3],
    min = include$3[4],
    Base_Int63_emul =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(_m_, _l_){return runtime.caml_int64_compare(_m_, _l_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       of_string_opt,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       [0,
        symbol,
        symbol$0,
        symbol$2,
        symbol$3,
        symbol$1,
        symbol$4,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$1,
        zero,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       [0, wrap_exn, unwrap],
       Repr,
       1];
   runtime.caml_register_global(33, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[256],
    hash_fold_t = Base_Import[205],
    func = Base_Import[219];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return caml_call2(Stdlib_Int32[15], x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Int32[13],
    include = caml_call1(Base_Comparator[5], [0, ascending, sexp_of_t]),
    comparator = include[1],
    num_bits = 32,
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float;
   function shift_right_logical(_O_, _N_){return _O_ >>> _N_ | 0;}
   function shift_right(_M_, _L_){return _M_ >> _L_;}
   function shift_left(_K_, _J_){return _K_ << _J_;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(_I_, _H_){return _I_ ^ _H_;}
   function bit_or(_G_, _F_){return _G_ | _F_;}
   function bit_and(_E_, _D_){return _E_ & _D_;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(_C_){return - _C_ | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1],
    _a_ =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function to_float(_B_){return _B_;}
   function of_float_unchecked(_A_){return _A_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return f | 0;
    var _z_ = caml_call1(Base_Float0[28], f);
    return caml_call3(Base_Printf[7], _a_, _z_, 0);
   }
   var
    include$0 =
      caml_call1(Base_Comparable[14], [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = runtime.caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = caml_lessthan,
    symbol$5 = runtime.caml_notequal,
    _b_ = [0, "src/int32.ml", 100, 4],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function descending(x, y){return ascending(y, x);}
   function min(x, y){return caml_lessthan(x, y) ? x : y;}
   function max(x, y){return caml_greaterthan(x, y) ? x : y;}
   function equal(x, y){return caml_equal(x, y);}
   function between(t, low, high){
    var _y_ = caml_lessequal(low, t);
    return _y_ ? caml_lessequal(t, high) : _y_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _v_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _w_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _v_],
     _x_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _w_);
    return caml_call1(Base_Or_error[35], _x_);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(_u_, _t_){return _u_ - _t_ | 0;}
   function symbol$9(_s_, _r_){return _s_ + _r_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[14],
    of_int64_exn = Base_Int_conversions[15],
    of_int64_trunc = Base_Int_conversions[16],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[25],
    of_nativeint_exn = Base_Int_conversions[26],
    of_nativeint_trunc = Base_Int_conversions[27],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var _p_ = caml_call1(to_int_exn, e), _q_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _q_, _p_));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var
    raise_s = Base_Error[30],
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int32[7], x),
     x$5 = x$0 | x$0 >>> 1 | 0,
     x$4 = x$5 | x$5 >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return caml_call1(Stdlib_Int32[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_call2(Base_Import[102][2], x$0, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$4 = x | x >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var _o_ = Stdlib_Int32[1], _n_ = x & caml_call1(Stdlib_Int32[7], x);
    return caml_call2(Base_Import[102][4], _n_, _o_);
   }
   function floor_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _k_ = [0, [0, cst, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_floor_log2_got_inval, _k_));
    }
    var
     _l_ = runtime.Base_int_math_int32_clz(i),
     _m_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _m_, _l_);
   }
   function ceil_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _i_ = [0, [0, cst$0, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_ceil_log2_got_invali, _i_));
    }
    if(caml_call2(Stdlib_Int32[17], i, Stdlib_Int32[2])) return 0;
    var _j_ = runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7], i));
    return caml_call2(Base_Import[93], num_bits, _j_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare = Base_Import[230],
    hash_fold_t$0 = Base_Import[205],
    func$0 = Base_Import[219],
    _d_ = [0, [5, 6, 0, 0, 0], cst_lx],
    _e_ = [0, [5, 6, 0, 0, 0], cst_lx];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[5], s, _e_, function(_h_){return _h_;});
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$3[1],
    symbol$12 = include$3[2],
    symbol$13 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    Base_Int32 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       of_string_opt,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_g_){return runtime.Base_int_math_int32_clz(_g_);},
       function(_f_){return runtime.Base_int_math_int32_ctz(_f_);},
       [0,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        symbol,
        symbol$10,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        abs,
        symbol,
        zero,
        symbol$11,
        symbol$12,
        symbol$13,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       caml_int32_bswap];
   runtime.caml_register_global(29, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Word_size
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[30],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    _b_ = [0, "src/int63.ml", 161, 9],
    repr = Base_Word_size[3] ? 0 : 1,
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    invariant = Base_Int[30],
    Hex = Base_Int[31],
    of_string_opt = Base_Int[32],
    to_string_hum = Base_Int[33],
    one = Base_Int[34],
    minus_one = Base_Int[35],
    rem = Base_Int[36],
    round = Base_Int[37],
    round_towards_zero = Base_Int[38],
    round_down = Base_Int[39],
    round_up = Base_Int[40],
    round_nearest = Base_Int[41],
    succ = Base_Int[42],
    pred = Base_Int[43],
    pow = Base_Int[44],
    bit_and = Base_Int[45],
    bit_or = Base_Int[46],
    bit_xor = Base_Int[47],
    bit_not = Base_Int[48],
    popcount = Base_Int[49],
    shift_left = Base_Int[50],
    shift_right = Base_Int[51],
    decr = Base_Int[52],
    incr = Base_Int[53],
    of_int32_exn = Base_Int[54],
    to_int32_exn = Base_Int[55],
    of_int64_exn = Base_Int[56],
    to_int64 = Base_Int[57],
    of_nativeint_exn = Base_Int[58],
    to_nativeint_exn = Base_Int[59],
    of_float_unchecked = Base_Int[60],
    num_bits = Base_Int[61],
    max_value = Base_Int[62],
    min_value = Base_Int[63],
    shift_right_logical = Base_Int[64],
    ceil_pow2 = Base_Int[65],
    floor_pow2 = Base_Int[66],
    ceil_log2 = Base_Int[67],
    is_pow2 = Base_Int[69],
    clz = Base_Int[70],
    ctz = Base_Int[71],
    O = Base_Int[72],
    symbol = Base_Int[73],
    lnot = Base_Int[74],
    abs = Base_Int[75],
    zero = Base_Int[76],
    symbol$0 = Base_Int[77],
    symbol$1 = Base_Int[78],
    symbol$2 = Base_Int[79],
    of_int = Base_Int[81],
    to_int32 = Base_Int[84],
    of_int64 = Base_Int[85],
    of_nativeint = Base_Int[86],
    _a_ = Base_Int[87];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return caml_call1(_a_, x);}
   function to_nativeint(x){return [0, caml_call1(_a_, x)];}
   function bswap32(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[87], caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[88], caml_int64_of_int32(t)));
   }
   var
    repr$0 = 0,
    include =
      repr
       ? [0,
         Base_Int63_emul[2],
         Base_Int63_emul[3],
         Base_Int63_emul[4],
         Base_Int63_emul[5],
         Base_Int63_emul[6],
         Base_Int63_emul[7],
         Base_Int63_emul[8],
         Base_Int63_emul[9],
         Base_Int63_emul[10],
         Base_Int63_emul[11],
         Base_Int63_emul[12],
         Base_Int63_emul[13],
         Base_Int63_emul[14],
         Base_Int63_emul[15],
         Base_Int63_emul[16],
         Base_Int63_emul[17],
         Base_Int63_emul[18],
         Base_Int63_emul[19],
         Base_Int63_emul[20],
         Base_Int63_emul[21],
         Base_Int63_emul[22],
         Base_Int63_emul[23],
         Base_Int63_emul[24],
         Base_Int63_emul[25],
         Base_Int63_emul[26],
         Base_Int63_emul[27],
         Base_Int63_emul[28],
         Base_Int63_emul[29],
         Base_Int63_emul[30],
         Base_Int63_emul[31],
         Base_Int63_emul[32],
         Base_Int63_emul[33],
         Base_Int63_emul[34],
         Base_Int63_emul[35],
         Base_Int63_emul[36],
         Base_Int63_emul[37],
         Base_Int63_emul[38],
         Base_Int63_emul[39],
         Base_Int63_emul[40],
         Base_Int63_emul[41],
         Base_Int63_emul[42],
         Base_Int63_emul[43],
         Base_Int63_emul[44],
         Base_Int63_emul[45],
         Base_Int63_emul[46],
         Base_Int63_emul[47],
         Base_Int63_emul[48],
         Base_Int63_emul[49],
         Base_Int63_emul[50],
         Base_Int63_emul[51],
         Base_Int63_emul[52],
         Base_Int63_emul[53],
         Base_Int63_emul[54],
         Base_Int63_emul[55],
         Base_Int63_emul[56],
         Base_Int63_emul[57],
         Base_Int63_emul[58],
         Base_Int63_emul[59],
         Base_Int63_emul[60],
         Base_Int63_emul[61],
         Base_Int63_emul[62],
         Base_Int63_emul[63],
         Base_Int63_emul[64],
         Base_Int63_emul[65],
         Base_Int63_emul[66],
         Base_Int63_emul[67],
         Base_Int63_emul[68],
         Base_Int63_emul[69],
         Base_Int63_emul[70],
         Base_Int63_emul[71],
         Base_Int63_emul[72],
         Base_Int63_emul[73],
         Base_Int63_emul[74],
         Base_Int63_emul[75],
         Base_Int63_emul[76],
         Base_Int63_emul[77],
         Base_Int63_emul[78],
         Base_Int63_emul[79],
         Base_Int63_emul[80],
         Base_Int63_emul[81],
         Base_Int63_emul[82],
         Base_Int63_emul[83],
         Base_Int63_emul[85],
         Base_Int63_emul[86],
         Base_Int63_emul[87],
         Base_Int63_emul[88],
         Base_Int63_emul[89],
         Base_Int63_emul[90],
         Base_Int63_emul[91],
         Base_Int63_emul[92],
         ,
         Base_Int63_emul[94],
         Base_Int63_emul[95],
         Base_Int63_emul[96],
         Base_Int63_emul[97],
         Base_Int63_emul[98],
         Base_Int63_emul[99],
         Base_Int63_emul[100],
         Base_Int63_emul[101],
         Base_Int63_emul[102],
         Base_Int63_emul[103],
         Base_Int63_emul[104],
         Base_Int63_emul[105],
         Base_Int63_emul[106],
         Base_Int63_emul[107],
         Base_Int63_emul[108],
         Base_Int63_emul[109],
         Base_Int63_emul[84],
         Base_Int63_emul[115],
         Base_Int63_emul[110],
         Base_Int63_emul[111],
         Base_Int63_emul[112]]
       : [0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_aG_, _aF_){return _aF_ <= _aG_ ? 1 : 0;},
         function(_aE_, _aD_){return _aE_ <= _aD_ ? 1 : 0;},
         function(_aC_, _aB_){return _aC_ === _aB_ ? 1 : 0;},
         function(_aA_, _az_){return _az_ < _aA_ ? 1 : 0;},
         function(_ay_, _ax_){return _ay_ < _ax_ ? 1 : 0;},
         function(_aw_, _av_){return _aw_ !== _av_ ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         of_string_opt,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(_au_, _at_){return _au_ + _at_ | 0;},
         function(_as_, _ar_){return _as_ - _ar_ | 0;},
         caml_mul,
         symbol,
         function(_aq_){return - _aq_ | 0;},
         function(_ap_){return - _ap_ | 0;},
         symbol$1,
         symbol$0,
         caml_div,
         rem,
         symbol$2,
         function(_ao_, _an_){return _ao_ & _an_;},
         function(_am_, _al_){return _am_ | _al_;},
         function(_ak_, _aj_){return _ak_ ^ _aj_;},
         lnot,
         function(_ai_, _ah_){return _ai_ << _ah_;},
         function(_ag_, _af_){return _ag_ >> _af_;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         num_bits,
         max_value,
         min_value,
         function(_ae_, _ad_){return _ae_ >>> _ad_ | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         ,
         is_pow2,
         clz,
         ctz,
         [0,
          function(_ac_, _ab_){return _ac_ + _ab_ | 0;},
          function(_aa_, _$_){return _aa_ - _$_ | 0;},
          caml_mul,
          caml_div,
          function(___){return - ___ | 0;},
          O[1],
          function(_Z_, _Y_){return _Y_ <= _Z_ ? 1 : 0;},
          function(_X_, _W_){return _X_ <= _W_ ? 1 : 0;},
          function(_V_, _U_){return _V_ === _U_ ? 1 : 0;},
          function(_T_, _S_){return _S_ < _T_ ? 1 : 0;},
          function(_R_, _Q_){return _R_ < _Q_ ? 1 : 0;},
          function(_P_, _O_){return _P_ !== _O_ ? 1 : 0;},
          O[3],
          function(_N_){return - _N_ | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(_M_, _L_){return _M_ & _L_;},
          function(_K_, _J_){return _K_ | _J_;},
          function(_I_, _H_){return _I_ ^ _H_;},
          O[2],
          function(_G_, _F_){return _G_ << _F_;},
          function(_E_, _D_){return _E_ >> _D_;},
          function(_C_, _B_){return _C_ >>> _B_ | 0;}],
         of_int,
         to_int,
         to_int_trunc,
         of_int32_exn,
         to_int32,
         function(_A_){return _A_;},
         of_int64,
         caml_int64_to_int32,
         of_nativeint,
         to_nativeint,
         function(_z_){return _z_;},
         to_nativeint_trunc,
         of_float_unchecked,
         repr$0,
         runtime.caml_bswap16,
         bswap32,
         bswap48],
    t_sexp_grammar$0 = include[1],
    of_float$0 = include[2],
    to_float$0 = include[3],
    of_int_exn$0 = include[4],
    to_int_exn$0 = include[5],
    hash_fold_t$0 = include[6],
    hash$0 = include[7],
    t_of_sexp$0 = include[8],
    sexp_of_t$0 = include[9],
    of_string$0 = include[10],
    to_string$0 = include[11],
    symbol$3 = include[12],
    symbol$4 = include[13],
    symbol$5 = include[14],
    symbol$6 = include[15],
    symbol$7 = include[16],
    symbol$8 = include[17],
    equal$0 = include[18],
    compare$0 = include[19],
    min$0 = include[20],
    max$0 = include[21],
    ascending$0 = include[22],
    descending$0 = include[23],
    between$0 = include[24],
    clamp_exn$0 = include[25],
    clamp$0 = include[26],
    comparator$0 = include[27],
    pp$0 = include[28],
    hashable$0 = include[29],
    is_positive$0 = include[30],
    is_non_negative$0 = include[31],
    is_negative$0 = include[32],
    is_non_positive$0 = include[33],
    sign$0 = include[34],
    invariant$0 = include[35],
    Hex$0 = include[36],
    of_string_opt$0 = include[37],
    to_string_hum$0 = include[38],
    zero$0 = include[39],
    one$0 = include[40],
    minus_one$0 = include[41],
    symbol$9 = include[42],
    symbol$10 = include[43],
    symbol$11 = include[44],
    symbol$12 = include[45],
    neg = include[46],
    symbol$13 = include[47],
    symbol$14 = include[48],
    symbol$15 = include[49],
    symbol$16 = include[50],
    rem$0 = include[51],
    symbol$17 = include[52],
    land = include[53],
    lor = include[54],
    lxor = include[55],
    lnot$0 = include[56],
    lsl = include[57],
    asr = include[58],
    round$0 = include[59],
    round_towards_zero$0 = include[60],
    round_down$0 = include[61],
    round_up$0 = include[62],
    round_nearest$0 = include[63],
    abs$0 = include[64],
    succ$0 = include[65],
    pred$0 = include[66],
    pow$0 = include[67],
    bit_and$0 = include[68],
    bit_or$0 = include[69],
    bit_xor$0 = include[70],
    bit_not$0 = include[71],
    popcount$0 = include[72],
    shift_left$0 = include[73],
    shift_right$0 = include[74],
    decr$0 = include[75],
    incr$0 = include[76],
    of_int32_exn$0 = include[77],
    to_int32_exn$0 = include[78],
    of_int64_exn$0 = include[79],
    to_int64$0 = include[80],
    of_nativeint_exn$0 = include[81],
    to_nativeint_exn$0 = include[82],
    num_bits$0 = include[83],
    max_value$0 = include[84],
    min_value$0 = include[85],
    lsr = include[86],
    shift_right_logical$0 = include[87],
    ceil_pow2$0 = include[88],
    floor_pow2$0 = include[89],
    ceil_log2$0 = include[90],
    is_pow2$0 = include[92],
    clz$0 = include[93],
    ctz$0 = include[94],
    O$0 = include[95],
    of_int$0 = include[96],
    to_int$0 = include[97],
    to_int_trunc$0 = include[98],
    of_int32 = include[99],
    to_int32$0 = include[100],
    to_int32_trunc = include[101],
    of_int64$0 = include[102],
    of_int64_trunc = include[103],
    of_nativeint$0 = include[104],
    to_nativeint$0 = include[105],
    of_nativeint_trunc = include[106],
    to_nativeint_trunc$0 = include[107],
    of_float_unchecked$0 = include[108],
    repr$1 = include[109],
    bswap16 = include[110],
    bswap32$0 = include[111],
    bswap48$0 = include[112];
   function symbol$18(t, u){
    var
     sum = caml_call2(symbol$9, t, u),
     _v_ = caml_call2(bit_xor$0, t, caml_call1(bit_not$0, sum));
    if
     (caml_call2
       (symbol$7,
        caml_call2(bit_or$0, caml_call2(bit_xor$0, t, u), _v_),
        zero$0))
     return sum;
    var
     _w_ = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     _x_ = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], _w_],
     _y_ = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], _x_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow, _y_));
   }
   function symbol$19(t, u){
    var
     diff = caml_call2(symbol$10, t, u),
     pos_diff = caml_call2(symbol$6, t, u);
    if(caml_call2(symbol$8, t, u)){
     var _r_ = caml_call1(is_positive$0, diff);
     if(caml_call2(Base_Bool[15], pos_diff, _r_)){
      var
       _s_ = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       _t_ = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], _s_],
       _u_ = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], _t_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[9], cst_overflow$0, _u_));
     }
    }
    return diff;
   }
   var negative_one = caml_call1(of_int$0, -1);
   function div_would_overflow(t, u){
    var _q_ = caml_call2(symbol$5, t, min_value$0);
    return _q_ ? caml_call2(symbol$5, u, negative_one) : _q_;
   }
   function symbol$20(t, u){
    var product = caml_call2(symbol$11, t, u);
    a:
    if(caml_call2(symbol$8, u, zero$0)){
     if
      (!
       div_would_overflow(product, u)
       && ! caml_call2(symbol$8, caml_call2(symbol$16, product, u), t))
      break a;
     var
      _n_ = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
      _o_ = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], _n_],
      _p_ = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], _o_];
     return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$1, _p_));
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return caml_call2(symbol$16, t, u);
    var
     _k_ =
       [0,
        [0,
         cst_product$0,
         caml_call1(sexp_of_t$0, caml_call2(symbol$16, t, u))],
        0],
     _l_ = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], _k_],
     _m_ = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], _l_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$2, _m_));
   }
   function abs$1(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_abs_overflow)
            : caml_call1(abs$0, t);
   }
   function neg$0(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_neg_overflow)
            : caml_call1(neg, t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   function random_of_int(opt, bound){
    var
     state = opt ? opt[1] : Base_Random[18][1],
     _j_ = caml_call1(to_int_exn$0, bound);
    return caml_call1(of_int$0, caml_call2(Base_Random[18][6], state, _j_));
   }
   function random_of_int64(opt, bound){
    var
     state = opt ? opt[1] : Base_Random[18][1],
     _i_ = caml_call1(to_int64$0, bound);
    return caml_call1
            (of_int64_exn$0, caml_call2(Base_Random[18][9], state, _i_));
   }
   var random_of_int$0 = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    var
     state = opt ? opt[1] : Base_Random[18][1],
     _g_ = caml_call1(to_int_exn$0, hi),
     _h_ = caml_call1(to_int_exn$0, lo);
    return caml_call1
            (of_int$0, caml_call3(Base_Random[18][11], state, _h_, _g_));
   }
   function random_incl_of_int64(opt, lo, hi){
    var
     state = opt ? opt[1] : Base_Random[18][1],
     _e_ = caml_call1(to_int64$0, hi),
     _f_ = caml_call1(to_int64$0, lo);
    return caml_call1
            (of_int64_exn$0, caml_call3(Base_Random[18][14], state, _f_, _e_));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2(t){
    if(Base_Word_size[3]){
     var _c_ = caml_call1(to_int_exn$0, t);
     return caml_call1(Base_Int[68], _c_);
    }
    if(caml_call2(symbol$4, t, zero$0)){
     var _d_ = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _d_));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if
      (!
       caml_call2
        (equal$0,
         zero$0,
         caml_call2
          (bit_and$0, t, caml_call2(shift_left$0, one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       invariant$0,
       Hex$0,
       of_string_opt$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random_of_int$0,
       random_incl,
       floor_log2,
       [0, Base_Int63_emul[114], repr$1]];
   runtime.caml_register_global(31, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Merge_into_action = [0],
    Base_Hashtbl_intf = [0, Key, Merge_into_action];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Base__Error, Base__Import, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30];
   function max(x, y){return y < x ? x : y;}
   var
    _a_ = [0, cst_src_avltree_ml, 50, 6],
    _b_ = [0, cst_src_avltree_ml, 56, 6],
    _c_ = [0, cst_src_avltree_ml, 67, 6],
    _d_ = [0, cst_src_avltree_ml, 66, 6],
    _e_ = [0, cst_src_avltree_ml, 87, 22],
    _f_ = [0, cst_src_avltree_ml, 110, 26],
    _g_ = [0, cst_src_avltree_ml, 129, 30],
    _h_ = [0, cst_src_avltree_ml, 145, 26],
    _i_ = [0, cst_src_avltree_ml, 163, 30],
    _j_ = [0, cst_src_avltree_ml, 193, 9],
    _k_ = [0, cst_src_avltree_ml, 205, 9],
    _l_ = [0, cst_src_avltree_ml, 417, 15],
    _m_ = [0, cst_src_avltree_ml, 436, 18],
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl",
    dummy = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      if(typeof left !== "number"){
       var left_key = 0 === left[0] ? left[2] : left[1];
       if(0 <= caml_call2(compare, left_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      if(typeof right !== "number"){
       var right_key = 0 === right[0] ? right[2] : right[1];
       if(0 >= caml_call2(compare, right_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      var _B_ = max(hl, hr);
      if(h !== caml_call2(Base_Import[91], _B_, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var _C_ = caml_call2(Base_Import[93], hl, hr);
      if(2 < caml_call1(Base_Import[123], _C_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(x){
    if(typeof x !== "number" && 0 === x[0]){
     var
      left = x[1],
      old_height = x[4],
      right = x[5],
      _z_ = height(right),
      _A_ = max(height(left), _z_),
      new_height = caml_call2(Base_Import[91], _A_, 1);
     if(new_height !== old_height) x[4] = new_height;
     return;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left_node = root_node[1],
      right_node = root_node[5],
      hl = height(left_node),
      hr = height(right_node);
     if(caml_call2(Base_Import[91], hr, 2) < hl){
      if(typeof left_node !== "number" && 0 === left_node[0]){
       var
        left_node_left = left_node[1],
        left_node_right = left_node[5],
        _x_ = height(left_node_right);
       if(_x_ <= height(left_node_left)){
        root_node[1] = left_node_right;
        left_node[5] = root_node;
        update_height(root_node);
        update_height(left_node);
        return left_node;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left_node[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left_node;
        update_height(left_node);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     if(caml_call2(Base_Import[91], hl, 2) >= hr){update_height(root_node); return root_node;
     }
     if(typeof right_node !== "number" && 0 === right_node[0]){
      var
       right_node_left = right_node[1],
       right_node_right = right_node[5],
       _y_ = height(right_node_left);
      if(_y_ <= height(right_node_right)){
       root_node[5] = right_node_left;
       right_node[1] = root_node;
       update_height(root_node);
       update_height(right_node);
       return right_node;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right_node[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right_node;
       update_height(right_node);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    return root_node;
   }
   function set_left(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var left = node[1];
     if(! caml_call2(Base_Import[128], left, tree$0)) node[1] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function set_right(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var right = node[5];
     if(! caml_call2(Base_Import[128], right, tree$0)) node[5] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function add(t, replace, added, compare, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){
     added[1] = 0;
     if(replace) t[3] = v;
    }
    else if(0 <= c)
     set_right(t, add(right, replace, added, compare, k, v));
    else
     set_left(t, add(left, replace, added, compare, k, v));
    return t;
   }
   function add$0(t, replace, compare, added, key, data){
    var t$0 = add(t, replace, added, compare, key, data);
    return added[1] ? balance(t$0) : t$0;
   }
   function first(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var l = t$0[1];
      if(typeof l !== "number"){t$0 = l; continue;}
      var v = t$0[3], k = t$0[2];
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var _v_ = t$0[2], _w_ = t$0[3];
      if(typeof t$0[5] !== "number"){var r = t$0[5]; t$0 = r; continue;}
      var v = _w_, k = _v_;
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function findi_and_call_impl
   (t,
    compare,
    k,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     if(0 !== t$0[0]){
      var k$1 = t$0[1], v$0 = t$0[2];
      return 0 === caml_call2(compare, k, k$1)
              ? caml_call5(call_if_found, if_found, k$1, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     }
     var
      left = t$0[1],
      k$0 = t$0[2],
      v = t$0[3],
      right = t$0[5],
      c = caml_call2(compare, k, k$0);
     if(0 === c)
      return caml_call5(call_if_found, if_found, k$0, v, arg1, arg2);
     var right$0 = 0 <= c ? right : left;
     t$0 = right$0;
    }
   }
   function call_if_found(if_found, _u_, data, _t_, param){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, _s_, param){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, _r_, param){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, _q_, param){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, _p_, data, arg, param){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(0 === left[0]){set_left(tree, remove_min_elt(left)); return tree;}
    var k = tree[2], v = tree[3];
    return typeof tree[5] === "number" ? [1, k, v] : (set_left(tree, 0), tree);
   }
   function remove(t, removed, compare, k$0){
    if(typeof t === "number"){removed[1] = 0; return 0;}
    if(0 !== t[0]){
     var k$2 = t[1];
     return 0 === caml_call2(compare, k$0, k$2)
             ? (removed[1] = 1, 0)
             : (removed[1] = 0, t);
    }
    var
     left$0 = t[1],
     k$1 = t[2],
     right = t[5],
     c = caml_call2(compare, k$0, k$1);
    if(0 !== c)
     return 0 <= c
             ? (set_right(t, remove(right, removed, compare, k$0)), t)
             : (set_left(t, remove(left$0, removed, compare, k$0)), t);
    removed[1] = 1;
    if(typeof left$0 === "number") return right;
    if(typeof right === "number") return left$0;
    var tree = right;
    for(;;){
     if(typeof tree === "number")
      var tree$0 = 0;
     else if(0 === tree[0]){
      var left = tree[1];
      if(typeof left !== "number"){tree = left; continue;}
      var tree$0 = tree;
     }
     else
      var tree$0 = tree;
     if(typeof tree$0 === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     if(0 === tree$0[0]){
      set_right(tree$0, remove_min_elt(right));
      set_left(tree$0, left$0);
      return tree$0;
     }
     var
      k = tree$0[1],
      v = tree$0[2],
      t2 = balance(remove_min_elt(right)),
      _n_ = height(t2),
      _o_ = max(height(left$0), _n_);
     return [0, left$0, k, v, caml_call2(Base_Import[91], _o_, 1), t2];
    }
   }
   function remove$0(t, removed, compare, k){
    return balance(remove(t, removed, compare, k));
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 !== t$0[0]){
      var key$4 = t$0[1], data$4 = t$0[2];
      return caml_call3(f, key$4, data$4, init$0);
     }
     var left = t$0[1];
     if(typeof left === "number"){
      var key = t$0[2], data = t$0[3], match = t$0[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init$0));
      }
     }
     else{
      if(0 === left[0]){
       var key$1 = t$0[2], data$1 = t$0[3], match$0 = t$0[5];
       if(typeof match$0 !== "number" && 0 !== match$0[0]){
        var rkey$0 = match$0[1], rdata$0 = match$0[2];
        return caml_call3
                (f,
                 rkey$0,
                 rdata$0,
                 caml_call3(f, key$1, data$1, fold(left, init$0, f)));
       }
      }
      else{
       var
        lkey$0 = left[1],
        ldata$0 = left[2],
        key$3 = t$0[2],
        data$3 = t$0[3],
        match$1 = t$0[5];
       if(typeof match$1 === "number")
        return caml_call3
                (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0));
       if(0 !== match$1[0]){
        var rkey$1 = match$1[1], rdata$1 = match$1[2];
        return caml_call3
                (f,
                 rkey$1,
                 rdata$1,
                 caml_call3
                  (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0)));
       }
      }
      if(typeof left !== "number" && 1 === left[0]){
       var
        lkey = left[1],
        ldata = left[2],
        key$2 = t$0[2],
        data$2 = t$0[3],
        right$0 = t$0[5],
        init$2 =
          caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init$0));
       t$0 = right$0;
       init$0 = init$2;
       continue;
      }
     }
     var
      key$0 = t$0[2],
      data$0 = t$0[3],
      right = t$0[5],
      init$1 = caml_call3(f, key$0, data$0, fold(left, init$0, f));
     t$0 = right;
     init$0 = init$1;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], data$0 = t$0[2];
      return caml_call2(f, key$0, data$0);
     }
     var left = t$0[1], key = t$0[2], data = t$0[3], right = t$0[5];
     iter(left, f);
     caml_call2(f, key, data);
     t$0 = right;
    }
   }
   function mapi_inplace(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], value$0 = t$0[2];
      t$0[2] = caml_call2(f, key$0, value$0);
      return 0;
     }
     var left = t$0[1], key = t$0[2], value = t$0[3], right = t$0[5];
     mapi_inplace(left, f);
     t$0[3] = caml_call2(f, key, value);
     t$0 = right;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       0,
       is_empty,
       invariant,
       add$0,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove$0,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(18, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Random, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Random = global_data.Base__Random,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[30],
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[4][3];}
   function compare_key(t){return t[4][2];}
   function ensure_mutation_allowed(t){
    var _aA_ = 1 - t[5];
    return _aA_
            ? caml_call1(Base_Import[124], cst_Hashtbl_mutation_not_allow)
            : _aA_;
   }
   function without_mutating(t, f){
    if(! t[5]) return caml_call1(f, 0);
    t[5] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = 1;
    return x;
   }
   var
    max_table_length = caml_call1(Base_Int[66], Base_Array[46]),
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    cst_Hashtbl_choose_randomly_ex =
      "[Hashtbl.choose_randomly_exn] of empty hashtbl",
    _a_ = [0, cst_src_hashtbl_ml, 333, 2],
    _b_ = [0, "Hashtbl.find_exn: not found"],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    _c_ = [0, cst_src_hashtbl_ml, 584, 4],
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values";
   function create(_ay_, opt, hashable, param){
    var
     growth_allowed = _ay_ ? _ay_[1] : 1,
     size = opt ? opt[1] : 0,
     _az_ = caml_call2(Base_Int[16], 1, size),
     size$0 = caml_call2(Base_Int[15], _az_, max_table_length),
     size$1 = caml_call1(Base_Int[65], size$0);
    return [0,
            caml_call2(Base_Array[47], size$1, Base_Avltree[1]),
            0,
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[4][1], key),
     _ax_ = caml_call2(Base_Import[93], t[1].length - 1, 1);
    return caml_call2(Base_Import[116], hash, _ax_);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added = [0, 0],
     _aw_ = compare_key(t),
     new_root =
       caml_call6(Base_Avltree[4], root, replace, _aw_, added, key, data);
    if(added[1]) t[2] = caml_call2(Base_Import[91], t[2], 1);
    if(1 - caml_call2(Base_Import[128], new_root, root))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    return added[1];
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     _an_ = should_grow ? t[3] : should_grow;
    if(_an_){
     var
      _ao_ = caml_call2(Base_Import[88], len, 2),
      new_array_length = caml_call2(Base_Int[15], _ao_, max_table_length),
      _ap_ = len < new_array_length ? 1 : 0;
     if(_ap_){
      var
       new_table =
         caml_call2(Base_Array[47], new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){add_worker(t, 1, key, data); return 0;},
       _ar_ = caml_call2(Base_Import[93], old_table.length - 1, 1),
       _aq_ = 0;
      if(_ar_ >= 0){
       var i = _aq_;
       for(;;){
        var _au_ = caml_check_bound(old_table, i)[1 + i];
        caml_call2(Base_Avltree[17], _au_, f);
        var _av_ = i + 1 | 0;
        if(_ar_ === i) break;
        i = _av_;
       }
      }
      var _as_ = 0;
     }
     else
      var _as_ = _ap_;
     var _at_ = _as_;
    }
    else
     var _at_ = _an_;
    return _at_;
   }
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    var added = add_worker(t, 0, key, data);
    return added ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Hashtbl_add_exn_got_key_al,
         key,
         sexp_of_key$0);
    return caml_call1(Base_Error[29], error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var _ak_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      var _al_ = Base_Avltree[1];
      caml_check_bound(t[1], i)[1 + i] = _al_;
      var _am_ = i + 1 | 0;
      if(_ak_ === i) break;
      i = _am_;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var _ah_ = slot(t, key), tree = caml_check_bound(t[1], _ah_)[1 + _ah_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ai_ = compare_key(t);
     return caml_call5
             (Base_Avltree[8], tree, _ai_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var _af_ = slot(t, key), tree = caml_check_bound(t[1], _af_)[1 + _af_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _ag_ = compare_key(t);
     return caml_call6
             (Base_Avltree[9], tree, _ag_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var _ad_ = slot(t, key), tree = caml_check_bound(t[1], _ad_)[1 + _ad_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _ae_ = compare_key(t);
     return caml_call7
             (Base_Avltree[10], tree, _ae_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var _ab_ = slot(t, key), tree = caml_check_bound(t[1], _ab_)[1 + _ab_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ac_ = compare_key(t);
     return caml_call5
             (Base_Avltree[11], tree, _ac_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var _$_ = slot(t, key), tree = caml_check_bound(t[1], _$_)[1 + _$_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _aa_ = compare_key(t);
     return caml_call6
             (Base_Avltree[12], tree, _aa_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var _Z_ = slot(t, key), tree = caml_check_bound(t[1], _Z_)[1 + _Z_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var ___ = compare_key(t);
     return caml_call7
             (Base_Avltree[13], tree, ___, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var _X_ = slot(t, key), tree = caml_check_bound(t[1], _X_)[1 + _X_];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var _Y_ = compare_key(t);
     return caml_call3(Base_Avltree[14], tree, _Y_, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added_or_removed = [0, 0],
     _U_ = compare_key(t),
     new_root = caml_call4(Base_Avltree[15], root, added_or_removed, _U_, key);
    if(1 - caml_call2(Base_Import[128], root, new_root))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    var
     _V_ = added_or_removed[1],
     _W_ = _V_ ? (t[2] = caml_call2(Base_Import[93], t[2], 1), 0) : _V_;
    return _W_;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[5];
    try{
     t[5] = 0;
     var _S_ = caml_call2(Base_Import[93], n, 1), _R_ = 0;
     if(_S_ >= 0){
      var i = _R_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = caml_call3(Base_Avltree[16], bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var _T_ = i + 1 | 0;
       if(_S_ === i) break;
       i = _T_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[5];
    try{
     t[5] = 0;
     var _P_ = caml_call2(Base_Import[93], n, 1), _O_ = 0;
     if(_P_ >= 0){
      var i = _O_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         caml_call2(Base_Avltree[17], bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var _Q_ = i + 1 | 0;
       if(_P_ === i) break;
       i = _Q_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i){
    var i$0 = i;
    for(;;){
     var avltree = table[1 + i$0];
     if(! caml_call1(Base_Avltree[2], avltree))
      return caml_call1(Base_Avltree[19], avltree);
     var
      _M_ = caml_call2(Base_Import[93], table.length - 1, 1),
      _N_ = caml_call2(Base_Import[91], i$0, 1),
      i$1 = caml_call2(Base_Import[116], _N_, _M_);
     i$0 = i$1;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function choose_randomly_nonempty(random_state, t){
    var
     start_idx = caml_call2(Base_Random[18][6], random_state, t[1].length - 1);
    return choose_nonempty(t[1], start_idx);
   }
   function choose_randomly(opt, t){
    var random_state = opt ? opt[1] : Base_Random[18][1];
    return is_empty(t) ? 0 : [0, choose_randomly_nonempty(random_state, t)];
   }
   function choose_randomly_exn(opt, t){
    var random_state = opt ? opt[1] : Base_Random[18][1];
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Hashtbl_choose_randomly_ex, 0));
    return choose_randomly_nonempty(random_state, t);
   }
   function invariant(invariant_key, invariant_data, t){
    var _I_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var _J_ = compare_key(t), _K_ = caml_check_bound(t[1], i)[1 + i];
      caml_call2(Base_Avltree[3], _K_, _J_);
      var _L_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _L_;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return caml_call2(Base_Import[91], i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var _G_ = [1, [0, _b_, [0, caml_call1(t[4][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[267], _G_], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _F_ = caml_call2(f, key, data);
                 return _F_ ? caml_call1(r, 1) : _F_;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(_E_){return _E_;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[3]], [0, t[2]], t[4], 0),
     t1 = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$0){
    return find_and_call
            (t,
             id,
             function(data){return data;},
             function(key){
              var default$1 = caml_call1(default$0, 0);
              set(t, key, default$1);
              return default$1;
             });
   }
   function findi_or_add(t, id, default$0){
    return find_and_call
            (t,
             id,
             function(data){return data;},
             function(key){
              var default$1 = caml_call1(default$0, key);
              set(t, key, default$1);
              return default$1;
             });
   }
   function find_and_remove(t, key){
    var result = find_and_call(t, key, if_found, if_not_found);
    if(caml_call1(Base_Option[51], result)) remove(t, key);
    return result;
   }
   function change(t, key, f){
    var match = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    if(! match) return remove(t, key);
    var data = match[1];
    return set(t, key, data);
   }
   function update_and_return(t, key, f){
    var data = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    set(t, key, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    return remove_if_zero
            ? change
              (t,
               key,
               function(opt){
                var
                 _D_ = caml_call2(Base_Option[28], opt, 0),
                 n = caml_call2(Base_Import[91], by, _D_);
                return 0 === n ? 0 : [0, n];
               })
            : update
              (t,
               key,
               function(param){
                if(! param) return by;
                var i = param[1];
                return caml_call2(Base_Import[91], by, i);
               });
   }
   function incr(_C_, opt, t, key){
    var by = _C_ ? _C_[1] : 1, remove_if_zero = opt ? opt[1] : 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(_B_, opt, t, key){
    var by = _B_ ? _B_[1] : 1, remove_if_zero = opt ? opt[1] : 0;
    return incr_by(remove_if_zero, t, key, caml_call1(Base_Import[113], by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var _A_ = match[1];
    if(_A_ && _A_[2]){var tl = _A_[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = caml_call1(Base_List[17], rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    caml_call2
     (Base_List[19],
      rows,
      function(r){
       var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
       return mem(res, key)
               ? (dupes[1] = [0, key, dupes[1]], 0)
               : set(res, key, data);
      });
    var keys = dupes[1];
    return keys
            ? [0, 175765640, caml_call2(Base_List[124], keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[125],
         Base_Import[127],
         lst);
    if(175765640 <= match[1]){
     var k = match[2];
     return [0, -1048878709, caml_call1(Base_List[86], k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[125],
             Base_Import[127],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var match = of_alist(growth_allowed, size, hashable, lst);
    if(17724 <= match[1]){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return caml_call5
            (Base_Or_error[34],
             0,
             0,
             cst_Hashtbl_of_alist_exn_dupli,
             key,
             sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return caml_call1(Base_Error[29], e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[127], get_key = Base_Import[125];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = caml_call1(Base_List[17], rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    caml_call2
     (Base_List[19],
      rows,
      function(r){
       var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
       return add_multi(res, key, data);
      });
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     _w_ = to_alist(t),
     _x_ =
       caml_call2
        (Base_List[81],
         _w_,
         function(_z_, param){
          var k2 = param[1], k1 = _z_[1];
          return caml_call2(t[4][2], k1, k2);
         }),
     _y_ = caml_call2(Base_Import[148], sexp_of_key, sexp_of_data);
    return caml_call1(caml_call1(Base_Import[150], _y_), _x_);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     _p_ = caml_call2(Base_Import[172], k_of_sexp, d_of_sexp),
     alist = caml_call2(Base_Import[174], _p_, sexp),
     match =
       of_alist(0, [0, caml_call1(Base_List[17], alist)], hashable, alist);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     k = match[2],
     _q_ =
       caml_call2
        (Base_Import[172],
         function(_v_){return _v_;},
         function(_u_){return _u_;}),
     alist_sexps = caml_call2(Base_Import[174], _q_, sexp),
     found_first_k = [0, 0];
    caml_call3
     (Base_List[65],
      alist,
      alist_sexps,
      function(_r_, param){
       var
        k2_sexp = param[1],
        k2 = _r_[1],
        _s_ = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
       if(_s_){
        if(found_first_k[1])
         return caml_call2
                 (Base_Import[157], cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
        found_first_k[1] = 1;
        var _t_ = 0;
       }
       else
        var _t_ = _s_;
       return _t_;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var _o_ = caml_call2(Base_List[134][3], k_grammar, v_grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _o_);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    caml_call2
     (Base_List[19],
      rows,
      function(row){
       var
        key = caml_call1(get_key, row),
        data = caml_call1(get_data, row),
        match = find_and_call(groups, key, if_found, if_not_found);
       if(match)
        var old = match[1], data$0 = caml_call2(combine, old, data);
       else
        var data$0 = data;
       return set(groups, key, data$0);
      });
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(_n_){return _n_;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows);
    if(175765640 <= match[1]){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      _l_ =
        [0, [0, cst_keys, caml_call2(Base_Import[150], sexp_of_key, keys)], 0],
      _m_ = caml_call2(Base_Sexp[9], cst_Hashtbl_create_with_key_du, _l_);
     return caml_call1(Base_Or_error[35], _m_);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     _k_ =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return caml_call1(Base_Or_error[31], _k_);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - caml_call2(Base_Hashable[1], t_left[4], t_right[4]))
     caml_call1(Base_Import[126], cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[3]], [0, t_left[2]], t_left[4], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var
                     match = find_and_call(t_right, key, if_found, if_not_found);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find_and_call(t_left, key, if_found, if_not_found)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data$0 = find_and_call(dst, key, if_found, if_not_found),
               action =
                 without_mutating
                  (dst,
                   function(param){
                    return caml_call3(f, key, data, dst_data$0);
                   });
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data$0) return set(dst, key, data$0);
              var
               dst_data = dst_data$0[1],
               _j_ = 1 - caml_call2(Base_Import[128], dst_data, data$0);
              return _j_ ? set(dst, key, data$0) : _j_;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    return caml_call2
            (Base_List[19], to_remove, function(key){return remove(t, key);});
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    return caml_call2
            (Base_List[19],
             map_results,
             function(param){
              var result = param[2], key = param[1];
              if(! result) return remove(t, key);
              var data = result[1];
              return set(t, key, data);
             });
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var _h_ = Base_Avltree[18];
              return caml_call2
                      (Base_Array[19],
                       t[1],
                       function(_i_){return caml_call2(_h_, _i_, f);});
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var _f_ = t$0[2] === t[2] ? 1 : 0;
    return _f_
            ? caml_call1
              (with_return,
               function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find_and_call(t, key, if_found, if_not_found);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              _g_ = 1 - caml_call2(equal, data, data$0);
                             return _g_ ? caml_call1(r, 0) : _g_;
                            });
                  });
                return 1;
               })
            : _f_;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    _d_ = Creators([0, hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_alist$0 = _d_[3],
    of_alist_report_all_dups$0 = _d_[4],
    of_alist_or_error$0 = _d_[5],
    of_alist_exn$0 = _d_[6],
    of_alist_multi$0 = _d_[7],
    create_mapped$0 = _d_[8],
    create_with_key$0 = _d_[9],
    create_with_key_or_error$0 = _d_[10],
    create_with_key_exn$0 = _d_[11],
    group$0 = _d_[12];
   function hashable$0(t){return t[4];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, caml_call1(Base_Hashable[3], m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return caml_call1(Base_Hashable[4], t[4]);}
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t){
    return sexp_of_t(K[1], sexp_of_v, t);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    var _e_ = K[1];
    return t_of_sexp
            (caml_call1(Base_Hashable[3], [0, K[2], K[3], K[4]]),
             _e_,
             v_of_sexp,
             sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return t_sexp_grammar(K[1], v_grammar);
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       choose_randomly,
       choose_randomly_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        choose_randomly,
        choose_randomly_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(26, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[83],
    hashable = Base_Hashtbl[92][1],
    poly_hashable = Base_Hashtbl[86][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[30],
    cst_element_already_exists = "element already exists",
    _a_ = [0, 0];
   function is_empty(t){return caml_call1(Base_Hashtbl[29], t);}
   function find_map(t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (Base_Hashtbl[19],
                t,
                function(elt){
                 var o = caml_call1(f, elt);
                 return o ? caml_call1(r, o) : 0;
                });
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return caml_call3(Base_Hashtbl[36], t, k, 0);}
   function strict_add(t, k){
    return caml_call2(mem, t, k)
            ? caml_call1(Base_Or_error[36], cst_element_already_exists)
            : (caml_call3(Base_Hashtbl[36], t, k, 0), _a_);
   }
   function strict_add_exn(t, k){
    var _q_ = strict_add(t, k);
    return caml_call1(Base_Or_error[31], _q_);
   }
   var
    remove = Base_Hashtbl[31],
    _b_ = [0, 0],
    cst_element_not_in_set = "element not in set";
   function strict_remove(t, k){
    if(caml_call2(mem, t, k)){caml_call2(remove, t, k); return _b_;}
    var _p_ = caml_call1(Base_Hashtbl[15], t);
    return caml_call5(Base_Or_error[34], 0, 0, cst_element_not_in_set, k, _p_);
   }
   function strict_remove_exn(t, k){
    var _o_ = strict_remove(t, k);
    return caml_call1(Base_Or_error[31], _o_);
   }
   function fold(t, init, f){
    return caml_call3
            (Base_Hashtbl[18],
             t,
             init,
             function(key, param, acc){return caml_call2(f, acc, key);});
   }
   function iter(t, f){return caml_call2(Base_Hashtbl[19], t, f);}
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   var
    to_list = Base_Hashtbl[66],
    _c_ = [0, 0],
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element";
   function sexp_of_t(sexp_of_e, t){
    var
     _l_ = caml_call1(to_list, t),
     _m_ = caml_call1(hashable, t)[2],
     _n_ = caml_call2(Base_List[81], _l_, _m_);
    return caml_call2(Base_Import[150], sexp_of_e, _n_);
   }
   function to_array(t){
    var
     len = caml_call1(length, t),
     index = [0, caml_call2(Base_Import[93], len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return caml_call2(Base_Array[47], len, key);
              index[1] = caml_call2(Base_Import[93], index[1], 1);
              var _k_ = index[1];
              runtime.caml_check_bound(acc, _k_)[1 + _k_] = key;
              return acc;
             });
   }
   function exists(t, f){
    return caml_call2
            (Base_Hashtbl[22],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function for_all(t, f){
    return 1
           -
            caml_call2
             (Base_Hashtbl[22],
              t,
              function(key, param){return 1 - caml_call1(f, key);});
   }
   function equal(t1, t2){
    return caml_call3
            (Base_Hashtbl[75], function(_j_, param){return 1;}, t1, t2);
   }
   function copy(t){return caml_call1(Base_Hashtbl[17], t);}
   function filter(t, f){
    return caml_call2
            (Base_Hashtbl[48],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function union(t1, t2){
    return caml_call3
            (Base_Hashtbl[64], t1, t2, function(_i_, param){return _c_;});
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - caml_call2(Base_Hashtbl[30], t2, key);});
   }
   function inter(t1, t2){
    var _h_ = caml_call1(length, t2);
    if(_h_ < caml_call1(length, t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    return caml_call2
            (Base_Hashtbl[48],
             smaller,
             function(key, param){
              return caml_call2(Base_Hashtbl[30], larger, key);
             });
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    return caml_call2
            (Base_List[19],
             to_remove,
             function(x){return caml_call2(remove, t, x);});
   }
   function of_hashtbl_keys(hashtbl){
    return caml_call2(Base_Hashtbl[42], hashtbl, function(_g_){return 0;});
   }
   function to_hashtbl(t, f){
    return caml_call2
            (Base_Hashtbl[43],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function create(growth_allowed, size, m){
    return caml_call3(Base_Hashtbl[4], growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = caml_call1(Base_List[17], l);
    var t = caml_call3(Base_Hashtbl[4], growth_allowed, [0, size$0], m);
    caml_call2(Base_List[19], l, function(k){return add(t, k);});
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return caml_call2(Base_Import[157], cst_Hash_set_t_of_sexp_require, sexp);
    var
     list = sexp[1],
     t = create(0, [0, caml_call1(Base_List[17], list)], m);
    caml_call2
     (Base_List[19],
      list,
      function(sexp){
       var e = caml_call1(e_of_sexp, sexp);
       return 0 === strict_add(t, e)[0]
               ? 0
               : caml_call2
                 (Base_Import[157], cst_Hash_set_t_of_sexp_got_a_d, sexp);
      });
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(caml_call1(Base_Hashable[4], Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    _d_ = Creators([0, poly_hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_list$0 = _d_[3];
   function t_sexp_grammar(grammar){
    var _f_ = caml_call1(Base_List[6], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _f_);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t){return sexp_of_t(Elt[1], t);}
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var _e_ = caml_call1(Base_Import[195], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _e_);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[92][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_007 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    float_of_string_opt = Base_Float0[6],
    nan = Base_Float0[7],
    max_value = Base_Float0[8],
    neg_infinity = Base_Float0[9],
    max_finite_value = Base_Float0[10],
    epsilon_float = Base_Float0[11],
    classify_float = Base_Float0[12],
    abs_float = Base_Float0[13],
    is_integer = Base_Float0[14],
    symbol = Base_Float0[15],
    symbol$0 = Base_Float0[16],
    frexp = Base_Float0[17],
    ldexp = Base_Float0[18],
    is_nan = Base_Float0[19],
    to_int64_preserve_order = Base_Float0[20],
    to_int64_preserve_order_exn = Base_Float0[21],
    of_int64_preserve_order = Base_Float0[22],
    one_ulp = Base_Float0[23],
    upper_bound_for_int = Base_Float0[24],
    lower_bound_for_int = Base_Float0[26],
    clamp_unchecked = Base_Float0[27],
    box = Base_Float0[28],
    compare = Base_Float0[37],
    raise_s = Base_Error[30],
    hash_fold_t = Base_Import[210],
    func = Base_Import[224];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[254],
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[108][9],
    include = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t]),
    comparator = include[1],
    _a_ = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var _aV_ = caml_call1(float_of_string, s); return _aV_;}
    catch(_aW_){return caml_call3(Base_Printf[7], _a_, s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     _aU_ = caml_call1(float_of_string, y),
     y$0 =
       caml_call2(Base_Import[108][4], _aU_, x)
        ? y
        : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return caml_call2(Base_Import[112], y$0, cst);
     var match = runtime.caml_string_get(y$0, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return y$0;
     }
     var i$0 = caml_call2(Base_Import[91], i, 1);
     i = i$0;
    }
   }
   var
    min_positive_subnormal_value = caml_call2(symbol, 2., -1074.),
    min_positive_normal_value = caml_call2(symbol, 2., -1022.),
    zero = 0.,
    of_int = Base_Int[4],
    to_int = Base_Int[3];
   function of_int63(i){return caml_call1(Base_Int63[3], i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = caml_call1(lower_bound_for_int, Base_Int[61]),
    iround_ubound = caml_call1(upper_bound_for_int, Base_Int[61]),
    _b_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    _c_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    _d_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    _e_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    _f_ =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"];
   function iround_up(t){
    if(! caml_call2(Base_Import[108][5], t, 0.))
     return caml_call2(Base_Import[108][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[60], t)]
             : 0;
    var t$0 = caml_call1(round_up, t);
    return caml_call2(Base_Import[108][2], t$0, iround_ubound)
            ? [0, caml_call1(Base_Int[60], t$0)]
            : 0;
   }
   function iround_up_exn(t){
    if(caml_call2(Base_Import[108][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[108][2], t$0, iround_ubound))
      return caml_call1(Base_Int[60], t$0);
     var _aS_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _b_, _aS_, 0);
    }
    if(caml_call2(Base_Import[108][6], t, iround_lbound))
     return caml_call1(Base_Int[60], t);
    var _aT_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _c_, _aT_, 0);
   }
   function iround_down(t){
    if(caml_call2(Base_Import[108][6], t, 0.))
     return caml_call2(Base_Import[108][2], t, iround_ubound)
             ? [0, caml_call1(Base_Int[60], t)]
             : 0;
    var t$0 = caml_call1(round_down, t);
    return caml_call2(Base_Import[108][6], t$0, iround_lbound)
            ? [0, caml_call1(Base_Int[60], t$0)]
            : 0;
   }
   function iround_down_exn(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(caml_call2(Base_Import[108][2], t, iround_ubound))
      return caml_call1(Base_Int[60], t);
     var _aQ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _d_, _aQ_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[108][6], t$0, iround_lbound))
     return caml_call1(Base_Int[60], t$0);
    var _aR_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _e_, _aR_, 0);
   }
   function iround_towards_zero(t){
    if
     (caml_call2(Base_Import[108][6], t, iround_lbound)
      && caml_call2(Base_Import[108][2], t, iround_ubound))
     return [0, caml_call1(Base_Int[60], t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if
     (caml_call2(Base_Import[108][6], t, iround_lbound)
      && caml_call2(Base_Import[108][2], t, iround_ubound))
     return caml_call1(Base_Int[60], t);
    var _aP_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _f_, _aP_, 0);
   }
   var
    _g_ = caml_call2(symbol, 2., 52.),
    round_nearest_lb = caml_call1(Base_Import[114], _g_),
    round_nearest_ub = caml_call2(symbol, 2., 52.),
    one_ulp_less_than_half = caml_call2(one_ulp, 759637122, 0.5);
   function add_half_for_round_nearest(t){
    var
     _aO_ =
       caml_call2(Base_Import[108][4], t, one_ulp_less_than_half)
        ? one_ulp_less_than_half
        : 0.5;
    return caml_call2(Base_Import[92], t, _aO_);
   }
   function iround_nearest_32(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     return caml_call2(Base_Import[108][2], t$0, iround_ubound)
             ? [0, caml_call1(Base_Int[60], t$0)]
             : 0;
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return caml_call2(Base_Import[108][6], t$1, iround_lbound)
            ? [0, caml_call1(Base_Int[60], t$1)]
            : 0;
   }
   function iround_nearest_64(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(! caml_call2(Base_Import[108][1], t, round_nearest_ub))
      return caml_call2(Base_Import[108][2], t, iround_ubound)
              ? [0, caml_call1(Base_Int[60], t)]
              : 0;
     var _aM_ = add_half_for_round_nearest(t);
     return [0, caml_call1(Base_Int[60], _aM_)];
    }
    if(! caml_call2(Base_Import[108][5], t, round_nearest_lb))
     return caml_call2(Base_Import[108][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[60], t)]
             : 0;
    var _aN_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return [0, caml_call1(Base_Int[60], _aN_)];
   }
   var
    _R_ = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    _P_ =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    _Q_ =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _L_ = [0, cst_src_float_ml, 862, 2],
    _K_ =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    _J_ = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    _I_ = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    _F_ = [0, cst_src_float_ml, 700, 8],
    _E_ = [0, cst_src_float_ml, 703, 8],
    _A_ = [0, cst_src_float_ml, 710, 8],
    _B_ = [0, cst_src_float_ml, 711, 8],
    _C_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    _D_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    _z_ = [0, cst_src_float_ml, 687, 8],
    cst_0 = ".0",
    _G_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    _H_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    _w_ =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    _x_ = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    _y_ = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    _r_ = [0, cst_Infinite],
    _s_ = [0, cst_Nan],
    _t_ = [0, cst_Normal],
    _u_ = [0, cst_Subnormal],
    _v_ = [0, cst_Zero],
    _p_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    _q_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    _n_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    _o_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    _l_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    _m_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    _j_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _k_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    _h_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _i_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329,
    iround_nearest_64$0 =
      Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     if(caml_call2(Base_Import[108][2], t$0, iround_ubound))
      return caml_call1(Base_Int[60], t$0);
     var _aK_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _h_, _aK_, 0);
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    if(caml_call2(Base_Import[108][6], t$1, iround_lbound))
     return caml_call1(Base_Int[60], t$1);
    var _aL_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _i_, _aL_, 0);
   }
   function iround_nearest_exn_64(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(caml_call2(Base_Import[108][1], t, round_nearest_ub)){
      var _aG_ = add_half_for_round_nearest(t);
      return caml_call1(Base_Int[60], _aG_);
     }
     if(caml_call2(Base_Import[108][2], t, iround_ubound))
      return caml_call1(Base_Int[60], t);
     var _aH_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _j_, _aH_, 0);
    }
    if(caml_call2(Base_Import[108][5], t, round_nearest_lb)){
     var _aI_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
     return caml_call1(Base_Int[60], _aI_);
    }
    if(caml_call2(Base_Import[108][6], t, iround_lbound))
     return caml_call1(Base_Int[60], t);
    var _aJ_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _k_, _aJ_, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    var dir = opt ? opt[1] : 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    var dir = opt ? opt[1] : 857423934;
    try{var _aE_ = [0, iround_exn([0, dir], t)]; return _aE_;}
    catch(_aF_){return 0;}
   }
   function is_inf(t){
    var _aD_ = caml_call2(Base_Import[96], 1., t);
    return caml_call2(Base_Import[108][4], _aD_, 0.);
   }
   function is_finite(t){
    var _aC_ = caml_call2(Base_Import[94], t, t);
    return caml_call2(Base_Import[108][4], _aC_, 0.);
   }
   function min_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[108][1], x, y) ? x : y;
   }
   function max_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[108][5], x, y) ? x : y;
   }
   var
    add = Base_Import[92],
    sub = Base_Import[94],
    neg = Base_Import[114],
    scale = Base_Import[90];
   function square(x){return caml_call2(Base_Import[90], x, x);}
   function fractional(t){return caml_call1(Base_Import[125], t);}
   function integral(t){return caml_call1(Base_Import[127], t);}
   function round_towards_zero(t){
    return caml_call2(Base_Import[108][6], t, 0.)
            ? caml_call1(round_down, t)
            : caml_call1(round_up, t);
   }
   function round_nearest_inline(t){
    if
     (caml_call2(Base_Import[108][5], t, round_nearest_lb)
      && caml_call2(Base_Import[108][1], t, round_nearest_ub))
     return caml_call1(round_down, add_half_for_round_nearest(t));
    return caml_call2(Base_Import[92], t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if
     (!
      caml_call2(Base_Import[108][2], t, round_nearest_lb)
      && ! caml_call2(Base_Import[108][6], t, round_nearest_ub)){
     var
      floor = caml_call1(round_down, t),
      ceil_or_succ = caml_call2(Base_Import[92], floor, 1.),
      diff_floor = caml_call2(Base_Import[94], t, floor),
      diff_ceil = caml_call2(Base_Import[94], ceil_or_succ, t);
     if(caml_call2(Base_Import[108][1], diff_floor, diff_ceil)) return floor;
     if(caml_call2(Base_Import[108][5], diff_floor, diff_ceil))
      return ceil_or_succ;
     var _aB_ = caml_call2(mod_float, floor, 2.);
     return caml_call2(Base_Import[108][4], _aB_, 0.) ? floor : ceil_or_succ;
    }
    return caml_call2(Base_Import[92], t, 0.);
   }
   var
    int63_round_lbound = caml_call1(lower_bound_for_int, Base_Int63[84]),
    int63_round_ubound = caml_call1(upper_bound_for_int, Base_Int63[84]);
   function int63_round_up_exn(t){
    if(caml_call2(Base_Import[108][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[108][2], t$0, int63_round_ubound))
      return caml_call1(Base_Int63[83], t$0);
     var _az_ = caml_call1(Base_Float0[28], t);
     return caml_call3(Base_Printf[7], _l_, _az_, 0);
    }
    if(caml_call2(Base_Import[108][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[83], t);
    var _aA_ = caml_call1(Base_Float0[28], t);
    return caml_call3(Base_Printf[7], _m_, _aA_, 0);
   }
   function int63_round_down_exn(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(caml_call2(Base_Import[108][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[83], t);
     var _ax_ = caml_call1(Base_Float0[28], t);
     return caml_call3(Base_Printf[7], _n_, _ax_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[108][6], t$0, int63_round_lbound))
     return caml_call1(Base_Int63[83], t$0);
    var _ay_ = caml_call1(Base_Float0[28], t);
    return caml_call3(Base_Printf[7], _o_, _ay_, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(caml_call2(Base_Import[108][5], t, 0.)){
     if(caml_call2(Base_Import[108][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[83], t);
     var _av_ = caml_call1(box, t0);
     return caml_call3(Base_Printf[7], _p_, _av_, 0);
    }
    if(caml_call2(Base_Import[108][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[83], t);
    var _aw_ = caml_call1(box, t0);
    return caml_call3(Base_Printf[7], _q_, _aw_, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var _au_ = iround_nearest_exn(f);
    return caml_call1(Base_Int63[97], _au_);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    var dir = opt ? opt[1] : 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? round_towards_zero(t)
              : round_nearest_inline(t)
            : 759637122
              <= dir
              ? caml_call1(round_down, t)
              : caml_call1(round_up, t);
   }
   var compare$1 = runtime.caml_int_compare;
   function t_of_sexp$0(sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _ao_ = sexp_008[1], _ap_ = caml_string_compare(_ao_, cst_infinite);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= _ap_){
           if(0 < _ap_){
            if(_ao_ === cst_nan$1) break e;
            if(_ao_ === cst_normal) break d;
            if(_ao_ === cst_subnormal) break c;
            if(_ao_ !== cst_zero) break a;
            break b;
           }
          }
          else if(_ao_ !== cst_Infinite){
           if(_ao_ === cst_Nan) break e;
           if(_ao_ === cst_Normal) break d;
           if(_ao_ === cst_Subnormal) break c;
           if(_ao_ !== cst_Zero) break a;
           break b;
          }
          return 0;
         }
         return 1;
        }
        return 2;
       }
       return 3;
      }
      return 4;
     }
     var _aq_ = sexp_008[1];
     if(! _aq_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
     var _ar_ = _aq_[1];
     if(0 !== _ar_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_007, sexp_008);
     var _as_ = _ar_[1], _at_ = caml_string_compare(_as_, cst_infinite);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= _at_){
          if(0 < _at_){
           if(_as_ === cst_nan$1) break e;
           if(_as_ === cst_normal) break d;
           if(_as_ === cst_subnormal) break c;
           if(_as_ !== cst_zero) break a;
           break b;
          }
         }
         else if(_as_ !== cst_Infinite){
          if(_as_ === cst_Nan) break e;
          if(_as_ === cst_Normal) break d;
          if(_as_ === cst_Subnormal) break c;
          if(_as_ !== cst_Zero) break a;
          break b;
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3], error_source_007, sexp_008);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_007, sexp_008);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_007, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_007, sexp_008);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_007, sexp_008);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_007, sexp_008);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _r_;
      case 1:
       return _s_;
      case 2:
       return _t_;
      case 3:
       return _u_;
      default: return _v_;
    }
   }
   function to_string$0(t){
    var _an_ = sexp_of_t$0(t);
    return caml_call1(Base_Import[161], _an_);
   }
   function of_string$0(s){
    return t_of_sexp$0(caml_call1(Base_Import[137], s));
   }
   function classify(t){
    switch(caml_call1(classify_float, t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(_al_, opt, string){
    var
     delimiter = _al_ ? _al_[1] : 95,
     strip_zero = opt ? opt[1] : 0,
     match = caml_call2(Base_String[97], string, 46);
    if(! match)
     return caml_call2(Base_Int_conversions[37], string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = caml_call2(Base_Int_conversions[37], left, delimiter),
     right$0 =
       strip_zero
        ? caml_call2
          (Base_String[105],
           [0, function(c){return caml_call2(Base_Char[12], c, 48);}],
           right)
        : right;
    if(right$0 === cst$4) return left$0;
    var _am_ = caml_call2(Base_Import[112], cst$0, right$0);
    return caml_call2(Base_Import[112], left$0, _am_);
   }
   function to_string_hum(delimiter, _ak_, strip_zero, opt, f){
    var decimals = _ak_ ? _ak_[1] : 3, explicit_plus = opt ? opt[1] : 0;
    if(decimals < 0) caml_call3(Base_Printf[7], _w_, decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match)
     return caml_call2(Base_Import[108][5], f, 0.) ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call3(Base_Printf[2], _x_, decimals, f)
        : caml_call3(Base_Printf[2], _y_, decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = caml_call1(sexp_of_t, t);
    if(1009018843 <= Base_Sexp[18][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return caml_call4(Base_String[69], 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var _aj_ = [0, [0, cst_sexp, caml_call1(Base_Sexp[4], sexp)], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_sexp_of_float_produced_str, _aj_));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    var prefix = opt ? opt[1] : cst$2, match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match)
     return caml_call2(Base_Import[108][1], t, 0.) ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      a:
      {
       if
        (caml_call2(Base_Import[108][4], denominator, 100.)
         && caml_call2(Base_Import[108][6], numerator, 999.95))
        break a;
       if(caml_call2(Base_Import[108][6], denominator, 100000.)){
        var
         t$0 = caml_call2(Base_Import[90], denominator, 9.9995),
         _ai_ = round_nearest_inline(t$0);
        if(caml_call2(Base_Import[108][6], numerator, _ai_)) break a;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      }
      var
       t = caml_call2(Base_Import[90], denominator, 9999.5),
       _ah_ = round_nearest_inline(t);
      if(! caml_call2(Base_Import[108][1], numerator, _ah_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      var
       k =
         caml_call1
          (round_down, caml_call2(Base_Import[96], numerator, denominator)),
       lower = caml_call2(Base_Import[90], denominator, k),
       _ag_ = caml_call2(Base_Import[92], k, 1.),
       higher = caml_call2(Base_Import[90], denominator, _ag_),
       diff_right = caml_call2(Base_Import[94], higher, numerator),
       diff_left = caml_call2(Base_Import[94], numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         caml_call2(Base_Import[108][1], diff_right, diff_left)
          ? caml_call2(Base_Import[91], k$0, 1)
          : caml_call2
             (Base_Import[108][5], diff_right, diff_left)
            ? k$0
            : 0
              === caml_call2(Base_Import[122], k$0, 2)
              ? k$0
              : caml_call2(Base_Import[91], k$0, 1),
       d = caml_call2(Base_Import[122], k$1, 10),
       i = caml_call2(Base_Import[95], k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call4(Base_Printf[2], _C_, prefix, i, mag)
                : caml_call5(Base_Printf[2], _D_, prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     if(! caml_call2(Base_Import[108][1], t, 999.95)){
      if(caml_call2(Base_Import[108][1], t, 999950.))
       return conv(kilo, t, 100.);
      if(caml_call2(Base_Import[108][1], t, 999950000.))
       return conv(mega, t, 100000.);
      if(caml_call2(Base_Import[108][1], t, 999950000000.))
       return conv(giga, t, 100000000.);
      if(caml_call2(Base_Import[108][1], t, 999950000000000.))
       return conv(tera, t, 100000000000.);
      if(! peta) return caml_call3(Base_Printf[2], _H_, prefix, t);
      var peta$0 = peta[1];
      return caml_call2(Base_Import[108][1], t, 999950000000000000.)
              ? conv(peta$0, t, 100000000000000.)
              : caml_call3(Base_Printf[2], _G_, prefix, t);
     }
     if
      (caml_call2(Base_Import[108][2], 0., t)
       && caml_call2(Base_Import[108][1], t, 999.95)){
      var
       x = caml_call2(Base_Import[112], prefix, caml_format_float("%.1f", t));
      if(! caml_call2(Base_String[93], x, cst_0)) return x;
      var
       x$0 = caml_call1(Base_Bytes0[15], x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 1), 32);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 2), 32);
      return runtime.caml_string_of_bytes(x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    }
    if(caml_call2(Base_Import[108][6], t, 0.)) return go(t);
    var _af_ = go(caml_call1(Base_Import[114], t));
    return caml_call2(Base_Import[112], cst$1, _af_);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, _I_, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, caml_call2(Base_Import[92], x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = caml_call2(Base_Import[96], 1., x$0[1]);
     n$0[1] = caml_call1(Base_Import[113], n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; n$0[1]--;}
    }
    for(;;){
     if(1 >= n$0[1]) return caml_call2(Base_Import[90], x$0[1], accum[1]);
     if(0 !== caml_call2(Base_Import[116], n$0[1], 1))
      accum[1] = caml_call2(Base_Import[90], x$0[1], accum[1]);
     x$0[1] = caml_call2(Base_Import[90], x$0[1], x$0[1]);
     n$0[1] = caml_call2(Base_Import[120], n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(caml_call2(Base_Import[108][4], x, 0.)) return 0.;
    if(! is_finite(x)) return x;
    if(555917426 <= how[1])
     var
      sd = how[2],
      _ab_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      dd = caml_call2(Base_Import[93], sd, _ab_),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      _ae_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      sd$1 = caml_call2(Base_Import[91], dd$1, _ae_),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = caml_call1(Base_Int[75], dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       _ac_ =
         round_nearest_half_to_even(caml_call2(Base_Import[90], x, order));
      return caml_call2(Base_Import[96], _ac_, order);
     }
     var
      _ad_ = round_nearest_half_to_even(caml_call2(Base_Import[96], x, order));
     return caml_call2(Base_Import[90], _ad_, order);
    }
    return of_string(caml_call3(Base_Printf[2], _J_, sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call3(Base_Printf[7], _K_, significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var _aa_ = caml_call2(Base_Import[108][2], low, t);
    return _aa_ ? caml_call2(Base_Import[108][2], t, high) : _aa_;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[108][2], min, max))
     return caml_call3(clamp_unchecked, t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   function clamp(t, min, max){
    if(caml_call2(Base_Import[108][2], min, max))
     return [0, caml_call3(clamp_unchecked, t, min, max)];
    var
     _Z_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     ___ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _Z_],
     _$_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, ___);
    return caml_call1(Base_Or_error[35], _$_);
   }
   var
    symbol$1 = Base_Import[92],
    symbol$2 = Base_Import[94],
    symbol$3 = Base_Import[90],
    symbol$4 = Base_Import[96],
    symbol$5 = Base_Import[114];
   function sign_exn(t){
    if(caml_call2(Base_Import[108][5], t, 0.)) return 2;
    if(caml_call2(Base_Import[108][1], t, 0.)) return 0;
    if(caml_call2(Base_Import[108][4], t, 0.)) return 1;
    var
     _X_ = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     _Y_ = caml_call2(Base_Sexp[9], cst_Float_sign_exn_of_NAN, _X_);
    return caml_call1(Base_Error[30], _Y_);
   }
   function sign_or_nan(t){
    return caml_call2(Base_Import[108][5], t, 0.)
            ? 2
            : caml_call2
               (Base_Import[108][1], t, 0.)
              ? 0
              : caml_call2(Base_Import[108][4], t, 0.) ? 1 : 3;
   }
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    mantissa_bits = 52,
    _M_ = Base_Int64[34],
    exponent_mask64 =
      runtime.caml_int64_sub
       (caml_call2(Base_Int64[50], Base_Int64[34], 11), _M_),
    exponent_mask = caml_call1(Base_Int64[6], exponent_mask64),
    _N_ = Base_Int63[40],
    _O_ = caml_call2(Base_Int63[73], Base_Int63[40], mantissa_bits),
    mantissa_mask = caml_call2(Base_Int63[43], _O_, _N_),
    mantissa_mask64 = caml_call1(Base_Int63[80], mantissa_mask);
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     _W_ = caml_call2(Base_Int64[64], bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (caml_call2(Base_Int64[45], _W_, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return caml_call1
            (Base_Int63[106], runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(caml_call2(Base_Int[45], exponent, exponent_mask) !== exponent)
     return caml_call4(Base_Printf[6], _P_, exponent, exponent_mask, 0);
    var _T_ = caml_call2(Base_Int63[68], mantissa, mantissa_mask);
    if(caml_call2(Base_Int63[17], _T_, mantissa)){
     var
      _U_ = caml_call1(Base_Int63[11], mantissa_mask),
      _V_ = caml_call1(Base_Int63[11], mantissa);
     return caml_call4(Base_Printf[6], _Q_, _V_, _U_, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = caml_call1(Base_Int63[80], mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    return caml_call2
            (Base_Or_error[28],
             0,
             function(param){
              return create_ieee_exn(negative, exponent, mantissa);
             });
   }
   function to_string$1(x){return caml_call2(Base_Printf[2], _R_, x);}
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 =
      caml_call1(Base_Comparable[14], [0, compare$0, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return caml_call2(Base_Import[108][5], t, 0.);}
   function is_non_negative(t){return caml_call2(Base_Import[108][6], t, 0.);}
   function is_negative(t){return caml_call2(Base_Import[108][1], t, 0.);}
   function is_non_positive(t){return caml_call2(Base_Import[108][2], t, 0.);}
   var
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$1[1],
    _S_ = Base_Import[108],
    symbol$6 = _S_[3],
    symbol$7 = _S_[1],
    symbol$8 = _S_[5],
    symbol$9 = _S_[4],
    symbol$10 = _S_[2],
    symbol$11 = _S_[6];
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[224],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[108],
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    symbol$15 = include$2[4],
    symbol$16 = include$2[5],
    symbol$17 = include$2[6],
    ascending = include$2[7],
    descending = include$2[8],
    compare$2 = include$2[9],
    equal = include$2[10];
   function min(x, y){
    if(! caml_call2(symbol$12, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   function max(x, y){
    if(! caml_call2(symbol$16, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   var
    Base_Float =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       symbol$17,
       symbol$13,
       symbol$15,
       symbol$16,
       symbol$12,
       symbol$14,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       float_of_string_opt,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       invariant,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$1,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    _a_ = Stdlib_Buffer[18],
    _b_ = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){
    return caml_call4(_a_, t, s, pos, len);
   }
   function add_subbytes(t, s, pos, len){
    return caml_call4(_b_, t, s, pos, len);
   }
   function sexp_of_t(t){
    var _c_ = caml_call1(contents, t);
    return caml_call1(Base_Import[137], _c_);
   }
   var
    caml_buffer_length = Stdlib_Buffer[7],
    caml_buffer_blit = Stdlib_Buffer[5];
   function create$0(len){return caml_call1(Base_Bytes[32], len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_call5(caml_buffer_blit, src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      caml_call1
       (caml_call1(Base_Blit[2], [0, caml_buffer_length]),
        [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0];
   function get(opt, param){
    var at_most_num_frames = opt ? opt[1] : Base_Int[62];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : caml_call1(Stdlib_Printexc[14], t);
   }
   function to_string_list(t){
    var _f_ = to_string(t);
    return caml_call1(Base_String[101], _f_);
   }
   function sexp_of_t(t){
    var _e_ = to_string_list(t);
    return [1, caml_call2(Base_List[52], _e_, function(x){return [0, x];})];
   }
   var
    set_recording = Stdlib_Printexc[7],
    am_recording = Stdlib_Printexc[8],
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM",
    cst_b = "b";
   function most_recent(param){return caml_call1(Stdlib_Printexc[12], 0);}
   function most_recent_for_exn(exn){
    return caml_call1(Base_Exn[18], exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = caml_call1(am_recording, 0);
    caml_call1(set_recording, b);
    return caml_call2
            (Base_Exn[13],
             f,
             function(param){return caml_call1(set_recording, saved);});
   }
   function initialize_module(param){
    var match = caml_call1(Base_Sys0[20], cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      _a_ = Base_String[94],
      _b_ = caml_call2(Base_String[99], x, 44),
      ocamlrunparam_mentions_backtra =
        caml_call2
         (Base_List[23],
          _b_,
          function(_d_){return caml_call2(_a_, _d_, cst_b);});
    else
     var ocamlrunparam_mentions_backtra = 0;
    var _c_ = 1 - ocamlrunparam_mentions_backtra;
    return _c_ ? caml_call1(set_recording, 1) : _c_;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    hash_fold_t = Base_Sexp_with_comparable[1],
    hash = Base_Sexp_with_comparable[2],
    t_of_sexp = Base_Sexp_with_comparable[3],
    sexp_of_t = Base_Sexp_with_comparable[4],
    Not_found_s = Base_Sexp_with_comparable[5],
    Of_sexp_error = Base_Sexp_with_comparable[6],
    message = Base_Sexp_with_comparable[7],
    default_indent = Base_Sexp_with_comparable[8],
    pp_hum = Base_Sexp_with_comparable[9],
    pp_hum_indent = Base_Sexp_with_comparable[10],
    pp_mach = Base_Sexp_with_comparable[11],
    pp = Base_Sexp_with_comparable[12],
    to_string_hum = Base_Sexp_with_comparable[13],
    to_string_mach = Base_Sexp_with_comparable[14],
    to_string = Base_Sexp_with_comparable[15],
    of_float_style = Base_Sexp_with_comparable[16],
    of_int_style = Base_Sexp_with_comparable[17],
    t_sexp_grammar = Base_Sexp_with_comparable[18],
    invariant = Base_Sexp_with_comparable[19],
    of_string = Base_Sexp_with_comparable[20],
    symbol$0 = Base_Sexp_with_comparable[21],
    symbol$1 = Base_Sexp_with_comparable[22],
    symbol$2 = Base_Sexp_with_comparable[23],
    symbol$3 = Base_Sexp_with_comparable[24],
    symbol$4 = Base_Sexp_with_comparable[25],
    symbol$5 = Base_Sexp_with_comparable[26],
    equal = Base_Sexp_with_comparable[27],
    compare = Base_Sexp_with_comparable[28],
    min = Base_Sexp_with_comparable[29],
    max = Base_Sexp_with_comparable[30],
    ascending = Base_Sexp_with_comparable[31],
    descending = Base_Sexp_with_comparable[32],
    between = Base_Sexp_with_comparable[33],
    clamp_exn = Base_Sexp_with_comparable[34],
    clamp = Base_Sexp_with_comparable[35],
    comparator = Base_Sexp_with_comparable[36],
    Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator],
    am_testing = Base_Import[130],
    Exported_for_specific_uses = [0, am_testing],
    compare_array = Base_Array[1],
    equal_array = Base_Array[104],
    globalize_array = Base_Array[2],
    array_of_sexp = Base_Array[3],
    sexp_of_array = Base_Array[4];
   function array_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Array[5], a_sexp_grammar);
   }
   var
    compare_bool = Base_Bool[17],
    equal_bool = Base_Bool[16],
    globalize_bool = Base_Bool[2],
    hash_fold_bool = Base_Bool[4],
    func = Base_Bool[5];
   function hash_bool(x){return caml_call1(func, x);}
   var
    bool_of_sexp = Base_Bool[6],
    sexp_of_bool = Base_Bool[7],
    bool_sexp_grammar = Base_Bool[3],
    compare_char = Base_Char[17],
    equal_char = Base_Char[16],
    globalize_char = Base_Char[2],
    hash_fold_char = Base_Char[4],
    func$0 = Base_Char[5];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[6],
    sexp_of_char = Base_Char[7],
    char_sexp_grammar = Base_Char[3],
    sexp_of_exn = Base_Exn[1],
    compare_float = Base_Float[17],
    equal_float = Base_Float[16],
    globalize_float = Base_Float[1],
    hash_fold_float = Base_Float[5],
    func$1 = Base_Float[6];
   function hash_float(x){return caml_call1(func$1, x);}
   var
    float_of_sexp = Base_Float[7],
    sexp_of_float = Base_Float[8],
    float_sexp_grammar = Base_Float[2],
    compare_int = Base_Int[14],
    equal_int = Base_Int[13],
    globalize_int = Base_Int[1],
    hash_fold_int = Base_Int[7],
    func$2 = Base_Int[8];
   function hash_int(x){return caml_call1(func$2, x);}
   var
    int_of_sexp = Base_Int[9],
    sexp_of_int = Base_Int[10],
    int_sexp_grammar = Base_Int[2],
    compare_int32 = Base_Int32[20],
    equal_int32 = Base_Int32[19],
    globalize_int32 = Base_Int32[1],
    hash_fold_int32 = Base_Int32[7],
    func$3 = Base_Int32[8];
   function hash_int32(x){return caml_call1(func$3, x);}
   var
    int32_of_sexp = Base_Int32[9],
    sexp_of_int32 = Base_Int32[10],
    int32_sexp_grammar = Base_Int32[2],
    compare_int64 = Base_Int64[14],
    equal_int64 = Base_Int64[13],
    globalize_int64 = Base_Int64[1],
    hash_fold_int64 = Base_Int64[7],
    func$4 = Base_Int64[8];
   function hash_int64(x){return caml_call1(func$4, x);}
   var
    int64_of_sexp = Base_Int64[9],
    sexp_of_int64 = Base_Int64[10],
    int64_sexp_grammar = Base_Int64[2],
    compare_list = Base_List[1],
    equal_list = Base_List[151],
    globalize_list = Base_List[2],
    hash_fold_list = Base_List[3],
    list_of_sexp = Base_List[4],
    sexp_of_list = Base_List[5];
   function list_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_List[6], a_sexp_grammar);
   }
   var
    compare_nativeint = Base_Nativeint[20],
    equal_nativeint = Base_Nativeint[19],
    globalize_nativeint = Base_Nativeint[1],
    hash_fold_nativeint = Base_Nativeint[7],
    func$5 = Base_Nativeint[8];
   function hash_nativeint(x){return caml_call1(func$5, x);}
   var
    nativeint_of_sexp = Base_Nativeint[9],
    sexp_of_nativeint = Base_Nativeint[10],
    nativeint_sexp_grammar = Base_Nativeint[2],
    compare_option = Base_Option[1],
    equal_option = Base_Option[5],
    globalize_option = Base_Option[2],
    hash_fold_option = Base_Option[3],
    option_of_sexp = Base_Option[7],
    sexp_of_option = Base_Option[8];
   function option_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Option[4], a_sexp_grammar);
   }
   var
    compare_ref = Base_Ref[1],
    equal_ref = Base_Ref[2],
    globalize_ref = Base_Ref[3],
    ref_of_sexp = Base_Ref[4],
    sexp_of_ref = Base_Ref[5];
   function ref_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Ref[6], a_sexp_grammar);
   }
   var
    compare_string = Base_String[51],
    equal_string = Base_String[131],
    globalize_string = Base_String[1],
    hash_fold_string = Base_String[40];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[41],
    sexp_of_string = Base_String[42],
    string_sexp_grammar = Base_String[2],
    compare_bytes = Base_Bytes[17],
    equal_bytes = Base_Bytes[16],
    globalize_bytes = Base_Bytes[1],
    bytes_of_sexp = Base_Bytes[2],
    sexp_of_bytes = Base_Bytes[3],
    bytes_sexp_grammar = Base_Bytes[4],
    compare_unit = Base_Unit[17],
    equal_unit = Base_Unit[16],
    globalize_unit = Base_Unit[2],
    hash_fold_unit = Base_Unit[4],
    func$6 = Base_Unit[5];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[6],
    sexp_of_unit = Base_Unit[7],
    unit_sexp_grammar = Base_Unit[3],
    symbol$6 = Base_List[152][1],
    _a_ = Base_Int[72],
    symbol$7 = _a_[1],
    lnot = _a_[2],
    abs = _a_[3],
    zero = _a_[4],
    symbol$8 = _a_[5],
    symbol$9 = _a_[6],
    symbol$10 = _a_[7],
    _b_ = Base_Import[97],
    ascending$0 = _b_[1],
    descending$0 = _b_[2],
    max$0 = _b_[3],
    min$0 = _b_[4],
    include = Base_Float[106],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol_concat = Base_String[66],
    fst = Base_Import[125],
    snd = Base_Import[127],
    failwith = Base_Import[124],
    invalid_arg = Base_Import[126],
    raise_s = Base_Error[30],
    Export =
      [0,
       compare_array,
       equal_array,
       globalize_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool,
       equal_bool,
       globalize_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char,
       equal_char,
       globalize_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float,
       equal_float,
       globalize_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int,
       equal_int,
       globalize_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32,
       equal_int32,
       globalize_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64,
       equal_int64,
       globalize_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list,
       equal_list,
       globalize_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint,
       equal_nativeint,
       globalize_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option,
       equal_option,
       globalize_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref,
       equal_ref,
       globalize_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string,
       equal_string,
       globalize_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes,
       equal_bytes,
       globalize_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit,
       equal_unit,
       globalize_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol_concat,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s],
    compare_array$0 = Export[1],
    equal_array$0 = Export[2],
    globalize_array$0 = Export[3],
    array_of_sexp$0 = Export[4],
    sexp_of_array$0 = Export[5],
    array_sexp_grammar$0 = Export[6],
    compare_bool$0 = Export[7],
    equal_bool$0 = Export[8],
    globalize_bool$0 = Export[9],
    hash_fold_bool$0 = Export[10],
    hash_bool$0 = Export[11],
    bool_of_sexp$0 = Export[12],
    sexp_of_bool$0 = Export[13],
    bool_sexp_grammar$0 = Export[14],
    compare_char$0 = Export[15],
    equal_char$0 = Export[16],
    globalize_char$0 = Export[17],
    hash_fold_char$0 = Export[18],
    hash_char$0 = Export[19],
    char_of_sexp$0 = Export[20],
    sexp_of_char$0 = Export[21],
    char_sexp_grammar$0 = Export[22],
    sexp_of_exn$0 = Export[23],
    compare_float$0 = Export[24],
    equal_float$0 = Export[25],
    globalize_float$0 = Export[26],
    hash_fold_float$0 = Export[27],
    hash_float$0 = Export[28],
    float_of_sexp$0 = Export[29],
    sexp_of_float$0 = Export[30],
    float_sexp_grammar$0 = Export[31],
    compare_int$0 = Export[32],
    equal_int$0 = Export[33],
    globalize_int$0 = Export[34],
    hash_fold_int$0 = Export[35],
    hash_int$0 = Export[36],
    int_of_sexp$0 = Export[37],
    sexp_of_int$0 = Export[38],
    int_sexp_grammar$0 = Export[39],
    compare_int32$0 = Export[40],
    equal_int32$0 = Export[41],
    globalize_int32$0 = Export[42],
    hash_fold_int32$0 = Export[43],
    hash_int32$0 = Export[44],
    int32_of_sexp$0 = Export[45],
    sexp_of_int32$0 = Export[46],
    int32_sexp_grammar$0 = Export[47],
    compare_int64$0 = Export[48],
    equal_int64$0 = Export[49],
    globalize_int64$0 = Export[50],
    hash_fold_int64$0 = Export[51],
    hash_int64$0 = Export[52],
    int64_of_sexp$0 = Export[53],
    sexp_of_int64$0 = Export[54],
    int64_sexp_grammar$0 = Export[55],
    compare_list$0 = Export[56],
    equal_list$0 = Export[57],
    globalize_list$0 = Export[58],
    hash_fold_list$0 = Export[59],
    list_of_sexp$0 = Export[60],
    sexp_of_list$0 = Export[61],
    list_sexp_grammar$0 = Export[62],
    compare_nativeint$0 = Export[63],
    equal_nativeint$0 = Export[64],
    globalize_nativeint$0 = Export[65],
    hash_fold_nativeint$0 = Export[66],
    hash_nativeint$0 = Export[67],
    nativeint_of_sexp$0 = Export[68],
    sexp_of_nativeint$0 = Export[69],
    nativeint_sexp_grammar$0 = Export[70],
    compare_option$0 = Export[71],
    equal_option$0 = Export[72],
    globalize_option$0 = Export[73],
    hash_fold_option$0 = Export[74],
    option_of_sexp$0 = Export[75],
    sexp_of_option$0 = Export[76],
    option_sexp_grammar$0 = Export[77],
    compare_ref$0 = Export[78],
    equal_ref$0 = Export[79],
    globalize_ref$0 = Export[80],
    ref_of_sexp$0 = Export[81],
    sexp_of_ref$0 = Export[82],
    ref_sexp_grammar$0 = Export[83],
    compare_string$0 = Export[84],
    equal_string$0 = Export[85],
    globalize_string$0 = Export[86],
    hash_fold_string$0 = Export[87],
    hash_string$0 = Export[88],
    string_of_sexp$0 = Export[89],
    sexp_of_string$0 = Export[90],
    string_sexp_grammar$0 = Export[91],
    compare_bytes$0 = Export[92],
    equal_bytes$0 = Export[93],
    globalize_bytes$0 = Export[94],
    bytes_of_sexp$0 = Export[95],
    sexp_of_bytes$0 = Export[96],
    bytes_sexp_grammar$0 = Export[97],
    compare_unit$0 = Export[98],
    equal_unit$0 = Export[99],
    globalize_unit$0 = Export[100],
    hash_fold_unit$0 = Export[101],
    hash_unit$0 = Export[102],
    unit_of_sexp$0 = Export[103],
    sexp_of_unit$0 = Export[104],
    unit_sexp_grammar$0 = Export[105],
    symbol$18 = Export[106],
    symbol$19 = Export[107],
    lnot$0 = Export[108],
    abs$0 = Export[109],
    zero$0 = Export[110],
    symbol$20 = Export[111],
    symbol$21 = Export[112],
    symbol$22 = Export[113],
    ascending$1 = Export[114],
    descending$1 = Export[115],
    max$1 = Export[116],
    min$1 = Export[117],
    symbol$23 = Export[118],
    symbol$24 = Export[119],
    symbol$25 = Export[120],
    symbol$26 = Export[121],
    symbol$27 = Export[122],
    symbol$28 = Export[123],
    symbol$29 = Export[124],
    symbol_concat$0 = Export[125],
    fst$0 = Export[126],
    snd$0 = Export[127],
    failwith$0 = Export[128],
    invalid_arg$0 = Export[129],
    raise_s$0 = Export[130],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[267];
   caml_call1(Base_Backtrace[7], 0);
   var
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Sexp,
       Exported_for_specific_uses,
       Export,
       compare_array$0,
       equal_array$0,
       globalize_array$0,
       array_of_sexp$0,
       sexp_of_array$0,
       array_sexp_grammar$0,
       compare_bool$0,
       equal_bool$0,
       globalize_bool$0,
       hash_fold_bool$0,
       hash_bool$0,
       bool_of_sexp$0,
       sexp_of_bool$0,
       bool_sexp_grammar$0,
       compare_char$0,
       equal_char$0,
       globalize_char$0,
       hash_fold_char$0,
       hash_char$0,
       char_of_sexp$0,
       sexp_of_char$0,
       char_sexp_grammar$0,
       sexp_of_exn$0,
       compare_float$0,
       equal_float$0,
       globalize_float$0,
       hash_fold_float$0,
       hash_float$0,
       float_of_sexp$0,
       sexp_of_float$0,
       float_sexp_grammar$0,
       compare_int$0,
       equal_int$0,
       globalize_int$0,
       hash_fold_int$0,
       hash_int$0,
       int_of_sexp$0,
       sexp_of_int$0,
       int_sexp_grammar$0,
       compare_int32$0,
       equal_int32$0,
       globalize_int32$0,
       hash_fold_int32$0,
       hash_int32$0,
       int32_of_sexp$0,
       sexp_of_int32$0,
       int32_sexp_grammar$0,
       compare_int64$0,
       equal_int64$0,
       globalize_int64$0,
       hash_fold_int64$0,
       hash_int64$0,
       int64_of_sexp$0,
       sexp_of_int64$0,
       int64_sexp_grammar$0,
       compare_list$0,
       equal_list$0,
       globalize_list$0,
       hash_fold_list$0,
       list_of_sexp$0,
       sexp_of_list$0,
       list_sexp_grammar$0,
       compare_nativeint$0,
       equal_nativeint$0,
       globalize_nativeint$0,
       hash_fold_nativeint$0,
       hash_nativeint$0,
       nativeint_of_sexp$0,
       sexp_of_nativeint$0,
       nativeint_sexp_grammar$0,
       compare_option$0,
       equal_option$0,
       globalize_option$0,
       hash_fold_option$0,
       option_of_sexp$0,
       sexp_of_option$0,
       option_sexp_grammar$0,
       compare_ref$0,
       equal_ref$0,
       globalize_ref$0,
       ref_of_sexp$0,
       sexp_of_ref$0,
       ref_sexp_grammar$0,
       compare_string$0,
       equal_string$0,
       globalize_string$0,
       hash_fold_string$0,
       hash_string$0,
       string_of_sexp$0,
       sexp_of_string$0,
       string_sexp_grammar$0,
       compare_bytes$0,
       equal_bytes$0,
       globalize_bytes$0,
       bytes_of_sexp$0,
       sexp_of_bytes$0,
       bytes_sexp_grammar$0,
       compare_unit$0,
       equal_unit$0,
       globalize_unit$0,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp$0,
       sexp_of_unit$0,
       unit_sexp_grammar$0,
       symbol$18,
       symbol$19,
       lnot$0,
       abs$0,
       zero$0,
       symbol$20,
       symbol$21,
       symbol$22,
       ascending$1,
       descending$1,
       max$1,
       min$1,
       symbol$23,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol_concat$0,
       fst$0,
       snd$0,
       failwith$0,
       invalid_arg$0,
       raise_s$0,
       Continue_or_stop,
       Not_found_s$0];
   runtime.caml_register_global(21, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsT0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfQm9vbDAiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX29ial9kdXAiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsaXplX2Jvb2wiLCJiIiwiZ2xvYmFsaXplX2NoYXIiLCJjIiwiZ2xvYmFsaXplX3VuaXQiLCJ1IiwiZ2xvYmFsaXplX2FycmF5IiwicGFyYW0iLCJhIiwiZ2xvYmFsaXplX2xpc3QiLCJ4cyIsIngiLCJnbG9iYWxpemVfb3B0aW9uIiwiZ2xvYmFsaXplX3Jlc3VsdCIsImdsb2JhbGl6ZV9hIiwiZ2xvYmFsaXplX2IiLCJ0IiwiZ2xvYmFsaXplX3JlZiIsInIiLCJCYXNlX0dsb2JhbGl6ZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2dsb2JhbGl6ZS5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsZUFBQUMsR0NNMkIsU0FBQztBQUFBLFlBQUFDLGVBQUFDLEdBSUMsU0FBQztBQUFBLFlBQUFDLGVBQUFDLEdBV0MsU0FBQztBQUFBLFlBQUFDLGdCQUFBQyxPQUFBQyxHQUlOLGdCQUFrQjtBQUFBLFlBQUFDLGVBQUFYLEdBQUFTO0FBQUFBLElBRXJCLFlBQ2I7QUFBQSxRQUFBRyxLQURhLFVBQUFDLElBQUEsZ0JBRUQ7QUFBQSxJQUFQLGlDQUFHO0FBQUEsR0FBdUI7QUFBQSxZQUFBQyxpQkFBQWQsR0FBQVM7QUFBQUEsSUFHcEIsWUFDVDtBQUFBLFFBQUFJLElBRFM7QUFBQSxJQUVGLDRCQUFLO0FBQUE7QUFBQSxZQUFBRSxpQkFBQUMsYUFBQUMsYUFBQUM7QUFBQUEsSUFJdEIsbUJBQUFSLElBQUEsTUFDYSxzQ0FBZTtBQUFBLFFBQUFQLElBRDVCO0FBQUEsSUFFbUIsc0NBQWU7QUFBQTtBQUFBLFlBQUFnQixjQUFBVixPQUFBVyxHQUdiLGlCQUNpQjtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUQ1Q3hDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGUgW2dsb2JhbGl6ZV97Ym9vbCxjaGFyLHVuaXR9XSBmdW5jdGlvbnMgYXJlIHdyaXR0ZW4gYXMgbWF0Y2hlcyBwbHVzIHRoZSBpZGVudGl0eVxuICAgZnVuY3Rpb24gc28gdGhhdCB0aGUgdHlwZSBjaGVja2VyIGNhbiBnaXZlIHRoZW0gdGhlIGRlc2lyZWQgdHlwZSwgd2l0aG91dCBoYXZpbmcgdG8gZG9cbiAgIGFueXRoaW5nIHNwZWNpYWwuICBIb3dldmVyLCBbZ2xvYmFsaXplX2ludF0gY2Fubm90IGJlIHdyaXR0ZW4gdGhpcyB3YXksIHNvIHdlIHJlc29ydCB0b1xuICAgdXNpbmcgYW4gW2V4dGVybmFsXS4gKilcblxubGV0IGdsb2JhbGl6ZV9ib29sID0gZnVuY3Rpb25cbiAgfCAodHJ1ZSB8IGZhbHNlKSBhcyBiIC0+IGJcbjs7XG5cbmxldCBnbG9iYWxpemVfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ1xceDAwJyAuLiAnXFx4RkYnIGFzIGMgLT4gY1xuOztcblxuZXh0ZXJuYWwgZ2xvYmFsaXplX2Zsb2F0IDogKGZsb2F0W0Bsb2NhbF0pIC0+IGZsb2F0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2ludCA6IChpbnRbQGxvY2FsXSkgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2ludDMyIDogKGludDMyW0Bsb2NhbF0pIC0+IGludDMyID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2ludDY0IDogKGludDY0W0Bsb2NhbF0pIC0+IGludDY0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX25hdGl2ZWludCA6IChuYXRpdmVpbnRbQGxvY2FsXSkgLT4gbmF0aXZlaW50ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2J5dGVzIDogKGJ5dGVzW0Bsb2NhbF0pIC0+IGJ5dGVzID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX3N0cmluZyA6IChzdHJpbmdbQGxvY2FsXSkgLT4gc3RyaW5nID0gXCJjYW1sX29ial9kdXBcIlxuXG5sZXQgZ2xvYmFsaXplX3VuaXQgKCgpIGFzIHUpID0gdVxuXG5leHRlcm5hbCBnbG9iYWxpemVfYXJyYXknIDogKCdhIGFycmF5W0Bsb2NhbF0pIC0+ICdhIGFycmF5ID0gXCJjYW1sX29ial9kdXBcIlxuXG5sZXQgZ2xvYmFsaXplX2FycmF5IF8gYSA9IGdsb2JhbGl6ZV9hcnJheScgYVxuXG5sZXQgcmVjIGdsb2JhbGl6ZV9saXN0IGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB4cyAtPiBmIHggOjogZ2xvYmFsaXplX2xpc3QgZiB4c1xuOztcblxubGV0IGdsb2JhbGl6ZV9vcHRpb24gZiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB4IC0+IFNvbWUgKGYgeClcbjs7XG5cbmxldCBnbG9iYWxpemVfcmVzdWx0IGdsb2JhbGl6ZV9hIGdsb2JhbGl6ZV9iIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBhIC0+IE9rIChnbG9iYWxpemVfYSBhKVxuICB8IEVycm9yIGIgLT4gRXJyb3IgKGdsb2JhbGl6ZV9iIGIpXG47O1xuXG5sZXQgZ2xvYmFsaXplX3JlZicgciA9IHJlZiAhclxubGV0IGdsb2JhbGl6ZV9yZWYgXyByID0gZ2xvYmFsaXplX3JlZicgclxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjc5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY29tcGFyZSIsImRlc2NlbmRpbmciLCJ4IiwieSIsIm1heCIsIm1pbiIsIkJhc2VfUG9seTAiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9wb2x5MC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxHQ2dCcUIseUJBQVc7QUFBQSxZQUFBQyxJQUFBRixHQUFBQztBQUFBQSxJQUNMLE9BQWIsd0JBQWEsc0NBQVk7QUFBQTtBQUFBLFlBQUFFLElBQUFILEdBQUFDO0FBQUFBLElBQ1osT0FBYix3QkFBYSxtQ0FBWTtBQUFBO0FBQUEsT0FBQUcsYURsQnZDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiogUHJpbWl0aXZlcyBmb3IgcG9seW1vcnBoaWMgY29tcGFyZS4gKilcblxuKCpfIFBvbHltb3JwaGljIGNvbXBpbGVyIHByaW1pdGl2ZXMgY2FuJ3QgYmUgYWxpYXNlcyBhcyB0aGlzIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgaW5saW5pbmcuIChJZiBhbGlhc2VkIHdpdGhvdXQgYSB0eXBlIGFubm90YXRpb24sIHRoZSBjb21waWxlciB3b3VsZCBpbXBsZW1lbnQgdGhlbVxuICB1c2luZyB0aGUgZ2VuZXJpYyBjb2RlIGRvaW5nIGEgQyBjYWxsLCBhbmQgaXQncyB0aGlzIGNvZGUgdGhhdCB3b3VsZCBiZSBpbmxpbmVkLikgQXMgYVxuICByZXN1bHQgd2UgaGF2ZSB0byBjb3B5IHRoZSBbZXh0ZXJuYWwgLi4uXSBkZWNsYXJhdGlvbiBoZXJlLiAqKVxuZXh0ZXJuYWwgKCA8ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA9ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPiApIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoID49ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBhc2NlbmRpbmcgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBjb21wYXJlIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuZXh0ZXJuYWwgZXF1YWwgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxubGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbmxldCBtYXggeCB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxubGV0IG1pbiB4IHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6OTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwiY2FtbF9ieXRlc19sZXNzZXF1YWwiLCJjYW1sX2VxdWFsIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfUG9seTAiLCJTdGRsaWJfVWNoYXIiLCJTaGFkb3dfc3RkbGliIiwiU3RkbGliIiwiU3RkbGliX01vcmVMYWJlbHMiLCJFeGl0IiwiTm90X2ZvdW5kIiwibWF4X2ludCIsIm1pbl9pbnQiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYm9vbF9vZl9zdHJpbmdfb3B0IiwiYm9vbF9vZl9zdHJpbmciLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0Iiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50X29wdCIsInJlYWRfaW50IiwicmVhZF9mbG9hdF9vcHQiLCJyZWFkX2Zsb2F0Iiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJvcGVuX291dF9nZW4iLCJmbHVzaCIsImZsdXNoX2FsbCIsIm91dHB1dF9jaGFyIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9ieXRlcyIsIm91dHB1dCIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X3ZhbHVlIiwic2Vla19vdXQiLCJwb3Nfb3V0Iiwib3V0X2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2Vfb3V0IiwiY2xvc2Vfb3V0X25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX291dCIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsIm9wZW5faW5fZ2VuIiwiaW5wdXRfY2hhciIsImlucHV0X2xpbmUiLCJpbnB1dCIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9ieXRlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X3ZhbHVlIiwic2Vla19pbiIsInBvc19pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2VfaW4iLCJjbG9zZV9pbl9ub2VyciIsInNldF9iaW5hcnlfbW9kZV9pbiIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wiLCJleGl0IiwiYXRfZXhpdCIsInZhbGlkX2Zsb2F0X2xleGVtIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsImRvX2F0X2V4aXQiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsImludmFsaWRfYXJnIiwiZmFpbHdpdGgiLCJNYXRjaF9mYWlsdXJlIiwiQXNzZXJ0X2ZhaWx1cmUiLCJJbnZhbGlkX2FyZ3VtZW50IiwiRmFpbHVyZSIsIk91dF9vZl9tZW1vcnkiLCJTdGFja19vdmVyZmxvdyIsIlN5c19lcnJvciIsIkVuZF9vZl9maWxlIiwiRGl2aXNpb25fYnlfemVybyIsIlN5c19ibG9ja2VkX2lvIiwiVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUiLCJtaW4iLCJtYXgiLCJhYnMiLCJsbm90Iiwic3ltYm9sX2NvbmNhdCIsIkxhcmdlRmlsZSIsIkhhc2h0YmwiLCJNYXAiLCJTZXQiLCJib29sX3RvX2ludCIsIngiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwieSIsIkludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhciIsImNvbXBhcmUiLCJlcXVhbCIsIkludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcCIsIkludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcCIsIk5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljXyIsIkJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYSIsIkNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYSIsImkiLCJVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb20iLCJCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJhc3IiLCJsYW5kIiwibG9yIiwibHNsIiwibHNyIiwibHhvciIsIm1vZCIsImZzdCIsInNuZCIsInBoeXNfZXF1YWwiLCJmbG9hdF9vZl9zdHJpbmciLCJhbV90ZXN0aW5nIiwiQmFzZV9JbXBvcnQwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvaW1wb3J0MC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQXJGLFNBQUE7QUFBQSxJQUFBc0YsZ0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUF4RixjQUFBO0FBQUEsSUFBQXlGLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFqRyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFpRyxPQUFBO0FBQUEsSUFBQWhHLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQTRGLGdCQUFBO0FBQUEsSUFBQTNGLGdCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBNEQsV0FBQTtBQUFBLElBQUEzRCxVQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQTJCLFlBQUE7QUFBQSxJQUFBMUIscUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQW9CLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUEzRztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUE0RyxZQUFBQyxHQzZEbUMsU0FBa0I7QUFBQSxZQUFBOUIsU0FBQSxVRDdEckQ7QUFBQSxPQUFBQSxXQUFBO0FBQUEsWUFBQUEsU0FBQTtBQUFBLFlBQUFBLFNBQUE7QUFBQSxZQUFBQSxTQUFBO0FBQUEsWUFBQUEsU0FBQTtBQUFBLFlBQUFBLFNBQUE7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QUEsWUFBQUMsS0FBQTtBQUFBLE9BQUF6QixTQUFBO0FBQUEsWUFBQTBCLElBQUE7QUFBQSxZQUFBQyxJQUFBO0FBQUEsWUFBQUMsSUFBQTtBQUFBLFlBQUFDLEtBQUE7QUFBQSxPQUFBQyxNQUFBLGtCQUFBL0IsUUFBQSxjQUFBZCxhQUFBO0FBQUEsWUFBQThDLElBQUE7QUFBQSxPQUFBL0MsZ0JBQUE7QUFBQSxZQUFBZ0QsSUFBQTtBQUFBLFlBQUFDLFdBQUE7QUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsYUN5VWlCO0FBQUEsSUFBQUM7QUFBQUEsTUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEelU5QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBtb2R1bGUgaXMgaW5jbHVkZWQgaW4gW0ltcG9ydF0uICBJdCBpcyBhaW1lZCBhdCBtb2R1bGVzIHRoYXQgZGVmaW5lIHRoZSBzdGFuZGFyZFxuICAgY29tYmluYXRvcnMgZm9yIFtzZXhwX29mXSwgW29mX3NleHBdLCBbY29tcGFyZV0gYW5kIFtoYXNoXSBhbmQgYXJlIGluY2x1ZGVkIGluXG4gICBbSW1wb3J0XS4gKilcblxuaW5jbHVkZSAoXG4gIFNoYWRvd19zdGRsaWIgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICBlbmRcbiAgd2l0aCB0eXBlICdhIHJlZiA6PSAnYSByZWZcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0IDo9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgKCogVGhlc2UgbW9kdWxlcyBhcmUgcmVkZWZpbmVkIGluIEJhc2UgKilcbiAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICB3aXRoIG1vZHVsZSBBdG9taWMgOj0gU2hhZG93X3N0ZGxpYi5BdG9taWNcbiAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gIHdpdGggbW9kdWxlIEJ5dGVzIDo9IFNoYWRvd19zdGRsaWIuQnl0ZXNcbiAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gIHdpdGggbW9kdWxlIEZsb2F0IDo9IFNoYWRvd19zdGRsaWIuRmxvYXRcbiAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gIHdpdGggbW9kdWxlIEludDMyIDo9IFNoYWRvd19zdGRsaWIuSW50MzJcbiAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICB3aXRoIG1vZHVsZSBMaXN0IDo9IFNoYWRvd19zdGRsaWIuTGlzdFxuICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gIHdpdGggbW9kdWxlIE9wdGlvbiA6PSBTaGFkb3dfc3RkbGliLk9wdGlvblxuICB3aXRoIG1vZHVsZSBQcmludGYgOj0gU2hhZG93X3N0ZGxpYi5QcmludGZcbiAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICB3aXRoIG1vZHVsZSBSYW5kb20gOj0gU2hhZG93X3N0ZGxpYi5SYW5kb21cbiAgd2l0aCBtb2R1bGUgUmVzdWx0IDo9IFNoYWRvd19zdGRsaWIuUmVzdWx0XG4gIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICB3aXRoIG1vZHVsZSBTdGFjayA6PSBTaGFkb3dfc3RkbGliLlN0YWNrXG4gIHdpdGggbW9kdWxlIFN0cmluZyA6PSBTaGFkb3dfc3RkbGliLlN0cmluZ1xuICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgd2l0aCBtb2R1bGUgVWNoYXIgOj0gU2hhZG93X3N0ZGxpYi5VY2hhclxuICB3aXRoIG1vZHVsZSBVbml0IDo9IFNoYWRvd19zdGRsaWIuVW5pdClcbiAgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxudHlwZSAnYSByZWYgPSAnYSBTdGRsaWIucmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG4oKiBSZXNodWZmbGUgW1N0ZGxpYl0gc28gdGhhdCB3ZSBjaG9vc2UgdGhlIG1vZHVsZXMgdXNpbmcgbGFiZWxzIHdoZW4gYXZhaWxhYmxlLiAqKVxubW9kdWxlIFN0ZGxpYiA9IHN0cnVjdFxuICBpbmNsdWRlIFN0ZGxpYlxuICBpbmNsdWRlIFN0ZGxpYi5TdGRMYWJlbHNcbiAgaW5jbHVkZSBTdGRsaWIuTW9yZUxhYmVsc1xuZW5kXG5cbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgoJ2EgLT4gJ2IpW0Bsb2NhbF9vcHRdKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuKCogVGhlc2UgbmVlZCB0byBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBnZXQgdGhlIGxhenkgYmVoYXZpb3IgKilcbmV4dGVybmFsICggJiYgKSA6IChib29sW0Bsb2NhbF9vcHRdKSAtPiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsIG5vdCA6IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5cbigqIFdlIHVzZSBbT2JqLm1hZ2ljXSBoZXJlIGFzIG90aGVyIGltcGxlbWVudGF0aW9ucyBnZW5lcmF0ZSBhIGNvbmRpdGlvbmFsIGp1bXAgYW5kIHRoZVxuICAgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZSBpcyBub3RpY2VhYmxlLiAqKVxubGV0IGJvb2xfdG9faW50ICh4IDogYm9vbCkgOiBpbnQgPSBTdGRsaWIuT2JqLm1hZ2ljIHhcblxuKCogVGhpcyBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseSAqKVxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxubGV0ICggIT0gKSA9IFN0ZGxpYi4oICE9IClcbmxldCAoICogKSA9IFN0ZGxpYi4oICogKVxubGV0ICggKiogKSA9IFN0ZGxpYi4oICoqIClcbmxldCAoICouICkgPSBTdGRsaWIuKCAqLiApXG5sZXQgKCArICkgPSBTdGRsaWIuKCArIClcbmxldCAoICsuICkgPSBTdGRsaWIuKCArLiApXG5sZXQgKCAtICkgPSBTdGRsaWIuKCAtIClcbmxldCAoIC0uICkgPSBTdGRsaWIuKCAtLiApXG5sZXQgKCAvICkgPSBTdGRsaWIuKCAvIClcbmxldCAoIC8uICkgPSBTdGRsaWIuKCAvLiApXG5cbm1vZHVsZSBQb2x5ID0gUG9seTAgKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5ICopXG5cbm1vZHVsZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG4gIGV4dGVybmFsICggPCApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgZXF1YWwgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBpbnQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGludCkgeSA9IGNvbXBhcmUgeSB4XG4gIGxldCBtYXggKHggOiBpbnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBpbnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAoKiBEZWNsYXJlZCBhcyBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfYXBwbHlfWCB3cmFwcGluZyBldmVuIHdoZW5cbiAgICAgY29tcGlsaW5nIHdpdGhvdXQgY3Jvc3MgbGlicmFyeSBpbmxpbmluZy4gKilcbiAgZXh0ZXJuYWwgKCA9IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJWVxdWFsXCJcblxuICBleHRlcm5hbCAoIDw+IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJW5vdGVxdWFsXCJcblxuICBleHRlcm5hbCAoIDwgKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlbGVzc3RoYW5cIlxuXG4gIGV4dGVybmFsICggPiApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVncmVhdGVydGhhblwiXG5cbiAgZXh0ZXJuYWwgKCA8PSApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVsZXNzZXF1YWxcIlxuXG4gIGV4dGVybmFsICggPj0gKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZ3JlYXRlcmVxdWFsXCJcblxuICBleHRlcm5hbCBjb21wYXJlXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnRcbiAgICA9IFwiJWNvbXBhcmVcIlxuXG4gIGV4dGVybmFsIGVxdWFsXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVlcXVhbFwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IFN0ZGxpYi5JbnQ2NC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLkludDY0LnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBtYXggKHggOiBTdGRsaWIuSW50NjQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5JbnQ2NC50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYm9vbCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogYm9vbCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYm9vbCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBib29sKSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogYm9vbCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogY2hhcikgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IGNoYXIpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgaSB4ID0gU3RkbGliLlVjaGFyLnRvX2ludCB4XG4gIGxldCAoIDwgKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA8PSApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA8PiApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA9ICkgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPiApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPiApIChpIHgpIChpIHkpXG4gIGxldCAoID49ICkgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIChpIHgpIChpIHkpXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmFzY2VuZGluZyAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZGVzY2VuZGluZyAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBjb21wYXJlICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgKGkgeCkgKGkgeSlcbiAgbGV0IGVxdWFsICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIChpIHgpIChpIHkpXG4gIGxldCBtYXggKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGZsb2F0KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGZsb2F0KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGZsb2F0KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogZmxvYXQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGZsb2F0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGZsb2F0KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogZmxvYXQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IHN0cmluZykgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IHN0cmluZykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IHN0cmluZykgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBzdHJpbmcpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBzdHJpbmcpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYnl0ZXMpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBieXRlcykgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG4oKiBUaGlzIG5lZWRzIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgY2FuIHNwZWNpYWxpemUgaXQgYXMgYVxuICAgZGlyZWN0IHNldCBvciBjYW1sX21vZGlmeSAqKVxuZXh0ZXJuYWwgKCA6PSApIDogKCdhIHJlZltAbG9jYWxfb3B0XSkgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbigqIFRoZXNlIG5lZWQgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBvdGhlcndpc2UgdGhlIGNvbXBpbGVyIHdvbid0IHVuYm94XG4gICByZWZlcmVuY2VzICopXG5leHRlcm5hbCAoICEgKSA6ICgnYSByZWZbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHJlZiA6ICdhIC0+ICgnYSByZWZbQGxvY2FsX29wdF0pID0gXCIlbWFrZW11dGFibGVcIlxuXG5sZXQgKCBAICkgPSBTdGRsaWIuKCBAIClcbmxldCAoIF4gKSA9IFN0ZGxpYi4oIF4gKVxubGV0ICggfi0gKSA9IFN0ZGxpYi4oIH4tIClcbmxldCAoIH4tLiApID0gU3RkbGliLiggfi0uIClcbmxldCAoIGFzciApID0gU3RkbGliLiggYXNyIClcbmxldCAoIGxhbmQgKSA9IFN0ZGxpYi4oIGxhbmQgKVxubGV0IGxub3QgPSBTdGRsaWIubG5vdFxubGV0ICggbG9yICkgPSBTdGRsaWIuKCBsb3IgKVxubGV0ICggbHNsICkgPSBTdGRsaWIuKCBsc2wgKVxubGV0ICggbHNyICkgPSBTdGRsaWIuKCBsc3IgKVxubGV0ICggbHhvciApID0gU3RkbGliLiggbHhvciApXG5sZXQgKCBtb2QgKSA9IFN0ZGxpYi4oIG1vZCApXG5sZXQgYWJzID0gU3RkbGliLmFic1xubGV0IGZhaWx3aXRoID0gU3RkbGliLmZhaWx3aXRoXG5sZXQgZnN0ID0gU3RkbGliLmZzdFxubGV0IGludmFsaWRfYXJnID0gU3RkbGliLmludmFsaWRfYXJnXG5sZXQgc25kID0gU3RkbGliLnNuZFxuXG4oKiBbcmFpc2VdIG5lZWRzIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgYXMgdGhlIGNvbXBpbGVyIGF1dG9tYXRpY2FsbHkgcmVwbGFjZXNcbiAgICclcmFpc2UnIGJ5ICclcmVyYWlzZScgd2hlbiBhcHByb3ByaWF0ZS4gKilcbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+IF8gPSBcIiVyYWlzZVwiXG5cbmxldCBwaHlzX2VxdWFsID0gU3RkbGliLiggPT0gKVxuXG5leHRlcm5hbCBkZWNyIDogKGludCByZWZbQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVkZWNyXCJcbmV4dGVybmFsIGluY3IgOiAoaW50IHJlZltAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWluY3JcIlxuXG4oKiB1c2VkIGJ5IHNleHBfY29udiwgd2hpY2ggZmxvYXQwIGRlcGVuZHMgb24gdGhyb3VnaCBvcHRpb24gKilcbmxldCBmbG9hdF9vZl9zdHJpbmcgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nXG5cbigqIFthbV90ZXN0aW5nXSBpcyB1c2VkIGluIGEgZmV3IHBsYWNlcyB0byBiZWhhdmUgZGlmZmVyZW50bHkgd2hlbiBpbiB0ZXN0aW5nIG1vZGUsIHN1Y2hcbiAgIGFzIGluIFtyYW5kb20ubWxdLiAgW2FtX3Rlc3RpbmddIGlzIGltcGxlbWVudGVkIHVzaW5nIFtCYXNlX2FtX3Rlc3RpbmddLCBhIHdlYWsgQy9qc1xuICAgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbZmFsc2VdLCBidXQgd2hlbiBsaW5raW5nIGFuIGlubGluZS10ZXN0LXJ1bm5lciBleGVjdXRhYmxlLCBpc1xuICAgb3ZlcnJpZGRlbiBieSBhbm90aGVyIHByaW1pdGl2ZSB0aGF0IHJldHVybnMgW3RydWVdLiAqKVxuZXh0ZXJuYWwgYW1fdGVzdGluZyA6IHVuaXQgLT4gYm9vbCA9IFwiQmFzZV9hbV90ZXN0aW5nXCJcblxubGV0IGFtX3Rlc3RpbmcgPSBhbV90ZXN0aW5nICgpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6ODY3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsInRvX2Zsb2F0Iiwib2ZfZmxvYXQiLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJzdWNjIiwicHJlZCIsIkJhc2VfSW50MCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLFNBQUE7QUFBQSxZQUFBQyxTQUFBO0FBQUEsT0FBQUMsWUFBQSxZQUFBQyxZQUFBO0FBQUEsWUFBQUMsS0FBQTtBQUFBLFlBQUFDLEtBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo5MDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQwIiwiU3RkbGliX1ByaW50ZiIsInNwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJrc3ByaW50ZiIsImticHJpbnRmIiwiZmFpbHdpdGhmIiwiZm10IiwicyIsInBhcmFtIiwiaW52YWxpZF9hcmdmIiwiQmFzZV9QcmludGYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9wcmludGYubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBLElDS21DO0FBQUE7QUFBQSxzQkFBQUMsR0FBQUMsT0FBc0IsdUNBQVU7QUFBQSxpQkFBSztBQUFBO0FBQUEsWUFBQUMsYUFBQUg7QUFBQUEsSUFDbEM7QUFBQTtBQUFBLHNCQUFBQyxHQUFBQyxPQUFzQix1Q0FBYTtBQUFBLGlCQUFLO0FBQUE7QUFBQTtBQUFBLElBQUFFO0FBQUFBLE1ETjlFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnQwXG5pbmNsdWRlIFN0ZGxpYi5QcmludGZcblxuKCoqIGZhaWx3aXRoLCBpbnZhbGlkX2FyZywgYW5kIGV4aXQgYWNjZXB0aW5nIHByaW50ZidzIGZvcm1hdC4gKilcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGZhaWx3aXRoZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gZmFpbHdpdGggcykgZm10XG5sZXRbQGlubGluZSBuZXZlcl0gaW52YWxpZF9hcmdmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAoKSAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo5NTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9zeXNfYXJndiIsImNhbWxfc3lzX2dldGVudiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwzIiwiZiIsImEwIiwiYTEiLCJhMiIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQwIiwiQmFzZV9QcmludGYiLCJTdGRsaWJfU3lzIiwiYmFja2VuZF90eXBlIiwiaW50ZXJhY3RpdmUiLCJvc190eXBlIiwidW5peCIsIndpbjMyIiwiY3lnd2luIiwid29yZF9zaXplX2luX2JpdHMiLCJpbnRfc2l6ZV9pbl9iaXRzIiwiYmlnX2VuZGlhbiIsIm1heF9zdHJpbmdfbGVuZ3RoIiwibWF4X2FycmF5X2xlbmd0aCIsInJ1bnRpbWVfdmFyaWFudCIsInJ1bnRpbWVfcGFyYW1ldGVycyIsImFyZ3YiLCJnZXRfYXJndiIsInBhcmFtIiwib2NhbWxfdmVyc2lvbiIsImVuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwicnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiZ2V0ZW52X2V4biIsInZhciIsImdldGVudiIsIngiLCJCcmVhayIsIkJhc2VfU3lzMCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL3N5czAubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxZQUFBQyxTQUFBQyxPQzhCa0IsdUJBQWU7QUFBQTtBQUFBLElBQUFDLGdCRDlCakM7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUM7QUFBQUEsSUNvQ0UsY0FBSTtBQUFBO0FBQUEsZURwQ047QUFBQTtBQUFBLE1Dc0NJLGdEQUE0RTtBQUFBLEtEdENoRjtBQUFBO0FBQUEsR0NzQ2dGO0FBQUEsWUFBQUMsT0FBQUQ7QUFBQUEsSUFJOUUsUUFBQUUsSUFBTTtBQUFBO0FBQUEsZUQxQ1I7QUFBQSxxQ0M0Q2tDO0FBQUEsS0Q1Q2xDO0FBQUE7QUFBQSxJQzJDUztBQUFBLEdBQzZCO0FBQUE7QUFBQSxJQUFBQyxRRDVDdEM7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBbU3lzMF0gZGVmaW5lcyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtTdGRsaWIuU3lzXS4gIFtTeXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtTdGRsaWIuU3lzXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIHN5cy5tbFxuICAgc2hvdWxkIHVzZSBbU3RkbGliLlN5c10uIFtTeXMwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZVxuICAgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSB0aGVzZVxuICAgZnVuY3Rpb25zIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TeXNdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBTeXMgPSBTeXMwXS4gIERlZmluaW5nIFttb2R1bGUgU3lzID0gU3lzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgaXQgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TeXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbnR5cGUgYmFja2VuZF90eXBlID0gU3RkbGliLlN5cy5iYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG5cbmxldCBiYWNrZW5kX3R5cGUgPSBTdGRsaWIuU3lzLmJhY2tlbmRfdHlwZVxubGV0IGludGVyYWN0aXZlID0gU3RkbGliLlN5cy5pbnRlcmFjdGl2ZVxubGV0IG9zX3R5cGUgPSBTdGRsaWIuU3lzLm9zX3R5cGVcbmxldCB1bml4ID0gU3RkbGliLlN5cy51bml4XG5sZXQgd2luMzIgPSBTdGRsaWIuU3lzLndpbjMyXG5sZXQgY3lnd2luID0gU3RkbGliLlN5cy5jeWd3aW5cbmxldCB3b3JkX3NpemVfaW5fYml0cyA9IFN0ZGxpYi5TeXMud29yZF9zaXplXG5sZXQgaW50X3NpemVfaW5fYml0cyA9IFN0ZGxpYi5TeXMuaW50X3NpemVcbmxldCBiaWdfZW5kaWFuID0gU3RkbGliLlN5cy5iaWdfZW5kaWFuXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSBTdGRsaWIuU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgbWF4X2FycmF5X2xlbmd0aCA9IFN0ZGxpYi5TeXMubWF4X2FycmF5X2xlbmd0aFxubGV0IHJ1bnRpbWVfdmFyaWFudCA9IFN0ZGxpYi5TeXMucnVudGltZV92YXJpYW50XG5sZXQgcnVudGltZV9wYXJhbWV0ZXJzID0gU3RkbGliLlN5cy5ydW50aW1lX3BhcmFtZXRlcnNcbmxldCBhcmd2ID0gU3RkbGliLlN5cy5hcmd2XG5sZXQgZ2V0X2FyZ3YgKCkgPSBTdGRsaWIuU3lzLmFyZ3ZcbmxldCBvY2FtbF92ZXJzaW9uID0gU3RkbGliLlN5cy5vY2FtbF92ZXJzaW9uXG5sZXQgZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgPSBTdGRsaWIuU3lzLmVuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG5sZXQgcnVudGltZV93YXJuaW5nc19lbmFibGVkID0gU3RkbGliLlN5cy5ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcblxubGV0IGdldGVudl9leG4gdmFyID1cbiAgdHJ5IFN0ZGxpYi5TeXMuZ2V0ZW52IHZhciB3aXRoXG4gIHwgU3RkbGliLk5vdF9mb3VuZCAtPlxuICAgIFByaW50Zi5mYWlsd2l0aGYgXCJTeXMuZ2V0ZW52X2V4bjogZW52aXJvbm1lbnQgdmFyaWFibGUgJXMgaXMgbm90IHNldFwiIHZhciAoKVxuOztcblxubGV0IGdldGVudiB2YXIgPVxuICBtYXRjaCBTdGRsaWIuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxuZXh0ZXJuYWwgb3BhcXVlX2lkZW50aXR5IDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pID0gXCIlb3BhcXVlXCJcbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eV9nbG9iYWwgOiAnYSAtPiAnYSA9IFwiJW9wYXF1ZVwiXG5cbmV4Y2VwdGlvbiBCcmVhayA9IFN0ZGxpYi5TeXMuQnJlYWtcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDQ3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21ha2VfdmVjdCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9BcnJheUxhYmVscyIsIkJhc2VfSW1wb3J0MCIsIkJhc2VfSW50MCIsIkJhc2VfUHJpbnRmIiwiQmFzZV9TeXMwIiwiaW52YWxpZF9hcmdmIiwiQXJyYXkiLCJtYXhfbGVuZ3RoIiwiY3JlYXRlIiwibGVuIiwieCIsImNyZWF0ZV9sb2NhbCIsImNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIiwiYXBwZW5kIiwiYmxpdCIsImNvbmNhdCIsImNvcHkiLCJmaWxsIiwiY3N0X0FycmF5X2luaXQiLCJpbml0IiwicmVzIiwiaSIsIm1ha2VfbWF0cml4Iiwib2ZfbGlzdCIsInN1YiIsInRvX2xpc3QiLCJmb2xkIiwidCIsInIiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0IiwiY29tcGFyZSIsInN3YXAiLCJqIiwiZWx0X2kiLCJlbHRfaiIsIkJhc2VfQXJyYXkwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvYXJyYXkwLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxZQUFBQyxPQUFBQyxLQUFBQyxHQzBETSw2QkFDOEU7QUFBQSxZQUFBQyxhQUFBRixLQUFBQyxHQUszRSw2QkFFK0Q7QUFBQSxZQUFBRSwyQkFBQUg7QUFBQUEsSUFJbEUsd0NBRTRFO0FBQUE7QUFBQTtBQUFBLElBQUFJLFNEeEVsRjtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLFlBQUFDLEtBQUFWLEtBQUFkO0FBQUFBLElDa0ZFLGNBQ0s7QUFBQSxJQUNBLFlBQ0Esb0RBTUM7QUFBQTtBQUFBLEtBQUFlLElBSmtCO0FBQUEsS0FBQVUsTUE3QnBCO0FBQUEsV0E4Qlc7QUFBQSxXQUFhO0FBQUE7QUFBQSxTQUFBQyxJQUFBO0FBQUE7QUFBQSxNQUNQO0FBQUEsZ0JBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXhCO0FBQUEsR0FBSTtBQUFBO0FBQUEsSUFBQUMsY0QzRlI7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxZQUFBQyxLQUFBQyxHQUFBUixNQUFBeEI7QUFBQUE7QUFBQUEsS0FBQWlDLElDb0dFO0FBQUEsV0FDYTtBQUFBLFdBQVk7QUFBQTtBQUFBLFNBQUFQLElBQUE7QUFBQTtBQUFBLE1BQ2xCO0FBQUEsZ0JBQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUU1QjtBQUFBLEdBQUU7QUFBQSxZQUFBUSxXQUFBRixHQUFBaEMsR0FBQXdCO0FBQUFBLFFBQUFTLElBSUYsaUJBQ1E7QUFBQSxJQUFZO0FBQUEsU0FBQVAsSUFBQTtBQUFBO0FBQUEsTUFDYjtBQUFBLGdCQUFxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFNUI7QUFBQSxHQUFFO0FBQUEsWUFBQVMsS0FBQUgsR0FBQWhDO0FBQUFBLFFBQUEsTUFJVyxxREFBWTtBQUFBO0FBQUEsU0FBQTBCLElBQUE7QUFBQTtBQUFBLE1BQ3ZCO0FBQUEsZ0JBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQURLO0FBQUEsR0FFckI7QUFBQSxZQUFBVSxNQUFBSixHQUFBaEM7QUFBQUEsUUFBQSxNQUlTLHFEQUFZO0FBQUE7QUFBQSxTQUFBMEIsSUFBQTtBQUFBO0FBQUEsTUFDdkI7QUFBQSxnQkFBb0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBREc7QUFBQSxHQUVyQjtBQUFBLFlBQUFXLElBQUFMLEdBQUFoQztBQUFBQSxRQUFBYyxNQUlKO0FBQUEsSUFDQSxjQUNLO0FBQUE7QUFBQSxLQUFBQyxJQUVpQjtBQUFBLEtBQUFrQixJQTFFbEI7QUFBQSxXQTJFVztBQUFBLFdBQU87QUFBQTtBQUFBLFNBQUFQLElBQUE7QUFBQTtBQUFBLE1BQ0g7QUFBQSxnQkFBb0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXJDO0FBQUEsR0FBRTtBQUFBLFlBQUFZLEtBQUFOLEdBQUFoQztBQUFBQSxRQUFBYyxNQUlKO0FBQUEsSUFDQSxjQUNLO0FBQUE7QUFBQSxLQUFBQyxJQUVpQjtBQUFBLEtBQUFrQixJQXRGbEI7QUFBQSxXQXVGVztBQUFBLFdBQU87QUFBQTtBQUFBLFNBQUFQLElBQUE7QUFBQTtBQUFBLE1BQ0g7QUFBQSxnQkFBc0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXZDO0FBQUEsR0FBRTtBQUFBLFlBQUFhLFlBQUFQLEdBQUFRO0FBQUFBLElBR3VCLHFEQUF1QztBQUFBO0FBQUEsWUFBQUMsS0FBQVQsR0FBQU4sR0FBQWdCO0FBQUFBO0FBQUFBLEtBQUFDLFFBR3REO0FBQUEsS0FBQUMsUUFDQTtBQUFBLElBQ1o7QUFBQSxJQUNBO0FBQUEsSUFBb0I7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUQ3SnRCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBbQXJyYXkwXSBkZWZpbmVzIGFycmF5IGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtc1xuICAgb2YgW1N0ZGxpYi5BcnJheV0uICBbQXJyYXkwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW1N0ZGxpYi5BcnJheV1cbiAgIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gYXJyYXkwLm1sIHNob3VsZCB1c2UgW1N0ZGxpYi5BcnJheV0uXG4gICBbQXJyYXkwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBhcnJheXMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkFycmF5XSBpbiBidWlsZCBvcmRlciBzaG91bGRcbiAgIGRvIFttb2R1bGUgQXJyYXkgPSBBcnJheTBdLiAgVGhpcyBpbmNsdWRlcyB1c2VzIG9mIHN1YnNjcmlwdCBzeW50YXggKFt4LihpKV0sIFt4LihpKSA8LVxuICAgZV0pLCB3aGljaCB0aGUgT0NhbWwgcGFyc2VyIGRlc3VnYXJzIGludG8gY2FsbHMgdG8gW0FycmF5LmdldF0gYW5kIFtBcnJheS5zZXRdLlxuICAgRGVmaW5pbmcgW21vZHVsZSBBcnJheSA9IEFycmF5MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tXG4gICBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5BcnJheV0uICopXG5cblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuICBleHRlcm5hbCBjcmVhdGVfbG9jYWwgOiBpbnQgLT4gJ2EgLT4gKCdhIGFycmF5W0Bsb2NhbF0pID0gXCJjYW1sX21ha2VfdmVjdFwiXG4gIGV4dGVybmFsIGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG4gIGV4dGVybmFsIGdldCA6ICgnYSBhcnJheVtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6ICgnYSBhcnJheVtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcblxuICBleHRlcm5hbCBzZXRcbiAgICA6ICAoJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAnYVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWFycmF5X3NhZmVfc2V0XCJcblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0XG4gICAgOiAgKCdhIGFycmF5W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gJ2FcbiAgICA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRcbiAgICA6ICAoJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAnYVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0XG4gICAgOiAgc3JjOignYSBhcnJheVtAbG9jYWxfb3B0XSlcbiAgICAtPiBzcmNfcG9zOmludFxuICAgIC0+IGRzdDooJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gZHN0X3BvczppbnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gdW5pdFxuICAgID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZW5kXG5cbmluY2x1ZGUgQXJyYXlcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aFxuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gIHRyeSBjcmVhdGUgbGVuIHggd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGUgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBjcmVhdGVfbG9jYWwgfmxlbiB4ID1cbiAgXG4gICAgKHRyeSBjcmVhdGVfbG9jYWwgbGVuIHggd2l0aFxuICAgICB8IEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgICAgIGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZV9sb2NhbCB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKSlcbjs7XG5cbmxldCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuID1cbiAgdHJ5IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIGxlbiB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgaW52YWxpZF9hcmdmIFwiQXJyYXkuY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBhcHBlbmQgPSBTdGRsaWIuQXJyYXkuYXBwZW5kXG5sZXQgYmxpdCA9IFN0ZGxpYi5BcnJheS5ibGl0XG5sZXQgY29uY2F0ID0gU3RkbGliLkFycmF5LmNvbmNhdFxubGV0IGNvcHkgPSBTdGRsaWIuQXJyYXkuY29weVxubGV0IGZpbGwgPSBTdGRsaWIuQXJyYXkuZmlsbFxuXG5sZXQgaW5pdCBsZW4gfmY6KChmIDogXyAtPiBfKSBbQGxvY2FsXSkgPVxuICBpZiBsZW4gPSAwXG4gIHRoZW4gW3x8XVxuICBlbHNlIGlmIGxlbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICBlbHNlIChcbiAgICBsZXQgcmVzID0gY3JlYXRlIH5sZW4gKGYgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gSW50MC5wcmVkIGxlbiBkb1xuICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgIGRvbmU7XG4gICAgcmVzKVxuOztcblxubGV0IG1ha2VfbWF0cml4ID0gU3RkbGliLkFycmF5Lm1ha2VfbWF0cml4XG5sZXQgb2ZfbGlzdCA9IFN0ZGxpYi5BcnJheS5vZl9saXN0XG5sZXQgc3ViID0gU3RkbGliLkFycmF5LnN1YlxubGV0IHRvX2xpc3QgPSBTdGRsaWIuQXJyYXkudG9fbGlzdFxuXG5sZXQgZm9sZCB0IH5pbml0IH5mOigoZiA6IF8gLT4gXyAtPiBfKSBbQGxvY2FsXSkgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IGZvbGRfcmlnaHQgdCB+ZjooKGYgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pIH5pbml0ID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IGxlbmd0aCB0IC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCB0IGkpICFyXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgaXRlciB0IH5mOigoZiA6IF8gLT4gXykgW0Bsb2NhbF0pID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgdCB+ZjooKGYgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBtYXAgdCB+ZjooKGYgOiBfIC0+IF8pIFtAbG9jYWxdKSA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gW3x8XVxuICBlbHNlIChcbiAgICBsZXQgciA9IGNyZWF0ZSB+bGVuIChmICh1bnNhZmVfZ2V0IHQgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHQgaSkpXG4gICAgZG9uZTtcbiAgICByKVxuOztcblxubGV0IG1hcGkgdCB+ZjooKGYgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCByID0gY3JlYXRlIH5sZW4gKGYgMCAodW5zYWZlX2dldCB0IDApKSBpblxuICAgIGZvciBpID0gMSB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHQgaSkpXG4gICAgZG9uZTtcbiAgICByKVxuOztcblxubGV0IHN0YWJsZV9zb3J0IHQgfmNvbXBhcmUgPSBTdGRsaWIuQXJyYXkuc3RhYmxlX3NvcnQgdCB+Y21wOmNvbXBhcmVcblxubGV0IHN3YXAgdCBpIGogPVxuICBsZXQgZWx0X2kgPSB0LihpKSBpblxuICBsZXQgZWx0X2ogPSB0LihqKSBpblxuICB1bnNhZmVfc2V0IHQgaSBlbHRfajtcbiAgdW5zYWZlX3NldCB0IGogZWx0X2lcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTI0OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwzIiwiZiIsImEwIiwiYTEiLCJhMiIsImdsb2JhbF9kYXRhIiwiQmFzZV9QcmludGYiLCJTdGRsaWJfQ2hhciIsImZhaWx3aXRoZiIsImVzY2FwZWQiLCJsb3dlcmNhc2UiLCJ0b19pbnQiLCJ1bnNhZmVfb2ZfaW50IiwidXBwZXJjYXNlIiwiaW50X2lzX29rIiwiaSIsIm9mX2ludCIsIm9mX2ludF9leG4iLCJlcXVhbCIsInQxIiwidDIiLCJCYXNlX0NoYXIwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvY2hhcjAubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsWUFBQUMsT0FBQTtBQUFBLFlBQUFDLGNBQUE7QUFBQSxPQUFBQyxZQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsUUFBQSxNQ29Ca0I7QUFBQTtBQUFBLEdBQWtCO0FBQUE7QUFBQTtBQUFBLE1BRUg7QUFBQTtBQUFBO0FBQUEsWUFBQUMsT0FBQUQsR0FDZixnQ0FBaUQ7QUFBQSxZQUFBRSxXQUFBRjtBQUFBQSxJQUc5RCwwQkFFRSxnQ0FBNkQ7QUFBQTtBQUFBLFlBQUFHLE1BQUFDLElBQUFDLElBR3pDLHlCQUFnQjtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFUVjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRCakMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFtDaGFyMF0gZGVmaW5lcyBjaGFyIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtcyBvZlxuICAgW1N0ZGxpYi5DaGFyXS4gIFtDaGFyMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtTdGRsaWIuQ2hhcl0gdGhhdFxuICAgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gY2hhcjAubWwgc2hvdWxkIHVzZSBbU3RkbGliLkNoYXJdLlxuICAgW0NoYXIwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBjaGFycyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQ2hhcl0gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIENoYXIgPSBDaGFyMF0uICBEZWZpbmluZyBbbW9kdWxlIENoYXIgPSBDaGFyMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdFxuICAgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5DaGFyXS4gKilcblxub3BlbiEgSW1wb3J0MFxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxubGV0IGVzY2FwZWQgPSBTdGRsaWIuQ2hhci5lc2NhcGVkXG5sZXQgbG93ZXJjYXNlID0gU3RkbGliLkNoYXIubG93ZXJjYXNlX2FzY2lpXG5sZXQgdG9faW50ID0gU3RkbGliLkNoYXIuY29kZVxubGV0IHVuc2FmZV9vZl9pbnQgPSBTdGRsaWIuQ2hhci51bnNhZmVfY2hyXG5sZXQgdXBwZXJjYXNlID0gU3RkbGliLkNoYXIudXBwZXJjYXNlX2FzY2lpXG5cbigqIFdlIHVzZSBvdXIgb3duIHJhbmdlIHRlc3Qgd2hlbiBjb252ZXJ0aW5nIGludGVnZXJzIHRvIGNoYXJzIHJhdGhlciB0aGFuXG4gICBjYWxsaW5nIFtTdGRsaWIuQ2hhci5jaHJdIGJlY2F1c2UgaXQncyBzaW1wbGUgYW5kIGl0IHNhdmVzIHVzIGEgZnVuY3Rpb24gY2FsbFxuICAgYW5kIHRoZSB0cnktd2l0aCAoZXhjZXB0aW9ucyBjb3N0LCBlc3BlY2lhbGx5IGluIHRoZSB3b3JsZCB3aXRoIGJhY2t0cmFjZXMpLiAqKVxubGV0IGludF9pc19vayBpID0gMCA8PSBpICYmIGkgPD0gMjU1XG5sZXQgbWluX3ZhbHVlID0gdW5zYWZlX29mX2ludCAwXG5sZXQgbWF4X3ZhbHVlID0gdW5zYWZlX29mX2ludCAyNTVcbmxldCBvZl9pbnQgaSA9IGlmIGludF9pc19vayBpIHRoZW4gU29tZSAodW5zYWZlX29mX2ludCBpKSBlbHNlIE5vbmVcblxubGV0IG9mX2ludF9leG4gaSA9XG4gIGlmIGludF9pc19vayBpXG4gIHRoZW4gdW5zYWZlX29mX2ludCBpXG4gIGVsc2UgZmFpbHdpdGhmIFwiQ2hhci5vZl9pbnRfZXhuIGdvdCBpbnRlZ2VyIG91dCBvZiByYW5nZTogJWRcIiBpICgpXG47O1xuXG5sZXQgZXF1YWwgKHQxIDogY2hhcikgdDIgPSBQb2x5LmVxdWFsIHQxIHQyXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTMwMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0hhc2hfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsaUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMzEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0MCIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiaGRfZXhuIiwibGVuZ3RoIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwiY3N0X0xpc3RfZXhpc3RzMiIsImNzdF9MaXN0X2ZvbGRfbGVmdDIiLCJjc3RfTGlzdF9mb3JfYWxsMiIsImNzdF9MaXN0X2l0ZXIyIiwiY3N0X0xpc3RfcmV2X21hcDIiLCJleGlzdHMiLCJ0IiwieHMiLCJ4IiwiZXhpc3RzMl9vayIsImwxIiwibDIiLCJmb2xkIiwiaW5pdCIsImwiLCJhIiwiZm9sZDJfb2siLCJmb3JfYWxsIiwiZm9yX2FsbDJfb2siLCJpdGVyIiwiaXRlcjJfb2siLCJub250YWlsX21hcCIsInkiLCJub250YWlsX21hcGkiLCJwYXJ0aXRpb24iLCJyZXZfbWFwIiwiYWNjdSIsInBhcmFtIiwicmV2X21hcDJfb2siLCJzb3J0IiwiY29tcGFyZSIsInN0YWJsZV9zb3J0IiwicmV2IiwicmVzIiwibWF0Y2giLCJyZXN0IiwiZm9sZF9yaWdodCIsImIiLCJmb2xkX3JpZ2h0Ml9vayIsImMiLCJCYXNlX0xpc3QwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvbGlzdDAubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxtQkNrR0U7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLE9BQUFDLEdBQUFwQjtBQUFBQSxRQUFBb0IsTUE3RUE7QUFBQTtBQUFBLGVBQ1E7QUFBQSxTQUFBQyxLQURSLFFBQUFDLElBQUE7QUFBQSxLQUVnQixxQkFBUztBQUFBLEtBQVU7QUFBQTtBQUFBLEdBQVk7QUFBQSxZQUFBQyxXQUFBQyxJQUFBQyxJQUFBekI7QUFBQUEsUUFBQXdCLE9BSS9DLElBQUFDLE9BQUE7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ZixHQUFBZ0I7QUFBQUEsSUFHM0Msb0RBQStCO0FBQUE7QUFBQSxZQUFBQyxZQUFBakIsR0FBQWdCO0FBQUFBLElBQ3hCLG9EQUFzQztBQUFBO0FBQUEsWUFBQUUsSUFBQUM7QUFBQUEsSUFFekQ7QUFBQSxTQUFBQyxRQUFBO0FBQUE7QUFBQSxVQUFBQyxPQUFBLFVBQUFiLElBQUEsVUFBQWQsSUFBQTtBQUFBLE1BRVksc0RBQXdCO0FBQUE7QUFBQTtBQUFBLElBRG5CO0FBQUEsR0FDbUI7QUFBQSxZQUFBNEIsV0FBQXRCLEdBQUE1QixHQUFBMkI7QUFBQUEsSUFJNUM7QUFBQSxjQUUrQyxLQUFQLHVCQUFBRSxHQUFBc0IsR0FBYiwwQkFBSztBQUFBLGtCQUEwQjtBQUFBO0FBQUEsWUFBQUMsZUFBQTVCLElBQUFDLElBQUF6QixHQUFBMkI7QUFBQUEsSUFJMUQsaUJBQ1k7QUFBQSxjQUNnRDtBQUFBLElBQVQsT0FBUTtBQUFBLGFBQVI7QUFBQTtBQUFBO0FBQUEsc0JBQUFFLEdBQUFzQixHQUFBRSxHQUFmLDZCQUFPLEdBQW9DO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BcEIvRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURsR0YiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFtMaXN0MF0gZGVmaW5lcyBsaXN0IGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtcyBvZlxuICAgW1N0ZGxpYi5MaXN0XS4gIFtMaXN0MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtTdGRsaWIuTGlzdF0gdGhhdFxuICAgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gbGlzdDAubWwgc2hvdWxkIHVzZSBbU3RkbGliLkxpc3RdLlxuICAgW0xpc3QwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBsaXN0cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuTGlzdF0gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIExpc3QgPSBMaXN0MF0uICBEZWZpbmluZyBbbW9kdWxlIExpc3QgPSBMaXN0MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdFxuICAgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5MaXN0XS4gKilcblxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBoZF9leG4gPSBTdGRsaWIuTGlzdC5oZFxubGV0IGxlbmd0aCA9IFN0ZGxpYi5MaXN0Lmxlbmd0aFxubGV0IHJldl9hcHBlbmQgPSBTdGRsaWIuTGlzdC5yZXZfYXBwZW5kXG5sZXQgdGxfZXhuID0gU3RkbGliLkxpc3QudGxcbmxldCB1bnppcCA9IFN0ZGxpYi5MaXN0LnNwbGl0XG5cbigqIFNvbWUgb2YgdGhlc2UgYXJlIGV0YSBleHBhbmRlZCBpbiBvcmRlciB0byBwZXJtdXRlIHBhcmFtZXRlciBvcmRlciB0byBmb2xsb3cgQmFzZVxuICAgY29udmVudGlvbnMuICopXG5cbmxldCByZWMgZXhpc3RzIHQgfmY6KGYgW0Bsb2NhbF0pID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCB4IDo6IHhzIC0+IGlmIGYgeCB0aGVuIHRydWUgZWxzZSBleGlzdHMgeHMgfmZcbjs7XG5cbmxldCByZWMgZXhpc3RzMl9vayBsMSBsMiB+ZjooKGYgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gZmFsc2VcbiAgfCBhMSA6OiBsMSwgYTIgOjogbDIgLT4gZiBhMSBhMiB8fCBleGlzdHMyX29rIGwxIGwyIH5mXG4gIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG47O1xuXG5sZXQgcmVjIGZvbGQgdCB+aW5pdCB+ZjooKGYgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gaW5pdFxuICB8IGEgOjogbCAtPiBmb2xkIGwgfmluaXQ6KGYgaW5pdCBhKSB+ZlxuOztcblxubGV0IHJlYyBmb2xkMl9vayBsMSBsMiB+aW5pdCB+ZjooKGYgOiBfIC0+IF8gLT4gXyAtPiBfKSBbQGxvY2FsXSkgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiBpbml0XG4gIHwgYTEgOjogbDEsIGEyIDo6IGwyIC0+IGZvbGQyX29rIGwxIGwyIH5mIH5pbml0OihmIGluaXQgYTEgYTIpXG4gIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mOihmIFtAbG9jYWxdKSA9IG5vdCAoZXhpc3RzIHQgfmY6KGZ1biB4IC0+IG5vdCAoZiB4KSkpXG5cbmxldCByZWMgZm9yX2FsbDJfb2sgbDEgbDIgfmY6KChmIDogXyAtPiBfIC0+IF8pIFtAbG9jYWxdKSA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBhMSA6OiBsMSwgYTIgOjogbDIgLT4gZiBhMSBhMiAmJiBmb3JfYWxsMl9vayBsMSBsMiB+ZlxuICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcbjs7XG5cbmxldCByZWMgaXRlciB0IH5mOigoZiA6IF8gLT4gXykgW0Bsb2NhbF0pID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCBhIDo6IGwgLT5cbiAgICBmIGE7XG4gICAgaXRlciBsIH5mXG47O1xuXG5sZXQgcmVjIGl0ZXIyX29rIGwxIGwyIH5mOigoZiA6IF8gLT4gXyAtPiB1bml0KSBbQGxvY2FsXSkgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAoKVxuICB8IGExIDo6IGwxLCBhMiA6OiBsMiAtPlxuICAgIGYgYTEgYTI7XG4gICAgaXRlcjJfb2sgbDEgbDIgfmZcbiAgfCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG47O1xuXG5sZXQgcmVjIG5vbnRhaWxfbWFwIHQgfmY6KGYgW0Bsb2NhbF0pID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IHhzIC0+XG4gICAgbGV0IHkgPSBmIHggaW5cbiAgICB5IDo6IG5vbnRhaWxfbWFwIHhzIH5mXG47O1xuXG5sZXQgbm9udGFpbF9tYXBpIHQgfmYgPSBTdGRsaWIuTGlzdC5tYXBpIHQgfmZcbmxldCBwYXJ0aXRpb24gdCB+ZiA9IFN0ZGxpYi5MaXN0LnBhcnRpdGlvbiB0IH5mXG5cbmxldCByZXZfbWFwID1cbiAgbGV0IHJlYyBybWFwX2YgZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGEgOjogbCAtPiBybWFwX2YgZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgZnVuIGwgfmY6KGYgW0Bsb2NhbF0pIC0+IHJtYXBfZiBmIFtdIGxcbjs7XG5cbmxldCByZXZfbWFwMl9vayA9XG4gIGxldCByZWMgcm1hcDJfZiBmIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgW10gLT4gYWNjdVxuICAgIHwgYTEgOjogbDEsIGEyIDo6IGwyIC0+IHJtYXAyX2YgZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBmdW4gbDEgbDIgfmY6KChmIDogXyAtPiBfIC0+IF8pIFtAbG9jYWxdKSAtPiBybWFwMl9mIGYgW10gbDEgbDJcbjs7XG5cbmxldCBzb3J0IGwgfmNvbXBhcmUgPSBTdGRsaWIuTGlzdC5zb3J0IGwgfmNtcDpjb21wYXJlXG5sZXQgc3RhYmxlX3NvcnQgbCB+Y29tcGFyZSA9IFN0ZGxpYi5MaXN0LnN0YWJsZV9zb3J0IGwgfmNtcDpjb21wYXJlXG5cbmxldCByZXYgPSBmdW5jdGlvblxuICB8IChbXSB8IFsgXyBdKSBhcyByZXMgLT4gcmVzXG4gIHwgeCA6OiB5IDo6IHJlc3QgLT4gcmV2X2FwcGVuZCByZXN0IFsgeTsgeCBdXG47O1xuXG5sZXQgZm9sZF9yaWdodCBsIH5mOigoZiA6IF8gLT4gXyAtPiBfKSBbQGxvY2FsXSkgfmluaXQgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBpbml0ICgqIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIFt+Zl0gYmVsb3cgKilcbiAgfCBfIC0+IGZvbGQgfmY6KGZ1biBhIGIgLT4gZiBiIGEpIH5pbml0IChyZXYgbCkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfcmlnaHQyX29rIGwxIGwyIH5mOigoZiA6IF8gLT4gXyAtPiBfIC0+IF8pIFtAbG9jYWxdKSB+aW5pdCA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IGluaXQgKCogYXZvaWQgdGhlIGFsbG9jYXRpb24gb2YgW35mXSBiZWxvdyAqKVxuICB8IF8sIF8gLT4gZm9sZDJfb2sgfmY6KGZ1biBhIGIgYyAtPiBmIGIgYyBhKSB+aW5pdCAocmV2IGwxKSAocmV2IGwyKSBbQG5vbnRhaWxdXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE1NTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiZGVzY3JpcHRpb24iLCJCYXNlX0ltcG9ydDAiLCJCYXNlX0ludDAiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9MaXN0MCIsIkJhc2VfQ2hhcjAiLCJGb2xkaW5nIiwiSGFzaCIsImhhc2hfZm9sZF91bml0IiwicyIsInBhcmFtIiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF9zdHJpbmciLCJhc19pbnQiLCJ4IiwiaGFzaF9mb2xkX2ludDMyIiwiaGFzaF9mb2xkX2NoYXIiLCJoYXNoX2ZvbGRfYm9vbCIsImhhc2hfZm9sZF9uYXRpdmVpbnQiLCJoYXNoX2ZvbGRfb3B0aW9uIiwiaGFzaF9mb2xkX2VsZW0iLCJoYXNoX2ZvbGRfbGlzdCIsImxpc3QiLCJoYXNoX2ZvbGRfbGF6eV90IiwiaGFzaF9mb2xkX3JlZl9mcm96ZW4iLCJoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIiwiYXJyYXkiLCJpIiwiZSIsImhhc2hfbmF0aXZlaW50IiwiaGFzaF9pbnQ2NCIsImhhc2hfaW50MzIiLCJoYXNoX2NoYXIiLCJoYXNoX2ludCIsImhhc2hfYm9vbCIsImhhc2hfc3RyaW5nIiwiaGFzaF9mbG9hdCIsImhhc2hfdW5pdCIsIkYiLCJmb2xkX2ludCIsImZvbGRfaW50NjQiLCJmb2xkX2Zsb2F0IiwiZm9sZF9zdHJpbmciLCJhbGxvYyIsInJlc2V0IiwiZ2V0X2hhc2hfdmFsdWUiLCJGb3JfdGVzdHMiLCJjcmVhdGUiLCJzZWVkIiwib2ZfZm9sZCIsImhhc2hfZm9sZF90IiwidCIsIkJ1aWx0aW4iLCJydW4iLCJmb2xkZXIiLCJvcHQiLCJjb21wYXJlX3N0YXRlIiwic3RhdGVfdG9fc3RyaW5nIiwic3RhdGUiLCJCYXNlX0hhc2giXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9oYXNoLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFB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b250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCpcbiAgIFRoaXMgaXMgdGhlIGludGVyZmFjZSB0byB0aGUgcnVudGltZSBzdXBwb3J0IGZvciBbcHB4X2hhc2hdLlxuXG4gICBUaGUgW3BweF9oYXNoXSBzeW50YXggZXh0ZW5zaW9uIHN1cHBvcnRzOiBbQEBkZXJpdmluZyBoYXNoXSBhbmQgWyVoYXNoX2ZvbGQ6IFRZUEVdIGFuZFxuICAgWyVoYXNoOiBUWVBFXVxuXG4gICBGb3IgdHlwZSBbdF0gYSBmdW5jdGlvbiBbaGFzaF9mb2xkX3RdIG9mIHR5cGUgW0hhc2guc3RhdGUgLT4gdCAtPiBIYXNoLnN0YXRlXSBpc1xuICAgZ2VuZXJhdGVkLlxuXG4gICBUaGUgZ2VuZXJhdGVkIFtoYXNoX2ZvbGRfPFQ+XSBmdW5jdGlvbiBpcyBjb21wb3NpdGlvbmFsLCBmb2xsb3dpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGVcbiAgIHR5cGU7IGFsbG93aW5nIHVzZXIgb3ZlcnJpZGVzIGF0IGV2ZXJ5IGxldmVsLiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIG9jYW1sJ3MgYnVpbHRpblxuICAgcG9seW1vcnBoaWMgaGFzaGluZyBbSGFzaHRibC5oYXNoXSB3aGljaCBpZ25vcmVzIHVzZXIgb3ZlcnJpZGVzLlxuXG4gICBUaGUgZ2VuZXJhdG9yIGFsc28gcHJvdmlkZXMgYSBkaXJlY3QgaGFzaC1mdW5jdGlvbiBbaGFzaF0gKG5hbWVkIFtoYXNoXzxUPl0gd2hlbiA8VD4gIT1cbiAgIFwidFwiKSBvZiB0eXBlOiBbdCAtPiBIYXNoLmhhc2hfdmFsdWVdLlxuXG4gICBUaGUgZm9sZGluZyBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2hfZm9sZDogVFlQRV1cbiAgIFRoZSBkaXJlY3QgaGFzaCBmdW5jdGlvbiBjYW4gYmUgYWNjZXNzZWQgYXMgWyVoYXNoOiBUWVBFXVxuKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgQ2hhciA9IENoYXIwXG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBIYXNoX2ludGZcblxuKCoqIEJ1aWx0aW4gZm9sZGluZy1zdHlsZSBoYXNoIGZ1bmN0aW9ucywgYWJzdHJhY3RlZCBvdmVyIFtIYXNoX2ludGYuU10gKilcbm1vZHVsZSBGb2xkaW5nIChIYXNoIDogSGFzaF9pbnRmLlMpIDpcbiAgSGFzaF9pbnRmLkJ1aWx0aW5faW50ZlxuICB3aXRoIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gICBhbmQgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlID0gc3RydWN0XG4gIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICB0eXBlICdhIGZvbGRlciA9IHN0YXRlIC0+ICdhIC0+IHN0YXRlXG5cbiAgbGV0IGhhc2hfZm9sZF91bml0IHMgKCkgPSBzXG4gIGxldCBoYXNoX2ZvbGRfaW50ID0gSGFzaC5mb2xkX2ludFxuICBsZXQgaGFzaF9mb2xkX2ludDY0ID0gSGFzaC5mb2xkX2ludDY0XG4gIGxldCBoYXNoX2ZvbGRfZmxvYXQgPSBIYXNoLmZvbGRfZmxvYXRcbiAgbGV0IGhhc2hfZm9sZF9zdHJpbmcgPSBIYXNoLmZvbGRfc3RyaW5nXG4gIGxldCBhc19pbnQgZiBzIHggPSBoYXNoX2ZvbGRfaW50IHMgKGYgeClcblxuICAoKiBUaGlzIGlnbm9yZXMgdGhlIHNpZ24gYml0IG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyB1bmxpa2VseSB0byBsZWFkIHRvXG4gICAgIGZyZXF1ZW50IGNvbGxpc2lvbnMgKG1pbl92YWx1ZSBjb2xsaWRpbmcgd2l0aCAwIGlzIHRoZSBtb3N0IGxpa2VseSBvbmUpLiAgKilcbiAgbGV0IGhhc2hfZm9sZF9pbnQzMiA9IGFzX2ludCBTdGRsaWIuSW50MzIudG9faW50XG4gIGxldCBoYXNoX2ZvbGRfY2hhciA9IGFzX2ludCBDaGFyLnRvX2ludFxuXG4gIGxldCBoYXNoX2ZvbGRfYm9vbCA9XG4gICAgYXNfaW50IChmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IDFcbiAgICAgIHwgZmFsc2UgLT4gMClcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX25hdGl2ZWludCBzIHggPSBoYXNoX2ZvbGRfaW50NjQgcyAoU3RkbGliLkludDY0Lm9mX25hdGl2ZWludCB4KVxuXG4gIGxldCBoYXNoX2ZvbGRfb3B0aW9uIGhhc2hfZm9sZF9lbGVtIHMgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBoYXNoX2ZvbGRfaW50IHMgMFxuICAgIHwgU29tZSB4IC0+IGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfaW50IHMgMSkgeFxuICA7O1xuXG4gIGxldCByZWMgaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gc1xuICAgIHwgeCA6OiB4cyAtPiBoYXNoX2ZvbGRfbGlzdF9ib2R5IGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfZWxlbSBzIHgpIHhzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF9lbGVtIHMgbGlzdCA9XG4gICAgKCogVGhlIFtsZW5ndGhdIG9mIHRoZSBsaXN0IG11c3QgYmUgaW5jb3Jwb3JhdGVkIGludG8gdGhlIGhhc2gtc3RhdGUgc28gdmFsdWVzIG9mXG4gICAgICAgdHlwZXMgc3VjaCBhcyBbdW5pdCBsaXN0XSAtIChbXSwgWygpXSwgWygpOygpXSwuLikgYXJlIGhhc2hlZCBkaWZmZXJlbnRseS4gKilcbiAgICAoKiBUaGUgW2xlbmd0aF0gbXVzdCBjb21lIGJlZm9yZSB0aGUgZWxlbWVudHMgdG8gYXZvaWQgYSB2aW9sYXRpb24gb2YgdGhlIHJ1bGVcbiAgICAgICBlbmZvcmNlZCBieSBQZXJmZWN0X2hhc2guICopXG4gICAgbGV0IHMgPSBoYXNoX2ZvbGRfaW50IHMgKExpc3QubGVuZ3RoIGxpc3QpIGluXG4gICAgbGV0IHMgPSBoYXNoX2ZvbGRfbGlzdF9ib2R5IGhhc2hfZm9sZF9lbGVtIHMgbGlzdCBpblxuICAgIHNcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2xhenlfdCBoYXNoX2ZvbGRfZWxlbSBzIHggPSBoYXNoX2ZvbGRfZWxlbSBzIChTdGRsaWIuTGF6eS5mb3JjZSB4KVxuICBsZXQgaGFzaF9mb2xkX3JlZl9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAheFxuXG4gIGxldCByZWMgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgaSA9XG4gICAgaWYgaSA9IEFycmF5Lmxlbmd0aCBhcnJheVxuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGUgPSBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkgaW5cbiAgICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyBlKSBhcnJheSAoaSArIDEpKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgPVxuICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faVxuICAgICAgKCogW2xlbmd0aF0gbXVzdCBiZSBpbmNvcnBvcmF0ZWQgZm9yIGFycmF5cywgYXMgaXQgaXMgZm9yIGxpc3RzLiBTZWUgY29tbWVudCBhYm92ZSAqKVxuICAgICAgaGFzaF9mb2xkX2VsZW1cbiAgICAgIChoYXNoX2ZvbGRfaW50IHMgKEFycmF5Lmxlbmd0aCBhcnJheSkpXG4gICAgICBhcnJheVxuICAgICAgMFxuICA7O1xuXG4gICgqIHRoZSBkdXBsaWNhdGlvbiBoZXJlIGlzIGJlY2F1c2Ugd2UgdGhpbmtcbiAgICAgb2NhbWwgY2FuJ3QgZWxpbWluYXRlIGluZGlyZWN0IGZ1bmN0aW9uIGNhbGxzIG90aGVyd2lzZS4gKilcbiAgbGV0IGhhc2hfbmF0aXZlaW50IHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9uYXRpdmVpbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2ludDY0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50NjQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQzMiB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludDMyIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfY2hhciB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2NoYXIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9ib29sIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfYm9vbCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5cbiAgbGV0IGhhc2hfc3RyaW5nIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9zdHJpbmcgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2Zsb2F0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfZmxvYXQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF91bml0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdW5pdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5lbmRcblxubW9kdWxlIEYgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuRnVsbFxuICB3aXRoIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICAgYW5kIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gICBhbmQgdHlwZSBzZWVkID0gSGFzaC5zZWVkID0gc3RydWN0XG4gIGluY2x1ZGUgSGFzaFxuXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgY3JlYXRlID9zZWVkICgpID0gcmVzZXQgP3NlZWQgKGFsbG9jICgpKVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBGb2xkaW5nIChIYXNoKVxuXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGZvbGRlciAoSGFzaC5yZXNldCA/c2VlZCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5lbmRcblxubW9kdWxlIEludGVybmFsaGFzaCA6IHNpZ1xuICBpbmNsdWRlXG4gICAgSGFzaF9pbnRmLlNcbiAgICB3aXRoIHR5cGUgc3RhdGUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zdGF0ZVxuICAgICAoKiBXZSBnaXZlIGEgY29uY3JldGUgdHlwZSBmb3IgW3N0YXRlXSwgYWxiZWl0IG9ubHkgcGFydGlhbGx5IGV4cG9zZWQgKHNlZVxuICAgICAgICBCYXNlX2ludGVybmFsaGFzaF90eXBlcyksIHNvIHRoYXQgaXQgdW5pZmllcyB3aXRoIHRoZSBzYW1lIHR5cGUgaW4gW0Jhc2VfYm9vdF0sXG4gICAgICAgIGFuZCB0byBhbGxvdyBvcHRpbWl6YXRpb25zIGZvciB0aGUgaW1tZWRpYXRlIHR5cGUuICopXG4gICAgIGFuZCB0eXBlIHNlZWQgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zZWVkXG4gICAgIGFuZCB0eXBlIGhhc2hfdmFsdWUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5oYXNoX3ZhbHVlXG5cbiAgZXh0ZXJuYWwgZm9sZF9pbnQ2NCA6IHN0YXRlIC0+IGludDY0IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0XCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX2ludCA6IHN0YXRlIC0+IGludCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcIiBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfZmxvYXQgOiBzdGF0ZSAtPiBmbG9hdCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9zdHJpbmcgOiBzdGF0ZSAtPiBzdHJpbmcgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBnZXRfaGFzaF92YWx1ZSA6IHN0YXRlIC0+IGhhc2hfdmFsdWUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXCJcbiAgW0BAbm9hbGxvY11cbmVuZCA9IHN0cnVjdFxuICBsZXQgZGVzY3JpcHRpb24gPSBcImludGVybmFsaGFzaFwiXG5cbiAgaW5jbHVkZSBCYXNlX2ludGVybmFsaGFzaF90eXBlc1xuXG4gIGxldCBhbGxvYyAoKSA9IGNyZWF0ZV9zZWVkZWQgMFxuICBsZXQgcmVzZXQgPyhzZWVkID0gMCkgX3QgPSBjcmVhdGVfc2VlZGVkIHNlZWRcblxuICBtb2R1bGUgRm9yX3Rlc3RzID0gc3RydWN0XG4gICAgbGV0IGNvbXBhcmVfc3RhdGUgKGEgOiBzdGF0ZSkgKGIgOiBzdGF0ZSkgPSBjb21wYXJlIChhIDo+IGludCkgKGIgOj4gaW50KVxuICAgIGxldCBzdGF0ZV90b19zdHJpbmcgKHN0YXRlIDogc3RhdGUpID0gSW50LnRvX3N0cmluZyAoc3RhdGUgOj4gaW50KVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICBpbmNsdWRlIEludGVybmFsaGFzaFxuXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgY3JlYXRlID9zZWVkICgpID0gcmVzZXQgP3NlZWQgKGFsbG9jICgpKVxuICBsZXQgcnVuID9zZWVkIGZvbGRlciB4ID0gZ2V0X2hhc2hfdmFsdWUgKGZvbGRlciAocmVzZXQgP3NlZWQgKGFsbG9jICgpKSkgeClcbiAgbGV0IG9mX2ZvbGQgaGFzaF9mb2xkX3QgdCA9IGdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdCAoY3JlYXRlICgpKSB0KVxuXG4gIG1vZHVsZSBCdWlsdGluID0gc3RydWN0XG4gICAgbW9kdWxlIEZvbGRpbmcgPSBGb2xkaW5nIChJbnRlcm5hbGhhc2gpXG4gICAgaW5jbHVkZSBGb2xkaW5nXG5cbiAgICAoKiBbRm9sZGluZ10gcHJvdmlkZXMgc29tZSBkZWZhdWx0IGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIFtoYXNoXypdIGZ1bmN0aW9ucyBiZWxvdyxcbiAgICAgICBidXQgdGhleSBhcmUgaW5lZmZpY2llbnQgZm9yIHNvbWUgdXNlLWNhc2VzIGJlY2F1c2Ugb2YgdGhlIHVzZSBvZiB0aGUgW2hhc2hfZm9sZF1cbiAgICAgICBmdW5jdGlvbnMuIEF0IHRoaXMgcG9pbnQsIHRoZSBbaGFzaF92YWx1ZV0gdHlwZSBoYXMgYmVlbiBmaXhlZCB0byBbaW50XSwgc28gdGhpc1xuICAgICAgIG1vZHVsZSBjYW4gcHJvdmlkZSBzcGVjaWFsaXplZCBpbXBsZW1lbnRhdGlvbnMuICopXG5cbiAgICBsZXQgaGFzaF9jaGFyID0gQ2hhcjAudG9faW50XG5cbiAgICAoKiBUaGlzIGhhc2ggd2FzIGNob3NlbiBmcm9tIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JhZGJveS82MjY3NzQzXG5cbiAgICAgICBJdCBhdHRlbXB0cyB0byBmdWxmaWxsIHRoZSBwcmltYXJ5IGdvYWxzIG9mIGEgbm9uLWNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbjpcblxuICAgICAgIC0gYSBiaXQgY2hhbmdlIGluIHRoZSBpbnB1dCBzaG91bGQgY2hhbmdlIH4xLzIgb2YgdGhlIG91dHB1dCBiaXRzXG4gICAgICAgLSB0aGUgb3V0cHV0IHNob3VsZCBiZSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgYWNyb3NzIHRoZSBvdXRwdXQgcmFuZ2VcbiAgICAgICAtIGlucHV0cyB0aGF0IGFyZSBjbG9zZSB0byBlYWNoIG90aGVyIHNob3VsZG4ndCBsZWFkIHRvIG91dHB1dHMgdGhhdCBhcmUgY2xvc2UgdG9cbiAgICAgICAgIGVhY2ggb3RoZXIuXG4gICAgICAgLSBhbGwgYml0cyBvZiB0aGUgaW5wdXQgYXJlIHVzZWQgaW4gZ2VuZXJhdGluZyB0aGUgb3V0cHV0XG5cbiAgICAgICBJbiBvdXIgY2FzZSB3ZSBhbHNvIHdhbnQgaXQgdG8gYmUgZmFzdCwgbm9uLWFsbG9jYXRpbmcsIGFuZCBpbmxpbmFibGUuICAqKVxuICAgIGxldFtAaW5saW5lIGFsd2F5c10gaGFzaF9pbnQgKHQgOiBpbnQpID1cbiAgICAgIGxldCB0ID0gbG5vdCB0ICsgKHQgbHNsIDIxKSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI0KSBpblxuICAgICAgbGV0IHQgPSB0ICsgKHQgbHNsIDMpICsgKHQgbHNsIDgpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMTQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMikgKyAodCBsc2wgNCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAyOCkgaW5cbiAgICAgIHQgKyAodCBsc2wgMzEpXG4gICAgOztcblxuICAgIGxldCBoYXNoX2Jvb2wgeCA9IGlmIHggdGhlbiAxIGVsc2UgMFxuXG4gICAgZXh0ZXJuYWwgaGFzaF9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiQmFzZV9oYXNoX2RvdWJsZVwiIFtAQG5vYWxsb2NdXG5cbiAgICBsZXQgaGFzaF91bml0ICgpID0gMFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIFRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxODk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF93aGljaF9pc19hYnN0cmFjdF9pbl9hbl9pbSIsImNhbWxfZXF1YWwiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9jYWxsMiIsImYiLCJhMCIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydDAiLCJCYXNlX1ByaW50ZiIsImNvbXBhcmVfYWJzdHJhY3QiLCJ0eXBlX25hbWUiLCJwYXJhbSIsImVxdWFsX2Fic3RyYWN0IiwiQ29tcGFyYWJsZSIsIkVxdWFsIiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfaW50IiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50NjQiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfc3RyaW5nIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfZWx0IiwiYSIsImIiLCJsZW5fYSIsImxlbl9iIiwicmV0IiwiaSIsImwiLCJyIiwicmVzIiwiY29tcGFyZV9saXN0IiwieXMiLCJ5IiwieHMiLCJ4IiwiY29tcGFyZV9vcHRpb24iLCJjb21wYXJlX3JlZiIsImVxdWFsX2Jvb2wiLCJlcXVhbF9jaGFyIiwiZXF1YWxfaW50IiwiZXF1YWxfaW50MzIiLCJlcXVhbF9pbnQ2NCIsImVxdWFsX25hdGl2ZWludCIsImVxdWFsX3N0cmluZyIsImVxdWFsX3VuaXQiLCJlcXVhbF9mbG9hdCIsImVxdWFsX2FycmF5IiwiZXF1YWxfZWx0IiwiZXF1YWxfbGlzdCIsImVxdWFsX29wdGlvbiIsImVxdWFsX3JlZiIsIkJhc2VfUHB4X2NvbXBhcmVfbGliIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQv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QUFzQixXQUFBRCxXQUFBMUIsR0FBQUM7QUFBQUEsUUFBQUQsTUFJTixHQUFBQyxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUFBUyxLQUFBO0FBQUEsUUFBQUMsSUFBQTtBQUFBLFFBQUFDLEtBQUE7QUFBQSxRQUFBQyxJQUFBO0FBQUEsY0FHc0I7QUFBQSxPQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUZ2QjtBQUFBLEtBQ087QUFBQTtBQUFBLEdBQzhDO0FBQUEsWUFBQWUsYUFBQUYsV0FBQTFCLEdBQUFDO0FBQUFBLElBSWpFO0FBQUE7QUFBQSxVQUFBQSxNQUFBLE1BQUFELE1BQUE7QUFBQSxNQUdvQixzQ0FBYTtBQUFBO0FBQUE7QUFBQSxpQkFGakI7QUFBQSxJQUNpQjtBQUFBLEdBQ0E7QUFBQSxZQUFBNkIsVUFBQUgsV0FBQTFCLEdBQUFDO0FBQUFBLElBR0wsd0NBQWU7QUFBQTtBQUFBO0FBQUEsSUFBQTZCO0FBQUFBLE1EdEsvQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBJbXBvcnQwXG5cbmxldCBjb21wYXJlX2Fic3RyYWN0IH50eXBlX25hbWUgXyBfID1cbiAgUHJpbnRmLmtzcHJpbnRmXG4gICAgZmFpbHdpdGhcbiAgICBcIkNvbXBhcmUgY2FsbGVkIG9uIHRoZSB0eXBlICVzLCB3aGljaCBpcyBhYnN0cmFjdCBpbiBhbiBpbXBsZW1lbnRhdGlvbi5cIlxuICAgIHR5cGVfbmFtZVxuOztcblxubGV0IGVxdWFsX2Fic3RyYWN0IH50eXBlX25hbWUgXyBfID1cbiAgUHJpbnRmLmtzcHJpbnRmXG4gICAgZmFpbHdpdGhcbiAgICBcIkVxdWFsIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbnR5cGUgJ2EgY29tcGFyZSA9ICdhIC0+ICdhIC0+IGludFxudHlwZSAnYSBlcXVhbCA9ICdhIC0+ICdhIC0+IGJvb2xcblxubW9kdWxlIENvbXBhcmFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYSB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYiBjb21wYXJlIC0+ICgnYSwgJ2IpIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYiBjb21wYXJlIC0+ICdjIGNvbXBhcmUgLT4gKCdhLCAnYiwgJ2MpIHQgY29tcGFyZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgRXF1YWwgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGVxdWFsIDogdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGVxdWFsIDogJ2EgZXF1YWwgLT4gJ2EgdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGVxdWFsIDogJ2EgZXF1YWwgLT4gJ2IgZXF1YWwgLT4gKCdhLCAnYikgdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICdjIGVxdWFsIC0+ICgnYSwgJ2IsICdjKSB0IGVxdWFsXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBCdWlsdGluID0gc3RydWN0XG4gIGxldCBjb21wYXJlX2Jvb2wgOiBib29sIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfY2hhciA6IGNoYXIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9mbG9hdCA6IGZsb2F0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfaW50IDogaW50IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfaW50MzIgOiBpbnQzMiBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDY0IDogaW50NjQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9zdHJpbmcgOiBzdHJpbmcgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV91bml0IDogdW5pdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG5cbiAgbGV0IGNvbXBhcmVfYXJyYXkgY29tcGFyZV9lbHQgYSBiID1cbiAgICBpZiBwaHlzX2VxdWFsIGEgYlxuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGxlbl9hID0gQXJyYXkwLmxlbmd0aCBhIGluXG4gICAgICBsZXQgbGVuX2IgPSBBcnJheTAubGVuZ3RoIGIgaW5cbiAgICAgIGxldCByZXQgPSBjb21wYXJlIGxlbl9hIGxlbl9iIGluXG4gICAgICBpZiByZXQgPD4gMFxuICAgICAgdGhlbiByZXRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICAgICAgaWYgaSA9IGxlbl9hXG4gICAgICAgICAgdGhlbiAwXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbCA9IEFycmF5MC51bnNhZmVfZ2V0IGEgaVxuICAgICAgICAgICAgYW5kIHIgPSBBcnJheTAudW5zYWZlX2dldCBiIGkgaW5cbiAgICAgICAgICAgIGxldCByZXMgPSBjb21wYXJlX2VsdCBsIHIgaW5cbiAgICAgICAgICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgbG9vcCAoaSArIDEpKVxuICAgICAgICBpblxuICAgICAgICBsb29wIDApKVxuICA7O1xuXG4gIGxldCByZWMgY29tcGFyZV9saXN0IGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBbXSwgW10gLT4gMFxuICAgIHwgW10sIF8gLT4gLTFcbiAgICB8IF8sIFtdIC0+IDFcbiAgICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICAgIGxldCByZXMgPSBjb21wYXJlX2VsdCB4IHkgaW5cbiAgICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgY29tcGFyZV9saXN0IGNvbXBhcmVfZWx0IHhzIHlzXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfb3B0aW9uIGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBOb25lLCBOb25lIC0+IDBcbiAgICB8IE5vbmUsIFNvbWUgXyAtPiAtMVxuICAgIHwgU29tZSBfLCBOb25lIC0+IDFcbiAgICB8IFNvbWUgYSwgU29tZSBiIC0+IGNvbXBhcmVfZWx0IGEgYlxuICA7O1xuXG4gIGxldCBjb21wYXJlX3JlZiBjb21wYXJlX2VsdCBhIGIgPSBjb21wYXJlX2VsdCAhYSAhYlxuICBsZXQgZXF1YWxfYm9vbCA6IGJvb2wgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9jaGFyIDogY2hhciBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludCA6IGludCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludDMyIDogaW50MzIgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQ2NCA6IGludDY0IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfbmF0aXZlaW50IDogbmF0aXZlaW50IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfc3RyaW5nIDogc3RyaW5nIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfdW5pdCA6IHVuaXQgZXF1YWwgPSBQb2x5LmVxdWFsXG5cbiAgKCogW1BvbHkuZXF1YWxdIGlzIElFRUUgY29tcGxpYW50LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50IGhlcmUuICopXG4gIGxldCBlcXVhbF9mbG9hdCB4IHkgPSBlcXVhbF9pbnQgKGNvbXBhcmVfZmxvYXQgeCB5KSAwXG5cbiAgbGV0IGVxdWFsX2FycmF5IGVxdWFsX2VsdCBhIGIgPVxuICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgfHxcbiAgICBsZXQgbGVuX2EgPSBBcnJheTAubGVuZ3RoIGEgaW5cbiAgICBsZXQgbGVuX2IgPSBBcnJheTAubGVuZ3RoIGIgaW5cbiAgICBlcXVhbCBsZW5fYSBsZW5fYlxuICAgICYmXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaSA9IGxlbl9hXG4gICAgICB8fFxuICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICBlcXVhbF9lbHQgbCByICYmIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG4gIDs7XG5cbiAgbGV0IHJlYyBlcXVhbF9saXN0IGVxdWFsX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IFtdLCBfIHwgXywgW10gLT4gZmFsc2VcbiAgICB8IHggOjogeHMsIHkgOjogeXMgLT4gZXF1YWxfZWx0IHggeSAmJiBlcXVhbF9saXN0IGVxdWFsX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb24gZXF1YWxfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgICB8IE5vbmUsIFNvbWUgXyB8IFNvbWUgXywgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gZXF1YWxfZWx0IGEgYlxuICA7O1xuXG4gIGxldCBlcXVhbF9yZWYgZXF1YWxfZWx0IGEgYiA9IGVxdWFsX2VsdCAhYSAhYlxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjExMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJTdGQiLCJIYXNoYWJsZSIsIkJhc2VfUHB4X2hhc2hfbGliIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxvQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxMjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiQmFzZV9QcHhfY29tcGFyZV9saWIiLCJCYXNlX0hhc2giLCJTZXhwbGliMF9TZXhwIiwiU2V4cGxpYjBfU2V4cF9jb252IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwiZXF1YWwiLCJOb3RfZm91bmRfcyIsIk9mX3NleHBfZXJyb3IiLCJtZXNzYWdlIiwiZGVmYXVsdF9pbmRlbnQiLCJwcF9odW0iLCJwcF9odW1faW5kZW50IiwicHBfbWFjaCIsInBwIiwidG9fc3RyaW5nX2h1bSIsInRvX3N0cmluZ19tYWNoIiwidG9fc3RyaW5nIiwib2ZfZmxvYXRfc3R5bGUiLCJvZl9pbnRfc3R5bGUiLCJQcml2YXRlIiwiY29tcGFyZSIsImFfMDAxIiwiYl8wMDIiLCJhXzAwMyIsImJfMDA0IiwiYV8wMDUiLCJiXzAwNiIsImxldHJlY19mdW5jdGlvbl9jb250ZXh0IiwiaGFzaF9mb2xkX3QiLCJoc3YiLCJhcmciLCJoYXNoIiwieCIsImZ1bmMiLCJ0X3NleHBfZ3JhbW1hciIsImludmFyaWFudCIsInBhcmFtIiwiQmFzZV9TZXhwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvc2V4cC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxZQUFBQyxRQUFBQyxPQUFBQztBQUFBQSxJQ1lLLG9CQUNLO0FBQUEsSUFDQTtBQUFBLFNBQUFDLFFBQUE7QUFBQSx3QkFHWTtBQUFBLFNBQUFDLFFBSFo7QUFBQSxLQUUrQiwyREFHdUM7QUFBQTtBQUFBLFFBQUFDLFFBTHRFO0FBQUEsdUJBSVk7QUFBQSxRQUFBQyxRQUpaO0FBQUEsSUFLK0IscUVBQXVDO0FBQUE7QUFBQSxPQUFBQywwQkRuQmhGO0FBQUEsWUFBQUMsWUFBQUMsS0FBQUM7QUFBQUEsSUN5Qks7QUFBQSxTQUFBckMsS0FBQSxRQUFBb0MsUUFFWTtBQUFBLEtBRVYsOENBSWtDO0FBQUE7QUFBQSxRQUFBcEMsT0FScEMsUUFBQW9DLFFBTVk7QUFBQSxJQUVWLDhEQUFrQztBQUFBO0FBQUEsWUFBQUUsS0FBQUMsR0FTOUIsZ0RBQU07QUFBQSxZQUFBQyxLQUFBSDtBQUFBQSxRQUFBRCxNQUhBLHVDQUNWO0FBQUEsSUFBbUIsb0NBQUM7QUFBQTtBQUFBLEdBRXpCO0FBQUEsT0FBQUssaUJBQUE7QUFBQSxZQUFBQyxVQUFBQyxPQU9zQixTQUFFO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQVB4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQxQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4gSGFzaC5CdWlsdGluXG5vcGVuIFBweF9jb21wYXJlX2xpYi5CdWlsdGluXG5pbmNsdWRlIFNleHBsaWIwLlNleHBcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID0gU2V4cGxpYjAuU2V4cC50ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxubGV0IHJlYyBjb21wYXJlID1cbiAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgaWYgU3RkbGliLiggPT0gKSBhX18wMDFfIGJfXzAwMl9cbiAgICAgdGhlbiAwXG4gICAgIGVsc2UgKFxuICAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgIHwgQXRvbSBfYV9fMDAzXywgQXRvbSBfYl9fMDA0XyAtPiBjb21wYXJlX3N0cmluZyBfYV9fMDAzXyBfYl9fMDA0X1xuICAgICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgICAgIHwgTGlzdCBfYV9fMDA1XywgTGlzdCBfYl9fMDA2XyAtPiBjb21wYXJlX2xpc3QgY29tcGFyZSBfYV9fMDA1XyBfYl9fMDA2XylcbiAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG47O1xuXG5sZXQgcmVjIChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBBdG9tIF9hMCAtPlxuICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgX2EwXG4gICAgIHwgTGlzdCBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF90IGhzdiBfYTBcbiAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcblxuYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2NvbnYuc2V4cF90X3NleHBfZ3JhbW1hclxubGV0IG9mX3N0cmluZyA9ICgpXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydDAiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJCYXNlX0hhc2giLCJCYXNlX1BweF9jb21wYXJlX2xpYiIsIkJhc2VfR2xvYmFsaXplIiwiQmFzZV9TZXhwIiwiRXhpdCIsIk5vdF9mb3VuZCIsIm1heF9pbnQiLCJtaW5faW50IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uX2Zsb2F0IiwiY2hhcl9vZl9pbnQiLCJzdHJpbmdfb2ZfYm9vbCIsImJvb2xfb2Zfc3RyaW5nX29wdCIsImJvb2xfb2Zfc3RyaW5nIiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2Zsb2F0IiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwicHJpbnRfY2hhciIsInByaW50X3N0cmluZyIsInByaW50X2J5dGVzIiwicHJpbnRfaW50IiwicHJpbnRfZmxvYXQiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfbmV3bGluZSIsInByZXJyX2NoYXIiLCJwcmVycl9zdHJpbmciLCJwcmVycl9ieXRlcyIsInByZXJyX2ludCIsInByZXJyX2Zsb2F0IiwicHJlcnJfZW5kbGluZSIsInByZXJyX25ld2xpbmUiLCJyZWFkX2xpbmUiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2ludCIsInJlYWRfZmxvYXRfb3B0IiwicmVhZF9mbG9hdCIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwib3Blbl9vdXRfZ2VuIiwiZmx1c2giLCJmbHVzaF9hbGwiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXRfYnl0ZXMiLCJvdXRwdXQiLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X2J5dGUiLCJvdXRwdXRfYmluYXJ5X2ludCIsIm91dHB1dF92YWx1ZSIsInNlZWtfb3V0IiwicG9zX291dCIsIm91dF9jaGFubmVsX2xlbmd0aCIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJvcGVuX2luIiwib3Blbl9pbl9iaW4iLCJvcGVuX2luX2dlbiIsImlucHV0X2NoYXIiLCJpbnB1dF9saW5lIiwiaW5wdXQiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfYnl0ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF92YWx1ZSIsInNlZWtfaW4iLCJwb3NfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsImNsb3NlX2luIiwiY2xvc2VfaW5fbm9lcnIiLCJzZXRfYmluYXJ5X21vZGVfaW4iLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic3ltYm9sIiwiZXhpdCIsImF0X2V4aXQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJkb19hdF9leGl0IiwiZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQiLCJTdGRsaWIiLCJib29sX3RvX2ludCIsIkludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhciIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJtYXgiLCJtaW4iLCJJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY18iLCJCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGEiLCJDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGEiLCJVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb20iLCJCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXAiLCJzeW1ib2xfY29uY2F0IiwiYXNyIiwibGFuZCIsImxub3QiLCJsb3IiLCJsc2wiLCJsc3IiLCJseG9yIiwibW9kIiwiYWJzIiwiZmFpbHdpdGgiLCJmc3QiLCJpbnZhbGlkX2FyZyIsInNuZCIsInBoeXNfZXF1YWwiLCJmbG9hdF9vZl9zdHJpbmciLCJhbV90ZXN0aW5nIiwiZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQiLCJ3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCIsInJlYWRfb2xkX29wdGlvbl9mb3JtYXQiLCJsaXN0X21hcCIsInNleHBfb2ZfdW5pdCIsInNleHBfb2ZfYm9vbCIsInNleHBfb2Zfc3RyaW5nIiwic2V4cF9vZl9ieXRlcyIsInNleHBfb2ZfY2hhciIsInNleHBfb2ZfaW50Iiwic2V4cF9vZl9mbG9hdCIsInNleHBfb2ZfaW50MzIiLCJzZXhwX29mX2ludDY0Iiwic2V4cF9vZl9uYXRpdmVpbnQiLCJzZXhwX29mX3JlZiIsInNleHBfb2ZfbGF6eV90Iiwic2V4cF9vZl9vcHRpb24iLCJzZXhwX29mX3BhaXIiLCJzZXhwX29mX3RyaXBsZSIsInNleHBfb2ZfbGlzdCIsInNleHBfb2ZfYXJyYXkiLCJzZXhwX29mX2hhc2h0YmwiLCJzZXhwX29mX29wYXF1ZSIsInNleHBfb2ZfZnVuIiwiT2Zfc2V4cF9lcnJvciIsInJlY29yZF9jaGVja19leHRyYV9maWVsZHMiLCJvZl9zZXhwX2Vycm9yIiwib2Zfc2V4cF9lcnJvcl9leG4iLCJ1bml0X29mX3NleHAiLCJib29sX29mX3NleHAiLCJzdHJpbmdfb2Zfc2V4cCIsImJ5dGVzX29mX3NleHAiLCJjaGFyX29mX3NleHAiLCJpbnRfb2Zfc2V4cCIsImZsb2F0X29mX3NleHAiLCJpbnQzMl9vZl9zZXhwIiwiaW50NjRfb2Zfc2V4cCIsIm5hdGl2ZWludF9vZl9zZXhwIiwicmVmX29mX3NleHAiLCJsYXp5X3Rfb2Zfc2V4cCIsIm9wdGlvbl9vZl9zZXhwIiwicGFpcl9vZl9zZXhwIiwidHJpcGxlX29mX3NleHAiLCJsaXN0X29mX3NleHAiLCJhcnJheV9vZl9zZXhwIiwiaGFzaHRibF9vZl9zZXhwIiwib3BhcXVlX29mX3NleHAiLCJmdW5fb2Zfc2V4cCIsInNleHBfZ3JhbW1hcl93aXRoX3RhZ3MiLCJzZXhwX2dyYW1tYXJfd2l0aF90YWdfbGlzdCIsInVuaXRfc2V4cF9ncmFtbWFyIiwiYm9vbF9zZXhwX2dyYW1tYXIiLCJzdHJpbmdfc2V4cF9ncmFtbWFyIiwiYnl0ZXNfc2V4cF9ncmFtbWFyIiwiY2hhcl9zZXhwX2dyYW1tYXIiLCJpbnRfc2V4cF9ncmFtbWFyIiwiZmxvYXRfc2V4cF9ncmFtbWFyIiwiaW50MzJfc2V4cF9ncmFtbWFyIiwiaW50NjRfc2V4cF9ncmFtbWFyIiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciIsInNleHBfdF9zZXhwX2dyYW1tYXIiLCJyZWZfc2V4cF9ncmFtbWFyIiwibGF6eV90X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9zZXhwX2dyYW1tYXIiLCJsaXN0X3NleHBfZ3JhbW1hciIsImFycmF5X3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9zZXhwX2dyYW1tYXIiLCJmdW5fc2V4cF9ncmFtbWFyIiwic2V4cF9vZl9leG4iLCJwcmludGV4Y19wcmVmZXJfc2V4cCIsInNleHBfb2ZfZXhuX29wdCIsIkV4bl9jb252ZXJ0ZXIiLCJoYXNoX2ZvbGRfbmF0aXZlaW50IiwiaGFzaF9mb2xkX2ludDY0IiwiaGFzaF9mb2xkX2ludDMyIiwiaGFzaF9mb2xkX2NoYXIiLCJoYXNoX2ZvbGRfaW50IiwiaGFzaF9mb2xkX2Jvb2wiLCJoYXNoX2ZvbGRfc3RyaW5nIiwiaGFzaF9mb2xkX2Zsb2F0IiwiaGFzaF9mb2xkX3VuaXQiLCJoYXNoX2ZvbGRfb3B0aW9uIiwiaGFzaF9mb2xkX2xpc3QiLCJoYXNoX2ZvbGRfbGF6eV90IiwiaGFzaF9mb2xkX3JlZl9mcm96ZW4iLCJoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIiwiaGFzaF9uYXRpdmVpbnQiLCJoYXNoX2ludDY0IiwiaGFzaF9pbnQzMiIsImhhc2hfY2hhciIsImhhc2hfaW50IiwiaGFzaF9ib29sIiwiaGFzaF9zdHJpbmciLCJoYXNoX2Zsb2F0IiwiaGFzaF91bml0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfaW50IiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50NjQiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfc3RyaW5nIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfbGlzdCIsImNvbXBhcmVfb3B0aW9uIiwiY29tcGFyZV9yZWYiLCJlcXVhbF9ib29sIiwiZXF1YWxfY2hhciIsImVxdWFsX2Zsb2F0IiwiZXF1YWxfaW50IiwiZXF1YWxfaW50MzIiLCJlcXVhbF9pbnQ2NCIsImVxdWFsX25hdGl2ZWludCIsImVxdWFsX3N0cmluZyIsImVxdWFsX3VuaXQiLCJlcXVhbF9hcnJheSIsImVxdWFsX2xpc3QiLCJlcXVhbF9vcHRpb24iLCJlcXVhbF9yZWYiLCJnbG9iYWxpemVfYm9vbCIsImdsb2JhbGl6ZV9jaGFyIiwiZ2xvYmFsaXplX2Zsb2F0IiwiZ2xvYmFsaXplX2ludCIsImdsb2JhbGl6ZV9pbnQzMiIsImdsb2JhbGl6ZV9pbnQ2NCIsImdsb2JhbGl6ZV9uYXRpdmVpbnQiLCJnbG9iYWxpemVfYnl0ZXMiLCJnbG9iYWxpemVfc3RyaW5nIiwiZ2xvYmFsaXplX3VuaXQiLCJnbG9iYWxpemVfYXJyYXkiLCJnbG9iYWxpemVfbGlzdCIsImdsb2JhbGl6ZV9vcHRpb24iLCJnbG9iYWxpemVfcmVzdWx0IiwiZ2xvYmFsaXplX3JlZiIsIk5vdF9mb3VuZF9zIiwiQmFzZV9JbXBvcnQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFD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QUFBLElBQUFDLGdCQUFBO0FBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mjc4NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1N5czAiLCJCYXNlX0ltcG9ydCIsInNleHBfb2ZfdCIsInBhcmFtIiwibnVtX2JpdHMiLCJjc3RfdW5rbm93bl93b3JkX3NpemUiLCJ3b3JkX3NpemUiLCJCYXNlX1dvcmRfc2l6ZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL3dvcmRfc2l6ZS5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsVUFBQUMsT0NTRyx3QkFFa0M7QUFBQSxZQUFBQyxTQUFBRCxPQU10QixzQkFFRjtBQUFBO0FBQUEsVURuQmI7QUFBQSxJQUFBRSx3QkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBLDBCQzBCUztBQUFBLElBQUFDLGlCRDFCVCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPVxuICB8IFczMlxuICB8IFc2NFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IFczMiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXMzJcIlxuICAgIHwgVzY0IC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlc2NFwiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBudW1fYml0cyA9IGZ1bmN0aW9uXG4gIHwgVzMyIC0+IDMyXG4gIHwgVzY0IC0+IDY0XG47O1xuXG5sZXQgd29yZF9zaXplID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZV9pbl9iaXRzIHdpdGhcbiAgfCAzMiAtPiBXMzJcbiAgfCA2NCAtPiBXNjRcbiAgfCBfIC0+IGZhaWx3aXRoIFwidW5rbm93biB3b3JkIHNpemVcIlxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyODE3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfRm9ybWF0dGVyIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0Zvcm1hdCIsIkJhc2VfSW1wb3J0IiwiciIsImNzdF9wcCIsImFsbCIsInBhcmFtIiwicmVnaXN0ZXIiLCJwIiwiUmVnaXN0ZXJfcHAiLCJNIiwicHAiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwibW9kdWxlX25hbWUiLCJmb3JtYXR0ZXIiLCJ0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvcHJldHR5X3ByaW50ZXIubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxJQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLFlBQUFDLElBQUFDLE9DR2EsWUFBRTtBQUFBLFlBQUFDLFNBQUFDLEdBQ0UsOEJBQVk7QUFBQSxZQUFBQyxZQUFBQztBQUFBQSxRQUFBQyxLREo3QjtBQUFBLElDb0JXLFNBQVM7QUFBQSxJQUF1QjtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRHBCM0M7QUFBQTtBQUFBLGdCQUFBRjtBQUFBQSxZQUFBRyxjQUFBO0FBQUEsaUJBQUFGLEdBQUFHLFdBQUFDO0FBQUFBLGFBQUEsTUNnQ2lFO0FBQUEsU0FBZTtBQUFBO0FBQUEsUURoQ2hGIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxubGV0IHIgPSByZWYgWyBcIkJhc2UuU2V4cC5wcF9odW1cIiBdXG5sZXQgYWxsICgpID0gIXJcbmxldCByZWdpc3RlciBwID0gciA6PSBwIDo6ICFyXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHBwIDogRm9ybWF0dGVyLnQgLT4gdCAtPiB1bml0XG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyX3BwIChNIDogc2lnXG4gICAgaW5jbHVkZSBTXG5cbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgbGV0ICgpID0gcmVnaXN0ZXIgKE0ubW9kdWxlX25hbWUgXiBcIi5wcFwiKVxuZW5kXG5cbm1vZHVsZSBSZWdpc3RlciAoTSA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gIGVuZCkgPVxuICBSZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICBsZXQgcHAgZm9ybWF0dGVyIHQgPSBTdGRsaWIuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgKE0udG9fc3RyaW5nIHQpXG4gIGVuZClcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyODc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF8yIiwiY3N0X3NyY19leG5fbWwiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiU3RkbGliX1ByaW50ZXhjIiwiQmFzZV9JbXBvcnQiLCJTdGRsaWJfUHJpbnRmIiwiU3RkbGliX0Zvcm1hdCIsIkJhc2VfU2V4cCIsIkJhc2VfUHJpbnRmIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwic2V4cF9vZl90IiwiZXhpdCIsIkZpbmFsbHkiLCJwYXJhbSIsImFyZzFfMDAyIiwiYXJnMF8wMDEiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwiUmVyYWlzZWQiLCJhcmcxXzAwNiIsImFyZzBfMDA1IiwicmVzMF8wMDciLCJyZXMxXzAwOCIsIlNleHAiLCJ0IiwiY3JlYXRlX3MiLCJzZXhwIiwicmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJyZXJhaXNlIiwiZXhuIiwic3RyIiwiYnQiLCJyZXJhaXNlZiIsImV4YyIsImZvcm1hdCIsInRvX3N0cmluZyIsInRvX3N0cmluZ19tYWNoIiwicHJvdGVjdHgiLCJ4IiwiZmluYWxseSIsInJlcyIsImZpbmFsX2V4biIsInByb3RlY3QiLCJkb2VzX3JhaXNlIiwicHAiLCJwcGYiLCJtYXRjaCIsImluY2x1ZGUiLCJwcmludF93aXRoX2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2UiLCJoYW5kbGVfdW5jYXVnaHRfYXV4IiwiZG9fYXRfZXhpdCIsImhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCIsImhhbmRsZV91bmNhdWdodCIsIm11c3RfZXhpdCIsInJlcmFpc2VfdW5jYXVnaHQiLCJmdW5jIiwicmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UiLCJlIiwiaW5pdGlhbGl6ZV9tb2R1bGUiLCJjbGVhcl9iYWNrdHJhY2UiLCJQcml2YXRlIiwiQmFzZV9FeG4iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9leG4ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FB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dCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBleG4gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9leG4gOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuW0BAQGVuZF1cblxubGV0IGV4aXQgPSBTdGRsaWIuZXhpdFxuXG5leGNlcHRpb24gRmluYWxseSBvZiB0ICogdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEZpbmFsbHldIChmdW5jdGlvblxuICAgIHwgRmluYWxseSAoYXJnMF9fMDAxXywgYXJnMV9fMDAyXykgLT5cbiAgICAgIGxldCByZXMwX18wMDNfID0gc2V4cF9vZl90IGFyZzBfXzAwMV9cbiAgICAgIGFuZCByZXMxX18wMDRfID0gc2V4cF9vZl90IGFyZzFfXzAwMl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImV4bi5tbC5GaW5hbGx5XCI7IHJlczBfXzAwM187IHJlczFfXzAwNF8gXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5leGNlcHRpb24gUmVyYWlzZWQgb2Ygc3RyaW5nICogdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFJlcmFpc2VkXSAoZnVuY3Rpb25cbiAgICB8IFJlcmFpc2VkIChhcmcwX18wMDVfLCBhcmcxX18wMDZfKSAtPlxuICAgICAgbGV0IHJlczBfXzAwN18gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDVfXG4gICAgICBhbmQgcmVzMV9fMDA4XyA9IHNleHBfb2ZfdCBhcmcxX18wMDZfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJleG4ubWwuUmVyYWlzZWRcIjsgcmVzMF9fMDA3XzsgcmVzMV9fMDA4XyBdXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmV4Y2VwdGlvbiBTZXhwIG9mIFNleHAudFxuXG4oKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlOlxuXG4gICB7W1xuICAgICBleGNlcHRpb24gU2V4cCBvZiBTZXhwLnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG4gICAgICgqIC4uLiAqKVxuICAgICBbQEBAZW5kXVxuICAgXX1cblxuICAgdG8gZWxpbWluYXRlIHRoZSBleHRyYSB3cmFwcGluZyBvZiBbKFNleHAgLi4uKV0uICopXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2V4cF0gKGZ1bmN0aW9uXG4gICAgfCBTZXhwIHQgLT4gdFxuICAgIHwgXyAtPlxuICAgICAgKCogUmVhY2hpbmcgdGhpcyBicmFuY2ggaW5kaWNhdGVzIGEgYnVnIGluIHNleHBsaWIuICopXG4gICAgICBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgY3JlYXRlX3Mgc2V4cCA9IFNleHAgc2V4cFxuXG5sZXQgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgdCBiYWNrdHJhY2UgPVxuICBTdGRsaWIuUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgdCBiYWNrdHJhY2Vcbjs7XG5cbmV4dGVybmFsIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgOiB0IC0+IGJvb2wgPSBcIkJhc2VfY2FtbF9leG5faXNfbW9zdF9yZWNlbnRfZXhuXCJcblxubGV0IHJlcmFpc2UgZXhuIHN0ciA9XG4gIGxldCBleG4nID0gUmVyYWlzZWQgKHN0ciwgZXhuKSBpblxuICBpZiBpc19waHlzX2VxdWFsX21vc3RfcmVjZW50IGV4blxuICB0aGVuIChcbiAgICBsZXQgYnQgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4nIGJ0KVxuICBlbHNlIHJhaXNlIGV4bidcbjs7XG5cbmxldCByZXJhaXNlZiBleGMgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gc3RyICgpIC0+IHJlcmFpc2UgZXhjIHN0cikgZm9ybWF0XG5sZXQgdG9fc3RyaW5nIGV4YyA9IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgKHNleHBfb2ZfZXhuIGV4YylcbmxldCB0b19zdHJpbmdfbWFjaCBleGMgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX2V4biBleGMpXG5sZXQgc2V4cF9vZl90ID0gc2V4cF9vZl9leG5cblxubGV0IHByb3RlY3R4IH5mIHggfihmaW5hbGx5IDogXyAtPiB1bml0KSA9XG4gIG1hdGNoIGYgeCB3aXRoXG4gIHwgcmVzIC0+XG4gICAgZmluYWxseSB4O1xuICAgIHJlc1xuICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICBsZXQgYnQgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAobWF0Y2ggZmluYWxseSB4IHdpdGhcbiAgICAgfCAoKSAtPiByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4gYnRcbiAgICAgfCBleGNlcHRpb24gZmluYWxfZXhuIC0+XG4gICAgICAgKCogVW5mb3J0dW5hdGVseSwgdGhlIGJhY2t0cmFjZSBvZiB0aGUgW2ZpbmFsX2V4bl0gaXMgZGlzY2FyZGVkIGhlcmUuICopXG4gICAgICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKEZpbmFsbHkgKGV4biwgZmluYWxfZXhuKSkgYnQpXG47O1xuXG5sZXQgcHJvdGVjdCB+ZiB+ZmluYWxseSA9IHByb3RlY3R4IH5mICgpIH5maW5hbGx5XG5cbmxldCBkb2VzX3JhaXNlICh0eXBlIGEpIChmIDogdW5pdCAtPiBhKSA9XG4gIHRyeVxuICAgIGlnbm9yZSAoZiAoKSA6IGEpO1xuICAgIGZhbHNlXG4gIHdpdGhcbiAgfCBfIC0+IHRydWVcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICAgIHR5cGUgdCA9IGV4blxuXG4gICAgbGV0IHBwIHBwZiB0ID1cbiAgICAgIG1hdGNoIHNleHBfb2ZfZXhuX29wdCB0IHdpdGhcbiAgICAgIHwgU29tZSBzZXhwIC0+IFNleHAucHBfaHVtIHBwZiBzZXhwXG4gICAgICB8IE5vbmUgLT4gU3RkbGliLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmIChTdGRsaWIuUHJpbnRleGMudG9fc3RyaW5nIHQpXG4gICAgOztcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FeG5cIlxuICBlbmQpXG5cbmxldCBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSA9XG4gIFN0ZGxpYi5Gb3JtYXQuZXByaW50ZiBcIkBbPDI+VW5jYXVnaHQgZXhjZXB0aW9uOkBcXG5AXFxuQFslYUBdQF1AXFxuQC5cIiBwcCBleGM7XG4gIGlmIFN0ZGxpYi5QcmludGV4Yy5iYWNrdHJhY2Vfc3RhdHVzICgpXG4gIHRoZW4gU3RkbGliLlByaW50ZXhjLnByaW50X3Jhd19iYWNrdHJhY2UgU3RkbGliLnN0ZGVyciByYXdfYmFja3RyYWNlO1xuICBTdGRsaWIuZmx1c2ggU3RkbGliLnN0ZGVyclxuOztcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciAoKSA9XG4gIFN0ZGxpYi5QcmludGV4Yy5zZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgcHJpbnRfd2l0aF9iYWNrdHJhY2Vcbjs7XG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfYXV4IH5kb19hdF9leGl0IH5leGl0IGYgPVxuICB0cnkgZiAoKSB3aXRoXG4gIHwgZXhjIC0+XG4gICAgbGV0IHJhd19iYWNrdHJhY2UgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAoKiBPbmUgcmVhc29uIHRvIHJ1biBbZG9fYXRfZXhpdF0gaGFuZGxlcnMgYmVmb3JlIHByaW50aW5nIG91dCB0aGUgZXJyb3IgbWVzc2FnZSBpc1xuICAgICAgIHRoYXQgaXQgaGVscHMgY3Vyc2VzIGFwcGxpY2F0aW9ucyBicmluZyB0aGUgdGVybWluYWwgaW4gYSBnb29kIHN0YXRlLCBvdGhlcndpc2UgdGhlXG4gICAgICAgZXJyb3IgbWVzc2FnZSBtaWdodCBnZXQgY29ycnVwdGVkLiAgQWxzbywgdGhlIE9DYW1sIHRvcC1sZXZlbCB1bmNhdWdodCBleGNlcHRpb25cbiAgICAgICBoYW5kbGVyIGRvZXMgdGhlIHNhbWUuICopXG4gICAgaWYgZG9fYXRfZXhpdFxuICAgIHRoZW4gKFxuICAgICAgdHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGhcbiAgICAgIHwgXyAtPiAoKSk7XG4gICAgKHRyeSBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgIHwgXyAtPlxuICAgICAgICh0cnlcbiAgICAgICAgICBTdGRsaWIuUHJpbnRmLmVwcmludGYgXCJFeG4uaGFuZGxlX3VuY2F1Z2h0IGNvdWxkIG5vdCBwcmludDsgZXhpdGluZyBhbnl3YXlcXG4lIVwiXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBfIC0+ICgpKSk7XG4gICAgZXhpdCAxXG47O1xuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2FuZF9leGl0IGYgPSBoYW5kbGVfdW5jYXVnaHRfYXV4IGYgfmV4aXQgfmRvX2F0X2V4aXQ6dHJ1ZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0IH5leGl0Om11c3RfZXhpdCBmID1cbiAgaGFuZGxlX3VuY2F1Z2h0X2F1eCBmIH5leGl0OihpZiBtdXN0X2V4aXQgdGhlbiBleGl0IGVsc2UgaWdub3JlKSB+ZG9fYXRfZXhpdDptdXN0X2V4aXRcbjs7XG5cbmxldCByZXJhaXNlX3VuY2F1Z2h0IHN0ciBmdW5jID1cbiAgdHJ5IGZ1bmMgKCkgd2l0aFxuICB8IGV4biAtPlxuICAgIGxldCBidCA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChSZXJhaXNlZCAoc3RyLCBleG4pKSBidFxuOztcblxuZXh0ZXJuYWwgY2xlYXJfYmFja3RyYWNlIDogdW5pdCAtPiB1bml0ID0gXCJCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvc1wiIFtAQG5vYWxsb2NdXG5cbmxldCByYWlzZV93aXRob3V0X2JhY2t0cmFjZSBlID1cbiAgKCogV2UgY2xlYXIgdGhlIGJhY2t0cmFjZSB0byByZWR1Y2UgY29uZnVzaW9uLCBzbyB0aGF0IHBlb3BsZSBkb24ndCB0aGluayB3aGF0ZXZlclxuICAgICBpcyBzdG9yZWQgY29ycmVzcG9uZHMgdG8gdGhpcyByYWlzZS4gKilcbiAgY2xlYXJfYmFja3RyYWNlICgpO1xuICBTdGRsaWIucmFpc2Vfbm90cmFjZSBlXG47O1xuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKClcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGNsZWFyX2JhY2t0cmFjZSA9IGNsZWFyX2JhY2t0cmFjZVxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzEyNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0V4biIsImNzdF9SZXR1cm4iLCJjc3RfdXNlX29mX3JldHVybl9mcm9tX2Ffd2l0aF8iLCJ3aXRoX3JldHVybiIsIlJldHVybiIsImlzX2FsaXZlIiwicmV0dXJuIiwiYSIsImV4biIsIndpdGhfcmV0dXJuX29wdGlvbiIsInByZXBlbmQiLCJwYXJhbSIsIngiLCJCYXNlX1dpdGhfcmV0dXJuIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvd2l0aF9yZXR1cm4ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsWUFBQVA7QUFBQUE7QUFBQUEsS0FBQVEsU0NPRTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxhQUFBQyxTQUFBQztBQUFBQSxLQVFFO0FBQUEsTUFDSztBQUFBLEtBQ0wsOENBQXdDO0FBQUE7QUFBQSxJQUUxQyxRQUFBQSxNQUNVLHlCQUNSO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTURyQko7QUFBQSxLQ3lCSTtBQUFBLEtBQ0Esc0JBRVE7QUFBQSxTQUFBRCxJQUZSO0FBQUEsS0FDaUI7QUFBQTtBQUFBLEdBQ0M7QUFBQSxZQUFBRSxtQkFBQWI7QUFBQUEsSUFJcEI7QUFBQSxzQkFBQVU7QUFBQUEsY0FDRSx1QkFBQUMsR0FBdUIsbUNBQXNCO0FBQUEsY0FBRztBQUFBLGFBQzVDLEVBQUM7QUFBQTtBQUFBLFlBQUFHLFFBQUFDLE9BQUFmO0FBQUFBLElBR21CLGdCQUFBZ0IsR0FBNEIsT0FBSyxrQkFBTCxpQkFBSyxFQUFqQztBQUFBLEdBQW9DO0FBQUEsT0FBQUMsbUJEckNoRSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogYmVsb25ncyBpbiBDb21tb24sIGJ1dCBtb3ZlZCBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSAnYSByZXR1cm4gPSB7IHJldHVybiA6ICdiLiAnYSAtPiAnYiB9IFtAQHVuYm94ZWRdXG5cbmxldCB3aXRoX3JldHVybiAodHlwZSBhKSBmID1cbiAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgKCogUmFpc2VkIHRvIGluZGljYXRlIH5yZXR1cm4gd2FzIGNhbGxlZC4gIExvY2FsIHNvIHRoYXQgdGhlIGV4Y2VwdGlvbiBpcyB0aWVkIHRvIGFcbiAgICAgICBwYXJ0aWN1bGFyIGNhbGwgb2YgW3dpdGhfcmV0dXJuXS4gKilcbiAgICBleGNlcHRpb24gUmV0dXJuIG9mIGFcbiAgZW5kXG4gIGluXG4gIGxldCBpc19hbGl2ZSA9IHJlZiB0cnVlIGluXG4gIGxldCByZXR1cm4gYSA9XG4gICAgaWYgbm90ICFpc19hbGl2ZVxuICAgIHRoZW4gZmFpbHdpdGggXCJ1c2Ugb2YgW3JldHVybl0gZnJvbSBhIFt3aXRoX3JldHVybl0gdGhhdCBhbHJlYWR5IHJldHVybmVkXCI7XG4gICAgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIChNLlJldHVybiBhKVxuICBpblxuICB0cnlcbiAgICBsZXQgYSA9IGYgeyByZXR1cm4gfSBpblxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIGFcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIChtYXRjaCBleG4gd2l0aFxuICAgICB8IE0uUmV0dXJuIGEgLT4gYVxuICAgICB8IF8gLT4gcmFpc2UgZXhuKVxuOztcblxubGV0IHdpdGhfcmV0dXJuX29wdGlvbiBmID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByZXR1cm4gLT5cbiAgICBmIHsgcmV0dXJuID0gKGZ1biBhIC0+IHJldHVybi5yZXR1cm4gKFNvbWUgYSkpIH07XG4gICAgTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IHByZXBlbmQgeyByZXR1cm4gfSB+ZiA9IHsgcmV0dXJuID0gKGZ1biB4IC0+IHJldHVybiAoZiB4KSkgfVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxNzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9WYXJpYW50Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxlQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzE4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX1ZhcmlhbnRzbGliIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxtQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxOTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiY29uc3QiLCJjIiwicGFyYW0iLCJub24iLCJ4IiwiZm9yZXZlciIsImUiLCJjb21wb3NlIiwiZyIsImZsaXAiLCJ5IiwiYXBwbHlfbl90aW1lcyIsIm4iLCJCYXNlX0ZuIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvZm4ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxZQUFBQyxRQUFBQyxHQUFBQyxPQ0VnQixTQUFDO0FBQUEsWUFBQUMsSUFBQVQsR0FBQVUsR0FNQywyQkFBSztBQUFBLFlBQUFDLFFBQUFYO0FBQUFBLElBT3JCLElBQUksUUFIRjtBQUFBLFVBQUFZLFNBQUFBLElEWkosMEJDZ0JTO0FBQUEsR0FBQztBQUFBLFlBQUFDLFFBQUFiLEdBQUFjLEdBQUFKLEdBUVksT0FBSyxjQUFMLGlCQUFLO0FBQUEsWUFBQUssS0FBQWYsR0FBQVUsR0FBQU0sR0FDViwwQkFBSztBQUFBLFlBQUFDLGNBQUFDLEdBQUFsQixHQUFBVTtBQUFBQSxRQUFBUSxNQUNTLEdBQUFSLE1BQUE7QUFBQTtBQUFBLGtCQUFlO0FBQUEsU0FBQUEsTUFBa0Msb0JBQUFRLE1BQVY7QUFBQSxLQUFPO0FBQUE7QUFBQTtBQUFBLEdBQVE7QUFBQSxPQUFBQyxVRDFCckYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5sZXQgY29uc3QgYyBfID0gY1xuXG5leHRlcm5hbCBpZ25vcmUgOiAoX1tAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIHRoaXMgaGFzIHRoZSBzYW1lIGJlaGF2aW9yIGFzIFtTdGRsaWIuaWdub3JlXSAqKVxuXG5sZXQgbm9uIGYgeCA9IG5vdCAoZiB4KVxuXG5sZXQgZm9yZXZlciBmID1cbiAgbGV0IHJlYyBmb3JldmVyICgpID1cbiAgICBmICgpO1xuICAgIGZvcmV2ZXIgKClcbiAgaW5cbiAgdHJ5IGZvcmV2ZXIgKCkgd2l0aFxuICB8IGUgLT4gZVxuOztcblxuZXh0ZXJuYWwgaWQgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoKCdhIC0+ICdiKVtAbG9jYWxfb3B0XSkgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbigqIFRoZSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGVzZSBmdW5jdGlvbnMgaXMgdG8gcGFzcyBpbiBmdW5jdGlvbmFsIGFyZ3VtZW50cyBhbmQgZ2V0XG4gICBmdW5jdGlvbnMgYXMgYSByZXN1bHQuICopXG5sZXQgY29tcG9zZSBmIGcgeCA9IGYgKGcgeClcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCByZWMgYXBwbHlfbl90aW1lcyB+biBmIHggPSBpZiBuIDw9IDAgdGhlbiB4IGVsc2UgYXBwbHlfbl90aW1lcyB+bjoobiAtIDEpIGYgKGYgeClcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMjM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIlNfdG9fUzIiLCJYIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiTW9uYWRfaW5maXgiLCJiaW5kIiwicmV0dXJuIiwibWFwIiwiam9pbiIsImlnbm9yZV9tIiwiYWxsIiwiYWxsX3VuaXQiLCJMZXRfc3ludGF4IiwiUzJfdG9fUzMiLCJTX3RvX1NfaW5kZXhlZCIsIlMyX3RvX1MiLCJTM190b19TMiIsIlNfaW5kZXhlZF90b19TMiIsIkJhc2VfTW9uYWRfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFFBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLGNBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQUMsY0FBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxTQUFBWjtBQUFBQTtBQUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFTLGFBQUE7QUFBQSxLQUFBUixjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUcsZUFBQWI7QUFBQUE7QUFBQUEsS0FBQUMsY0FBQTtBQUFBLEtBQUFDLGFBQUE7QUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFHLFFBQUFkO0FBQUFBO0FBQUFBLEtBQUFDLGNBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQVMsYUFBQTtBQUFBLEtBQUFSLGNBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBSyxTQUFBZjtBQUFBQTtBQUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFTLGFBQUE7QUFBQSxLQUFBUixjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQU0sZ0JBQUFoQjtBQUFBQTtBQUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFTLGFBQUE7QUFBQSxLQUFBUixjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBTztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzQxNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIkJhc2VfTGlzdDAiLCJNYWtlX2dlbmVyYWwiLCJiaW5kIiwicmV0dXJuIiwibWFwX3ZpYV9iaW5kIiwibWEiLCJhIiwibWF0Y2giLCJtYXAiLCJ4Iiwic3ltYm9sX2JpbmQiLCJ0Iiwic3ltYm9sX21hcCIsIk1vbmFkX2luZml4IiwiYm90aCIsImIiLCJPcGVuX29uX3JocyIsIkxldF9zeW50YXgiLCJqb2luIiwiaWdub3JlX20iLCJwYXJhbSIsImxvb3AiLCJ2cyIsInRzIiwidiIsImFsbCIsImFsbF91bml0IiwiTWFrZV9pbmRleGVkIiwiTSIsIk1ha2UzIiwiTWFrZTIiLCJNYWtlIiwiTWFrZTJfbG9jYWwiLCJyZXMiLCJNYWtlX2xvY2FsIiwiT2ZfbW9uYWRfZ2VuZXJhbCIsIk1vbmFkIiwiQmFzZV9Nb25hZCIsInRvX21vbmFkIiwib2ZfbW9uYWQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9tb25hZC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsWUFBQUMsYUFBQTtBQUFBLFFBQUFDLE9BQUEsUUFBQUMsV0FBQTtBQUFBLGFBQUFDLGFBQUFDLElBQUFYO0FBQUFBLEtDdUIyQjtBQUFBO0FBQUE7QUFBQSx1QkFBQVk7QUFBQUEsbUJBQUEsTUFBZ0M7QUFBQSxlQUFLO0FBQUEsZ0JBQUM7QUFBQTtBQUFBLFFBQUFDLFFEdkJqRTtBQUFBO0FBQUEsU0FBQUMsTUMyQjRCO0FBQUE7QUFBQSxTQUFBQyxJRDNCNUIsVUFBQUQsTUM0Qm1CO0FBQUEsYUFBQUUsWUFBQUMsR0FBQWpCLEdBSUcsNkJBQVM7QUFBQSxhQUFBa0IsV0FBQUQsR0FBQWpCLEdBQ1Qs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QTtBQUFBLFNBQUFyQyxPQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBLFNBQUFLLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQTRCLE9BQUFSO0FBQUFBO0FBQUFBLFNBQUFVLFdBQUE7QUFBQSxTQUFBQyxXQUFBO0FBQUEsU0FBQXJDLE9BQUE7QUFBQSxTQUFBQyxXQUFBO0FBQUEsU0FBQUssTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIE1vbmFkX2ludGZcblxubW9kdWxlIHR5cGUgQmFzaWNfZ2VuZXJhbCA9IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZFxuICAgIDogICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAtPiBmOignYSAtPiAoJ2IsICdqLCAnaywgJ2QsICdlKSB0KVxuICAgIC0+ICgnYiwgJ2ksICdrLCAnZCwgJ2UpIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZFxuICAgICAgfCBgQ3VzdG9tIG9mICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgIF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2ksICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbmVyYWwgKE0gOiBCYXNpY19nZW5lcmFsKSA9IHN0cnVjdFxuICBsZXQgYmluZCA9IE0uYmluZFxuICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cbiAgbGV0IG1hcF92aWFfYmluZCBtYSB+ZiA9IE0uYmluZCBtYSB+ZjooZnVuIGEgLT4gTS5yZXR1cm4gKGYgYSkpXG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggTS5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19iaW5kIC0+IG1hcF92aWFfYmluZFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+Pj0gKSB0IGYgPSBiaW5kIHQgfmZcbiAgICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCBhIGIgPSBhID4+PSBmdW4gYSAtPiBiID4+fCBmdW4gYiAtPiBhLCBiXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbGV0IGpvaW4gdCA9IHQgPj49IGZ1biB0JyAtPiB0J1xuICBsZXQgaWdub3JlX20gdCA9IG1hcCB0IH5mOihmdW4gXyAtPiAoKSlcblxuICBsZXQgYWxsID1cbiAgICBsZXQgcmVjIGxvb3AgdnMgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IHZzKVxuICAgICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biB2IC0+IGxvb3AgKHYgOjogdnMpIHRzXG4gICAgaW5cbiAgICBmdW4gdHMgLT4gbG9vcCBbXSB0c1xuICA7O1xuXG4gIGxldCByZWMgYWxsX3VuaXQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biAoKSAtPiBhbGxfdW5pdCB0c1xuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX2luZGV4ZWQgKE0gOiBCYXNpY19pbmRleGVkKSA6XG4gIFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UzIChNIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgTS50ID1cbiAgTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZTIgKE0gOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2QpIHQgOj0gKCdhLCAnZCkgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE0udFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlIChNIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UyX2xvY2FsIChNIDogQmFzaWMyX2xvY2FsKSA9IHN0cnVjdFxuICBsZXQgYmluZCA9IE0uYmluZFxuICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cblxuICBsZXQgbWFwX3ZpYV9iaW5kIG1hIH5mID1cbiAgICBsZXQgcmVzID0gTS5iaW5kIG1hIH5mOihmdW4gYSAtPiBNLnJldHVybiAoZiBhKSkgaW5cbiAgICByZXNcbiAgOztcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBNLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2JpbmQgLT4gbWFwX3ZpYV9iaW5kXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuICAgIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGVuZFxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcblxuICAgICAgbGV0IGJvdGggYSBiID1cbiAgICAgICAgbGV0IHJlcyA9XG4gICAgICAgICAgYmluZCBhIH5mOihmdW4gYSAtPlxuICAgICAgICAgICAgbGV0IHJlcyA9IG1hcCBiIH5mOihmdW4gYiAtPiBhLCBiKSBpblxuICAgICAgICAgICAgcmVzKVxuICAgICAgICBpblxuICAgICAgICByZXNcbiAgICAgIDs7XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbGV0IGpvaW4gdCA9IHQgPj49IEZuLmlkXG5cbiAgbGV0IGlnbm9yZV9tIHQgPVxuICAgIGxldCByZXMgPSBtYXAgdCB+ZjooZnVuIF8gLT4gKCkpIGluXG4gICAgcmVzXG4gIDs7XG5cbiAgbGV0IGFsbCA9XG4gICAgbGV0IHJlYyBsb29wIHZzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiB2cylcbiAgICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gdiAtPiBsb29wICh2IDo6IHZzKSB0c1xuICAgIGluXG4gICAgZnVuIHRzIC0+IGxvb3AgW10gdHNcbiAgOztcblxuICBsZXQgcmVjIGFsbF91bml0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gKCkgLT4gYWxsX3VuaXQgdHNcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9sb2NhbCAoTSA6IEJhc2ljX2xvY2FsKSA6IFNfbG9jYWwgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID1cbiAgTWFrZTJfbG9jYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgTS50XG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkX2dlbmVyYWwgKE1vbmFkIDogc2lnXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgICB2YWwgYmluZFxuICAgICAgOiAgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2ssICdkLCAnZSkgdClcbiAgICAgIC0+ICgnYiwgJ2ksICdrLCAnZCwgJ2UpIHRcblxuICAgIHZhbCBtYXAgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpLCAnZCwgJ2UpIHRcbiAgZW5kKSAoTSA6IHNpZ1xuICAgICAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNb25hZC50XG4gICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgTW9uYWQudCAtPiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICAgIGVuZCkgPVxuICBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE0udFxuXG4gICAgbGV0IHJldHVybiBhID0gTS5vZl9tb25hZCAoTW9uYWQucmV0dXJuIGEpXG4gICAgbGV0IGJpbmQgdCB+ZiA9IE0ub2ZfbW9uYWQgKE1vbmFkLmJpbmQgKE0udG9fbW9uYWQgdCkgfmY6KGZ1biBhIC0+IE0udG9fbW9uYWQgKGYgYSkpKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIChmdW4gdCB+ZiAtPiBNLm9mX21vbmFkIChNb25hZC5tYXAgKE0udG9fbW9uYWQgdCkgfmYpKVxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZF9pbmRleGVkXG4gICAgKE1vbmFkIDogU19pbmRleGVkKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnaSwgJ2opIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2opIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDNcbiAgICAoTW9uYWQgOiBTMykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IsICdjKSBNb25hZC50IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDJcbiAgICAoTW9uYWQgOiBTMikgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IpIE1vbmFkLnQgLT4gKCdhLCAnYikgdFxuICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkXG4gICAgKE1vbmFkIDogUykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICB0eXBlICdhIHRcblxuICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICdhIHQgLT4gJ2EgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICdhIE1vbmFkLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcblxuICBsZXRbQGlubGluZV0gYmluZCBhIH5mID0gKGYgW0BpbmxpbmVkIGhpbnRdKSBhXG4gIGxldFtAaW5saW5lXSBtYXAgYSB+ZiA9IChmIFtAaW5saW5lZCBoaW50XSkgYVxuXG4gIGV4dGVybmFsIHJldHVybiA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXRbQGlubGluZV0gKCA+PnwgKSBhIGYgPSBtYXAgYSB+ZlxuICAgIGxldFtAaW5saW5lXSAoID4+PSApIGEgZiA9IGJpbmQgYSB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXRbQGlubGluZV0gYm90aCBhIGIgPSBhLCBiXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgZW5kXG5cbiAgZXh0ZXJuYWwgam9pbiA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcbiAgZXh0ZXJuYWwgaWdub3JlX20gOiAoX1tAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG4gIGV4dGVybmFsIGFsbF91bml0IDogKHVuaXQgbGlzdFtAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG4gIGV4dGVybmFsIGFsbCA6ICgnYSBsaXN0W0Bsb2NhbF9vcHRdKSAtPiAoJ2EgbGlzdFtAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozODM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfVCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsU0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM4NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9BcHBsaWNhdGl2ZV9pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyx3QkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM4NTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfTGlzdDAiLCJTX3RvX1MyIiwiWCIsInJldHVybiIsIm1hcCIsImJvdGgiLCJzeW1ib2wiLCJzeW1ib2xfbWFwIiwiYXBwbHkiLCJtYXAyIiwibWFwMyIsImFsbCIsImFsbF91bml0IiwiQXBwbGljYXRpdmVfaW5maXgiLCJTMl90b19TIiwiVCIsIlMyX3RvX1MzIiwiUzNfdG9fUzIiLCJTM190b19TIiwiVDEiLCJUMiIsIk1ha2UzIiwiZGVyaXZlZF9tYXAiLCJ0IiwibWF0Y2giLCJ4IiwidGEiLCJ0YiIsInRjIiwidHMiLCJ4cyIsImEiLCJiIiwidSIsInYiLCJwYXJhbSIsInkiLCJNYWtlMiIsIk1ha2UiLCJNYWtlX2xldF9zeW50YXgzIiwiSW50ZiIsIkltcGwiLCJMZXRfc3ludGF4IiwiTWFrZV9sZXRfc3ludGF4MiIsIk1ha2UzX3VzaW5nX21hcDIiLCJ0ZiIsImZhYiIsImMiLCJNYWtlMl91c2luZ19tYXAyIiwiTWFrZV91c2luZ19tYXAyIiwiTWFrZTNfdXNpbmdfbWFwMl9sb2NhbCIsInJlcyIsIk1ha2UyX3VzaW5nX21hcDJfbG9jYWwiLCJNYWtlX3VzaW5nX21hcDJfbG9jYWwiLCJPZl9tb25hZDIiLCJNIiwibWYiLCJteCIsIk9mX21vbmFkIiwic3ltYm9sX2JpbmQiLCJNb25hZF9pbmZpeCIsImJpbmQiLCJqb2luIiwiaWdub3JlX20iLCJDb21wb3NlIiwiRiIsIkciLCJ0eCIsImN1c3RvbV9tYXAiLCJpbmNsdWRlIiwiUGFpciIsIkJhc2VfQXBwbGljYXRpdmUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9hcHBsaWNhdGl2ZS5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxZQUFBQyxRQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxTQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQUMsUUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxvQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFFBQUFDLEdBQUFiO0FBQUFBO0FBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFNBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFDLGFBQUE7QUFBQSxLQUFBQyxRQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLG9CQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUcsU0FBQWQ7QUFBQUE7QUFBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFDLFFBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsb0JBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBSSxTQUFBRixHQUFBYjtBQUFBQTtBQUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxTQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQUMsUUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxvQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFLLFFBQUFDLElBQUFDLElBQUFsQjtBQUFBQTtBQUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxTQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQUMsUUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxvQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFRLE1BQUE7QUFBQSxRQUFBbEIsV0FBQSxRQUFBRyxTQUFBO0FBQUEsYUFBQWdCLFlBQUFDLEdBQUFoQztBQUFBQSxLQ3lDeUIsT0FBUSxtQkFBUiwyQkFBYztBQUFBO0FBQUEsUUFBQWlDLFFEekN2QztBQUFBO0FBQUEsU0FBQXBCLE1DNkM2QjtBQUFBO0FBQUEsU0FBQXFCLElEN0M3QixVQUFBckIsTUM4Q21CO0FBQUEsYUFBQUcsV0FBQWdCLEdBQUFoQyxHQUdDLDRCQUFRO0FBQUEsYUFBQWtCLEtBQUFpQixJQUFBQyxJQUFBcEM7QUFBQUEsS0FDTixPQUFTLG1CQUFULDJCQUFnQjtBQUFBO0FBQUEsYUFBQW1CLEtBQUFnQixJQUFBQyxJQUFBQyxJQUFBckM7QUFBQUEsS0FDYixPQUFnQjtBQUFBLHNCQUFoQixtREFBdUI7QUFBQTtBQUFBLGFBQUFvQixJQUFBa0I7QUFBQUEsY0FBQSxJQUFBSixHQUFBSyxJQUM2QixrQkFBTztBQUFBLGVBQTVDO0FBQUEsS0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLGVEcERuRDtBQUFBO0FBQUEsa0JDb0RzRjtBQUFBO0FBQUEsYUFBQXpCLEtBQUFxQixJQUFBQztBQUFBQSxLQUNuRSw2QkFBQUksR0FBQUMsR0FBMEIsaUJBQUksRUFBQztBQUFBO0FBQUEsYUFBQTFCLFNBQUEyQixHQUFBQztBQUFBQSxLQUMvQixPQUE0QjtBQUFBO0FBQUEsY0FBNUI7QUFBQTtBQUFBLDhDQUFBQyxPQUFBQyxHQUFvQixTQUFDO0FBQUE7QUFBQSxnQkFBYTtBQUFBO0FBQUEsYUFBQTlCLFNBQUEyQixHQUFBQztBQUFBQSxLQUNsQyxPQUE0QjtBQUFBO0FBQUEsY0FBNUI7QUFBQTtBQUFBLDhDQUFBVCxHQUFBVSxPQUFvQixTQUFDO0FBQUE7QUFBQSxnQkFBYTtBQUFBO0FBQUEsYUFBQXZCLFNBQUFpQjtBQUFBQSxTQUFBLE1BQ2Q7QUFBQSxLQUFXLG1EQUFVO0FBQUE7QUFBQSxJRHhENUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQVEsTUFBQW5DO0FBQUFBLFFBQUFDLFdBQUEsTUFBQUssUUFBQSxNQUFBSixNQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFrQyxLQUFBcEM7QUFBQUEsUUFBQUMsV0FBQSxNQUFBSyxRQUFBLE1BQUFKLE1BQUE7QUFBQTtBQUFBO0FBQUEsWUFBQW1DLGlCQUFBckMsR0FBQXNDLE1BQUFDO0FBQUFBO0FBQUFBLEtBQUF0QyxXQUFBO0FBQUEsS0FBQUcsU0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFKLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFxQyxhQUFBO0FBQUEsS0FBQUE7QUFBQUEsT0FBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxpQkFBQXpDLEdBQUFzQyxNQUFBQztBQUFBQTtBQUFBQSxLQUFBdEMsV0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBcUMsaUJBQUE7QUFBQSxRQUFBekMsV0FBQSxRQUFBTSxPQUFBO0FBQUEsYUFBQUgsT0FBQXVDLElBQUFuQjtBQUFBQSxLQ29Jb0IseUNBQUFuQyxHQUFBd0MsR0FBMEIsdUJBQUcsR0FBQztBQUFBO0FBQUEsYUFBQVQsWUFBQUMsR0FBQWhDLEdBRXpCLE9BQVEsT0FBUiwyQkFBYztBQUFBLFFBQUFpQyxRRHRJdkM7QUFBQTtBQUFBLFNBQUFwQixNQzBJNEI7QUFBQTtBQUFBLFNBQUFxQixJRDFJNUIsVUFBQXJCLE1DMkltQjtBQUFBLGFBQUFHLFdBQUFnQixHQUFBaEMsR0FHQyw0QkFBUTtBQUFBLGFBQUFjLEtBQUFxQixJQUFBQztBQUFBQSxLQUNULHlDQUFBSSxHQUFBQyxHQUEwQixpQkFBSSxFQUFDO0FBQUE7QUFBQSxhQUFBdEIsS0FBQWdCLElBQUFDLElBQUFDLElBQUFyQztBQUFBQSxLQUNwQixPQUFlO0FBQUE7QUFBQSxjQUFmO0FBQUE7QUFBQSx1QkFBQXVELEtBQUFDLEdBQW9DLHlCQUFLLEdBQUM7QUFBQTtBQUFBLGFBQUFwQyxJQUFBa0I7QUFBQUEsY0FBQSxJQUFBSixHQUFBSyxJQUNLLGtCQUFPO0FBQUEsZUFBNUM7QUFBQSxLQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEseUJEakpuRDtBQUFBO0FBQUE7QUFBQSxrQkNpSnNGO0FBQUE7QUFBQSxhQUFBeEIsU0FBQTJCLEdBQUFDO0FBQUFBLEtBQ25FLHVDQUFBQyxPQUFBQyxHQUF5QixTQUFDLEVBQUM7QUFBQTtBQUFBLGFBQUE5QixTQUFBMkIsR0FBQUM7QUFBQUEsS0FDM0IsdUNBQUFULEdBQUFVLE9BQXlCLFNBQUMsRUFBQztBQUFBO0FBQUEsYUFBQXZCLFNBQUFpQjtBQUFBQSxTQUFBLE1BQ1A7QUFBQSxLQUFXLG1EQUFVO0FBQUE7QUFBQSxJRHBKNUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQW1CLGlCQUFBOUM7QUFBQUEsUUFBQUMsV0FBQSxNQUFBTSxPQUFBLE1BQUFMLE1BQUE7QUFBQTtBQUFBO0FBQUEsWUFBQTZDLGdCQUFBL0M7QUFBQUEsUUFBQUMsV0FBQSxNQUFBTSxPQUFBLE1BQUFMLE1BQUE7QUFBQTtBQUFBO0FBQUEsWUFBQThDLHVCQUFBO0FBQUEsUUFBQS9DLFdBQUEsUUFBQU0sT0FBQTtBQUFBLGFBQUFILE9BQUF1QyxJQUFBbkI7QUFBQUEsS0NnTG9CLHlDQUFBbkMsR0FBQXdDLEdBQTBCLHVCQUFHLEdBQUM7QUFBQTtBQUFBLGFBQUFULFlBQUFDLEdBQUFoQztBQUFBQSxLQUVILE9BQVc7QUFBQSxvQkFBWCxxQ0FBQTRDLE9BQUgsU0FBQyxFQUFlO0FBQUE7QUFBQSxRQUFBWCxRRGxMNUQ7QUFBQTtBQUFBLFNBQUFwQixNQ3NMNEI7QUFBQTtBQUFBLFNBQUFBLFFEdEw1QixVQUFBQSxNQ3VMcUI7QUFBQSxhQUFBRyxXQUFBZ0IsR0FBQWhDLEdBR0QsNEJBQVE7QUFBQSxhQUFBYyxLQUFBcUIsSUFBQUM7QUFBQUEsS0FDVCx5Q0FBQUksR0FBQUMsR0FBMEIsaUJBQUksRUFBQztBQUFBO0FBQUEsYUFBQXRCLEtBQUFnQixJQUFBQyxJQUFBQyxJQUFBckM7QUFBQUE7QUFBQUEsTUFBQTREO0FBQUFBLFFBR3BDO0FBQUE7QUFBQSxVQUFLO0FBQUE7QUFBQSxtQkFBQWhCLE9BQUFZO0FBQUFBLGVBQUFmLElBQW1CLFVBQUFELElBQUE7QUFBQSxXQUFpQiw2QkFBUTtBQUFBO0FBQUEsS0FDM0Q7QUFBQSxJQUFHO0FBQUEsYUFBQXBCLElBQUFrQjtBQUFBQSxjQUFBLElBQUFKLEdBQUFLLElBR3NFLGtCQUFPO0FBQUEsZUFBNUM7QUFBQSxLQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEseUJEbE1uRDtBQUFBO0FBQUE7QUFBQSxrQkNrTXNGO0FBQUE7QUFBQSxhQUFBeEIsU0FBQTJCLEdBQUFDO0FBQUFBLEtBQ25FLHVDQUFBQyxPQUFBQyxHQUF5QixTQUFDLEVBQUM7QUFBQTtBQUFBLGFBQUE5QixTQUFBMkIsR0FBQUM7QUFBQUEsS0FDM0IsdUNBQUFULEdBQUFVLE9BQXlCLFNBQUMsRUFBQztBQUFBO0FBQUEsYUFBQXZCLFNBQUFpQjtBQUFBQSxTQUFBLE1BQ1A7QUFBQSxLQUFXLG1EQUFVO0FBQUE7QUFBQSxJRHJNNUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQXVCLHVCQUFBbEQ7QUFBQUEsUUFBQUMsV0FBQSxNQUFBTSxPQUFBLE1BQUFMLE1BQUE7QUFBQTtBQUFBO0FBQUEsWUFBQWlELHNCQUFBbkQ7QUFBQUEsUUFBQUMsV0FBQSxNQUFBTSxPQUFBLE1BQUFMLE1BQUE7QUFBQTtBQUFBO0FBQUEsWUFBQWtELFVBQUFDO0FBQUFBLFFBQUFwRCxXQUFBO0FBQUEsYUFBQUssTUFBQWdELElBQUFDO0FBQUFBLEtDaU9zQixxQ0FBQWxFLEdBQXVCLDhCQUFXLEdBQUM7QUFBQTtBQUFBLFFBQUFhLE1Eak96RDtBQUFBO0FBQUE7QUFBQSxZQUFBc0QsU0FBQUg7QUFBQUE7QUFBQUEsS0FBQUksY0FBQTtBQUFBLEtBQUFwRCxhQUFBO0FBQUEsS0FBQXFELGNBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQTFELFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQTBELE9BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQXBELE1BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQThCLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQXNCLFFBQUFDLEdBQUFDO0FBQUFBLGFBQUEvRCxTQUFBNEI7QUFBQUEsU0FBQSxNQ2lQOEI7QUFBQSxLQUFZO0FBQUE7QUFBQSxhQUFBdkIsTUFBQXFDLElBQUFzQjtBQUFBQSxTQUFBLE1BQ1Y7QUFBQSxLQUFxQixnQ0FBRztBQUFBO0FBQUEsYUFBQUMsV0FBQTdDLEdBQUFoQztBQUFBQSxTQUFBLE1BQzVCO0FBQUE7QUFBQSxxQ0RuUDVCLGlDQ21QaUQ7QUFBQTtBQUFBO0FBQUEsS0FBQWEsTURuUGpEO0FBQUEsS0FBQWlFLFVBQUE7QUFBQSxLQUFBbEUsV0FBQTtBQUFBLEtBQUFDLFFBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFDLFVBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsb0JBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBeUQsS0FBQUwsR0FBQUM7QUFBQUEsYUFBQS9ELFNBQUE0QjtBQUFBQSxTQUFBLE1DOFBpQztBQUFBLEtBQVosb0NBQVU7QUFBQSxJQUFZO0FBQUEsYUFBQXZCLE1BQUFxQyxJQUFBc0I7QUFBQUE7QUFBQUEsTUFBQSxNQUN5QjtBQUFBLFlBQVQ7QUFBQSxZQUFSO0FBQUEsWUFBVjtBQUFBLFlBQVQ7QUFBQSxLQUFSLDJDQUF5QjtBQUFBLElBQTJCO0FBQUEsYUFBQUMsV0FBQTdDLEdBQUFoQztBQUFBQTtBQUFBQSxNQUFBLE1BQ3JCO0FBQUEsWUFBVDtBQUFBLFlBQVQ7QUFBQSxLQUFULHlDQUFnQjtBQUFBLElBQWtCO0FBQUE7QUFBQSxLQUFBYSxNRGhROUQ7QUFBQSxLQUFBaUUsVUFBQTtBQUFBLEtBQUFsRSxXQUFBO0FBQUEsS0FBQUMsUUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxTQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQUMsVUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxvQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQTBEO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUFyRSxHQUFBc0MsTUFBQUM7QUFBQUE7QUFBQUEsU0FBQXRDLFdBQUE7QUFBQSxTQUFBQyxNQUFBO0FBQUEsU0FBQUMsT0FBQTtBQUFBLFNBQUFDLFNBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFDLGFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBcHBsaWNhdGl2ZV9pbnRmXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5cbigqKiBUaGlzIG1vZHVsZSBzZXJ2ZXMgbW9zdGx5IGFzIGEgcGFydGlhbCBjaGVjayB0aGF0IFtTMl0gYW5kIFtTXSBhcmUgaW4gc3luYywgYnV0XG4gICAgYWN0dWFsbHkgY2FsbGluZyBpdCBpcyBvY2Nhc2lvbmFsbHkgdXNlZnVsLiAqKVxubW9kdWxlIFNfdG9fUzIgKFggOiBTKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TIChUIDogVC5UKSAoWCA6IFMyKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAoJ2EsIFQudCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgJ2EgdCA9ICgnYSwgVC50KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUzMgKFggOiBTMikgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kXG5cbm1vZHVsZSBTM190b19TMiAoVCA6IFQuVCkgKFggOiBTMykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZCkgdCA9ICgnYSwgJ2QsIFQudCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCkgdCA9ICgnYSwgJ2QsIFQudCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MgKFQxIDogVC5UKSAoVDIgOiBULlQpIChYIDogUzMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgVDEudCwgVDIudCkgWC50ID1cbnN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICdhIHQgPSAoJ2EsIFQxLnQsIFQyLnQpIFgudFxuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gcmV0dXJuIGYgPCo+IHRcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2FwcGx5IC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGxldCBtYXAyIHRhIHRiIH5mID0gbWFwIH5mIHRhIDwqPiB0YlxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9IG1hcCB+ZiB0YSA8Kj4gdGIgPCo+IHRjXG4gIGxldCBhbGwgdHMgPSBMaXN0LmZvbGRfcmlnaHQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KG1hcDIgfmY6KGZ1biB4IHhzIC0+IHggOjogeHMpKVxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcbiAgbGV0ICggKj4gKSB1IHYgPSByZXR1cm4gKGZ1biAoKSB5IC0+IHkpIDwqPiB1IDwqPiB2XG4gIGxldCAoIDwqICkgdSB2ID0gcmV0dXJuIChmdW4geCAoKSAtPiB4KSA8Kj4gdSA8Kj4gdlxuICBsZXQgYWxsX3VuaXQgdHMgPSBMaXN0LmZvbGQgdHMgfmluaXQ6KHJldHVybiAoKSkgfmY6KCAqPiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgbGV0ICggKj4gKSA9ICggKj4gKVxuICAgIGxldCAoIDwqICkgPSAoIDwqIClcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZSAoWCA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID0gTWFrZTIgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG4gIGVuZClcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheDNcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4MykgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHR5cGUgU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBpbmNsdWRlIFhcbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IEltcGxcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheDJcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4MikgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHR5cGUgU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG4gIE1ha2VfbGV0X3N5bnRheDNcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIFhcblxuICAgICAgdHlwZSAoJ2EsICdkLCBfKSB0ID0gKCdhLCAnZCkgWC50XG4gICAgZW5kKVxuICAgIChJbnRmKVxuICAgIChJbXBsKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4XG4gICAgKFggOiBGb3JfbGV0X3N5bnRheCkgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZClcbiAgICAoSW1wbCA6IEludGYuUykgPVxuICBNYWtlX2xldF9zeW50YXgyXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG5cbiAgICAgIHR5cGUgKCdhLCBfKSB0ID0gJ2EgWC50XG4gICAgZW5kKVxuICAgIChJbnRmKVxuICAgIChJbXBsKVxuXG4oKiogVGhpcyBmdW5jdG9yIGNsb3NlbHkgcmVzZW1ibGVzIFtNYWtlM10sIGFuZCBpbmRlZWQgaXQgY291bGQgYmUgaW1wbGVtZW50ZWRcbiAgICBtdWNoIHNob3J0ZXIgaW4gdGVybXMgb2YgW01ha2UzXS4gSG93ZXZlciwgd2UgaW1wbGVtZW50IGl0IGJ5IGhhbmQgc28gdGhhdFxuICAgIHRoZSByZXN1bHRpbmcgZnVuY3Rpb25zIGFyZSBtb3JlIGVmZmljaWVudCwgZS5nLiB1c2luZyBbbWFwMl0gZGlyZWN0bHkgaW5zdGVhZCBvZlxuICAgIGRlZmluaW5nIFthcHBseV0gaW4gdGVybXMgb2YgaXQgYW5kIHRoZW4gW21hcDJdIGluIHRlcm1zIG9mIHRoYXQuIEZvciBtb3N0XG4gICAgYXBwbGljYXRpdmVzIHRoaXMgZG9lcyBub3QgbWF0dGVyLCBidXQgZm9yIHNvbWUgKHN1Y2ggYXMgQm9uc2FpLlZhbHVlLnQpLCBpdCBoYXMgYVxuICAgIGxhcmdlciBpbXBhY3QuICopXG5tb2R1bGUgTWFrZTNfdXNpbmdfbWFwMiAoWCA6IEJhc2ljM191c2luZ19tYXAyKSA6XG4gIFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCBhcHBseSB0ZiB0YSA9IG1hcDIgdGYgdGEgfmY6KGZ1biBmIGEgLT4gZiBhKVxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gcmV0dXJuIGYgPCo+IHRcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX21hcDIgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IGJvdGggdGEgdGIgPSBtYXAyIHRhIHRiIH5mOihmdW4gYSBiIC0+IGEsIGIpXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwMiAobWFwMiB0YSB0YiB+ZikgdGMgfmY6KGZ1biBmYWIgYyAtPiBmYWIgYylcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCAoICo+ICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biAoKSB5IC0+IHkpXG4gIGxldCAoIDwqICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biB4ICgpIC0+IHgpXG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTJfdXNpbmdfbWFwMiAoWCA6IEJhc2ljMl91c2luZ19tYXAyKSA6XG4gIFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzX3VzaW5nX21hcDIgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlX3VzaW5nX21hcDIgKFggOiBCYXNpY191c2luZ19tYXAyKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID1cbiAgTWFrZTJfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZTNfdXNpbmdfbWFwMl9sb2NhbCAoWCA6IEJhc2ljM191c2luZ19tYXAyX2xvY2FsKSA6XG4gIFMzX2xvY2FsIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCBhcHBseSB0ZiB0YSA9IG1hcDIgdGYgdGEgfmY6KGZ1biBmIGEgLT4gZiBhKVxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gbWFwMiB+ZjooZnVuICgpIC0+IGYpIChyZXR1cm4gKCkpIHQgW0Bub250YWlsXVxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfbWFwMiAtPiBkZXJpdmVkX21hcFxuICAgIHwgYEN1c3RvbSBtYXAgLT4gbWFwXG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IGJvdGggdGEgdGIgPSBtYXAyIHRhIHRiIH5mOihmdW4gYSBiIC0+IGEsIGIpXG5cbiAgbGV0IG1hcDMgdGEgdGIgdGMgfmYgPVxuICAgIGxldCByZXMgPSBtYXAyIChib3RoIHRhIHRiKSB0YyB+ZjooZnVuIChhLCBiKSBjIC0+IGYgYSBiIGMpIGluXG4gICAgcmVzXG4gIDs7XG5cbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCAoICo+ICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biAoKSB5IC0+IHkpXG4gIGxldCAoIDwqICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biB4ICgpIC0+IHgpXG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTJfdXNpbmdfbWFwMl9sb2NhbCAoWCA6IEJhc2ljMl91c2luZ19tYXAyX2xvY2FsKSA6XG4gIFMyX2xvY2FsIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzX3VzaW5nX21hcDJfbG9jYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlX3VzaW5nX21hcDJfbG9jYWwgKFggOiBCYXNpY191c2luZ19tYXAyX2xvY2FsKSA6XG4gIFNfbG9jYWwgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID0gTWFrZTJfdXNpbmdfbWFwMl9sb2NhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQyIChNIDogTW9uYWQuUzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgTS50ID0gTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIE0udFxuXG4gICAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gICAgbGV0IGFwcGx5IG1mIG14ID0gTS5iaW5kIG1mIH5mOihmdW4gZiAtPiBNLm1hcCBteCB+ZilcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBNLm1hcFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZCAoTSA6IE1vbmFkLlMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBPZl9tb25hZDIgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgQ29tcG9zZSAoRiA6IFMpIChHIDogUykgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2EgRi50IEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgRy50XG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCByZXR1cm4gYSA9IEcucmV0dXJuIChGLnJldHVybiBhKVxuICAgICAgbGV0IGFwcGx5IHRmIHR4ID0gRy5hcHBseSAoRy5tYXAgfmY6Ri5hcHBseSB0ZikgdHhcbiAgICAgIGxldCBjdXN0b21fbWFwIHQgfmYgPSBHLm1hcCB+ZjooRi5tYXAgfmYpIHRcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIFBhaXIgKEYgOiBTKSAoRyA6IFMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhIEYudCAqICdhIEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgKiAnYSBHLnRcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHJldHVybiBhID0gRi5yZXR1cm4gYSwgRy5yZXR1cm4gYVxuICAgICAgbGV0IGFwcGx5IHRmIHR4ID0gRi5hcHBseSAoZnN0IHRmKSAoZnN0IHR4KSwgRy5hcHBseSAoc25kIHRmKSAoc25kIHR4KVxuICAgICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEYubWFwIH5mIChmc3QgdCksIEcubWFwIH5mIChzbmQgdClcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgICBlbmQpXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0NDg3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJNb2R1bGUiLCJtYWtlIiwiY29tcGFyZSIsInNleHBfb2ZfdCIsImNvbXBhcmF0b3IiLCJTX3RvX1MxIiwiUyIsIk1ha2UxIiwiTSIsInBhcmFtIiwiaW5jbHVkZSIsIlBvbHkiLCJEZXJpdmVkIiwiYSIsIkRlcml2ZWQyIiwiYiIsIkRlcml2ZWRfcGhhbnRvbSIsIkRlcml2ZWQyX3BoYW50b20iLCJCYXNlX0NvbXBhcmF0b3IiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9jb21wYXJhdG9yLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUMsU0FBQTtBQUFBLFlBQUFDLEtBQUFDLFNBQUFDO0FBQUFBLFFBQUFDLGFDa0NFO0FBQUE7QUFBQSxHQU02QjtBQUFBLFlBQUFDLFFBQUFDLE9BQUFGLGFEeEMvQjtBQUFBLFlBQUFHLE1BQUFDO0FBQUFBLFFBQUFKLGFBQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUYsVUFBQTtBQUFBLFlBQUFDLFVBQUFNLE9Dd0Z3QixXQUFhO0FBQUE7QUFBQSxJQUFBQyxVRHhGckM7QUFBQSxJQUFBTixhQUFBO0FBQUEsSUFBQU8sT0FBQTtBQUFBLFlBQUFDLFFBQUFKO0FBQUFBLGFBQUFKLFdBQUFTO0FBQUFBLFNBQUEsTUNnSGlEO0FBQUEsS0FBakMsdUNBQW1CO0FBQUEsSUFBdUM7QUFBQSxJRGhIMUU7QUFBQTtBQUFBLFlBQUFDLFNBQUFOO0FBQUFBLGFBQUFKLFdBQUFTLEdBQUFFO0FBQUFBLFNBQUEsTUNnSmtCO0FBQUEsS0FERiw2Q0FBNkI7QUFBQSxJQUV4QztBQUFBLElEakpMO0FBQUE7QUFBQSxZQUFBQyxnQkFBQVI7QUFBQUEsYUFBQUosV0FBQVM7QUFBQUEsU0FBQSxNQ3dLaUQ7QUFBQSxLQUFqQyx1Q0FBbUI7QUFBQSxJQUF1QztBQUFBLElEeEsxRTtBQUFBO0FBQUEsWUFBQUksaUJBQUFUO0FBQUFBLGFBQUFKLFdBQUFTLEdBQUFFO0FBQUFBLFNBQUEsTUN1TWtCO0FBQUEsS0FERiw2Q0FBNkI7QUFBQSxJQUV4QztBQUFBLElEeE1MO0FBQUE7QUFBQTtBQUFBLElBQUFHO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBVixPQUFBSixhQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICd3aXRuZXNzKSB0ID1cbiAgeyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gIH1cblxudHlwZSAoJ2EsICdiKSBjb21wYXJhdG9yID0gKCdhLCAnYikgdFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhIHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfZmMgPSBzaWdcbiAgdHlwZSBjb21wYXJhYmxlX3RcblxuICBpbmNsdWRlIFMgd2l0aCB0eXBlIHQgOj0gY29tcGFyYWJsZV90XG5lbmRcblxubW9kdWxlIE1vZHVsZSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSAobW9kdWxlIFMgd2l0aCB0eXBlIHQgPSAnYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnYilcbmVuZFxuXG5sZXQgbWFrZSAodHlwZSB0KSB+Y29tcGFyZSB+c2V4cF9vZl90ID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIGNvbXBhcmFibGVfdCA9IHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGVuZCA6IFNfZmNcbiAgICB3aXRoIHR5cGUgY29tcGFyYWJsZV90ID0gdClcbjs7XG5cbm1vZHVsZSBTX3RvX1MxIChTIDogUykgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gUy50XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gUy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBvcGVuIFNcblxuICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgTWFrZSAoTSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgTWFrZTEgKE0gOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBzZXhwX29mX3QgOiAnYSB0IC0+IFNleHAudFxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gTS57IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcblxuICBpbmNsdWRlIE1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gICAgICBsZXQgc2V4cF9vZl90IF8gPSBTZXhwLkF0b20gXCJfXCJcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZCA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAhJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgJ2NtcCkgY29tcGFyYXRvciAtPiAoJ2EgdCwgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZCAoTSA6IHNpZ1xuICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlICEnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoISdjbXBfYSwgISdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXBfYSkgY29tcGFyYXRvclxuICAgIC0+ICgnYiwgJ2NtcF9iKSBjb21wYXJhdG9yXG4gICAgLT4gKCgnYSwgJ2IpIHQsICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQyIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAoISdjbXBfYSwgISdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSBiID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgIDsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgYi5zZXhwX29mX3RcbiAgICB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZF9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXApIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCBfKSB0LCAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkX3BoYW50b20gKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJlIDogKCdhIC0+ICdhIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cC50KSAtPiAoJ2EsIF8pIHQgLT4gU2V4cC50XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgJ2NtcF9hIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkMl9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcbiAgdHlwZSAoISdjbXBfYSwgISdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXBfYSkgY29tcGFyYXRvclxuICAgIC0+ICgnYiwgJ2NtcF9iKSBjb21wYXJhdG9yXG4gICAgLT4gKCgnYSwgJ2IsIF8pIHQsICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQyX3BoYW50b20gKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgY29tcGFyZVxuICAgICAgOiAgKCdhIC0+ICdhIC0+IGludClcbiAgICAgIC0+ICgnYiAtPiAnYiAtPiBpbnQpXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIC0+IGludFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYiAtPiBTZXhwLnQpIC0+ICgnYSwgJ2IsIF8pIHQgLT4gU2V4cC50XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgKCEnY21wX2EsICEnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgYiA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICA7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IGIuc2V4cF9vZl90XG4gICAgfVxuICA7O1xuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDU2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0NvbXBhcmlzb25zIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxtQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ1NzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0ZpcnN0IiwiY3N0X1NlY29uZCIsImNzdF9maXJzdCIsImNzdF9zZWNvbmQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJlcnJvcl9zb3VyY2VfMDExIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiQmFzZV9IYXNoIiwiY29tcGFyZSIsImNtcF9mIiwiY21wX3MiLCJhXzAwMSIsImJfMDAyIiwiYV8wMDMiLCJiXzAwNCIsImFfMDA1IiwiYl8wMDYiLCJoYXNoX2ZvbGRfdCIsImhhc2hfZm9sZF9mIiwiaGFzaF9mb2xkX3MiLCJoc3YiLCJhcmciLCJ0X29mX3NleHAiLCJvZl9mXzAwNyIsIm9mX3NfMDA4Iiwic2V4cF8wMTMiLCJ0YWdfMDE0Iiwic2V4cF9hcmdzXzAyMCIsImFyZzBfMDIxIiwicmVzMF8wMjIiLCJzZXhwX2FyZ3NfMDE1IiwiYXJnMF8wMTYiLCJyZXMwXzAxNyIsInNleHBfb2ZfdCIsIm9mX2ZfMDI1Iiwib2Zfc18wMjYiLCJwYXJhbSIsImFyZzBfMDI3IiwicmVzMF8wMjgiLCJhcmcwXzAyOSIsInJlczBfMDMwIiwidF9zZXhwX2dyYW1tYXIiLCJmX3NleHBfZ3JhbW1hciIsInNfc2V4cF9ncmFtbWFyIiwiQmFzZV9FaXRoZXIwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvZWl0aGVyMC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxVQ2lESTtBQUFBO0FBQUEsSUFBQWIsYUFBQTtBQUFBLElBQUFELFlBQUE7QUFBQSxZQUFBZSxRQUFBQyxPQUFBQyxPQUFBQyxPQUFBQztBQUFBQSxJQXRDRixvQkFDSztBQUFBLElBQ0E7QUFBQSxTQUFBQyxRQUFBO0FBQUEsd0JBR2E7QUFBQSxTQUFBQyxRQUhiO0FBQUEsS0FFaUMsc0NBRzRCO0FBQUE7QUFBQSxRQUFBQyxRQUw3RDtBQUFBLHVCQUlhO0FBQUEsUUFBQUMsUUFKYjtBQUFBLElBS21DLHNDQUEwQjtBQUFBO0FBQUEsWUFBQUMsWUFBQUMsYUFBQUMsYUFBQUMsS0FBQUM7QUFBQUEsSUFZbEU7QUFBQSxTQUFBdEIsS0FBQSxRQUFBcUIsUUFFWTtBQUFBLEtBRVYseUNBSW9CO0FBQUE7QUFBQSxRQUFBckIsT0FSdEIsUUFBQXFCLFFBTVk7QUFBQSxJQUVWLDJDQUFvQjtBQUFBO0FBQUEsWUFBQUUsVUFBQUMsVUFBQUMsVUFBQUM7QUFBQUE7QUFBQUE7QUFBQUEsS0FXcEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BNEJJO0FBQUEsd0VBS29GO0FBQUE7QUFBQSxNQVBwRjtBQUFBLHVFQU9vRjtBQUFBO0FBQUEsZUFqQ3hGO0FBQUE7QUFBQSxNQWdDSTtBQUFBLHVFQUNvRjtBQUFBLGVBakN4RjtBQUFBO0FBQUEsTUE4Qkk7QUFBQSx1RUFHb0Y7QUFBQSxTQUFBQyxVQWpDeEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFBQyxnQkFBQTtBQUFBLE1BZ0JJO0FBQUE7QUFBQSxRQUFBQyxXQUFBO0FBQUEsUUFBQUMsV0FFb0I7QUFBQSxPQUNqQjtBQUFBO0FBQUEsTUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHdCQVlpRjtBQUFBO0FBQUEsU0FBQUMsZ0JBakN4RjtBQUFBLEtBSUk7QUFBQTtBQUFBLE9BQUFDLFdBQUE7QUFBQSxPQUFBQyxXQUVvQjtBQUFBLE1BQ2pCO0FBQUE7QUFBQSxLQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBd0JpRjtBQUFBO0FBQUEsSUFBdEUsMEVBQXNFO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxVQUFBQyxVQUFBQztBQUFBQSxJQU8xRjtBQUFBLFNBQUFDLFdBQUEsVUFBQUMsV0FLdUI7QUFBQSxLQUNqQjtBQUFBO0FBQUEsUUFBQUMsV0FOTixVQUFBQyxXQVF1QjtBQUFBLElBQ2pCO0FBQUEsR0FBOEQ7QUFBQSxZQUFBQyxlQUFBQyxnQkFBQUM7QUFBQUEsSUFVcEU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FnQkM7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BM0VDO0FBQUE7QUFBQTtBQUFBLEVEakRKIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2YsICdzKSB0ID1cbiAgfCBGaXJzdCBvZiAnZlxuICB8IFNlY29uZCBvZiAnc1xuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOlxuICAnZiAncy4gKCdmIC0+ICdmIC0+IGludCkgLT4gKCdzIC0+ICdzIC0+IGludCkgLT4gKCdmLCAncykgdCAtPiAoJ2YsICdzKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19mIF9jbXBfX3MgYV9fMDAxXyBiX18wMDJfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDAxXyBiX18wMDJfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICB8IEZpcnN0IF9hX18wMDNfLCBGaXJzdCBfYl9fMDA0XyAtPiBfY21wX19mIF9hX18wMDNfIF9iX18wMDRfXG4gICAgfCBGaXJzdCBfLCBfIC0+IC0xXG4gICAgfCBfLCBGaXJzdCBfIC0+IDFcbiAgICB8IFNlY29uZCBfYV9fMDA1XywgU2Vjb25kIF9iX18wMDZfIC0+IF9jbXBfX3MgX2FfXzAwNV8gX2JfXzAwNl8pXG47O1xuXG5sZXQgaGFzaF9mb2xkX3RcbiAgOiB0eXBlIGYgcy5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGYgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gKGYsIHMpIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9mIF9oYXNoX2ZvbGRfcyBoc3YgYXJnIC0+XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgRmlyc3QgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2YgaHN2IF9hMFxuICB8IFNlY29uZCBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfcyBoc3YgX2EwXG47O1xuXG5sZXQgdF9vZl9zZXhwIDpcbiAgJ2YgJ3MuXG4gIChTZXhwbGliMC5TZXhwLnQgLT4gJ2YpIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ3MpIC0+IFNleHBsaWIwLlNleHAudCAtPiAoJ2YsICdzKSB0XG4gID1cbiAgZnVuICh0eXBlIGZfXzAyM18gc19fMDI0XylcbiAgICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGZfXzAyM18pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gc19fMDI0XykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgICAgICAgLT4gKGZfXzAyM18sIHNfXzAyNF8pIHQpIC0+XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDExXyA9IFwiZWl0aGVyMC5tbC50XCIgaW5cbiAgICBmdW4gX29mX2ZfXzAwN18gX29mX3NfXzAwOF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZmlyc3RcIiB8IFwiRmlyc3RcIikgYXMgX3RhZ19fMDE0XykgOjogc2V4cF9hcmdzX18wMTVfKSBhc1xuICAgICAgICBfc2V4cF9fMDEzXyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTVfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMTZfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAxN18gPSBfb2ZfZl9fMDA3XyBhcmcwX18wMTZfIGluXG4gICAgICAgICAgIEZpcnN0IHJlczBfXzAxN19cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTFfXG4gICAgICAgICAgICAgX3RhZ19fMDE0X1xuICAgICAgICAgICAgIF9zZXhwX18wMTNfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIF90YWdfXzAxOV8pIDo6IHNleHBfYXJnc19fMDIwXykgYXNcbiAgICAgICAgX3NleHBfXzAxOF8gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDIwXyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDIxXyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMjJfID0gX29mX3NfXzAwOF8gYXJnMF9fMDIxXyBpblxuICAgICAgICAgICBTZWNvbmQgcmVzMF9fMDIyX1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAxMV9cbiAgICAgICAgICAgICBfdGFnX18wMTlfXG4gICAgICAgICAgICAgX3NleHBfXzAxOF8pXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJmaXJzdFwiIHwgXCJGaXJzdFwiKSBhcyBzZXhwX18wMTJfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMTFfIHNleHBfXzAxMl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInNlY29uZFwiIHwgXCJTZWNvbmRcIikgYXMgc2V4cF9fMDEyXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTJfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDEwXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMTFfIHNleHBfXzAxMF9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMTFfIHNleHBfXzAxMF9cbiAgICAgIHwgc2V4cF9fMDEwXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG47O1xuXG5sZXQgc2V4cF9vZl90IDpcbiAgJ2YgJ3MuXG4gICgnZiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgncyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnZiwgJ3MpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGZfXzAzMV8gc19fMDMyXylcbiAgICAgIDogICgoZl9fMDMxXyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChzX18wMzJfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAtPiAoZl9fMDMxXywgc19fMDMyXykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9mX18wMjVfIF9vZl9zX18wMjZfIC0+IGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IGFyZzBfXzAyN18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAyOF8gPSBfb2ZfZl9fMDI1XyBhcmcwX18wMjdfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkZpcnN0XCI7IHJlczBfXzAyOF8gXVxuICAgICAgfCBTZWNvbmQgYXJnMF9fMDI5XyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDMwXyA9IF9vZl9zX18wMjZfIGFyZzBfXzAyOV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2Vjb25kXCI7IHJlczBfXzAzMF8gXVxuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyIDpcbiAgJ2YgJ3MuXG4gICdmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gIC0+ICdzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gIC0+ICgnZiwgJ3MpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBmdW4gXydmX3NleHBfZ3JhbW1hciBfJ3Nfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJGaXJzdFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nZl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiU2Vjb25kXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydzX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ3MTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsIm9wYXF1ZV9pZGVudGl0eSIsIkZvcl9nZW5lcmF0ZWRfY29kZSIsIm5hbWUiLCJwYXJhbSIsImdldCIsInIiLCJmc2V0IiwidiIsInNldHRlciIsIm1hcCIsInVwZGF0ZXIiLCJmaWVsZCIsIm1hdGNoIiwiQmFzZV9GaWVsZCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2ZpZWxkLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsZ0JBQUE7QUFBQSxPQUFBQyxxQkFBQTtBQUFBLFlBQUFDLEtBQUFDLE9Dc0R5QixnQkFBVTtBQUFBLFlBQUFDLElBQUFELE9BQUFFLEdBQ1QsOEJBQWM7QUFBQSxZQUFBQyxLQUFBSCxPQUFBRSxHQUFBRSxHQUNYLGlDQUFjO0FBQUEsWUFBQUMsT0FBQUwsT0FDaEIsZ0JBQVk7QUFBQSxZQUFBTSxJQUFBTixPQUFBRSxHQUFBVDtBQUFBQSxRQUFBLE1BS0csY0FBRztBQUFBLElBQWlCO0FBQUE7QUFBQSxZQUFBYyxRQUFBQztBQUFBQSxRQUFBQyxRQUc1RDtBQUFBLGdCQUNVO0FBQUEsUUFBQUosU0FEVjtBQUFBLElBRWlCO0FBQUEscUJBQUFILEdBQUFUO0FBQUFBLGFBQThCLE9BQWlCO0FBQUEsaUNBQXBCLGNBQUcseUJBQWlCO0FBQUEsY0FBL0M7QUFBQSxHQUFnRDtBQUFBO0FBQUEsSUFBQWlCO0FBQUFBLE1EbkVuRSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhlIHR5cGUgW3RdIHNob3VsZCBiZSBhYnN0cmFjdCB0byBtYWtlIHRoZSBmc2V0IGFuZCBzZXQgZnVuY3Rpb25zIHVuYXZhaWxhYmxlXG4gICBmb3IgcHJpdmF0ZSB0eXBlcyBhdCB0aGUgbGV2ZWwgb2YgdHlwZXMgKGFuZCBub3QgYnkgcHV0dGluZyBOb25lIGluIHRoZSBmaWVsZCkuXG4gICBVbmZvcnR1bmF0ZWx5LCBtYWtpbmcgdGhlIHR5cGUgYWJzdHJhY3QgbWVhbnMgdGhhdCB3aGVuIGNyZWF0aW5nIGZpZWxkcyAodGhyb3VnaFxuICAgYSBbY3JlYXRlXSBmdW5jdGlvbikgdmFsdWUgcmVzdHJpY3Rpb24ga2lja3MgaW4uIFRoaXMgaXMgd29ya2VkIGFyb3VuZCBieSBpbnN0ZWFkXG4gICBub3QgbWFraW5nIHRoZSB0eXBlIGFic3RyYWN0LCBidXQgZm9yY2luZyBhbnlvbmUgYnJlYWtpbmcgdGhlIGFic3RyYWN0aW9uIHRvIHVzZVxuICAgdGhlIFtGb3JfZ2VuZXJhdGVkX2NvZGVdIG1vZHVsZSwgbWFraW5nIGl0IG9idmlvdXMgdG8gYW55IHJlYWRlciB0aGF0IHNvbWV0aGluZyB1Z2x5XG4gICBpcyBnb2luZyBvbi5cbiAgIHRfd2l0aF9wZXJtIChhbmQgZGVyaXZhdGl2ZXMpIGlzIHRoZSB0eXBlIHRoYXQgdXNlcnMgcmVhbGx5IHVzZS4gSXQgaXMgYSBjb25zdHJ1Y3RvclxuICAgYmVjYXVzZTpcbiAgIDEuIGl0IG1ha2VzIHR5cGUgZXJyb3JzIG1vcmUgcmVhZGFibGUgKGxlc3MgYWxpYXNpbmcpXG4gICAyLiB0aGUgdHlwZXIgaW4gb2NhbWwgNC4wMSBhbGxvd3MgdGhpczpcblxuICAge1tcbiAgICAgbW9kdWxlIEEgPSBzdHJ1Y3RcbiAgICAgICB0eXBlIHQgPSB7YSA6IGludH1cbiAgICAgZW5kXG4gICAgIHR5cGUgdCA9IEEudFxuICAgICBsZXQgZiAoeCA6IHQpID0geC5hXG4gICBdfVxuXG4gICAoYWx0aG91Z2ggd2l0aCBXYXJuaW5nIDQwOiBhIGlzIHVzZWQgb3V0IG9mIHNjb3BlKVxuICAgd2hpY2ggbWVhbnMgdGhhdCBpZiBbdF93aXRoX3Blcm1dIHdhcyByZWFsbHkgYW4gYWxpYXMgb24gW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSxcbiAgIHBlb3BsZSBjb3VsZCBzYXkgW3Quc2V0dGVyXSBhbmQgYnJlYWsgdGhlIGFic3RyYWN0aW9uIHdpdGggbm8gaW5kaWNhdGlvbiB0aGF0XG4gICBzb21ldGhpbmcgdWdseSBpcyBnb2luZyBvbiBpbiB0aGUgc291cmNlIGNvZGUuXG4gICBUaGUgd2FybmluZyBpcyAoSSB0aGluaykgZm9yIHBlb3BsZSB3aG8gd2FudCB0byBtYWtlIHRoZWlyIGNvZGUgY29tcGF0aWJsZSB3aXRoXG4gICBwcmV2aW91cyB2ZXJzaW9ucyBvZiBvY2FtbCwgc28gd2UgbWF5IHZlcnkgd2VsbCB0dXJuIGl0IG9mZi5cblxuICAgVGhlIHR5cGUgdF93aXRoX3Blcm0gY291bGQgYWxzbyBoYXZlIGJlZW4gYSBbdW5pdCAtPiBGb3JfZ2VuZXJhdGVkX2NvZGUudF0gdG8gd29ya1xuICAgYXJvdW5kIHZhbHVlIHJlc3RyaWN0aW9uIGFuZCB0aGVuIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0gd291bGQgaGF2ZSBiZWVuIGEgcHJvcGVyXG4gICBhYnN0cmFjdCB0eXBlLCBidXQgaXQgbG9va3MgbGlrZSBpdCBjb3VsZCBpbXBhY3QgcGVyZm9ybWFuY2UgKGZvciBleGFtcGxlLCBhIGZvbGQgb24gYVxuICAgcmVjb3JkIHR5cGUgd2l0aCA0MCBmaWVsZHMgd291bGQgYWN0dWFsbHkgYWxsb2NhdGUgdGhlIDQwIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0ncyBhdFxuICAgZXZlcnkgc2luZ2xlIGZvbGQuKSAqKVxuXG5tb2R1bGUgRm9yX2dlbmVyYXRlZF9jb2RlID0gc3RydWN0XG4gIHR5cGUgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHQgPVxuICAgIHsgZm9yY2VfdmFyaWFuY2UgOiAncGVybSAtPiB1bml0XG4gICAgOyAoKiBmb3JjZSBbdF0gdG8gYmUgY29udHJhdmFyaWFudCBpbiBbJ3Blcm1dLCBiZWNhdXNlIHBoYW50b20gdHlwZSB2YXJpYWJsZXMgb25cbiAgICAgICAgIGNvbmNyZXRlIHR5cGVzIGRvbid0IHdvcmsgdGhhdCB3ZWxsIG90aGVyd2lzZSAodXNpbmcgOj4gY2FuIHJlbW92ZSB0aGVtIGVhc2lseSkgKilcbiAgICAgIG5hbWUgOiBzdHJpbmdcbiAgICA7IHNldHRlciA6ICgncmVjb3JkIC0+ICdmaWVsZCAtPiB1bml0KSBvcHRpb25cbiAgICA7IGdldHRlciA6ICdyZWNvcmQgLT4gJ2ZpZWxkXG4gICAgOyBmc2V0IDogJ3JlY29yZCAtPiAnZmllbGQgLT4gJ3JlY29yZFxuICAgIH1cblxuICBsZXQgb3BhcXVlX2lkZW50aXR5ID0gU3lzMC5vcGFxdWVfaWRlbnRpdHlcbmVuZFxuXG50eXBlICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybSA9XG4gIHwgRmllbGQgb2YgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIEZvcl9nZW5lcmF0ZWRfY29kZS50XG5bQEB1bmJveGVkXVxuXG50eXBlICgncmVjb3JkLCAnZmllbGQpIHQgPSAoWyBgUmVhZCB8IGBTZXRfYW5kX2NyZWF0ZSBdLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtXG50eXBlICgncmVjb3JkLCAnZmllbGQpIHJlYWRvbmx5X3QgPSAoWyBgUmVhZCBdLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtXG5cbmxldCBuYW1lIChGaWVsZCBmaWVsZCkgPSBmaWVsZC5uYW1lXG5sZXQgZ2V0IChGaWVsZCBmaWVsZCkgciA9IGZpZWxkLmdldHRlciByXG5sZXQgZnNldCAoRmllbGQgZmllbGQpIHIgdiA9IGZpZWxkLmZzZXQgciB2XG5sZXQgc2V0dGVyIChGaWVsZCBmaWVsZCkgPSBmaWVsZC5zZXR0ZXJcblxudHlwZSAoJ3Blcm0sICdyZWNvcmQsICdyZXN1bHQpIHVzZXIgPVxuICB7IGYgOiAnZmllbGQuICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybSAtPiAncmVzdWx0IH1cblxubGV0IG1hcCAoRmllbGQgZmllbGQpIHIgfmYgPSBmaWVsZC5mc2V0IHIgKGYgKGZpZWxkLmdldHRlciByKSlcblxubGV0IHVwZGF0ZXIgKEZpZWxkIGZpZWxkKSA9XG4gIG1hdGNoIGZpZWxkLnNldHRlciB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzZXR0ZXIgLT4gU29tZSAoZnVuIHIgfmYgLT4gc2V0dGVyIHIgKGYgKGZpZWxkLmdldHRlciByKSkpXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ3NTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQwIiwiU3RkbGliX1N0cmluZ0xhYmVscyIsIkJhc2VfU3lzMCIsIlN0cmluZyIsIm1heF9sZW5ndGgiLCJzeW1ib2xfY29uY2F0IiwiY2FwaXRhbGl6ZSIsImNvbXBhcmUiLCJlc2NhcGVkIiwibG93ZXJjYXNlIiwibWFrZSIsInN1YiIsInVuY2FwaXRhbGl6ZSIsInVuc2FmZV9ibGl0IiwidXBwZXJjYXNlIiwic3BsaXRfb25fY2hhciIsImNvbmNhdCIsIm9wdCIsImwiLCJzZXAiLCJ4IiwiaXRlciIsInQiLCJpIiwiQmFzZV9TdHJpbmcwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvc3RyaW5nMC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLFFBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFOLFFBQUE7QUFBQSxJQUFBQSxNQUFBO0FBQUEsSUFBQU8sZUFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLE9BQUFDLEtBQUFDO0FBQUFBLFFBQUFDLE1DOENXO0FBQUEsSUFDVCxRQUNRO0FBQUEsSUFEUixTQUlPLGlEQUEyQjtBQUFBLFFBQUFDLElBSmxDO0FBQUEsSUFHVztBQUFBLEdBQ3VCO0FBQUEsWUFBQUMsS0FBQUMsR0FBQTNCO0FBQUFBO0FBQUFBLEtBQUEsTUFJckIsNkJBQWI7QUFBQSxXQUF5QjtBQUFBO0FBQUEsU0FBQTRCLElBQUE7QUFBQTtBQUFBLE1BQ3ZCO0FBQUEsZ0JBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQURLO0FBQUEsR0FFckI7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EekROIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBbU3RyaW5nMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluXG4gICB0ZXJtcyBvZiBbU3RkbGliLlN0cmluZ10uIFtTdHJpbmcwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtTdGRsaWIuU3RyaW5nXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIHN0cmluZzAubWwgc2hvdWxkXG4gICB1c2UgW1N0ZGxpYi5TdHJpbmddLiAgW1N0cmluZzBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2Unc1xuICAgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncywgaW5jbHVkaW5nIHRoZSBzdWJzY3JpcHQgc3ludGF4IFt4LltpXV0gd2hpY2hcbiAgIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0byBbU3RyaW5nXSwgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLlN0cmluZ10gaW5cbiAgIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuXG4gICB7W1xuICAgICBtb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN0cmluZ10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbm1vZHVsZSBTdHJpbmcgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgZ2V0IDogKHN0cmluZ1tAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IChzdHJpbmdbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRcbiAgICA6ICAoc3RyaW5nW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gY2hhclxuICAgID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZW5kXG5cbmluY2x1ZGUgU3RyaW5nXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgKCBeICkgPSAoIF4gKVxubGV0IGNhcGl0YWxpemUgPSBTdGRsaWIuU3RyaW5nLmNhcGl0YWxpemVfYXNjaWlcbmxldCBjb21wYXJlID0gU3RkbGliLlN0cmluZy5jb21wYXJlXG5sZXQgZXNjYXBlZCA9IFN0ZGxpYi5TdHJpbmcuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IFN0ZGxpYi5TdHJpbmcubG93ZXJjYXNlX2FzY2lpXG5sZXQgbWFrZSA9IFN0ZGxpYi5TdHJpbmcubWFrZVxubGV0IHN1YiA9IFN0ZGxpYi5TdHJpbmcuc3ViXG5sZXQgdW5jYXBpdGFsaXplID0gU3RkbGliLlN0cmluZy51bmNhcGl0YWxpemVfYXNjaWlcbmxldCB1bnNhZmVfYmxpdCA9IFN0ZGxpYi5TdHJpbmcudW5zYWZlX2JsaXRcbmxldCB1cHBlcmNhc2UgPSBTdGRsaWIuU3RyaW5nLnVwcGVyY2FzZV9hc2NpaVxubGV0IHNwbGl0X29uX2NoYXIgPSBTdGRsaWIuU3RyaW5nLnNwbGl0X29uX2NoYXJcblxubGV0IGNvbmNhdCA/KHNlcCA9IFwiXCIpIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBcIlwiXG4gICgqIFRoZSBzdGRsaWIgZG9lcyBub3Qgc3BlY2lhbGl6ZSB0aGlzIGNhc2UgYmVjYXVzZSBpdCBjb3VsZCBicmVhayBleGlzdGluZyBwcm9qZWN0cy4gKilcbiAgfCBbIHggXSAtPiB4XG4gIHwgbCAtPiBTdGRsaWIuU3RyaW5nLmNvbmNhdCB+c2VwIGxcbjs7XG5cbmxldCBpdGVyIHQgfmY6KGYgW0Bsb2NhbF0pID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ4MzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0ludDAiLCJCYXNlX1N0cmluZzAiLCJCYXNlX0hhc2giLCJCYXNlX0NvbXBhcmF0b3IiLCJjb21wYXJlIiwiYV8wMDEiLCJiXzAwMiIsIm4iLCJoYXNoX2ZvbGRfdCIsImhzdiIsImFyZyIsImhhc2giLCJzZXhwX29mX3QiLCJwYXJhbSIsInBvc19jbnVtXzAxMCIsInBvc19ib2xfMDA4IiwicG9zX2xudW1fMDA2IiwicG9zX2ZuYW1lXzAwNCIsImFyZ18wMTEiLCJibmRzXzAwMyIsImFyZ18wMDkiLCJhcmdfMDA3IiwiYXJnXzAwNSIsIlQiLCJpbmNsdWRlIiwiY29tcGFyYXRvciIsIm1ha2VfbG9jYXRpb25fc3RyaW5nIiwicG9zX2ZuYW1lIiwicG9zX2xudW0iLCJwb3NfY251bSIsInBvc19ib2wiLCJ0b19zdHJpbmciLCJ0IiwiQmFzZV9Tb3VyY2VfY29kZV9wb3NpdGlvbjAiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9zb3VyY2VfY29kZV9wb3NpdGlvbjAubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxRQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBTixNQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFPLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLFVDbURJO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsUUFBQUMsT0FBQUM7QUFBQUEsSUFwQ0csb0JBQ0s7QUFBQSxRQUFBQyxJQUVHO0FBQUEsSUFBa0QsWUFRakQ7QUFBQSxRQUFBQSxNQU5FO0FBQUEsSUFBNkMsY0FLNUM7QUFBQSxRQUFBQSxNQUhFO0FBQUEsSUFBMkMsbUJBQzFDLHNEQUdKO0FBQUE7QUFBQSxZQUFBQyxZQUFBQyxLQUFBQztBQUFBQTtBQUFBQSxLQUFBRCxRQVVOO0FBQUEsS0FBQUEsUUFFRjtBQUFBLEtBQUFBLFFBRUY7QUFBQSxJQUVGLGtEQUE4QjtBQUFBO0FBQUEsWUFBQUUsS0FBQUQ7QUFBQUEsUUFBQUQsTUFNakIsdUNBQ1Y7QUFBQSxJQUFtQixvQ0FFVDtBQUFBO0FBQUEsWUFBQUcsVUFBQUM7QUFBQUE7QUFBQUEsS0FBQUMsZUFJZDtBQUFBLEtBQUFDLGNBQUE7QUFBQSxLQUFBQyxlQUFBO0FBQUEsS0FBQUMsZ0JBQUE7QUFBQSxLQUFBQyxVQU9tQjtBQUFBLEtBQUFDLFdBQ2Y7QUFBQSxLQUFBQyxVQUllO0FBQUEsS0FBQUQsYUFDZjtBQUFBLEtBQUFFLFVBSWU7QUFBQSxLQUFBRixhQUNmO0FBQUEsS0FBQUcsVUFJZTtBQUFBLEtBQUFILGFBQ2Y7QUFBQSxJQUdIO0FBQUEsR0FBNkI7QUFBQTtBQUFBLElBQUFJLElBOUIvQjtBQUFBLElBQUFuQixZQUFBO0FBQUEsSUFBQUksZ0JBQUE7QUFBQSxJQUFBRyxTQUFBO0FBQUEsSUFBQWEsVUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxZQUFBQyxxQkFBQUMsV0FBQUMsVUFBQUMsVUFBQUM7QUFBQUE7QUFBQUEsS0FBQSxNQTJDNkQ7QUFBQSxXQUFkO0FBQUE7QUFBQSxPQUE3QjtBQUFBO0FBQUE7QUFBQSxJQUFzQiwyQ0FBMkM7QUFBQTtBQUFBLFlBQUFDLFVBQUFsQjtBQUFBQTtBQUFBQSxLQUFBZ0IsV0FHekU7QUFBQSxLQUFBQyxVQUFBO0FBQUEsS0FBQUYsV0FBQTtBQUFBLEtBQUFELFlBQUE7QUFBQSxJQUNaLG1FQUE0RDtBQUFBO0FBQUEsWUFBQWYsWUFBQW9CLEdBR2xDLHdCQUFhO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQWxEckM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURuREoiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IFN0ZGxpYi5MZXhpbmcucG9zaXRpb24gPVxuICAgIHsgcG9zX2ZuYW1lIDogc3RyaW5nXG4gICAgOyBwb3NfbG51bSA6IGludFxuICAgIDsgcG9zX2JvbCA6IGludFxuICAgIDsgcG9zX2NudW0gOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID1cbiAgICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDAxXyBiX18wMDJfXG4gICAgICAgdGhlbiAwXG4gICAgICAgZWxzZSAoXG4gICAgICAgICBtYXRjaCBjb21wYXJlX3N0cmluZyBhX18wMDFfLnBvc19mbmFtZSBiX18wMDJfLnBvc19mbmFtZSB3aXRoXG4gICAgICAgICB8IDAgLT5cbiAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfaW50IGFfXzAwMV8ucG9zX2xudW0gYl9fMDAyXy5wb3NfbG51bSB3aXRoXG4gICAgICAgICAgICB8IDAgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfaW50IGFfXzAwMV8ucG9zX2JvbCBiX18wMDJfLnBvc19ib2wgd2l0aFxuICAgICAgICAgICAgICAgfCAwIC0+IGNvbXBhcmVfaW50IGFfXzAwMV8ucG9zX2NudW0gYl9fMDAyXy5wb3NfY251bVxuICAgICAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgOiB0IC0+IHQgLT4gaW50KVxuICA7O1xuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBmdW4gaHN2IGFyZyAtPlxuICAgICAgbGV0IGhzdiA9XG4gICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgYXJnLnBvc19mbmFtZVxuICAgICAgICAgIGluXG4gICAgICAgICAgaGFzaF9mb2xkX2ludCBoc3YgYXJnLnBvc19sbnVtXG4gICAgICAgIGluXG4gICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfYm9sXG4gICAgICBpblxuICAgICAgaGFzaF9mb2xkX2ludCBoc3YgYXJnLnBvc19jbnVtXG4gIDs7XG5cbiAgbGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jIGFyZyA9XG4gICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICAgIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1biB7IHBvc19mbmFtZSA9IHBvc19mbmFtZV9fMDA0X1xuICAgICAgICAgOyBwb3NfbG51bSA9IHBvc19sbnVtX18wMDZfXG4gICAgICAgICA7IHBvc19ib2wgPSBwb3NfYm9sX18wMDhfXG4gICAgICAgICA7IHBvc19jbnVtID0gcG9zX2NudW1fXzAxMF9cbiAgICAgICAgIH0gLT5cbiAgICAgIGxldCBibmRzX18wMDNfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMTFfID0gc2V4cF9vZl9pbnQgcG9zX2NudW1fXzAxMF8gaW5cbiAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19jbnVtXCI7IGFyZ19fMDExXyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgaW5cbiAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgbGV0IGFyZ19fMDA5XyA9IHNleHBfb2ZfaW50IHBvc19ib2xfXzAwOF8gaW5cbiAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19ib2xcIjsgYXJnX18wMDlfIF0gOjogYm5kc19fMDAzX1xuICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDdfID0gc2V4cF9vZl9pbnQgcG9zX2xudW1fXzAwNl8gaW5cbiAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19sbnVtXCI7IGFyZ19fMDA3XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgaW5cbiAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgbGV0IGFyZ19fMDA1XyA9IHNleHBfb2Zfc3RyaW5nIHBvc19mbmFtZV9fMDA0XyBpblxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2ZuYW1lXCI7IGFyZ19fMDA1XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDNfXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuKCogVGhpcyBpcyB0aGUgc2FtZSBmdW5jdGlvbiBhcyBQcHhfaGVyZS5saWZ0X3Bvc2l0aW9uX2FzX3N0cmluZy4gKilcbmxldCBtYWtlX2xvY2F0aW9uX3N0cmluZyB+cG9zX2ZuYW1lIH5wb3NfbG51bSB+cG9zX2NudW0gfnBvc19ib2wgPVxuICBTdHJpbmcuY29uY2F0XG4gICAgWyBwb3NfZm5hbWU7IFwiOlwiOyBJbnQudG9fc3RyaW5nIHBvc19sbnVtOyBcIjpcIjsgSW50LnRvX3N0cmluZyAocG9zX2NudW0gLSBwb3NfYm9sKSBdXG47O1xuXG5sZXQgdG9fc3RyaW5nIHsgU3RkbGliLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfY251bTsgcG9zX2JvbCB9ID1cbiAgbWFrZV9sb2NhdGlvbl9zdHJpbmcgfnBvc19mbmFtZSB+cG9zX2xudW0gfnBvc19jbnVtIH5wb3NfYm9sXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ5NDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9JbnZhcmlhbnRfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsc0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0OTU1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIkJhc2VfTGlzdDAiLCJoZF9leG4iLCJsZW5ndGgiLCJyZXZfYXBwZW5kIiwidGxfZXhuIiwidW56aXAiLCJleGlzdHMiLCJleGlzdHMyX29rIiwiZm9sZCIsImZvbGQyX29rIiwiZm9yX2FsbCIsImZvcl9hbGwyX29rIiwiaXRlciIsIml0ZXIyX29rIiwibm9udGFpbF9tYXAiLCJub250YWlsX21hcGkiLCJwYXJ0aXRpb24iLCJyZXZfbWFwIiwicmV2X21hcDJfb2siLCJzb3J0Iiwic3RhYmxlX3NvcnQiLCJyZXYiLCJmb2xkX3JpZ2h0IiwiZm9sZF9yaWdodDJfb2siLCJpc19lbXB0eSIsInBhcmFtIiwicGFydGl0aW9uX21hcCIsInQiLCJmc3QiLCJzbmQiLCJ4IiwibWF0Y2giLCJ5IiwiQmFzZV9MaXN0MSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2xpc3QxLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsU0FBQUMsT0NHZSxvQkFFRDtBQUFBLFlBQUFDLGNBQUFDLEdBQUE5QjtBQUFBQSxRQUFBOEIsTUFZWixHQUFBQyxNQUFBLEdBQUFDLE1BQUE7QUFBQTtBQUFBLEtBUEU7QUFBQSxnQkFDaUI7QUFBQSxNQUFULHFDQUFPO0FBQUE7QUFBQSxTQUFBRixNQURmLFFBQUFHLElBQUEsUUFBQUMsUUFHVTtBQUFBLEtBQUc7QUFBQSxVQUFBQyxJQUFBLFVBQUFKLFFBQ0c7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBSSxNQURILFVBQUFILFFBRUk7QUFBQTtBQUFBLEdBRUk7QUFBQTtBQUFBLElBQUFJO0FBQUFBLE1EakJ6QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIExpc3QwXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmY6KGYgW0Bsb2NhbF0pID1cbiAgbGV0IHJlYyBsb29wIHQgZnN0IHNuZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCAoZiB4IDogXyBFaXRoZXIwLnQpIHdpdGhcbiAgICAgICB8IEZpcnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kXG4gICAgICAgfCBTZWNvbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkpXG4gIGluXG4gIGxvb3AgdCBbXSBbXSBbQG5vbnRhaWxdXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjUwNDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0Vycm9yIiwiY3N0X09rIiwiY3N0X2Vycm9yIiwiY3N0X29rIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsImVycm9yX3NvdXJjZV8wMDUiLCJCYXNlX0xpc3QxIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1ByaW50ZiIsIkJhc2VfSGFzaCIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsIkJhc2VfTW9uYWQiLCJ0X29mX3NleHAiLCJvZl9hXzAwMSIsIm9mX2JfMDAyIiwic2V4cF8wMDciLCJ0YWdfMDA4Iiwic2V4cF9hcmdzXzAwOSIsImFyZzBfMDEwIiwicmVzMF8wMTEiLCJzZXhwX2FyZ3NfMDE0IiwiYXJnMF8wMTUiLCJyZXMwXzAxNiIsInNleHBfb2ZfdCIsIm9mX2FfMDE5Iiwib2ZfYl8wMjAiLCJwYXJhbSIsImFyZzBfMDIxIiwicmVzMF8wMjIiLCJhcmcwXzAyMyIsInJlczBfMDI0IiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsImJfc2V4cF9ncmFtbWFyIiwiY29tcGFyZSIsImNtcF9hIiwiY21wX2IiLCJhXzAyNyIsImJfMDI4IiwiYV8wMjkiLCJiXzAzMCIsImFfMDMxIiwiYl8wMzIiLCJlcXVhbCIsImFfMDMzIiwiYl8wMzQiLCJhXzAzNSIsImJfMDM2IiwiYV8wMzciLCJiXzAzOCIsImhhc2hfZm9sZF90IiwiaGFzaF9mb2xkX2EiLCJoYXNoX2ZvbGRfYiIsImhzdiIsImFyZyIsImdsb2JhbGl6ZSIsImJpbmQiLCJ4IiwibWFwIiwicmV0dXJuIiwiaW5jbHVkZSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsIkxldF9zeW50YXgiLCJNb25hZF9pbmZpeCIsImpvaW4iLCJpZ25vcmVfbSIsImFsbCIsImFsbF91bml0IiwiaW52YXJpYW50IiwiY2hlY2tfb2siLCJjaGVja19lcnJvciIsInQiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwiZm9ybWF0IiwibWFwX2Vycm9yIiwiZSIsIkVycm9yIiwiaXNfb2siLCJpc19lcnJvciIsIm9mX29wdGlvbiIsIm9wdCIsIml0ZXIiLCJ2IiwiaXRlcl9lcnJvciIsInRvX2VpdGhlciIsIm9mX2VpdGhlciIsIm9rX2lmX3RydWUiLCJib29sIiwidHJ5X3dpdGgiLCJleG4iLCJva19leG4iLCJva19vcl9mYWlsd2l0aCIsInN0ciIsImNvbWJpbmUiLCJ0MSIsInQyIiwiZXJyIiwib2sxIiwib2syIiwiZXJyMSIsImVycjIiLCJjb21iaW5lX2Vycm9ycyIsImwiLCJtYXRjaCIsImVycnMiLCJjb21iaW5lX2Vycm9yc191bml0IiwiQmFzZV9SZXN1bHQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9yZXN1bHQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FB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QUE7QUFBQSxTQUFBekIsSUFIakQ7QUFBQTtBQUFBLElBQ21DO0FBQUEsR0FFYztBQUFBLFlBQUEwQixlQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxRQUlsQztBQUFBLEtBQUFDLE9BQWtDO0FBQUEsS0FBQW5DLEtBQUE7QUFBQSxJQUNqRCxpQ0FFc0I7QUFBQTtBQUFBLFlBQUFvQyxvQkFBQUg7QUFBQUEsSUFHUSxPQUFrQixrQkFBbEIsNEJBQUFoRixPQUE4QyxTQUFFLEVBQUM7QUFBQTtBQUFBO0FBQUEsSUFBQW9GO0FBQUFBLE1BelE3RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURoQkoiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcblxudHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgU3RkbGliLnJlc3VsdCA9XG4gIHwgT2sgb2YgJ2FcbiAgfCBFcnJvciBvZiAnYlxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgZXF1YWwsIGhhc2hdXG5cbmxldCB0X29mX3NleHAgOlxuICAnYSAnYi5cbiAgKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYikgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnYSwgJ2IpIHRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDE3XyBiX18wMThfKVxuICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE3XykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBiX18wMThfKSAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgICAtPiAoYV9fMDE3XywgYl9fMDE4XykgdCkgLT5cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMDVfID0gXCJyZXN1bHQubWwudFwiIGluXG4gICAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcIm9rXCIgfCBcIk9rXCIpIGFzIF90YWdfXzAwOF8pIDo6IHNleHBfYXJnc19fMDA5XykgYXNcbiAgICAgICAgX3NleHBfXzAwN18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDA5XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDEwXyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTFfID0gX29mX2FfXzAwMV8gYXJnMF9fMDEwXyBpblxuICAgICAgICAgICBPayByZXMwX18wMTFfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICAgIF90YWdfXzAwOF9cbiAgICAgICAgICAgICBfc2V4cF9fMDA3XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgX3RhZ19fMDEzXykgOjogc2V4cF9hcmdzX18wMTRfKSBhc1xuICAgICAgICBfc2V4cF9fMDEyXyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTRfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMTVfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAxNl8gPSBfb2ZfYl9fMDAyXyBhcmcwX18wMTVfIGluXG4gICAgICAgICAgIEVycm9yIHJlczBfXzAxNl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDVfXG4gICAgICAgICAgICAgX3RhZ19fMDEzX1xuICAgICAgICAgICAgIF9zZXhwX18wMTJfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwib2tcIiB8IFwiT2tcIikgYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBzZXhwX18wMDRfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDI1XyBiX18wMjZfKVxuICAgICAgOiAgKChhX18wMjVfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMjVfLCBiX18wMjZfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxOV8gX29mX2JfXzAyMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgT2sgYXJnMF9fMDIxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDIyXyBdXG4gICAgICB8IEVycm9yIGFyZzBfXzAyM18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAyNF8gPSBfb2ZfYl9fMDIwXyBhcmcwX18wMjNfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkVycm9yXCI7IHJlczBfXzAyNF8gXVxuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyIDpcbiAgJ2EgJ2IuXG4gICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJPa1wiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRXJyb3JcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlIDpcbiAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAyN18gYl9fMDI4XyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzAyN18gYl9fMDI4X1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDI3XywgYl9fMDI4XyB3aXRoXG4gICAgfCBPayBfYV9fMDI5XywgT2sgX2JfXzAzMF8gLT4gX2NtcF9fYSBfYV9fMDI5XyBfYl9fMDMwX1xuICAgIHwgT2sgXywgXyAtPiAtMVxuICAgIHwgXywgT2sgXyAtPiAxXG4gICAgfCBFcnJvciBfYV9fMDMxXywgRXJyb3IgX2JfXzAzMl8gLT4gX2NtcF9fYiBfYV9fMDMxXyBfYl9fMDMyXylcbjs7XG5cbmxldCBlcXVhbCA6XG4gICdhICdiLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG4gID1cbiAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMzNfIGJfXzAzNF8gLT5cbiAgaWYgU3RkbGliLiggPT0gKSBhX18wMzNfIGJfXzAzNF9cbiAgdGhlbiB0cnVlXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAzM18sIGJfXzAzNF8gd2l0aFxuICAgIHwgT2sgX2FfXzAzNV8sIE9rIF9iX18wMzZfIC0+IF9jbXBfX2EgX2FfXzAzNV8gX2JfXzAzNl9cbiAgICB8IE9rIF8sIF8gLT4gZmFsc2VcbiAgICB8IF8sIE9rIF8gLT4gZmFsc2VcbiAgICB8IEVycm9yIF9hX18wMzdfLCBFcnJvciBfYl9fMDM4XyAtPiBfY21wX19iIF9hX18wMzdfIF9iX18wMzhfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBhIGIuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChhLCBiKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfYSBfaGFzaF9mb2xkX2IgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IE9rIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgfCBFcnJvciBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2EwXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZ2xvYmFsaXplID0gZ2xvYmFsaXplX3Jlc3VsdFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UyX2xvY2FsIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICAgIHwgT2sgeCAtPiBmIHhcbiAgICA7O1xuXG4gICAgbGV0IG1hcCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgICAgfCBPayB4IC0+IE9rIChmIHgpXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCByZXR1cm4geCA9IE9rIHhcbiAgZW5kKVxuXG5sZXQgaW52YXJpYW50IGNoZWNrX29rIGNoZWNrX2Vycm9yIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBvayAtPiBjaGVja19vayBva1xuICB8IEVycm9yIGVycm9yIC0+IGNoZWNrX2Vycm9yIGVycm9yXG47O1xuXG5sZXQgZmFpbCB4ID0gRXJyb3IgeFxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxuXG5sZXQgbWFwX2Vycm9yIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBfIGFzIHggLT4geFxuICB8IEVycm9yIHggLT4gRXJyb3IgKGYgeClcbjs7XG5cbm1vZHVsZSBFcnJvciA9IE1vbmFkLk1ha2UyX2xvY2FsIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdiLCAnYSkgdFxuXG4gICAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgT2sgXyBhcyBvayAtPiBva1xuICAgICAgfCBFcnJvciBlIC0+IGYgZVxuICAgIDs7XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBfZXJyb3JcbiAgICBsZXQgcmV0dXJuIGUgPSBFcnJvciBlXG4gIGVuZClcblxubGV0IGlzX29rID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gZmFsc2VcbiAgfCBFcnJvciBfIC0+IHRydWVcbjs7XG5cbmxldCBvayA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBTb21lIHhcbiAgfCBFcnJvciBfIC0+IE5vbmVcbjs7XG5cbmxldCBlcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBOb25lXG4gIHwgRXJyb3IgeCAtPiBTb21lIHhcbjs7XG5cbmxldCBvZl9vcHRpb24gb3B0IH5lcnJvciA9XG4gIG1hdGNoIG9wdCB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+IEVycm9yIGVycm9yXG47O1xuXG5sZXQgaXRlciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgeCAtPiBmIHhcbiAgfCBFcnJvciBfIC0+ICgpXG47O1xuXG5sZXQgaXRlcl9lcnJvciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgXyAtPiAoKVxuICB8IEVycm9yIHggLT4gZiB4XG47O1xuXG5sZXQgdG9fZWl0aGVyIDogXyB0IC0+IF8gRWl0aGVyLnQgPSBmdW5jdGlvblxuICB8IE9rIHggLT4gRmlyc3QgeFxuICB8IEVycm9yIHggLT4gU2Vjb25kIHhcbjs7XG5cbmxldCBvZl9laXRoZXIgOiBfIEVpdGhlci50IC0+IF8gdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBPayB4XG4gIHwgU2Vjb25kIHggLT4gRXJyb3IgeFxuOztcblxubGV0IG9rX2lmX3RydWUgYm9vbCB+ZXJyb3IgPSBpZiBib29sIHRoZW4gT2sgKCkgZWxzZSBFcnJvciBlcnJvclxuXG5sZXQgdHJ5X3dpdGggZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciBleG5cbjs7XG5cbmxldCBva19leG4gPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4biAtPiByYWlzZSBleG5cbjs7XG5cbmxldCBva19vcl9mYWlsd2l0aCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3Igc3RyIC0+IGZhaWx3aXRoIHN0clxuOztcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlICgnb2ssICdlcnIpIF9yZXN1bHQgPSAoJ29rLCAnZXJyKSB0ID1cbiAgICB8IE9rIG9mICdva1xuICAgIHwgRXJyb3Igb2YgJ2VyclxuXG4gIGxldCBpc19lcnJvciA9IGlzX2Vycm9yXG4gIGxldCBpc19vayA9IGlzX29rXG5lbmRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IE9rIF8sIEVycm9yIGUgfCBFcnJvciBlLCBPayBfIC0+IEVycm9yIGVcbiAgfCBPayBvazEsIE9rIG9rMiAtPiBPayAob2sgb2sxIG9rMilcbiAgfCBFcnJvciBlcnIxLCBFcnJvciBlcnIyIC0+IEVycm9yIChlcnIgZXJyMSBlcnIyKVxuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0MS5wYXJ0aXRpb25fbWFwIGwgfmY6dG9fZWl0aGVyIGluXG4gIG1hdGNoIGVycnMgd2l0aFxuICB8IFtdIC0+IE9rIG9rXG4gIHwgXyA6OiBfIC0+IEVycm9yIGVycnNcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBtYXAgKGNvbWJpbmVfZXJyb3JzIGwpIH5mOihmdW4gKF8gOiB1bml0IGxpc3QpIC0+ICgpKVxuXG4oKiBkZXByZWNhdGVkIGJpbmRpbmcgZm9yIGV4cG9ydCBvbmx5ICopXG5sZXQgb2tfZnN0ID0gdG9fZWl0aGVyXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTM3MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJDb250aW51ZV9vcl9zdG9wIiwiRXhwb3J0IiwiQmFzZV9Db250YWluZXJfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFELHFCQUFBO0FBQUEsSUFBQUUsc0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1Mzg2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQXJyYXkwIiwiQmFzZV9MaXN0MCIsIkJhc2VfSW1wb3J0IiwiQmFzZV9XaXRoX3JldHVybiIsIndpdGhfcmV0dXJuIiwiaXRlciIsImZvbGQiLCJ0IiwicGFyYW0iLCJhIiwiY291bnQiLCJuIiwic3VtIiwiTSIsImZvbGRfcmVzdWx0IiwiaW5pdCIsImFjYyIsIml0ZW0iLCJlIiwieCIsImZvbGRfdW50aWwiLCJmaW5pc2giLCJtYXRjaCIsIm1pbl9lbHQiLCJjb21wYXJlIiwiZWx0IiwibWluIiwibWF4X2VsdCIsIm1heCIsImxlbmd0aCIsImMiLCJpc19lbXB0eSIsInIiLCJtZW0iLCJlcXVhbCIsInkiLCJleGlzdHMiLCJmb3JfYWxsIiwiZmluZF9tYXAiLCJyZXMiLCJmaW5kIiwidG9fbGlzdCIsInRvX2FycmF5IiwiYXJyYXkiLCJpIiwiTWFrZV9nZW4iLCJUIiwibSIsIk1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMiLCJpbmNsdWRlIiwib2ZfbGlzdCIsIm9mX2FycmF5IiwiY29uY2F0IiwiY29uY2F0X29mX2FycmF5IiwiYXBwZW5kIiwiYiIsImNvbmNhdF9tYXAiLCJmaWx0ZXJfbWFwIiwibWFwIiwiZmlsdGVyIiwicGFydGl0aW9uX21hcCIsInhzIiwiZWl0aGVyIiwieXMiLCJwYXJ0aXRpb25fdGYiLCJCYXNlX0NvbnRhaW5lciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2NvbnRhaW5lci5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxZQUFBQyxLQUFBQyxNQUFBQyxHQUFBZDtBQUFBQSxJQ2N5QztBQUFBLGtDQUFBZSxPQUFBQyxHQUFnQyx1QkFBRyxHQUFDO0FBQUE7QUFBQSxZQUFBQyxNQUFBSixNQUFBQyxHQUFBZDtBQUFBQSxJQUN0RDtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBa0IsR0FBQUY7QUFBQUEsY0FBaUMsMEJBQVMscUNBQVk7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBRyxJQUFBTixNQUFBTyxHQUFBTixHQUFBZDtBQUFBQSxJQUc1RTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBa0IsR0FBQUY7QUFBQUEsa0JBQUEsTUFBNkM7QUFBQSxjQUFLO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQUssWUFBQVIsTUFBQVMsTUFBQXRCLEdBQUFjO0FBQUFB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QUFFLFdBQUE7QUFBQSxTQUFBMUIsU0FBQTtBQUFBLFNBQUFDLFNBQUE7QUFBQSxTQUFBUSxjQUFBO0FBQUEsU0FBQU0sYUFBQTtBQUFBLFNBQUFnQixTQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUEzQixRQUFBO0FBQUEsU0FBQUUsTUFBQTtBQUFBLFNBQUE0QixPQUFBO0FBQUEsU0FBQUYsV0FBQTtBQUFBLFNBQUFHLFVBQUE7QUFBQSxTQUFBQyxXQUFBO0FBQUEsU0FBQW5CLFVBQUE7QUFBQSxTQUFBSSxVQUFBO0FBQUEsU0FBQXVCLFlBQUE7QUFBQSxTQUFBQyxhQUFBO0FBQUEsU0FBQUcsU0FBQTtBQUFBLFNBQUFGLFdBQUE7QUFBQSxTQUFBTSxNQUFBO0FBQUEsU0FBQUMsU0FBQTtBQUFBLFNBQUFGLGFBQUE7QUFBQSxTQUFBRCxhQUFBO0FBQUEsU0FBQVEsZUFBQTtBQUFBLFNBQUFKLGdCQUFBO0FBQUE7QUFBQSxpQkFBQTNCLElBQUExQixHQUFBWSxHQ29PZ0IscUNBQTBCO0FBQUEsUURwTzFDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgQ29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAoJ3QsICdhLCAnYWNjdW0pIGZvbGQgPVxuICAndCAtPiBpbml0OidhY2N1bSAtPiBmOigoJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSlbQGxvY2FsXSkgLT4gJ2FjY3VtXG5cbnR5cGUgKCd0LCAnYSkgaXRlciA9ICd0IC0+IGY6KCgnYSAtPiB1bml0KVtAbG9jYWxdKSAtPiB1bml0XG50eXBlICd0IGxlbmd0aCA9ICd0IC0+IGludFxuXG5sZXQgaXRlciB+KGZvbGQgOiAoXywgXywgXykgZm9sZCkgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKSBbQG5vbnRhaWxdXG5sZXQgY291bnQgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiBhIC0+IGlmIGYgYSB0aGVuIG4gKyAxIGVsc2UgbikgW0Bub250YWlsXVxuXG5sZXQgc3VtICh0eXBlIGEpIH5mb2xkIChtb2R1bGUgTSA6IFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDpNLnplcm8gfmY6KGZ1biBuIGEgLT4gTS4oICsgKSBuIChmIGEpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIFJlc3VsdC5Pa1xuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgUmVzdWx0Lk9rIHggLT4geFxuICAgICAgICAgfCBFcnJvciBfIGFzIGUgLT4gcmV0dXJuIGUpKSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgfmZpbmlzaCB0ID1cbiAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgZmluaXNoXG4gICAgICAoZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGl0ZW0gLT5cbiAgICAgICAgIG1hdGNoIGYgYWNjIGl0ZW0gd2l0aFxuICAgICAgICAgfCBDb250aW51ZV9vcl9zdG9wLkNvbnRpbnVlIHggLT4geFxuICAgICAgICAgfCBTdG9wIHggLT4gcmV0dXJuIHgpKSkgW0Bub250YWlsXVxuOztcblxubGV0IG1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZSA9XG4gIGZvbGQgdCB+aW5pdDpOb25lIH5mOihmdW4gYWNjIGVsdCAtPlxuICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgZWx0XG4gICAgfCBTb21lIG1pbiAtPiBpZiBjb21wYXJlIG1pbiBlbHQgPiAwIHRoZW4gU29tZSBlbHQgZWxzZSBhY2MpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmUgPVxuICBmb2xkIHQgfmluaXQ6Tm9uZSB+ZjooZnVuIGFjYyBlbHQgLT5cbiAgICBtYXRjaCBhY2Mgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIGVsdFxuICAgIHwgU29tZSBtYXggLT4gaWYgY29tcGFyZSBtYXggZWx0IDwgMCB0aGVuIFNvbWUgZWx0IGVsc2UgYWNjKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbGVuZ3RoIH5mb2xkIGMgPSBmb2xkIGMgfmluaXQ6MCB+ZjooZnVuIGFjYyBfIC0+IGFjYyArIDEpXG5cbmxldCBpc19lbXB0eSB+aXRlciBjID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4gXyAtPiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBtZW0gfml0ZXIgYyB4IH5lcXVhbCA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHkgLT4gaWYgZXF1YWwgeCB5IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBleGlzdHMgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb3JfYWxsIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIG5vdCAoZiB4KSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9tYXAgfml0ZXIgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgdCB+ZjooZnVuIHggLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIHIucmV0dXJuIChTb21lIHgpKTtcbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgdG9fbGlzdCB+Zm9sZCBjID0gTGlzdC5yZXYgKGZvbGQgYyB+aW5pdDpbXSB+ZjooZnVuIGFjYyB4IC0+IHggOjogYWNjKSlcblxubGV0IHRvX2FycmF5IH5sZW5ndGggfml0ZXIgYyA9XG4gIGxldCBhcnJheSA9IHJlZiBbfHxdIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgaXRlciBjIH5mOihmdW4geCAtPlxuICAgIGlmICFpID0gMCB0aGVuIGFycmF5IDo9IEFycmF5LmNyZWF0ZSB+bGVuOihsZW5ndGggYykgeDtcbiAgICAhYXJyYXkuKCFpKSA8LSB4O1xuICAgIGluY3IgaSk7XG4gICFhcnJheVxuOztcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogTWFrZV9nZW5fYXJnKSA6XG4gIEdlbmVyaWMgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20pIHQgOj0gKCdhLCAncGhhbnRvbSkgVC50IGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9XG5zdHJ1Y3RcbiAgbGV0IGZvbGQgPSBULmZvbGRcblxuICBsZXQgaXRlciA9XG4gICAgbWF0Y2ggVC5pdGVyIHdpdGhcbiAgICB8IGBDdXN0b20gaXRlciAtPiBpdGVyXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmYgLT4gaXRlciB+Zm9sZCB0IH5mXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9XG4gICAgbWF0Y2ggVC5sZW5ndGggd2l0aFxuICAgIHwgYEN1c3RvbSBsZW5ndGggLT4gbGVuZ3RoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgLT4gbGVuZ3RoIH5mb2xkIHRcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IGlzX2VtcHR5IH5pdGVyIHRcbiAgbGV0IG1lbSB0IHggfmVxdWFsID0gbWVtIH5pdGVyIHQgeCB+ZXF1YWxcbiAgbGV0IHN1bSBtIHQgPSBzdW0gfmZvbGQgbSB0XG4gIGxldCBjb3VudCB0IH5mID0gY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBleGlzdHMgfml0ZXIgdCB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gZm9yX2FsbCB+aXRlciB0IH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXAgfml0ZXIgdCB+ZlxuICBsZXQgZmluZCB0IH5mID0gZmluZCB+aXRlciB0IH5mXG4gIGxldCB0b19saXN0IHQgPSB0b19saXN0IH5mb2xkIHRcbiAgbGV0IHRvX2FycmF5IHQgPSB0b19hcnJheSB+bGVuZ3RoIH5pdGVyIHRcbiAgbGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IG1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gbWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gZm9sZF9yZXN1bHQgdCB+Zm9sZCB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBmb2xkX3VudGlsIHQgfmZvbGQgfmluaXQgfmYgfmZpbmlzaFxuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgKCdhLCBfKSB0ID0gJ2EgVC50XG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAoJ2EsIF8pIHQgPSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgIGVuZClcblxuICBsZXQgbWVtIHQgeCA9IG1lbSB0IHggfmVxdWFsOlQuRWx0LmVxdWFsXG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX2dlbl93aXRoX2NyZWF0b3JzX2FyZykgOlxuICBHZW5lcmljX3dpdGhfY3JlYXRvcnNcbiAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20pIHQgOj0gKCdhLCAncGhhbnRvbSkgVC50XG4gICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbiAgIGFuZCB0eXBlICgnYSwgJ3BoYW50b20pIGNvbmNhdCA6PSAoJ2EsICdwaGFudG9tKSBULmNvbmNhdCA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChUKVxuXG4gIGxldCBvZl9saXN0ID0gVC5vZl9saXN0XG4gIGxldCBvZl9hcnJheSA9IFQub2ZfYXJyYXlcbiAgbGV0IGNvbmNhdCA9IFQuY29uY2F0XG4gIGxldCBjb25jYXRfb2ZfYXJyYXkgPSBULmNvbmNhdF9vZl9hcnJheVxuICBsZXQgYXBwZW5kIGEgYiA9IGNvbmNhdCAoY29uY2F0X29mX2FycmF5IFt8IGE7IGIgfF0pXG4gIGxldCBjb25jYXRfbWFwIHQgfmYgPSBjb25jYXQgKGNvbmNhdF9vZl9hcnJheSAoQXJyYXkubWFwICh0b19hcnJheSB0KSB+ZikpXG5cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gICAgY29uY2F0X21hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBvZl9hcnJheSBbfHxdXG4gICAgICB8IFNvbWUgeSAtPiBvZl9hcnJheSBbfCB5IHxdKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBTb21lIChmIHgpKSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICAgIGxldCBhcnJheSA9IEFycmF5Lm1hcCAodG9fYXJyYXkgdCkgfmYgaW5cbiAgICBsZXQgeHMgPVxuICAgICAgQXJyYXkuZm9sZF9yaWdodCBhcnJheSB+aW5pdDpbXSB+ZjooZnVuIGVpdGhlciBhY2MgLT5cbiAgICAgICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCB4IC0+IHggOjogYWNjXG4gICAgICAgIHwgU2Vjb25kIF8gLT4gYWNjKVxuICAgIGluXG4gICAgbGV0IHlzID1cbiAgICAgIEFycmF5LmZvbGRfcmlnaHQgYXJyYXkgfmluaXQ6W10gfmY6KGZ1biBlaXRoZXIgYWNjIC0+XG4gICAgICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgXyAtPiBhY2NcbiAgICAgICAgfCBTZWNvbmQgeCAtPiB4IDo6IGFjYylcbiAgICBpblxuICAgIG9mX2xpc3QgeHMsIG9mX2xpc3QgeXNcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIHBhcnRpdGlvbl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gRmlyc3QgeCBlbHNlIFNlY29uZCB4KSBbQG5vbnRhaWxdXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2Vfd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2Vfd2l0aF9jcmVhdG9yc19hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICAgIHR5cGUgKCdhLCBfKSBjb25jYXQgPSAnYSBULnRcblxuICAgICAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IG9mX2FycmF5XG4gICAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMF93aXRoX2NyZWF0b3JzIChUIDogTWFrZTBfd2l0aF9jcmVhdG9yc19hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAoJ2EsIF8pIHQgPSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgICAgdHlwZSAoJ2EsIF8pIGNvbmNhdCA9ICdhIGxpc3RcblxuICAgICAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IEFycmF5LnRvX2xpc3RcbiAgICBlbmQpXG5cbiAgbGV0IG1lbSB0IHggPSBtZW0gdCB4IH5lcXVhbDpULkVsdC5lcXVhbFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjAwNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0luZGV4ZWRfY29udGFpbmVyX2ludGYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLDhCQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjAxOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0FycmF5MCIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1dpdGhfcmV0dXJuIiwid2l0aF9yZXR1cm4iLCJpdGVyaSIsImZvbGQiLCJ0IiwiaSIsIngiLCJmb2xkaSIsImluaXQiLCJhY2MiLCJ2IiwiY291bnRpIiwibiIsImEiLCJleGlzdHNpIiwiYyIsInIiLCJmb3JfYWxsaSIsImZpbmRfbWFwaSIsInJlcyIsImZpbmRpIiwiTWFrZV9nZW5fd2l0aF9jb250YWluZXIiLCJUIiwibGVuZ3RoIiwiaXNfZW1wdHkiLCJtZW0iLCJpdGVyIiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZXhpc3RzIiwiZm9yX2FsbCIsImNvdW50Iiwic3VtIiwiZmluZCIsImZpbmRfbWFwIiwidG9fbGlzdCIsInRvX2FycmF5IiwibWluX2VsdCIsIm1heF9lbHQiLCJtYXRjaCIsIk1ha2VfZ2VuIiwiQyIsImluY2x1ZGUiLCJNYWtlX2dlbl93aXRoX2NyZWF0b3JzIiwib2ZfbGlzdCIsIm9mX2FycmF5IiwiYXBwZW5kIiwiY29uY2F0IiwibWFwIiwiZmlsdGVyIiwiZmlsdGVyX21hcCIsImNvbmNhdF9tYXAiLCJwYXJ0aXRpb25fdGYiLCJwYXJ0aXRpb25fbWFwIiwiZGVyaXZlZF9pbml0IiwiZGVyaXZlZF9jb25jYXRfbWFwaSIsImNvbmNhdF9tYXBpIiwiZmlsdGVyX21hcGkiLCJ5IiwibWFwaSIsImZpbHRlcmkiLCJCYXNlX0luZGV4ZWRfY29udGFpbmVyIiwiY29uY2F0X29mX2FycmF5Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvaW5kZXhlZF9jb250YWluZXIubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtB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U0FBQUMsV0FBQTtBQUFBLFNBQUFFLFNBQUE7QUFBQSxTQUFBdkIsU0FBQTtBQUFBLFNBQUF3QixjQUFBO0FBQUEsU0FBQUMsYUFBQTtBQUFBLFNBQUFDLFNBQUE7QUFBQSxTQUFBQyxVQUFBO0FBQUEsU0FBQUMsUUFBQTtBQUFBLFNBQUFDLE1BQUE7QUFBQSxTQUFBQyxPQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBQyxXQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBL0IsVUFBQTtBQUFBLFNBQUFMLFVBQUE7QUFBQSxTQUFBWSxVQUFBO0FBQUEsU0FBQUcsV0FBQTtBQUFBLFNBQUFOLFNBQUE7QUFBQSxTQUFBUyxRQUFBO0FBQUEsU0FBQUYsWUFBQTtBQUFBLFNBQUFWLFNBQUE7QUFBQSxTQUFBbUQsT0FBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBSCxjQUFBO0FBQUEsU0FBQUQsZ0JBQUE7QUFBQTtBQUFBLGlCQUFBL0IsSUFBQXJCLEdBQUFFLEdDNktnQixxQ0FBMEI7QUFBQSxRRDdLMUMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5pbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxubGV0IGl0ZXJpIH5mb2xkIHQgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIHYgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgdiBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYykgW0Bub250YWlsXVxuOztcblxubGV0IGNvdW50aSB+Zm9sZGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGkgbiBhIC0+IGlmIGYgaSBhIHRoZW4gbiArIDEgZWxzZSBuKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZXhpc3RzaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvcl9hbGxpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBub3QgKGYgaSB4KSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9tYXBpIH5pdGVyaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gKFNvbWUgKGksIHgpKSk7XG4gICAgTm9uZSkgW0Bub250YWlsXVxuOztcblxuKCogQWxsb3dzIFtNYWtlX2dlbl0gdG8gc2hhcmUgYSBbQ29udGFpbmVyLkdlbmVyaWNdIGltcGxlbWVudGF0aW9uIHdpdGgsIGUuZy4sXG4gICBbQ29udGFpbmVyLk1ha2VfZ2VuX3dpdGhfY3JlYXRvcnNdLiAqKVxubW9kdWxlIE1ha2VfZ2VuX3dpdGhfY29udGFpbmVyXG4gICAgKFQgOiBNYWtlX2dlbl9hcmcpXG4gICAgKEMgOiBDb250YWluZXIuR2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbSkgdCA6PSAoJ2EsICdwaGFudG9tKSBULnRcbiAgICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCkgOlxuICBHZW5lcmljIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tKSB0IDo9ICgnYSwgJ3BoYW50b20pIFQudCBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHQgPVxuc3RydWN0XG4gIGluY2x1ZGUgQ1xuXG4gIGxldCBpdGVyaSA9XG4gICAgbWF0Y2ggVC5pdGVyaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXJpIC0+IGl0ZXJpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmYgLT4gaXRlcmkgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBmb2xkaSA9XG4gICAgbWF0Y2ggVC5mb2xkaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGZvbGRpIC0+IGZvbGRpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmluaXQgfmYgLT4gZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBjb3VudGkgdCB+ZiA9IGNvdW50aSB+Zm9sZGkgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gZXhpc3RzaSB+aXRlcmkgdCB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IGZvcl9hbGxpIH5pdGVyaSB0IH5mXG4gIGxldCBmaW5kX21hcGkgdCB+ZiA9IGZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZGkgdCB+ZiA9IGZpbmRpIH5pdGVyaSB0IH5mXG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogTWFrZV9nZW5fYXJnKSA6XG4gIEdlbmVyaWMgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20pIHQgOj0gKCdhLCAncGhhbnRvbSkgVC50IGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9XG5zdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZV9nZW4gKFQpXG4gIGluY2x1ZGUgQ1xuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY29udGFpbmVyIChUKSAoQylcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICgnYSwgXykgdCA9ICdhIFQudFxuICAgICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgTWFrZTAgKFQgOiBNYWtlMF9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgKF8sIF8pIHQgPSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgIGVuZClcblxuICBsZXQgbWVtIHQgeCA9IG1lbSB0IHggfmVxdWFsOlQuRWx0LmVxdWFsXG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX2dlbl93aXRoX2NyZWF0b3JzX2FyZykgOlxuICBHZW5lcmljX3dpdGhfY3JlYXRvcnNcbiAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20pIHQgOj0gKCdhLCAncGhhbnRvbSkgVC50XG4gICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbiAgIGFuZCB0eXBlICgnYSwgJ3BoYW50b20pIGNvbmNhdCA6PSAoJ2EsICdwaGFudG9tKSBULmNvbmNhdCA9IHN0cnVjdFxuICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlX2dlbl93aXRoX2NyZWF0b3JzIChUKVxuICBpbmNsdWRlIENcbiAgaW5jbHVkZSBNYWtlX2dlbl93aXRoX2NvbnRhaW5lciAoVCkgKEMpXG5cbiAgbGV0IGRlcml2ZWRfaW5pdCBuIH5mID0gb2ZfYXJyYXkgKEFycmF5LmluaXQgbiB+ZilcblxuICBsZXQgaW5pdCA9XG4gICAgbWF0Y2ggVC5pbml0IHdpdGhcbiAgICB8IGBDdXN0b20gaW5pdCAtPiBpbml0XG4gICAgfCBgRGVmaW5lX3VzaW5nX29mX2FycmF5IC0+IGRlcml2ZWRfaW5pdFxuICA7O1xuXG4gIGxldCBkZXJpdmVkX2NvbmNhdF9tYXBpIHQgfmYgPSBjb25jYXQgKFQuY29uY2F0X29mX2FycmF5IChBcnJheS5tYXBpICh0b19hcnJheSB0KSB+ZikpXG5cbiAgbGV0IGNvbmNhdF9tYXBpID1cbiAgICBtYXRjaCBULmNvbmNhdF9tYXBpIHdpdGhcbiAgICB8IGBDdXN0b20gY29uY2F0X21hcGkgLT4gY29uY2F0X21hcGlcbiAgICB8IGBEZWZpbmVfdXNpbmdfY29uY2F0IC0+IGRlcml2ZWRfY29uY2F0X21hcGlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgY29uY2F0X21hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBOb25lIC0+IG9mX2FycmF5IFt8fF1cbiAgICAgIHwgU29tZSB5IC0+IG9mX2FycmF5IFt8IHkgfF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWFwaSB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBTb21lIChmIGkgeCkpIFtAbm9udGFpbF1cblxuICBsZXQgZmlsdGVyaSB0IH5mID1cbiAgICBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX3dpdGhfY3JlYXRvcnNfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgKCdhLCBfKSB0ID0gJ2EgVC50XG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgICB0eXBlICgnYSwgXykgY29uY2F0ID0gJ2EgVC50XG5cbiAgICAgIGxldCBjb25jYXRfb2ZfYXJyYXkgPSBvZl9hcnJheVxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgTWFrZTBfd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2UwX3dpdGhfY3JlYXRvcnNfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgKF8sIF8pIHQgPSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgICAgdHlwZSAoJ2EsIF8pIGNvbmNhdCA9ICdhIGxpc3RcblxuICAgICAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IEFycmF5LnRvX2xpc3RcbiAgICBlbmQpXG5cbiAgbGV0IG1lbSB0IHggPSBtZW0gdCB4IH5lcXVhbDpULkVsdC5lcXVhbFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjczOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9JbXBvcnQiLCJTdGRsaWJfTGF6eSIsIkJhc2VfSGFzaCIsIkJhc2VfTW9uYWQiLCJVbmRlZmluZWQiLCJpc192YWwiLCJmcm9tX3ZhbCIsImZyb21fZnVuIiwiZm9yY2VfdmFsIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsImNvbXBhcmUiLCJjb21wYXJlX2EiLCJ0MSIsInQyIiwiZXF1YWwiLCJlcXVhbF9hIiwiaGFzaF9mb2xkX3QiLCJwZWVrIiwidCIsInJldHVybiIsIngiLCJiaW5kIiwibWFwIiwiaW5jbHVkZSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsIk1vbmFkX2luZml4Iiwiam9pbiIsImlnbm9yZV9tIiwiYWxsIiwiYWxsX3VuaXQiLCJMZXRfc3ludGF4IiwiY3N0X3VuZm9yY2VkX2xhenkiLCJzZXhwX29mX2EiLCJUX3VuZm9yY2luZyIsIkJhc2VfTGF6eSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2xhenkubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxlQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsWUFBQUMsZUFBQUM7QUFBQUEsSUNTMEIsbURBQW9DO0FBQUE7QUFBQSxZQUFBQyxRQUFBQyxXQUFBQyxJQUFBQztBQUFBQSxJQVV6RCx5Q0FBc0I7QUFBQSxjQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQStCO0FBQUE7QUFBQSxZQUFBQyxNQUFBQyxTQUFBSCxJQUFBQztBQUFBQSxJQUdwQyx5Q0FBc0I7QUFBQSxjQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0NBQTZCO0FBQUE7QUFBQSxPQUFBRyxjRHRCMUY7QUFBQSxZQUFBQyxLQUFBQztBQUFBQSxJQ3dCZ0IsNEJBQWtDO0FBQUEsY0FBcEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBd0I7QUFBQSxZQUFBQyxTQUFBQyxHQUtuQyw4QkFBVTtBQUFBLFlBQUFDLEtBQUFILEdBQUEzQjtBQUFBQSxJQUNUO0FBQUE7QUFBQSx1QkQ5QnBCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkM4QmdDLDBCQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBekI7QUFBQSxHQUEwQjtBQUFBO0FBQUEsSUFBQStCO0FBQUFBLE1EOUI5QztBQUFBO0FBQUEsZ0JBQUFKLEdBQUEzQjtBQUFBQSxRQ2dCZTtBQUFBO0FBQUEsMkJEaEJmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQ2dCZTtBQUFBLE9BQWtCO0FBQUEsSUFBQWdDLFVEaEJqQztBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFMLFNBQUE7QUFBQSxJQUFBRixXQUFBO0FBQUEsSUFBQUcsUUFBQTtBQUFBLElBQUFLLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxZQUFBekIsWUFBQTBCLFdBQUFmO0FBQUFBLElDdUNPO0FBQUEsS0FBdUMsc0RBQWdDO0FBQUEsY0FBekQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFDQUF5RDtBQUFBO0FBQUE7QUFBQSxJQUFBZ0IsY0R2QzlFO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFN0ZGxpYi5MYXp5XG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gbGF6eV90X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2xhenlfdFxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxhenlfdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxuZXh0ZXJuYWwgZm9yY2UgOiAoJ2EgdFtAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxubGV0IG1hcCB0IH5mID0gbGF6eSAoZiAoZm9yY2UgdCkpXG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiAwIGVsc2UgY29tcGFyZV9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPSBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gdHJ1ZSBlbHNlIGVxdWFsX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG5sZXQgaGFzaF9mb2xkX3QgPSBIYXNoLkJ1aWx0aW4uaGFzaF9mb2xkX2xhenlfdFxubGV0IHBlZWsgdCA9IGlmIGlzX3ZhbCB0IHRoZW4gU29tZSAoZm9yY2UgdCkgZWxzZSBOb25lXG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4geCA9IGZyb21fdmFsIHhcbiAgICBsZXQgYmluZCB0IH5mID0gbGF6eSAoZm9yY2UgKGYgKGZvcmNlIHQpKSlcbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubW9kdWxlIFRfdW5mb3JjaW5nID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgaWYgaXNfdmFsIHQgdGhlbiBzZXhwX29mX2EgKGZvcmNlIHQpIGVsc2Ugc2V4cF9vZl9zdHJpbmcgXCI8dW5mb3JjZWQgbGF6eT5cIlxuICA7O1xuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjkxNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0luZm9faW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsaUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo2OTI4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDIiLCJmIiwiYTAiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfUHJpbnRmIiwiaW52YWxpZF9hcmdmIiwic2xvd19jaGVja19wb3NfbGVuX2V4biIsInBvcyIsImxlbiIsInRvdGFsX2xlbmd0aCIsImNoZWNrX3Bvc19sZW5fZXhuIiwic3RvcCIsImdldF9wb3NfbGVuX2V4biIsIm9wdCIsInBhcmFtIiwiaSIsIlByaXZhdGUiLCJCYXNlX09yZGVyZWRfY29sbGVjdGlvbl9jb21tb24iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUgsR0FBQUMsSUFBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFMLEdBQUFDLElBQUFDLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyx1QkFBQUMsS0FBQUMsS0FBQUM7QUFBQUEsSUNPRSxZQUFnQjtBQUFBLElBQ2hCLFlBQWdCO0FBQUEsY0FHUDtBQUFBLElBQWtCO0FBQUEsY0FDdEI7QUFBQSxpQkFBdUU7QUFBQTtBQUFBLFlBQUFDLGtCQUFBSCxLQUFBQyxLQUFBQztBQUFBQTtBQUFBQSxLQUFBRSxPQWdCakU7QUFBQSxXQUNpQjtBQUFBLFdBQXpCO0FBQUE7QUFBQTtBQUFBLElBQThDLGFBQzVDLG9EQUE4QztBQUFBO0FBQUEsWUFBQUMsZ0JBQUFDLEtBQUFMLEtBQUFNLE9BQUFMO0FBQUFBLFFBQUFGLE1BSWpDO0FBQUEsSUFDbEI7QUFBQSxTQUFBUSxJQUFBLFFBQUFQLFFBRWM7QUFBQTtBQUFBLFNBQUFBLFFBQ0Y7QUFBQSxJQUVaO0FBQUEsSUFBeUM7QUFBQSxHQUNqQztBQUFBO0FBQUEsSUFBQVEsVUR6Q1Y7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBTcGxpdCBvZmYgdG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSB3aXRoIFtPcl9lcnJvcl0uICopXG5cbm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5sZXQgc2xvd19jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gIGlmIHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJOZWdhdGl2ZSBwb3NpdGlvbjogJWRcIiBwb3MgKCk7XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJOZWdhdGl2ZSBsZW5ndGg6ICVkXCIgbGVuICgpO1xuICAoKiBXZSB1c2UgW3BvcyA+IHRvdGFsX2xlbmd0aCAtIGxlbl0gcmF0aGVyIHRoYW4gW3BvcyArIGxlbiA+IHRvdGFsX2xlbmd0aF0gdG8gYXZvaWQgdGhlXG4gICAgIHBvc3NpYmlsaXR5IG9mIG92ZXJmbG93LiAqKVxuICBpZiBwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJwb3MgKyBsZW4gcGFzdCBlbmQ6ICVkICsgJWQgPiAlZFwiIHBvcyBsZW4gdG90YWxfbGVuZ3RoICgpXG5bQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuOztcblxubGV0IGNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoID1cbiAgKCogVGhpcyBpcyBiZXR0ZXIgdGhhbiBbc2xvd19jaGVja19wb3NfbGVuX2V4bl0gZm9yIHR3byByZWFzb25zOlxuXG4gICAgIC0gbXVjaCBsZXNzIGlubGluZWQgY29kZVxuICAgICAtIG9ubHkgb25lIGNvbmRpdGlvbmFsIGp1bXBcblxuICAgICBUaGUgcmVhc29uIGl0IHdvcmtzIGlzIHRoYXQgY2hlY2tpbmcgWzwgMF0gaXMgdGVzdGluZyB0aGUgaGlnaGVzdCBvcmRlciBiaXQsIHNvXG4gICAgIFthIDwgMCB8fCBiIDwgMF0gaXMgdGhlIHNhbWUgYXMgW2EgbG9yIGIgPCAwXS5cblxuICAgICBbcG9zICsgbGVuXSBjYW4gb3ZlcmZsb3csIHNvIFtwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5dIGlzIG5vdCBlcXVpdmFsZW50IHRvXG4gICAgIFt0b3RhbF9sZW5ndGggLSBsZW4gLSBwb3MgPCAwXSwgd2UgbmVlZCB0byB0ZXN0IGZvciBbcG9zICsgbGVuXSBvdmVyZmxvdyBhc1xuICAgICB3ZWxsLiAqKVxuICBsZXQgc3RvcCA9IHBvcyArIGxlbiBpblxuICBpZiBwb3MgbG9yIGxlbiBsb3Igc3RvcCBsb3IgKHRvdGFsX2xlbmd0aCAtIHN0b3ApIDwgMFxuICB0aGVuIHNsb3dfY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGhcbltAQGlubGluZSBhbHdheXNdXG47O1xuXG5sZXQgZ2V0X3Bvc19sZW5fZXhuID8ocG9zID0gMCkgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgaSAtPiBpXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgcG9zLCBsZW5cbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuID0gc2xvd19jaGVja19wb3NfbGVuX2V4blxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NzAwMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRG9tYWluIiwiU3RkbGliX1JhbmRvbSIsIlN0ZGxpYl9MYXp5IiwiQ2FtbGludGVybmFsTGF6eSIsIm9mX3N0YXRlIiwiUmVwciIsImFzc2lnbiIsImRzdCIsInNyYyIsIm1ha2VfZGVmYXVsdCIsImRlZmF1bHQiLCJzcGxpdF9mcm9tX3BhcmVudCIsInYiLCJwYXJhbSIsImdldF9zdGF0ZSIsInJhbmRvbV9rZXkiLCJCYXNlX1JhbmRvbV9yZXByIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvcmFuZG9tX3JlcHIubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxlQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsU0FBQTtBQUFBLE9BQUFDLE9BQUE7QUFBQSxZQUFBQyxPQUFBQyxLQUFBQztBQUFBQSxRQUFBLE1DVUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBQUFELFFBQVUsZ0NBQ1Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBQUFDLFFBQVU7QUFBQSxJQUNWLHlDQUFtQztBQUFBO0FBQUEsWUFBQUMsYUFBQUM7QUFBQUEsYUFBQUMsa0JBQUFDO0FBQUFBLEtBSWpDLDJEQUErQztBQUFBO0FBQUEsSUFFakQ7QUFBQTtBQUFBO0FBQUEsc0JBQUFDLE9BQXdELGlCQUFPLEVBQUM7QUFBQTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBLElBRXZDLG1EQUFnQztBQUFBO0FBQUEsT0FBQUMsbUJEcEIzRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICBvcGVuIFN0ZGxpYi5CaWdhcnJheVxuXG4gIHR5cGUgdCA9IChpbnQ2NCwgaW50NjRfZWx0LCBjX2xheW91dCkgQXJyYXkxLnRcblxuICBsZXQgb2Zfc3RhdGUgOiBTdGRsaWIuUmFuZG9tLlN0YXRlLnQgLT4gdCA9IFN0ZGxpYi5PYmoubWFnaWNcbmVuZFxuXG5sZXQgYXNzaWduIGRzdCBzcmMgPVxuICBsZXQgZHN0ID0gUmVwci5vZl9zdGF0ZSAoTGF6eS5mb3JjZSBkc3QpIGluXG4gIGxldCBzcmMgPSBSZXByLm9mX3N0YXRlIChMYXp5LmZvcmNlIHNyYykgaW5cbiAgU3RkbGliLkJpZ2FycmF5LkFycmF5MS5ibGl0IHNyYyBkc3RcblxubGV0IG1ha2VfZGVmYXVsdCBkZWZhdWx0ID1cbiAgbGV0IHNwbGl0X2Zyb21fcGFyZW50IHYgPVxuICAgIFN0ZGxpYi5MYXp5Lm1hcF92YWwgU3RkbGliLlJhbmRvbS5TdGF0ZS5zcGxpdCB2XG4gIGluXG4gIFN0ZGxpYi5Eb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50IChmdW4gKCkgLT4gZGVmYXVsdClcblxubGV0IGdldF9zdGF0ZSByYW5kb21fa2V5ID0gU3RkbGliLkRvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXlcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo3MDY1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfeG9yIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDUiLCJhMiIsImEzIiwiYTQiLCJnbG9iYWxfZGF0YSIsIkJhc2VfUmFuZG9tX3JlcHIiLCJCYXNlX0ltcG9ydCIsIlN0ZGxpYl9JbnQ2NCIsIlN0ZGxpYl9OYXRpdmVpbnQiLCJTdGRsaWJfSW50MzIiLCJCYXNlX0ludDAiLCJCYXNlX1ByaW50ZiIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWJfUmFuZG9tIiwiQmFzZV9MYXp5IiwiQmFzZV9DaGFyMCIsIkJhc2VfV29yZF9zaXplIiwiY3N0X2luaXRpYWxpemluZ19SYW5kb21fd2l0aF9hIiwiZHVtbXkiLCJmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMiLCJhbGxvd19pbl90ZXN0cyIsImJpdHMiLCJ0IiwiYm9vbCIsImludCIsIngiLCJpbnQzMiIsImludDY0IiwibmF0aXZlaW50IiwibWFrZSIsInNlZWQiLCJjb3B5IiwiY2hhciIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJwYXJhbSIsImFzc2lnbiIsImNzdF9mbG9hdCIsImNzdF9pbnQ2NCIsImNzdF9uYXRpdmVpbnQiLCJjc3RfaW50MzIiLCJjc3RfaW50IiwiZGVmYXVsdCIsImludF9vbl82NGJpdHMiLCJib3VuZCIsImludF9vbl8zMmJpdHMiLCJzdGF0ZSIsImZ1bGxfcmFuZ2VfaW50NjQiLCJmdWxsX3JhbmdlX2ludDMyIiwiZnVsbF9yYW5nZV9pbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsIm5hbWUiLCJsb3dlcl9ib3VuZCIsInVwcGVyX2JvdW5kIiwic3RyaW5nX29mX2JvdW5kIiwiaW50X2luY2wiLCJsbyIsImhpIiwiZGlmZiIsImludDMyX2luY2wiLCJuYXRpdmVpbnRfaW5jbCIsImludDY0X2luY2wiLCJmbG9hdCIsInNjYWxlIiwicjEiLCJyMiIsInJlc3VsdCIsImZsb2F0X3JhbmdlIiwieSIsImZ1bGxfaW5pdCIsImluaXQiLCJzZWxmX2luaXQiLCJzZXRfc3RhdGUiLCJzIiwiQmFzZV9SYW5kb20iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9yYW5kb20ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQywrQkFBQUM7QUFBQUEsUUFBQSxNQ21CRTtBQUFBO0FBQUEsSUFDSyx3Q0FFWTtBQUFBLElBRWIsbUVBQ2tGO0FBQUE7QUFB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QUE7QUFBQSxZQUFBRCxjQUFBOUMsR0FBQStDO0FBQUFBLElBQ2pDLE9BQStCLFlBQS9CLGlEQUFtQztBQUFBO0FBQUEsWUFBQWpELE9BQUFZO0FBQUFBLElBQ2xELE9BQStCLEtBQS9CLDJDQUErQjtBQUFBO0FBQUEsWUFBQUgsT0FBQUc7QUFBQUEsSUFDL0IsT0FBK0IsT0FBL0IsMkNBQStCO0FBQUE7QUFBQSxZQUFBRixRQUFBRTtBQUFBQSxJQUM3QixPQUErQixNQUEvQiwyQ0FBK0I7QUFBQTtBQUFBLFlBQUFzQyxVQUFBM0M7QUFBQUEsUUFBQVIsSUFDckI7QUFBQSxJQWpNSCxPQUFXLHNCQUFYLFdBaU11QztBQUFBO0FBQUEsWUFBQW9ELEtBQUE1QyxNQUN6RCwyQkFBb0I7QUFBQSxZQUFBNkMsVUFBQXZELGdCQUFBZTtBQUFBQSxJQTVObEM7QUFBQSxJQUNBLE9BNE4yRSxVQTVOM0UsZ0NBNE4yRTtBQUFBO0FBQUEsWUFBQXlDLFVBQUFDO0FBQUFBLElBQzlDLE9BQStCLG1CQUEvQiw4Q0FBaUM7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFsQlo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDNPcEQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcblxuKCogVW5mb3J0dW5hdGVseSwgYmVjYXVzZSB0aGUgc3RhbmRhcmQgbGlicmFyeSBkb2VzIG5vdCBleHBvc2VcbiAgIFtTdGRsaWIuUmFuZG9tLlN0YXRlLmRlZmF1bHRdLCB3ZSBoYXZlIHRvIGNvbnN0cnVjdCBvdXIgb3duLiAgV2UgdGhlbiBidWlsZCB0aGVcbiAgIFtTdGRsaWIuUmFuZG9tLmludF0sIFtTdGRsaWIuUmFuZG9tLmJvb2xdIGZ1bmN0aW9ucyBhbmQgZnJpZW5kcyB1c2luZyB0aGF0IGRlZmF1bHQgc3RhdGUgaW5cbiAgIGV4YWN0bHkgdGhlIHNhbWUgd2F5IGFzIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LlxuXG4gICBPbmUgb3RoZXIgdHJpY2tpbmVzcyBpcyB0aGF0IHdlIG5lZWQgYWNjZXNzIHRvIHRoZSB1bmV4cG9zZWQgW1N0ZGxpYi5SYW5kb20uU3RhdGUuYXNzaWduXVxuICAgZnVuY3Rpb24sIHdoaWNoIGFjY2Vzc2VzIHRoZSB1bmV4cG9zZWQgc3RhdGUgcmVwcmVzZW50YXRpb24uICBTbywgd2UgY29weSB0aGVcbiAgIFtTdGF0ZS5yZXByXSB0eXBlIGRlZmluaXRpb24gYW5kIFthc3NpZ25dIGZ1bmN0aW9uIHRvIGhlcmUgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSxcbiAgIGFuZCB1c2UgW09iai5tYWdpY10gdG8gZ2V0IGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gKilcblxuKCogUmVncmVzc2lvbiB0ZXN0cyBvdWdodCB0byBiZSBkZXRlcm1pbmlzdGljIGJlY2F1c2UgdGhhdCB3YXkgYW55b25lIHdobyBicmVha3MgdGhlIHRlc3RcbiAgIGtub3dzIHRoYXQgaXQncyB0aGVpciBjb2RlIHRoYXQgYnJva2UgdGhlIHRlc3QuICBJZiB0ZXN0cyBhcmUgbm9uZGV0ZXJtaW5pc3RpYywgYSB0ZXN0XG4gICBmYWlsdXJlIG1heSBpbnN0ZWFkIGhhcHBlbiBiZWNhdXNlIHRoZSB0ZXN0IHJ1bm5lciBnb3QgdW5sdWNreSBhbmQgdW5jb3ZlcmVkIGFuXG4gICBleGlzdGluZyBidWcgaW4gdGhlIGNvZGUgc3VwcG9zZWRseSBiZWluZyBcInByb3RlY3RlZFwiIGJ5IHRoZSB0ZXN0IGluIHF1ZXN0aW9uLiAqKVxubGV0IGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHMgPVxuICBpZiBhbV90ZXN0aW5nXG4gIHRoZW4gKFxuICAgIG1hdGNoIGFsbG93X2luX3Rlc3RzIHdpdGhcbiAgICB8IFNvbWUgdHJ1ZSAtPiAoKVxuICAgIHwgTm9uZSB8IFNvbWUgZmFsc2UgLT5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIFwiaW5pdGlhbGl6aW5nIFJhbmRvbSB3aXRoIGEgbm9uZGV0ZXJtaW5pc3RpYyBzZWVkIGlzIGZvcmJpZGRlbiBpbiBpbmxpbmUgdGVzdHNcIilcbjs7XG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkIDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubGV0IHJhbmRvbV9zZWVkID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gIGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHM7XG4gIHJhbmRvbV9zZWVkICgpXG47O1xuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgKCogV2UgYWxsb3cgbGF6aW5lc3Mgb25seSBmb3IgdGhlIGRlZmluaXRpb24gb2YgW2RlZmF1bHRdLCBiZWxvdywgd2hpY2ggbWF5IGxhemlseSBjYWxsXG4gICAgIFttYWtlX3NlbGZfaW5pdF0uIEZvciBhbGwgb3RoZXIgcHVycG9zZXMsIHdlIGNyZWF0ZSBhbmQgdXNlIFt0XSBlYWdlcmx5LiAqKVxuICB0eXBlIHQgPSBTdGRsaWIuUmFuZG9tLlN0YXRlLnQgTGF6eS50XG5cbiAgbGV0IGJpdHMgdCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSB0KVxuICBsZXQgYm9vbCB0ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5ib29sIChMYXp5LmZvcmNlIHQpXG4gIGxldCBpbnQgdCB4ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgdCkgeFxuICBsZXQgaW50MzIgdCB4ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5pbnQzMiAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBpbnQ2NCB0IHggPSBTdGRsaWIuUmFuZG9tLlN0YXRlLmludDY0IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IG5hdGl2ZWludCB0IHggPSBTdGRsaWIuUmFuZG9tLlN0YXRlLm5hdGl2ZWludCAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBtYWtlIHNlZWQgPSBMYXp5LmZyb21fdmFsIChTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2Ugc2VlZClcbiAgbGV0IGNvcHkgdCA9IExhenkuZnJvbV92YWwgKFN0ZGxpYi5SYW5kb20uU3RhdGUuY29weSAoTGF6eS5mb3JjZSB0KSlcbiAgbGV0IGNoYXIgdCA9IGludCB0IDI1NiB8PiBDaGFyLnVuc2FmZV9vZl9pbnRcbiAgbGV0IGFzY2lpIHQgPSBpbnQgdCAxMjggfD4gQ2hhci51bnNhZmVfb2ZfaW50XG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gICAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgICBMYXp5LmZyb21fdmFsIChTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuICA7O1xuXG4gIGxldCBhc3NpZ24gPSBSYW5kb21fcmVwci5hc3NpZ25cbiAgbGV0IGZ1bGxfaW5pdCB0IHNlZWQgPSBhc3NpZ24gdCAobWFrZSBzZWVkKVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICBpZiBhbV90ZXN0aW5nXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSBkZWZpbmUgQmFzZSdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlIGFzIGEgY29weSBvZiBPQ2FtbCdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlLlxuICAgICAgICAgVGhpcyBtZWFucyB0aGF0IHByb2dyYW1zIHRoYXQgdXNlIEJhc2UuUmFuZG9tIHdpbGwgc2VlIHRoZSBzYW1lIHNlcXVlbmNlIG9mXG4gICAgICAgICByYW5kb20gYml0cyBhcyBpZiB0aGV5IGhhZCB1c2VkIFN0ZGxpYi5SYW5kb20uIEhvd2V2ZXIsIGJlY2F1c2UgW2dldF9zdGF0ZV0gcmV0dXJuc1xuICAgICAgICAgYSBjb3B5LCBCYXNlLlJhbmRvbSBhbmQgT0NhbWwuUmFuZG9tIGFyZSBub3QgdXNpbmcgdGhlIHNhbWUgc3RhdGUuIElmIGEgcHJvZ3JhbVxuICAgICAgICAgdXNlZCBib3RoLCBlYWNoIG9mIHRoZW0gd291bGQgZ28gdGhyb3VnaCB0aGUgc2FtZSBzZXF1ZW5jZSBvZiByYW5kb20gYml0cy4gVG9cbiAgICAgICAgIGF2b2lkIHRoYXQsIHdlIHJlc2V0IE9DYW1sJ3MgcmFuZG9tIHN0YXRlIHRvIGEgZGlmZmVyZW50IHNlZWQsIGdpdmluZyBpdCBhXG4gICAgICAgICBkaWZmZXJlbnQgc2VxdWVuY2UuICopXG4gICAgICBsZXQgdCA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gICAgICBTdGRsaWIuUmFuZG9tLmluaXQgMTM3O1xuICAgICAgTGF6eS5mcm9tX3ZhbCB0KVxuICAgIGVsc2VcbiAgICAgIGxhenlcbiAgICAgICAgKCogT3V0c2lkZSBvZiB0ZXN0cywgd2UgaW5pdGlhbGl6ZSByYW5kb20gc3RhdGUgbm9uZGV0ZXJtaW5pc3RpY2FsbHkgYW5kIGxhemlseS5cbiAgICAgICAgICAgV2UgZm9yY2UgdGhlIHJhbmRvbSBpbml0aWFsaXphdGlvbiB0byBiZSBsYXp5IHNvIHRoYXQgd2UgZG8gbm90IHBheSBhbnkgY29zdFxuICAgICAgICAgICBmb3IgaXQgaW4gcHJvZ3JhbXMgdGhhdCBkbyBub3QgdXNlIHJhbmRvbW5lc3MuICopXG4gICAgICAgIChMYXp5LmZvcmNlIChtYWtlX3NlbGZfaW5pdCAoKSkpXG4gIDs7XG5cbiAgbGV0IGludF9vbl82NGJpdHMgdCBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIFN0ZGxpYi5JbnQ2NC50b19pbnQgKGludDY0IHQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnRfb25fMzJiaXRzIHQgYm91bmQgPVxuICAgICgqIE5vdCBhbHdheXMgdHJ1ZSB3aXRoIHRoZSBKYXZhU2NyaXB0IGJhY2tlbmQuICopXG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIFN0ZGxpYi5JbnQzMi50b19pbnQgKGludDMyIHQgKFN0ZGxpYi5JbnQzMi5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBpbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50NjQgPVxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQ2NCBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPlxuICAgICAgbG9neG9yXG4gICAgICAgIChiaXRzIHN0YXRlKVxuICAgICAgICAobG9neG9yIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMCkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDYwKSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQzMiA9XG4gICAgbGV0IG9wZW4gU3RkbGliLkludDMyIGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+IGxvZ3hvciAoYml0cyBzdGF0ZSkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMgc3RhdGUgPSBTdGRsaWIuSW50NjQudG9faW50IChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKVxuICBsZXQgZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzIHN0YXRlID0gU3RkbGliLkludDMyLnRvX2ludCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHMgc3RhdGUgPVxuICAgIFN0ZGxpYi5JbnQ2NC50b19uYXRpdmVpbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyBzdGF0ZSA9XG4gICAgU3RkbGliLk5hdGl2ZWludC5vZl9pbnQzMiAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9uYXRpdmVpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCByYWlzZV9jcm9zc2VkX2JvdW5kcyBuYW1lIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kIHN0cmluZ19vZl9ib3VuZCA9XG4gICAgUHJpbnRmLmZhaWx3aXRoZlxuICAgICAgXCJSYW5kb20uJXM6IGNyb3NzZWQgYm91bmRzIFslcyA+ICVzXVwiXG4gICAgICBuYW1lXG4gICAgICAoc3RyaW5nX29mX2JvdW5kIGxvd2VyX2JvdW5kKVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCB1cHBlcl9ib3VuZClcbiAgICAgICgpXG4gIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG4gIDs7XG5cbiAgbGV0IGludF9pbmNsID1cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImludFwiIGxvIGhpIEludC50b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IGhpIC0gbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBJbnQubWF4X3ZhbHVlXG4gICAgICB0aGVuIGxvICsgKGZ1bGxfcmFuZ2VfaW50IHN0YXRlIGxhbmQgSW50Lm1heF92YWx1ZSlcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwXG4gICAgICB0aGVuIGxvICsgaW50IHN0YXRlIChJbnQuc3VjYyBkaWZmKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQzMl9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDMyIHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQzMiBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50MzJcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMGxcbiAgICAgIHRoZW4gYWRkIGxvIChpbnQzMiBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgbmF0aXZlaW50X2luY2wgPVxuICAgIGxldCBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX25hdGl2ZWludCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBTdGRsaWIuTmF0aXZlaW50IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJuYXRpdmVpbnRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBuXG4gICAgICB0aGVuIGFkZCBsbyAobmF0aXZlaW50IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQ2NF9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDY0IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQ2NCBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50NjRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMExcbiAgICAgIHRoZW4gYWRkIGxvIChpbnQ2NCBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICAoKiBSZXR1cm4gYSB1bmlmb3JtbHkgcmFuZG9tIGZsb2F0IGluIFswLCAxKS4gKilcbiAgbGV0IHJlYyByYXdmbG9hdCBzdGF0ZSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHNjYWxlID0gMHgxcC0zMCBpblxuICAgICgqIDJeLTMwICopXG4gICAgbGV0IHIxID0gU3RkbGliLmZsb2F0X29mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBsZXQgcjIgPSBTdGRsaWIuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByZXN1bHQgPSAoKHIxICouIHNjYWxlKSArLiByMikgKi4gc2NhbGUgaW5cbiAgICAoKiBXaXRoIHZlcnkgc21hbGwgcHJvYmFiaWxpdHksIHJlc3VsdCBjYW4gcm91bmQgdXAgdG8gMS4wLCBzbyBpbiB0aGF0IGNhc2UsIHdlIGp1c3RcbiAgICAgICB0cnkgYWdhaW4uICopXG4gICAgaWYgcmVzdWx0IDwgMS4wIHRoZW4gcmVzdWx0IGVsc2UgcmF3ZmxvYXQgc3RhdGVcbiAgOztcblxuICBsZXQgZmxvYXQgc3RhdGUgaGkgPSByYXdmbG9hdCBzdGF0ZSAqLiBoaVxuXG4gIGxldCBmbG9hdF9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiZmxvYXRcIiBsbyBoaSBTdGRsaWIuc3RyaW5nX29mX2Zsb2F0O1xuICAgIGxvICsuIGZsb2F0IHN0YXRlIChoaSAtLiBsbylcbiAgOztcbmVuZFxuXG5sZXQgZGVmYXVsdCA9IFJhbmRvbV9yZXByLm1ha2VfZGVmYXVsdCBTdGF0ZS5kZWZhdWx0XG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGludCB4ID0gU3RhdGUuaW50IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludDMyIHggPSBTdGF0ZS5pbnQzMiAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBuYXRpdmVpbnQgeCA9IFN0YXRlLm5hdGl2ZWludCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnQ2NCB4ID0gU3RhdGUuaW50NjQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgZmxvYXQgeCA9IFN0YXRlLmZsb2F0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludF9pbmNsIHggeSA9IFN0YXRlLmludF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgaW50MzJfaW5jbCB4IHkgPSBTdGF0ZS5pbnQzMl9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgbmF0aXZlaW50X2luY2wgeCB5ID0gU3RhdGUubmF0aXZlaW50X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBpbnQ2NF9pbmNsIHggeSA9IFN0YXRlLmludDY0X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBmbG9hdF9yYW5nZSB4IHkgPSBTdGF0ZS5mbG9hdF9yYW5nZSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBjaGFyICgpID0gU3RhdGUuY2hhciAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgYXNjaWkgKCkgPSBTdGF0ZS5hc2NpaSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgP2FsbG93X2luX3Rlc3RzICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NzQ3OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwyIiwiZiIsImEwIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfUmFuZG9tIiwiQmFzZV9JbXBvcnQiLCJCYXNlX09yZGVyZWRfY29sbGVjdGlvbl9jb21tb24iLCJCYXNlX0FycmF5MCIsImludmFsaWRfYXJnZiIsIkFycmF5IiwibWF4X2xlbmd0aCIsImNyZWF0ZSIsImNyZWF0ZV9sb2NhbCIsImNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIiwiYXBwZW5kIiwiYmxpdCIsImNvbmNhdCIsImNvcHkiLCJmaWxsIiwiaW5pdCIsIm1ha2VfbWF0cml4Iiwib2ZfbGlzdCIsInN1YiIsInRvX2xpc3QiLCJmb2xkIiwiZm9sZF9yaWdodCIsIml0ZXIiLCJpdGVyaSIsIm1hcCIsIm1hcGkiLCJzdGFibGVfc29ydCIsInN3YXAiLCJwZXJtdXRlIiwib3B0IiwibGVuIiwidCIsInJhbmRvbV9zdGF0ZSIsInBvcyIsInRvdGFsX2xlbmd0aCIsImwiLCJudW1fc3dhcHMiLCJpIiwidGhpc19pIiwicmFuZG9tX2kiLCJCYXNlX0FycmF5X3Blcm11dGUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9hcnJheV9wZXJtdXRlLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSCxHQUFBQyxJQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxZQUFBQyxRQUFBLEtBQUFDLEtBQUFDLEtBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLGVDTVk7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsZUFHVjtBQUFBLElBQ0E7QUFBQSxTQUFBQyxJQUFBLFFBQUFMLFFBRWM7QUFBQTtBQUFBLFNBQUFBLFFBQ0Y7QUFBQSxJQUVaO0FBQUEsUUFBQU0sWUFDZ0I7QUFBQSxJQUNoQjtBQUFBLFNBQUFDLElBQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUMsU0FDZTtBQUFBLGFBRXNDO0FBQUEsYUFBOUI7QUFBQSxPQUFBQyxXQUFOO0FBQUEsTUFDZjtBQUFBLGdCQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFKeEI7QUFBQSxHQUtJO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRHRCTiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqIEFuIGludGVybmFsLW9ubHkgbW9kdWxlIGZhY3RvcmVkIG91dCBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gY29yZV9hcnJheVxuICAgIGFuZCBjb3JlX2xpc3QuICBDb250YWlucyBjb2RlIGZvciBwZXJtdXRpbmcgYW4gYXJyYXkuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBcnJheTBcblxubGV0IHBlcm11dGUgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgPyhwb3MgPSAwKSA/bGVuIHQgPVxuICAoKiBDb3BpZWQgZnJvbSBbT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjBdIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSB3aGVuIGNvbXBpbGluZ1xuICAgICB3aXRob3V0IGZsYW1iZGEuICopXG4gIGxldCB0b3RhbF9sZW5ndGggPSBsZW5ndGggdCBpblxuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgU29tZSBsIC0+IGxcbiAgICB8IE5vbmUgLT4gdG90YWxfbGVuZ3RoIC0gcG9zXG4gIGluXG4gIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoO1xuICBsZXQgbnVtX3N3YXBzID0gbGVuIC0gMSBpblxuICBmb3IgaSA9IG51bV9zd2FwcyBkb3dudG8gMSBkb1xuICAgIGxldCB0aGlzX2kgPSBwb3MgKyBpIGluXG4gICAgKCogW3JhbmRvbV9pXSBpcyBkcmF3biBmcm9tIFtwb3MsdGhpc19pXSAqKVxuICAgIGxldCByYW5kb21faSA9IHBvcyArIFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChpICsgMSkgaW5cbiAgICBzd2FwIHQgdGhpc19pIHJhbmRvbV9pXG4gIGRvbmVcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NzU4MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0VxdWFsIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxhQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NzU5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRXF1YWwiLCJjc3RfR3JlYXRlciIsImNzdF9MZXNzIiwiY3N0X2VxdWFsIiwiY3N0X2dyZWF0ZXIiLCJjc3RfbGVzcyIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJhbGwiLCJlcnJvcl9zb3VyY2VfMDA1IiwidF9zZXhwX2dyYW1tYXIiLCJTZXhwbGliMF9TZXhwX2NvbnZfZXJyb3IiLCJCYXNlX0hhc2giLCJjb21wYXJlIiwiaGFzaF9mb2xkX3QiLCJoc3YiLCJhcmciLCJoYXNoIiwidF9vZl9zZXhwIiwic2V4cF8wMDYiLCJzZXhwX29mX3QiLCJwYXJhbSIsImVxdWFsIiwiYSIsImIiLCJFeHBvcnQiLCJvZl9pbnQiLCJuIiwidG9faW50IiwiQmFzZV9PcmRlcmluZyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL29yZGVyaW5nLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxVQ2dDRztBQUFBO0FBQUE7QUFBQSxZQUFBQyxZQUFBQyxLQUFBQztBQUFBQSxJQXBCRTtBQUFBO0FBQUEsT0FDVSx1Q0FFdUM7QUFBQTtBQUFBLE9BRHRDLHVDQUNzQztBQUFBLGVBQXBDLHVDQUFvQztBQUFBO0FBQUE7QUFBQSxZQUFBQyxLQUFBRDtBQUFBQSxRQUFBRCxNQU9yQyx1Q0FDVjtBQUFBLElBQW1CLG9DQUVUO0FBQUE7QUFBQSxZQUFBRyxVQUFBQztBQUFBQTtBQUFBQTtBQUFBQSxLQU9kO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUMwQztBQUFBO0FBQUEsT0FFTTtBQUFBO0FBQUEsTUFESjtBQUFBO0FBQUEsZUFGNUM7QUFBQTtBQUFBLE1BYUU7QUFBQSx1RUFDb0Y7QUFBQSxlQWR0RjtBQUFBO0FBQUEsTUFXRTtBQUFBLHVFQUdvRjtBQUFBLGVBZHRGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FLRTtBQUFBLHdFQVNvRjtBQUFBO0FBQUEsTUFMcEY7QUFBQSx1RUFLb0Y7QUFBQTtBQUFBLEtBUHBGO0FBQUEsc0VBT29GO0FBQUE7QUFBQSxJQUF0RSwwRUFBc0U7QUFBQTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBLElBS3RGLHNCQUNXLG1CQUNDLG9CQUNFO0FBQUE7QUFBQSxHQUE0QjtBQUFBLFlBQUFDLE1BQUFDLEdBQUFDLEdBbUI3QiwyQ0FBVyxDQUFJO0FBQUEsT0FBQUMsU0F6QzVCO0FBQUEsWUFBQUMsT0FBQUMsR0FrRFksbUNBQXdEO0FBQUEsWUFBQUMsT0FBQVA7QUFBQUEsSUFFMUQsc0JBQ0Qsa0JBQ0Msa0JBQ0U7QUFBQTtBQUFBLEdBQUM7QUFBQTtBQUFBLElBQUFRO0FBQUFBLE1BdkRiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRGhDSCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTGVzc1xuICB8IEVxdWFsXG4gIHwgR3JlYXRlclxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA9IChTdGRsaWIuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbmxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgTGVzcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBFcXVhbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBHcmVhdGVyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBMZXNzOyBFcXVhbDsgR3JlYXRlciBdIDogdCBsaXN0KVxuXG5sZXQgdF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcIm9yZGVyaW5nLm1sLnRcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlc3NcIiB8IFwiTGVzc1wiKSAtPiBMZXNzXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSAtPiBFcXVhbFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIC0+IEdyZWF0ZXJcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IHNleHBfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgICAgICAgICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG47O1xuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBMZXNzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkxlc3NcIlxuICAgIHwgRXF1YWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXF1YWxcIlxuICAgIHwgR3JlYXRlciAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJHcmVhdGVyXCJcbiAgICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTGVzc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiRXF1YWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkdyZWF0ZXJcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgX29yZGVyaW5nID0gdCA9XG4gICAgfCBMZXNzXG4gICAgfCBFcXVhbFxuICAgIHwgR3JlYXRlclxuZW5kXG5cbmxldCBvZl9pbnQgbiA9IGlmIG4gPCAwIHRoZW4gTGVzcyBlbHNlIGlmIG4gPSAwIHRoZW4gRXF1YWwgZWxzZSBHcmVhdGVyXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IExlc3MgLT4gLTFcbiAgfCBFcXVhbCAtPiAwXG4gIHwgR3JlYXRlciAtPiAxXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjc3MjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1N5czAiLCJiYWNrZW5kX3R5cGUiLCJpbnRlcmFjdGl2ZSIsIm9zX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJ3b3JkX3NpemVfaW5fYml0cyIsImludF9zaXplX2luX2JpdHMiLCJiaWdfZW5kaWFuIiwibWF4X3N0cmluZ19sZW5ndGgiLCJtYXhfYXJyYXlfbGVuZ3RoIiwicnVudGltZV92YXJpYW50IiwicnVudGltZV9wYXJhbWV0ZXJzIiwiYXJndiIsImdldF9hcmd2Iiwib2NhbWxfdmVyc2lvbiIsImVuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwicnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiZ2V0ZW52X2V4biIsImdldGVudiIsIkJhc2VfU3lzIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo3Nzg0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9sZW5ndGhfbWlzbWF0Y2hfaW4iLCJjc3Rfc3JjX2xpc3RfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiY2FtbF9jYWxsNyIsImE1IiwiYTYiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiZXJyb3Jfc291cmNlXzAzMiIsIkJhc2VfSW1wb3J0IiwiQmFzZV9Db250YWluZXIiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfUmFuZG9tIiwiQmFzZV9BcnJheTAiLCJCYXNlX0FycmF5X3Blcm11dGUiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJTZXhwbGliMF9TZXhwX2NvbnZfZXJyb3IiLCJCYXNlX1Jlc3VsdCIsIkJhc2VfT3JkZXJpbmciLCJCYXNlX0xpc3QxIiwiQmFzZV9QcmludGYiLCJCYXNlX1N5cyIsIkJhc2VfQXBwbGljYXRpdmUiLCJCYXNlX01vbmFkIiwiU2V4cGxpYjBfU2V4cF9jb252IiwiaGRfZXhuIiwibGVuZ3RoIiwicmV2X2FwcGVuZCIsInRsX2V4biIsImV4aXN0cyIsImV4aXN0czJfb2siLCJmb2xkX2xlZnQiLCJmb2xkMl9vayIsImZvcl9hbGwiLCJmb3JfYWxsMl9vayIsIml0ZXIiLCJpdGVyMl9vayIsIm5vbnRhaWxfbWFwIiwicmV2X21hcCIsInJldl9tYXAyX29rIiwic29ydCIsInN0YWJsZV9zb3J0IiwicmV2IiwiZm9sZF9yaWdodCIsImZvbGRfcmlnaHQyX29rIiwiaXNfZW1wdHkiLCJwYXJ0aXRpb25fbWFwIiwiaW52YWxpZF9hcmdmIiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsImNvbXBhcmUiLCJjbXBfYSIsImFfMDEwIiwiYl8wMTEiLCJhXzAxMiIsImJfMDEzIiwib2ZfYV8wMTQiLCJwYXJhbSIsImFyZzBfMDE1IiwicmVzMF8wMTYiLCJPcl91bmVxdWFsX2xlbmd0aHMiLCJjc3RfTGlzdF9yYW5nZV9zdHJpZGVfZnVuY3Rpb24iLCJjc3RfTGlzdF9yYW5nZV9zdHJpZGVfbXVzdF9iZV8iLCJjc3RfaXRlcjJfZXhuIiwiY3N0X3Jldl9tYXAyX2V4biIsImNzdF9mb2xkMl9leG4iLCJjc3RfZm9sZF9yaWdodDJfZXhuIiwiY3N0X2Zvcl9hbGwyX2V4biIsImNzdF9leGlzdHMyX2V4biIsImludmFyaWFudCIsInQiLCJvZl9saXN0IiwicmFuZ2UiLCJzdHJpZGUiLCJvcHQiLCJzdGFydF9pIiwic3RvcF9pIiwic3RhcnQiLCJzdG9wIiwibmV4dF9pIiwib3JkZXIiLCJ4IiwieSIsInJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbSIsImluaXRpYWxfc3RyaWRlX29yZGVyIiwiaSIsImFjY3VtIiwiaV90b19zdG9wX29yZGVyIiwiaGQiLCJ0bCIsIm50aCIsIm4iLCJhIiwibnRoX2V4biIsIm1hdGNoIiwidW5vcmRlcmVkX2FwcGVuZCIsImwxIiwibDIiLCJsIiwib2ZfbGlzdHMiLCJiIiwic2hhcmVkX2xlbmd0aCIsImNoZWNrX2xlbmd0aDJfZXhuIiwibmFtZSIsInRhaWxfb2ZfYiIsInRhaWxfb2ZfYSIsImNoZWNrX2xlbmd0aDIiLCJsMyIsImMiLCJjaGVja19sZW5ndGgzX2V4biIsInRhaWxfb2ZfYyIsIm4xIiwibjIiLCJuMyIsImNoZWNrX2xlbmd0aDMiLCJpdGVyMiIsIml0ZXIyX2V4biIsInJldl9tYXAyIiwicmV2X21hcDJfZXhuIiwiZm9sZDIiLCJpbml0IiwiZm9sZDJfZXhuIiwiZm9sZF9yaWdodDIiLCJmb2xkX3JpZ2h0Ml9leG4iLCJmb3JfYWxsMiIsImZvcl9hbGwyX2V4biIsImV4aXN0czIiLCJleGlzdHMyX2V4biIsIm1lbSIsImVxdWFsIiwiYnMiLCJyZXZfZmlsdGVyIiwiYWNjdSIsImZpbHRlciIsImZpbmRfbWFwIiwiciIsIm5vdF9mb3VuZCIsImZpbmRfbWFwX2V4biIsImZpbmQiLCJmaW5kX2V4biIsImZpbmRpIiwiZmluZGlfZXhuIiwiZmluZF9tYXBpIiwicmVzdWx0IiwiZmluZF9tYXBpX2V4biIsImZvcl9hbGxpIiwiZXhpc3RzaSIsIm9mX2FycmF5IiwidG9fYXJyYXkiLCJ0b19saXN0IiwiY3N0X0xpc3RfbGFzdCIsImNzdF9MaXN0X3JhbmRvbV9lbGVtZW50X2V4bl9lbSIsImNzdF9MaXN0X2Ryb3BfbGFzdF9leG5fZW1wdHlfbCIsImNzdF9MaXN0X3N1YiIsImNzdF9MaXN0X3JlZHVjZV9iYWxhbmNlZF9leG4iLCJjc3RfTGlzdF9yZWR1Y2VfZXhuIiwiY3N0X21hcDNfZXhuIiwiY3N0X3Jldl9tYXAzX2V4biIsImNzdF9tYXAyX2V4biIsImNzdF9CYXNlX0xpc3RfVHJhbnNwb3NlX2dvdF9saSIsIm1heF9ub25fdGFpbGNhbGwiLCJjb3VudF9hcHBlbmQiLCJjb3VudCIsIngxIiwieDIiLCJ4MyIsIng0IiwieDUiLCJhcHBlbmQiLCJjb3VudF9tYXAiLCJjdHIiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwieHMiLCJ4OCIsIng3IiwieDYiLCJ4MCIsInkwIiwieTEiLCJ5MiIsInkzIiwieTQiLCJ5NSIsInk2IiwieTciLCJ5OCIsInlzIiwicmVzIiwibWFwIiwiZm9sZGluZ19tYXAiLCJhY2MiLCJuZXdfYWNjIiwiZm9sZF9tYXAiLCJzeW1ib2xfbWFwIiwibWFwMl9vayIsIm1hcDIiLCJtYXAyX2V4biIsInJldl9tYXAzX29rIiwiYWMiLCJyZXZfbWFwMyIsInJldl9tYXAzX2V4biIsIm1hcDNfb2siLCJtYXAzIiwibWFwM19leG4iLCJyZXZfbWFwX2FwcGVuZCIsImgiLCJ1bnppcCIsImxpc3QiLCJ1bnppcDMiLCJ6IiwiemlwX2V4biIsInppcCIsInJldl9tYXBpIiwibWFwaSIsImZvbGRpbmdfbWFwaSIsImZvbGRfbWFwaSIsIml0ZXJpIiwiZm9sZGkiLCJ2IiwiZmlsdGVyaSIsInBvcyIsInJlZHVjZSIsInJlZHVjZV9leG4iLCJyZWR1Y2VfYmFsYW5jZWQiLCJzdGVwX2FjY3VtIiwibnVtIiwicmVkdWNlX2JhbGFuY2VkX2V4biIsImdyb3VwaSIsImJyZWFrIiwiZ3JvdXBzIiwiY3VycmVudF9ncm91cCIsImdyb3VwIiwic29ydF9hbmRfZ3JvdXAiLCJjb25jYXRfbWFwIiwiY29uY2F0X21hcGkiLCJjb250IiwibWVyZ2UiLCJ0MiIsImgyIiwidDEiLCJoMSIsInJldHVybiIsInN5bWJvbF9iaW5kIiwiQXBwbGljYXRpdmUiLCJNb25hZCIsImFsbCIsImFsbF91bml0IiwiaWdub3JlX20iLCJqb2luIiwiYXBwbHkiLCJib3RoIiwic3ltYm9sIiwiT3Blbl9vbl9yaHMiLCJMZXRfc3ludGF4IiwiTW9uYWRfaW5maXgiLCJsYXN0X2V4biIsImxhc3QiLCJpc19wcmVmaXgiLCJwcmVmaXgiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSIsInJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIiwid2hpY2hfdG9fa2VlcCIsInRvX2tlZXAiLCJkZWR1cF9hbmRfc29ydCIsInNvcnRlZCIsImZpbmRfYV9kdXAiLCJoZDIiLCJoZDEiLCJjb250YWluc19kdXAiLCJsc3QiLCJmaW5kX2FsbF9kdXBzIiwicHJldiIsImFscmVhZHlfcmVjb3JkZWQiLCJhbGxfZXF1YWwiLCJzdW0iLCJtIiwibWluX2VsdCIsIm1heF9lbHQiLCJjb3VudGkiLCJpZHgiLCJyZXZfZmlsdGVyX21hcCIsImZpbHRlcl9tYXAiLCJyZXZfZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwaSIsImZpbHRlcl9vcHQiLCJwYXJ0aXRpb24zX21hcCIsImZzdCIsInNuZCIsInRyZCIsInBhcnRpdGlvbl90ZiIsInBhcnRpdGlvbl9yZXN1bHQiLCJvZl9hXzAyNCIsIm9mX2JfMDI1IiwieF8wMzMiLCJzZXhwXzAzMSIsImFyZzFfMDI4IiwiYXJnMF8wMjciLCJyZXMwXzAyOSIsInJlczFfMDMwIiwib2ZfYV8wMzQiLCJvZl9iXzAzNSIsInhfMDQwIiwiYXJnMV8wMzciLCJhcmcwXzAzNiIsInJlczBfMDM4IiwicmVzMV8wMzkiLCJiX3NleHBfZ3JhbW1hciIsInBhaXJfb2ZfZ3JvdXAiLCJrIiwiYWxpc3QiLCJrZXkiLCJ2YWx1ZSIsInJlbW92ZSIsImFkZCIsImludmVyc2UiLCJzdWIiLCJsZW4iLCJlbCIsInNwbGl0X24iLCJ0X29yaWciLCJ0YWtlIiwiZHJvcCIsImNodW5rc19vZiIsInN1Ymxpc3QiLCJzcGxpdF93aGlsZSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwiZHJvcF9sYXN0IiwiZHJvcF9sYXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0IiwibGlzdDEiLCJsaXN0MiIsImNvbmNhdCIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJyZXN0IiwiaXNfc29ydGVkX3N0cmljdGx5IiwiSW5maXgiLCJwZXJtdXRlIiwicmFuZG9tX3N0YXRlIiwiYXJyIiwicmFuZG9tX2VsZW1lbnRfZXhuIiwicmFuZG9tX2VsZW1lbnQiLCJjbXAiLCJoYXNoX2ZvbGRfdCIsImVxdWFsX2xvY2FsIiwidHJhbnNwb3NlIiwicm93cyIsImNvbHVtbnMiLCJkb19yZXYiLCJjb2x1bW5fYWNjIiwidHJpbW1lZF9yb3dzIiwiZm91bmRfZW1wdHkiLCJ0cmltbWVkIiwiY29sdW1uIiwiVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlIiwiYXJnMF8wNDEiLCJyZXMwXzA0MiIsInRyYW5zcG9zZV9leG4iLCJpbnRlcnNwZXJzZSIsInNlcCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsImZpbmlzaCIsImlzX3N1ZmZpeCIsInN1ZmZpeCIsImVxdWFsX2VsdCIsImxpc3RfbGVuIiwic3VmZml4X2xlbiIsIkJhc2VfTGlzdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2xpc3QubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFWLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDEyQzFCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcblxuXG5pbmNsdWRlIExpc3QxXG5cbigqIFRoaXMgaXRzZWxmIGluY2x1ZGVzIFtMaXN0MF0uICopXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBnbG9iYWxpemUgOiAnYS4gKCgnYVtAb2NhbWwubG9jYWxdKSAtPiAnYSkgLT4gKCdhIHRbQG9jYW1sLmxvY2FsXSkgLT4gJ2EgdCA9XG4gICAgZnVuICh0eXBlIGFfXzAwMV8pXG4gICAgICAgIDogKCgoYV9fMDAxX1tAb2NhbWwubG9jYWxdKSAtPiBhX18wMDFfKSAtPiAoYV9fMDAxXyB0W0BvY2FtbC5sb2NhbF0pIC0+IGFfXzAwMV8gdCkgLT5cbiAgICAgIGdsb2JhbGl6ZV9saXN0XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGxpc3Rfb2Zfc2V4cFxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9saXN0XG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxpc3Rfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBPcl91bmVxdWFsX2xlbmd0aHMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IE9rIG9mICdhXG4gICAgfCBVbmVxdWFsX2xlbmd0aHNcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDEwXyBiX18wMTFfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wMTBfIGJfXzAxMV9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAxMF8sIGJfXzAxMV8gd2l0aFxuICAgICAgfCBPayBfYV9fMDEyXywgT2sgX2JfXzAxM18gLT4gX2NtcF9fYSBfYV9fMDEyXyBfYl9fMDEzX1xuICAgICAgfCBPayBfLCBfIC0+IC0xXG4gICAgICB8IF8sIE9rIF8gLT4gMVxuICAgICAgfCBVbmVxdWFsX2xlbmd0aHMsIFVuZXF1YWxfbGVuZ3RocyAtPiAwKVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biAodHlwZSBhX18wMTdfKSA6ICgoYV9fMDE3XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAxN18gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMTRfIC0+IGZ1bmN0aW9uXG4gICAgICB8IE9rIGFyZzBfXzAxNV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAxNl8gPSBfb2ZfYV9fMDE0XyBhcmcwX18wMTVfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IHJlczBfXzAxNl8gXVxuICAgICAgfCBVbmVxdWFsX2xlbmd0aHMgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbF9sZW5ndGhzXCJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxubGV0IG9mX2xpc3QgdCA9IHRcblxubGV0IHJhbmdlJyB+Y29tcGFyZSB+c3RyaWRlID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF9pIHN0b3BfaSA9XG4gIGxldCBuZXh0X2kgPSBzdHJpZGUgc3RhcnRfaSBpblxuICBsZXQgb3JkZXIgeCB5ID0gT3JkZXJpbmcub2ZfaW50IChjb21wYXJlIHggeSkgaW5cbiAgbGV0IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKCkgPVxuICAgIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZSc6IHN0cmlkZSBmdW5jdGlvbiBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHZhbHVlXCJcbiAgaW5cbiAgbGV0IGluaXRpYWxfc3RyaWRlX29yZGVyID1cbiAgICBtYXRjaCBvcmRlciBzdGFydF9pIG5leHRfaSB3aXRoXG4gICAgfCBFcXVhbCAtPiByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpXG4gICAgfCBMZXNzIC0+IGBMZXNzXG4gICAgfCBHcmVhdGVyIC0+IGBHcmVhdGVyXG4gIGluXG4gIGxldCByZWMgbG9vcCBpIGFjY3VtID1cbiAgICBsZXQgaV90b19zdG9wX29yZGVyID0gb3JkZXIgaSBzdG9wX2kgaW5cbiAgICBtYXRjaCBpX3RvX3N0b3Bfb3JkZXIsIGluaXRpYWxfc3RyaWRlX29yZGVyIHdpdGhcbiAgICB8IExlc3MsIGBMZXNzIHwgR3JlYXRlciwgYEdyZWF0ZXIgLT5cbiAgICAgICgqIGhhdmVuJ3QgeWV0IHJlYWNoZWQgW3N0b3BfaV0uIENvbnRpbnVlLiAqKVxuICAgICAgbGV0IG5leHRfaSA9IHN0cmlkZSBpIGluXG4gICAgICAobWF0Y2ggb3JkZXIgaSBuZXh0X2ksIGluaXRpYWxfc3RyaWRlX29yZGVyIHdpdGhcbiAgICAgICB8IEVxdWFsLCBfIC0+IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKClcbiAgICAgICB8IExlc3MsIGBHcmVhdGVyIHwgR3JlYXRlciwgYExlc3MgLT5cbiAgICAgICAgIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZSc6IHN0cmlkZSBmdW5jdGlvbiBjYW5ub3QgY2hhbmdlIGRpcmVjdGlvblwiXG4gICAgICAgfCBMZXNzLCBgTGVzcyB8IEdyZWF0ZXIsIGBHcmVhdGVyIC0+IGxvb3AgbmV4dF9pIChpIDo6IGFjY3VtKSlcbiAgICB8IExlc3MsIGBHcmVhdGVyIHwgR3JlYXRlciwgYExlc3MgLT5cbiAgICAgICgqIHN0ZXBwZWQgcGFzdCBbc3RvcF9pXS4gIEZpbmlzaGVkLiAqKVxuICAgICAgYWNjdW1cbiAgICB8IEVxdWFsLCBfIC0+XG4gICAgICAoKiByZWFjaGVkIFtzdG9wX2ldLiAgRmluaXNoZWQuICopXG4gICAgICAobWF0Y2ggc3RvcCB3aXRoXG4gICAgICAgfCBgaW5jbHVzaXZlIC0+IGkgOjogYWNjdW1cbiAgICAgICB8IGBleGNsdXNpdmUgLT4gYWNjdW0pXG4gIGluXG4gIGxldCBzdGFydF9pID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIC0+IHN0YXJ0X2lcbiAgICB8IGBleGNsdXNpdmUgLT4gbmV4dF9pXG4gIGluXG4gIHJldiAobG9vcCBzdGFydF9pIFtdKVxuOztcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X2kgc3RvcF9pID1cbiAgaWYgc3RyaWRlID0gMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZTogc3RyaWRlIG11c3QgYmUgbm9uLXplcm9cIjtcbiAgcmFuZ2UnIH5jb21wYXJlIH5zdHJpZGU6KGZ1biB4IC0+IHggKyBzdHJpZGUpIH5zdGFydCB+c3RvcCBzdGFydF9pIHN0b3BfaVxuOztcblxubGV0IGhkIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBfIC0+IFNvbWUgeFxuOztcblxubGV0IHRsIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyA6OiB0JyAtPiBTb21lIHQnXG47O1xuXG5sZXQgbnRoIHQgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVjIG50aF9hdXggdCBuID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IGEgOjogdCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggdCAobiAtIDEpXG4gICAgaW5cbiAgICBudGhfYXV4IHQgbilcbjs7XG5cbmxldCBudGhfZXhuIHQgbiA9XG4gIG1hdGNoIG50aCB0IG4gd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiTGlzdC5udGhfZXhuICVkIGNhbGxlZCBvbiBsaXN0IG9mIGxlbmd0aCAlZFwiIG4gKGxlbmd0aCB0KSAoKVxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgdW5vcmRlcmVkX2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwgfCBsLCBbXSAtPiBsXG4gIHwgXyAtPiByZXZfYXBwZW5kIGwxIGwyXG47O1xuXG5tb2R1bGUgQ2hlY2tfbGVuZ3RoMiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgU2FtZV9sZW5ndGggb2YgaW50XG4gICAgfCBVbmVxdWFsX2xlbmd0aHMgb2ZcbiAgICAgICAgeyBzaGFyZWRfbGVuZ3RoIDogaW50XG4gICAgICAgIDsgdGFpbF9vZl9hIDogJ2EgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYiA6ICdiIGxpc3RcbiAgICAgICAgfVxuXG4gICgqIEluIHRoZSBbVW5lcXVhbF9sZW5ndGhzXSBjYXNlLCBhdCBsZWFzdCBvbmUgb2YgdGhlIHRhaWxzIHdpbGwgYmUgbm9uLWVtcHR5LiAqKVxuICBsZXQgb2ZfbGlzdHMgbDEgbDIgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgc2hhcmVkX2xlbmd0aCA9XG4gICAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICAgIHwgW10sIFtdIC0+IFNhbWVfbGVuZ3RoIHNoYXJlZF9sZW5ndGhcbiAgICAgIHwgXyA6OiBhLCBfIDo6IGIgLT4gbG9vcCBhIGIgKHNoYXJlZF9sZW5ndGggKyAxKVxuICAgICAgfCBbXSwgXyB8IF8sIFtdIC0+IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYSA9IGE7IHRhaWxfb2ZfYiA9IGIgfVxuICAgIGluXG4gICAgbG9vcCBsMSBsMiAwXG4gIDs7XG5lbmRcblxubGV0IGNoZWNrX2xlbmd0aDJfZXhuIG5hbWUgbDEgbDIgPVxuICBtYXRjaCBDaGVja19sZW5ndGgyLm9mX2xpc3RzIGwxIGwyIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+ICgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hOyB0YWlsX29mX2IgfSAtPlxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkXCJcbiAgICAgIG5hbWVcbiAgICAgIChzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYSlcbiAgICAgIChzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYilcbiAgICAgICgpXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDIub2ZfbGlzdHMgbDEgbDIgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gT3JfdW5lcXVhbF9sZW5ndGhzLk9rIChmIGwxIGwyKVxuICB8IFVuZXF1YWxfbGVuZ3RocyBfIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubW9kdWxlIENoZWNrX2xlbmd0aDMgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9XG4gICAgfCBTYW1lX2xlbmd0aCBvZiBpbnRcbiAgICB8IFVuZXF1YWxfbGVuZ3RocyBvZlxuICAgICAgICB7IHNoYXJlZF9sZW5ndGggOiBpbnRcbiAgICAgICAgOyB0YWlsX29mX2EgOiAnYSBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9iIDogJ2IgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYyA6ICdjIGxpc3RcbiAgICAgICAgfVxuXG4gICgqIEluIHRoZSBbVW5lcXVhbF9sZW5ndGhzXSBjYXNlLCBhdCBsZWFzdCBvbmUgb2YgdGhlIHRhaWxzIHdpbGwgYmUgbm9uLWVtcHR5LiAqKVxuICBsZXQgb2ZfbGlzdHMgbDEgbDIgbDMgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgYyBzaGFyZWRfbGVuZ3RoID1cbiAgICAgIG1hdGNoIGEsIGIsIGMgd2l0aFxuICAgICAgfCBbXSwgW10sIFtdIC0+IFNhbWVfbGVuZ3RoIHNoYXJlZF9sZW5ndGhcbiAgICAgIHwgXyA6OiBhLCBfIDo6IGIsIF8gOjogYyAtPiBsb29wIGEgYiBjIChzaGFyZWRfbGVuZ3RoICsgMSlcbiAgICAgIHwgW10sIF8sIF8gfCBfLCBbXSwgXyB8IF8sIF8sIFtdIC0+XG4gICAgICAgIFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYSA9IGE7IHRhaWxfb2ZfYiA9IGI7IHRhaWxfb2ZfYyA9IGMgfVxuICAgIGluXG4gICAgbG9vcCBsMSBsMiBsMyAwXG4gIDs7XG5lbmRcblxubGV0IGNoZWNrX2xlbmd0aDNfZXhuIG5hbWUgbDEgbDIgbDMgPVxuICBtYXRjaCBDaGVja19sZW5ndGgzLm9mX2xpc3RzIGwxIGwyIGwzIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+ICgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hOyB0YWlsX29mX2I7IHRhaWxfb2ZfYyB9IC0+XG4gICAgbGV0IG4xID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2EgaW5cbiAgICBsZXQgbjIgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYiBpblxuICAgIGxldCBuMyA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9jIGluXG4gICAgaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZCB8fCAlZCA8PiAlZFwiIG5hbWUgbjEgbjIgbjIgbjMgKClcbjs7XG5cbmxldCBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMy5vZl9saXN0cyBsMSBsMiBsMyB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiBPcl91bmVxdWFsX2xlbmd0aHMuT2sgKGYgbDEgbDIgbDMpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIF8gLT4gVW5lcXVhbF9sZW5ndGhzXG47O1xuXG5sZXQgaXRlcjIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihpdGVyMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgaXRlcjJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJpdGVyMl9leG5cIiBsMSBsMjtcbiAgaXRlcjJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KHJldl9tYXAyX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCByZXZfbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcInJldl9tYXAyX2V4blwiIGwxIGwyO1xuICByZXZfbWFwMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IGZvbGQyIGwxIGwyIH5pbml0IH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9sZDJfb2sgfmluaXQgfmYpIFtAbm9udGFpbF1cblxubGV0IGZvbGQyX2V4biBsMSBsMiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZm9sZDJfZXhuXCIgbDEgbDI7XG4gIGZvbGQyX29rIGwxIGwyIH5pbml0IH5mXG47O1xuXG5sZXQgZm9sZF9yaWdodDIgbDEgbDIgfmYgfmluaXQgPVxuICBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihmb2xkX3JpZ2h0Ml9vayB+ZiB+aW5pdCkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfcmlnaHQyX2V4biBsMSBsMiB+ZiB+aW5pdCA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZm9sZF9yaWdodDJfZXhuXCIgbDEgbDI7XG4gIGZvbGRfcmlnaHQyX29rIGwxIGwyIH5mIH5pbml0XG47O1xuXG5sZXQgZm9yX2FsbDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihmb3JfYWxsMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgZm9yX2FsbDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb3JfYWxsMl9leG5cIiBsMSBsMjtcbiAgZm9yX2FsbDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBleGlzdHMyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZXhpc3RzMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgZXhpc3RzMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImV4aXN0czJfZXhuXCIgbDEgbDI7XG4gIGV4aXN0czJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBlcXVhbCBhID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBiIDo6IGJzIC0+IGVxdWFsIGEgYiB8fCBsb29wIGVxdWFsIGEgYnNcbiAgaW5cbiAgbG9vcCBlcXVhbCBhIHRcbjs7XG5cbigqIFRoaXMgaXMgYSBjb3B5IG9mIHRoZSBjb2RlIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIHdpdGggYW4gZXh0cmEgZXRhLWV4cGFuc2lvbiB0b1xuICAgYXZvaWQgY3JlYXRpbmcgcGFydGlhbCBjbG9zdXJlcyAoc2hvd2VkIHVwIGZvciBbZmlsdGVyXSkgaW4gcHJvZmlsaW5nKS4gKilcbmxldCByZXZfZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVjIGZpbmQgfmYgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCB4IDo6IGwgLT4gaWYgZiB4IHRoZW4gZmluZCB+ZiAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCB+ZiBhY2N1IGxcbiAgaW5cbiAgZmluZCB+ZiBbXSB0XG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSByZXYgKHJldl9maWx0ZXIgdCB+ZilcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAobWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBsXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICBpblxuICBsb29wIHQgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRfbWFwX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9tYXBfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwX2V4blxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgbG9vcCBsXG4gIGluXG4gIGxvb3AgdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJlYyBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgeCA6OiB0IC0+IGlmIGYgeCB0aGVuIHggZWxzZSBmaW5kX2V4biB0IH5mXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiBpIHggdGhlbiBTb21lIChpLCB4KSBlbHNlIGxvb3AgKGkgKyAxKSBsXG4gIGluXG4gIGxvb3AgMCB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgZmluZGlfZXhuXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBsKVxuICBpblxuICBsb29wIDAgdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9tYXBpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9tYXBpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwaV9leG5cbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiB0cnVlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgJiYgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgfHwgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0IFtAbm9udGFpbF1cbjs7XG5cbigqKiBGb3IgdGhlIGNvbnRhaW5lciBpbnRlcmZhY2UuICopXG5sZXQgZm9sZF9sZWZ0ID0gZm9sZFxuXG5sZXQgb2ZfYXJyYXkgPSBBcnJheS50b19saXN0XG5sZXQgdG9fYXJyYXkgPSBBcnJheS5vZl9saXN0XG5sZXQgdG9fbGlzdCB0ID0gdFxuXG5sZXQgbWF4X25vbl90YWlsY2FsbCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMV8wMDBcbiAgKCogV2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQncyBzbWFsbC4gVGhpc1xuICAgICBudW1iZXIgd2FzIHRha2VuIGZyb20gb2NhbWwjc3RkbGliL2xpc3QubWwgd2hpY2ggaXMgYWxzbyBlcXVhbCB0byB0aGUgZGVmYXVsdCBsaW1pdFxuICAgICBvZiByZWN1cnNpdmUgY2FsbCBpbiB0aGUganNfb2Zfb2NhbWwgY29tcGlsZXIgYmVmb3JlIHN3aXRjaGluZyB0byB0cmFtcG9saW5lLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG47O1xuXG4oKiogVGFpbCByZWN1cnNpdmUgdmVyc2lvbnMgb2Ygc3RhbmRhcmQgW0xpc3RdIG1vZHVsZSAqKVxuXG5sZXQgdGFpbF9hcHBlbmQgbDEgbDIgPSByZXZfYXBwZW5kIChyZXYgbDEpIGwyXG5cbigqIFRoZXJlIGFyZSBhIGZldyBvcHRpbWl6ZWQgbGlzdCBvcGVyYXRpb25zIGhlcmUsIGluY2x1ZGluZyBhcHBlbmQgYW5kIG1hcC4gIFRoZXJlIGFyZVxuICAgYmFzaWNhbGx5IHR3byBvcHRpbWl6YXRpb25zIGluIHBsYXk6IGxvb3AgdW5yb2xsaW5nLCBhbmQgZHluYW1pYyBzd2l0Y2hpbmcgYmV0d2VlblxuICAgc3RhY2sgYW5kIGhlYXAgYWxsb2NhdGlvbi5cblxuICAgVGhlIGxvb3AtdW5yb2xsaW5nIGlzIHN0cmFpZ2h0Zm9yd2FyZCwgd2UganVzdCB1bnJvbGwgNSBsZXZlbHMgb2YgdGhlIGxvb3AuICBUaGlzIG1ha2VzXG4gICBlYWNoIGl0ZXJhdGlvbiBmYXN0ZXIsIGFuZCBhbHNvIHJlZHVjZXMgdGhlIG51bWJlciBvZiBzdGFjayBmcmFtZXMgY29uc3VtZWQgcGVyIGxpc3RcbiAgIGVsZW1lbnQuXG5cbiAgIFRoZSBkeW5hbWljIHN3aXRjaGluZyBpcyBkb25lIGJ5IGNvdW50aW5nIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzLCBhbmQgdGhlblxuICAgc3dpdGNoaW5nIHRvIHRoZSBcInNsb3dcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIHdlIGV4Y2VlZCBhIGdpdmVuIGxpbWl0LiAgVGhpcyBtZWFucyB0aGF0XG4gICBzaG9ydCBsaXN0cyB1c2UgdGhlIGZhc3Qgc3RhY2stYWxsb2NhdGlvbiBtZXRob2QsIGFuZCBsb25nIGxpc3RzIHVzZSBhIHNsb3dlciBvbmUgdGhhdFxuICAgZG9lc24ndCByZXF1aXJlIHN0YWNrIHNwYWNlLiAqKVxubGV0IHJlYyBjb3VudF9hcHBlbmQgbDEgbDIgY291bnQgPVxuICBtYXRjaCBsMiB3aXRoXG4gIHwgW10gLT4gbDFcbiAgfCBfIC0+XG4gICAgKG1hdGNoIGwxIHdpdGhcbiAgICAgfCBbXSAtPiBsMlxuICAgICB8IFsgeDEgXSAtPiB4MSA6OiBsMlxuICAgICB8IFsgeDE7IHgyIF0gLT4geDEgOjogeDIgOjogbDJcbiAgICAgfCBbIHgxOyB4MjsgeDMgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiBsMlxuICAgICB8IFsgeDE7IHgyOyB4MzsgeDQgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiBsMlxuICAgICB8IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHRsIC0+XG4gICAgICAgeDFcbiAgICAgICA6OiB4MlxuICAgICAgIDo6IHgzXG4gICAgICAgOjogeDRcbiAgICAgICA6OiB4NVxuICAgICAgIDo6XG4gICAgICAgKGlmIGNvdW50ID4gbWF4X25vbl90YWlsY2FsbFxuICAgICAgICB0aGVuIHRhaWxfYXBwZW5kIHRsIGwyXG4gICAgICAgIGVsc2UgY291bnRfYXBwZW5kIHRsIGwyIChjb3VudCArIDEpKSlcbjs7XG5cbmxldCBhcHBlbmQgbDEgbDIgPSBjb3VudF9hcHBlbmQgbDEgbDIgMFxuXG4oKiBBbiBvcmRpbmFyeSB0YWlsIHJlY3Vyc2l2ZSBtYXAgYnVpbGRzIHVwIGFuIGludGVybWVkaWF0ZSAocmV2ZXJzZWQpIHJlcHJlc2VudGF0aW9uLFxuICAgd2l0aCBvbmUgaGVhcCBhbGxvY2F0ZWQgb2JqZWN0IHBlciBlbGVtZW50LiBUaGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uIGluc3RlYWQgY2h1bmtzXG4gICA5IG9iamVjdHMgaW50byBvbmUgaGVhcCBhbGxvY2F0ZWQgb2JqZWN0LCByZWR1Y2luZyBhbGxvY2F0aW9uIGFuZCBwZXJmb3JtYW5jZSBjb3N0c1xuICAgYWNjb3JkaW5nbHkuIE5vdGUgdGhhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGxpc3QgaXMgZG9uZSBieSB0aGUgc3RkbGliJ3MgbWFwXG4gICBmdW5jdGlvbi4gKilcbmxldCB0YWlsX21hcCB4cyB+ZjooZiBbQGxvY2FsXSkgPVxuICBsZXQgcmVjIHJpc2UgeXMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4geXNcbiAgICB8ICh5MCwgeTEsIHkyLCB5MywgeTQsIHk1LCB5NiwgeTcsIHk4KSA6OiBicyAtPlxuICAgICAgcmlzZSAoeTAgOjogeTEgOjogeTIgOjogeTMgOjogeTQgOjogeTUgOjogeTYgOjogeTcgOjogeTggOjogeXMpIGJzXG4gIGluXG4gIGxldCByZWMgZGl2ZSBicyA9IGZ1bmN0aW9uXG4gICAgfCB4MCA6OiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB4NiA6OiB4NyA6OiB4OCA6OiB4cyAtPlxuICAgICAgbGV0IHkwID0gZiB4MCBpblxuICAgICAgbGV0IHkxID0gZiB4MSBpblxuICAgICAgbGV0IHkyID0gZiB4MiBpblxuICAgICAgbGV0IHkzID0gZiB4MyBpblxuICAgICAgbGV0IHk0ID0gZiB4NCBpblxuICAgICAgbGV0IHk1ID0gZiB4NSBpblxuICAgICAgbGV0IHk2ID0gZiB4NiBpblxuICAgICAgbGV0IHk3ID0gZiB4NyBpblxuICAgICAgbGV0IHk4ID0gZiB4OCBpblxuICAgICAgZGl2ZSAoKHkwLCB5MSwgeTIsIHkzLCB5NCwgeTUsIHk2LCB5NywgeTgpIDo6IGJzKSB4c1xuICAgIHwgeHMgLT4gcmlzZSAobm9udGFpbF9tYXAgfmYgeHMpIGJzXG4gIGluXG4gIGxldCByZXMgPSBkaXZlIFtdIHhzIGluXG4gIHJlc1xuOztcblxubGV0IHJlYyBjb3VudF9tYXAgfmY6KGYgW0Bsb2NhbF0pIGwgY3RyID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBbIHgxIF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgWyBmMSBdXG4gIHwgWyB4MTsgeDIgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgWyBmMTsgZjIgXVxuICB8IFsgeDE7IHgyOyB4MyBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBsZXQgZjMgPSBmIHgzIGluXG4gICAgWyBmMTsgZjI7IGYzIF1cbiAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgWyBmMTsgZjI7IGYzOyBmNCBdXG4gIHwgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogdGwgLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgbGV0IGY1ID0gZiB4NSBpblxuICAgIGYxXG4gICAgOjogZjJcbiAgICA6OiBmM1xuICAgIDo6IGY0XG4gICAgOjogZjVcbiAgICA6OiAoaWYgY3RyID4gbWF4X25vbl90YWlsY2FsbCB0aGVuIHRhaWxfbWFwIH5mIHRsIGVsc2UgY291bnRfbWFwIH5mIHRsIChjdHIgKyAxKSlcbjs7XG5cbmxldCBtYXAgbCB+ZiA9IGNvdW50X21hcCB+ZiBsIDBcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCAoID4+fCApIGwgZiA9IG1hcCBsIH5mXG5sZXQgbWFwMl9vayBsMSBsMiB+ZiA9IHJldiAocmV2X21hcDJfb2sgbDEgbDIgfmYpXG5sZXQgbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KG1hcDJfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IG1hcDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJtYXAyX2V4blwiIGwxIGwyO1xuICBtYXAyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgcmV2X21hcDNfb2sgbDEgbDIgbDMgfmYgPVxuICBsZXQgcmVjIGxvb3AgbDEgbDIgbDMgYWMgPVxuICAgIG1hdGNoIGwxLCBsMiwgbDMgd2l0aFxuICAgIHwgW10sIFtdLCBbXSAtPiBhY1xuICAgIHwgeDEgOjogbDEsIHgyIDo6IGwyLCB4MyA6OiBsMyAtPiBsb29wIGwxIGwyIGwzIChmIHgxIHgyIHgzIDo6IGFjKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgbG9vcCBsMSBsMiBsMyBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmV2X21hcDMgbDEgbDIgbDMgfmYgPSBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mOihyZXZfbWFwM19vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgcmV2X21hcDNfZXhuIGwxIGwyIGwzIH5mID1cbiAgY2hlY2tfbGVuZ3RoM19leG4gXCJyZXZfbWFwM19leG5cIiBsMSBsMiBsMztcbiAgcmV2X21hcDNfb2sgbDEgbDIgbDMgfmZcbjs7XG5cbmxldCBtYXAzX29rIGwxIGwyIGwzIH5mID0gcmV2IChyZXZfbWFwM19vayBsMSBsMiBsMyB+ZilcbmxldCBtYXAzIGwxIGwyIGwzIH5mID0gY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZjoobWFwM19vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgbWFwM19leG4gbDEgbDIgbDMgfmYgPVxuICBjaGVja19sZW5ndGgzX2V4biBcIm1hcDNfZXhuXCIgbDEgbDIgbDM7XG4gIG1hcDNfb2sgbDEgbDIgbDMgfmZcbjs7XG5cbmxldCByZWMgcmV2X21hcF9hcHBlbmQgbDEgbDIgfmYgPVxuICBtYXRjaCBsMSB3aXRoXG4gIHwgW10gLT4gbDJcbiAgfCBoIDo6IHQgLT4gcmV2X21hcF9hcHBlbmQgfmYgdCAoZiBoIDo6IGwyKVxuOztcblxubGV0IHVuemlwIGxpc3QgPVxuICBsZXQgcmVjIGxvb3AgbGlzdCBsMSBsMiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBsMSwgbDJcbiAgICB8ICh4LCB5KSA6OiB0bCAtPiBsb29wIHRsICh4IDo6IGwxKSAoeSA6OiBsMilcbiAgaW5cbiAgbG9vcCAocmV2IGxpc3QpIFtdIFtdXG47O1xuXG5sZXQgdW56aXAzIGxpc3QgPVxuICBsZXQgcmVjIGxvb3AgbGlzdCBsMSBsMiBsMyA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBsMSwgbDIsIGwzXG4gICAgfCAoeCwgeSwgeikgOjogdGwgLT4gbG9vcCB0bCAoeCA6OiBsMSkgKHkgOjogbDIpICh6IDo6IGwzKVxuICBpblxuICBsb29wIChyZXYgbGlzdCkgW10gW10gW11cbjs7XG5cbmxldCB6aXBfZXhuIGwxIGwyID1cbiAgdHJ5IG1hcDJfb2sgfmY6KGZ1biBhIGIgLT4gYSwgYikgbDEgbDIgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluIHppcF9leG46ICVkIDw+ICVkXCIgKGxlbmd0aCBsMSkgKGxlbmd0aCBsMikgKClcbjs7XG5cbmxldCB6aXAgbDEgbDIgPSBtYXAyIH5mOihmdW4gYSBiIC0+IGEsIGIpIGwxIGwyXG5cbigqKiBBZGRpdGlvbmFsIGxpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmV2X21hcGkgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGggOjogdCAtPiBsb29wIChpICsgMSkgKGYgaSBoIDo6IGFjYykgdFxuICBpblxuICBsb29wIDAgW10gbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwaSBsIH5mID0gcmV2IChyZXZfbWFwaSBsIH5mKVxuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGl0ZXJpIGwgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCBsIH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIHNuZCAoZm9sZCB0IH5pbml0OigwLCBpbml0KSB+ZjooZnVuIChpLCBhY2MpIHYgLT4gaSArIDEsIGYgaSBhY2MgdikpXG47O1xuXG5sZXQgZmlsdGVyaSBsIH5mID1cbiAgcmV2IChmb2xkaSBsIH5mOihmdW4gcG9zIGFjYyB4IC0+IGlmIGYgcG9zIHggdGhlbiB4IDo6IGFjYyBlbHNlIGFjYykgfmluaXQ6W10pXG47O1xuXG5sZXQgcmVkdWNlIGwgfmYgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgaGQgOjogdGwgLT4gU29tZSAoZm9sZCB+aW5pdDpoZCB+ZiB0bClcbjs7XG5cbmxldCByZWR1Y2VfZXhuIGwgfmYgPVxuICBtYXRjaCByZWR1Y2UgbCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmVkdWNlX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCByZWR1Y2VfYmFsYW5jZWQgbCB+ZiA9XG4gICgqIENhbGwgdGhlIFwic2l6ZVwiIG9mIGEgdmFsdWUgdGhlIG51bWJlciBvZiBsaXN0IGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNvbWJpbmVkIGludG9cbiAgICAgaXQgdmlhIGNhbGxzIHRvIFtmXS4gIFdlIHByb2NlZWQgYnkgdXNpbmcgW2ZdIHRvIGNvbWJpbmUgZWxlbWVudHMgaW4gdGhlIGFjY3VtdWxhdG9yXG4gICAgIG9mIHRoZSBzYW1lIHNpemUgdW50aWwgd2UgY2FuJ3QgY29tYmluZSBhbnkgbW9yZSwgdGhlbiBnZXR0aW5nIGEgbmV3IGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgaW5wdXQgbGlzdCBhbmQgcmVwZWF0aW5nLlxuXG4gICAgIFdpdGggdGhpcyBzdHJhdGVneSwgaW4gdGhlIGFjY3VtdWxhdG9yOlxuICAgICAtIHdlIG9ubHkgZXZlciBoYXZlIGVsZW1lbnRzIG9mIHNpemVzIGEgcG93ZXIgb2YgdHdvXG4gICAgIC0gd2UgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGVsZW1lbnQgb2YgZWFjaCBzaXplXG4gICAgIC0gdGhlIHN1bSBvZiBhbGwgdGhlIGVsZW1lbnQgc2l6ZXMgaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZFxuXG4gICAgIFRoZXNlIGNvbmRpdGlvbnMgZW5mb3JjZSB0aGF0IGxpc3Qgb2YgZWxlbWVudHMgb2YgZWFjaCBzaXplIGlzIHByZWNpc2VseSB0aGUgYmluYXJ5XG4gICAgIGV4cGFuc2lvbiBvZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnN1bWVkOiBpZiB5b3UndmUgY29uc3VtZWQgMTMgPSAwYjExMDFcbiAgICAgZWxlbWVudHMsIHlvdSBoYXZlIG9uZSBlbGVtZW50IG9mIHNpemUgOCwgb25lIG9mIHNpemUgNCwgYW5kIG9uZSBvZiBzaXplIDEuICBIZW5jZVxuICAgICB3aGVuIGEgbmV3IGVsZW1lbnQgY29tZXMgYWxvbmcsIHRoZSBudW1iZXIgb2YgY29tYmluaW5ncyB5b3UgbmVlZCB0byBkbyBpcyB0aGUgbnVtYmVyXG4gICAgIG9mIHRyYWlsaW5nIDFzIGluIHRoZSBiaW5hcnkgZXhwYW5zaW9uIG9mIFtudW1dLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgICBhbHJlYWR5IGdvbmUgaW50byB0aGUgYWNjdW11bGF0b3IuICBUaGUgYWNjdW11bGF0b3IgaXMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHNpemUsIHNvXG4gICAgIHRoZSBuZXh0IGVsZW1lbnQgdG8gY29tYmluZSB3aXRoIGlzIGFsd2F5cyB0aGUgaGVhZCBvZiB0aGUgbGlzdC4gKilcbiAgbGV0IHJlYyBzdGVwX2FjY3VtIG51bSBhY2MgeCA9XG4gICAgaWYgbnVtIGxhbmQgMSA9IDBcbiAgICB0aGVuIHggOjogYWNjXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhY2Mgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICgqIE5ldyBlbGVtZW50cyBmcm9tIGxhdGVyIGluIHRoZSBpbnB1dCBsaXN0IGdvIG9uIHRoZSBmcm9udCBvZiB0aGUgYWNjdW11bGF0b3IsIHNvXG4gICAgICAgICB0aGUgYWNjdW11bGF0b3IgaXMgaW4gcmV2ZXJzZSBvcmRlciB3cnQgdGhlIG9yaWdpbmFsIGxpc3Qgb3JkZXIsIGhlbmNlIFtmIHkgeF1cbiAgICAgICAgIGluc3RlYWQgb2YgW2YgeCB5XS4gKilcbiAgICAgIHwgeSA6OiB5cyAtPiBzdGVwX2FjY3VtIChudW0gYXNyIDEpIHlzIChmIHkgeCkpXG4gIGluXG4gICgqIEV4cGVyaW1lbnRhbGx5LCBpbmxpbmluZyBbZm9sZGldIGFuZCB1bnJvbGxpbmcgdGhpcyBsb29wIGEgZmV3IHRpbWVzIGNhbiByZWR1Y2VcbiAgICAgcnVudGltZSBkb3duIHRvIGEgdGhpcmQgYW5kIGFsbG9jYXRpb24gdG8gMS8xNnRoIG9yIHNvIGluIHRoZSBtaWNyb2JlbmNobWFya3MgYmVsb3cuXG4gICAgIEhvd2V2ZXIsIGluIG1vc3QgdXNlIGNhc2VzIFtmXSBpcyBsaWtlbHkgdG8gYmUgZXhwZW5zaXZlIChvdGhlcndpc2Ugd2h5IGRvIHlvdSBjYXJlXG4gICAgIGFib3V0IHRoZSBvcmRlciBvZiByZWR1Y3Rpb24/KSBzbyB0aGUgb3ZlcmhlYWQgb2YgdGhpcyBmdW5jdGlvbiBpdHNlbGYgZG9lc24ndCByZWFsbHlcbiAgICAgbWF0dGVyLiBJZiB5b3UgY29tZSB1cCB3aXRoIGEgdXNlLWNhc2Ugd2hlcmUgaXQgZG9lcywgdGhlbiB0aGF0J3Mgc29tZXRoaW5nIHlvdSBtaWdodFxuICAgICB3YW50IHRvIHRyeTogc2VlIGhnIGxvZyAtcHIgNDllZjA2NWY0MjlkLiAqKVxuICBtYXRjaCBmb2xkaSBsIH5pbml0OltdIH5mOnN0ZXBfYWNjdW0gd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IHhzIC0+IFNvbWUgKGZvbGQgeHMgfmluaXQ6eCB+ZjooZnVuIHggeSAtPiBmIHkgeCkpXG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlX2JhbGFuY2VkIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9iYWxhbmNlZF9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgZ3JvdXBpIGwgfmJyZWFrID1cbiAgbGV0IGdyb3VwcyA9XG4gICAgZm9sZGkgbCB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIHggLT5cbiAgICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgICB8IFtdIC0+IFsgWyB4IF0gXVxuICAgICAgfCBjdXJyZW50X2dyb3VwIDo6IHRsIC0+XG4gICAgICAgIGlmIGJyZWFrIGkgKGhkX2V4biBjdXJyZW50X2dyb3VwKSB4XG4gICAgICAgIHRoZW4gWyB4IF0gOjogY3VycmVudF9ncm91cCA6OiB0bCAoKiBzdGFydCBuZXcgZ3JvdXAgKilcbiAgICAgICAgZWxzZSAoeCA6OiBjdXJyZW50X2dyb3VwKSA6OiB0bClcbiAgICAoKiBleHRlbmQgY3VycmVudCBncm91cCAqKVxuICBpblxuICBtYXRjaCBncm91cHMgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgbCAtPiByZXZfbWFwIGwgfmY6cmV2XG47O1xuXG5sZXQgZ3JvdXAgbCB+YnJlYWsgPSBncm91cGkgbCB+YnJlYWs6KGZ1biBfIHggeSAtPiBicmVhayB4IHkpIFtAbm9udGFpbF1cblxubGV0IHNvcnRfYW5kX2dyb3VwIGwgfmNvbXBhcmUgPVxuICBsIHw+IHN0YWJsZV9zb3J0IH5jb21wYXJlIHw+IGdyb3VwIH5icmVhazooZnVuIHggeSAtPiBjb21wYXJlIHggeSA8PiAwKVxuOztcblxubGV0IGNvbmNhdF9tYXAgbCB+ZjooZiBbQGxvY2FsXSkgPVxuICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gYXV4IChyZXZfYXBwZW5kIChmIGhkKSBhY2MpIHRsXG4gIGluXG4gIGxldCByZXMgPSBhdXggW10gbCBpblxuICByZXNcbjs7XG5cbmxldCBjb25jYXRfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBhdXggY29udCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gYXV4IChjb250ICsgMSkgKHJldl9hcHBlbmQgKGYgY29udCBoZCkgYWNjKSB0bFxuICBpblxuICBhdXggMCBbXSBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtZXJnZSBsMSBsMiB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBhY2MgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBhY2MgbDJcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGFjYyBsMVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjb21wYXJlIGgxIGgyIDw9IDAgdGhlbiBsb29wIChoMSA6OiBhY2MpIHQxIGwyIGVsc2UgbG9vcCAoaDIgOjogYWNjKSBsMSB0MlxuICBpblxuICBsb29wIFtdIGwxIGwyIFtAbm9udGFpbF1cbjs7XG5cbm1vZHVsZSBDYXJ0ZXNpYW5fcHJvZHVjdCA9IHN0cnVjdFxuICAoKiBXZSBhcmUgZXhwbGljaXQgYWJvdXQgd2hhdCB3ZSBleHBvcnQgZnJvbSBmdW5jdG9ycyBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseVxuICAgICByZWJpbmQgbW9yZSBlZmZpY2llbnQgbGlzdC1zcGVjaWZpYyBmdW5jdGlvbnMuICopXG5cbiAgbGV0IGJpbmQgPSBjb25jYXRfbWFwXG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcDIgYSBiIH5mID0gY29uY2F0X21hcCBhIH5mOihmdW4geCAtPiBtYXAgYiB+ZjooZnVuIHkgLT4gZiB4IHkpKVxuICBsZXQgcmV0dXJuIHggPSBbIHggXVxuICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgbGV0ICggPj49ICkgdCAoZiBbQGxvY2FsXSkgPSBiaW5kIHQgfmZcblxuICBvcGVuIHN0cnVjdFxuICAgIG1vZHVsZSBBcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlLk1ha2VfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgICAgICBsZXQgbWFwMiA9IG1hcDJcbiAgICAgIGVuZClcblxuICAgIG1vZHVsZSBNb25hZCA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBlbmQpXG4gIGVuZFxuXG4gIGxldCBhbGwgPSBNb25hZC5hbGxcbiAgbGV0IGFsbF91bml0ID0gTW9uYWQuYWxsX3VuaXRcbiAgbGV0IGlnbm9yZV9tID0gTW9uYWQuaWdub3JlX21cbiAgbGV0IGpvaW4gPSBNb25hZC5qb2luXG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG4gIGVuZFxuXG4gIGxldCBhcHBseSA9IEFwcGxpY2F0aXZlLmFwcGx5XG4gIGxldCBib3RoID0gQXBwbGljYXRpdmUuYm90aFxuICBsZXQgbWFwMyA9IEFwcGxpY2F0aXZlLm1hcDNcbiAgbGV0ICggPCo+ICkgPSBBcHBsaWNhdGl2ZS4oIDwqPiApXG4gIGxldCAoICo+ICkgPSBBcHBsaWNhdGl2ZS4oICo+IClcbiAgbGV0ICggPCogKSA9IEFwcGxpY2F0aXZlLiggPCogKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoIDwqPiApID0gQXBwbGljYXRpdmUuKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSBBcHBsaWNhdGl2ZS4oICo+IClcbiAgICBsZXQgKCA8KiApID0gQXBwbGljYXRpdmUuKCA8KiApXG4gIGVuZFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoID4+PSApID0gKCA+Pj0gKVxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSAoQ2FydGVzaWFuX3Byb2R1Y3QgOiBNb25hZC5TX2xvY2FsIHdpdGggdHlwZSAnYSB0IDo9ICdhIHQpXG5cbigqKiByZXR1cm5zIGZpbmFsIGVsZW1lbnQgb2YgbGlzdCAqKVxubGV0IHJlYyBsYXN0X2V4biBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgWyB4IF0gLT4geFxuICB8IF8gOjogdGwgLT4gbGFzdF9leG4gdGxcbiAgfCBbXSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubGFzdFwiXG47O1xuXG4oKiogb3B0aW9uYWxseSByZXR1cm5zIGZpbmFsIGVsZW1lbnQgb2YgbGlzdCAqKVxubGV0IHJlYyBsYXN0IGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbIHggXSAtPiBTb21lIHhcbiAgfCBfIDo6IHRsIC0+IGxhc3QgdGxcbiAgfCBbXSAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGlzX3ByZWZpeCBsaXN0IH5wcmVmaXggfmVxdWFsID1cbiAgbWF0Y2ggcHJlZml4IHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgaGQgOjogdGwgLT5cbiAgICAobWF0Y2ggbGlzdCB3aXRoXG4gICAgIHwgW10gLT4gZmFsc2VcbiAgICAgfCBoZCcgOjogdGwnIC0+IGVxdWFsIGhkIGhkJyAmJiBpc19wcmVmaXggdGwnIH5wcmVmaXg6dGwgfmVxdWFsKVxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIHQgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IGExIDo6IHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgYTEgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCBhMiA6OiB0IC0+IGlmIGVxdWFsIGExIGEyIHRoZW4gU29tZSAoYTEsIGEyKSBlbHNlIGxvb3AgYTIgdFxuICAgIGluXG4gICAgbG9vcCBhMSB0IFtAbm9udGFpbF1cbjs7XG5cbigqIHJldHVybnMgbGlzdCB3aXRob3V0IGFkamFjZW50IGR1cGxpY2F0ZXMgKilcbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyA/KHdoaWNoX3RvX2tlZXAgPSBgTGFzdCkgbGlzdCB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgdG9fa2VlcCBhY2N1bSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB0b19rZWVwIDo6IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgZXF1YWwgaGQgdG9fa2VlcFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0b19rZWVwID1cbiAgICAgICAgICBtYXRjaCB3aGljaF90b19rZWVwIHdpdGhcbiAgICAgICAgICB8IGBGaXJzdCAtPiB0b19rZWVwXG4gICAgICAgICAgfCBgTGFzdCAtPiBoZFxuICAgICAgICBpblxuICAgICAgICBsb29wIHRvX2tlZXAgYWNjdW0gdGwpXG4gICAgICBlbHNlIGxvb3AgaGQgKHRvX2tlZXAgOjogYWNjdW0pIHRsXG4gIGluXG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gcmV2IChsb29wIGhkIFtdIHRsKVxuOztcblxuKCoqIHJldHVybnMgc29ydGVkIHZlcnNpb24gb2YgbGlzdCB3aXRoIGR1cGxpY2F0ZXMgcmVtb3ZlZCAqKVxubGV0IGRlZHVwX2FuZF9zb3J0IGxpc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3QgKCogcGVyZm9ybWFuY2UgaGFjayAqKVxuICB8IF8gLT5cbiAgICBsZXQgZXF1YWwgeCB4JyA9IGNvbXBhcmUgeCB4JyA9IDAgaW5cbiAgICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsaXN0IGluXG4gICAgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgfmVxdWFsIHNvcnRlZCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9hX2R1cCBsIH5jb21wYXJlID1cbiAgbGV0IHNvcnRlZCA9IHNvcnQgbCB+Y29tcGFyZSBpblxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IE5vbmVcbiAgICB8IGhkMSA6OiAoaGQyIDo6IF8gYXMgdGwpIC0+IGlmIGNvbXBhcmUgaGQxIGhkMiA9IDAgdGhlbiBTb21lIGhkMSBlbHNlIGxvb3AgdGxcbiAgaW5cbiAgbG9vcCBzb3J0ZWQgW0Bub250YWlsXVxuOztcblxubGV0IGNvbnRhaW5zX2R1cCBsc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBmaW5kX2FfZHVwIGxzdCB+Y29tcGFyZSB3aXRoXG4gIHwgU29tZSBfIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZmluZF9hbGxfZHVwcyBsIH5jb21wYXJlID1cbiAgKCogV2UgYWRkIHRoaXMgcmV2ZXJzYWwsIHNvIHdlIGNhbiBza2lwIGEgW3Jldl0gYXQgdGhlIGVuZC4gV2UgY291bGQgc2tpcFxuICAgICBbcmV2XSBhbnl3YXkgc2luY2Ugd2UgZG9uIG5vdCBnaXZlIGFueSBvcmRlcmluZyBndWFyYW50ZWVzLCBidXQgaXQgaXNcbiAgICAgbmljZSB0byBnZXQgcmVzdWx0cyBpbiBuYXR1cmFsIG9yZGVyLiAqKVxuICBsZXQgY29tcGFyZSBhIGIgPSBjb21wYXJlIGIgYSBpblxuICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsIGluXG4gICgqIFdhbGsgdGhlIGxpc3QgYW5kIHJlY29yZCB0aGUgZmlyc3Qgb2YgZWFjaCBjb25zZWN1dGl2ZSBydW4gb2YgaWRlbnRpY2FsIGVsZW1lbnRzICopXG4gIGxldCByZWMgbG9vcCBzb3J0ZWQgcHJldiB+YWxyZWFkeV9yZWNvcmRlZCBhY2MgPVxuICAgIG1hdGNoIHNvcnRlZCB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBjb21wYXJlIHByZXYgaGQgPD4gMFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlIGFjY1xuICAgICAgZWxzZSBpZiBhbHJlYWR5X3JlY29yZGVkXG4gICAgICB0aGVuIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZSBhY2NcbiAgICAgIGVsc2UgbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDp0cnVlIChoZCA6OiBhY2MpXG4gIGluXG4gIG1hdGNoIHNvcnRlZCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZWMgYWxsX2VxdWFsX3RvIHQgdiB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgeCA6OiB4cyAtPiBlcXVhbCB4IHYgJiYgYWxsX2VxdWFsX3RvIHhzIHYgfmVxdWFsXG47O1xuXG5sZXQgYWxsX2VxdWFsIHQgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogeHMgLT4gaWYgYWxsX2VxdWFsX3RvIHhzIHggfmVxdWFsIHRoZW4gU29tZSB4IGVsc2UgTm9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGlkeCBjb3VudCBhIC0+IGlmIGYgaWR4IGEgdGhlbiBjb3VudCArIDEgZWxzZSBjb3VudCkgW0Bub250YWlsXVxuOztcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGFzc2VydCAoaSA+PSAwKTtcbiAgICBpZiBpID0gMCB0aGVuIGFjY3VtIGVsc2UgbG9vcCAoaSAtIDEpIChmIChpIC0gMSkgOjogYWNjdW0pXG4gIGluXG4gIGxvb3AgbiBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmV2X2ZpbHRlcl9tYXAgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBsIGFjY3VtID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgaGQgd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IGxvb3AgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgdGwgYWNjdW0pXG4gIGluXG4gIGxvb3AgbCBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmlsdGVyX21hcCBsIH5mID0gcmV2IChyZXZfZmlsdGVyX21hcCBsIH5mKVxuXG5sZXQgcmV2X2ZpbHRlcl9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSBsIGFjY3VtID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgaSBoZCB3aXRoXG4gICAgICAgfCBTb21lIHggLT4gbG9vcCAoaSArIDEpIHRsICh4IDo6IGFjY3VtKVxuICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgdGwgYWNjdW0pXG4gIGluXG4gIGxvb3AgMCBsIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSBsIH5mID0gcmV2IChyZXZfZmlsdGVyX21hcGkgbCB+ZilcbmxldCBmaWx0ZXJfb3B0IGwgPSBmaWx0ZXJfbWFwIGwgfmY6Rm4uaWRcblxubGV0IHBhcnRpdGlvbjNfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kIHRyZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kLCByZXYgdHJkXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgYEZzdCB5IC0+IGxvb3AgdCAoeSA6OiBmc3QpIHNuZCB0cmRcbiAgICAgICB8IGBTbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkgdHJkXG4gICAgICAgfCBgVHJkIHkgLT4gbG9vcCB0IGZzdCBzbmQgKHkgOjogdHJkKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gIGxldCBmIHggOiBfIEVpdGhlci50ID0gaWYgZiB4IHRoZW4gRmlyc3QgeCBlbHNlIFNlY29uZCB4IGluXG4gIHBhcnRpdGlvbl9tYXAgdCB+ZiBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcGFydGl0aW9uX3Jlc3VsdCB0ID0gcGFydGl0aW9uX21hcCB0IH5mOlJlc3VsdC50b19laXRoZXJcblxubW9kdWxlIEFzc29jID0gc3RydWN0XG4gIHR5cGUgJ2Ega2V5ID0gKCdhW0B0YWcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX2tleV90YWcgPSBMaXN0IFtdXSlcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQga2V5X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIGtleSA9XG4gICAgZnVuIF9vZl9hX18wMThfIC0+IF9vZl9hX18wMThfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2Zfa2V5IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGtleSAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDIwXyAtPiBfb2ZfYV9fMDIwX1xuICA7O1xuXG4gIGxldCBrZXlfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGtleSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgVGFnZ2VkXG4gICAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY19rZXlfdGFnXG4gICAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gXydhX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICB9XG4gICAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIHZhbHVlID0gKCdhW0B0YWcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3ZhbHVlX3RhZyA9IExpc3QgW11dKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB2YWx1ZV9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB2YWx1ZSA9XG4gICAgZnVuIF9vZl9hX18wMjFfIC0+IF9vZl9hX18wMjFfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdmFsdWUgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdmFsdWUgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBmdW4gX29mX2FfXzAyM18gLT4gX29mX2FfXzAyM19cbiAgOztcblxuICBsZXQgdmFsdWVfc2V4cF9ncmFtbWFyIDpcbiAgICAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdmFsdWUgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgVGFnZ2VkXG4gICAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY192YWx1ZV90YWdcbiAgICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPSBfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgKCgnYSBrZXkgKiAnYiB2YWx1ZSkgbGlzdFtAdGFnIFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY190YWcgPSBMaXN0IFtdXSlcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnYSAnYi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMzJfID0gXCJsaXN0Lm1sLkFzc29jLnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDI0XyBfb2ZfYl9fMDI1XyB4X18wMzNfIC0+XG4gICAgICBsaXN0X29mX3NleHBcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wMjdfOyBhcmcxX18wMjhfIF0gLT5cbiAgICAgICAgICAgIGxldCByZXMwX18wMjlfID0ga2V5X29mX3NleHAgX29mX2FfXzAyNF8gYXJnMF9fMDI3X1xuICAgICAgICAgICAgYW5kIHJlczFfXzAzMF8gPSB2YWx1ZV9vZl9zZXhwIF9vZl9iX18wMjVfIGFyZzFfXzAyOF8gaW5cbiAgICAgICAgICAgIHJlczBfXzAyOV8sIHJlczFfXzAzMF9cbiAgICAgICAgICB8IHNleHBfXzAzMV8gLT5cbiAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMzJfXG4gICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgc2V4cF9fMDMxXylcbiAgICAgICAgeF9fMDMzX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdiLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfYV9fMDM0XyBfb2ZfYl9fMDM1XyB4X18wNDBfIC0+XG4gICAgICBzZXhwX29mX2xpc3RcbiAgICAgICAgKGZ1biAoYXJnMF9fMDM2XywgYXJnMV9fMDM3XykgLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAzOF8gPSBzZXhwX29mX2tleSBfb2ZfYV9fMDM0XyBhcmcwX18wMzZfXG4gICAgICAgICAgIGFuZCByZXMxX18wMzlfID0gc2V4cF9vZl92YWx1ZSBfb2ZfYl9fMDM1XyBhcmcxX18wMzdfIGluXG4gICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzAzOF87IHJlczFfXzAzOV8gXSlcbiAgICAgICAgeF9fMDQwX1xuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgJ2EgJ2IuXG4gICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICBUYWdnZWRcbiAgICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3RhZ1xuICAgICAgICAgICAgOyB2YWx1ZSA9IExpc3QgW11cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9XG4gICAgICAgICAgICAgICAgKGxpc3Rfc2V4cF9ncmFtbWFyXG4gICAgICAgICAgICAgICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAoa2V5X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyKS51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zICgodmFsdWVfc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIpLnVudHlwZWQsIEVtcHR5KSApKVxuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnVudHlwZWRcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBwYWlyX29mX2dyb3VwID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgKGssIF8pIDo6IF8gYXMgbGlzdCAtPiBrLCBtYXAgbGlzdCB+ZjpzbmRcbiAgOztcblxuICBsZXQgZ3JvdXAgYWxpc3QgfmVxdWFsID1cbiAgICBncm91cCBhbGlzdCB+YnJlYWs6KGZ1biAoeCwgXykgKHksIF8pIC0+IG5vdCAoZXF1YWwgeCB5KSkgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgc29ydF9hbmRfZ3JvdXAgYWxpc3QgfmNvbXBhcmUgPVxuICAgIHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlOihmdW4gKHgsIF8pICh5LCBfKSAtPiBjb21wYXJlIHggeSlcbiAgICB8PiBtYXAgfmY6cGFpcl9vZl9ncm91cFxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5mOihmdW4gKGtleScsIF8pIC0+IGVxdWFsIGtleSBrZXknKSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIChzbmQgeClcbiAgOztcblxuICBsZXQgZmluZF9leG4gPVxuICAgIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuQXNzb2MuZmluZF9leG46IG5vdCBmb3VuZFwiKSBpblxuICAgIGxldCBmaW5kX2V4biB0IH5lcXVhbCBrZXkgPVxuICAgICAgbWF0Y2ggZmluZCB0IGtleSB+ZXF1YWwgd2l0aFxuICAgICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgICAgfCBTb21lIHZhbHVlIC0+IHZhbHVlXG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgZmluZF9leG5cbiAgOztcblxuICBsZXQgbWVtIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5lcXVhbCBrZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBfIC0+IHRydWVcbiAgOztcblxuICBsZXQgcmVtb3ZlIHQgfmVxdWFsIGtleSA9IGZpbHRlciB0IH5mOihmdW4gKGtleScsIF8pIC0+IG5vdCAoZXF1YWwga2V5IGtleScpKSBbQG5vbnRhaWxdXG5cbiAgbGV0IGFkZCB0IH5lcXVhbCBrZXkgdmFsdWUgPVxuICAgICgqIHRoZSByZW1vdmUgZG9lc24ndCBjaGFuZ2UgdGhlIG1hcCBzZW1hbnRpY3MsIGJ1dCBrZWVwcyB0aGUgbGlzdCBzbWFsbCAqKVxuICAgIChrZXksIHZhbHVlKSA6OiByZW1vdmUgdCB+ZXF1YWwga2V5XG4gIDs7XG5cbiAgbGV0IGludmVyc2UgdCA9IG1hcCB0IH5mOihmdW4gKHgsIHkpIC0+IHksIHgpXG4gIGxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mOihmdW4gKGtleSwgdmFsdWUpIC0+IGtleSwgZiB2YWx1ZSkgW0Bub250YWlsXVxuZW5kXG5cbmxldCBzdWIgbCB+cG9zIH5sZW4gPVxuICAoKiBXZSB1c2UgW3BvcyA+IGxlbmd0aCBsIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gbGVuZ3RoIGxdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBsIC0gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnN1YlwiO1xuICByZXZcbiAgICAoZm9sZGkgbCB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGVsIC0+XG4gICAgICAgaWYgaSA+PSBwb3MgJiYgaSA8IHBvcyArIGxlbiB0aGVuIGVsIDo6IGFjYyBlbHNlIGFjYykpXG47O1xuXG5sZXQgc3BsaXRfbiB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdLCB0X29yaWdcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIG4gdCBhY2N1bSA9XG4gICAgICBpZiBuID0gMFxuICAgICAgdGhlbiByZXYgYWNjdW0sIHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiB0X29yaWcsIFtdICgqIGluIHRoaXMgY2FzZSwgdF9vcmlnID0gcmV2IGFjY3VtICopXG4gICAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSkpXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxuKCogY29waWVkIGZyb20gW3NwbGl0X25dIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2UgdF9vcmlnIG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIHJldiBhY2N1bVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IHRfb3JpZ1xuICAgICAgICB8IGhkIDo6IHRsIC0+IGxvb3AgKG4gLSAxKSB0bCAoaGQgOjogYWNjdW0pKVxuICAgIGluXG4gICAgbG9vcCBuIHRfb3JpZyBbXSlcbjs7XG5cbmxldCByZWMgZHJvcCB0IG4gPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBfIDo6IHRsIHdoZW4gbiA+IDAgLT4gZHJvcCB0bCAobiAtIDEpXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgY2h1bmtzX29mIGwgfmxlbmd0aCA9XG4gIGlmIGxlbmd0aCA8PSAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5jaHVua3Nfb2Y6IEV4cGVjdGVkIGxlbmd0aCA+IDAsIGdvdCAlZFwiIGxlbmd0aCAoKTtcbiAgbGV0IHJlYyBhdXggb2ZfbGVuZ3RoIGFjYyBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IHN1Ymxpc3QsIGwgPSBzcGxpdF9uIGwgbGVuZ3RoIGluXG4gICAgICBhdXggb2ZfbGVuZ3RoIChzdWJsaXN0IDo6IGFjYykgbFxuICBpblxuICBhdXggbGVuZ3RoIFtdIGxcbjs7XG5cbmxldCBzcGxpdF93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IHQgLT4gcmV2IGFjYywgdFxuICBpblxuICBsb29wIFtdIHhzIFtAbm9udGFpbF1cbjs7XG5cbigqIGNvcGllZCBmcm9tIFtzcGxpdF93aGlsZV0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlICopXG5sZXQgdGFrZV93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IF8gLT4gcmV2IGFjY1xuICBpblxuICBsb29wIFtdIHhzIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZWMgZHJvcF93aGlsZSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGRyb3Bfd2hpbGUgdGwgfmZcbiAgfCB0IC0+IHRcbjs7XG5cbmxldCBkcm9wX2xhc3QgdCA9XG4gIG1hdGNoIHJldiB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyA6OiBsc3QgLT4gU29tZSAocmV2IGxzdClcbjs7XG5cbmxldCBkcm9wX2xhc3RfZXhuIHQgPVxuICBtYXRjaCBkcm9wX2xhc3QgdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIkxpc3QuZHJvcF9sYXN0X2V4bjogZW1wdHkgbGlzdFwiXG4gIHwgU29tZSBsc3QgLT4gbHN0XG47O1xuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3QgbGlzdDEgbGlzdDIgPVxuICBpZiBpc19lbXB0eSBsaXN0MlxuICB0aGVuIFtdXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBsMSBsMiBhY2N1bSA9XG4gICAgICBtYXRjaCBsMSB3aXRoXG4gICAgICB8IFtdIC0+IGFjY3VtXG4gICAgICB8IGhkIDo6IHRsIC0+IGxvb3AgdGwgbDIgKHJldl9hcHBlbmQgKG1hcCB+ZjooZnVuIHggLT4gaGQsIHgpIGwyKSBhY2N1bSlcbiAgICBpblxuICAgIHJldiAobG9vcCBsaXN0MSBsaXN0MiBbXSkpXG47O1xuXG5sZXQgY29uY2F0IGwgPSBmb2xkX3JpZ2h0IGwgfmluaXQ6W10gfmY6YXBwZW5kXG5sZXQgY29uY2F0X25vX29yZGVyIGwgPSBmb2xkIGwgfmluaXQ6W10gfmY6KGZ1biBhY2MgbCAtPiByZXZfYXBwZW5kIGwgYWNjKVxubGV0IGNvbnMgeCBsID0geCA6OiBsXG5cbmxldCBpc19zb3J0ZWQgbCB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIHwgWyBfIF0gLT4gdHJ1ZVxuICAgIHwgeDEgOjogKHgyIDo6IF8gYXMgcmVzdCkgLT4gY29tcGFyZSB4MSB4MiA8PSAwICYmIGxvb3AgcmVzdFxuICBpblxuICBsb29wIGwgW0Bub250YWlsXVxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDwgMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsIFtAbm9udGFpbF1cbjs7XG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gICgqIHNwZWNpYWwgY2FzZXMgdG8gc3BlZWQgdGhpbmdzIHVwIGluIHRyaXZpYWwgY2FzZXMgKilcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3RcbiAgfCBbIHg7IHkgXSAtPiBpZiBSYW5kb20uU3RhdGUuYm9vbCByYW5kb21fc3RhdGUgdGhlbiBbIHk7IHggXSBlbHNlIGxpc3RcbiAgfCBfIC0+XG4gICAgbGV0IGFyciA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIEFycmF5X3Blcm11dGUucGVybXV0ZSBhcnIgfnJhbmRvbV9zdGF0ZTtcbiAgICBBcnJheS50b19saXN0IGFyclxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgaWYgaXNfZW1wdHkgbGlzdFxuICB0aGVuIGZhaWx3aXRoIFwiTGlzdC5yYW5kb21fZWxlbWVudF9leG46IGVtcHR5IGxpc3RcIlxuICBlbHNlIG50aF9leG4gbGlzdCAoUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCBsaXN0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIGxpc3QpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgY29tcGFyZSBjbXAgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgaWYgbiA9IDAgdGhlbiBjb21wYXJlIGNtcCB4cyB5cyBlbHNlIG5cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA9IGhhc2hfZm9sZF9saXN0XG5cbmxldCBlcXVhbF9sb2NhbCAoKGVxdWFsIDogXyAtPiBfIC0+IF8pIFtAbG9jYWxdKSB0MSB0MiA9XG4gIGxldCByZWMgbG9vcCB+ZXF1YWwgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgeDEgOjogdDEsIHgyIDo6IHQyIC0+IGVxdWFsIHgxIHgyICYmIGxvb3AgfmVxdWFsIHQxIHQyXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgfmVxdWFsIHQxIHQyXG47O1xuXG5sZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgZnVuIGYgeCB5IC0+IGVxdWFsX2xvY2FsIGYgeCB5XG47O1xuXG5sZXQgdHJhbnNwb3NlID1cbiAgbGV0IHJlYyBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHQgY29sdW1uX2FjYyB0cmltbWVkIGZvdW5kX2VtcHR5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGNvbHVtbl9hY2MsIHRyaW1tZWQsIGZvdW5kX2VtcHR5XG4gICAgfCBbXSA6OiB0bCAtPiBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsIGNvbHVtbl9hY2MgdHJpbW1lZCB0cnVlXG4gICAgfCAoeCA6OiB4cykgOjogdGwgLT5cbiAgICAgIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdGwgKHggOjogY29sdW1uX2FjYykgKHhzIDo6IHRyaW1tZWQpIGZvdW5kX2VtcHR5XG4gIGluXG4gIGxldCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgPSBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgW10gW10gZmFsc2UgaW5cbiAgbGV0IHJlYyBsb29wIHJvd3MgY29sdW1ucyBkb19yZXYgPVxuICAgIG1hdGNoIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyB3aXRoXG4gICAgfCBbXSwgW10sIF8gLT4gU29tZSAocmV2IGNvbHVtbnMpXG4gICAgfCBjb2x1bW4sIHRyaW1tZWRfcm93cywgZm91bmRfZW1wdHkgLT5cbiAgICAgIGlmIGZvdW5kX2VtcHR5XG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgY29sdW1uID0gaWYgZG9fcmV2IHRoZW4gcmV2IGNvbHVtbiBlbHNlIGNvbHVtbiBpblxuICAgICAgICBsb29wIHRyaW1tZWRfcm93cyAoY29sdW1uIDo6IGNvbHVtbnMpIChub3QgZG9fcmV2KSlcbiAgaW5cbiAgZnVuIHQgLT4gbG9vcCB0IFtdIHRydWVcbjs7XG5cbmV4Y2VwdGlvbiBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIG9mIGludCBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzXVxuICAgIChmdW5jdGlvblxuICAgICAgfCBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIGFyZzBfXzA0MV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzA0Ml8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9pbnQgYXJnMF9fMDQxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxpc3QubWwuVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc1wiXG4gICAgICAgICAgOyByZXMwX18wNDJfXG4gICAgICAgICAgXVxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmxldCB0cmFuc3Bvc2VfZXhuIGwgPVxuICBtYXRjaCB0cmFuc3Bvc2UgbCB3aXRoXG4gIHwgU29tZSBsIC0+IGxcbiAgfCBOb25lIC0+IHJhaXNlIChUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIChtYXAgbCB+ZjpsZW5ndGgpKVxuOztcblxubGV0IGludGVyc3BlcnNlIHQgfnNlcCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB4cyAtPiB4IDo6IGZvbGRfcmlnaHQgeHMgfmluaXQ6W10gfmY6KGZ1biB5IGFjYyAtPiBzZXAgOjogeSA6OiBhY2MpXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcblxubGV0IGlzX3N1ZmZpeCBsaXN0IH5zdWZmaXggfmVxdWFsOigoZXF1YWxfZWx0IDogXyAtPiBfIC0+IF8pIFtAbG9jYWxdKSA9XG4gIGxldCBsaXN0X2xlbiA9IGxlbmd0aCBsaXN0IGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsaXN0X2xlbiA+PSBzdWZmaXhfbGVuXG4gICYmIGVxdWFsX2xvY2FsIGVxdWFsX2VsdCAoZHJvcCBsaXN0IChsaXN0X2xlbiAtIHN1ZmZpeF9sZW4pKSBzdWZmaXhcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6OTgwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX29ial90YWciLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImdsb2JhbF9kYXRhIiwidF9zZXhwX2dyYW1tYXIiLCJtb2R1bGVfbmFtZSIsIlN0ZGxpYl9Gb3JtYXQiLCJCYXNlX0V4biIsIlN0ZGxpYl9QcmludGV4YyIsIkJhc2VfTGF6eSIsIkNhbWxpbnRlcm5hbExhenkiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfTGlzdCIsIkJhc2VfUHJpbnRmIiwiQmFzZV9TZXhwIiwiQmFzZV9IYXNoIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NvdXJjZV9jb2RlX3Bvc2l0aW9uMCIsIkJhc2VfQ2hhcjAiLCJCYXNlX1N0cmluZzAiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiY3N0X2NvdWxkX25vdF9jb25zdHJ1Y3RfaW5mbyIsImNzdF9CYWNrdHJhY2UiLCJzZXhwX29mX3QiLCJwYXJhbSIsImFyZzBfMDAxIiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsInJlczBfMDA0IiwiYXJnMF8wMDUiLCJyZXMwXzAwNiIsImFyZzBfMDA3IiwicmVzMF8wMDgiLCJhcmcyXzAxMSIsImFyZzFfMDEwIiwiYXJnMF8wMDkiLCJyZXMwXzAxMiIsInJlczFfMDEzIiwicmVzMl8wMTQiLCJhcmcxXzAxNiIsImFyZzBfMDE1IiwicmVzMF8wMTciLCJyZXMxXzAxOCIsImFyZzJfMDIxIiwiYXJnMV8wMjAiLCJhcmcwXzAxOSIsInJlczBfMDIyIiwicmVzMV8wMjMiLCJyZXMyXzAyNCIsImFyZzFfMDI2IiwiYXJnMF8wMjUiLCJyZXMwXzAyNyIsInJlczFfMDI4IiwiYXJnMV8wMzAiLCJhcmcwXzAyOSIsInJlczBfMDMxIiwicmVzMV8wMzIiLCJ0b19zdHJpbmdzX2h1bSIsInQiLCJhYyIsInNleHAiLCJzdHJpbmciLCJleG4iLCJ0YWciLCJib2R5IiwidHMiLCJ0cnVuY19hZnRlciIsIm1heCIsIm4iLCJiYWNrdHJhY2UiLCJ0b19zZXhwc19odW0iLCJoZXJlIiwibGVuIiwidG9fc2V4cF9odW0iLCJzZXhwcyIsInByb3RlY3QiLCJ0b19tZXNzYWdlIiwiaW5mbyIsIm9mX21lc3NhZ2UiLCJpbnZhcmlhbnQiLCJ0X29mX3NleHAiLCJjb21wYXJlIiwidDEiLCJ0MiIsImVxdWFsIiwiaGFzaF9mb2xkX3QiLCJzdGF0ZSIsImhhc2giLCJ0b19zdHJpbmdfaHVtIiwibWVzc2FnZSIsInMiLCJ0b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQiLCJ0b19zdHJpbmdfbWFjaCIsIm9mX2xhenkiLCJsIiwib2ZfbGF6eV9zZXhwIiwib2ZfbGF6eV90IiwibGF6eV90Iiwib2Zfc3RyaW5nIiwiY3JlYXRlZiIsImZvcm1hdCIsIm9mX3RodW5rIiwiY3JlYXRlIiwic3RyaWN0IiwieCIsInNleHBfb2ZfeCIsImNyZWF0ZV9zIiwidGFnX3NfbGF6eSIsInRhZ19zIiwidGFnX2FyZyIsIm9mX2xpc3QiLCJFeG4iLCJ0b19leG4iLCJtYXRjaCIsIm9mX2V4biIsInBwIiwicHBmIiwiaW5jbHVkZSIsIkJhc2VfSW5mbyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2luZm8ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFD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QSxRQUFBO0FBQUE7QUFBQSx1QkFHSTtBQUFBLFFBQUFuRCxNQUhKO0FBQUEsSUFFa0I7QUFBQSxHQUNSO0FBQUEsWUFBQW9ELE9BQUE3QyxXQUFBUDtBQUFBQSxJQUlmO0FBQUEsU0FBQW1ELFFBQUE7QUFBQTtBQUFBLGdCQUkyQyxJQUFsQztBQUFBO0FBQUEsVUFBQXZCLElBSlQsZ0JBS3NCO0FBQUEsU0FBQXJCLGNBTHRCO0FBQUE7QUFBQTtBQUFBLFNBQUFBLGNBRVk7QUFBQSxJQUtaO0FBQUEsU0FBQVgsSUFBQTtBQUFBLHVCQUNpQjtBQUFBLFNBQUFXLGNBRGpCO0FBQUEsS0FFMkIsc0JBQUE3QyxPQUFzQixzQ0FBWSxHQUFsQztBQUFBO0FBQUEsSUFGM0Isa0JBR2EsMENBQ3FFO0FBQUEsUUFBQTZDLGNBSmxGO0FBQUEsSUFJdUI7QUFBQSxxQkFBQTdDO0FBQUFBLGFBQTJCLDBEQUFtQjtBQUFBLGNBQTlDO0FBQUEsR0FBMkQ7QUFBQSxZQUFBMkYsR0FBQUMsS0FBQTFEO0FBQUFBLFFBQUEsTUFPL0I7QUFBQSxJQUFpQjtBQUFBO0FBQUE7QUFBQSxJQUFBMkQsVUEvQm5EO0FBQUEsSUFBQUYsT0FBQTtBQUFBLElBQUFHO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDFObkIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0luZm9dLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIGFzIG1hbnkgcGxhY2VzIGFzIHBvc3NpYmxlLiBQbGVhc2UgYXZvaWRcbiAgIGFkZGluZyBuZXcgZGVwZW5kZW5jaWVzLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW5mb19pbnRmXG5tb2R1bGUgQ2hhciA9IENoYXIwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG5tb2R1bGUgTWVzc2FnZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBvZiBTZXhwLnRcbiAgICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgICB8IEV4biBvZiBleG5cbiAgICB8IFNleHAgb2YgU2V4cC50XG4gICAgfCBUYWdfc2V4cCBvZiBzdHJpbmcgKiBTZXhwLnQgKiBTb3VyY2VfY29kZV9wb3NpdGlvbjAudCBvcHRpb25cbiAgICB8IFRhZ190IG9mIHN0cmluZyAqIHRcbiAgICB8IFRhZ19hcmcgb2Ygc3RyaW5nICogU2V4cC50ICogdFxuICAgIHwgT2ZfbGlzdCBvZiBpbnQgb3B0aW9uICogdCBsaXN0XG4gICAgfCBXaXRoX2JhY2t0cmFjZSBvZiB0ICogc3RyaW5nICgqIGJhY2t0cmFjZSAqKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgcmVjIHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3QgYXJnMF9fMDAxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDAyXyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ291bGRfbm90X2NvbnN0cnVjdFwiOyByZXMwX18wMDJfIF1cbiAgICAgIHwgU3RyaW5nIGFyZzBfXzAwM18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwNF8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDNfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlN0cmluZ1wiOyByZXMwX18wMDRfIF1cbiAgICAgIHwgRXhuIGFyZzBfXzAwNV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwNl8gPSBzZXhwX29mX2V4biBhcmcwX18wMDVfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4blwiOyByZXMwX18wMDZfIF1cbiAgICAgIHwgU2V4cCBhcmcwX18wMDdfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDhfID0gU2V4cC5zZXhwX29mX3QgYXJnMF9fMDA3XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZXhwXCI7IHJlczBfXzAwOF8gXVxuICAgICAgfCBUYWdfc2V4cCAoYXJnMF9fMDA5XywgYXJnMV9fMDEwXywgYXJnMl9fMDExXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAxMl8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDlfXG4gICAgICAgIGFuZCByZXMxX18wMTNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDEwX1xuICAgICAgICBhbmQgcmVzMl9fMDE0XyA9IHNleHBfb2Zfb3B0aW9uIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgYXJnMl9fMDExXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19zZXhwXCI7IHJlczBfXzAxMl87IHJlczFfXzAxM187IHJlczJfXzAxNF8gXVxuICAgICAgfCBUYWdfdCAoYXJnMF9fMDE1XywgYXJnMV9fMDE2XykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAxN18gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMTVfXG4gICAgICAgIGFuZCByZXMxX18wMThfID0gc2V4cF9vZl90IGFyZzFfXzAxNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX3RcIjsgcmVzMF9fMDE3XzsgcmVzMV9fMDE4XyBdXG4gICAgICB8IFRhZ19hcmcgKGFyZzBfXzAxOV8sIGFyZzFfXzAyMF8sIGFyZzJfXzAyMV8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMjJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE5X1xuICAgICAgICBhbmQgcmVzMV9fMDIzXyA9IFNleHAuc2V4cF9vZl90IGFyZzFfXzAyMF9cbiAgICAgICAgYW5kIHJlczJfXzAyNF8gPSBzZXhwX29mX3QgYXJnMl9fMDIxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19hcmdcIjsgcmVzMF9fMDIyXzsgcmVzMV9fMDIzXzsgcmVzMl9fMDI0XyBdXG4gICAgICB8IE9mX2xpc3QgKGFyZzBfXzAyNV8sIGFyZzFfXzAyNl8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMjdfID0gc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9pbnQgYXJnMF9fMDI1X1xuICAgICAgICBhbmQgcmVzMV9fMDI4XyA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX3QgYXJnMV9fMDI2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPZl9saXN0XCI7IHJlczBfXzAyN187IHJlczFfXzAyOF8gXVxuICAgICAgfCBXaXRoX2JhY2t0cmFjZSAoYXJnMF9fMDI5XywgYXJnMV9fMDMwXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMV8gPSBzZXhwX29mX3QgYXJnMF9fMDI5X1xuICAgICAgICBhbmQgcmVzMV9fMDMyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzFfXzAzMF8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiV2l0aF9iYWNrdHJhY2VcIjsgcmVzMF9fMDMxXzsgcmVzMV9fMDMyXyBdXG4gICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcmVjIHRvX3N0cmluZ3NfaHVtIHQgYWMgPVxuICAgICgqIFdlIHVzZSBbU2V4cC50b19zdHJpbmdfbWFjaF0sIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCB3ZSBhcmUgaW1wbGVtZW50aW5nXG4gICAgICAgW3RvX3N0cmluZ3NfaHVtXSwgYmVjYXVzZSB3ZSB3YW50IHRoZSBpbmZvIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lLCBhbmQgb25jZSB3ZSd2ZVxuICAgICAgIGhhZCB0byByZXNvcnQgdG8gc2V4cHMsIHRoZSBtZXNzYWdlIGlzIGdvaW5nIHRvIHN0YXJ0IG5vdCBsb29raW5nIHNvIHByZXR0eVxuICAgICAgIGFueXdheS4gKilcbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3Qgc2V4cCAtPlxuICAgICAgXCJjb3VsZCBub3QgY29uc3RydWN0IGluZm86IFwiIDo6IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBzdHJpbmcgOjogYWNcbiAgICB8IEV4biBleG4gLT4gU2V4cC50b19zdHJpbmdfbWFjaCAoRXhuLnNleHBfb2ZfdCBleG4pIDo6IGFjXG4gICAgfCBTZXhwIHNleHAgLT4gU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwIDo6IGFjXG4gICAgfCBUYWdfc2V4cCAodGFnLCBzZXhwLCBfKSAtPiB0YWcgOjogXCI6IFwiIDo6IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgVGFnX3QgKHRhZywgdCkgLT4gdGFnIDo6IFwiOiBcIiA6OiB0b19zdHJpbmdzX2h1bSB0IGFjXG4gICAgfCBUYWdfYXJnICh0YWcsIHNleHAsIHQpIC0+XG4gICAgICBsZXQgYm9keSA9IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBcIjogXCIgOjogdG9fc3RyaW5nc19odW0gdCBhYyBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gYm9keSBlbHNlIHRhZyA6OiBcIjogXCIgOjogYm9keVxuICAgIHwgV2l0aF9iYWNrdHJhY2UgKHQsIGJhY2t0cmFjZSkgLT5cbiAgICAgIHRvX3N0cmluZ3NfaHVtIHQgKFwiXFxuQmFja3RyYWNlOlxcblwiIDo6IGJhY2t0cmFjZSA6OiBhYylcbiAgICB8IE9mX2xpc3QgKHRydW5jX2FmdGVyLCB0cykgLT5cbiAgICAgIGxldCB0cyA9XG4gICAgICAgIG1hdGNoIHRydW5jX2FmdGVyIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRzXG4gICAgICAgIHwgU29tZSBtYXggLT5cbiAgICAgICAgICBsZXQgbiA9IExpc3QubGVuZ3RoIHRzIGluXG4gICAgICAgICAgaWYgbiA8PSBtYXhcbiAgICAgICAgICB0aGVuIHRzXG4gICAgICAgICAgZWxzZSBMaXN0LnRha2UgdHMgbWF4IEAgWyBTdHJpbmcgKFByaW50Zi5zcHJpbnRmIFwiYW5kICVkIG1vcmUgaW5mb1wiIChuIC0gbWF4KSkgXVxuICAgICAgaW5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPlxuICAgICAgICB0b19zdHJpbmdzX2h1bSB0IChpZiBMaXN0LmlzX2VtcHR5IGFjIHRoZW4gYWMgZWxzZSBcIjsgXCIgOjogYWMpKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgdCA9IFN0cmluZy5jb25jYXQgKHRvX3N0cmluZ3NfaHVtIHQgW10pXG5cbiAgKCogTGlrZSBbU3RyaW5nLnNwbGl0X2xpbmVzXSwgYnV0IGxlc3Mgb3B0aW1pemVkIGFuZCBkb2Vzbid0IGhhbmRsZSBbXFxyXFxuXS4gQXZvaWRzIGFcbiAgICAgZGVwZW5kZW5jeSBjeWNsZS4gSW1wcm92ZXMgb24gbmFpdmUgW1N0cmluZy5zcGxpdF9vbl9jaGFyXSBieSByZW1vdmluZyBlbXB0eSBmaW5hbFxuICAgICBsaW5lLiAqKVxuICBsZXQgc3BsaXRfbGluZXMgc3RyaW5nID1cbiAgICBsZXQgc3RyaW5nID1cbiAgICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0cmluZyBpblxuICAgICAgaWYgbGVuID4gMCAmJiBDaGFyLmVxdWFsICdcXG4nIChTdHJpbmcuZ2V0IHN0cmluZyAobGVuIC0gMSkpXG4gICAgICB0aGVuIFN0cmluZy5zdWIgc3RyaW5nIH5wb3M6MCB+bGVuOihsZW4gLSAxKVxuICAgICAgZWxzZSBzdHJpbmdcbiAgICBpblxuICAgIFN0cmluZy5zcGxpdF9vbl9jaGFyIHN0cmluZyB+c2VwOidcXG4nXG4gIDs7XG5cbiAgbGV0IHJlYyB0b19zZXhwc19odW0gdCBhYyA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IF8gYXMgdCAtPiBzZXhwX29mX3QgdCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBBdG9tIHN0cmluZyA6OiBhY1xuICAgIHwgRXhuIGV4biAtPiBFeG4uc2V4cF9vZl90IGV4biA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IHNleHAgOjogYWNcbiAgICB8IFRhZ19zZXhwICh0YWcsIHNleHAsIGhlcmUpIC0+XG4gICAgICBMaXN0XG4gICAgICAgIChBdG9tIHRhZ1xuICAgICAgICAgOjogc2V4cFxuICAgICAgICAgOjpcbiAgICAgICAgIChtYXRjaCBoZXJlIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgICB8IFNvbWUgaGVyZSAtPiBbIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZSBdKSlcbiAgICAgIDo6IGFjXG4gICAgfCBUYWdfdCAodGFnLCB0KSAtPiBMaXN0IChBdG9tIHRhZyA6OiB0b19zZXhwc19odW0gdCBbXSkgOjogYWNcbiAgICB8IFRhZ19hcmcgKHRhZywgc2V4cCwgdCkgLT5cbiAgICAgIGxldCBib2R5ID0gc2V4cCA6OiB0b19zZXhwc19odW0gdCBbXSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gTGlzdCBib2R5IDo6IGFjIGVsc2UgTGlzdCAoQXRvbSB0YWcgOjogYm9keSkgOjogYWNcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICBTZXhwLkxpc3QgWyB0b19zZXhwX2h1bSB0OyBzZXhwX29mX2xpc3Qgc2V4cF9vZl9zdHJpbmcgKHNwbGl0X2xpbmVzIGJhY2t0cmFjZSkgXVxuICAgICAgOjogYWNcbiAgICB8IE9mX2xpc3QgKF8sIHRzKSAtPlxuICAgICAgTGlzdC5mb2xkIChMaXN0LnJldiB0cykgfmluaXQ6YWMgfmY6KGZ1biBhYyB0IC0+IHRvX3NleHBzX2h1bSB0IGFjKVxuXG4gIGFuZCB0b19zZXhwX2h1bSB0ID1cbiAgICBtYXRjaCB0b19zZXhwc19odW0gdCBbXSB3aXRoXG4gICAgfCBbIHNleHAgXSAtPiBzZXhwXG4gICAgfCBzZXhwcyAtPiBTZXhwLkxpc3Qgc2V4cHNcbiAgOztcblxuICAoKiBXZSB1c2UgW3Byb3RlY3RdIHRvIGd1YXJkIGFnYWluc3QgZXhjZXB0aW9ucyByYWlzZWQgYnkgdXNlci1zdXBwbGllZCBmdW5jdGlvbnMsIHNvXG4gICAgIHRoYXQgZmFpbHVyZSB0byBwcm9kdWNlIG9uZSBwYXJ0IG9mIGFuIGluZm8gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCBvdGhlciBwYXJ0cy4gKilcbiAgbGV0IHByb3RlY3QgZiA9XG4gICAgdHJ5IGYgKCkgd2l0aFxuICAgIHwgZXhuIC0+IENvdWxkX25vdF9jb25zdHJ1Y3QgKEV4bi5zZXhwX29mX3QgZXhuKVxuICA7O1xuXG4gIGxldCBvZl9pbmZvIGluZm8gPSBwcm90ZWN0IChmdW4gKCkgLT4gTGF6eS5mb3JjZSBpbmZvKVxuICBsZXQgdG9faW5mbyB0ID0gbGF6eSB0XG5lbmRcblxub3BlbiBNZXNzYWdlXG5cbnR5cGUgdCA9IE1lc3NhZ2UudCBMYXp5LnRcblxubGV0IGludmFyaWFudCBfID0gKClcbmxldCB0b19tZXNzYWdlID0gTWVzc2FnZS5vZl9pbmZvXG5sZXQgb2ZfbWVzc2FnZSA9IE1lc3NhZ2UudG9faW5mb1xuXG4oKiBJdCBpcyBPSyB0byB1c2UgW01lc3NhZ2UudG9fc2V4cF9odW1dLCB3aGljaCBpcyBub3Qgc3RhYmxlLCBiZWNhdXNlIFt0X29mX3NleHBdIGJlbG93XG4gICBjYW4gaGFuZGxlIGFueSBzZXhwLiAqKVxubGV0IHNleHBfb2ZfdCB0ID0gTWVzc2FnZS50b19zZXhwX2h1bSAodG9fbWVzc2FnZSB0KVxubGV0IHRfb2Zfc2V4cCBzZXhwID0gbGF6eSAoTWVzc2FnZS5TZXhwIHNleHApXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB7IHVudHlwZWQgPSBBbnkgXCJJbmZvLnRcIiB9XG5sZXQgY29tcGFyZSB0MSB0MiA9IFNleHAuY29tcGFyZSAoc2V4cF9vZl90IHQxKSAoc2V4cF9vZl90IHQyKVxubGV0IGVxdWFsIHQxIHQyID0gU2V4cC5lcXVhbCAoc2V4cF9vZl90IHQxKSAoc2V4cF9vZl90IHQyKVxubGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBTZXhwLmhhc2hfZm9sZF90IHN0YXRlIChzZXhwX29mX3QgdClcbmxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG5cbmxldCB0b19zdHJpbmdfaHVtIHQgPVxuICBtYXRjaCB0b19tZXNzYWdlIHQgd2l0aFxuICB8IFN0cmluZyBzIC0+IHNcbiAgfCBtZXNzYWdlIC0+IFNleHAudG9fc3RyaW5nX2h1bSAoTWVzc2FnZS50b19zZXhwX2h1bSBtZXNzYWdlKVxuOztcblxubGV0IHRvX3N0cmluZ19odW1fZGVwcmVjYXRlZCB0ID0gTWVzc2FnZS50b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgKHRvX21lc3NhZ2UgdClcbmxldCB0b19zdHJpbmdfbWFjaCB0ID0gU2V4cC50b19zdHJpbmdfbWFjaCAoc2V4cF9vZl90IHQpXG5sZXQgb2ZfbGF6eSBsID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFN0cmluZyAoTGF6eS5mb3JjZSBsKSkpXG5sZXQgb2ZfbGF6eV9zZXhwIGwgPSBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gU2V4cCAoTGF6eS5mb3JjZSBsKSkpXG5sZXQgb2ZfbGF6eV90IGxhenlfdCA9IExhenkuam9pbiBsYXp5X3RcbmxldCBvZl9zdHJpbmcgbWVzc2FnZSA9IExhenkuZnJvbV92YWwgKFN0cmluZyBtZXNzYWdlKVxubGV0IGNyZWF0ZWYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIG9mX3N0cmluZyBmb3JtYXRcbmxldCBvZl90aHVuayBmID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFN0cmluZyAoZiAoKSkpKVxuXG5sZXQgY3JlYXRlID9oZXJlID9zdHJpY3QgdGFnIHggc2V4cF9vZl94ID1cbiAgbWF0Y2ggc3RyaWN0IHdpdGhcbiAgfCBOb25lIC0+IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfc2V4cCAodGFnLCBzZXhwX29mX3ggeCwgaGVyZSkpKVxuICB8IFNvbWUgKCkgLT4gb2ZfbWVzc2FnZSAoVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBMYXp5LmZyb21fdmFsIChTZXhwIHNleHApXG5sZXQgdGFnIHQgfnRhZyA9IGxhenkgKFRhZ190ICh0YWcsIHRvX21lc3NhZ2UgdCkpXG5cbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9XG4gIGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfYXJnIChcIlwiLCBMYXp5LmZvcmNlIHRhZywgdG9fbWVzc2FnZSB0KSkpXG47O1xuXG5sZXQgdGFnX3MgdCB+dGFnID0gdGFnX3NfbGF6eSB0IH50YWc6KExhenkuZnJvbV92YWwgdGFnKVxuXG5sZXQgdGFnX2FyZyB0IHRhZyB4IHNleHBfb2ZfeCA9XG4gIGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfYXJnICh0YWcsIHNleHBfb2ZfeCB4LCB0b19tZXNzYWdlIHQpKSlcbjs7XG5cbmxldCBvZl9saXN0ID90cnVuY19hZnRlciB0cyA9IGxhenkgKE9mX2xpc3QgKHRydW5jX2FmdGVyLCBMaXN0Lm1hcCB0cyB+Zjp0b19tZXNzYWdlKSlcblxuZXhjZXB0aW9uIEV4biBvZiB0XG5cbmxldCAoKSA9XG4gICgqIFdlIGluc3RhbGwgYSBjdXN0b20gZXhuLWNvbnZlcnRlciByYXRoZXIgdGhhbiB1c2VcbiAgICAgW2V4Y2VwdGlvbiBFeG4gb2YgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF0gLi4uIFtAQEBlbmRdXSB0byBlbGltaW5hdGUgdGhlIGV4dHJhXG4gICAgIHdyYXBwaW5nIG9mIFwiKEV4biAuLi4pXCIuICopXG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeG5dIChmdW5jdGlvblxuICAgIHwgRXhuIHQgLT4gc2V4cF9vZl90IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IHRvX2V4biB0ID1cbiAgaWYgbm90IChMYXp5LmlzX3ZhbCB0KVxuICB0aGVuIEV4biB0XG4gIGVsc2UgKFxuICAgIG1hdGNoIExhenkuZm9yY2UgdCB3aXRoXG4gICAgfCBNZXNzYWdlLkV4biBleG4gLT4gZXhuXG4gICAgfCBfIC0+IEV4biB0KVxuOztcblxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9XG4gIGxldCBiYWNrdHJhY2UgPVxuICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYEdldCAtPlxuICAgICAgU29tZSAoU3RkbGliLlByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gICAgfCBTb21lIChgVGhpcyBzKSAtPiBTb21lIHNcbiAgaW5cbiAgbWF0Y2ggZXhuLCBiYWNrdHJhY2Ugd2l0aFxuICB8IEV4biB0LCBOb25lIC0+IHRcbiAgfCBFeG4gdCwgU29tZSBiYWNrdHJhY2UgLT4gbGF6eSAoV2l0aF9iYWNrdHJhY2UgKHRvX21lc3NhZ2UgdCwgYmFja3RyYWNlKSlcbiAgfCBfLCBOb25lIC0+IExhenkuZnJvbV92YWwgKE1lc3NhZ2UuRXhuIGV4bilcbiAgfCBfLCBTb21lIGJhY2t0cmFjZSAtPiBsYXp5IChXaXRoX2JhY2t0cmFjZSAoU2V4cCAoRXhuLnNleHBfb2ZfdCBleG4pLCBiYWNrdHJhY2UpKVxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbmZvXCJcbiAgICBsZXQgcHAgcHBmIHQgPSBTdGRsaWIuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZ19odW0gdClcbiAgZW5kKVxuXG5tb2R1bGUgSW50ZXJuYWxfcmVwciA9IE1lc3NhZ2VcblxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEwMzIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsInRfc2V4cF9ncmFtbWFyIiwibW9kdWxlX25hbWUiLCJCYXNlX0luZm8iLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiY29tcGFyZSIsImVxdWFsIiwiaGFzaF9mb2xkX3QiLCJoYXNoIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwiaW52YXJpYW50IiwidG9fc3RyaW5nX2h1bSIsInRvX3N0cmluZ19tYWNoIiwidG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIiwib2Zfc3RyaW5nIiwib2ZfbGF6eSIsIm9mX2xhenlfc2V4cCIsIm9mX3RodW5rIiwib2ZfbGF6eV90IiwiY3JlYXRlIiwiY3JlYXRlX3MiLCJjcmVhdGVmIiwidGFnIiwidGFnX3MiLCJ0YWdfc19sYXp5IiwidGFnX2FyZyIsIm9mX2xpc3QiLCJvZl9leG4iLCJ0b19leG4iLCJwcCIsIkludGVybmFsX3JlcHIiLCJyYWlzZSIsInQiLCJyYWlzZV9zIiwic2V4cCIsInRvX2luZm8iLCJvZl9pbmZvIiwiaW5jbHVkZSIsIkJhc2VfRXJyb3IiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9lcnJvci5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsWUFBQUMsTUFBQUM7QUFBQUEsSUNRb0I7QUFBQSxHQUFVO0FBQUEsWUFBQUMsUUFBQUMsTUFDTCxPQUFlLE1BQWYsMkJBQWU7QUFBQSxZQUFBQyxRQUFBSCxHQUN4QixTQUFDO0FBQUEsWUFBQUksUUFBQUosR0FDRCxTQUFDO0FBQUE7QUFBQSxJQUFBSyxVRFhqQjtBQUFBLElBQUFSLE9BQUE7QUFBQSxJQUFBUztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtFcnJvcl0gYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcy4gIFBsZWFzZSBhdm9pZCBhZGRpbmcgbmV3XG4gICBkZXBlbmRlbmNpZXMuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbmZvXG5cbmxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJFcnJvci50XCIgfVxubGV0IHJhaXNlIHQgPSByYWlzZSAodG9fZXhuIHQpXG5sZXQgcmFpc2VfcyBzZXhwID0gcmFpc2UgKGNyZWF0ZV9zIHNleHApXG5sZXQgdG9faW5mbyB0ID0gdFxubGV0IG9mX2luZm8gdCA9IHRcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FcnJvclwiXG4gICAgbGV0IHBwID0gcHBcbiAgZW5kKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEwNDE3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9leG4iLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9GaWVsZCIsIkJhc2VfSW1wb3J0IiwiQmFzZV9TZXhwIiwiQmFzZV9Tb3VyY2VfY29kZV9wb3NpdGlvbjAiLCJCYXNlX0Vycm9yIiwicmFpc2VfcyIsImNzdF9pbnZhcmlhbnRfZmFpbGVkIiwiY3N0X2ZpZWxkIiwiY3N0X3Byb2JsZW1fd2l0aF9maWVsZCIsImludmFyaWFudCIsImhlcmUiLCJ0Iiwic2V4cF9vZl90IiwiZXhuIiwiY2hlY2tfZmllbGQiLCJmaWVsZCIsIkJhc2VfSW52YXJpYW50Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvaW52YXJpYW50Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFSLE1BQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQVMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFiLFVBQUE7QUFBQSxJQUFBYyx1QkFBQTtBQUFBLElBQUFkLFlBQUE7QUFBQSxJQUFBZSxZQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxZQUFBQyxVQUFBQyxNQUFBQyxHQUFBQyxXQUFBakI7QUFBQUEsSUNNRSxjQUFJO0FBQUEsVUFBQWtCO0FBQUFBO0FBQUFBLE1BQUFBLE1ETk47QUFBQSxZQ2FlO0FBQUEsWUFERztBQUFBO0FBQUEsUUFESDtBQUFBLEtBRlQsT0FLSztBQUFBLHVCQUxMLG9EQUtLO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFlBQUFILEdBQUFoQixHQUFBb0I7QUFBQUEsSUFJVDtBQUFBLGVBQUksY0FBRTtBQUFBO0FBQUE7QUFBQSxVQUFBRjtBQUFBQTtBQUFBQSxNQUFBQSxNRGxCUjtBQUFBLFlDdUI4RDtBQUFBLFlBQTNCO0FBQUEsWUFBZjtBQUFBLEtBRmQsT0FFMEU7QUFBQSx1QkFGMUUsc0RBRTBFO0FBQUE7QUFBQTtBQUFBLE9BQUFHLGlCRHZCaEYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnZhcmlhbnRfaW50ZlxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubGV0IGludmFyaWFudCBoZXJlIHQgc2V4cF9vZl90IGYgOiB1bml0ID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiXCIsIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZVxuICAgICAgICAgOyBcImV4blwiLCBzZXhwX29mX2V4biBleG5cbiAgICAgICAgIDsgXCJcIiwgc2V4cF9vZl90IHRcbiAgICAgICAgIF0pXG47O1xuXG5sZXQgY2hlY2tfZmllbGQgdCBmIGZpZWxkID1cbiAgdHJ5IGYgKEZpZWxkLmdldCBmaWVsZCB0KSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJwcm9ibGVtIHdpdGggZmllbGRcIlxuICAgICAgICAgWyBcImZpZWxkXCIsIHNleHBfb2Zfc3RyaW5nIChGaWVsZC5uYW1lIGZpZWxkKTsgXCJleG5cIiwgc2V4cF9vZl9leG4gZXhuIF0pXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEwNDg2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0xpc3QiLCJCYXNlX0Vycm9yIiwiQmFzZV9XaXRoX3JldHVybiIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9SZXN1bHQiLCJCYXNlX0ltcG9ydCIsIkJhc2VfUHJpbnRmIiwiQmFzZV9BcHBsaWNhdGl2ZSIsImNvbXBhcmUiLCJjbXBfYSIsImFfMDAxIiwiYl8wMDIiLCJlcXVhbCIsImFfMDA3IiwiYl8wMDgiLCJoYXNoX2ZvbGRfdCIsImhhc2hfZm9sZF9hIiwiaHN2IiwiYXJnIiwidF9vZl9zZXhwIiwib2ZfYV8wMTMiLCJ4XzAxNSIsInNleHBfb2ZfdCIsIm9mX2FfMDE2IiwieF8wMTciLCJ0X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiYmluZCIsImlnbm9yZV9tIiwiam9pbiIsIm1hcCIsInJldHVybiIsImludmFyaWFudCIsImludmFyaWFudF9hIiwidCIsImEiLCJlcnJvciIsIm1hcDIiLCJiIiwieCIsInkiLCJlIiwiZTEiLCJlMiIsIkZvcl9hcHBsaWNhdGl2ZSIsInN5bWJvbCIsImFwcGx5IiwiYm90aCIsIm1hcDMiLCJpbmNsdWRlIiwiT3Blbl9vbl9yaHMiLCJvayIsImlzX29rIiwiaXNfZXJyb3IiLCJjc3RfdW5pbXBsZW1lbnRlZCIsInRyeV93aXRoIiwib3B0IiwiYmFja3RyYWNlIiwiZXhuIiwidHJ5X3dpdGhfam9pbiIsIm9rX2V4biIsInBhcmFtIiwiZXJyIiwib2ZfZXhuIiwib2ZfZXhuX3Jlc3VsdCIsInoiLCJoZXJlIiwic3RyaWN0IiwibWVzc2FnZSIsInNleHBfb2ZfYSIsImVycm9yX3MiLCJzZXhwIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwiZm9ybWF0IiwidGFnIiwidGFnX3MiLCJ0YWdfc19sYXp5IiwidGFnX2FyZyIsInVuaW1wbGVtZW50ZWQiLCJzIiwiY29tYmluZV9pbnRlcm5hbCIsImxpc3QiLCJvbl9vayIsIm9uX2Vycm9yIiwibWF0Y2giLCJlcnJzIiwiaWdub3JlX3VuaXRfbGlzdCIsImVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5IiwiYWxsIiwiYWxsX3VuaXQiLCJjb21iaW5lX2Vycm9ycyIsImV0YSIsImNvbWJpbmVfZXJyb3JzX3VuaXQiLCJmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIiwibCIsImZpbmRfb2siLCJmaW5kX21hcF9vayIsImVsdCIsIml0ZXIiLCJpdGVyX2Vycm9yIiwiQmFzZV9Pcl9lcnJvciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL29yX2Vycm9yLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsUUFBQUMsT0FBQUMsT0FBQUM7QUFBQUEsSUNNaUMscUVBQW9EO0FBQUE7QUFBQSxZQUFBQyxNQUFBSCxPQUFBSSxPQUFBQztBQUFBQSxJQUlwRCxxRUFBZ0Q7QUFBQTtBQUFBLFlBQUFDLFlBQUFDLGFBQUFDLEtBQUFDO0FBQUFBLElBVW5ELHVFQUF5RDtBQUFBO0FBQUEsWUFBQUMsVUFBQUMsVUFBQUM7QUFBQUEsSUFJMUQsaUVBQW9EO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxVQUFBQztBQUFBQSxJQUlwRCxpRUFBb0Q7QUFBQTtBQUFBLFlBQUFDLGVBQUFDO0FBQUFBLElBSXZELGdFQUEyRDtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjRGhDckY7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxVQUFBQyxhQUFBQztBQUFBQSxJQ2dERSxtQkFBQUMsSUFBQSxNQUNVLGlDQUM0QjtBQUFBLFFBQUFDLFFBRnRDO0FBQUEsSUFFaUIsdUNBQXFCO0FBQUE7QUFBQSxZQUFBQyxLQUFBRixHQUFBRyxHQUFBbkQ7QUFBQUEsSUFJdEM7QUFBQSxTQUFBb0QsSUFBQTtBQUFBLHdCQUFBQyxJQUFBLE1BQ21CLCtCQUFPO0FBQUEsU0FBQUMsSUFEMUI7QUFBQTtBQUFBO0FBQUEsU0FBQUMsS0FBQTtBQUFBO0FBQUEsVUFBQUMsS0FBQTtBQUFBLE1BRzhCLDhEQUEwQjtBQUFBO0FBQUEsU0FBQUYsSUFIeEQ7QUFBQTtBQUFBLElBRWlEO0FBQUEsR0FDTztBQUFBO0FBQUEsSUFBQVgsUUR6RDFEO0FBQUEsSUFBQWM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBeEIsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQXdCLGNBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUE7QUFBQSxZQUFBQyxTQUFBQyxLQUFBckU7QUFBQUEsUUFBQXNFLFlDaUdhO0FBQUEsSUFDWCxjQUFPO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTURsR1Qsa0NDbUdXO0FBQUEsS0FBTSxnREFBcUU7QUFBQTtBQUFBO0FBQUEsWUFBQUMsY0FBQUYsV0FBQXRFO0FBQUFBLElBR2hELE9BQXVCLGlCQUF2Qix1QkFBdUI7QUFBQTtBQUFBLFlBQUF5RSxPQUFBQztBQUFBQSxJQUVoRCx1QkFBQXRCLElBQUEsVUFDRDtBQUFBLFFBQUF1QixNQURDO0FBQUEsSUFFSSxzQ0FBZTtBQUFBO0FBQUEsWUFBQUMsT0FBQU4sV0FBQUM7QUFBQUEsSUFHRSxzREFBNkI7QUFBQTtBQUFBLFlBQUFNLGNBQUFQLFdBQUFRO0FBQUFBLElBRTdDLGVBQ0Q7QUFBQSxRQUFBUCxNQURDO0FBQUEsSUFFRCw2QkFBcUI7QUFBQTtBQUFBLFlBQUF0QixNQUFBOEIsTUFBQUMsUUFBQUMsU0FBQWpDLEdBQUFrQztBQUFBQSxJQUk5QjtBQUFBLDRFQUFnRDtBQUFBO0FBQUEsWUFBQUMsUUFBQUMsTUFHL0IsNENBQXFCO0FBQUEsWUFBQUMsYUFBQUo7QUFBQUEsSUFDYiwrQ0FBeUI7QUFBQTtBQUFBLFlBQUFLLE9BQUFDO0FBQUFBLElBQ3RDLHVEQUFtQztBQUFBO0FBQUEsWUFBQUMsSUFBQXpDLEdBQUF5QztBQUFBQSxRQUFBLE1BQ3RDO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJEM0hqQixtQ0MySHVEO0FBQUE7QUFBQSxZQUFBQyxNQUFBMUMsR0FBQXlDO0FBQUFBLFFBQUEsTUFDcEM7QUFBQTtBQUFBO0FBQUE7QUFBQSwyQkQ1SG5CLG1DQzRIMkQ7QUFBQTtBQUFBLFlBQUFFLFdBQUEzQyxHQUFBeUM7QUFBQUEsUUFBQSxNQUNuQztBQUFBO0FBQUE7QUFBQTtBQUFBLDJCRDdIeEIsbUNDNkhxRTtBQUFBO0FBQUEsWUFBQUcsUUFBQTVDLEdBQUFrQyxTQUFBakMsR0FBQWtDO0FBQUFBLElBR25FO0FBQUE7QUFBQTtBQUFBLHNCQUFBNUI7QUFBQUEsY0FBZ0MsMkRBQW1DO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQXNDLGNBQUFDO0FBQUFBLElBR2hELDBEQUFzQztBQUFBO0FBQUEsWUFBQUMsaUJBQUFDLE1BQUFDLE9BQUFDO0FBQUFBLFFBQUFDLFFBSXBEO0FBQUEsSUFBMEIsdUJBQUE5QyxJQUFBLFVBQ25CLGdDQUFTO0FBQUEsUUFBQStDLE9BRFU7QUFBQSxJQUVWLHNDQUFlO0FBQUE7QUFBQSxZQUFBQyxpQkFBQTFCLE9BR0EsU0FBRTtBQUFBLFlBQUEyQiwyQkFBQU47QUFBQUEsSUFFUiwwQkFBQXpDLElBQUEsU0FDcEI7QUFBQSxJQUNELDBDQUFrQjtBQUFBO0FBQUEsWUFBQWdELElBQUFQO0FBQUFBLElBR2Y7QUFBQSxpQ0RuSmYseUNDbUpzRjtBQUFBO0FBQUEsWUFBQVEsU0FBQVI7QUFBQUEsSUFHcEY7QUFBQSxnRUFBa0Y7QUFBQTtBQUFBLFlBQUFTLGVBQUFUO0FBQUFBLFFBQUFsRSxNQUcxRDtBQUFBO0FBQUE7QUFBQSwyQkR6SjFCO0FBQUEsc0JBQUE0RSxLQUFBLGlDQ3lKb0Y7QUFBQTtBQUFBLFlBQUFDLG9CQUFBWDtBQUFBQSxRQUFBbEUsTUFHbEY7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQTRFLEtENUpGLGlDQzRKdUU7QUFBQTtBQUFBLFlBQUFFLHVCQUFBQztBQUFBQTtBQUFBQSxLQUFBVixRQUl0RDtBQUFBLEtBQUFDLE9BQXdDO0FBQUEsS0FBQW5DLEtBQUE7QUFBQSxJQUN2RCwwQkFDYyxvQ0FDRjtBQUFBO0FBQUEsWUFBQTZDLFFBQUFEO0FBQUFBLFFBQUFWLFFBSU47QUFBQSxJQUE0QixjQUFBOUMsSUFBQSxVQUN0QjtBQUFBO0FBQUE7QUFBQSxPQUlMO0FBQUE7QUFBQTtBQUFBLGtCQUFBc0I7QUFBQUEsVUFBZTtBQUFBLFdBQ0Y7QUFBQSxjQUFBQyxNQURFO0FBQUEsVUFFRztBQUFBLFNBQUk7QUFBQSxJQUh6Qiw4Q0FHMkI7QUFBQTtBQUFBLFlBQUFtQyxZQUFBRixHQUFBNUc7QUFBQUEsSUFJL0I7QUFBQTtBQUFBLHNCQUFBMEU7QUFBQUE7QUFBQUEsZUFBQTtBQUFBLGlCQUdPO0FBQUE7QUFBQTtBQUFBLDRCQUFBcUM7QUFBQUEsd0JBQUEzRCxJQUNTO0FBQUEsb0JBQUssZUFDSSwyQkFDRztBQUFBLHdCQUFBdUIsTUFGUDtBQUFBLG9CQUVJO0FBQUEsbUJBQUc7QUFBQSxjQUp4Qiw4Q0FJMkI7QUFBQSxhQUFDO0FBQUE7QUFBQTtBQUFBLElBQUFoQyxRRHhMbEM7QUFBQSxJQUFBcUUsT0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID0gKCdhLCBFcnJvci50KSBSZXN1bHQudFxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT4gUmVzdWx0LmNvbXBhcmUgX2NtcF9fYSBFcnJvci5jb21wYXJlIGFfXzAwMV8gYl9fMDAyX1xuOztcblxubGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9XG4gIGZ1biBfY21wX19hIGFfXzAwN18gYl9fMDA4XyAtPiBSZXN1bHQuZXF1YWwgX2NtcF9fYSBFcnJvci5lcXVhbCBhX18wMDdfIGJfXzAwOF9cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA6XG4gICdhLlxuICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gIC0+ICdhIHRcbiAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfYSBoc3YgYXJnIC0+IFJlc3VsdC5oYXNoX2ZvbGRfdCBfaGFzaF9mb2xkX2EgRXJyb3IuaGFzaF9mb2xkX3QgaHN2IGFyZ1xuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biBfb2ZfYV9fMDEzXyB4X18wMTVfIC0+IFJlc3VsdC50X29mX3NleHAgX29mX2FfXzAxM18gRXJyb3IudF9vZl9zZXhwIHhfXzAxNV9cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAxNl8geF9fMDE3XyAtPiBSZXN1bHQuc2V4cF9vZl90IF9vZl9hX18wMTZfIEVycm9yLnNleHBfb2ZfdCB4X18wMTdfXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IFJlc3VsdC50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyIEVycm9yLnRfc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgKCA+Pj0gKSA9IFJlc3VsdC4oID4+PSApXG5sZXQgKCA+PnwgKSA9IFJlc3VsdC4oID4+fCApXG5sZXQgYmluZCA9IFJlc3VsdC5iaW5kXG5sZXQgaWdub3JlX20gPSBSZXN1bHQuaWdub3JlX21cbmxldCBqb2luID0gUmVzdWx0LmpvaW5cbmxldCBtYXAgPSBSZXN1bHQubWFwXG5sZXQgcmV0dXJuID0gUmVzdWx0LnJldHVyblxuXG5tb2R1bGUgTW9uYWRfaW5maXggPSBSZXN1bHQuTW9uYWRfaW5maXhcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgYSAtPiBpbnZhcmlhbnRfYSBhXG4gIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IuaW52YXJpYW50IGVycm9yXG47O1xuXG5sZXQgbWFwMiBhIGIgfmYgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBPayB4LCBPayB5IC0+IE9rIChmIHggeSlcbiAgfCBPayBfLCAoRXJyb3IgXyBhcyBlKSB8IChFcnJvciBfIGFzIGUpLCBPayBfIC0+IGVcbiAgfCBFcnJvciBlMSwgRXJyb3IgZTIgLT4gRXJyb3IgKEVycm9yLm9mX2xpc3QgWyBlMTsgZTIgXSlcbjs7XG5cbm1vZHVsZSBGb3JfYXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZS5NYWtlX3VzaW5nX21hcDJfbG9jYWwgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgbGV0IG1hcDIgPSBtYXAyXG4gIGVuZClcblxubGV0ICggKj4gKSA9IEZvcl9hcHBsaWNhdGl2ZS4oICo+IClcbmxldCAoIDwqICkgPSBGb3JfYXBwbGljYXRpdmUuKCA8KiApXG5sZXQgKCA8Kj4gKSA9IEZvcl9hcHBsaWNhdGl2ZS4oIDwqPiApXG5sZXQgYXBwbHkgPSBGb3JfYXBwbGljYXRpdmUuYXBwbHlcbmxldCBib3RoID0gRm9yX2FwcGxpY2F0aXZlLmJvdGhcbmxldCBtYXAzID0gRm9yX2FwcGxpY2F0aXZlLm1hcDNcblxubW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gRm9yX2FwcGxpY2F0aXZlLkFwcGxpY2F0aXZlX2luZml4XG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgKCogZnJvbSBBcHBsaWNhdGl2ZS5NYWtlICopXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICBlbmRcbmVuZFxuXG5sZXQgb2sgPSBSZXN1bHQub2tcbmxldCBpc19vayA9IFJlc3VsdC5pc19va1xubGV0IGlzX2Vycm9yID0gUmVzdWx0LmlzX2Vycm9yXG5cbmxldCB0cnlfd2l0aCA/KGJhY2t0cmFjZSA9IGZhbHNlKSBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuID9iYWNrdHJhY2U6KGlmIGJhY2t0cmFjZSB0aGVuIFNvbWUgYEdldCBlbHNlIE5vbmUpKVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gP2JhY2t0cmFjZSBmID0gam9pbiAodHJ5X3dpdGggP2JhY2t0cmFjZSBmKVxuXG5sZXQgb2tfZXhuID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBlcnIgLT4gRXJyb3IucmFpc2UgZXJyXG47O1xuXG5sZXQgb2ZfZXhuID9iYWNrdHJhY2UgZXhuID0gRXJyb3IgKEVycm9yLm9mX2V4biA/YmFja3RyYWNlIGV4bilcblxubGV0IG9mX2V4bl9yZXN1bHQgP2JhY2t0cmFjZSA9IGZ1bmN0aW9uXG4gIHwgT2sgXyBhcyB6IC0+IHpcbiAgfCBFcnJvciBleG4gLT4gb2ZfZXhuID9iYWNrdHJhY2UgZXhuXG47O1xuXG5sZXQgZXJyb3IgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRXJyb3IgKEVycm9yLmNyZWF0ZSA/aGVyZSA/c3RyaWN0IG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgZXJyb3JfcyBzZXhwID0gRXJyb3IgKEVycm9yLmNyZWF0ZV9zIHNleHApXG5sZXQgZXJyb3Jfc3RyaW5nIG1lc3NhZ2UgPSBFcnJvciAoRXJyb3Iub2Zfc3RyaW5nIG1lc3NhZ2UpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBlcnJvcl9zdHJpbmcgZm9ybWF0XG5sZXQgdGFnIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnIH50YWcpXG5sZXQgdGFnX3MgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfc19sYXp5IH50YWcpXG5cbmxldCB0YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooZnVuIGUgLT4gRXJyb3IudGFnX2FyZyBlIG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgdW5pbXBsZW1lbnRlZCBzID0gZXJyb3IgXCJ1bmltcGxlbWVudGVkXCIgcyBzZXhwX29mX3N0cmluZ1xuXG5cbmxldCBjb21iaW5lX2ludGVybmFsIGxpc3Qgfm9uX29rIH5vbl9lcnJvciA9XG4gIG1hdGNoIFJlc3VsdC5jb21iaW5lX2Vycm9ycyBsaXN0IHdpdGhcbiAgfCBPayB4IC0+IE9rIChvbl9vayB4KVxuICB8IEVycm9yIGVycnMgLT4gRXJyb3IgKG9uX2Vycm9yIGVycnMpXG47O1xuXG5sZXQgaWdub3JlX3VuaXRfbGlzdCAoXyA6IHVuaXQgbGlzdCkgPSAoKVxuXG5sZXQgZXJyb3Jfb2ZfbGlzdF9pZl9uZWNlc3NhcnkgPSBmdW5jdGlvblxuICB8IFsgZSBdIC0+IGVcbiAgfCBsaXN0IC0+IEVycm9yLm9mX2xpc3QgbGlzdFxuOztcblxubGV0IGFsbCBsaXN0ID0gY29tYmluZV9pbnRlcm5hbCBsaXN0IH5vbl9vazpGbi5pZCB+b25fZXJyb3I6ZXJyb3Jfb2ZfbGlzdF9pZl9uZWNlc3NhcnlcblxubGV0IGFsbF91bml0IGxpc3QgPVxuICBjb21iaW5lX2ludGVybmFsIGxpc3Qgfm9uX29rOmlnbm9yZV91bml0X2xpc3Qgfm9uX2Vycm9yOmVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5XG47O1xuXG5sZXQgY29tYmluZV9lcnJvcnMgbGlzdCA9IGNvbWJpbmVfaW50ZXJuYWwgbGlzdCB+b25fb2s6Rm4uaWQgfm9uX2Vycm9yOkVycm9yLm9mX2xpc3RcblxubGV0IGNvbWJpbmVfZXJyb3JzX3VuaXQgbGlzdCA9XG4gIGNvbWJpbmVfaW50ZXJuYWwgbGlzdCB+b25fb2s6aWdub3JlX3VuaXRfbGlzdCB+b25fZXJyb3I6RXJyb3Iub2ZfbGlzdFxuOztcblxubGV0IGZpbHRlcl9va19hdF9sZWFzdF9vbmUgbCA9XG4gIGxldCBvaywgZXJycyA9IExpc3QucGFydGl0aW9uX21hcCBsIH5mOlJlc3VsdC50b19laXRoZXIgaW5cbiAgbWF0Y2ggb2sgd2l0aFxuICB8IFtdIC0+IEVycm9yIChFcnJvci5vZl9saXN0IGVycnMpXG4gIHwgXyAtPiBPayBva1xuOztcblxubGV0IGZpbmRfb2sgbCA9XG4gIG1hdGNoIExpc3QuZmluZF9tYXAgbCB+ZjpSZXN1bHQub2sgd2l0aFxuICB8IFNvbWUgeCAtPiBPayB4XG4gIHwgTm9uZSAtPlxuICAgIEVycm9yXG4gICAgICAoRXJyb3Iub2ZfbGlzdFxuICAgICAgICAgKExpc3QubWFwIGwgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICB8IE9rIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IEVycm9yIGVyciAtPiBlcnIpKSlcbjs7XG5cbmxldCBmaW5kX21hcF9vayBsIH5mID1cbiAgV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgRXJyb3JcbiAgICAgIChFcnJvci5vZl9saXN0XG4gICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgbWF0Y2ggZiBlbHQgd2l0aFxuICAgICAgICAgICAgfCBPayBfIGFzIHggLT4gcmV0dXJuIHhcbiAgICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKSkgW0Bub250YWlsXVxuOztcblxubGV0IG1hcCA9IFJlc3VsdC5tYXBcbmxldCBpdGVyID0gUmVzdWx0Lml0ZXJcbmxldCBpdGVyX2Vycm9yID0gUmVzdWx0Lml0ZXJfZXJyb3JcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDgwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfTmVnIiwiY3N0X1BvcyIsImNzdF9aZXJvIiwiY3N0X25lZyIsImNzdF9wb3MiLCJjc3RfemVybyIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJlcnJvcl9zb3VyY2VfMDAzIiwidF9zZXhwX2dyYW1tYXIiLCJhbGwiLCJtb2R1bGVfbmFtZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9Qb2x5MCIsIkJhc2VfSGFzaCIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsInRfb2Zfc2V4cCIsInNleHBfMDA0Iiwic2V4cF9vZl90IiwicGFyYW0iLCJjb21wYXJlIiwiaGFzaF9mb2xkX3QiLCJoc3YiLCJhcmciLCJzeW1ib2wiLCJ4IiwieSIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJlcXVhbCIsIm1heCIsIm1pbiIsIlJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSIsIm9mX3N0cmluZyIsInMiLCJ0b19zdHJpbmciLCJ0IiwidG9faW50Iiwib2ZfaW50IiwibiIsIkJhc2VfU2lnbjAiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9zaWduMC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxVQ1lHO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBO0FBQUFBO0FBQUFBLEtBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBRTBDO0FBQUE7QUFBQSxPQUNGO0FBQUE7QUFBQSxNQUZBO0FBQUE7QUFBQSxlQUR4QztBQUFBO0FBQUEsTUFhRTtBQUFBLHVFQUNvRjtBQUFBLGVBZHRGO0FBQUE7QUFBQSxNQVdFO0FBQUEsdUVBR29GO0FBQUEsZUFkdEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQU9FO0FBQUEsd0VBT29GO0FBQUE7QUFBQSxNQUxwRjtBQUFBLHVFQUtvRjtBQUFBO0FBQUEsS0FUcEY7QUFBQSxzRUFTb0Y7QUFBQTtBQUFBLElBQXRFLDBFQUFzRTtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUFLdEYsc0JBQ1UsbUJBQ0Msb0JBQ0Q7QUFBQTtBQUFBLEdBQXdCO0FBQUEsT0FBQUMsVUF0QmxDO0FBQUEsWUFBQUMsWUFBQUMsS0FBQUM7QUFBQUEsSUEyQ0U7QUFBQTtBQUFBLE9BQ1MsdUNBRW9DO0FBQUE7QUFBQSxPQURuQyx1Q0FDbUM7QUFBQSxlQUFwQyx1Q0FBb0M7QUFBQTtBQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0FBQUMsR0FrQjFCLHFCQUFjO0FBQUEsWUFBQUYsU0FBQUMsR0FBQUMsR0FDYixzQkFBZTtBQUFBLFlBQUFGLFNBQUFDLEdBQUFDLEdBQ2YsdUJBQWU7QUFBQSxZQUFBRixTQUFBQyxHQUFBQyxHQUNoQix1QkFBYztBQUFBLFlBQUFGLFNBQUFDLEdBQUFDLEdBQ2QscUJBQWM7QUFBQSxZQUFBRixTQUFBQyxHQUFBQyxHQUNiLHNCQUFlO0FBQUEsWUFBQUMsVUFBQUYsR0FBQUMsR0FDWixzQ0FBa0I7QUFBQSxZQUFBRSxXQUFBSCxHQUFBQyxHQUNqQixzQ0FBbUI7QUFBQSxPQUFBTixZQWY5QztBQUFBLFlBQUFTLE1BQUFKLEdBQUFDLEdBaUJzQix1QkFBYztBQUFBLFlBQUFJLElBQUFMLEdBQUFDLEdBQ1AscUJBQWM7QUFBQSxZQUFBSyxJQUFBTixHQUFBQyxHQUNkLHFCQUFjO0FBQUE7QUFBQSxJQUFBTTtBQUFBQSxNQW5CM0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxHQXNCMEIsT0FBa0IsVUFBbEIsZ0NBQWtCO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsUUFBQSxNQUNiO0FBQUEsSUFBYTtBQUFBO0FBQUEsWUFBQUMsT0FBQWxCO0FBQUFBLElBRWpDLHNCQUNGLGtCQUNDLGtCQUNEO0FBQUE7QUFBQSxHQUFDO0FBQUEsWUFBQW1CLE9BQUFDLEdBUUcsbUNBQWtEO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQXBDL0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHBFRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBpcyBicm9rZW4gb2ZmIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBTaWduIGFuZCBDb21wYXJhYmxlLiAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBOZWdcbiAgfCBaZXJvXG4gIHwgUG9zXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbmxldCB0X29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDAzXyA9IFwic2lnbjAubWwudFwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSAtPiBOZWdcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIC0+IFBvc1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgc2V4cF9fMDAyXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICAgICAgICAgICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbjs7XG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IE5lZyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOZWdcIlxuICAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIk5lZ1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBOZWcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgIHwgWmVybyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBQb3MgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5sZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3MgXSA6IHQgbGlzdClcblxuW0BAQGVuZF1cblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiB0KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogdCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogdCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IHQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogdCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xXG4gIHwgWmVybyAtPiAwXG4gIHwgUG9zIC0+IDFcbjs7XG5cbmxldCBfID0gaGFzaFxuXG4oKiBJZ25vcmUgdGhlIGhhc2ggZnVuY3Rpb24gcHJvZHVjZWQgYnkgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2hdICopXG5sZXQgaGFzaCA9IHRvX2ludFxubGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlNpZ25cIlxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBOZWcgZWxzZSBpZiBuID0gMCB0aGVuIFplcm8gZWxzZSBQb3NcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDk2NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0NvbXBhcmFibGVfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsdUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDk3NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsImNzdF9tYXgiLCJjc3RfbWluIiwiY3N0X3NyY19jb21wYXJhYmxlX21sIiwiY2FtbF9jb21wYXJlIiwiY2FtbF9lcXVhbCIsImNhbWxfZ3JlYXRlcnRoYW4iLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0NvbXBhcmF0b3IiLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX1BvbHkwIiwiQmFzZV9TaWduMCIsImdlcSIsImNtcCIsImEiLCJiIiwibGVxIiwiZXF1YWwiLCJtaW4iLCJ0IiwibWF4IiwiSW5maXgiLCJUIiwic3ltYm9sIiwiQ29tcGFyaXNvbnMiLCJpbmNsdWRlIiwiY29tcGFyZSIsIk1ha2VfdXNpbmdfY29tcGFyYXRvciIsInNleHBfb2ZfdCIsImNvbXBhcmF0b3IiLCJSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUiLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImxvdyIsImhpZ2giLCJjbGFtcF91bmNoZWNrZWQiLCJjbGFtcF9leG4iLCJjbGFtcCIsIk1ha2UiLCJJbmhlcml0IiwiQyIsImxleGljb2dyYXBoaWMiLCJjbXBzIiwieCIsInkiLCJwYXJhbSIsInJlcyIsImxpZnQiLCJyZXZlcnNlIiwiY29tcGFyZV9yZXZlcnNlZCIsIkJhc2VfQ29tcGFyYWJsZSIsImFzY2VuZGluZyIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvY29tcGFyYWJsZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQywrQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQTtBQUFBLElBQUFwQixV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LGdCQUF4QjtBQUFBLGdCQUZaO0FBQUEsU0FFc0QseUNBQ3JCO0FBQUE7QUFBQTtBQUFBLFNBQUFLO0FBQUFBLFdEekR6QztBQUFBLFNBQUFJLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUF1QixZQUFBakMsR0Nlc0IsMENBQWMsQ0FBSTtBQUFBLGlCQUFBa0MsZ0JBQUFsQztBQUFBQSxTQUNkLDJDQUFjO0FBQUEsUUFBSztBQUFBLGlCQUFBbUMsWUFBQW5DLEdBQ3ZCLDBDQUFjLENBQUk7QUFBQSxpQkFBQW9DLGdCQUFBcEM7QUFBQUEsU0FDZCwyQ0FBYztBQUFBLFFBQUs7QUFBQSxpQkFBQXFDLEtBQUFyQztBQUFBQSxhQUFBLE1BQ2pCO0FBQUEsU0FBZ0I7QUFBQTtBQUFBLFFEbkI1QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvbXBhcmFibGVfaW50ZlxuXG5tb2R1bGUgV2l0aF96ZXJvIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgemVybyA6IHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUXG5cbiAgbGV0IGlzX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+IDBcbiAgbGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPj0gMFxuICBsZXQgaXNfbmVnYXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDwgMFxuICBsZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA8PSAwXG4gIGxldCBzaWduIHQgPSBTaWduMC5vZl9pbnQgKGNvbXBhcmUgdCB6ZXJvKVxuZW5kXG5cbm1vZHVsZSBQb2x5IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgUG9seVxuICBlbmRcblxuICBpbmNsdWRlIFBvbHlcblxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcblxuICBtb2R1bGUgQyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUpXG4gIGVuZFxuXG4gIGluY2x1ZGUgQ1xuZW5kXG5cbmxldCBndCBjbXAgYSBiID0gY21wIGEgYiA+IDBcbmxldCBsdCBjbXAgYSBiID0gY21wIGEgYiA8IDBcbmxldCBnZXEgY21wIGEgYiA9IGNtcCBhIGIgPj0gMFxubGV0IGxlcSBjbXAgYSBiID0gY21wIGEgYiA8PSAwXG5sZXQgZXF1YWwgY21wIGEgYiA9IGNtcCBhIGIgPSAwXG5sZXQgbm90X2VxdWFsIGNtcCBhIGIgPSBjbXAgYSBiIDw+IDBcbmxldCBtaW4gY21wIHQgdCcgPSBpZiBsZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcbmxldCBtYXggY21wIHQgdCcgPSBpZiBnZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcblxubW9kdWxlIEluZml4IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgOiBJbmZpeCB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgbGV0ICggPiApIGEgYiA9IGd0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPCApIGEgYiA9IGx0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPj0gKSBhIGIgPSBnZXEgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8PSApIGEgYiA9IGxlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoID0gKSBhIGIgPSBlcXVhbCBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw+ICkgYSBiID0gbm90X2VxdWFsIFQuY29tcGFyZSBhIGJcbmVuZFxuW0BAaW5saW5lIGFsd2F5c11cblxubW9kdWxlIENvbXBhcmlzb25zIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgOiBDb21wYXJpc29ucyB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeCAoVClcblxuICBsZXQgY29tcGFyZSA9IFQuY29tcGFyZVxuICBsZXQgZXF1YWwgPSAoID0gKVxuICBsZXQgbWluIHQgdCcgPSBtaW4gY29tcGFyZSB0IHQnXG4gIGxldCBtYXggdCB0JyA9IG1heCBjb21wYXJlIHQgdCdcbmVuZFxuW0BAaW5saW5lIGFsd2F5c11cblxubW9kdWxlIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kKSA6IFMgd2l0aCB0eXBlIHQgOj0gVC50IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFQuY29tcGFyYXRvcl93aXRuZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgY29tcGFyZSA9IGNvbXBhcmF0b3IuY29tcGFyZVxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgbW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IENvbXBhcmlzb25zIChUKVxuICBpbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhc2NlbmRpbmcgPSBjb21wYXJlXG4gIGxldCBkZXNjZW5kaW5nIHQgdCcgPSBjb21wYXJlIHQnIHRcbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbiAgTWFrZV91c2luZ19jb21wYXJhdG9yIFtAaW5saW5lZCBoaW50XSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG4gIGVuZClcblxubW9kdWxlIEluaGVyaXQgKEMgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSAoVCA6IHNpZ1xuICAgICAgICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICAgICAgW0BAQGVuZF1cblxuICAgICAgICAgIHZhbCBjb21wb25lbnQgOiB0IC0+IEMudFxuICAgICAgICBlbmQpID1cbiAgTWFrZSAoc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjb21wYXJlIHQgdCcgPSBDLmNvbXBhcmUgKFQuY29tcG9uZW50IHQpIChULmNvbXBvbmVudCB0JylcbiAgZW5kKVxuXG4oKiBjb21wYXJlIFt4XSBhbmQgW3ldIGxleGljb2dyYXBoaWNhbGx5IHVzaW5nIGZ1bmN0aW9ucyBpbiB0aGUgbGlzdCBbY21wc10gKilcbmxldCBsZXhpY29ncmFwaGljIGNtcHMgeCB5ID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IGNtcCA6OiBjbXBzIC0+XG4gICAgICBsZXQgcmVzID0gY21wIHggeSBpblxuICAgICAgaWYgcmVzID0gMCB0aGVuIGxvb3AgY21wcyBlbHNlIHJlc1xuICAgIHwgW10gLT4gMFxuICBpblxuICBsb29wIGNtcHNcbjs7XG5cbmxldCBsaWZ0IGNtcCB+ZiB4IHkgPSBjbXAgKGYgeCkgKGYgeSlcbmxldCByZXZlcnNlIGNtcCB4IHkgPSBjbXAgeSB4XG5cbnR5cGUgJ2EgcmV2ZXJzZWQgPSAnYVxuXG5sZXQgY29tcGFyZV9yZXZlcnNlZCBjbXAgeCB5ID0gY21wIHkgeFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMjQ1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDIiLCJmIiwiYTAiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJlcXVhbCIsImEiLCJiIiwiaGFzaF9wYXJhbSIsImhhc2giLCJwb2x5IiwicGFyYW0iLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJzZXhwX29mX3QiLCJjb21wYXJlIiwiSGFzaGFibGUiLCJCYXNlX0hhc2hhYmxlX2ludGYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9oYXNoYWJsZV9pbnRmLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0FBQUM7QUFBQUEsUUFBQSxNQzJDSTtBQUFBLElBQWM7QUFBQTtBQUFBO0FBQUEsZUFDVjtBQUFBLEtBQXdCO0FBQUEsZ0JBQ3JCO0FBQUEsTUFBOEIsdURBQ0s7QUFBQSxnQkFETDtBQUFBO0FBQUE7QUFBQSxnQkFEVDtBQUFBO0FBQUEsSUFEZDtBQUFBLEdBRzRCO0FBQUE7QUFBQSxJQUFBQyxhRDlDOUM7QUFBQSxJQUFBQyxPQUFBO0FBQUE7QUFBQSxJQUFBQyxPQUFBLHlDQUFBQyxPQ21EbUUsV0FBYTtBQUFBLFlBQUFDLE9BQUFDLEtBRzVFLG1DQUFxRTtBQUFBLFlBQUFDLE9BQUFIO0FBQUFBLFFBQUFJLFlBRzVELFVBQUFDLFVBQUEsVUFBQVAsT0FBQTtBQUFBLElBQ1Q7QUFBQSxHQU9rQjtBQUFBO0FBQUEsSUFBQVEsV0RqRXRCO0FBQUEsSUFBQVosVUFBQTtBQUFBLElBQUFHLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFFLFdBQUE7QUFBQSxJQUFBRSxXQUFBO0FBQUEsSUFBQUk7QUFBQUEsTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbigqKiBAY2Fub25pY2FsIEJhc2UuSGFzaGFibGUuS2V5ICopXG5tb2R1bGUgdHlwZSBLZXkgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cblxuICAoKiogVmFsdWVzIHJldHVybmVkIGJ5IFtoYXNoXSBtdXN0IGJlIG5vbi1uZWdhdGl2ZS4gIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHJhaXNlZCBpbiB0aGVcbiAgICAgIGNhc2UgdGhhdCBbaGFzaF0gcmV0dXJucyBhIG5lZ2F0aXZlIHZhbHVlLiAqKVxuICB2YWwgaGFzaCA6IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIEhhc2hhYmxlID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBoYXNoIDogJ2EgLT4gaW50XG4gICAgOyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gICAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgKCoqIFRoaXMgZnVuY3Rpb24gaXMgc291bmQgYnV0IG5vdCBjb21wbGV0ZSwgbWVhbmluZyB0aGF0IGlmIGl0IHJldHVybnMgW3RydWVdIHRoZW4gaXQnc1xuICAgICAgc2FmZSB0byB1c2UgdGhlIHR3byBpbnRlcmNoYW5nZWFibHkuICBJZiBpdCdzIFtmYWxzZV0sIHlvdSBoYXZlIG5vIGd1YXJhbnRlZXMuICBGb3JcbiAgICAgIGV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgID4gdXRvcFxuICAgICAgICBvcGVuIENvcmU7O1xuICAgICAgICBsZXQgZXF1YWwgKGEgOiAnYSBIYXNodGJsX2ludGYuSGFzaGFibGUudCkgYiA9XG4gICAgICAgICAgcGh5c19lcXVhbCBhIGJcbiAgICAgICAgICB8fCAocGh5c19lcXVhbCBhLmhhc2ggYi5oYXNoXG4gICAgICAgICAgICAgICYmIHBoeXNfZXF1YWwgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgICAgICAgICAgICAmJiBwaHlzX2VxdWFsIGEuc2V4cF9vZl90IGIuc2V4cF9vZl90KVxuICAgICAgICA7O1xuICAgICAgICBsZXQgYSA9IEhhc2h0YmxfaW50Zi5IYXNoYWJsZS57IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCA9IEludC5zZXhwX29mX3QgfTs7XG4gICAgICAgIGxldCBiID0gSGFzaHRibF9pbnRmLkhhc2hhYmxlLnsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90ID0gSW50LnNleHBfb2ZfdCB9OztcbiAgICAgICAgZXF1YWwgYSBiOzsgICgqIGZhbHNlPyEgKilcbiAgICAgIF19XG4gICopXG4gIGxldCBlcXVhbCBhIGIgPVxuICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgfHwgKHBoeXNfZXF1YWwgYS5oYXNoIGIuaGFzaFxuICAgICAgICAmJiBwaHlzX2VxdWFsIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICAgICAgJiYgcGh5c19lcXVhbCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgaGFzaF9wYXJhbSA9IFN0ZGxpYi5IYXNodGJsLmhhc2hfcGFyYW1cbiAgbGV0IGhhc2ggPSBTdGRsaWIuSGFzaHRibC5oYXNoXG4gIGxldCBwb2x5ID0geyBoYXNoOyBjb21wYXJlID0gUG9seS5jb21wYXJlOyBzZXhwX29mX3QgPSAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB9XG5cbiAgbGV0IG9mX2tleSAodHlwZSBhKSAobW9kdWxlIEtleSA6IEtleSB3aXRoIHR5cGUgdCA9IGEpID1cbiAgICB7IGhhc2ggPSBLZXkuaGFzaDsgY29tcGFyZSA9IEtleS5jb21wYXJlOyBzZXhwX29mX3QgPSBLZXkuc2V4cF9vZl90IH1cbiAgOztcblxuICBsZXQgdG9fa2V5ICh0eXBlIGEpIHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH0gPVxuICAgIChtb2R1bGUgc3RydWN0XG4gICAgICB0eXBlIHQgPSBhXG5cbiAgICAgIGxldCBoYXNoID0gaGFzaFxuICAgICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gICAgZW5kIDogS2V5XG4gICAgICB3aXRoIHR5cGUgdCA9IGEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBIYXNoYWJsZVxuXG5tb2R1bGUgdHlwZSBIYXNoYWJsZSA9IHNpZ1xuICB0eXBlICdhIHQgPSAnYSBIYXNoYWJsZS50ID1cbiAgICB7IGhhc2ggOiAnYSAtPiBpbnRcbiAgICA7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICB2YWwgcG9seSA6ICdhIHRcbiAgdmFsIG9mX2tleSA6IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpIC0+ICdhIHRcbiAgdmFsIHRvX2tleSA6ICdhIHQgLT4gKG1vZHVsZSBLZXkgd2l0aCB0eXBlIHQgPSAnYSlcbiAgdmFsIGhhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+ICdhIC0+IGludFxuICB2YWwgaGFzaCA6ICdhIC0+IGludFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTEzMDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0hhc2hhYmxlX2ludGYiLCJlcXVhbCIsImhhc2hfcGFyYW0iLCJoYXNoIiwicG9seSIsIm9mX2tleSIsInRvX2tleSIsIkJhc2VfSGFzaGFibGUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMzE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfU3RyaW5nYWJsZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsa0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMTMyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0lkZW50aWZpYWJsZV9pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyx5QkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMzQwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQ29tcGFyYWJsZSIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJCYXNlX0lkZW50aWZpYWJsZSIsIlQiLCJoYXNoX2ZvbGRfdCIsImhhc2giLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJzeW1ib2wiLCJlcXVhbCIsImNvbXBhcmUiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsImluY2x1ZGUiLCJwcCIsImhhc2hhYmxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsZ0JBQUFDO0FBQUFBO0FBQUFBLFNBQUFDLGNBQUE7QUFBQSxTQUFBQyxPQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBO0FBQUEsU0FBQUMsU0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUMsUUFBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBQyxNQUFBO0FBQUEsU0FBQUMsTUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxhQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxRQUFBO0FBQUEsU0FBQUMsYUFBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBQyxLQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQXBCO0FBQUFBO0FBQUFBLFNBQUFDLGNBQUE7QUFBQSxTQUFBQyxPQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBO0FBQUEsU0FBQUMsU0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUMsUUFBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBQyxNQUFBO0FBQUEsU0FBQUMsTUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxhQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxRQUFBO0FBQUEsU0FBQUMsYUFBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBQyxLQUFBO0FBQUEsU0FBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNDcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsImFsbCIsIm1vZHVsZV9uYW1lIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0lkZW50aWZpYWJsZSIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJjc3RfQmFzZV9Vbml0X29mX3N0cmluZ19leHBlY3QiLCJjb21wYXJlIiwicGFyYW0iLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJpbmNsdWRlIiwic3ltYm9sIiwiZXF1YWwiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsInBwIiwiaGFzaGFibGUiLCJpbnZhcmlhbnQiLCJCYXNlX1VuaXQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS91bml0Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsUUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBSixNQUFBO0FBQUEsSUFBQUssTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxZQUFBQyxLQUFBQyxHQ2FhLDBCQUFNO0FBQUE7QUFBQSxJQUFBQyxZQUFmO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxZQUFBQyxRQUFBLEtBQUFDLE9BU2dCLFNBQUM7QUFBQSxZQUFBQyxVQUFBRDtBQUFBQSxJQUVIO0FBQUEsY0FFUDtBQUFBLGVBQTJDO0FBQUE7QUFBQSxZQUFBRSxVQUFBRixPQUdqQyxXQUFJO0FBQUE7QUFBQSxJQUFBRztBQUFBQSxNQWhCckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFaLGdCQUFBO0FBQUEsSUFBQUUsU0FBQTtBQUFBLElBQUFFLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUssY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBRSxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQU4sWUFBQTtBQUFBLElBQUFPLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxVQUFBaEIsT0F1QmUsU0FBRTtBQUFBO0FBQUEsSUFBQWlCO0FBQUFBLE1BdkJqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEYkoiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBhbGwgPSAoWyAoKSBdIDogdCBsaXN0KVxuICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID0gKGdsb2JhbGl6ZV91bml0IDogKHRbQG9jYW1sLmxvY2FsXSkgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3VuaXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX3VuaXQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKHVuaXRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfdW5pdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB1bml0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGNvbXBhcmUgXyBfID0gMFxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCIoKVwiIC0+ICgpXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiQmFzZS5Vbml0Lm9mX3N0cmluZzogKCkgZXhwZWN0ZWRcIlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVuaXRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxubGV0IGludmFyaWFudCAoKSA9ICgpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE1NzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGw0IiwiYTEiLCJhMiIsImEzIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJCYXNlX09yX2Vycm9yIiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIiwiZ2V0X3Bvc19sZW5fZXhuIiwiY2hlY2tfcG9zX2xlbl9leG4iLCJQcml2YXRlIiwiZ2V0X3Bvc19sZW4iLCJwb3MiLCJsZW4iLCJwYXJhbSIsInRvdGFsX2xlbmd0aCIsImV4biIsInMiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUUsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLFlBQUFDLFlBQUFDLEtBQUFDLEtBQUFDLE9BQUFDO0FBQUFBLElDSUU7QUFBQSxlQUFjO0FBQUE7QUFBQTtBQUFBLFVBQUFDO0FBQUFBLFNBQUFBLE1ESmhCO0FBQUE7QUFBQSxTQUFBQyxJQUFBO0FBQUEsS0NLMEIsdUNBQXVCO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQVY7QUFBQUEsTURMakQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMFxuXG5sZXQgZ2V0X3Bvc19sZW4gP3BvcyA/bGVuICgpIH50b3RhbF9sZW5ndGggPVxuICB0cnkgUmVzdWx0Lk9rIChnZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGgpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IHMgLT4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIHNcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE2MjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDQiLCJhMiIsImEzIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsInBvcyIsImxlbiIsInQiLCJnZXQiLCJsZW5ndGgiLCJwcmVkIiwibWF0Y2giLCJoaSIsImxvIiwibWlkIiwiZmluZF9sYXN0X3NhdGlzZnlpbmciLCJ4IiwiaSIsImJpbmFyeV9zZWFyY2giLCJjb21wYXJlIiwiaG93IiwidiIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIiwic2VnbWVudF9vZiIsImlzX2xlZnQiLCJpc19yaWdodCIsIkJhc2VfQmluYXJ5X3NlYXJjaCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxzQkFBQUMsS0FBQUMsS0FBQUMsR0FBQUMsS0FBQUMsUUFBQUM7QUFBQUE7QUFBQUEsS0FBQSxNQzJDeUU7QUFBQSxLQUFBQyxRQUFyRTtBQUFBLEtBQUFMLFFBQStFO0FBQUEsS0FBQUQsUUFBQTtBQUFBLFdBR3hFO0FBQUEsS0FBQU8sT0FBQTtBQUFBLEtBQUFDLE9BQ0k7QUFBQSxLQUFBRCxLQUFBO0FBQUE7QUFBQSxLQW5CVjtBQUFBO0FBQUEsWUFHZTtBQUFBLFlBQUQ7QUFBQSxNQUFBRSxNQUFMO0FBQUEsS0FDRixHQUFMLGlCQUFLO0FBQUEsTUFHTjtBQUFBLGNBQUFELE9BRytDLHFDQUFTO0FBQUE7QUFBQSxRQUFBQSxLQVU1RDtBQUFBO0FBQUEsS0F0Q0EsWUFDSztBQUFBLEtBQ1EsR0FBTCxpQkFBSyx5QkFDUjtBQUFBLFNBQUFBLE9BQzBDO0FBQUEsS0FBUTtBQUFBO0FBQUEsR0FrQ0o7QUFBQSxZQUFBRSxxQkFBQVYsS0FBQUMsS0FBQUMsR0FBQUcsTUFBQUYsS0FBQUM7QUFBQUE7QUFBQUEsS0FBQSxNQVFvQjtBQUFBLEtBQUFFLFFBQXJFO0FBQUEsS0FBQUwsUUFBK0U7QUFBQSxLQUFBRCxRQUFBO0FBQUEsSUFFakYsZ0JBQ0s7QUFBQTtBQUFBLEtBQUFNO0FBQUFBLE9BSUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBQUFLLEdBQW1FLDhCQUFRO0FBQUEsSUFBQztBQUFBLFNBQUFDLElBQUE7QUFBQSxLQUtoRSw2QkFDRyxrQ0FBUTtBQUFBO0FBQUEsY0FKVDtBQUFBLElBQUQsK0NBQWU7QUFBQSxHQUlMO0FBQUEsWUFBQUMsY0FBQWIsS0FBQUMsS0FBQUMsR0FBQUUsUUFBQUQsS0FBQVcsU0FBQUMsS0FBQUM7QUFBQUEsSUFhM0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFvQkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBQUFMLEdBQStELDZDQUFXLENBQUs7QUFBQSxpQkFsQi9FO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBQUFBLEdBQThELDRDQUFXLENBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUc3RTtBQUFBO0FBQUE7QUFBQTtBQUFBLDJCQUFBQSxHQUE4RCw2Q0FBVyxDQUFLO0FBQUE7QUFBQTtBQUFBLGlCQWtCOUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBQUFBLEdBQStELDRDQUFXLENBQUksRUFDN0U7QUFBQSxJQXhCSDtBQUFBO0FBQUEsTUFBQUw7QUFBQUEsUUFlSztBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFBSyxHQUE4RCw2Q0FBVyxDQUFLO0FBQUE7QUFBQTtBQUFBLEtBQUM7QUFBQSxVQUFBQSxJQUFBO0FBQUEsTUFFM0QsU0FBUixvQkFBUSwyQkFBbUI7QUFBQTtBQUFBLEtBQ3RCO0FBQUE7QUFBQTtBQUFBLEtBQUFMO0FBQUFBLE9BVGpCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUFBSyxHQUErRCw2Q0FBVyxDQUFLO0FBQUEsSUFBQztBQUFBLFNBQUFBLE1BQUE7QUFBQSxLQUU1RCxTQUFSLG9CQUFRO0FBQUEsTUFBbUI7QUFBQTtBQUFBLElBQ3RCO0FBQUEsR0FZbkI7QUFBQSxZQUFBTSx3QkFBQWpCLEtBQUFDLEtBQUFDLEdBQUFFLFFBQUFELEtBQUFlLFlBQUFIO0FBQUFBLGFBQUFJLFFBQUFSO0FBQUFBLEtBS0sscURBRVc7QUFBQTtBQUFBLGFBQUFTLFNBQUFULEdBRUUscUJBQVc7QUFBQSxJQUNoQztBQUFBLGNBRUU7QUFBQSxjQUVBLHlEQUF3RTtBQUFBO0FBQUEsT0FBQVUscUJEeEg1RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgYSBzZWFyY2ggZm9yIHRoZSBmaXJzdCAocmVzcC4gbGFzdCkgZWxlbWVudFxuICAgc2F0aXNmeWluZyBhIHByZWRpY2F0ZSwgYXNzdW1pbmcgdGhhdCB0aGUgcHJlZGljYXRlIGlzIGluY3JlYXNpbmcgb25cbiAgIHRoZSBjb250YWluZXIsIG1lYW5pbmcgdGhhdCwgaWYgdGhlIGNvbnRhaW5lciBpcyBbdTEuLi51bl0sIHRoZXJlIGV4aXN0cyBhXG4gICBrIHN1Y2ggdGhhdCBwKHUxKT0uLi4uPXAodWspID0gZmFsc2UgYW5kIHAodWsrMSk9Li4uLj1wKHVuKT0gdHJ1ZS5cbiAgIElmIHRoaXMgayA9IDEgKHJlc3AgbiksIGZpbmRfbGFzdF9ub3Rfc2F0aXNmeWluZyAocmVzcCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcpXG4gICB3aWxsIHJldHVybiBOb25lLiAqKVxuXG5sZXQgcmVjIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCA9XG4gIGlmIGxvID4gaGlcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgcHJlZCAoZ2V0IHQgbG8pXG4gIHRoZW4gU29tZSBsb1xuICBlbHNlIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvOihsbyArIDEpIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYSBjb250YWluZXIgW3RdLCBhIHByZWRpY2F0ZSBbcHJlZF0gYW5kIHR3byBpbmRpY2VzIFtsbyA8IGhpXSwgc3VjaCB0aGF0XG4gICBbcHJlZF0gaXMgaW5jcmVhc2luZyBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLlxuXG4gICByZXR1cm4gYSByYW5nZSAobG8sIGhpKSB3aGVyZTpcbiAgIC0gbG8gYW5kIGhpIGFyZSBjbG9zZSBlbm91Z2ggdG9nZXRoZXIgZm9yIGEgbGluZWFyIHNlYXJjaFxuICAgLSBJZiBbcHJlZF0gaXMgbm90IGNvbnN0YW50bHkgW2ZhbHNlXSBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICBvbiB3aGljaCBbcHJlZF0gaXMgW3RydWVdIGlzIGJldHdlZW4gW2xvXSBhbmQgW2hpXS4gKilcbigqIEludmFyaWFudDogdGhlIGZpcnN0IGVsZW1lbnQgc2F0aXNmeWluZyBbcHJlZF0sIGlmIGl0IGV4aXN0cyBpcyBiZXR3ZWVuIFtsb10gYW5kIFtoaV0gKilcbmxldCByZWMgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgPVxuICAoKiBXYXJuaW5nOiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IHRlcm1pbmF0ZSBpZiB0aGUgY29uc3RhbnQgKGN1cnJlbnRseSA4KSBpc1xuICAgICBzZXQgPD0gMSAqKVxuICBpZiBoaSAtIGxvIDw9IDhcbiAgdGhlbiBsbywgaGlcbiAgZWxzZSAoXG4gICAgbGV0IG1pZCA9IGxvICsgKChoaSAtIGxvKSAvIDIpIGluXG4gICAgaWYgcHJlZCAoZ2V0IHQgbWlkKVxuICAgICgqIElOVkFSSUFOVCBjaGVjazogaXQgbWVhbnMgdGhlIGZpcnN0IHNhdGlzZnlpbmcgZWxlbWVudCBpcyBiZXR3ZWVuIFtsb10gYW5kIFttaWRdICopXG4gICAgdGhlblxuICAgICAgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGk6bWlkIH5wcmVkXG4gICAgICAoKiBJTlZBUklBTlQgY2hlY2s6IGl0IG1lYW5zIHRoZSBmaXJzdCBzYXRpc2Z5aW5nIGVsZW1lbnQsIGlmIGl0IGV4aXN0cyxcbiAgICAgICAgIGlzIGJldHdlZW4gW21pZCsxXSBhbmQgW2hpXSAqKVxuICAgIGVsc2UgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbzoobWlkICsgMSkgfmhpIH5wcmVkKVxuOztcblxubGV0IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgbGV0IGxvID0gcG9zIGluXG4gIGxldCBoaSA9IHBvcyArIGxlbiAtIDEgaW5cbiAgbGV0IGxvLCBoaSA9IGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkIGluXG4gIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYW4gYXJyYXkgd2l0aCBzaGFwZSBbdHJ1ZSwuLi50cnVlLGZhbHNlLC4uLmZhbHNlXSAoaS5lLiwgdGhlIF9yZXZlcnNlXyBvZiB3aGF0XG4gICBpcyBkZXNjcmliZWQgYWJvdmUpIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB0cnVlIG9yIE5vbmUgaWYgdGhlcmUgYXJlIG5vXG4gICB0cnVlKilcbmxldCBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+cHJlZCB+Z2V0IH5sZW5ndGggPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgaWYgbGVuID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgKCogVGhlIGxhc3Qgc2F0aXNmeWluZyBpcyB0aGUgb25lIGp1c3QgYmVmb3JlIHRoZSBmaXJzdCBub3Qgc2F0aXNmeWluZyAqKVxuICAgIG1hdGNoXG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgfnBvcyB+bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBub3QgKHByZWQgeCkpXG4gICAgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIChwb3MgKyBsZW4gLSAxKVxuICAgICgqIFRoaXMgbWVhbnMgdGhhdCBhbGwgZWxlbWVudHMgc2F0aXNmeSBwcmVkLlxuICAgICAgIFRoZXJlIGlzIGF0IGxlYXN0IGFuIGVsZW1lbnQgYXMgKGxlbiA+IDApICopXG4gICAgfCBTb21lIGkgd2hlbiBpID0gcG9zIC0+IE5vbmUgKCogbm8gZWxlbWVudCBzYXRpc2ZpZXMgcHJlZCAqKVxuICAgIHwgU29tZSBpIC0+IFNvbWUgKGkgLSAxKSlcbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoXG4gICAgICA/cG9zXG4gICAgICA/bGVuXG4gICAgICB0XG4gICAgICB+bGVuZ3RoOigobGVuZ3RoIDogXyAtPiBfKSBbQGxvY2FsXSlcbiAgICAgIH5nZXQ6KChnZXQgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pXG4gICAgICB+Y29tcGFyZTooKGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pXG4gICAgICBob3dcbiAgICAgIHZcbiAgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKSBbQG5vbnRhaWxcbiAgICBdXG4gIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKSBbQG5vbnRhaWxcbiAgICBdXG4gIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgKG1hdGNoXG4gICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgIChtYXRjaFxuICAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMCkgW0Bub250YWlsXG4gICAgXVxuICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApIFtAbm9udGFpbFxuICAgIF1cbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnNlZ21lbnRfb2YgaG93ID1cbiAgbGV0IGlzX2xlZnQgeCA9XG4gICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICB8IGBSaWdodCAtPiBmYWxzZVxuICBpblxuICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X29uX2xlZnQgLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnByZWQ6aXNfbGVmdCBbQG5vbnRhaWxdXG4gIHwgYEZpcnN0X29uX3JpZ2h0IC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+cHJlZDppc19yaWdodCBbQG5vbnRhaWxdXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNzg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImFsbCIsIldoaWNoX3RhcmdldF9ieV9rZXkiLCJXaGljaF90YXJnZXRfYnlfc2VnbWVudCIsIkJhc2VfQmluYXJ5X3NlYXJjaGFibGVfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExODA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDciLCJmIiwiYTAiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJjYW1sX2NhbGw4IiwiYTciLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiQmFzZV9CaW5hcnlfc2VhcmNoIiwiTWFrZV9nZW4iLCJUIiwiZ2V0IiwibGVuZ3RoIiwiYmluYXJ5X3NlYXJjaCIsInBvcyIsImxlbiIsInQiLCJjb21wYXJlIiwiaG93IiwidiIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIiwic2VnbWVudF9vZiIsIkJhc2VfQmluYXJ5X3NlYXJjaGFibGUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9iaW5hcnlfc2VhcmNoYWJsZS5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQyxJQUFBQyxJQUFBQyxJQUFBQyxJQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUMsSUFBQUMsSUFBQUMsSUFBQUMsSUFBQUMsSUFBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLFlBQUFDLFNBQUFDO0FBQUFBLFFBQUFDLE1BQUEsTUFBQUMsU0FBQTtBQUFBLGFBQUFDLGNBQUFDLEtBQUFDLEtBQUFDLEdBQUFDLFNBQUFDLEtBQUFDO0FBQUFBLEtDZ0JJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFtRTtBQUFBO0FBQUEsYUFBQUMsd0JBQUFOLEtBQUFDLEtBQUFDLEdBQUFLLFlBQUFIO0FBQUFBLEtBSW5FO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFBOEU7QUFBQTtBQUFBLElEcEJsRjtBQUFBO0FBQUE7QUFBQSxJQUFBSTtBQUFBQSxNQUFBO0FBQUEsZ0JBQUFaO0FBQUFBLFlBQUFDLE1BQUEsTUFBQUMsU0FBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUY7QUFBQUEsWUFBQUMsTUFBQSxNQUFBQyxTQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGVfaW50ZlxuXG5tb2R1bGUgdHlwZSBBcmcgPSBzaWdcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIGVsdFxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IEFyZykgPSBzdHJ1Y3RcbiAgbGV0IGdldCA9IFQuZ2V0XG4gIGxldCBsZW5ndGggPSBULmxlbmd0aFxuXG4gIGxldCBiaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5jb21wYXJlIGhvdyB2XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAnYSBlbHQgPSBULmVsdFxuICAgIHR5cGUgJ2EgdCA9IFQudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICB0eXBlICdhIHQgPSAnYSBULnRcblxuICAgIGxldCBnZXQgPSBULmdldFxuICAgIGxldCBsZW5ndGggPSBULmxlbmd0aFxuICBlbmQpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE4NzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9CbGl0X2ludGYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGlCQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE4ODIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0MCIsIkJhc2VfU3lzMCIsIlN0ZGxpYl9CeXRlc0xhYmVscyIsIlByaW1pdGl2ZXMiLCJtYXhfbGVuZ3RoIiwiYmxpdCIsImJsaXRfc3RyaW5nIiwiY29tcGFyZSIsImNvcHkiLCJjcmVhdGUiLCJjc3RfQnl0ZXNfY3JlYXRlX2xvY2FsIiwiY3JlYXRlX2xvY2FsIiwibGVuIiwiZmlsbCIsIm1ha2UiLCJtYXAiLCJ0IiwibCIsInIiLCJpIiwibWFwaSIsInN1YiIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIkJhc2VfQnl0ZXMwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvYnl0ZXMwLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsWUFBQUMsYUFBQUM7QUFBQUEsSUM0R0k7QUFBQSxLQUFzQztBQUFBLElBQ3JDLGtEQUF3QjtBQUFBO0FBQUEsT0FBQUMsT0Q3RzdCLHdCQUFBQyxPQUFBO0FBQUEsWUFBQUMsSUFBQUMsR0FBQXJCO0FBQUFBLFFBQUFzQixJQ29IRTtBQUFBLElBQ0EsWUFDSztBQUFBO0FBQUEsS0FBQUMsSUFFSztBQUFBLFdBQ0s7QUFBQSxXQUFLO0FBQUE7QUFBQSxTQUFBQyxJQUFBO0FBQUE7QUFBQSxNQUNtQiw0QkFBcEIsY0FBZjtBQUFBLGdCQUFtQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFckM7QUFBQSxHQUFFO0FBQUEsWUFBQUMsS0FBQUosR0FBQXJCO0FBQUFBLFFBQUFzQixJQUlKO0FBQUEsSUFDQSxZQUNLO0FBQUE7QUFBQSxLQUFBQyxJQUVLO0FBQUEsV0FDSztBQUFBLFdBQUs7QUFBQTtBQUFBLFNBQUFDLElBQUE7QUFBQTtBQUFBLE1BQ3FCO0FBQUEsY0FBdEIsaUJBQWY7QUFBQSxnQkFBcUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXZDO0FBQUEsR0FBRTtBQUFBO0FBQUEsSUFBQUUsTUR4SU47QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFtCeXRlczBdIGRlZmluZXMgc3RyaW5nIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHlcbiAgIGRlZmluZWQgaW4gdGVybXMgb2YgW1N0ZGxpYi5CeXRlc10uIFtCeXRlczBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzc1xuICAgdGhlIHBhcnQgb2YgW1N0ZGxpYi5CeXRlc10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gYnl0ZXMwLm1sIHNob3VsZCB1c2UgW1N0ZGxpYi5CeXRlc10uIFtCeXRlczBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmRcbiAgIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQnl0ZXNdIGluXG4gICBidWlsZCBvcmRlciBzaG91bGQgZG86XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBCeXRlcyAgPSBCeXRlczBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgQnl0ZXMgPSBCeXRlczBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHNcbiAgIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuQnl0ZXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5tb2R1bGUgUHJpbWl0aXZlcyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiAoYnl0ZXNbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IChieXRlc1tAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gY2hhclxuICAgID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5cbiAgZXh0ZXJuYWwgc2V0XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGNoYXJbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoY2hhcltAbG9jYWxfb3B0XSlcbiAgICAtPiB1bml0XG4gICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcblxuICAoKiBbdW5zYWZlX2JsaXRfc3RyaW5nXSBpcyBub3QgZXhwb3J0ZWQgaW4gdGhlIFtzdGRsaWJdIHNvIHdlIGV4cG9ydCBpdCBoZXJlICopXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIDogIHNyYzooc3RyaW5nW0Bsb2NhbF9vcHRdKVxuICAgIC0+IHNyY19wb3M6aW50XG4gICAgLT4gZHN0OihieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50NjRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnQ2NFxuICAgID0gXCIlY2FtbF9ieXRlc19nZXQ2NHVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50NjRbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50MzJcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnQzMlxuICAgID0gXCIlY2FtbF9ieXRlc19nZXQzMnVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50MzJcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50MzJbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50MTZcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnRcbiAgICA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZ1XCJcblxuICBleHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiB1bml0XG4gICAgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5lbmRcblxuaW5jbHVkZSBQcmltaXRpdmVzXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgYmxpdCA9IFN0ZGxpYi5CeXRlcy5ibGl0XG5sZXQgYmxpdF9zdHJpbmcgPSBTdGRsaWIuQnl0ZXMuYmxpdF9zdHJpbmdcbmxldCBjb21wYXJlID0gU3RkbGliLkJ5dGVzLmNvbXBhcmVcbmxldCBjb3B5ID0gU3RkbGliLkJ5dGVzLmNvcHlcbmxldCBjcmVhdGUgPSBTdGRsaWIuQnl0ZXMuY3JlYXRlXG5cbmV4dGVybmFsIHVuc2FmZV9jcmVhdGVfbG9jYWwgOiBpbnQgLT4gKGJ5dGVzW0Bsb2NhbF0pID0gXCJCYXNlX3Vuc2FmZV9jcmVhdGVfbG9jYWxfYnl0ZXNcIlxuW0BAbm9hbGxvY11cblxubGV0IGNyZWF0ZV9sb2NhbCBsZW4gPVxuICBcbiAgICAoaWYgbGVuID4gU3lzMC5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuY3JlYXRlX2xvY2FsXCI7XG4gICAgIHVuc2FmZV9jcmVhdGVfbG9jYWwgbGVuKVxuOztcblxubGV0IGZpbGwgPSBTdGRsaWIuQnl0ZXMuZmlsbFxubGV0IG1ha2UgPSBTdGRsaWIuQnl0ZXMubWFrZVxuXG5sZXQgbWFwIHQgfmY6KChmIDogXyAtPiBfKSBbQGxvY2FsXSkgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGlmIGwgPSAwXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCB0IGkpKVxuICAgIGRvbmU7XG4gICAgcilcbjs7XG5cbmxldCBtYXBpIHQgfmY6KChmIDogXyAtPiBfIC0+IF8pIFtAbG9jYWxdKSA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgaWYgbCA9IDBcbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgdCBpKSlcbiAgICBkb25lO1xuICAgIHIpXG47O1xuXG5sZXQgc3ViID0gU3RkbGliLkJ5dGVzLnN1YlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdFxuICA6ICBzcmM6KGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAtPiBzcmNfcG9zOmludFxuICAtPiBkc3Q6KGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAtPiBkc3RfcG9zOmludFxuICAtPiBsZW46aW50XG4gIC0+IHVuaXRcbiAgPSBcImNhbWxfYmxpdF9ieXRlc1wiXG5bQEBub2FsbG9jXVxuXG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLkJ5dGVzLnRvX3N0cmluZ1xubGV0IG9mX3N0cmluZyA9IFN0ZGxpYi5CeXRlcy5vZl9zdHJpbmdcblxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZ1xuICA6ICBub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihieXRlc1tAbG9jYWxfb3B0XSlcbiAgLT4gKHN0cmluZ1tAbG9jYWxfb3B0XSlcbiAgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nX3Byb21pc2Vfbm9fbXV0YXRpb25cbiAgOiAgKHN0cmluZ1tAbG9jYWxfb3B0XSlcbiAgLT4gKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE5ODUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9zdHJpbmdfb2ZfYnl0ZXMiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNSIsImEzIiwiYTQiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIiwiTWFrZV9nZW4iLCJTcmMiLCJEc3QiLCJ1bnNhZmVfYmxpdCIsImJsaXQiLCJzcmMiLCJzcmNfcG9zIiwiZHN0IiwiZHN0X3BvcyIsImxlbiIsImJsaXRvIiwib3B0IiwicGFyYW0iLCJzcmNfbGVuIiwic3ViIiwicG9zIiwic3VibyIsImkiLCJNYWtlX3RvX3N0cmluZyIsIlQiLCJUb19ieXRlcyIsIkJhc2VfQmxpdCIsIlNlcXVlbmNlIiwiY3JlYXRlX2xpa2UiLCJsZW5ndGgiLCJpbmNsdWRlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvYmxpdC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLFNBQUFDLEtBQUFDO0FBQUFBLFFBQUFDLGNBQUE7QUFBQSxhQUFBQyxLQUFBQyxLQUFBQyxTQUFBQyxLQUFBQyxTQUFBQztBQUFBQSxTQUFBLE1DdUJvQjtBQUFBLEtBSGhCO0FBQUEsZUFPZ0I7QUFBQSxLQUhoQjtBQUFBLGVBR2dDO0FBQUE7QUFBQSxlQUNoQjtBQUFBLGtCQUE0QztBQUFBO0FBQUEsYUFBQUMsTUFBQUwsS0FBQSxVQUFBRSxLQUFBSSxLQUFBQztBQUFBQSxTQUFBTixVQUl4RDtBQUFBO0FBQUEsVUFBQU8sVUFBQTtBQUFBO0FBQUE7QUFBQSxhQUVZO0FBQUEsT0FBQUEsVUFBQTtBQUFBLFNBQUFMLFVBRlo7QUFBQSxLQU9KLGdEQUE2QztBQUFBO0FBQUEsYUFBQU0sSUFBQVQsS0FBQVUsS0FBQU47QUFBQUEsU0FBQSxNQU91QjtBQUFBLEtBQXBFO0FBQUEsU0FBQUYsTUFDVTtBQUFBLEtBQ1YsWUFBZ0I7QUFBQSxLQUNoQjtBQUFBLElBQUc7QUFBQSxhQUFBUyxLQUFBTCxLQUFBRixLQUFBSjtBQUFBQSxTQUFBVSxNQUdJO0FBQUEsS0FDUDtBQUFBLFVBQUFFLElBQUEsUUFBQUEsTUFLaUI7QUFBQTtBQUFBO0FBQUEsYUFDRjtBQUFBLE9BQUFBLE1BQUE7QUFBQSxLQU5mLHlCQU1vQztBQUFBO0FBQUEsSUQzRHhDO0FBQUE7QUFBQSxZQUFBQyxlQUFBQyxHQUFBQztBQUFBQSxhQUFBTixJQUFBVCxLQUFBVSxLQUFBTjtBQUFBQSxLQzhIZ0UsT0FBbUIscUJBQW5CLHVDQUFtQjtBQUFBO0FBQUEsYUFBQU8sS0FBQUQsS0FBQU4sS0FBQUo7QUFBQUEsS0FJbkIsT0FBb0IscUJBQXBCLHVDQUFvQjtBQUFBO0FBQUEsSURsSXBGO0FBQUE7QUFBQTtBQUFBLElBQUFnQjtBQUFBQSxNQUFBO0FBQUEsZ0JBQUFDO0FBQUFBLGlCQUFBQyxZQUFBZCxLQUFBRyxPQ3FGNkIsbUNBQVc7QUFBQTtBQUFBLFNBQUFZLFNEckZ4QztBQUFBLFNBQUFyQixjQUFBO0FBQUEsU0FBQXNCO0FBQUFBLFdBQUE7QUFBQSxTQUFBdEIsZ0JBQUE7QUFBQSxTQUFBQyxPQUFBO0FBQUEsU0FBQU0sUUFBQTtBQUFBLFNBQUFJLE1BQUE7QUFBQSxTQUFBRSxPQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBZixLQUFBQztBQUFBQSxZQUFBc0IsU0FBQTtBQUFBLGlCQUFBRCxZQUFBZCxLQUFBRyxPQ2tIK0IsOEJBQVc7QUFBQTtBQUFBLFNBQUFULGNEbEgxQztBQUFBLFNBQUFxQixXQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmxpdF9pbnRmXG5cbm1vZHVsZSB0eXBlIFNlcXVlbmNlX2dlbiA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbGVuZ3RoIDogKF8gdFtAbG9jYWxdKSAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5cbiAgICAoU3JjIDogU2VxdWVuY2VfZ2VuKSAoRHN0IDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBjcmVhdGVfbGlrZSA6IGxlbjppbnQgLT4gJ2EgU3JjLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSBTcmMudCwgJ2EgdCkgYmxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpID1cbnN0cnVjdFxuICBsZXQgdW5zYWZlX2JsaXQgPSBEc3QudW5zYWZlX2JsaXRcblxuICBsZXQgYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpzcmNfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihTcmMubGVuZ3RoIHNyYyk7XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpkc3RfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihEc3QubGVuZ3RoIGRzdCk7XG4gICAgaWYgbGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuXG4gIDs7XG5cbiAgbGV0IGJsaXRvXG4gICAgICAgIH5zcmNcbiAgICAgICAgPyhzcmNfcG9zID0gMClcbiAgICAgICAgPyhzcmNfbGVuID0gU3JjLmxlbmd0aCBzcmMgLSBzcmNfcG9zKVxuICAgICAgICB+ZHN0XG4gICAgICAgID8oZHN0X3BvcyA9IDApXG4gICAgICAgICgpXG4gICAgPVxuICAgIGJsaXQgfnNyYyB+c3JjX3BvcyB+bGVuOnNyY19sZW4gfmRzdCB+ZHN0X3Bvc1xuICA7O1xuXG4gICgqIFtzdWJdIGFuZCBbc3Vib10gZW5zdXJlIHRoYXQgZXZlcnkgcG9zaXRpb24gb2YgdGhlIGNyZWF0ZWQgc2VxdWVuY2UgaXMgcG9wdWxhdGVkIGJ5XG4gICAgIGFuIGVsZW1lbnQgb2YgdGhlIHNvdXJjZSBhcnJheS4gIFRodXMgZXZlcnkgZWxlbWVudCBvZiBbZHN0XSBiZWxvdyBpcyB3ZWxsXG4gICAgIGRlZmluZWQuICopXG4gIGxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDooU3JjLmxlbmd0aCBzcmMpO1xuICAgIGxldCBkc3QgPSBEc3QuY3JlYXRlX2xpa2UgfmxlbiBzcmMgaW5cbiAgICBpZiBsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3Bvczpwb3MgfmRzdCB+ZHN0X3BvczowIH5sZW47XG4gICAgZHN0XG4gIDs7XG5cbiAgbGV0IHN1Ym8gPyhwb3MgPSAwKSA/bGVuIHNyYyA9XG4gICAgc3ViXG4gICAgICBzcmNcbiAgICAgIH5wb3NcbiAgICAgIH5sZW46XG4gICAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgICAgfCBTb21lIGkgLT4gaVxuICAgICAgICAgfCBOb25lIC0+IFNyYy5sZW5ndGggc3JjIC0gcG9zKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMSAoU2VxdWVuY2UgOiBzaWdcbiAgICBpbmNsdWRlIFNlcXVlbmNlX2dlblxuXG4gICAgdmFsIGNyZWF0ZV9saWtlIDogbGVuOmludCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgdCwgJ2EgdCkgYmxpdFxuICBlbmQpID1cbiAgTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5cbm1vZHVsZSBNYWtlMV9nZW5lcmljIChTZXF1ZW5jZSA6IFNlcXVlbmNlMSkgPSBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcblxubW9kdWxlIE1ha2UgKFNlcXVlbmNlIDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZVxuXG4gICAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6ICh0LCB0KSBibGl0XG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBTZXF1ZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9IFNlcXVlbmNlLnRcblxuICAgIG9wZW4gU2VxdWVuY2VcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmRcblxuICBpbmNsdWRlIE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuZW5kXG5cbm1vZHVsZSBNYWtlX2Rpc3RpbmN0XG4gICAgKFNyYyA6IFNlcXVlbmNlKSAoRHN0IDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIFNlcXVlbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+IHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB1bnNhZmVfYmxpdCA6IChTcmMudCwgdCkgYmxpdFxuICAgICAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBNYWtlX2dlblxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IFNyYy50XG5cbiAgICAgIG9wZW4gU3JjXG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gRHN0LnRcblxuICAgICAgb3BlbiBEc3RcblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICAgIGVuZClcblxubW9kdWxlIE1ha2VfdG9fc3RyaW5nIChUIDogc2lnXG4gICAgdHlwZSB0XG4gIGVuZClcbiAgICAoVG9fYnl0ZXMgOiBTX2Rpc3RpbmN0IHdpdGggdHlwZSBzcmMgOj0gVC50IHdpdGggdHlwZSBkc3QgOj0gYnl0ZXMpID1cbnN0cnVjdFxuICBvcGVuIFRvX2J5dGVzXG5cbiAgbGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3ViIHNyYyB+cG9zIH5sZW4pXG4gIDs7XG5cbiAgbGV0IHN1Ym8gP3BvcyA/bGVuIHNyYyA9XG4gICAgQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6KHN1Ym8gP3BvcyA/bGVuIHNyYylcbiAgOztcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyMTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfRWl0aGVyX2ludGYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLG1CQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTIxMTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1dpdGhfcmV0dXJuIiwiQmFzZV9MaXN0MCIsIkJhc2VfTW9uYWQiLCJCYXNlX0FwcGxpY2F0aXZlIiwiQmFzZV9FaXRoZXIwIiwiY29tcGFyZSIsImhhc2hfZm9sZF90IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJzd2FwIiwicGFyYW0iLCJ4IiwiaXNfZmlyc3QiLCJpc19zZWNvbmQiLCJ2YWx1ZSIsInZhbHVlX21hcCIsInQiLCJmaXJzdCIsInNlY29uZCIsIm1hcCIsImVxdWFsIiwiZXExIiwiZXEyIiwidDEiLCJ0MiIsInkiLCJpbnZhcmlhbnQiLCJzIiwiTWFrZV9mb2N1c2VkIiwiTSIsInJldHVybiIsIm90aGVyIiwiZm9jdXMiLCJjb21iaW5lIiwiYmluZCIsInJlcyIsImluY2x1ZGUiLCJzeW1ib2xfYmluZCIsIkxldF9zeW50YXgiLCJNb25hZF9pbmZpeCIsImpvaW4iLCJpZ25vcmVfbSIsIm1hcDIiLCJBcHAiLCJib3RoIiwic3ltYm9sIiwic3ltYm9sX21hcCIsImFwcGx5IiwibWFwMyIsImFsbCIsImFsbF91bml0IiwiQXBwbGljYXRpdmVfaW5maXgiLCJjb21iaW5lX2FsbCIsInRzIiwiYWNjIiwibWF0Y2giLCJjb21iaW5lX2FsbF91bml0IiwidG9fb3B0aW9uIiwiZGVmYXVsdCIsIndpdGhfcmV0dXJuIiwicmV0IiwiRmlyc3QiLCJTZWNvbmQiLCJFeHBvcnQiLCJCYXNlX0VpdGhlciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2VpdGhlci5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsS0FBQUM7QUFBQUEsSUNLVyx1QkFBQUMsSUFBQSxVQUNJO0FBQUEsUUFBQUEsTUFESjtBQUFBLElBRUs7QUFBQSxHQUFPO0FBQUEsWUFBQUMsU0FBQUYsT0FHUiw2QkFFTTtBQUFBLFlBQUFHLFVBQUFILE9BR0wsNkJBRUk7QUFBQSxZQUFBSSxNQUFBSixXQUFBQyxJQUdWLFVBQXVCLFNBQUM7QUFBQSxZQUFBSSxVQUFBQyxHQUFBQyxPQUFBQztBQUFBQSxJQUdoQyxtQkFBQVAsSUFBQSxNQUNhLDJCQUNTO0FBQUEsUUFBQUEsTUFGdEI7QUFBQSxJQUVjLDhCQUFRO0FBQUE7QUFBQSxZQUFBUSxJQUFBSCxHQUFBQyxP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UUFBQWhCO0FBQUFBLElDK0xNLG1CQUFBUyxJQUFBLE1BRWE7QUFBQSxRQUFBZCxJQUZiO0FBQUEsSUFDYztBQUFBLEdBQ2tCO0FBQUEsWUFBQXNCLFVBQUFWLElBQUFDLElBQUEvQixHQUFBc0M7QUFBQUEsSUFJaEM7QUFBQSxTQUFBcEIsSUFBQTtBQUFBLHlCQUFBYyxJQUFBLE9BRTRCLG1DQUFXO0FBQUEsU0FBQWQsTUFGdkM7QUFBQTtBQUFBO0FBQUEsU0FBQUEsTUFBQTtBQUFBLHlCQUFBYyxNQUFBLE9BQytCLG1DQUFPO0FBQUEsU0FBQWQsTUFEdEM7QUFBQTtBQUFBLElBRzZCO0FBQUEsR0FBTztBQUFBLFlBQUF1QixPQUFBbEIsR0FBQXZCO0FBQUFBLElBSXBDLGVBR2tCO0FBQUEsUUFBQWtCLElBSGxCO0FBQUEsSUFDYyx1QkFFSztBQUFBO0FBQUE7QUFBQSxJQUFBbUQsU0QvTXpCO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBFaXRoZXJfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBFaXRoZXIwXG5cbmxldCBzd2FwID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IFNlY29uZCB4XG4gIHwgU2Vjb25kIHggLT4gRmlyc3QgeFxuOztcblxubGV0IGlzX2ZpcnN0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IHRydWVcbiAgfCBTZWNvbmQgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NlY29uZCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiBmYWxzZVxuICB8IFNlY29uZCBfIC0+IHRydWVcbjs7XG5cbmxldCB2YWx1ZSAoRmlyc3QgeCB8IFNlY29uZCB4KSA9IHhcblxubGV0IHZhbHVlX21hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBmaXJzdCB4XG4gIHwgU2Vjb25kIHggLT4gc2Vjb25kIHhcbjs7XG5cbmxldCBpdGVyID0gdmFsdWVfbWFwXG5cbmxldCBtYXAgdCB+Zmlyc3QgfnNlY29uZCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZpcnN0IHggLT4gRmlyc3QgKGZpcnN0IHgpXG4gIHwgU2Vjb25kIHggLT4gU2Vjb25kIChzZWNvbmQgeClcbjs7XG5cbmxldCBmaXJzdCB4ID0gRmlyc3QgeFxubGV0IHNlY29uZCB4ID0gU2Vjb25kIHhcblxubGV0IGVxdWFsIGVxMSBlcTIgdDEgdDIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gZXExIHggeVxuICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBlcTIgeCB5XG4gIHwgRmlyc3QgXywgU2Vjb25kIF8gfCBTZWNvbmQgXywgRmlyc3QgXyAtPiBmYWxzZVxuOztcblxubGV0IGludmFyaWFudCBmIHMgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gZiB4XG4gIHwgU2Vjb25kIHkgLT4gcyB5XG47O1xuXG5tb2R1bGUgRm9jdXMgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IEZvY3VzIG9mIHsgdmFsdWUgOiAnYSBbQGdsb2JhbF0gfVxuICAgIHwgT3RoZXIgb2YgeyB2YWx1ZSA6ICdiIFtAZ2xvYmFsXSB9XG5lbmRcblxubW9kdWxlIE1ha2VfZm9jdXNlZCAoTSA6IHNpZ1xuICAgIHR5cGUgKCsnYSwgKydiKSB0XG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gICAgdmFsIG90aGVyIDogJ2IgLT4gKF8sICdiKSB0XG4gICAgdmFsIGZvY3VzIDogKCdhLCAnYikgdCAtPiAoKCdhLCAnYikgRm9jdXMudFtAbG9jYWxdKVxuXG4gICAgdmFsIGNvbWJpbmVcbiAgICAgIDogICgnYSwgJ2QpIHRcbiAgICAgIC0+ICgnYiwgJ2QpIHRcbiAgICAgIC0+IGY6KCgnYSAtPiAnYiAtPiAnYylbQGxvY2FsXSlcbiAgICAgIC0+IG90aGVyOigoJ2QgLT4gJ2QgLT4gJ2QpW0Bsb2NhbF0pXG4gICAgICAtPiAoJ2MsICdkKSB0XG5cbiAgICB2YWwgYmluZCA6ICgnYSwgJ2IpIHQgLT4gZjooKCdhIC0+ICgnYywgJ2IpIHQpW0Bsb2NhbF0pIC0+ICgnYywgJ2IpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG4gIG9wZW4gV2l0aF9yZXR1cm5cblxuICBsZXQgbWFwIHQgfmYgPVxuICAgIGxldCByZXMgPSBiaW5kIHQgfmY6KGZ1biB4IC0+IHJldHVybiAoZiB4KSkgaW5cbiAgICByZXNcbiAgOztcblxuICBpbmNsdWRlIE1vbmFkLk1ha2UyX2xvY2FsIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBBcHAgPSBBcHBsaWNhdGl2ZS5NYWtlMl91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gICAgICBsZXQgbWFwMiA6ICgnYSwgJ3gpIHQgLT4gKCdiLCAneCkgdCAtPiBmOigoJ2EgLT4gJ2IgLT4gJ2MpW0Bsb2NhbF0pIC0+ICgnYywgJ3gpIHQgPVxuICAgICAgICBmdW4gdDEgdDIgfmYgLT5cbiAgICAgICAgYmluZCB0MSB+ZjooZnVuIHggLT4gYmluZCB0MiB+ZjooZnVuIHkgLT4gcmV0dXJuIChmIHggeSkpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgICAgIDs7XG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgQXBwXG5cbiAgbGV0IGNvbWJpbmVfYWxsID1cbiAgICBsZXQgcmVjIG90aGVyX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvdGhlciBhY2NcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICAobWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgICAgICB8IEZvY3VzIF8gLT4gb3RoZXJfbG9vcCBmIGFjYyB0c1xuICAgICAgICAgfCBPdGhlciBvIC0+IG90aGVyX2xvb3AgZiAoZiBhY2Mgby52YWx1ZSkgdHMpXG4gICAgaW5cbiAgICBsZXQgcmVjIHJldHVybl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiBhY2MpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgKG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgICAgICAgfCBGb2N1cyB4IC0+IHJldHVybl9sb29wIGYgKHgudmFsdWUgOjogYWNjKSB0c1xuICAgICAgICAgfCBPdGhlciBvIC0+IG90aGVyX2xvb3AgZiBvLnZhbHVlIHRzKVxuICAgIGluXG4gICAgZnVuIHRzIH5mIC0+IHJldHVybl9sb29wIGYgW10gdHNcbiAgOztcblxuICBsZXQgY29tYmluZV9hbGxfdW5pdCA9XG4gICAgbGV0IHJlYyBvdGhlcl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gb3RoZXIgYWNjXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgKG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgICAgICAgfCBGb2N1cyBfIC0+IG90aGVyX2xvb3AgZiBhY2MgdHNcbiAgICAgICAgIHwgT3RoZXIgbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8udmFsdWUpIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgKG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgICAgICAgfCBGb2N1cyB7IHZhbHVlID0gKCkgfSAtPiByZXR1cm5fbG9vcCBmIHRzXG4gICAgICAgICB8IE90aGVyIHsgdmFsdWUgPSBvIH0gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiB0c1xuICA7O1xuXG4gIGxldCB0b19vcHRpb24gdCA9XG4gICAgbWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgfCBGb2N1cyB4IC0+IFNvbWUgeC52YWx1ZVxuICAgIHwgT3RoZXIgXyAtPiBOb25lXG4gIDs7XG5cbiAgbGV0IHZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgIHwgRm9jdXMgeCAtPiB4LnZhbHVlXG4gICAgfCBPdGhlciBfIC0+IGRlZmF1bHRcbiAgOztcblxuICBsZXQgd2l0aF9yZXR1cm4gZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByZXQgLT4gb3RoZXIgKGYgKFdpdGhfcmV0dXJuLnByZXBlbmQgcmV0IH5mOnJldHVybikpKSBbQG5vbnRhaWxdXG4gIDs7XG5lbmRcblxubW9kdWxlIEZpcnN0ID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IHJldHVybiA9IGZpcnN0XG4gICAgbGV0IG90aGVyID0gc2Vjb25kXG5cbiAgICBsZXQgZm9jdXMgdCA6IF8gRm9jdXMudCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRmlyc3QgeCAtPiBGb2N1cyB7IHZhbHVlID0geCB9XG4gICAgICB8IFNlY29uZCB5IC0+IE90aGVyIHsgdmFsdWUgPSB5IH1cbiAgICA7O1xuXG4gICAgbGV0IGNvbWJpbmUgdDEgdDIgfmYgfm90aGVyID1cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gRmlyc3QgKGYgeCB5KVxuICAgICAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gU2Vjb25kIChvdGhlciB4IHkpXG4gICAgICB8IFNlY29uZCB4LCBfIHwgXywgU2Vjb25kIHggLT4gU2Vjb25kIHhcbiAgICA7O1xuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRmlyc3QgeCAtPiBmIHhcbiAgICAgICgqIFJldXNlIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCBhbGxvY2F0aW9uLiAqKVxuICAgICAgfCBTZWNvbmQgXyBhcyB5IC0+IHlcbiAgICA7O1xuICBlbmQpXG5cbm1vZHVsZSBTZWNvbmQgPSBNYWtlX2ZvY3VzZWQgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2IsICdhKSB0XG5cbiAgICBsZXQgcmV0dXJuID0gc2Vjb25kXG4gICAgbGV0IG90aGVyID0gZmlyc3RcblxuICAgIGxldCBmb2N1cyB0IDogXyBGb2N1cy50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZWNvbmQgeCAtPiBGb2N1cyB7IHZhbHVlID0geCB9XG4gICAgICB8IEZpcnN0IHkgLT4gT3RoZXIgeyB2YWx1ZSA9IHkgfVxuICAgIDs7XG5cbiAgICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IFNlY29uZCAoZiB4IHkpXG4gICAgICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gRmlyc3QgKG90aGVyIHggeSlcbiAgICAgIHwgRmlyc3QgeCwgXyB8IF8sIEZpcnN0IHggLT4gRmlyc3QgeFxuICAgIDs7XG5cbiAgICBsZXQgYmluZCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZWNvbmQgeCAtPiBmIHhcbiAgICAgICgqIFJldXNlIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCBhbGxvY2F0aW9uLCBsaWtlIFtGaXJzdC5iaW5kXSBhYm92ZS4gKilcbiAgICAgIHwgRmlyc3QgXyBhcyB5IC0+IHlcbiAgICA7O1xuICBlbmQpXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2YsICdzKSBfZWl0aGVyID0gKCdmLCAncykgdCA9XG4gICAgfCBGaXJzdCBvZiAnZlxuICAgIHwgU2Vjb25kIG9mICdzXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjQ2MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsImNzdCIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9Tb3VyY2VfY29kZV9wb3NpdGlvbjAiLCJCYXNlX0Vycm9yIiwiQmFzZV9JbXBvcnQiLCJCYXNlX01vbmFkIiwiQmFzZV9BcHBsaWNhdGl2ZSIsImNvbXBhcmUiLCJnbG9iYWxpemUiLCJoYXNoX2ZvbGRfdCIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsImNzdF9PcHRpb25fdmFsdWVfZXhuIiwiY3N0X09wdGlvbl92YWx1ZV9leG5fTm9uZSIsInRfc2V4cF9ncmFtbWFyIiwiYV9zZXhwX2dyYW1tYXIiLCJpc19ub25lIiwicGFyYW0iLCJpc19zb21lIiwidmFsdWVfbWFwIiwibyIsImRlZmF1bHQiLCJ4IiwiaXRlciIsImEiLCJpbnZhcmlhbnQiLCJ0IiwiY2FsbCIsInZhbHVlIiwidmFsdWVfZXhuIiwiaGVyZSIsImVycm9yIiwibWVzc2FnZSIsInAiLCJlIiwibSIsInZhbHVlX29yX3RodW5rIiwidG9fYXJyYXkiLCJ0b19saXN0IiwibWluX2VsdCIsIm1heF9lbHQiLCJzdW0iLCJNIiwiZm9yX2FsbCIsImV4aXN0cyIsIm1lbSIsImVxdWFsIiwibGVuZ3RoIiwiZm9sZCIsImluaXQiLCJjb3VudCIsImZpbmQiLCJmaW5kX21hcCIsInNvbWUiLCJmaXJzdF9zb21lIiwieSIsInNvbWVfaWYiLCJjb25kIiwibWVyZ2UiLCJiIiwiZmlsdGVyIiwidiIsInRyeV93aXRoIiwidHJ5X3dpdGhfam9pbiIsInJldHVybiIsIm1hcCIsImJpbmQiLCJpbmNsdWRlIiwic3ltYm9sX2JpbmQiLCJNb25hZF9pbmZpeCIsImpvaW4iLCJpZ25vcmVfbSIsIkxldF9zeW50YXgiLCJtYXAyIiwiYm90aCIsInN5bWJvbCIsInN5bWJvbF9tYXAiLCJhcHBseSIsIm1hcDMiLCJhbGwiLCJhbGxfdW5pdCIsIkFwcGxpY2F0aXZlX2luZml4IiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZmluaXNoIiwiQmFzZV9PcHRpb24iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9vcHRpb24ubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVAsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxZQUFBQyxlQUFBQztBQUFBQSxJQ2lDNEIsbURBQW9DO0FBQUE7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LEdDZ1FpQixjQUFNO0FBQUEsT0FBQTJDLFFEaFF2QjtBQUFBLFlBQUFRLEtBQUFuRCxHQUFBaUMsR0FBQWpFO0FBQUFBLElDb1FJO0FBQUEsU0FBQWlFLE1BQUEsTUFBQWpDLE1BQUE7QUFBQSxLQUV5QixtQ0FBTztBQUFBO0FBQUEsSUFEVDtBQUFBLEdBQ1M7QUFBQTtBQUFBLElBQUE2QyxZRHRRcEM7QUFBQSxJQUFBSCxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFTLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFKLFNBQUE7QUFBQSxJQUFBSyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLFlBQUF4RCxHQUFBdUIsTUFBQTNEO0FBQUFBLElDNFE2QixzREFBc0M7QUFBQTtBQUFBLFlBQUE2RixXQUFBekQsR0FBQXVCLE1BQUEzRCxHQUFBOEY7QUFBQUEsSUFDL0IsOERBQTZDO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EN1FqRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG9wdGlvbiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfb3B0aW9uXG5cbiAgbGV0IGdsb2JhbGl6ZSA6ICdhLiAoKCdhW0BvY2FtbC5sb2NhbF0pIC0+ICdhKSAtPiAoJ2EgdFtAb2NhbWwubG9jYWxdKSAtPiAnYSB0ID1cbiAgICBmdW4gKHR5cGUgYV9fMDA1XylcbiAgICAgICAgOiAoKChhX18wMDVfW0BvY2FtbC5sb2NhbF0pIC0+IGFfXzAwNV8pIC0+IChhX18wMDVfIHRbQG9jYW1sLmxvY2FsXSkgLT4gYV9fMDA1XyB0KSAtPlxuICAgICAgZ2xvYmFsaXplX29wdGlvblxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdCA6XG4gICAgJ2EuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gJ2EgdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBoYXNoX2ZvbGRfb3B0aW9uXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gICAgb3B0aW9uX29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBzZXhwX29mX29wdGlvblxuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBvcHRpb25fc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kIDpcbnNpZ1xuICB0eXBlICdhIHQgPSAnYSBvcHRpb25cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gIHZhbCBnbG9iYWxpemUgOiAoKCdhW0BvY2FtbC5sb2NhbF0pIC0+ICdhKSAtPiAoJ2EgdFtAb2NhbWwubG9jYWxdKSAtPiAnYSB0XG5cbiAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZClcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID1cbiAgfCBOb25lXG4gIHwgU29tZSBvZiAnYVxuXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NvbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHZhbHVlX21hcCBvIH5kZWZhdWx0IH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IGYgeFxuICB8IE5vbmUgLT4gZGVmYXVsdFxuOztcblxubGV0IGl0ZXIgbyB+ZiA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxuXG5sZXQgY2FsbCB4IH5mID1cbiAgbWF0Y2ggZiB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZiAtPiBmIHhcbjs7XG5cbmxldCB2YWx1ZSB0IH5kZWZhdWx0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBkZWZhdWx0XG4gIHwgU29tZSB4IC0+IHhcbjs7XG5cbmxldCB2YWx1ZV9leG4gP2hlcmUgP2Vycm9yID9tZXNzYWdlIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT5cbiAgICBsZXQgZXJyb3IgPVxuICAgICAgbWF0Y2ggaGVyZSwgZXJyb3IsIG1lc3NhZ2Ugd2l0aFxuICAgICAgfCBOb25lLCBOb25lLCBOb25lIC0+IEVycm9yLm9mX3N0cmluZyBcIk9wdGlvbi52YWx1ZV9leG4gTm9uZVwiXG4gICAgICB8IE5vbmUsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5vZl9zdHJpbmcgbVxuICAgICAgfCBOb25lLCBTb21lIGUsIE5vbmUgLT4gZVxuICAgICAgfCBOb25lLCBTb21lIGUsIFNvbWUgbSAtPiBFcnJvci50YWcgZSB+dGFnOm1cbiAgICAgIHwgU29tZSBwLCBOb25lLCBOb25lIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSBcIk9wdGlvbi52YWx1ZV9leG5cIiBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBOb25lLCBTb21lIG0gLT4gRXJyb3IuY3JlYXRlIG0gcCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90XG4gICAgICB8IFNvbWUgcCwgU29tZSBlLCBfIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZVxuICAgICAgICAgICh2YWx1ZSBtZXNzYWdlIH5kZWZhdWx0OlwiXCIpXG4gICAgICAgICAgKGUsIHApXG4gICAgICAgICAgKHNleHBfb2ZfcGFpciBFcnJvci5zZXhwX29mX3QgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdClcbiAgICBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgdmFsdWVfb3JfdGh1bmsgbyB+ZGVmYXVsdCA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0ICgpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gW3x8XVxuICB8IFNvbWUgeCAtPiBbfCB4IHxdXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgeCAtPiBbIHggXVxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZTpfID0gdFxubGV0IG1heF9lbHQgdCB+Y29tcGFyZTpfID0gdFxuXG5sZXQgc3VtICh0eXBlIGEpIChtb2R1bGUgTSA6IENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICB2YWx1ZV9tYXAgdCB+ZGVmYXVsdDpNLnplcm8gfmZcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSB4IC0+IGYgeFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgYScgLT4gZXF1YWwgYSBhJ1xuOztcblxubGV0IGxlbmd0aCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSBfIC0+IDFcbjs7XG5cbmxldCBpc19lbXB0eSA9IGlzX25vbmVcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gaW5pdFxuICB8IFNvbWUgeCAtPiBmIGluaXQgeFxuOztcblxubGV0IGNvdW50IHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIGEgLT4gaWYgZiBhIHRoZW4gMSBlbHNlIDBcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHggLT4gaWYgZiB4IHRoZW4gdCBlbHNlIE5vbmVcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IGYgYVxuOztcblxubGV0IGVxdWFsIGYgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHgsIFNvbWUgeCcgLT4gZiB4IHgnXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHNvbWUgeCA9IFNvbWUgeFxuXG5sZXQgZmlyc3Rfc29tZSB4IHkgPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBTb21lIF8gLT4geFxuICB8IE5vbmUgLT4geVxuOztcblxubGV0IHNvbWVfaWYgY29uZCB4ID0gaWYgY29uZCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcblxubGV0IG1lcmdlIGEgYiB+ZiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IE5vbmUsIHggfCB4LCBOb25lIC0+IHhcbiAgfCBTb21lIGEsIFNvbWUgYiAtPiBTb21lIChmIGEgYilcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgdiBhcyBvIHdoZW4gZiB2IC0+IG9cbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aCBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiBTb21lIHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IFNvbWUgKGYgYSlcbjs7XG5cbm1vZHVsZSBNb25hZF9hcmcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IHJldHVybiB4ID0gU29tZSB4XG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gIGxldCBiaW5kIG8gfmYgPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIDs7XG5lbmRcblxuaW5jbHVkZSBNb25hZC5NYWtlX2xvY2FsIChNb25hZF9hcmcpXG5cbm1vZHVsZSBBcHBsaWNhdGl2ZV9hcmcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IHJldHVybiB4ID0gU29tZSB4XG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gIGxldCBtYXAyIHggeSB+ZiA9XG4gICAgbWF0Y2ggeCwgeSB3aXRoXG4gICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHgsIFNvbWUgeSAtPiBTb21lIChmIHggeSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2VfdXNpbmdfbWFwMl9sb2NhbCAoQXBwbGljYXRpdmVfYXJnKVxuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjc2NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfc3JjX2Jvb2xfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJhbGwiLCJtb2R1bGVfbmFtZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9TZXhwIiwiQmFzZV9Pcl9lcnJvciIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9QcmludGYiLCJCYXNlX0NvbXBhcmF0b3IiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiaW52YWxpZF9hcmdmIiwiY29tcGFyZSIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJoYXNoYWJsZSIsIm9mX3N0cmluZyIsInMiLCJ0b19zdHJpbmciLCJpbmNsdWRlIiwiY29tcGFyYXRvciIsInBwIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsImludmFyaWFudCIsInBhcmFtIiwiYmV0d2VlbiIsInQiLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwibWluIiwibWF4IiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJ0b19pbnQiLCJzeW1ib2wiLCJhIiwiYiIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJlcXVhbCIsIkJhc2VfQm9vbCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2Jvb2wubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLFlBQUFDLEtBQUFDLEdDa0JhLDBCQUFNO0FBQUE7QUFBQSxJQUFBQyxZQUFmO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUFXYztBQUFBLDZCQUdQO0FBQUEsZUFBcUU7QUFBQTtBQUFBO0FBQUEsSUFBQUMsWUFkNUU7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFEO0FBQUFBLE1BQUE7QUFBQSxJQUFBRSxLQUFBO0FBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsWUFBQUMsVUFBQUMsT0FtQ29CLFNBQUU7QUFBQSxZQUFBQyxRQUFBQyxHQUFBQyxLQUFBQztBQUFBQSxRQUFBLE1BQ0M7QUFBQSxJQUFRLDJEQUFhO0FBQUE7QUFBQSxZQUFBQyxnQkFBQUgsR0FBQUksS0FBQUM7QUFBQUEsSUFDWDtBQUFBO0FBQUEsY0FBeUIsaURBQXdCO0FBQUE7QUFBQSxZQUFBQyxVQUFBTixHQUFBSSxLQUFBQztBQUFBQSxJQUc3RTtBQUFBLEtBQ1AsbUNBQTJCO0FBQUEsSUFEUjtBQUFBLEdBQ1E7QUFBQSxZQUFBRSxNQUFBUCxHQUFBSSxLQUFBQztBQUFBQSxJQUl4QjtBQUFBLEtBTUssd0NBQTZCO0FBQUE7QUFBQSxXQURHO0FBQUEsV0FBeEI7QUFBQSxXQUZaO0FBQUEsSUFFc0QseUNBQ3JCO0FBQUE7QUFBQSxZQUFBRyxPQUFBekIsR0FHeEIscUNBQWE7QUFBQSxZQUFBMEIsT0FBQUMsR0FBQUM7QUFBQUE7QUFBQUEsS0FBQSxNQU1tQjtBQUFBLFdBQWI7QUFBQSxLQUFBNUIsSUFBRDtBQUFBLElBRE07QUFBQSxHQUNpQjtBQUFBLFlBQUEwQixTQUFBQyxHQUFBQztBQUFBQTtBQUFBQSxLQUFBLE1BQ1I7QUFBQSxXQUFkO0FBQUEsS0FBQTVCLElBQUQ7QUFBQSxJQUZNO0FBQUEsR0FFa0I7QUFBQSxhQU03QjtBQUFBLCtCQUE4QjtBQUFBO0FBQUEsS0FBQVEsWUFBYztBQUFBLEtBQUFrQixXQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBRyxZQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFuQyxZQUFBO0FBQUEsS0FBQW9DLFFBQUE7QUFBQSxLQUFBVCxNQUFBO0FBQUEsS0FBQUQsTUFBQTtBQUFBLEtBQUFXO0FBQUFBLE9BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUEvQjtBQUFBLEVEckZ6QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJvb2wwXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJvb2xcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9ib29sIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIGZhbHNlOyB0cnVlIF0gOiB0IGxpc3QpXG4gIGxldCAoZ2xvYmFsaXplIDogKHRbQG9jYW1sLmxvY2FsXSkgLT4gdCkgPSAoZ2xvYmFsaXplX2Jvb2wgOiAodFtAb2NhbWwubG9jYWxdKSAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfYm9vbFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfYm9vbCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoYm9vbF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ib29sIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGJvb2xfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcInRydWVcIiAtPiB0cnVlXG4gICAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgICB8IHMgLT4gaW52YWxpZF9hcmdmIFwiQm9vbC5vZl9zdHJpbmc6IGV4cGVjdGVkIHRydWUgb3IgZmFsc2UgYnV0IGdvdCAlc1wiIHMgKClcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9ib29sXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQm9vbFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCB0b19pbnQgeCA9IGJvb2xfdG9faW50IHhcblxubW9kdWxlIE5vbl9zaG9ydF9jaXJjdWl0aW5nID0gc3RydWN0XG4gICgqIFdlIGRvbid0IGV4cG9zZSB0aGlzLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSBpbnZhcmlhbnQgbWVudGlvbmVkIGJlbG93IG9mXG4gICAgICh0b19pbnQgdHJ1ZSA9IDEpIGFuZCAodG9faW50IGZhbHNlID0gMCkuICopXG4gIGxldCB1bnNhZmVfb2ZfaW50ICh4IDogaW50KSA6IGJvb2wgPSBTdGRsaWIuT2JqLm1hZ2ljIHhcbiAgbGV0ICggfHwgKSBhIGIgPSB1bnNhZmVfb2ZfaW50ICh0b19pbnQgYSBsb3IgdG9faW50IGIpXG4gIGxldCAoICYmICkgYSBiID0gdW5zYWZlX29mX2ludCAodG9faW50IGEgbGFuZCB0b19pbnQgYilcbmVuZFxuXG4oKiBXZSBkbyB0aGlzIGFzIGEgZGlyZWN0IGFzc2VydCBvbiB0aGUgdGhlb3J5IHRoYXQgaXQncyBhIGNoZWFwIHRoaW5nIHRvIHRlc3QgYW5kIGFcbiAgIHJlYWxseSBjb3JlIGludmFyaWFudCB0aGF0IHdlIG5ldmVyIGV4cGVjdCB0byBicmVhaywgYW5kIHdlIHNob3VsZCBiZSBoYXBweSBmb3IgYVxuICAgcHJvZ3JhbSB0byBmYWlsIGltbWVkaWF0ZWx5IGlmIHRoaXMgaXMgdmlvbGF0ZWQuICopXG5sZXQgKCkgPSBhc3NlcnQgKFBvbHkuKCA9ICkgKHRvX2ludCB0cnVlKSAxICYmIFBvbHkuKCA9ICkgKHRvX2ludCBmYWxzZSkgMClcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTI5MjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiRW51bWVyYWJsZSIsIkJhc2VfUHB4X2VudW1lcmF0ZV9saWIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMseUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjk0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfQm90aCIsImNzdF9MZWZ0IiwiY3N0X1JpZ2h0IiwiY3N0X1NlcXVlbmNlX250aCIsImNzdF9ib3RoIiwiY3N0X2xlZnQiLCJjc3RfcmlnaHQiLCJjc3Rfc3RhdGUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJlcnJvcl9zb3VyY2VfMDI3IiwiQmFzZV9MaXN0MSIsIkJhc2VfV2l0aF9yZXR1cm4iLCJCYXNlX0ltcG9ydCIsIkNhbWxpbnRlcm5hbExhenkiLCJCYXNlX1Jlc3VsdCIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9Cb29sIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiQmFzZV9IYXNoIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0FycmF5MCIsIkJhc2VfTW9uYWQiLCJzZXhwX29mX3QiLCJvZl9hXzAwMSIsIm9mX3NfMDAyIiwicGFyYW0iLCJzdGF0ZV8wMDQiLCJhcmdfMDA1IiwiYm5kc18wMDMiLCJzdGF0ZV8wMDkiLCJ2YWx1ZV8wMDciLCJhcmdfMDEwIiwiYm5kc18wMDYiLCJhcmdfMDA4IiwiU3RlcCIsIm5leHRfc3RlcCIsInMiLCJtYXRjaCIsImEiLCJkZWxheWVkX2ZvbGRfc3RlcCIsImluaXQiLCJmaW5pc2giLCJsb29wIiwibmV4dCIsImFjYyIsIkV4cGVydCIsInVuZm9sZF9zdGVwIiwidW5mb2xkIiwidW5mb2xkX3dpdGgiLCJzZWVkIiwidW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCIsInJ1bm5pbmdfc3RlcCIsImlubmVyX2ZpbmlzaGVkIiwiZmluaXNoaW5nX3N0ZXAiLCJzdGF0ZSIsInkiLCJpbm5lcl9zdGF0ZSIsIngiLCJvZl9saXN0IiwibCIsImZvbGQiLCJ0IiwidiIsInRvX2xpc3RfcmV2IiwidG9fbGlzdCIsImkiLCJzZXhwX29mX2EiLCJyYW5nZSIsIm9wdCIsInN0YXJ0X3YiLCJzdG9wX3YiLCJzdHJpZGUiLCJzdGFydCIsInN0b3AiLCJzdGVwIiwib2ZfbGF6eSIsInRfbGF6eSIsIm1hcGkiLCJmb2xkaW5nX21hcCIsImZvbGRpbmdfbWFwaSIsImZpbHRlciIsImZpbHRlcmkiLCJsZW5ndGgiLCJ0b19hcnJheSIsImxlbiIsImZpbmQiLCJmaW5kX21hcCIsInNvbWVfYiIsImZpbmRfbWFwaSIsImZvcl9hbGwiLCJmb3JfYWxsaSIsImV4aXN0cyIsImV4aXN0c2kiLCJpdGVyIiwiaXNfZW1wdHkiLCJtZW0iLCJlcXVhbCIsImIiLCJlbXB0eSIsImJpbmQiLCJyZXN0IiwicmV0dXJuIiwibWFwIiwiaW5jbHVkZSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsIk1vbmFkX2luZml4Iiwiam9pbiIsImlnbm9yZV9tIiwiYWxsIiwiYWxsX3VuaXQiLCJMZXRfc3ludGF4IiwibnRoIiwibiIsIm50aF9leG4iLCJjb21wYXJlIiwiY21wX2EiLCJjbXBfYiIsImFfMDEzIiwiYl8wMTQiLCJhXzAxNSIsImJfMDE2IiwiYV8wMTciLCJiXzAxOCIsImFfMDIxIiwiYV8wMTkiLCJiXzAyMiIsImJfMDIwIiwiaGFzaF9mb2xkX3QiLCJoYXNoX2ZvbGRfYSIsImhhc2hfZm9sZF9iIiwiaHN2IiwiYXJnIiwidF9vZl9zZXhwIiwib2ZfYV8wMjMiLCJvZl9iXzAyNCIsInNleHBfMDI5IiwidGFnXzAzMCIsInNleHBfYXJnc18wMzYiLCJhcmcwXzAzNyIsInJlczBfMDM4Iiwic2V4cF9hcmdzXzAzMSIsImFyZzBfMDMyIiwicmVzMF8wMzMiLCJzZXhwX2FyZ3NfMDQxIiwiYXJnMV8wNDMiLCJhcmcwXzA0MiIsInJlczBfMDQ0IiwicmVzMV8wNDUiLCJvZl9hXzA0OCIsIm9mX2JfMDQ5IiwiYXJnMF8wNTAiLCJyZXMwXzA1MSIsImFyZzBfMDUyIiwicmVzMF8wNTMiLCJhcmcxXzA1NSIsImFyZzBfMDU0IiwicmVzMF8wNTYiLCJyZXMxXzA1NyIsInRfc2V4cF9ncmFtbWFyIiwiYV9zZXhwX2dyYW1tYXIiLCJiX3NleHBfZ3JhbW1hciIsIk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50IiwiY3N0X2hkX2V4biIsImNzdF9TZXF1ZW5jZV90bF9leG4iLCJjc3RfU2VxdWVuY2VfY2h1bmtzX2V4biIsImNzdF9TZXF1ZW5jZV9maW5kX2V4biIsImNzdF9TZXF1ZW5jZV9yZWR1Y2VfZXhuIiwiY3N0X1NlcXVlbmNlX3N1YiIsImNzdF9TZXF1ZW5jZV90YWtlIiwiY3N0X1NlcXVlbmNlX2Ryb3AiLCJtZXJnZV93aXRoX2R1cGxpY2F0ZXMiLCJuZXh0MiIsInMyIiwibmV4dDEiLCJzMSIsImNvbXBhcmlzb24iLCJtZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWQiLCJtZXJnZV9zb3J0ZWQiLCJoZCIsImhkX2V4biIsInRsIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiZmlsdGVyX29wdCIsImZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwaSIsInNwbGl0X24iLCJhY2N1bSIsImNodW5rc19leG4iLCJ4cyIsImZpbmRpIiwiZmluZF9leG4iLCJhcHBlbmQiLCJjb25jYXRfbWFwIiwiY29uY2F0IiwiY29uY2F0X21hcGkiLCJ6aXAiLCJ6aXBfZnVsbCIsImJvdW5kZWRfbGVuZ3RoIiwiYXRfbW9zdCIsImxlbmd0aF9pc19ib3VuZGVkX2J5IiwibWF4IiwibWluIiwiaXRlcmkiLCJmb2xkaSIsInJlZHVjZSIsInJlZHVjZV9leG4iLCJyZXMiLCJncm91cCIsImJyZWFrIiwiY3VyIiwicHJldiIsImZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIiwibGFzdF9lbHQiLCJyZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyIsImNvdW50IiwiZWx0IiwiY291bnRpIiwic3VtIiwibSIsIm1pbl9lbHQiLCJtYXhfZWx0Iiwic3ViIiwicG9zIiwidGFrZSIsImRyb3AiLCJ0YWtlX3doaWxlIiwiZHJvcF93aGlsZSIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfcmlnaHRfd2l0aF9saXN0IiwiSW5maXgiLCJjc3RfU2VxdWVuY2VfY3ljbGVfbGlzdF9leG4iLCJpbnRlcnNwZXJzZSIsInNlcCIsInJlcGVhdCIsImN5Y2xlX2xpc3RfZXhuIiwiY2FydGVzaWFuX3Byb2R1Y3QiLCJzYSIsInNiIiwic2luZ2xldG9uIiwiZGVsYXllZF9mb2xkIiwib3B0aW9uIiwiayIsImZvbGRfbSIsIml0ZXJfbSIsImZvbGRfdW50aWwiLCJmb2xkX3Jlc3VsdCIsImUiLCJmb3JjZV9lYWdlcmx5IiwibWVtb2l6ZSIsImRyb3BfZWFnZXJseSIsImRyb3Bfd2hpbGVfb3B0aW9uIiwiY29tcGFyZV9hIiwidDEiLCJ0MiIsInIiLCJ2MiIsInYxIiwiYyIsImVxdWFsX2EiLCJyb3VuZF9yb2JpbiIsImxpc3QiLCJkb25lX3N0YWNrIiwidG9kb19zdGFjayIsImludGVybGVhdmUiLCJmMSIsImYyIiwiaW50ZXJsZWF2ZWRfY2FydGVzaWFuX3Byb2R1Y3QiLCJ4MSIsIngyIiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQiLCJvZl9zZXF1ZW5jZSIsInNlcXVlbmNlIiwicnVuIiwidGh1bmsiLCJCYXNlX1NlcXVlbmNlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvc2VxdWVuY2UubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxVQUFBQyxVQUFBQztBQUFBQSxJQ3dCSSw4QkFJYztBQUFBLElBSmQ7QUFBQTtBQUFBLE1BQUFDLFlBQUE7QUFBQSxNQUFBQyxVQVF3QjtBQUFBLE1BQUFDLFdBQ2Y7QUFBQSxLQUdI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IENvbnRhaW5lcl9pbnRmLkV4cG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgTGlzdCA9IExpc3QxXG5cbm1vZHVsZSBTdGVwID0gc3RydWN0XG4gICgqICdhIGlzIGFuIGl0ZW0gaW4gdGhlIHNlcXVlbmNlLCAncyBpcyB0aGUgc3RhdGUgdGhhdCB3aWxsIHByb2R1Y2UgdGhlIHJlbWFpbmRlciBvZlxuICAgICB0aGUgc2VxdWVuY2UgKilcbiAgdHlwZSAoJ2EsICdzKSB0ID1cbiAgICB8IERvbmVcbiAgICB8IFNraXAgb2YgeyBzdGF0ZSA6ICdzIH1cbiAgICB8IFlpZWxkIG9mXG4gICAgICAgIHsgdmFsdWUgOiAnYVxuICAgICAgICA7IHN0YXRlIDogJ3NcbiAgICAgICAgfVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAncy5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgncyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAncykgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDExXyBzX18wMTJfKVxuICAgICAgICA6ICAoKGFfXzAxMV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDEyXyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgICAtPiAoYV9fMDExXywgc19fMDEyXykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgICBmdW4gX29mX2FfXzAwMV8gX29mX3NfXzAwMl8gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBEb25lIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkRvbmVcIlxuICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHN0YXRlX18wMDRfIH0gLT5cbiAgICAgICAgICBsZXQgYm5kc19fMDAzXyA9IChbXSA6IF8gU3RkbGliLkxpc3QudCkgaW5cbiAgICAgICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgICAgICBsZXQgYXJnX18wMDVfID0gX29mX3NfXzAwMl8gc3RhdGVfXzAwNF8gaW5cbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJzdGF0ZVwiOyBhcmdfXzAwNV8gXSA6OiBibmRzX18wMDNfXG4gICAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBcIlNraXBcIiA6OiBibmRzX18wMDNfKVxuICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB2YWx1ZV9fMDA3Xzsgc3RhdGUgPSBzdGF0ZV9fMDA5XyB9IC0+XG4gICAgICAgICAgbGV0IGJuZHNfXzAwNl8gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gICAgICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICAgICAgbGV0IGFyZ19fMDEwXyA9IF9vZl9zX18wMDJfIHN0YXRlX18wMDlfIGluXG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwic3RhdGVcIjsgYXJnX18wMTBfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICAgICAgbGV0IGFyZ19fMDA4XyA9IF9vZl9hX18wMDFfIHZhbHVlX18wMDdfIGluXG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwidmFsdWVcIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgICAgIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gXCJZaWVsZFwiIDo6IGJuZHNfXzAwNl8pXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5vcGVuIFN0ZXBcblxuKCogJ2EgaXMgYW4gaXRlbSBpbiB0aGUgc2VxdWVuY2UsICdzIGlzIHRoZSBzdGF0ZSB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgcmVtYWluZGVyIG9mIHRoZVxuICAgc2VxdWVuY2UgKilcbnR5cGUgK18gdCA9XG4gIHwgU2VxdWVuY2UgOlxuICAgICAgeyBzdGF0ZSA6ICdzXG4gICAgICA7IG5leHQgOiAncyAtPiAoJ2EsICdzKSBTdGVwLnRcbiAgICAgIH1cbiAgICAgIC0+ICdhIHRcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgbmV4dF9zdGVwIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSkgPVxuICAgIG1hdGNoIGYgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSB9XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9IH1cbiAgOztcblxuICBsZXQgZGVsYXllZF9mb2xkX3N0ZXAgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGxvb3AgcyBuZXh0IGZpbmlzaCBmIGFjYyA9XG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IGZpbmlzaCBhY2NcbiAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGYgYWNjIE5vbmUgfms6KGxvb3AgcyBuZXh0IGZpbmlzaCBmKVxuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gZiBhY2MgKFNvbWUgYSkgfms6KGxvb3AgcyBuZXh0IGZpbmlzaCBmKVxuICAgIGluXG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuZXh0IGZpbmlzaCBmIGluaXRcbiAgOztcbmVuZFxuXG5sZXQgdW5mb2xkX3N0ZXAgfmluaXQgfmYgPSBTZXF1ZW5jZSB7IHN0YXRlID0gaW5pdDsgbmV4dCA9IGYgfVxuXG5sZXQgdW5mb2xkIH5pbml0IH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQgfmY6KGZ1biBzIC0+XG4gICAgbWF0Y2ggZiBzIHdpdGhcbiAgICB8IE5vbmUgLT4gU3RlcC5Eb25lXG4gICAgfCBTb21lIChhLCBzKSAtPiBTdGVwLllpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSlcbjs7XG5cbmxldCB1bmZvbGRfd2l0aCBzIH5pbml0IH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gaW5pdCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChzZWVkLCBzKSAtPlxuICAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzZWVkLCBzIH1cbiAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICAgICAgKG1hdGNoIGYgc2VlZCBhIHdpdGhcbiAgICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gc2VlZCB9IC0+IFNraXAgeyBzdGF0ZSA9IHNlZWQsIHMgfVxuICAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gc2VlZCB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHNlZWQsIHMgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgdW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCBzIH5pbml0IH5ydW5uaW5nX3N0ZXAgfmlubmVyX2ZpbmlzaGVkIH5maW5pc2hpbmdfc3RlcCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGBJbm5lcl9ydW5uaW5nIChpbml0LCBzKVxuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHN0YXRlIC0+XG4gICAgICAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICAgICAgIHwgYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgLT5cbiAgICAgICAgICAgICAgIChtYXRjaCBuZXh0IGlubmVyX3N0YXRlIHdpdGhcbiAgICAgICAgICAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gYElubmVyX2ZpbmlzaGVkIChpbm5lcl9maW5pc2hlZCBzdGF0ZSkgfVxuICAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gaW5uZXJfc3RhdGUgfSAtPlxuICAgICAgICAgICAgICAgICAgU2tpcCB7IHN0YXRlID0gYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgfVxuICAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gaW5uZXJfc3RhdGUgfSAtPlxuICAgICAgICAgICAgICAgICAgKG1hdGNoIHJ1bm5pbmdfc3RlcCBzdGF0ZSB4IHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlIH0gLT4gU2tpcCB7IHN0YXRlID0gYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgfVxuICAgICAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHk7IHN0YXRlIH0gLT5cbiAgICAgICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSB5OyBzdGF0ZSA9IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIH0pKVxuICAgICAgICAgICAgIHwgYElubmVyX2ZpbmlzaGVkIHN0YXRlIC0+XG4gICAgICAgICAgICAgICAobWF0Y2ggZmluaXNoaW5nX3N0ZXAgc3RhdGUgd2l0aFxuICAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgfSAtPiBTa2lwIHsgc3RhdGUgPSBgSW5uZXJfZmluaXNoZWQgc3RhdGUgfVxuICAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHk7IHN0YXRlIH0gLT5cbiAgICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSB5OyBzdGF0ZSA9IGBJbm5lcl9maW5pc2hlZCBzdGF0ZSB9KSlcbiAgICAgIH1cbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDpsIH5mOihmdW5jdGlvblxuICAgIHwgW10gLT4gRG9uZVxuICAgIHwgeCA6OiBsIC0+IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IGwgfSlcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCB2IG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gdlxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyB2IG5leHQgZlxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyAoZiB2IGEpIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBpbml0IG5leHQgZlxuOztcblxubGV0IHRvX2xpc3RfcmV2IHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKVxuXG5cbmxldCB0b19saXN0IChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSA9XG4gIGxldCBzYWZlX3RvX2xpc3QgdCA9IExpc3QucmV2ICh0b19saXN0X3JldiB0KSBpblxuICBsZXQgcmVjIHRvX2xpc3QgcyBuZXh0IGkgPVxuICAgIGlmIGkgPSAwXG4gICAgdGhlbiBzYWZlX3RvX2xpc3QgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IFtdXG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiB0b19saXN0IHMgbmV4dCBpXG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBhIDo6IHRvX2xpc3QgcyBuZXh0IChpIC0gMSkpXG4gIGluXG4gIHRvX2xpc3QgcyBuZXh0IDUwMFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X3Ygc3RvcF92ID1cbiAgbGV0IHN0ZXAgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgYGluY2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID4gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSBpOyBzdGF0ZSA9IGkgKyBzdHJpZGUgfVxuICAgIHwgYGluY2x1c2l2ZSAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA8IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gaTsgc3RhdGUgPSBpICsgc3RyaWRlIH1cbiAgICB8IGBleGNsdXNpdmUgd2hlbiBzdHJpZGUgPj0gMCAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA+PSBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGk7IHN0YXRlID0gaSArIHN0cmlkZSB9XG4gICAgfCBgZXhjbHVzaXZlIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpIDw9IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gaTsgc3RhdGUgPSBpICsgc3RyaWRlIH1cbiAgaW5cbiAgbGV0IGluaXQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfdlxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBzdGFydF92ICsgc3RyaWRlXG4gIGluXG4gIHVuZm9sZF9zdGVwIH5pbml0IH5mOnN0ZXBcbjs7XG5cbmxldCBvZl9sYXp5IHRfbGF6eSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnRfbGF6eSB+ZjooZnVuIHRfbGF6eSAtPlxuICAgIGxldCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgPSBMYXp5LmZvcmNlIHRfbGF6eSBpblxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgU2tpcFxuICAgICAgICB7IHN0YXRlID1cbiAgICAgICAgICAgIChsZXQgdiA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gaW5cbiAgICAgICAgICAgICBsYXp5IHYpXG4gICAgICAgIH1cbiAgICB8IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgWWllbGRcbiAgICAgICAgeyB2YWx1ZSA9IHhcbiAgICAgICAgOyBzdGF0ZSA9XG4gICAgICAgICAgICAobGV0IHYgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IGluXG4gICAgICAgICAgICAgbGF6eSB2KVxuICAgICAgICB9KVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gc2VlZFxuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHNlZWQgLT5cbiAgICAgICAgICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGYgYTsgc3RhdGUgPSBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gMCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChpLCBzKSAtPlxuICAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpLCBzIH1cbiAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gZiBpIGE7IHN0YXRlID0gaSArIDEsIHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdCB+ZjooZnVuIGFjYyB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgYWNjIHggaW5cbiAgICBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBhY2MgfSlcbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF93aXRoIHQgfmluaXQ6KDAsIGluaXQpIH5mOihmdW4gKGksIGFjYykgeCAtPlxuICAgIGxldCBhY2MsIHggPSBmIGkgYWNjIHggaW5cbiAgICBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBpICsgMSwgYWNjIH0pXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBzZWVkXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gc2VlZCAtPlxuICAgICAgICAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGYgYSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbWFwIH5mOnNuZCAoZmlsdGVyIChtYXBpIHQgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKSlcbjs7XG5cbmxldCBsZW5ndGggdCA9XG4gIGxldCByZWMgbG9vcCBpIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gaVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgaSBzIG5leHRcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIChpICsgMSkgcyBuZXh0XG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6KFtdLCAwKSB+ZjooZnVuIChsLCBpKSB4IC0+IHggOjogbCwgaSArIDEpXG5cbmxldCB0b19hcnJheSB0ID1cbiAgbGV0IGwsIGxlbiA9IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IHggOjogbCAtPlxuICAgIGxldCBhID0gQXJyYXkuY3JlYXRlIH5sZW4geCBpblxuICAgIGxldCByZWMgbG9vcCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCAoaSA9IC0xKVxuICAgICAgfCB4IDo6IGwgLT5cbiAgICAgICAgYS4oaSkgPC0geDtcbiAgICAgICAgbG9vcCAoaSAtIDEpIGxcbiAgICBpblxuICAgIGxvb3AgKGxlbiAtIDIpIGw7XG4gICAgYVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gZiBhIC0+IFNvbWUgYVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggZiBhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBzIG5leHQgZlxuICAgICAgIHwgc29tZV9iIC0+IHNvbWVfYilcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggZiBpIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICAgICB8IHNvbWVfYiAtPiBzb21lX2IpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gd2hlbiBub3QgKGYgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gbm90IChmIGkgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIGYgYSAtPiB0cnVlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIGYgaSBhIC0+IHRydWVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgfCBEb25lIC0+ICgpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZlxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICBmIGE7XG4gICAgICBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGlzX2VtcHR5IHQgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIF8gLT4gZmFsc2VcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBhID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gXyB9IHdoZW4gZXF1YWwgYSBiIC0+IHRydWVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBhXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgYSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZW1wdHkgPSBTZXF1ZW5jZSB7IHN0YXRlID0gKCk7IG5leHQgPSAoZnVuICgpIC0+IERvbmUpIH1cblxubGV0IGJpbmQgdCB+ZiA9XG4gIHVuZm9sZF9zdGVwXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0sIHJlc3QgLT5cbiAgICAgICAgKG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICB8IERvbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgICAgICAgIFNraXAgeyBzdGF0ZSA9IGVtcHR5LCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgICAgICAgIFNraXAgeyBzdGF0ZSA9IGYgYSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSB9KSlcbiAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0sIHJlc3QgfVxuICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSwgcmVzdCB9KSlcbiAgICB+aW5pdDooZW1wdHksIHQpXG47O1xuXG5sZXQgcmV0dXJuIHggPVxuICB1bmZvbGRfc3RlcCB+aW5pdDooU29tZSB4KSB+ZjooZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gRG9uZVxuICAgIHwgU29tZSB4IC0+IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IE5vbmUgfSlcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgZW5kKVxuXG5sZXQgbnRoIHMgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBOb25lXG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIGkgcyBuZXh0XG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICBpZiBwaHlzX2VxdWFsIGkgMCB0aGVuIFNvbWUgYSBlbHNlIGxvb3AgKGkgLSAxKSBzIG5leHRcbiAgICBpblxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIG4gcyBuZXh0KVxuOztcblxubGV0IG50aF9leG4gcyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLm50aFwiXG4gIGVsc2UgKFxuICAgIG1hdGNoIG50aCBzIG4gd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLm50aFwiXG4gICAgfCBTb21lIHggLT4geClcbjs7XG5cbm1vZHVsZSBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgTGVmdCBvZiAnYVxuICAgIHwgUmlnaHQgb2YgJ2JcbiAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAxM18gYl9fMDE0XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDEzXyBiX18wMTRfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMTNfLCBiX18wMTRfIHdpdGhcbiAgICAgIHwgTGVmdCBfYV9fMDE1XywgTGVmdCBfYl9fMDE2XyAtPiBfY21wX19hIF9hX18wMTVfIF9iX18wMTZfXG4gICAgICB8IExlZnQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBMZWZ0IF8gLT4gMVxuICAgICAgfCBSaWdodCBfYV9fMDE3XywgUmlnaHQgX2JfXzAxOF8gLT4gX2NtcF9fYiBfYV9fMDE3XyBfYl9fMDE4X1xuICAgICAgfCBSaWdodCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIFJpZ2h0IF8gLT4gMVxuICAgICAgfCBCb3RoIChfYV9fMDE5XywgX2FfXzAyMV8pLCBCb3RoIChfYl9fMDIwXywgX2JfXzAyMl8pIC0+XG4gICAgICAgIChtYXRjaCBfY21wX19hIF9hX18wMTlfIF9iX18wMjBfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19iIF9hX18wMjFfIF9iX18wMjJfXG4gICAgICAgICB8IG4gLT4gbikpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90XG4gICAgOiB0eXBlIGEgYi5cbiAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICAtPiAoYSwgYikgdFxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIGZ1biBfaGFzaF9mb2xkX2EgX2hhc2hfZm9sZF9iIGhzdiBhcmcgLT5cbiAgICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgICB8IExlZnQgX2EwIC0+XG4gICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgICAgfCBSaWdodCBfYTAgLT5cbiAgICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2EwXG4gICAgICB8IEJvdGggKF9hMCwgX2ExKSAtPlxuICAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyIGluXG4gICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgICAgICBpblxuICAgICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICdhICdiLlxuICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpXG4gICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYilcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNDZfIGJfXzA0N18pXG4gICAgICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzA0Nl8pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDQ3XykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgICAgICAgICAtPiAoYV9fMDQ2XywgYl9fMDQ3XykgdCkgLT5cbiAgICAgIGxldCBlcnJvcl9zb3VyY2VfXzAyN18gPSBcInNlcXVlbmNlLm1sLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50LnRcIiBpblxuICAgICAgZnVuIF9vZl9hX18wMjNfIF9vZl9iX18wMjRfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJsZWZ0XCIgfCBcIkxlZnRcIikgYXMgX3RhZ19fMDMwXykgOjogc2V4cF9hcmdzX18wMzFfKSBhc1xuICAgICAgICAgIF9zZXhwX18wMjlfIC0+XG4gICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDMxXyB3aXRoXG4gICAgICAgICAgIHwgWyBhcmcwX18wMzJfIF0gLT5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMDMzXyA9IF9vZl9hX18wMjNfIGFyZzBfXzAzMl8gaW5cbiAgICAgICAgICAgICBMZWZ0IHJlczBfXzAzM19cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjdfXG4gICAgICAgICAgICAgICBfdGFnX18wMzBfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDI5XylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIF90YWdfXzAzNV8pIDo6IHNleHBfYXJnc19fMDM2XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDM0XyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAzNl8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDM3XyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzAzOF8gPSBfb2ZfYl9fMDI0XyBhcmcwX18wMzdfIGluXG4gICAgICAgICAgICAgUmlnaHQgcmVzMF9fMDM4X1xuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAyN19cbiAgICAgICAgICAgICAgIF90YWdfXzAzNV9cbiAgICAgICAgICAgICAgIF9zZXhwX18wMzRfKVxuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiYm90aFwiIHwgXCJCb3RoXCIpIGFzIF90YWdfXzA0MF8pIDo6IHNleHBfYXJnc19fMDQxXykgYXNcbiAgICAgICAgICBfc2V4cF9fMDM5XyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA0MV8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDQyXzsgYXJnMV9fMDQzXyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzA0NF8gPSBfb2ZfYV9fMDIzXyBhcmcwX18wNDJfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzA0NV8gPSBfb2ZfYl9fMDI0XyBhcmcxX18wNDNfIGluXG4gICAgICAgICAgICAgQm90aCAocmVzMF9fMDQ0XywgcmVzMV9fMDQ1XylcbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjdfXG4gICAgICAgICAgICAgICBfdGFnX18wNDBfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDM5XylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIHNleHBfXzAyOF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIHNleHBfXzAyOF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBzZXhwX18wMjhfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDI2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgICAgICAgfCBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdiLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNThfIGJfXzA1OV8pXG4gICAgICAgIDogICgoYV9fMDU4XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wNTlfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAgIC0+IChhX18wNThfLCBiX18wNTlfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICAgIGZ1biBfb2ZfYV9fMDQ4XyBfb2ZfYl9fMDQ5XyAtPiBmdW5jdGlvblxuICAgICAgICB8IExlZnQgYXJnMF9fMDUwXyAtPlxuICAgICAgICAgIGxldCByZXMwX18wNTFfID0gX29mX2FfXzA0OF8gYXJnMF9fMDUwXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgcmVzMF9fMDUxXyBdXG4gICAgICAgIHwgUmlnaHQgYXJnMF9fMDUyXyAtPlxuICAgICAgICAgIGxldCByZXMwX18wNTNfID0gX29mX2JfXzA0OV8gYXJnMF9fMDUyXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IHJlczBfXzA1M18gXVxuICAgICAgICB8IEJvdGggKGFyZzBfXzA1NF8sIGFyZzFfXzA1NV8pIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzA1Nl8gPSBfb2ZfYV9fMDQ4XyBhcmcwX18wNTRfXG4gICAgICAgICAgYW5kIHJlczFfXzA1N18gPSBfb2ZfYl9fMDQ5XyBhcmcxX18wNTVfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiOyByZXMwX18wNTZfOyByZXMxX18wNTdfIF1cbiAgOztcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOlxuICAgICdhICdiLlxuICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgVmFyaWFudFxuICAgICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkxlZnRcIlxuICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiUmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiQm90aFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmxldCBtZXJnZV93aXRoX2R1cGxpY2F0ZXNcbiAgICAgIChTZXF1ZW5jZSB7IHN0YXRlID0gczE7IG5leHQgPSBuZXh0MSB9KVxuICAgICAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IG5leHQyIH0pXG4gICAgICB+Y29tcGFyZVxuICA9XG4gIGxldCB1bnNoYWRvd2VkX2NvbXBhcmUgPSBjb21wYXJlIGluXG4gIGxldCBvcGVuIE1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50IGluXG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMxIH0sIHMyIC0+IFNraXAgeyBzdGF0ZSA9IG5leHQxIHMxLCBzMiB9XG4gICAgfCBzMSwgU2tpcCB7IHN0YXRlID0gczIgfSAtPiBTa2lwIHsgc3RhdGUgPSBzMSwgbmV4dDIgczIgfVxuICAgIHwgKFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxJyB9IGFzIHMxKSwgKFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyJyB9IGFzIHMyKVxuICAgICAgLT5cbiAgICAgIGxldCBjb21wYXJpc29uID0gdW5zaGFkb3dlZF9jb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8IDBcbiAgICAgIHRoZW4gWWllbGQgeyB2YWx1ZSA9IExlZnQgYTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMScgfSwgczIgfVxuICAgICAgZWxzZSBpZiBjb21wYXJpc29uID0gMFxuICAgICAgdGhlblxuICAgICAgICBZaWVsZCB7IHZhbHVlID0gQm90aCAoYSwgYik7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEnIH0sIFNraXAgeyBzdGF0ZSA9IHMyJyB9IH1cbiAgICAgIGVsc2UgWWllbGQgeyB2YWx1ZSA9IFJpZ2h0IGI7IHN0YXRlID0gczEsIFNraXAgeyBzdGF0ZSA9IHMyJyB9IH1cbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEgfSwgRG9uZSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IExlZnQgYTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBEb25lIH1cbiAgICB8IERvbmUsIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBSaWdodCBiOyBzdGF0ZSA9IERvbmUsIFNraXAgeyBzdGF0ZSA9IHMyIH0gfVxuICBpblxuICBTZXF1ZW5jZSB7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgU2tpcCB7IHN0YXRlID0gczIgfTsgbmV4dCB9XG47O1xuXG5sZXQgbWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIHMxIHMyIH5jb21wYXJlID1cbiAgbWFwIChtZXJnZV93aXRoX2R1cGxpY2F0ZXMgczEgczIgfmNvbXBhcmUpIH5mOihmdW5jdGlvblxuICAgIHwgTGVmdCB4IHwgUmlnaHQgeCB8IEJvdGggKHgsIF8pIC0+IHgpXG47O1xuXG5sZXQgKG1lcmdlIFtAZGVwcmVjYXRlZFxuICAgICAgIFwiW3NpbmNlIDIwMjEtMDddIEZvciBpZGVudGljYWwgYmVoYXZpb3IsIHVzZSBcXFxuICAgICAgICBbU2VxdWVuY2UubWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkXSwgYnV0IGNvbnNpZGVyIHVzaW5nIFxcXG4gICAgICAgIFtTZXF1ZW5jZS5tZXJnZV9zb3J0ZWRdIGluc3RlYWQuXCJdKVxuICA9XG4gIG1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZFxuOztcblxubGV0IG1lcmdlX3NvcnRlZFxuICAgICAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0pXG4gICAgICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSlcbiAgICAgIH5jb21wYXJlXG4gID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSwgczIgLT4gU2tpcCB7IHN0YXRlID0gbmV4dDEgczEsIHMyIH1cbiAgICB8IHMxLCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IHMxLCBuZXh0MiBzMiB9XG4gICAgfCAoWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEnIH0gYXMgczEpLCAoWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczInIH0gYXMgczIpXG4gICAgICAtPlxuICAgICAgbGV0IGNvbXBhcmlzb24gPSBjb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8PSAwXG4gICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxJyB9LCBzMiB9XG4gICAgICBlbHNlIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMxLCBTa2lwIHsgc3RhdGUgPSBzMicgfSB9XG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0sIERvbmUgLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIERvbmUgfVxuICAgIHwgRG9uZSwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczIgfSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gRG9uZSwgU2tpcCB7IHN0YXRlID0gczIgfSB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9OyBuZXh0IH1cbjs7XG5cbmxldCBoZCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gLT4gU29tZSBhXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBoZF9leG4gcyA9XG4gIG1hdGNoIGhkIHMgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJoZF9leG5cIlxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgdGwgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gYSB9IC0+IFNvbWUgYVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgKG1hdGNoIGxvb3AgcyBuZXh0IHdpdGhcbiAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgfCBTb21lIHMgLT4gU29tZSAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkpXG47O1xuXG5sZXQgdGxfZWFnZXJseV9leG4gcyA9XG4gIG1hdGNoIHRsIHMgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS50bF9leG5cIlxuICB8IFNvbWUgcyAtPiBzXG47O1xuXG5sZXQgbGlmdF9pZGVudGl0eSBuZXh0IHMgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IERvbmUgLT4gRG9uZVxuICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgSWRlbnRpdHkgcyB9XG4gIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBJZGVudGl0eSBzIH1cbjs7XG5cbmxldCBuZXh0IHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBTb21lIChhLCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuZXh0XG47O1xuXG5sZXQgZmlsdGVyX29wdCBzID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHMgLT5cbiAgICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gTm9uZTsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gU29tZSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgZmlsdGVyX21hcCBzIH5mID0gZmlsdGVyX29wdCAobWFwIHMgfmYpXG5sZXQgZmlsdGVyX21hcGkgcyB+ZiA9IGZpbHRlcl9tYXAgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCBzcGxpdF9uIHMgbiA9XG4gIGxldCByZWMgbG9vcCBzIGkgYWNjdW0gbmV4dCA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiBMaXN0LnJldiBhY2N1bSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBMaXN0LnJldiBhY2N1bSwgZW1wdHlcbiAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBpIGFjY3VtIG5leHRcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyAoaSAtIDEpIChhIDo6IGFjY3VtKSBuZXh0KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuIFtdIG5leHRcbjs7XG5cbmxldCBjaHVua3NfZXhuIHQgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UuY2h1bmtzX2V4blwiXG4gIGVsc2VcbiAgICB1bmZvbGRfc3RlcCB+aW5pdDp0IH5mOihmdW4gdCAtPlxuICAgICAgbWF0Y2ggc3BsaXRfbiB0IG4gd2l0aFxuICAgICAgfCBbXSwgX2VtcHR5IC0+IERvbmVcbiAgICAgIHwgKF8gOjogXyBhcyB4cyksIHQgLT4gWWllbGQgeyB2YWx1ZSA9IHhzOyBzdGF0ZSA9IHQgfSlcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBpIGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIGYgaSBhIC0+IFNvbWUgKGksIGEpXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgKGkgKyAxKSBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgMCBmXG47O1xuXG5sZXQgZmluZF9leG4gcyB+ZiA9XG4gIG1hdGNoIGZpbmQgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLmZpbmRfZXhuXCJcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IGFwcGVuZCBzMSBzMiA9XG4gIG1hdGNoIHMxLCBzMiB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHMxOyBuZXh0ID0gbmV4dDEgfSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gYEZpcnN0X2xpc3QgczFcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBGaXJzdF9saXN0IHMxIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0MSBzMSB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gYFNlY29uZF9saXN0IHMyIH1cbiAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSAtPiBTa2lwIHsgc3RhdGUgPSBgRmlyc3RfbGlzdCBzMSB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0gLT5cbiAgICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYEZpcnN0X2xpc3QgczEgfSlcbiAgICAgICAgICAgIHwgYFNlY29uZF9saXN0IHMyIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0MiBzMiB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IGBTZWNvbmRfbGlzdCBzMiB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYFNlY29uZF9saXN0IHMyIH0pKVxuICAgICAgfVxuOztcblxubGV0IGNvbmNhdF9tYXAgcyB+ZiA9IGJpbmQgcyB+ZlxubGV0IGNvbmNhdCBzID0gY29uY2F0X21hcCBzIH5mOkZuLmlkXG5sZXQgY29uY2F0X21hcGkgcyB+ZiA9IGNvbmNhdF9tYXAgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCB6aXAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0pIChTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBuZXh0MiB9KSA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0sIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBhLCBiOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH0gfVxuICAgIHwgRG9uZSwgXyB8IF8sIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSwgczIgLT4gU2tpcCB7IHN0YXRlID0gbmV4dDEgczEsIHMyIH1cbiAgICB8IHMxLCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IHMxLCBuZXh0MiBzMiB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9OyBuZXh0IH1cbjs7XG5cbmxldCB6aXBfZnVsbFxuICAgICAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0pXG4gICAgICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSlcbiAgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9LCBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYEJvdGggKGEsIGIpOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH0gfVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9LCBzMiAtPiBTa2lwIHsgc3RhdGUgPSBuZXh0MSBzMSwgczIgfVxuICAgIHwgczEsIFNraXAgeyBzdGF0ZSA9IHMyIH0gLT4gU2tpcCB7IHN0YXRlID0gczEsIG5leHQyIHMyIH1cbiAgICB8IERvbmUsIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBgUmlnaHQgYjsgc3RhdGUgPSBEb25lLCBuZXh0MiBzMiB9XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9LCBEb25lIC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYExlZnQgYTsgc3RhdGUgPSBuZXh0MSBzMSwgRG9uZSB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9OyBuZXh0IH1cbjs7XG5cbmxldCBib3VuZGVkX2xlbmd0aCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSkgfmF0X21vc3QgPVxuICBsZXQgcmVjIGxvb3AgaSBzZWVkIG5leHQgPVxuICAgIGlmIGkgPiBhdF9tb3N0XG4gICAgdGhlbiBgR3JlYXRlclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBgSXMgaVxuICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzZWVkIH0gLT4gbG9vcCBpIHNlZWQgbmV4dFxuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzZWVkIH0gLT4gbG9vcCAoaSArIDEpIHNlZWQgbmV4dClcbiAgaW5cbiAgbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IGxlbmd0aF9pc19ib3VuZGVkX2J5ID8obWluID0gLTEpID9tYXggdCA9XG4gIGxldCBsZW5ndGhfaXNfYXRfbGVhc3QgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pID1cbiAgICBsZXQgcmVjIGxvb3AgcyBhY2MgPVxuICAgICAgaWYgYWNjID49IG1pblxuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IGZhbHNlXG4gICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBhY2NcbiAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIChhY2MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgcyAwXG4gIGluXG4gIG1hdGNoIG1heCB3aXRoXG4gIHwgTm9uZSAtPiBsZW5ndGhfaXNfYXRfbGVhc3QgdFxuICB8IFNvbWUgbWF4IC0+XG4gICAgKG1hdGNoIGJvdW5kZWRfbGVuZ3RoIHQgfmF0X21vc3Q6bWF4IHdpdGhcbiAgICAgfCBgSXMgbGVuIHdoZW4gbGVuID49IG1pbiAtPiB0cnVlXG4gICAgIHwgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCBpdGVyaSBzIH5mID0gaXRlciAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcykgW0Bub250YWlsXVxuXG5sZXQgZm9sZGkgcyB+aW5pdCB+ZiA9XG4gIGZvbGQgfmluaXQgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biBhY2MgKGksIHMpIC0+IGYgaSBhY2MgcykgW0Bub250YWlsXVxuOztcblxubGV0IHJlZHVjZSBzIH5mID1cbiAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChhLCBzKSAtPiBTb21lIChmb2xkIHMgfmluaXQ6YSB+Zilcbjs7XG5cbmxldCByZWR1Y2VfZXhuIHMgfmYgPVxuICBtYXRjaCByZWR1Y2UgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLnJlZHVjZV9leG5cIlxuICB8IFNvbWUgcmVzIC0+IHJlc1xuOztcblxubGV0IGdyb3VwIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSB+YnJlYWsgPVxuICB1bmZvbGRfc3RlcFxuICAgIH5pbml0OihTb21lIChbXSwgcykpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gRG9uZVxuICAgICAgfCBTb21lIChhY2MsIHMpIC0+XG4gICAgICAgIChtYXRjaCBhY2MsIG5leHQgcyB3aXRoXG4gICAgICAgICB8IF8sIFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBTb21lIChhY2MsIHMpIH1cbiAgICAgICAgIHwgW10sIERvbmUgLT4gRG9uZVxuICAgICAgICAgfCBhY2MsIERvbmUgLT4gWWllbGQgeyB2YWx1ZSA9IExpc3QucmV2IGFjYzsgc3RhdGUgPSBOb25lIH1cbiAgICAgICAgIHwgW10sIFlpZWxkIHsgdmFsdWUgPSBjdXI7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IFNvbWUgKFsgY3VyIF0sIHMpIH1cbiAgICAgICAgIHwgKHByZXYgOjogXyBhcyBhY2MpLCBZaWVsZCB7IHZhbHVlID0gY3VyOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICBpZiBicmVhayBwcmV2IGN1clxuICAgICAgICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBMaXN0LnJldiBhY2M7IHN0YXRlID0gU29tZSAoWyBjdXIgXSwgcykgfVxuICAgICAgICAgICBlbHNlIFNraXAgeyBzdGF0ZSA9IFNvbWUgKGN1ciA6OiBhY2MsIHMpIH0pKVxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgbGFzdF9lbHQgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgbGFzdF9lbHQgc1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggbGFzdF9lbHQgd2l0aFxuICAgICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNvbWUgKGIsIGEpXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IGxvb3AgKFNvbWUgYSkgcylcbiAgaW5cbiAgbG9vcCBOb25lIHMgW0Bub250YWlsXVxuOztcblxubGV0IHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIHMgfmVxdWFsID1cbiAgdW5mb2xkX3dpdGggcyB+aW5pdDpOb25lIH5mOihmdW4gcHJldiBhIC0+XG4gICAgbWF0Y2ggcHJldiB3aXRoXG4gICAgfCBTb21lIGIgd2hlbiBlcXVhbCBhIGIgLT4gU2tpcCB7IHN0YXRlID0gU29tZSBhIH1cbiAgICB8IE5vbmUgfCBTb21lIF8gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gU29tZSBhIH0pXG47O1xuXG5sZXQgY291bnQgcyB+ZiA9IGZvbGQgcyB+aW5pdDowIH5mOihmdW4gYWNjIGVsdCAtPiBhY2MgKyBCb29sLnRvX2ludCAoZiBlbHQpKSBbQG5vbnRhaWxdXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGkgYWNjIGVsdCAtPiBhY2MgKyBCb29sLnRvX2ludCAoZiBpIGVsdCkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgaW5pdCBuIH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT5cbiAgICBpZiBpID49IG4gdGhlbiBEb25lIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGYgaTsgc3RhdGUgPSBpICsgMSB9KVxuOztcblxubGV0IHN1YiBzIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2Uuc3ViXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IDAsIHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biAoaSwgcykgLT5cbiAgICAgICAgICAgICBpZiBpIC0gcG9zID49IGxlblxuICAgICAgICAgICAgIHRoZW4gRG9uZVxuICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpLCBzIH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IHdoZW4gaSA+PSBwb3MgLT5cbiAgICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gaSArIDEsIHMgfVxuICAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSArIDEsIHMgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgdGFrZSBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLnRha2VcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gMCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChpLCBzKSAtPlxuICAgICAgICAgICAgIGlmIGkgPj0gbGVuXG4gICAgICAgICAgICAgdGhlbiBEb25lXG4gICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGksIHMgfVxuICAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gaSArIDEsIHMgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgZHJvcCBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLmRyb3BcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gMCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChpLCBzKSAtPlxuICAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpLCBzIH1cbiAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGkgPj0gbGVuIC0+XG4gICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBpICsgMSwgcyB9XG4gICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSArIDEsIHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCB0YWtlX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gcyAtPlxuICAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGYgYSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IF8gfSAtPiBEb25lKVxuICAgICAgfVxuOztcblxubGV0IGRyb3Bfd2hpbGUgcyB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGBEcm9wcGluZyBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICAgfCBgRHJvcHBpbmcgcyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgRHJvcHBpbmcgcyB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGYgYSAtPiBTa2lwIHsgc3RhdGUgPSBgRHJvcHBpbmcgcyB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgSWRlbnRpdHkgcyB9KVxuICAgICAgICAgICAgfCBgSWRlbnRpdHkgcyAtPiBsaWZ0X2lkZW50aXR5IG5leHQgcylcbiAgICAgIH1cbjs7XG5cbmxldCBzaGlmdF9yaWdodCBzIHggPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBgQ29uc2luZyAoc2VlZCwgeClcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBDb25zaW5nIChzZWVkLCB4KSAtPiBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBgSWRlbnRpdHkgc2VlZCB9XG4gICAgICAgICAgICB8IGBJZGVudGl0eSBzIC0+IGxpZnRfaWRlbnRpdHkgbmV4dCBzKVxuICAgICAgfVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCBzIGwgPSBhcHBlbmQgKG9mX2xpc3QgbCkgc1xubGV0IHNoaWZ0X2xlZnQgPSBkcm9wXG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgaW50ZXJzcGVyc2UgcyB+c2VwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gYEluaXQgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgIHwgYEluaXQgcyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgSW5pdCBzIH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBSdW5uaW5nIHMgfSlcbiAgICAgICAgICAgIHwgYFJ1bm5pbmcgcyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgUnVubmluZyBzIH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBzZXA7IHN0YXRlID0gYFB1dHRpbmcgKGEsIHMpIH0pXG4gICAgICAgICAgICB8IGBQdXR0aW5nIChhLCBzKSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBgUnVubmluZyBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgcmVwZWF0IHggPSB1bmZvbGRfc3RlcCB+aW5pdDp4IH5mOihmdW4geCAtPiBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSB4IH0pXG5cbmxldCBjeWNsZV9saXN0X2V4biB4cyA9XG4gIGlmIExpc3QuaXNfZW1wdHkgeHMgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuXCI7XG4gIGxldCBzID0gb2ZfbGlzdCB4cyBpblxuICBjb25jYXRfbWFwIH5mOihmdW4gKCkgLT4gcykgKHJlcGVhdCAoKSlcbjs7XG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCBzYSBzYiA9IGNvbmNhdF9tYXAgc2EgfmY6KGZ1biBhIC0+IHppcCAocmVwZWF0IGEpIHNiKVxubGV0IHNpbmdsZXRvbiB4ID0gcmV0dXJuIHhcblxubGV0IGRlbGF5ZWRfZm9sZCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXAgcyB+aW5pdCB+ZmluaXNoIH5mOihmdW4gYWNjIG9wdGlvbiB+ayAtPlxuICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgfCBOb25lIC0+IGsgYWNjXG4gICAgfCBTb21lIGEgLT4gZiBhY2MgYSB+aylcbjs7XG5cbmxldCBmb2xkX20gfmJpbmQgfnJldHVybiB0IH5pbml0IH5mID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwXG4gICAgdFxuICAgIH5pbml0XG4gICAgfmY6KGZ1biBhY2Mgb3B0aW9uIH5rIC0+XG4gICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgfCBOb25lIC0+IGJpbmQgKHJldHVybiBhY2MpIH5mOmtcbiAgICAgIHwgU29tZSBhIC0+IGJpbmQgKGYgYWNjIGEpIH5mOmspXG4gICAgfmZpbmlzaDpyZXR1cm5cbjs7XG5cbmxldCBpdGVyX20gfmJpbmQgfnJldHVybiB0IH5mID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwXG4gICAgdFxuICAgIH5pbml0OigpXG4gICAgfmY6KGZ1biAoKSBvcHRpb24gfmsgLT5cbiAgICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gYmluZCAocmV0dXJuICgpKSB+ZjprXG4gICAgICB8IFNvbWUgYSAtPiBiaW5kIChmIGEpIH5mOmspXG4gICAgfmZpbmlzaDpyZXR1cm5cbjs7XG5cbmxldCBmb2xkX3VudGlsIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBhY2MgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZpbmlzaCBhY2NcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGFjY1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggKGYgYWNjIGEgOiAoJ2EsICdiKSBDb250aW51ZV9vcl9zdG9wLnQpIHdpdGhcbiAgICAgICB8IFN0b3AgeCAtPiB4XG4gICAgICAgfCBDb250aW51ZSBhY2MgLT4gbG9vcCBzIG5leHQgZiBhY2MpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHQgZiBpbml0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCBzIH5pbml0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGFjYyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gUmVzdWx0LnJldHVybiBhY2NcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGFjY1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggKGYgYWNjIGEgOiAoXywgXykgUmVzdWx0LnQpIHdpdGhcbiAgICAgICB8IEVycm9yIF8gYXMgZSAtPiBlXG4gICAgICAgfCBPayBhY2MgLT4gbG9vcCBzIG5leHQgZiBhY2MpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHQgZiBpbml0XG47O1xuXG5sZXQgZm9yY2VfZWFnZXJseSB0ID0gb2ZfbGlzdCAodG9fbGlzdCB0KVxuXG5sZXQgbWVtb2l6ZSAodHlwZSBhKSAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBUIG9mIChhLCB0KSBTdGVwLnQgTGF6eS50XG4gIGVuZFxuICBpblxuICBsZXQgcmVjIG1lbW9pemUgcyA9IE0uVCAobGF6eSAoZmluZF9zdGVwIHMpKVxuICBhbmQgZmluZF9zdGVwIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBmaW5kX3N0ZXAgc1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IG1lbW9pemUgcyB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBtZW1vaXplIHM7IG5leHQgPSAoZnVuIChNLlQgbCkgLT4gTGF6eS5mb3JjZSBsKSB9XG47O1xuXG5sZXQgZHJvcF9lYWdlcmx5IHMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGkgfmxlbiBzIG5leHQgPVxuICAgIGlmIGkgPj0gbGVuXG4gICAgdGhlbiBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IGVtcHR5XG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIGkgfmxlbiBzIG5leHRcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IGxvb3AgKGkgKyAxKSB+bGVuIHMgbmV4dClcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIDAgfmxlbiBzIG5leHRcbjs7XG5cbmxldCBkcm9wX3doaWxlX29wdGlvbiAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3Agc1xuICAgIHwgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gcyB9IC0+XG4gICAgICBpZiBmIHggdGhlbiBsb29wIHMgZWxzZSBTb21lICh4LCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KVxuICBpblxuICBsb29wIHMgW0Bub250YWlsXVxuOztcblxubGV0IGNvbXBhcmUgY29tcGFyZV9hIHQxIHQyID1cbiAgV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciAoemlwX2Z1bGwgdDEgdDIpIH5mOihmdW5jdGlvblxuICAgICAgfCBgTGVmdCBfIC0+IHIucmV0dXJuIDFcbiAgICAgIHwgYFJpZ2h0IF8gLT4gci5yZXR1cm4gKC0xKVxuICAgICAgfCBgQm90aCAodjEsIHYyKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfYSB2MSB2MiBpblxuICAgICAgICBpZiBjIDw+IDAgdGhlbiByLnJldHVybiBjKTtcbiAgICAwKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPVxuICBmb3JfYWxsICh6aXBfZnVsbCB0MSB0MikgfmY6KGZ1bmN0aW9uXG4gICAgfCBgQm90aCAoYTEsIGEyKSAtPiBlcXVhbF9hIGExIGEyXG4gICAgfCBgTGVmdCBfIHwgYFJpZ2h0IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgcm91bmRfcm9iaW4gbGlzdCA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSA6OiB0b2RvX3N0YWNrIC0+XG4gICAgICAobWF0Y2ggZiBzIHdpdGhcbiAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgWWllbGRcbiAgICAgICAgICAgeyB2YWx1ZSA9IHhcbiAgICAgICAgICAgOyBzdGF0ZSA9IHRvZG9fc3RhY2ssIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9IDo6IGRvbmVfc3RhY2tcbiAgICAgICAgICAgfVxuICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICBTa2lwIHsgc3RhdGUgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSA6OiB0b2RvX3N0YWNrLCBkb25lX3N0YWNrIH1cbiAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gdG9kb19zdGFjaywgZG9uZV9zdGFjayB9KVxuICAgIHwgW10gLT5cbiAgICAgIGlmIExpc3QuaXNfZW1wdHkgZG9uZV9zdGFjayB0aGVuIERvbmUgZWxzZSBTa2lwIHsgc3RhdGUgPSBMaXN0LnJldiBkb25lX3N0YWNrLCBbXSB9XG4gIGluXG4gIGxldCBzdGF0ZSA9IGxpc3QsIFtdIGluXG4gIFNlcXVlbmNlIHsgc3RhdGU7IG5leHQgfVxuOztcblxubGV0IGludGVybGVhdmUgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IGYxIH0pID1cbiAgbGV0IG5leHQgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2ssIHMxKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBmMiB9IDo6IHRvZG9fc3RhY2sgLT5cbiAgICAgIChtYXRjaCBmMiBzMiB3aXRoXG4gICAgICAgfCBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICAgICBZaWVsZFxuICAgICAgICAgICB7IHZhbHVlID0geFxuICAgICAgICAgICA7IHN0YXRlID0gdG9kb19zdGFjaywgU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gZjIgfSA6OiBkb25lX3N0YWNrLCBzMVxuICAgICAgICAgICB9XG4gICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICAgICBTa2lwIHsgc3RhdGUgPSB0b2RvX3N0YWNrLCBTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBmMiB9IDo6IGRvbmVfc3RhY2ssIHMxIH1cbiAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gdG9kb19zdGFjaywgZG9uZV9zdGFjaywgczEgfSlcbiAgICB8IFtdIC0+XG4gICAgICAobWF0Y2ggZjEgczEsIGRvbmVfc3RhY2sgd2l0aFxuICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHQ7IHN0YXRlID0gczEgfSwgXyAtPlxuICAgICAgICAgU2tpcCB7IHN0YXRlID0gTGlzdC5yZXYgKHQgOjogZG9uZV9zdGFjayksIFtdLCBzMSB9XG4gICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9LCBfIC0+IFNraXAgeyBzdGF0ZSA9IExpc3QucmV2IGRvbmVfc3RhY2ssIFtdLCBzMSB9XG4gICAgICAgfCBEb25lLCBfIDo6IF8gLT4gU2tpcCB7IHN0YXRlID0gTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxIH1cbiAgICAgICB8IERvbmUsIFtdIC0+IERvbmUpXG4gIGluXG4gIGxldCBzdGF0ZSA9IFtdLCBbXSwgczEgaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZTsgbmV4dCB9XG47O1xuXG5sZXQgaW50ZXJsZWF2ZWRfY2FydGVzaWFuX3Byb2R1Y3QgczEgczIgPVxuICBtYXAgczEgfmY6KGZ1biB4MSAtPiBtYXAgczIgfmY6KGZ1biB4MiAtPiB4MSwgeDIpKSB8PiBpbnRlcmxlYXZlXG47O1xuXG5sZXQgb2Zfc2VxIChzZXEgOiBfIFN0ZGxpYi5TZXEudCkgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDpzZXEgfmY6KGZ1biBzZXEgLT5cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IERvbmVcbiAgICB8IENvbnMgKGhkLCB0bCkgLT4gWWllbGQgeyB2YWx1ZSA9IGhkOyBzdGF0ZSA9IHRsIH0pXG47O1xuXG5sZXQgdG9fc2VxIChTZXF1ZW5jZSB7IHN0YXRlOyBuZXh0IH0pID1cbiAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICBtYXRjaCBuZXh0IHN0YXRlIHdpdGhcbiAgICB8IERvbmUgLT4gU3RkbGliLlNlcS5OaWxcbiAgICB8IFNraXAgeyBzdGF0ZSB9IC0+IGxvb3Agc3RhdGVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBoZDsgc3RhdGUgfSAtPiBTdGRsaWIuU2VxLkNvbnMgKGhkLCBmdW4gKCkgLT4gbG9vcCBzdGF0ZSlcbiAgaW5cbiAgZnVuICgpIC0+IGxvb3Agc3RhdGVcbjs7XG5cbm1vZHVsZSBHZW5lcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAnZWx0IHN0ZXBzID0gV3JhcCBvZiAoJ2VsdCwgdW5pdCAtPiAnZWx0IHN0ZXBzKSBTdGVwLnRcblxuICBsZXQgdW53cmFwIChXcmFwIHN0ZXApID0gc3RlcFxuXG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlbHQpIHQgPSAoJ2EgLT4gJ2VsdCBzdGVwcykgLT4gJ2VsdCBzdGVwc1xuXG4gICAgbGV0IHJldHVybiB4IGsgPSBrIHhcblxuICAgIGxldCBiaW5kIG0gfmYgayA9XG4gICAgICBtIChmdW4gYSAtPlxuICAgICAgICBsZXQgbScgPSBmIGEgaW5cbiAgICAgICAgbScgaylcbiAgICA7O1xuXG4gICAgbGV0IG1hcCBtIH5mIGsgPSBtIChmdW4gYSAtPiBrIChmIGEpKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBNb25hZC5NYWtlMiAoVClcblxuICBsZXQgeWllbGQgZSBrID0gV3JhcCAoWWllbGQgeyB2YWx1ZSA9IGU7IHN0YXRlID0gayB9KVxuICBsZXQgdG9fc3RlcHMgdCA9IHQgKGZ1biAoKSAtPiBXcmFwIERvbmUpXG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlID1cbiAgICBkZWxheWVkX2ZvbGRcbiAgICAgIHNlcXVlbmNlXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biAoKSB4IH5rIGYgLT4gV3JhcCAoWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gKGZ1biAoKSAtPiBrICgpIGYpIH0pKVxuICAgICAgfmZpbmlzaDpyZXR1cm5cbiAgOztcblxuICBsZXQgcnVuIHQgPVxuICAgIGxldCBpbml0ICgpID0gdG9fc3RlcHMgdCBpblxuICAgIGxldCBmIHRodW5rID0gdW53cmFwICh0aHVuayAoKSkgaW5cbiAgICB1bmZvbGRfc3RlcCB+aW5pdCB+ZlxuICA7O1xuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTQ4NTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiU2V4cGxpYjBfU2V4cF9ncmFtbWFyIiwiY3N0X1NleHBhYmxlX09mX3N0cmluZ2FibGVfdF9vIiwiT2Zfc2V4cGFibGUiLCJTZXhwYWJsZSIsIk0iLCJ0X29mX3NleHAiLCJzZXhwIiwicyIsImV4biIsInNleHBfb2ZfdCIsInQiLCJPZl9zZXhwYWJsZTEiLCJhX29mX3NleHAiLCJzZXhwX29mX2EiLCJPZl9zZXhwYWJsZTIiLCJiX29mX3NleHAiLCJzZXhwX29mX2IiLCJPZl9zZXhwYWJsZTMiLCJjX29mX3NleHAiLCJzZXhwX29mX2MiLCJPZl9zdHJpbmdhYmxlIiwidF9zZXhwX2dyYW1tYXIiLCJCYXNlX1NleHBhYmxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvc2V4cGFibGUubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLFlBQUFDLFVBQUFDO0FBQUFBLGFBQUFDLFVBQUFDO0FBQUFBLFNBQUFDLElDV1k7QUFBQSxLQUNSLGNBQUk7QUFBQSxXQUFBQztBQUFBQSxVQUFBQSxNRFpSO0FBQUEsTUNhYSw4Q0FBMEI7QUFBQTtBQUFBO0FBQUEsYUFBQUMsVUFBQUM7QUFBQUEsU0FBQSxNQUdBO0FBQUEsS0FBaUI7QUFBQTtBQUFBLElEaEJ4RDtBQUFBO0FBQUEsWUFBQUMsYUFBQVIsVUFBQUM7QUFBQUEsYUFBQUMsVUFBQU8sV0FBQU47QUFBQUEsU0FBQUMsSUMyQlk7QUFBQSxLQUNSLGNBQUk7QUFBQSxXQUFBQztBQUFBQSxVQUFBQSxNRDVCUjtBQUFBLE1DNkJhLDhDQUEwQjtBQUFBO0FBQUE7QUFBQSxhQUFBQyxVQUFBSSxXQUFBSDtBQUFBQSxTQUFBLE1BR29CO0FBQUEsS0FBaUI7QUFBQTtBQUFBLElEaEM1RTtBQUFBO0FBQUEsWUFBQUksYUFBQVgsVUFBQUM7QUFBQUEsYUFBQUMsVUFBQU8sV0FBQUcsV0FBQVQ7QUFBQUEsU0FBQUMsSUMyQ1k7QUFBQSxLQUNSLGNBQUk7QUFBQSxXQUFBQztBQUFBQSxVQUFBQSxNRDVDUjtBQUFBLE1DNkNhLDhDQUEwQjtBQUFBO0FBQUE7QUFBQSxhQUFBQyxVQUFBSSxXQUFBRyxXQUFBTjtBQUFBQSxTQUFBLE1BSUk7QUFBQSxLQUFpQjtBQUFBO0FBQUEsSURqRDVEO0FBQUE7QUFBQSxZQUFBTyxhQUFBZCxVQUFBQztBQUFBQSxhQUFBQyxVQUFBTyxXQUFBRyxXQUFBRyxXQUFBWjtBQUFBQSxTQUFBQyxJQzZEWTtBQUFBLEtBQ1IsY0FBSTtBQUFBLFdBQUFDO0FBQUFBLFVBQUFBLE1EOURSO0FBQUEsTUMrRGEsOENBQTBCO0FBQUE7QUFBQTtBQUFBLGFBQUFDLFVBQUFJLFdBQUFHLFdBQUFHLFdBQUFUO0FBQUFBLFNBQUEsTUFJYztBQUFBLEtBQWlCO0FBQUE7QUFBQSxJRG5FdEU7QUFBQTtBQUFBLFlBQUFVLGNBQUFoQjtBQUFBQSxhQUFBQyxVQUFBQztBQUFBQSxLQ2tGSTtBQUFBLE1BS0U7QUFBQSxzRUFFTTtBQUFBLFNBQUFDLElBUFI7QUFBQSxLQUVFLGNBQUs7QUFBQSxXQUFBQztBQUFBQSxVQUFBQSxNRHBGWDtBQUFBLE1DcUZnQiw4Q0FJSjtBQUFBO0FBQUE7QUFBQSxhQUFBQyxVQUFBQyxHQUdrQiwrQkFBZTtBQUFBO0FBQUEsS0FBQVcsaUJBR3pDO0FBQUEsSUFBZ0Q7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUQvRnBEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGVcblxubW9kdWxlIE9mX3NleHBhYmxlXG4gICAgKFNleHBhYmxlIDogUykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlIHRcblxuICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6IHQgLT4gU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6IFNleHBhYmxlLnQgLT4gdFxuICAgICAgICAgICAgICAgICAgICBlbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwYWJsZS5zZXhwX29mX3QgKE0udG9fc2V4cGFibGUgdClcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUxXG4gICAgKFNleHBhYmxlIDogUzEpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6ICdhIHQgLT4gJ2EgU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiAnYSBTZXhwYWJsZS50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIChNLnRvX3NleHBhYmxlIHQpXG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlMlxuICAgIChTZXhwYWJsZSA6IFMyKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogKCdhLCAnYikgU2V4cGFibGUudCAtPiAoJ2EsICdiKSB0XG4gICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiB0ID1cbiAgICBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiAoTS50b19zZXhwYWJsZSB0KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTNcbiAgICAoU2V4cGFibGUgOiBTMykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6ICgnYSwgJ2IsICdjKSBTZXhwYWJsZS50IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIGNfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIGNfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2Igc2V4cF9vZl9jIHQgPVxuICAgIFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHNleHBfb2ZfYyAoTS50b19zZXhwYWJsZSB0KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBPZl9zdHJpbmdhYmxlIChNIDogU3RyaW5nYWJsZS5TKSA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIFMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG53aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IE0ub2Zfc3RyaW5nIHMgd2l0aFxuICAgICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwKVxuICAgIHwgU2V4cC5MaXN0IF8gLT5cbiAgICAgIG9mX3NleHBfZXJyb3JcbiAgICAgICAgXCJTZXhwYWJsZS5PZl9zdHJpbmdhYmxlLnRfb2Zfc2V4cCBleHBlY3RlZCBhbiBhdG9tLCBidXQgZ290IGEgbGlzdFwiXG4gICAgICAgIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKE0udG9fc3RyaW5nIHQpXG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDogTS50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIHN0cmluZ19zZXhwX2dyYW1tYXJcbiAgOztcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE0OTc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9zcmNfYXJyYXlfbWwiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9TZXF1ZW5jZSIsIkJhc2VfUmFuZG9tIiwiQmFzZV9PcHRpb24iLCJCYXNlX0xpc3QiLCJCYXNlX0NvbnRhaW5lciIsIkJhc2VfT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbiIsIkJhc2VfQXJyYXkwIiwiQmFzZV9BcnJheV9wZXJtdXRlIiwiQmFzZV9CaW5hcnlfc2VhcmNoYWJsZSIsIkJhc2VfQmxpdCIsImludmFsaWRfYXJnZiIsIm1heF9sZW5ndGgiLCJjcmVhdGUiLCJjcmVhdGVfbG9jYWwiLCJjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCIsImFwcGVuZCIsImNvbmNhdCIsImNvcHkiLCJmaWxsIiwiaW5pdCIsIm1ha2VfbWF0cml4Iiwib2ZfbGlzdCIsInN1YiIsInRvX2xpc3QiLCJmb2xkIiwiZm9sZF9yaWdodCIsIml0ZXIiLCJpdGVyaSIsIm1hcCIsIm1hcGkiLCJzdGFibGVfc29ydCIsInN3YXAiLCJjb21wYXJlIiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsIlNvcnRlciIsIlMiLCJnZXQiLCJzZXQiLCJsZW5ndGgiLCJhcnIiLCJpIiwiaiIsInRtcCIsInNvcnQiLCJsZWZ0IiwicmlnaHQiLCJwb3MiLCJ2IiwiZmluYWxfcG9zIiwiaV9uZXh0IiwiSW5zZXJ0aW9uX3NvcnQiLCJoZWFwaWZ5Iiwicm9vdCIsInJlbGF0aXZlX3Jvb3QiLCJsZWZ0X2NoaWxkIiwicmlnaHRfY2hpbGQiLCJsYXJnZXN0IiwiSGVhcF9zb3J0IiwiZml2ZV9lbGVtZW50X3NvcnQiLCJtMSIsIm0yIiwibTMiLCJtNCIsIm01IiwiY29tcGFyZV9hbmRfc3dhcCIsImludHJvX3NvcnQiLCJtYXhfZGVwdGgiLCJsZW4iLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1hdGNoIiwibWlkZGxlX3NvcnRlZCIsInBpdm90MiIsInBpdm90MSIsImwiLCJwIiwiciIsInB2IiwiSW50cm9fc29ydCIsIlNvcnQiLCJjc3RfQXJyYXlfaXRlcjJfZXhuIiwiY3N0X0FycmF5X21hcDJfZXhuIiwiY3N0X0FycmF5X2ZvbGQyX2V4biIsImNzdF9BcnJheV9leGlzdHMyX2V4biIsImNzdF9BcnJheV9mb3JfYWxsMl9leG4iLCJvZl9hcnJheSIsInQiLCJ0b19hcnJheSIsImlzX2VtcHR5IiwiaXNfc29ydGVkIiwicmVzdWx0IiwiZWx0X2kiLCJlbHRfaV9taW51c18xIiwiaXNfc29ydGVkX3N0cmljdGx5IiwibWVyZ2UiLCJsMSIsImwyIiwibWVyZ2VkIiwiYTFfaW5kZXgiLCJhMl9pbmRleCIsInVzZV9hMSIsImNvcHlfbWF0cml4IiwiZm9sZGluZ19tYXAiLCJhY2MiLCJ4IiwieSIsIm5ld19hY2MiLCJmb2xkX21hcCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsImZpbmlzaCIsImNvdW50Iiwic3VtIiwibSIsIm1pbl9lbHQiLCJtYXhfZWx0IiwiZm9sZGkiLCJmb2xkaW5nX21hcGkiLCJmb2xkX21hcGkiLCJjb3VudGkiLCJpZHgiLCJhIiwiY29uY2F0X21hcCIsImNvbmNhdF9tYXBpIiwicmV2X2lucGxhY2UiLCJyZXYiLCJvZl9saXN0X3JldiIsIm9mX2xpc3RfbWFwIiwieHMiLCJ0bCIsImhkIiwicGFyYW0iLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwiZmlsdGVyX21hcGkiLCJrIiwiZmlsdGVyX21hcCIsImZpbHRlcl9vcHQiLCJjaGVja19sZW5ndGgyX2V4biIsIm5hbWUiLCJ0MSIsInQyIiwibjEiLCJuMiIsIml0ZXIyX2V4biIsIngxIiwibWFwMl9leG4iLCJmb2xkMl9leG4iLCJhYyIsImZpbHRlciIsImZpbHRlcmkiLCJleGlzdHMiLCJleGlzdHNpIiwibWVtIiwiZXF1YWwiLCJmb3JfYWxsIiwiZm9yX2FsbGkiLCJleGlzdHMyX2V4biIsImZvcl9hbGwyX2V4biIsIm1hcF9pbnBsYWNlIiwiZmluZGlfaW50ZXJuYWwiLCJpZl9mb3VuZCIsImlmX25vdF9mb3VuZCIsImZvdW5kIiwidmFsdWVfZm91bmQiLCJ2YWx1ZSIsImZpbmRpIiwiZmluZGlfZXhuIiwiZmluZF9leG4iLCJmaW5kIiwiZmluZF9tYXAiLCJub3RfZm91bmQiLCJmaW5kX21hcF9leG4iLCJmaW5kX21hcGkiLCJjc3RfQXJyYXlfcmVkdWNlX2V4biIsImZpbmRfbWFwaV9leG4iLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSIsIm4iLCJwcmV2IiwiY3VyIiwicmVkdWNlIiwicmVkdWNlX2V4biIsInBlcm11dGUiLCJjc3RfQXJyYXlfcmFuZG9tX2VsZW1lbnRfZXhuX2UiLCJjc3RfQXJyYXlfemlwX2V4biIsImNzdF9BcnJheV90cmFuc3Bvc2VfZXhuIiwicmFuZG9tX2VsZW1lbnRfZXhuIiwib3B0IiwicmFuZG9tX3N0YXRlIiwicmFuZG9tX2VsZW1lbnQiLCJ6aXAiLCJ4MiIsInppcF9leG4iLCJ1bnppcCIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25fbWFwaSIsImJvdGgiLCJmaXJzdHMiLCJzZWNvbmRzIiwicGFydGl0aW9uaV90ZiIsInBhcnRpdGlvbl9tYXAiLCJwYXJ0aXRpb25fdGYiLCJsYXN0IiwidG9fc2VxdWVuY2VfbXV0YWJsZSIsInRvX3NlcXVlbmNlIiwiY2FydGVzaWFuX3Byb2R1Y3QiLCJpMSIsImkyIiwidHJhbnNwb3NlIiwidHQiLCJ3aWR0aCIsImRlcHRoIiwiZCIsInciLCJ0cmFuc3Bvc2VfZXhuIiwiaW5jbHVkZSIsImJpbmFyeV9zZWFyY2giLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQiLCJibGl0IiwiYmxpdG8iLCJzdWJvIiwiaW52YXJpYW50IiwiaW52YXJpYW50X2EiLCJCYXNlX0FycmF5Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvYXJyYXkubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCRDVzQkY7QUFBQSxHQzRzQkU7QUFBQTtBQUFBLEVENXNCRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG50eXBlICdhIHQgPSAnYSBhcnJheSBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX2FycmF5XG5cbmxldCBnbG9iYWxpemUgOiAnYS4gKCgnYVtAb2NhbWwubG9jYWxdKSAtPiAnYSkgLT4gKCdhIHRbQG9jYW1sLmxvY2FsXSkgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMDVfKVxuICAgICAgOiAoKChhX18wMDVfW0BvY2FtbC5sb2NhbF0pIC0+IGFfXzAwNV8pIC0+IChhX18wMDVfIHRbQG9jYW1sLmxvY2FsXSkgLT4gYV9fMDA1XyB0KSAtPlxuICAgIGdsb2JhbGl6ZV9hcnJheVxuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGFycmF5X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2FycmF5XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gYXJyYXlfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbigqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYSBuZXcgaW4tcGxhY2UsIGNvbnN0YW50IGhlYXAgc29ydGluZyBhbGdvcml0aG0gdG8gcmVwbGFjZSB0aGVcbiAgIG9uZSB1c2VkIGJ5IHRoZSBzdGFuZGFyZCBsaWJyYXJpZXMuICBJdHMgb25seSBwdXJwb3NlIGlzIHRvIGJlIGZhc3RlciAoaG9wZWZ1bGx5XG4gICBzdHJpY3RseSBmYXN0ZXIpIHRoYW4gdGhlIGJhc2Ugc29ydCBhbmQgc3RhYmxlX3NvcnQuXG5cbiAgIEF0IGEgaGlnaCBsZXZlbCB0aGUgYWxnb3JpdGhtIGlzOlxuICAgLSBwaWNrIHR3byBwaXZvdCBwb2ludHMgYnk6XG4gICAtIHBpY2sgNSBhcmJpdHJhcnkgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXlcbiAgIC0gc29ydCB0aGVtIHdpdGhpbiB0aGUgYXJyYXlcbiAgIC0gdGFrZSB0aGUgZWxlbWVudHMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIG1pZGRsZSBlbGVtZW50IG9mIHRoZSBzb3J0IGFzIHRoZSBwaXZvdHNcbiAgIC0gc29ydCB0aGUgYXJyYXkgd2l0aDpcbiAgIC0gYWxsIGVsZW1lbnRzIGxlc3MgdGhhbiBwaXZvdDEgdG8gdGhlIGxlZnQgKHJhbmdlIDEpXG4gICAtIGFsbCBlbGVtZW50cyA+PSBwaXZvdDEgYW5kIDw9IHBpdm90MiBpbiB0aGUgbWlkZGxlIChyYW5nZSAyKVxuICAgLSBhbGwgZWxlbWVudHMgPiBwaXZvdDIgdG8gdGhlIHJpZ2h0IChyYW5nZSAzKVxuICAgLSBpZiBwaXZvdDEgYW5kIHBpdm90MiBhcmUgZXF1YWwsIHRoZW4gdGhlIG1pZGRsZSByYW5nZSBpcyBzb3J0ZWQsIHNvIGlnbm9yZSBpdFxuICAgLSByZWN1cnNlIGludG8gcmFuZ2UgMSwgMiAoaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIHVuZXF1YWwpLCBhbmQgM1xuICAgLSBkdXJpbmcgcmVjdXJzaW9uIHRoZXJlIGFyZSB0d28gaW5mbGVjdGlvbiBwb2ludHM6XG4gICAtIGlmIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IHJhbmdlIGlzIHNtYWxsLCB1c2UgaW5zZXJ0aW9uIHNvcnQgdG8gc29ydCBpdFxuICAgLSBpZiB0aGUgc3RhY2sgZGVwdGggaXMgbGFyZ2UsIHNvcnQgdGhlIHJhbmdlIHdpdGggaGVhcC1zb3J0IHRvIGF2b2lkIG5eMiB3b3JzdC1jYXNlXG4gICAgIGJlaGF2aW9yXG5cbiAgIFNlZSB0aGUgZm9sbG93aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uOlxuICAgLSBcIkR1YWwtUGl2b3QgUXVpY2tzb3J0XCIgYnkgVmxhZGltaXIgWWFyb3NsYXZza2l5LlxuICAgICBBdmFpbGFibGUgYXRcbiAgICAgaHR0cDovL3d3dy5rcmljaGUuY29tLmFyL3Jvb3QvcHJvZ3JhbW1pbmcvc3BhY2VUaW1lQ29tcGxleGl0eS9EdWFsUGl2b3RRdWlja3NvcnQucGRmXG4gICAtIFwiUXVpY2tzb3J0IGlzIE9wdGltYWxcIiBieSBTZWRnZXdpY2sgYW5kIEJlbnRsZXkuXG4gICAgIFNsaWRlcyBhdCBodHRwOi8vd3d3LmNzLnByaW5jZXRvbi5lZHUvfnJzL3RhbGtzL1F1aWNrc29ydElzT3B0aW1hbC5wZGZcbiAgIC0gaHR0cDovL3d3dy5zb3J0aW5nLWFsZ29yaXRobXMuY29tL3F1aWNrLXNvcnQtMy13YXkgKilcblxubW9kdWxlIFNvcnRlciAoUyA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gICAgdmFsIHNldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBTXG5cbiAgbGV0IHN3YXAgYXJyIGkgaiA9XG4gICAgbGV0IHRtcCA9IGdldCBhcnIgaSBpblxuICAgIHNldCBhcnIgaSAoZ2V0IGFyciBqKTtcbiAgICBzZXQgYXJyIGogdG1wXG4gIDs7XG5cbiAgbW9kdWxlIHR5cGUgU29ydCA9IHNpZ1xuICAgIHZhbCBzb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOigoJ2EgLT4gJ2EgLT4gaW50KVtAbG9jYWxdKVxuICAgICAgLT4gbGVmdDppbnQgKCogbGVmdG1vc3QgaW5kZXggb2Ygc3ViLWFycmF5IHRvIHNvcnQgKilcbiAgICAgIC0+IHJpZ2h0OmludCAoKiByaWdodG1vc3QgaW5kZXggb2Ygc3ViLWFycmF5IHRvIHNvcnQgKilcbiAgICAgIC0+IHVuaXRcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnNlcnRpb25fc29ydCAqKVxuICBtb2R1bGUgSW5zZXJ0aW9uX3NvcnQgOiBTb3J0ID0gc3RydWN0XG4gICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgIDEuICB0aGUgc3ViYXJyYXkgYXJyW2xlZnQgLi4gaS0xXSBpcyBzb3J0ZWRcbiAgICAgICAyLiAgdGhlIHN1YmFycmF5IGFycltpKzEgLi4gcG9zXSBpcyBzb3J0ZWQgYW5kIGNvbnRhaW5zIG9ubHkgZWxlbWVudHMgPiB2XG4gICAgICAgMy4gIGFycltpXSBtYXkgYmUgdGhvdWdodCBvZiBhcyBjb250YWluaW5nIHZcbiAgICAqKVxuICAgIGxldCByZWMgaW5zZXJ0X2xvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGkgdiA9XG4gICAgICBsZXQgaV9uZXh0ID0gaSAtIDEgaW5cbiAgICAgIGlmIGlfbmV4dCA+PSBsZWZ0ICYmIGNvbXBhcmUgKGdldCBhcnIgaV9uZXh0KSB2ID4gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHNldCBhcnIgaSAoZ2V0IGFyciBpX25leHQpO1xuICAgICAgICBpbnNlcnRfbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgaV9uZXh0IHYpXG4gICAgICBlbHNlIGlcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICAoKiBsb29wIGludmFyaWFudDpcbiAgICAgICAgIFthcnJdIGlzIHNvcnRlZCBmcm9tIFtsZWZ0XSB0byBbcG9zIC0gMV0sIGluY2x1c2l2ZSAqKVxuICAgICAgZm9yIHBvcyA9IGxlZnQgKyAxIHRvIHJpZ2h0IGRvXG4gICAgICAgIGxldCB2ID0gZ2V0IGFyciBwb3MgaW5cbiAgICAgICAgbGV0IGZpbmFsX3BvcyA9IGluc2VydF9sb29wIGFyciB+bGVmdCB+Y29tcGFyZSBwb3MgdiBpblxuICAgICAgICBzZXQgYXJyIGZpbmFsX3BvcyB2XG4gICAgICBkb25lXG4gICAgOztcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwc29ydCAqKVxuICBtb2R1bGUgSGVhcF9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgIHJvb3QncyBjaGlsZHJlbiBhcmUgYm90aCBlaXRoZXIgcm9vdHMgb2YgbWF4LWhlYXBzIG9yID4gcmlnaHQgKilcbiAgICBsZXQgcmVjIGhlYXBpZnkgYXJyIH5jb21wYXJlIHJvb3QgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCByZWxhdGl2ZV9yb290ID0gcm9vdCAtIGxlZnQgaW5cbiAgICAgIGxldCBsZWZ0X2NoaWxkID0gKDIgKiByZWxhdGl2ZV9yb290KSArIGxlZnQgKyAxIGluXG4gICAgICBsZXQgcmlnaHRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDIgaW5cbiAgICAgIGxldCBsYXJnZXN0ID1cbiAgICAgICAgaWYgbGVmdF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIGxlZnRfY2hpbGQpIChnZXQgYXJyIHJvb3QpID4gMFxuICAgICAgICB0aGVuIGxlZnRfY2hpbGRcbiAgICAgICAgZWxzZSByb290XG4gICAgICBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiByaWdodF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIHJpZ2h0X2NoaWxkKSAoZ2V0IGFyciBsYXJnZXN0KSA+IDBcbiAgICAgICAgdGhlbiByaWdodF9jaGlsZFxuICAgICAgICBlbHNlIGxhcmdlc3RcbiAgICAgIGluXG4gICAgICBpZiBsYXJnZXN0IDw+IHJvb3RcbiAgICAgIHRoZW4gKFxuICAgICAgICBzd2FwIGFyciByb290IGxhcmdlc3Q7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxhcmdlc3QgfmxlZnQgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgYnVpbGRfaGVhcCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIEVsZW1lbnRzIGluIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgYXJyYXkgYXJlIGFscmVhZHkgaGVhcHMgb2Ygc2l6ZSAxLiAgV2UgbW92ZVxuICAgICAgICAgdGhyb3VnaCB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgYXJyYXkgZnJvbSBiYWNrIHRvIGZyb250IGV4YW1pbmluZyB0aGUgZWxlbWVudCBhdFxuICAgICAgICAgaGFuZCwgYW5kIHRoZSBsZWZ0IGFuZCByaWdodCBjaGlsZHJlbiwgZml4aW5nIHRoZSBoZWFwIHByb3BlcnR5IGFzIHdlIGdvLiAqKVxuICAgICAgZm9yIGkgPSAobGVmdCArIHJpZ2h0KSAvIDIgZG93bnRvIGxlZnQgZG9cbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgaSB+bGVmdCB+cmlnaHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ7XG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uLiBpXSBpcyBhIG1heC1oZWFwIEhcbiAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLi4gcmlnaHRdIGlzIHNvcnRlZCAoY2FsbCBpdCBTKVxuICAgICAgICAgMy4gIGV2ZXJ5IGVsZW1lbnQgb2YgSCBpcyBsZXNzIHRoYW4gZXZlcnkgZWxlbWVudCBvZiBTICopXG4gICAgICBmb3IgaSA9IHJpZ2h0IGRvd250byBsZWZ0ICsgMSBkb1xuICAgICAgICBzd2FwIGFyciBsZWZ0IGk7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxlZnQgfmxlZnQgfnJpZ2h0OihpIC0gMSlcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludHJvc29ydCAqKVxuICBtb2R1bGUgSW50cm9fc29ydCA6IHNpZ1xuICAgIGluY2x1ZGUgU29ydFxuXG4gICAgdmFsIGZpdmVfZWxlbWVudF9zb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOigoJ2EgLT4gJ2EgLT4gaW50KVtAbG9jYWxdKVxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHVuaXRcbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGZpdmVfZWxlbWVudF9zb3J0IGFyciB+Y29tcGFyZTooKGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pIG0xIG0yIG0zIG00IG01ID1cbiAgICAgIGxldCBjb21wYXJlX2FuZF9zd2FwIGkgaiA9XG4gICAgICAgIGlmIGNvbXBhcmUgKGdldCBhcnIgaSkgKGdldCBhcnIgaikgPiAwIHRoZW4gc3dhcCBhcnIgaSBqXG4gICAgICBpblxuICAgICAgKCogT3B0aW1hbCA1LWVsZW1lbnQgc29ydGluZyBuZXR3b3JrOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgMS0tby0tLS0tby0tLS0tby0tLS0tLS0tLS0tLS0tMVxuICAgICAgICAgICAgICAgfCAgICAgfCAgICAgfFxuICAgICAgICAgICAgMi0tby0tLS0tfC0tby0tfC0tLS0tby0tby0tLS0tMlxuICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfCAgICAgfCAgfFxuICAgICAgICAgICAgMy0tLS0tLS0tby0tby0tfC0tby0tfC0tby0tLS0tM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfFxuICAgICAgICAgICAgNC0tLS0tby0tLS0tLS0tby0tby0tfC0tLS0tby0tNFxuICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgfFxuICAgICAgICAgICAgNS0tLS0tby0tLS0tLS0tLS0tLS0tby0tLS0tby0tNVxuICAgICAgICAgIHZ9ICopXG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG0yO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNTtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTMgbTQ7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTQgbTUgW0Bub250YWlsXVxuICAgIDs7XG5cbiAgICAoKiBjaG9vc2UgcGl2b3RzIGZvciB0aGUgYXJyYXkgYnkgc29ydGluZyA1IGVsZW1lbnRzIGFuZCBleGFtaW5pbmcgdGhlIGNlbnRlciB0aHJlZVxuICAgICAgIGVsZW1lbnRzLiAgVGhlIGdvYWwgaXMgdG8gY2hvb3NlIHR3byBwaXZvdHMgdGhhdCB3aWxsIGVpdGhlcjpcbiAgICAgICAtIGJyZWFrIHRoZSByYW5nZSB1cCBpbnRvIDMgZXZlbiBwYXJ0aXRpb25zXG4gICAgICAgICBvclxuICAgICAgIC0gZWxpbWluYXRlIGEgY29tbW9ubHkgYXBwZWFyaW5nIGVsZW1lbnQgYnkgc29ydGluZyBpdCBpbnRvIHRoZSBjZW50ZXIgcGFydGl0aW9uXG4gICAgICAgICBieSBpdHNlbGZcbiAgICAgICAgIFRvIHRoaXMgZW5kIHdlIGxvb2sgYXQgdGhlIGNlbnRlciAzIGVsZW1lbnRzIG9mIHRoZSA1IGFuZCByZXR1cm4gcGFpcnMgb2YgZXF1YWxcbiAgICAgICAgIGVsZW1lbnRzIG9yIHRoZSB3aWRlc3QgcmFuZ2UgKilcbiAgICBsZXQgY2hvb3NlX3Bpdm90cyBhcnIgfmNvbXBhcmU6KChjb21wYXJlIDogXyAtPiBfIC0+IF8pIFtAbG9jYWxdKSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHNpeHRoID0gKHJpZ2h0IC0gbGVmdCkgLyA2IGluXG4gICAgICBsZXQgbTEgPSBsZWZ0ICsgc2l4dGggaW5cbiAgICAgIGxldCBtMiA9IG0xICsgc2l4dGggaW5cbiAgICAgIGxldCBtMyA9IG0yICsgc2l4dGggaW5cbiAgICAgIGxldCBtNCA9IG0zICsgc2l4dGggaW5cbiAgICAgIGxldCBtNSA9IG00ICsgc2l4dGggaW5cbiAgICAgIGZpdmVfZWxlbWVudF9zb3J0IGFyciB+Y29tcGFyZSBtMSBtMiBtMyBtNCBtNTtcbiAgICAgIGxldCBtMl92YWwgPSBnZXQgYXJyIG0yIGluXG4gICAgICBsZXQgbTNfdmFsID0gZ2V0IGFyciBtMyBpblxuICAgICAgbGV0IG00X3ZhbCA9IGdldCBhcnIgbTQgaW5cbiAgICAgIGlmIGNvbXBhcmUgbTJfdmFsIG0zX3ZhbCA9IDBcbiAgICAgIHRoZW4gbTJfdmFsLCBtM192YWwsIHRydWVcbiAgICAgIGVsc2UgaWYgY29tcGFyZSBtM192YWwgbTRfdmFsID0gMFxuICAgICAgdGhlbiBtM192YWwsIG00X3ZhbCwgdHJ1ZVxuICAgICAgZWxzZSBtMl92YWwsIG00X3ZhbCwgZmFsc2VcbiAgICA7O1xuXG4gICAgbGV0IGR1YWxfcGl2b3RfcGFydGl0aW9uIGFyciB+Y29tcGFyZTooKGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgcGl2b3QxLCBwaXZvdDIsIHBpdm90c19lcXVhbCA9IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCBpblxuICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgMS4gIGxlZnQgPD0gbCA8IHIgPD0gcmlnaHRcbiAgICAgICAgIDIuICBsIDw9IHAgPD0gclxuICAgICAgICAgMy4gIGwgPD0geCA8IHAgICAgIGltcGxpZXMgYXJyW3hdID49IHBpdm90MVxuICAgICAgICAgYW5kIGFyclt4XSA8PSBwaXZvdDJcbiAgICAgICAgIDQuICBsZWZ0IDw9IHggPCBsICBpbXBsaWVzIGFyclt4XSA8IHBpdm90MVxuICAgICAgICAgNS4gIHIgPCB4IDw9IHJpZ2h0IGltcGxpZXMgYXJyW3hdID4gcGl2b3QyICopXG4gICAgICBsZXQgcmVjIGxvb3AgbCBwIHIgPVxuICAgICAgICBsZXQgcHYgPSBnZXQgYXJyIHAgaW5cbiAgICAgICAgaWYgY29tcGFyZSBwdiBwaXZvdDEgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHN3YXAgYXJyIHAgbDtcbiAgICAgICAgICBjb250IChsICsgMSkgKHAgKyAxKSByKVxuICAgICAgICBlbHNlIGlmIGNvbXBhcmUgcHYgcGl2b3QyID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBsb29wIGludmFyaWFudHM6ICBzYW1lIGFzIHRob3NlIG9mIHRoZSBvdXRlciBsb29wICopXG4gICAgICAgICAgbGV0IHJlYyBzY2FuX2JhY2t3YXJkcyByID1cbiAgICAgICAgICAgIGlmIHIgPiBwICYmIGNvbXBhcmUgKGdldCBhcnIgcikgcGl2b3QyID4gMCB0aGVuIHNjYW5fYmFja3dhcmRzIChyIC0gMSkgZWxzZSByXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgciA9IHNjYW5fYmFja3dhcmRzIHIgaW5cbiAgICAgICAgICBzd2FwIGFyciByIHA7XG4gICAgICAgICAgY29udCBsIHAgKHIgLSAxKSlcbiAgICAgICAgZWxzZSBjb250IGwgKHAgKyAxKSByXG4gICAgICBhbmQgY29udCBsIHAgciA9IGlmIHAgPiByIHRoZW4gbCwgciBlbHNlIGxvb3AgbCBwIHIgaW5cbiAgICAgIGxldCBsLCByID0gY29udCBsZWZ0IGxlZnQgcmlnaHQgaW5cbiAgICAgIGwsIHIsIHBpdm90c19lcXVhbFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBsZW4gPSByaWdodCAtIGxlZnQgKyAxIGluXG4gICAgICAoKiBUaGlzIHRha2VzIGNhcmUgb2Ygc29tZSBlZGdlIGNhc2VzLCBzdWNoIGFzIGxlZnQgPiByaWdodCBvciB2ZXJ5IHNob3J0IGFycmF5cyxcbiAgICAgICAgIHNpbmNlIEluc2VydGlvbl9zb3J0LnNvcnQgaGFuZGxlcyB0aGVzZSBjYXNlcyBwcm9wZXJseS4gIFRodXMgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgbWFrZSBzdXJlIHRoYXQgbGVmdCBhbmQgcmlnaHQgYXJlIHZhbGlkIGluIHJlY3Vyc2l2ZSBjYWxscy4gKilcbiAgICAgIGlmIGxlbiA8PSAzMlxuICAgICAgdGhlbiBJbnNlcnRpb25fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgaWYgbWF4X2RlcHRoIDwgMFxuICAgICAgdGhlbiBIZWFwX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG1heF9kZXB0aCA9IG1heF9kZXB0aCAtIDEgaW5cbiAgICAgICAgbGV0IGwsIHIsIG1pZGRsZV9zb3J0ZWQgPSBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0OihsIC0gMSk7XG4gICAgICAgIGlmIG5vdCBtaWRkbGVfc29ydGVkIHRoZW4gaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdDpsIH5yaWdodDpyO1xuICAgICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OihyICsgMSkgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBoZWFwX3NvcnRfc3dpdGNoX2RlcHRoID1cbiAgICAgICAgKCogV2UgYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0IGEgcmVjdXJzaW9uIGRlcHRoIG9mIDMyLiBHTlUgaW50cm9zb3J0IHVzZXMgMmxnKG4pLlxuICAgICAgICAgICBUaGUgZXhwZWN0ZWQgcmVjdXJzaW9uIGRlcHRoIGZvciBwZXJmZWN0IDMtd2F5IHNwbGl0cyBpcyBsb2dfMyhuKS5cblxuICAgICAgICAgICBVc2luZyAzMiBtZWFucyBhIGJhbGFuY2VkIDMtd2F5IHNwbGl0IHdvdWxkIHdvcmsgdXAgdG8gM14zMiBlbGVtZW50cyAocm91Z2hseVxuICAgICAgICAgICAyXjUwIG9yIDEwXjE1KS4gR05VIHJlYWNoZXMgYSBkZXB0aCBvZiAzMiBhdCA2NTUzNiBlbGVtZW50cy5cblxuICAgICAgICAgICBGb3Igc21hbGwgYXJyYXlzLCB0aGlzIG1ha2VzIHVzIGxlc3MgbGlrZWx5IHRvIGJhaWwgb3V0IHRvIGhlYXAgc29ydCwgYnV0IHRoZVxuICAgICAgICAgICAzMipOIGNvc3QgYmVmb3JlIHdlIGRvIGlzIG5vdCB0aGF0IG11Y2guXG5cbiAgICAgICAgICAgRm9yIGxhcmdlIGFycmF5cywgdGhpcyBtZWFucyB3ZSBhcmUgbW9yZSBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0XG4gICAgICAgICAgIHNvbWUgcG9pbnQgaWYgd2UgZ2V0IHNvbWUgYmFkIHNwbGl0cyBvciBpZiB0aGUgYXJyYXkgaXMgaHVnZS4gQnV0IHRoYXQncyBvbmx5IGFcbiAgICAgICAgICAgY29uc3RhbnQgZmFjdG9yIGNvc3QgaW4gdGhlIGZpbmFsIHN0YWdlcyBvZiByZWN1cnNpb24uXG5cbiAgICAgICAgICAgQWxsIGluIGFsbCwgdGhpcyBzZWVtcyB0byBiZSBhIHNtYWxsIHRyYWRlb2ZmIGFuZCBhdm9pZHMgcGF5aW5nIGEgY29zdCB0b1xuICAgICAgICAgICBjb21wdXRlIGEgbG9nYXJpdGhtIGF0IHRoZSBzdGFydC4gKilcbiAgICAgICAgMzJcbiAgICAgIGluXG4gICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoOmhlYXBfc29ydF9zd2l0Y2hfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHNvcnQgP3BvcyA/bGVuIGFyciB+Y29tcGFyZTooKGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgW0Bsb2NhbF0pID1cbiAgICBsZXQgcG9zLCBsZW4gPVxuICAgICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBhcnIpXG4gICAgaW5cbiAgICBJbnRyb19zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0OnBvcyB+cmlnaHQ6KHBvcyArIGxlbiAtIDEpXG4gIDs7XG5lbmRcbltAQGlubGluZV1cblxubW9kdWxlIFNvcnQgPSBTb3J0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldFxuICAgIGxldCBzZXQgPSB1bnNhZmVfc2V0XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBlbmQpXG5cbmxldCBzb3J0ID0gU29ydC5zb3J0XG5sZXQgb2ZfYXJyYXkgdCA9IHRcbmxldCB0b19hcnJheSB0ID0gdFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGlzX3NvcnRlZCB0IH5jb21wYXJlID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID4gMCAmJiAhcmVzdWx0IGRvXG4gICAgbGV0IGVsdF9pID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgbGV0IGVsdF9pX21pbnVzXzEgPSB1bnNhZmVfZ2V0IHQgKCFpIC0gMSkgaW5cbiAgICBpZiBjb21wYXJlIGVsdF9pX21pbnVzXzEgZWx0X2kgPiAwIHRoZW4gcmVzdWx0IDo9IGZhbHNlO1xuICAgIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgaXNfc29ydGVkX3N0cmljdGx5IHQgfmNvbXBhcmUgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPiAwICYmICFyZXN1bHQgZG9cbiAgICBsZXQgZWx0X2kgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICBsZXQgZWx0X2lfbWludXNfMSA9IHVuc2FmZV9nZXQgdCAoIWkgLSAxKSBpblxuICAgIGlmIGNvbXBhcmUgZWx0X2lfbWludXNfMSBlbHRfaSA+PSAwIHRoZW4gcmVzdWx0IDo9IGZhbHNlO1xuICAgIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVyZ2UgYTEgYTIgfmNvbXBhcmUgPVxuICBsZXQgbDEgPSBBcnJheS5sZW5ndGggYTEgaW5cbiAgbGV0IGwyID0gQXJyYXkubGVuZ3RoIGEyIGluXG4gIGlmIGwxID0gMFxuICB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsMiA9IDBcbiAgdGhlbiBjb3B5IGExXG4gIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhMiAwKSAodW5zYWZlX2dldCBhMSAobDEgLSAxKSkgPj0gMFxuICB0aGVuIGFwcGVuZCBhMSBhMlxuICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTEgMCkgKHVuc2FmZV9nZXQgYTIgKGwyIC0gMSkpID4gMFxuICB0aGVuIGFwcGVuZCBhMiBhMVxuICBlbHNlIChcbiAgICBsZXQgbGVuID0gbDEgKyBsMiBpblxuICAgIGxldCBtZXJnZWQgPSBjcmVhdGUgfmxlbiAodW5zYWZlX2dldCBhMSAwKSBpblxuICAgIGxldCBhMV9pbmRleCA9IHJlZiAwIGluXG4gICAgbGV0IGEyX2luZGV4ID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IHVzZV9hMSA9XG4gICAgICAgIGlmIGwxID0gIWExX2luZGV4XG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBpZiBsMiA9ICFhMl9pbmRleFxuICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgZWxzZSBjb21wYXJlICh1bnNhZmVfZ2V0IGExICFhMV9pbmRleCkgKHVuc2FmZV9nZXQgYTIgIWEyX2luZGV4KSA8PSAwXG4gICAgICBpblxuICAgICAgaWYgdXNlX2ExXG4gICAgICB0aGVuIChcbiAgICAgICAgdW5zYWZlX3NldCBtZXJnZWQgaSAodW5zYWZlX2dldCBhMSAhYTFfaW5kZXgpO1xuICAgICAgICBhMV9pbmRleCA6PSAhYTFfaW5kZXggKyAxKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHVuc2FmZV9zZXQgbWVyZ2VkIGkgKHVuc2FmZV9nZXQgYTIgIWEyX2luZGV4KTtcbiAgICAgICAgYTJfaW5kZXggOj0gIWEyX2luZGV4ICsgMSlcbiAgICBkb25lO1xuICAgIG1lcmdlZClcbjs7XG5cbmxldCBjb3B5X21hdHJpeCA9IG1hcCB+Zjpjb3B5XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcCB0IH5mOihmdW4geCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcbmxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgYWNjIDo9IGYgaSAhYWNjICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGlkeCBjb3VudCBhIC0+IGlmIGYgaWR4IGEgdGhlbiBjb3VudCArIDEgZWxzZSBjb3VudCkgW0Bub250YWlsXVxuOztcblxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9IGNvbmNhdCAodG9fbGlzdCAobWFwIH5mIHQpKVxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcGkgfmYgdCkpXG5cbmxldCByZXZfaW5wbGFjZSB0ID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICB3aGlsZSAhaSA8ICFqIGRvXG4gICAgc3dhcCB0ICFpICFqO1xuICAgIGluY3IgaTtcbiAgICBkZWNyIGpcbiAgZG9uZVxuOztcblxubGV0IHJldiB0ID1cbiAgbGV0IHQgPSBjb3B5IHQgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IG9mX2xpc3RfcmV2IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgYSA6OiBsIC0+XG4gICAgbGV0IGxlbiA9IDEgKyBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfmxlbiBhIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgICgqIFdlIHN0YXJ0IGF0IFtsZW4gLSAyXSBiZWNhdXNlIHdlIGFscmVhZHkgcHV0IFthXSBhdCBbdC4obGVuIC0gMSldLiAqKVxuICAgIGZvciBpID0gbGVuIC0gMiBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIHQuKGkpIDwtIGE7XG4gICAgICAgIHIgOj0gbFxuICAgIGRvbmU7XG4gICAgdFxuOztcblxuKCogW29mX2xpc3RfbWFwXSBhbmQgW29mX2xpc3RfcmV2X21hcF0gYXJlIGJhc2VkIG9uIGZ1bmN0aW9ucyBmcm9tIHRoZSBPQ2FtbFxuICAgZGlzdHJpYnV0aW9uLiAqKVxuXG5sZXQgb2ZfbGlzdF9tYXAgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiBoZCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaGQpO1xuICAgICAgICBmaWxsIChpICsgMSkgdGxcbiAgICBpblxuICAgIGZpbGwgMSB0bCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgb2ZfbGlzdF9tYXBpIHhzIH5mID1cbiAgbWF0Y2ggeHMgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBoZCA6OiB0bCAtPlxuICAgIGxldCBhID0gY3JlYXRlIH5sZW46KDEgKyBMaXN0Lmxlbmd0aCB0bCkgKGYgMCBoZCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgYSBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICB1bnNhZmVfc2V0IGEgaSAoZiBpIGhkKTtcbiAgICAgICAgZmlsbCBhIChpICsgMSkgdGxcbiAgICBpblxuICAgIGZpbGwgYSAxIHRsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXAgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwIHhzIH5mIGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXBpIHhzIH5mID1cbiAgbGV0IHQgPSBvZl9saXN0X21hcGkgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgciA9IHJlZiBbfHxdIGluXG4gIGxldCBrID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCB0IGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYSAtPlxuICAgICAgaWYgIWsgPSAwIHRoZW4gciA6PSBjcmVhdGUgfmxlbjoobGVuZ3RoIHQpIGE7XG4gICAgICB1bnNhZmVfc2V0ICFyICFrIGE7XG4gICAgICBpbmNyIGtcbiAgZG9uZTtcbiAgaWYgIWsgPSBsZW5ndGggdCB0aGVuICFyIGVsc2UgaWYgIWsgPiAwIHRoZW4gc3ViIH5wb3M6MCB+bGVuOiFrICFyIGVsc2UgW3x8XVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfaSBhIC0+IGYgYSkgW0Bub250YWlsXVxubGV0IGZpbHRlcl9vcHQgdCA9IGZpbHRlcl9tYXAgdCB+ZjpGbi5pZFxuXG5sZXQgcmFpc2VfbGVuZ3RoX21pc21hdGNoIG5hbWUgbjEgbjIgPVxuICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19sZW5ndGgyX2V4biBuYW1lIHQxIHQyID1cbiAgbGV0IG4xID0gbGVuZ3RoIHQxIGluXG4gIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yXG47O1xuXG5sZXQgaXRlcjJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5pdGVyMl9leG5cIiB0MSB0MjtcbiAgaXRlcmkgdDEgfmY6KGZ1biBpIHgxIC0+IGYgeDEgKHVuc2FmZV9nZXQgdDIgaSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXAyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkubWFwMl9leG5cIiB0MSB0MjtcbiAgaW5pdCAobGVuZ3RoIHQxKSB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGQyX2V4biB0MSB0MiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZm9sZDJfZXhuXCIgdDEgdDI7XG4gIGZvbGRpIHQxIH5pbml0IH5mOihmdW4gaSBhYyB4IC0+IGYgYWMgeCAodW5zYWZlX2dldCB0MiBpKSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKSBbQG5vbnRhaWxdXG5sZXQgZmlsdGVyaSB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIFtAbm9udGFpbF1cblxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPSBleGlzdHMgdCB+ZjooZXF1YWwgYSkgW0Bub250YWlsXVxuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBleGlzdHMyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZXhpc3RzMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmZvcl9hbGwyX2V4blwiIHQxIHQyO1xuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQxIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0MSAhaSkgKHVuc2FmZV9nZXQgdDIgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXF1YWwgZXF1YWwgdDEgdDIgPSBsZW5ndGggdDEgPSBsZW5ndGggdDIgJiYgZm9yX2FsbDJfZXhuIHQxIHQyIH5mOmVxdWFsXG5cblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgdW5zYWZlX3NldCB0IGkgKGYgKHVuc2FmZV9nZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBmaW5kaV9pbnRlcm5hbCB0IH5mIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBpZl9ub3RfZm91bmQgKClcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBmb3VuZCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgKG5vdCAhZm91bmQpICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGYgIWkgdmFsdWVcbiAgICAgIHRoZW4gKFxuICAgICAgICB2YWx1ZV9mb3VuZCA6PSB2YWx1ZTtcbiAgICAgICAgZm91bmQgOj0gdHJ1ZSlcbiAgICAgIGVsc2UgaW5jciBpXG4gICAgZG9uZTtcbiAgICBpZiAhZm91bmQgdGhlbiBpZl9mb3VuZCB+aTohaSB+dmFsdWU6IXZhbHVlX2ZvdW5kIGVsc2UgaWZfbm90X2ZvdW5kICgpKVxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBTb21lIChpLCB2YWx1ZSkpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IE5vbmUpXG47O1xuXG5sZXQgZmluZGlfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBpLCB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZGlfZXhuOiBub3QgZm91bmRcIikpKVxuOztcblxubGV0IGZpbmRfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZjooZnVuIF9pIHggLT4gZiB4KVxuICAgIH5pZl9mb3VuZDooZnVuIH5pOl8gfnZhbHVlIC0+IHZhbHVlKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX2V4bjogbm90IGZvdW5kXCIpKSlcbiAgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmQgdCB+ZiA9IE9wdGlvbi5tYXAgKGZpbmRpIHQgfmY6KGZ1biBfaSB4IC0+IGYgeCkpIH5mOihmdW4gKF9pLCB4KSAtPiB4KVxuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRfbWFwX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfbWFwX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXAgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcF9leG5cbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiAhaSB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRfbWFwaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX21hcGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXBpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBpX2V4blxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIHQgfmVxdWFsID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBpZiBuIDw9IDFcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZXN1bHQgPSByZWYgTm9uZSBpblxuICAgIGxldCBpID0gcmVmIDEgaW5cbiAgICBsZXQgcHJldiA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgY3VyID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBlcXVhbCBjdXIgIXByZXZcbiAgICAgIHRoZW4gKFxuICAgICAgICByZXN1bHQgOj0gU29tZSAoIXByZXYsIGN1cik7XG4gICAgICAgIGkgOj0gbilcbiAgICAgIGVsc2UgKFxuICAgICAgICBwcmV2IDo9IGN1cjtcbiAgICAgICAgaW5jciBpKVxuICAgIGRvbmU7XG4gICAgIXJlc3VsdClcbjs7XG5cbmxldCByZWR1Y2UgdCB+ZiA9XG4gIGlmIGxlbmd0aCB0ID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHIgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIGZvciBpID0gMSB0byBsZW5ndGggdCAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gICAgZG9uZTtcbiAgICBTb21lICFyKVxuOztcblxubGV0IHJlZHVjZV9leG4gdCB+ZiA9XG4gIG1hdGNoIHJlZHVjZSB0IH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiQXJyYXkucmVkdWNlX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCBwZXJtdXRlID0gQXJyYXlfcGVybXV0ZS5wZXJtdXRlXG5cbmxldCByYW5kb21fZWxlbWVudF9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBmYWlsd2l0aCBcIkFycmF5LnJhbmRvbV9lbGVtZW50X2V4bjogZW1wdHkgYXJyYXlcIlxuICBlbHNlIHQuKFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChsZW5ndGggdCkpXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnQgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIHRyeSBTb21lIChyYW5kb21fZWxlbWVudF9leG4gfnJhbmRvbV9zdGF0ZSB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgemlwIHQxIHQyID1cbiAgaWYgbGVuZ3RoIHQxIDw+IGxlbmd0aCB0MiB0aGVuIE5vbmUgZWxzZSBTb21lIChtYXAyX2V4biB0MSB0MiB+ZjooZnVuIHgxIHgyIC0+IHgxLCB4MikpXG47O1xuXG5sZXQgemlwX2V4biB0MSB0MiA9XG4gIGlmIGxlbmd0aCB0MSA8PiBsZW5ndGggdDJcbiAgdGhlbiBmYWlsd2l0aCBcIkFycmF5LnppcF9leG5cIlxuICBlbHNlIG1hcDJfZXhuIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKVxuOztcblxubGV0IHVuemlwIHQgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gW3x8XSwgW3x8XVxuICBlbHNlIChcbiAgICBsZXQgeCwgeSA9IHQuKDApIGluXG4gICAgbGV0IHJlczEgPSBjcmVhdGUgfmxlbjpuIHggaW5cbiAgICBsZXQgcmVzMiA9IGNyZWF0ZSB+bGVuOm4geSBpblxuICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgbGV0IHgsIHkgPSB0LihpKSBpblxuICAgICAgcmVzMS4oaSkgPC0geDtcbiAgICAgIHJlczIuKGkpIDwtIHlcbiAgICBkb25lO1xuICAgIHJlczEsIHJlczIpXG47O1xuXG5sZXQgc29ydGVkX2NvcHkgdCB+Y29tcGFyZSA9XG4gIGxldCB0MSA9IGNvcHkgdCBpblxuICBzb3J0IHQxIH5jb21wYXJlO1xuICB0MVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICBsZXQgKGJvdGggOiBfIEVpdGhlci50IHQpID0gbWFwaSB0IH5mIGluXG4gIGxldCBmaXJzdHMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgeCAtPiBTb21lIHhcbiAgICAgIHwgU2Vjb25kIF8gLT4gTm9uZSlcbiAgaW5cbiAgbGV0IHNlY29uZHMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgXyAtPiBOb25lXG4gICAgICB8IFNlY29uZCB4IC0+IFNvbWUgeClcbiAgaW5cbiAgZmlyc3RzLCBzZWNvbmRzXG47O1xuXG5sZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIEZpcnN0IHggZWxzZSBTZWNvbmQgeCkgW0Bub250YWlsXVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biBfIHggLT4gZiB4KSBbQG5vbnRhaWxdXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biBfIHggLT4gZiB4KSBbQG5vbnRhaWxdXG5sZXQgbGFzdCB0ID0gdC4obGVuZ3RoIHQgLSAxKVxuXG4oKiBDb252ZXJ0IHRvIGEgc2VxdWVuY2UgYnV0IGRvZXMgbm90IGF0dGVtcHQgdG8gcHJvdGVjdCBhZ2FpbnN0IG1vZGlmaWNhdGlvblxuICAgaW4gdGhlIGFycmF5LiAqKVxubGV0IHRvX3NlcXVlbmNlX211dGFibGUgdCA9XG4gIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBpIC0+XG4gICAgaWYgaSA+PSBsZW5ndGggdFxuICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSB0LihpKTsgc3RhdGUgPSBpICsgMSB9KVxuOztcblxubGV0IHRvX3NlcXVlbmNlIHQgPSB0b19zZXF1ZW5jZV9tdXRhYmxlIChjb3B5IHQpXG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCB0MSB0MiA9XG4gIGlmIGlzX2VtcHR5IHQxIHx8IGlzX2VtcHR5IHQyXG4gIHRoZW4gW3x8XVxuICBlbHNlIChcbiAgICBsZXQgbjEgPSBsZW5ndGggdDEgaW5cbiAgICBsZXQgbjIgPSBsZW5ndGggdDIgaW5cbiAgICBsZXQgdCA9IGNyZWF0ZSB+bGVuOihuMSAqIG4yKSAodDEuKDApLCB0Mi4oMCkpIGluXG4gICAgbGV0IHIgPSByZWYgMCBpblxuICAgIGZvciBpMSA9IDAgdG8gbjEgLSAxIGRvXG4gICAgICBmb3IgaTIgPSAwIHRvIG4yIC0gMSBkb1xuICAgICAgICB0LighcikgPC0gdDEuKGkxKSwgdDIuKGkyKTtcbiAgICAgICAgaW5jciByXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICB0KVxuOztcblxubGV0IHRyYW5zcG9zZSB0dCA9XG4gIGlmIGxlbmd0aCB0dCA9IDBcbiAgdGhlbiBTb21lIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHdpZHRoID0gbGVuZ3RoIHR0IGluXG4gICAgbGV0IGRlcHRoID0gbGVuZ3RoIHR0LigwKSBpblxuICAgIGlmIGV4aXN0cyB0dCB+ZjooZnVuIHQgLT4gbGVuZ3RoIHQgPD4gZGVwdGgpXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBTb21lIChpbml0IGRlcHRoIH5mOihmdW4gZCAtPiBpbml0IHdpZHRoIH5mOihmdW4gdyAtPiB0dC4odykuKGQpKSkpKVxuOztcblxubGV0IHRyYW5zcG9zZV9leG4gdHQgPVxuICBtYXRjaCB0cmFuc3Bvc2UgdHQgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJBcnJheS50cmFuc3Bvc2VfZXhuXCJcbiAgfCBTb21lIHR0JyAtPiB0dCdcbjs7XG5cbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGUuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZ2V0ID0gZ2V0XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBlbmQpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIHQgPVxuICAgICAgaWYgbGVuID0gMFxuICAgICAgdGhlbiBbfHxdXG4gICAgICBlbHNlIChcbiAgICAgICAgYXNzZXJ0IChsZW5ndGggdCA+IDApO1xuICAgICAgICBjcmVhdGUgfmxlbiB0LigwKSlcbiAgICA7O1xuXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpdGVyIHQgfmY6aW52YXJpYW50X2FcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNvcnQgPSBTb3J0XG4gIG1vZHVsZSBTb3J0ZXIgPSBTb3J0ZXJcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2MTU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfT2JqX2xvY2FsIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2MTY2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNiIsImEyIiwiYTMiLCJhNCIsImE1IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIlN0ZGxpYl9PYmoiLCJCYXNlX0FycmF5MCIsIkJhc2VfSW50MCIsIkJhc2VfU3RyaW5nMCIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9CbGl0IiwiY3N0X09ial9hcnJheV90X29mX2xlbmd0aCIsImludmFyaWFudCIsInQiLCJsZW5ndGgiLCJzZXhwX29mX3QiLCJ6ZXJvX29iaiIsImNyZWF0ZV96ZXJvIiwibGVuIiwiZW1wdHkiLCJnZXQiLCJpIiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSIsIm9iaiIsInNldF93aXRoX2NhbWxfbW9kaWZ5IiwidW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVuIiwiaW50Iiwic2V0Iiwib2xkX29iaiIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGUiLCJzd2FwIiwiaiIsImEiLCJiIiwiY3JlYXRlIiwieCIsInNpbmdsZXRvbiIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyIsInVuc2FmZV9zZXRfaW50IiwidW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIiLCJ1bnNhZmVfYmxpdCIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiaW5jbHVkZSIsImJsaXQiLCJibGl0byIsInN1YiIsInN1Ym8iLCJjb3B5IiwiQmFzZV9PYmpfYXJyYXkiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9vYmpfYXJyYXkubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEs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NUI7QUFBQUEsSUFheEQ7QUFBQSxlQUVlLDJDQUFPO0FBQUE7QUFBQSxVQUFBRyxJQUFBO0FBQUE7QUFBQSxXQUFBQSxNQUMyQiwrQ0FBOUI7QUFBQSxPQUFmLGdCQUFlO0FBQUEsaUJBQTRDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUR6QztBQUFBO0FBQUEsY0FJWjtBQUFBLElBQU87QUFBQSxTQUFBQSxNQUFBO0FBQUE7QUFBQSxVQUFBQSxNQUNnQyxpREFBOUI7QUFBQSxNQUFmLGdCQUFlO0FBQUEsZ0JBQTRDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUQ5QztBQUFBLEdBRVg7QUFBQTtBQUFBLElBQUEwQixVRG5MUjtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQVAsZ0JBQUE7QUFBQSxJQUFBUSxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLFlBQUFDLEtBQUFUO0FBQUFBLFFBQUFFLE1DK0xZO0FBQUEsSUFDVjtBQUFBLElBQWtCO0FBQUEsR0FDZjtBQUFBO0FBQUEsSUFBQVE7QUFBQUEsTURqTUwiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxuKCogV2UgbWFpbnRhaW4gdGhlIHByb3BlcnR5IHRoYXQgYWxsIHZhbHVlcyBvZiB0eXBlIFt0XSBkbyBub3QgaGF2ZSB0aGUgdGFnXG4gICBbZG91YmxlX2FycmF5X3RhZ10uICBTb21lIGZ1bmN0aW9ucyBiZWxvdyBhc3N1bWUgdGhpcyBpbiBvcmRlciB0byBhdm9pZCB0ZXN0aW5nIHRoZVxuICAgdGFnLCBhbmQgd2lsbCBzZWdmYXVsdCBpZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgaG9sZC4gKilcbnR5cGUgdCA9IFN0ZGxpYi5PYmoudCBhcnJheVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBhc3NlcnQgKFN0ZGxpYi5PYmoudGFnIChTdGRsaWIuT2JqLnJlcHIgdCkgPD4gU3RkbGliLk9iai5kb3VibGVfYXJyYXlfdGFnKVxuOztcblxubGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCAoKiB3b3VsZCBjaGVjayBmb3IgZmxvYXQgYXJyYXlzIGluIDMyIGJpdCwgYnV0IHdoYXRldmVyICopXG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIFNleHAuQXRvbVxuICAgIChTdHJpbmcuY29uY2F0IH5zZXA6XCJcIiBbIFwiPE9ial9hcnJheS50IG9mIGxlbmd0aCBcIjsgSW50LnRvX3N0cmluZyAobGVuZ3RoIHQpOyBcIj5cIiBdKVxuOztcblxubGV0IHplcm9fb2JqID0gU3RkbGliLk9iai5yZXByICgwIDogaW50KVxuXG4oKiBXZSBjYWxsIFtBcnJheS5jcmVhdGVdIHdpdGggYSB2YWx1ZSB0aGF0IGlzIG5vdCBhIGZsb2F0IHNvIHRoYXQgdGhlIGFycmF5IGRvZXNuJ3QgZ2V0XG4gICB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICopXG5sZXQgY3JlYXRlX3plcm8gfmxlbiA9IEFycmF5LmNyZWF0ZSB+bGVuIHplcm9fb2JqXG5sZXQgZW1wdHkgPSBbfHxdXG5cbnR5cGUgbm90X2FfZmxvYXQgPVxuICB8IE5vdF9hX2Zsb2F0XzBcbiAgfCBOb3RfYV9mbG9hdF8xIG9mIGludFxuXG5sZXQgX25vdF9hX2Zsb2F0XzAgPSBOb3RfYV9mbG9hdF8wXG5sZXQgX25vdF9hX2Zsb2F0XzEgPSBOb3RfYV9mbG9hdF8xIDQyXG5cbmxldCBnZXQgdCBpID1cbiAgKCogTWFrZSB0aGUgY29tcGlsZXIgYmVsaWV2ZSBbdF0gaXMgYW4gYXJyYXkgbm90IGNvbnRhaW5pbmcgZmxvYXRzIHNvIGl0IGRvZXMgbm90IGNoZWNrXG4gICAgIGlmIFt0XSBpcyB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICBJdCBpcyBOT1Qgb2sgdG8gdXNlIFtpbnQgYXJyYXldIHNpbmNlIChpZlxuICAgICB0aGlzIGZ1bmN0aW9uIGlzIGlubGluZWQgYW5kIHRoZSBhcnJheSBjb250YWlucyBpbi1oZWFwIGJveGVkIHZhbHVlcykgd3JvbmcgcmVnaXN0ZXJcbiAgICAgdHlwaW5nIG1heSByZXN1bHQsIGxlYWRpbmcgdG8gYSBmYWlsdXJlIHRvIHJlZ2lzdGVyIG5lY2Vzc2FyeSBHQyByb290cy4gKilcbiAgU3RkbGliLk9iai5yZXByXG4gICAgKCogW1N5cy5vcGFxdWVfaWRlbnRpdHldIGlzIHJlcXVpcmVkIG9uIHRoZSBhcnJheSBiZWNhdXNlIHRoaXMgY29kZSBicmVha3MgdGhlIHVzdWFsXG4gICAgICAgYXNzdW1wdGlvbnMgYWJvdXQgYXJyYXkga2luZHMgdGhhdCB0aGUgRmxhbWJkYSAyIG9wdGltaXNlciBjYW4gc2VlLiAqKVxuICAgICgoU3lzLm9wYXF1ZV9pZGVudGl0eSAoU3RkbGliLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpKS4oaSlcbiAgICAgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX2dldCB0IGkgPVxuICAoKiBNYWtlIHRoZSBjb21waWxlciBiZWxpZXZlIFt0XSBpcyBhbiBhcnJheSBub3QgY29udGFpbmluZyBmbG9hdHMgc28gaXQgZG9lcyBub3QgY2hlY2tcbiAgICAgaWYgW3RdIGlzIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gKilcbiAgU3RkbGliLk9iai5yZXByXG4gICAgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoT2JqX2xvY2FsLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkpXG4gICAgICAgaVxuICAgICA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIFNhbWUgY29tbWVudCBhcyBbdW5zYWZlX2dldF0uIFN5cy5vcGFxdWVfaWRlbnRpdHkgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb21cbiAgICAgcG90ZW50aWFsbHkgd3JvbmdseSBndWVzc2luZyB0aGUgdHlwZSBvZiB0aGUgYXJyYXkgYmFzZWQgb24gdGhlIHR5cGUgb2YgZWxlbWVudCwgdGhhdFxuICAgICBpcyBwcmV2ZW50IHRoZSBpbXBsaWNhdGlvbjogKE9iai50YWcgb2JqID0gT2JqLmRvdWJsZV90YWcpID0+IChPYmoudGFnIHQgPVxuICAgICBPYmouZG91YmxlX2FycmF5X3RhZykgd2hpY2ggZmxhbWJkYSBoYXMgdHJpZWQgaW4gdGhlIHBhc3QgKGF0IGxlYXN0IHRoYXQncyBhc3N1bWluZ1xuICAgICB0aGUgY29tcGlsZXIgcmVzcGVjdHMgU3lzLm9wYXF1ZV9pZGVudGl0eSwgd2hpY2ggaXMgbm90IGFsd2F5cyB0aGUgY2FzZSkuICopXG4gIEFycmF5LnVuc2FmZV9zZXRcbiAgICAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoT2JqX2xvY2FsLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkpXG4gICAgaVxuICAgIChTdGRsaWIuT2JqLm9iaiAoU3lzLm9wYXF1ZV9pZGVudGl0eSBvYmopIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmogPVxuICAoKiBzYW1lIGFzIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSBidXQgc2FmZSAqKVxuICAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoU3RkbGliLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpKS4oaSlcbiAgPC0gKFN0ZGxpYi5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50ID1cbiAgKCogVGhpcyBza2lwcyBbY2FtbF9tb2RpZnldLCB3aGljaCBpcyBPSyBpZiBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZXMgYXJlIGludGVnZXJzLiAqKVxuICBBcnJheS51bnNhZmVfc2V0XG4gICAgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKE9ial9sb2NhbC5tYWdpYyAodCA6IHQpIDogaW50IGFycmF5KSlcbiAgICBpXG4gICAgKFN5cy5vcGFxdWVfaWRlbnRpdHkgaW50KVxuOztcblxuKCogRm9yIFtzZXRdIGFuZCBbdW5zYWZlX3NldF0sIGlmIGEgcG9pbnRlciBpcyBpbnZvbHZlZCwgd2UgZmlyc3QgZG8gYSBwaHlzaWNhbC1lcXVhbGl0eVxuICAgdGVzdCB0byBzZWUgaWYgdGhlIHBvaW50ZXIgaXMgY2hhbmdpbmcuICBJZiBub3QsIHdlIGRvbid0IG5lZWQgdG8gZG8gdGhlIFtzZXRdLCB3aGljaFxuICAgc2F2ZXMgYSBjYWxsIHRvIFtjYW1sX21vZGlmeV0uICBXZSB0aGluayB0aGlzIHBoeXNpY2FsLWVxdWFsaXR5IHRlc3QgaXMgd29ydGggaXRcbiAgIGJlY2F1c2UgaXQgaXMgdmVyeSBjaGVhcCAoYm90aCB2YWx1ZXMgYXJlIGFscmVhZHkgYXZhaWxhYmxlIGZyb20gdGhlIFtpc19pbnRdIHRlc3QpXG4gICBhbmQgYmVjYXVzZSBbY2FtbF9tb2RpZnldIGlzIGV4cGVuc2l2ZS4gKilcblxubGV0IHNldCB0IGkgb2JqID1cbiAgKCogV2UgdXNlIFtnZXRdIGZpcnN0IGJ1dCB0aGVuIHdlIHVzZSBbQXJyYXkudW5zYWZlX3NldF0gc2luY2Ugd2Uga25vdyB0aGF0IFtpXSBpc1xuICAgICB2YWxpZC4gKilcbiAgbGV0IG9sZF9vYmogPSBnZXQgdCBpIGluXG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IG9sZF9vYmogJiYgU3RkbGliLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKFN0ZGxpYi5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSBpZiBub3QgKHBoeXNfZXF1YWwgb2xkX29iaiBvYmopXG4gIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldCB0IGkgb2JqID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvbGRfb2JqICYmIFN0ZGxpYi5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChTdGRsaWIuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9vYmogb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSBvYmogPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IG9sZF9vYmogJiYgU3RkbGliLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKFN0ZGxpYi5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0IHN3YXAgdCBpIGogPVxuICBsZXQgYSA9IGdldCB0IGkgaW5cbiAgbGV0IGIgPSBnZXQgdCBqIGluXG4gIHVuc2FmZV9zZXQgdCBpIGI7XG4gIHVuc2FmZV9zZXQgdCBqIGFcbjs7XG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgKCogSWYgd2UgY2FuLCB1c2UgW0FycmF5LmNyZWF0ZV0gZGlyZWN0bHkuIEV2ZW4gdGhvdWdoIFtpc19pbnRdIGNoZWNrIGlzIHN1YnN1bWVkIGJ5XG4gICAgIHRoZSB0YWcgY2hlY2ssIGNoZWNraW5nIGl0IGlzIG11Y2ggZmFzdGVyLCBzaW5jZSBpdCBhdm9pZHMgYSBDIGZ1bmN0aW9uIGNhbGwuICAqKVxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCB4IHx8IFN0ZGxpYi5PYmoudGFnIHggPD4gU3RkbGliLk9iai5kb3VibGVfdGFnXG4gIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4geFxuICBlbHNlIChcbiAgICAoKiBPdGhlcndpc2UgdXNlIFtjcmVhdGVfemVyb10gYW5kIHNldCB0aGUgY29udGVudHMgKilcbiAgICBsZXQgdCA9IGNyZWF0ZV96ZXJvIH5sZW4gaW5cbiAgICBsZXQgeCA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHhcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgc2luZ2xldG9uIG9iaiA9IGNyZWF0ZSB+bGVuOjEgb2JqXG5cbigqIFByZS1jb25kaXRpb246IHQuKGkpIGlzIGFuIGludGVnZXIuICopXG5sZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBvYmogPVxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoU3RkbGliLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlXG4gICAgKCogW3QuKGkpXSBpcyBhbiBpbnRlZ2VyIGFuZCBbb2JqXSBpcyBub3QsIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGlmIHRoZXkgYXJlXG4gICAgICAgZXF1YWwuICopXG4gICAgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCB1bnNhZmVfc2V0X2ludCB0IGkgaW50ID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvbGRfb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50XG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoU3RkbGliLk9iai5yZXByIGludClcbjs7XG5cbmxldCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciB0IGkgPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIG5vdCAoU3RkbGliLk9iai5pc19pbnQgb2xkX29iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChTdGRsaWIuT2JqLnJlcHIgMClcbjs7XG5cbigqKiBbdW5zYWZlX2JsaXRdIGlzIGxpa2UgW0FycmF5LmJsaXRdLCBleGNlcHQgaXQgdXNlcyBvdXIgb3duIGZvci1sb29wIHRvIGF2b2lkXG4gICAgY2FtbF9tb2RpZnkgd2hlbiBwb3NzaWJsZS4gIEl0cyBwZXJmb3JtYW5jZSBpcyBzdGlsbCBub3QgY29tcGFyYWJsZSB0byBhIG1lbWNweS4gKilcbmxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICgqIFdoZW4gW3BoeXNfZXF1YWwgc3JjIGRzdF0sIHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciBbZHN0X3BvcyA8IHNyY19wb3NdIGFuZCBoYXZlIHRoZVxuICAgICBmb3IgbG9vcCBnbyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGRhdGEgdGhhdCB3ZSBzdGlsbCBuZWVkXG4gICAgIHRvIHJlYWQuICBXaGVuIFtub3QgKHBoeXNfZXF1YWwgc3JjIGRzdCldLCBkb2luZyB0aGlzIGlzIGhhcm1sZXNzLiAgRnJvbSBhXG4gICAgIG1lbW9yeS1wZXJmb3JtYW5jZSBwZXJzcGVjdGl2ZSwgaXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciBvbmUgbG9vcHMgdXAgb3IgZG93bi5cbiAgICAgQ29uc3RhbnQtc3RyaWRlIGFjY2VzcywgZm9yd2FyZCBvciBiYWNrd2FyZCwgc2hvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIChhdCBsZWFzdCBvblxuICAgICBhbiBpbnRlbCBpNykuICBTbywgd2UgZG9uJ3QgZG8gYSBjaGVjayBmb3IgW3BoeXNfZXF1YWwgc3JjIGRzdF0gYW5kIGFsd2F5cyBsb29wIHVwIGluXG4gICAgIHRoYXQgY2FzZS4gKilcbiAgaWYgZHN0X3BvcyA8IHNyY19wb3NcbiAgdGhlblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IGRzdCAoZHN0X3BvcyArIGkpICh1bnNhZmVfZ2V0IHNyYyAoc3JjX3BvcyArIGkpKVxuICAgIGRvbmVcbiAgZWxzZVxuICAgIGZvciBpID0gbGVuIC0gMSBkb3dudG8gMCBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG47O1xuXG5pbmNsdWRlIEJsaXQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVfemVyb1xuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBjb3B5IHNyYyA9XG4gIGxldCBkc3QgPSBjcmVhdGVfemVybyB+bGVuOihsZW5ndGggc3JjKSBpblxuICBibGl0byB+c3JjIH5kc3QgKCk7XG4gIGRzdFxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNjM2OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfc3JjX3VuaWZvcm1fYXJyYXlfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfQ29udGFpbmVyIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0FycmF5IiwiU2V4cGxpYjBfU2V4cF9ncmFtbWFyIiwiQmFzZV9MaXN0IiwiU3RkbGliX09iaiIsIkJhc2VfT2JqX2FycmF5IiwiQmFzZV9TZXhwYWJsZSIsIkJhc2VfQmxpdCIsImVtcHR5IiwidW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIiwibGVuIiwiY3JlYXRlX29ial9hcnJheSIsImNyZWF0ZSIsIngiLCJzaW5nbGV0b24iLCJzd2FwIiwidCIsImkiLCJqIiwiZ2V0IiwiYXJyIiwic2V0IiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X2ludCIsInVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbiIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyIsImxlbmd0aCIsInVuc2FmZV9ibGl0IiwiY29weSIsInVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZSIsInVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSIsInNldF93aXRoX2NhbWxfbW9kaWZ5IiwidW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIiLCJjc3RfVW5pZm9ybV9hcnJheV9pbml0IiwiY3N0X0FycmF5X21hcDJfZXhuIiwiaW52YXJpYW50IiwiaW5pdCIsImwiLCJyZXMiLCJvZl9hcnJheSIsIm1hcCIsImEiLCJtYXBpIiwiaXRlciIsIml0ZXJpIiwiZm9sZGkiLCJhY2MiLCJ0b19saXN0Iiwib2ZfbGlzdCIsInRvX2FycmF5IiwiZXhpc3RzIiwiZm9yX2FsbCIsIm1hcDJfZXhuIiwidDEiLCJ0MiIsInRfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsImluY2x1ZGUiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJjcmVhdGVfbGlrZSIsImJsaXQiLCJibGl0byIsInN1YiIsInN1Ym8iLCJmb2xkIiwiciIsIm1pbl9lbHQiLCJjb21wYXJlIiwibWF4X2VsdCIsImNvbXBhcmVfZWx0IiwiYiIsImxlbl9hIiwibGVuX2IiLCJyZXQiLCJTb3J0Iiwic29ydCIsIkJhc2VfVW5pZm9ybV9hcnJheSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL3VuaWZvcm1fYXJyYXkubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyw0QkFBQUM7QUFBQUEsSUNpQ3lDLHlDQUEwQjtBQUFBO0FBQUEsWUFBQUMsaUJBQUFELEtBQ3JDLHlDQUEwQjtBQUFBLFlBQUFFLE9BQUFGLEtBQUFHLEdBQ2xDLDRDQUF5QztBQUFBLFlBQUFDLFVBQUFELEdBQzNDLHdDQUF1QztBQUFBLFlBQUFFLEtBQUFDLEdBQUFDLEdBQUFDLEdBQ3hDLDhDQUFvQjtBQUFBLFlBQUFDLElBQUFDLEtBQUFILEdBQ3JCLDZDQUFvQztBQUFBLFlBQUFJLElBQUFELEtBQUFILEdBQUFKLEdBQ2xDLGdEQUF1QztBQUFBLFlBQUFTLFdBQUFGLEtBQUFILEdBQ2xDLDZDQUEyQztBQUFBLFlBQUFNLFdBQUFILEtBQUFILEdBQUFKO0FBQUFB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QUFBQSxJQUU1QjtBQUFBLEdBQUU7QUFBQSxZQUFBbUQsUUFBQXBELEdBQUFxRDtBQUFBQSxJQUdxQixzREFBa0M7QUFBQTtBQUFBLFlBQUFDLFFBQUF0RCxHQUFBcUQ7QUFBQUEsSUFDbEMsc0RBQWtDO0FBQUE7QUFBQSxZQUFBQSxRQUFBRSxhQUFBN0IsR0FBQThCO0FBQUFBLElBSXRELHVDQUNFO0FBQUE7QUFBQSxLQUFBQyxRQUVTO0FBQUEsS0FBQUMsUUFDQTtBQUFBLEtBQUFDLE1BQ1o7QUFBQSxJQUNBLGNBQ0s7QUFBQSxRQUFBMUQsSUFXSDtBQUFBO0FBQUEsS0FSRSxnQkFDSztBQUFBO0FBQUEsTUFBQXFCLElBRUs7QUFBQSxNQUFBNkIsSUFDQTtBQUFBLE1BQUE1QixNQUNFO0FBQUEsS0FDVixjQUFpQjtBQUFBLFNBQUF0QixNQUFjO0FBQUEsS0FBTztBQUFBO0FBQUEsR0FFbEM7QUFBQTtBQUFBLElBQUEyRCxPRDNNZDtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuKCogV0FSTklORzpcbiAgIFdlIHVzZSBub24tbWVtb3J5LXNhZmUgdGhpbmdzIHRocm91Z2hvdXQgdGhlIFtUcnVzdGVkXSBtb2R1bGUuXG4gICBNb3N0IG9mIGl0IGlzIG9ubHkgc2FmZSBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSB0eXBlIHNpZ25hdHVyZSAoZS5nLiBleHBvc2luZ1xuICAgW3ZhbCBjb3B5IDogJ2EgdCAtPiAnYiB0XSB3b3VsZCBiZSBhIGJpZyBtaXN0YWtlKS4gKilcbm1vZHVsZSBUcnVzdGVkIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBlbXB0eSA6ICdhIHRcbiAgdmFsIHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlX29ial9hcnJheSA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiAnYSAtPiAnYSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYSB0XG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgc3dhcCA6IF8gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9nZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgdW5zYWZlX3NldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnQgOiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBzZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIGxlbmd0aCA6ICgnYSB0W0Bsb2NhbF0pIC0+IGludFxuICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgdCwgJ2EgdCkgQmxpdC5ibGl0XG4gIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gIHZhbCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciA6IF8gdCAtPiBpbnQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IE9ial9hcnJheS50XG5cbiAgbGV0IGVtcHR5ID0gT2JqX2FycmF5LmVtcHR5XG4gIGxldCB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbiA9IE9ial9hcnJheS5jcmVhdGVfemVybyB+bGVuXG4gIGxldCBjcmVhdGVfb2JqX2FycmF5IH5sZW4gPSBPYmpfYXJyYXkuY3JlYXRlX3plcm8gfmxlblxuICBsZXQgY3JlYXRlIH5sZW4geCA9IE9ial9hcnJheS5jcmVhdGUgfmxlbiAoU3RkbGliLk9iai5yZXByIHgpXG4gIGxldCBzaW5nbGV0b24geCA9IE9ial9hcnJheS5zaW5nbGV0b24gKFN0ZGxpYi5PYmoucmVwciB4KVxuICBsZXQgc3dhcCB0IGkgaiA9IE9ial9hcnJheS5zd2FwIHQgaSBqXG4gIGxldCBnZXQgYXJyIGkgPSBTdGRsaWIuT2JqLm9iaiAoT2JqX2FycmF5LmdldCBhcnIgaSlcbiAgbGV0IHNldCBhcnIgaSB4ID0gT2JqX2FycmF5LnNldCBhcnIgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfZ2V0IGFyciBpID0gU3RkbGliLk9iai5vYmogKE9ial9hcnJheS51bnNhZmVfZ2V0IGFyciBpKVxuICBsZXQgdW5zYWZlX3NldCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXQgYXJyIGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX3NldF9pbnQgYXJyIGkgeCA9IE9ial9hcnJheS51bnNhZmVfc2V0X2ludCBhcnIgaSB4XG5cbiAgbGV0IHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeFxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9IE9ial9hcnJheS5sZW5ndGhcbiAgbGV0IHVuc2FmZV9ibGl0ID0gT2JqX2FycmF5LnVuc2FmZV9ibGl0XG4gIGxldCBjb3B5ID0gT2JqX2FycmF5LmNvcHlcblxuICBsZXQgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPSBPYmpfYXJyYXkuc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyID0gT2JqX2FycmF5LnVuc2FmZV9jbGVhcl9pZl9wb2ludGVyXG5lbmRcblxuaW5jbHVkZSBUcnVzdGVkXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIGFzc2VydCAoU3RkbGliLk9iai50YWcgKFN0ZGxpYi5PYmoucmVwciB0KSA8PiBTdGRsaWIuT2JqLmRvdWJsZV9hcnJheV90YWcpXG47O1xuXG5sZXQgaW5pdCBsIH5mID1cbiAgaWYgbCA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlVuaWZvcm1fYXJyYXkuaW5pdFwiXG4gIGVsc2UgKFxuICAgIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbjpsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgZG9uZTtcbiAgICByZXMpXG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyID0gaW5pdCB+ZjooQXJyYXkudW5zYWZlX2dldCBhcnIpIChBcnJheS5sZW5ndGggYXJyKSBbQG5vbnRhaWxdXG5sZXQgbWFwIGEgfmYgPSBpbml0IH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IGEgaSkpIChsZW5ndGggYSkgW0Bub250YWlsXVxubGV0IG1hcGkgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgaSAodW5zYWZlX2dldCBhIGkpKSAobGVuZ3RoIGEpIFtAbm9udGFpbF1cblxubGV0IGl0ZXIgYSB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIGEgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZVxuOztcblxubGV0IGZvbGRpIGEgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGFjYyA6PSBmIGkgIWFjYyAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFhY2Ncbjs7XG5cbmxldCB0b19saXN0IHQgPSBMaXN0LmluaXQgfmY6KGdldCB0KSAobGVuZ3RoIHQpXG5cbmxldCBvZl9saXN0IGwgPVxuICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSB4IC0+IHNldCByZXMgaSB4KTtcbiAgcmVzXG47O1xuXG4oKiBJdCBpcyBub3Qgc2FmZSBmb3IgW3RvX2FycmF5XSB0byBiZSB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYmVjYXVzZSB3ZSBoYXZlIGNvZGUgdGhhdFxuICAgcmVsaWVzIG9uIFtmbG9hdCBhcnJheV1zIGJlaW5nIHVuYm94ZWQsIGZvciBleGFtcGxlIGluIFtiaW5fd3JpdGVfYXJyYXldLiAqKVxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiBpID1cbiAgICBpZiBpIDwgMCB0aGVuIGZhbHNlIGVsc2UgZiAodW5zYWZlX2dldCB0IGkpIHx8IGxvb3AgdCB+ZiAoaSAtIDEpXG4gIGluXG4gIGxvb3AgdCB+ZiAobGVuZ3RoIHQgLSAxKVxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IH5mIGkgPSBpZiBpIDwgMCB0aGVuIHRydWUgZWxzZSBmICh1bnNhZmVfZ2V0IHQgaSkgJiYgbG9vcCB0IH5mIChpIC0gMSkgaW5cbiAgbG9vcCB0IH5mIChsZW5ndGggdCAtIDEpXG47O1xuXG5sZXQgbWFwMl9leG4gdDEgdDIgfmYgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQxIGluXG4gIGlmIGxlbmd0aCB0MiA8PiBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDJfZXhuXCI7XG4gIGluaXQgbGVuIH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAoZ3JhbW1hciA6IGVsdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBlbHQgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKEFycmF5LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5pbmNsdWRlXG4gIFNleHBhYmxlLk9mX3NleHBhYmxlMVxuICAgIChBcnJheSlcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19hcnJheVxuICAgICAgbGV0IG9mX3NleHBhYmxlID0gb2ZfYXJyYXlcbiAgICBlbmQpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIHQgPVxuICAgICAgaWYgbGVuID0gMFxuICAgICAgdGhlbiBlbXB0eVxuICAgICAgZWxzZSAoXG4gICAgICAgIGFzc2VydCAobGVuZ3RoIHQgPiAwKTtcbiAgICAgICAgY3JlYXRlIH5sZW4gKGdldCB0IDApKVxuICAgIDs7XG5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbigqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHBweF9jb21wYXJlIFtjb21wYXJlX2FycmF5XSBidXQgdXNlcyBvdXIgW3Vuc2FmZV9nZXRdIGFuZCBbbGVuZ3RoXS4gKilcbmxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGEgYiA9XG4gIGlmIHBoeXNfZXF1YWwgYSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBsZXQgbGVuX2EgPSBsZW5ndGggYSBpblxuICAgIGxldCBsZW5fYiA9IGxlbmd0aCBiIGluXG4gICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICBpZiByZXQgPD4gMFxuICAgIHRoZW4gcmV0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICB0aGVuIDBcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGwgPSB1bnNhZmVfZ2V0IGEgaVxuICAgICAgICAgIGFuZCByID0gdW5zYWZlX2dldCBiIGkgaW5cbiAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICBpblxuICAgICAgbG9vcCAwKSlcbjs7XG5cbm1vZHVsZSBTb3J0ID0gQXJyYXkuUHJpdmF0ZS5Tb3J0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRcbiAgICBsZXQgc2V0ID0gdW5zYWZlX3NldFxuICBlbmQpXG5cbmxldCBzb3J0ID0gU29ydC5zb3J0XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTY3MDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfVWNoYXIiLCJzdWNjIiwicHJlZCIsImlzX3ZhbGlkIiwiaXNfY2hhciIsInVuc2FmZV90b19jaGFyIiwidW5zYWZlX29mX2ludCIsIm9mX2ludCIsInRvX2ludCIsIm9mX2NoYXIiLCJjb21wYXJlIiwiZXF1YWwiLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJCYXNlX1VjaGFyMCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2NzQyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfRmxvYXRhYmxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2NzU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9zcmNfZmxvYXQwX21sIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX09wdGlvbiIsIkJhc2VfUHJpbnRmIiwiU3RkbGliX0Zsb2F0IiwiY2VpbCIsImZsb29yIiwibW9kX2Zsb2F0IiwibW9kZiIsImZsb2F0X29mX3N0cmluZyIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJuYW4iLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm1heF9maW5pdGVfdmFsdWUiLCJlcHNpbG9uX2Zsb2F0IiwiY2xhc3NpZnlfZmxvYXQiLCJhYnNfZmxvYXQiLCJpc19pbnRlZ2VyIiwic3ltYm9sIiwiYSIsImIiLCJtIiwiZnJleHAiLCJsZGV4cCIsImlzX25hbiIsIngiLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsInQiLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlcl9leG4iLCJvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsIm9uZV91bHAiLCJkaXIiLCJtYXRjaCIsInVwcGVyX2JvdW5kX2Zvcl9pbnQiLCJudW1fYml0cyIsImV4cCIsImlzX3hfbWludXNfb25lX2V4YWN0IiwibG93ZXJfYm91bmRfZm9yX2ludCIsIm1pbl9pbnRfYXNfZmxvYXQiLCJjbGFtcF91bmNoZWNrZWQiLCJtaW4iLCJtYXgiLCJib3giLCJpbmNsdWRlIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImNvbXBhcmUiLCJlcXVhbCIsIkJhc2VfRmxvYXQwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvZmxvYXQwLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxLQUFBO0FBQUEsWUFBQUMs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ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgY2VpbCA9IFN0ZGxpYi5jZWlsXG5sZXQgZmxvb3IgPSBTdGRsaWIuZmxvb3JcbmxldCBtb2RfZmxvYXQgPSBTdGRsaWIubW9kX2Zsb2F0XG5sZXQgbW9kZiA9IFN0ZGxpYi5tb2RmXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ1xubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nX29wdFxubGV0IG5hbiA9IFN0ZGxpYi5uYW5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBtYXhfZmluaXRlX3ZhbHVlID0gU3RkbGliLm1heF9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBTdGRsaWIuZXBzaWxvbl9mbG9hdFxubGV0IGNsYXNzaWZ5X2Zsb2F0ID0gU3RkbGliLmNsYXNzaWZ5X2Zsb2F0XG5sZXQgYWJzX2Zsb2F0ID0gU3RkbGliLmFic19mbG9hdFxubGV0IGlzX2ludGVnZXIgPSBTdGRsaWIuRmxvYXQuaXNfaW50ZWdlclxubGV0ICggKiogKSA9IFN0ZGxpYi4oICoqIClcblxubGV0ICggJS4gKSBhIGIgPVxuICAoKiBSYWlzZSBpbiBjYXNlIG9mIGEgbmVnYXRpdmUgbW9kdWx1cywgYXMgZG9lcyBJbnQuKCAlICkuICopXG4gIGlmIGIgPCAwLlxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCIlZiAlJSAlZiBpbiBmbG9hdDAubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIgYSBiICgpO1xuICBsZXQgbSA9IFN0ZGxpYi5tb2RfZmxvYXQgYSBiIGluXG4gICgqIFByb2R1Y2UgYSBub24tbmVnYXRpdmUgcmVzdWx0IGluIGFuYWxvZ3kgd2l0aCBJbnQuKCAlICkuICopXG4gIGlmIG0gPCAwLiB0aGVuIG0gKy4gYiBlbHNlIG1cbjs7XG5cbigqIFRoZSBiaXRzIG9mIElOUklBJ3MgW1BlcnZhc2l2ZXNdIHRoYXQgd2UganVzdCB3YW50IHRvIGV4cG9zZSBpbiBbRmxvYXRdLiBNb3N0IGFyZVxuICAgYWxyZWFkeSBkZXByZWNhdGVkIGluIFtQZXJ2YXNpdmVzXSwgYW5kIGV2ZW50dWFsbHkgYWxsIG9mIHRoZW0gc2hvdWxkIGJlLiAqKVxuaW5jbHVkZSAoXG4gIFN0ZGxpYiA6XG4gIHNpZ1xuICAgIGV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuXG4gICAgZXh0ZXJuYWwgbGRleHBcbiAgICAgIDogIChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgICAtPiAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgPSBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGFzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbmhfZmxvYXRcIiBcImNhbWxfYXNpbmhcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gIGVuZClcblxuKCogV2UgbmVlZCB0aGlzIGluZGlyZWN0aW9uIGJlY2F1c2UgdGhlc2UgYXJlIGV4cG9zZWQgYXMgXCJ2YWxcIiBpbnN0ZWFkIG9mIFwiZXh0ZXJuYWxcIiAqKVxubGV0IGZyZXhwID0gZnJleHBcbmxldCBsZGV4cCA9IGxkZXhwXG5sZXQgaXNfbmFuIHggPSAoeCA6IGZsb2F0KSA8PiB4XG5cbigqIEFuIG9yZGVyLXByZXNlcnZpbmcgYmlqZWN0aW9uIGJldHdlZW4gYWxsIGZsb2F0cyBleGNlcHQgZm9yIE5hTnMsIGFuZCA5OS45NSUgb2ZcbiAgIGludDY0cy5cblxuICAgTm90ZSB3ZSBkb24ndCBkaXN0aW5ndWlzaCAwLiBhbmQgLTAuIGFzIHNlcGFyYXRlIHZhbHVlcyBoZXJlLCB0aGV5IGJvdGggbWFwIHRvIDBMLCB3aGljaFxuICAgbWFwcyBiYWNrIHRvIDAuXG5cbiAgIFRoaXMgc2hvdWxkIHdvcmsgYm90aCBvbiBsaXR0bGUtZW5kaWFuIGFuZCBoaWdoLWVuZGlhbiBDUFVzLiAgV2lraXBlZGlhIHNheXM6IFwib25cbiAgIG1vZGVybiBzdGFuZGFyZCBjb21wdXRlcnMgKGkuZS4sIGltcGxlbWVudGluZyBJRUVFIDc1NCksIG9uZSBtYXkgaW4gcHJhY3RpY2Ugc2FmZWx5XG4gICBhc3N1bWUgdGhhdCB0aGUgZW5kaWFubmVzcyBpcyB0aGUgc2FtZSBmb3IgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBhcyBmb3IgaW50ZWdlcnNcIlxuICAgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW5kaWFubmVzcyNGbG9hdGluZy1wb2ludF9hbmRfZW5kaWFubmVzcykuXG4qKVxubGV0IHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHQgPVxuICBpZiBpc19uYW4gdFxuICB0aGVuIE5vbmVcbiAgZWxzZSBpZiB0ID0gMC5cbiAgdGhlbiAoKiBhbHNvIGluY2x1ZGVzIC0wLiAqKVxuICAgIFNvbWUgMExcbiAgZWxzZSBpZiB0ID4gMC5cbiAgdGhlbiBTb21lIChTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB0KVxuICBlbHNlIFNvbWUgKFN0ZGxpYi5JbnQ2NC5uZWcgKFN0ZGxpYi5JbnQ2NC5iaXRzX29mX2Zsb2F0ICgtLnQpKSlcbjs7XG5cbmxldCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlcl9leG4geCA9IE9wdGlvbi52YWx1ZV9leG4gKHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHgpXG5cbmxldCBvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB4ID1cbiAgaWYgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSB4IDBMXG4gIHRoZW4gU3RkbGliLkludDY0LmZsb2F0X29mX2JpdHMgeFxuICBlbHNlIH4tLihTdGRsaWIuSW50NjQuZmxvYXRfb2ZfYml0cyAoU3RkbGliLkludDY0Lm5lZyB4KSlcbjs7XG5cbmxldCBvbmVfdWxwIGRpciB0ID1cbiAgbWF0Y2ggdG9faW50NjRfcHJlc2VydmVfb3JkZXIgdCB3aXRoXG4gIHwgTm9uZSAtPiBTdGRsaWIubmFuXG4gIHwgU29tZSB4IC0+XG4gICAgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXJcbiAgICAgIChTdGRsaWIuSW50NjQuYWRkXG4gICAgICAgICB4XG4gICAgICAgICAobWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICB8IGBVcCAtPiAxTFxuICAgICAgICAgIHwgYERvd24gLT4gLTFMKSlcbjs7XG5cbigqIFt1cHBlcl9ib3VuZF9mb3JfaW50XSBhbmQgW2xvd2VyX2JvdW5kX2Zvcl9pbnRdIGFyZSBmb3IgY2FsY3VsYXRpbmcgdGhlIG1heC9taW4gZmxvYXRcbiAgIHRoYXQgZml0cyBpbiBhIGdpdmVuLXNpemUgaW50ZWdlciB3aGVuIHJvdW5kZWQgdG93YXJkcyAwICh1c2luZyBbaW50X29mX2Zsb2F0XSkuXG5cbiAgIG1heF9pbnQvbWluX2ludCBkZXBlbmQgb24gW251bV9iaXRzXSwgZS5nLiArLy0gMl4zMCwgKy8tIDJeNjIgaWYgMzEtYml0LCA2My1iaXRcbiAgIChyZXNwZWN0aXZlbHkpIHdoaWxlIGZsb2F0IGlzIElFRUUgc3RhbmRhcmQgZm9yIGRvdWJsZSAoNTIgc2lnbmlmaWNhbnQgYml0cykuXG5cbiAgIEluIGFsbCBjYXNlcywgd2Ugd2FudCB0byBndWFyYW50ZWUgdGhhdFxuICAgW2xvd2VyX2JvdW5kX2Zvcl9pbnQgPD0geCA8PSB1cHBlcl9ib3VuZF9mb3JfaW50XVxuICAgaWZmIFtpbnRfb2ZfZmxvYXQgeF0gZml0cyBpbiBhbiBpbnQgd2l0aCBbbnVtX2JpdHNdIGJpdHMuXG5cbiAgIFsyICoqIChudW1fYml0cyAtIDEpXSBpcyB0aGUgZmlyc3QgZmxvYXQgZ3JlYXRlciB0aGF0IG1heF9pbnQsIHdlIHVzZSB0aGUgcHJlY2VkaW5nXG4gICBmbG9hdCBhcyB1cHBlciBib3VuZC5cblxuICAgWy0gKDIgKiogKG51bV9iaXRzIC0gMSkpXSBpcyBlcXVhbCB0byBtaW5faW50LlxuICAgRm9yIGxvd2VyIGJvdW5kIHdlIGxvb2sgZm9yIHRoZSBzbWFsbGVzdCBmbG9hdCBbZl0gc2F0aXNmeWluZyBbZiA+IG1pbl9pbnQgLSAxXSBzbyB0aGF0XG4gICBbZl0gcm91bmRzIHRvd2FyZCB6ZXJvIHRvIFttaW5faW50XVxuXG4gICBTbyBpbiBwYXJ0aWN1bGFyIHdlIHdpbGwgaGF2ZTpcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IHggPD0gLSAoMiAqKiAoMS14KSldXG4gICBbdXBwZXJfYm91bmRfZm9yX2ludCB4ICA8ICAgIDIgKiogKDEteCkgXVxuKilcbmxldCB1cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzID1cbiAgbGV0IGV4cCA9IFN0ZGxpYi5mbG9hdF9vZl9pbnQgKG51bV9iaXRzIC0gMSkgaW5cbiAgb25lX3VscCBgRG93biAoMi4gKiogZXhwKVxuOztcblxubGV0IGlzX3hfbWludXNfb25lX2V4YWN0IHggPVxuICAoKiBbeCA9IHggLS4gMS5dIGRvZXMgbm90IHdvcmsgd2l0aCB4ODcgZmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYyBiYWNrZW5kICh3aGljaCBpcyB1c2VkXG4gICAgIG9uIDMyLWJpdCBvY2FtbCkgYmVjYXVzZSBvZiA4MC1iaXQgcmVnaXN0ZXIgcHJlY2lzaW9uIG9mIGludGVybWVkaWF0ZSBjb21wdXRhdGlvbnMuXG5cbiAgICAgQW4gYWx0ZXJuYXRpdmUgd2F5IG9mIGNvbXB1dGluZyB0aGlzOiBbeCAtLiBvbmVfdWxwIGBEb3duIHggPD0gMS5dIGlzIGFsc28gcHJvbmUgdG9cbiAgICAgdGhlIHNhbWUgcHJlY2lzaW9uIGlzc3VlczogeW91IG5lZWQgdG8gbWFrZSBzdXJlIFt4XSBpcyA2NC1iaXQuXG4gICopXG4gIGxldCBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBub3QgKFN0ZGxpYi5JbnQ2NC5iaXRzX29mX2Zsb2F0IHggPSBTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCAoeCAtLiAxLikpXG47O1xuXG5sZXQgbG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBTdGRsaWIuZmxvYXRfb2ZfaW50IChudW1fYml0cyAtIDEpIGluXG4gIGxldCBtaW5faW50X2FzX2Zsb2F0ID0gfi0uKDIuICoqIGV4cCkgaW5cbiAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiBudW1fYml0cyAtIDEgPCA1MyAoKiA1MyA9ICNiaXRzIGluIHRoZSBmbG9hdCdzIG1hbnRpc3NhIHdpdGggc2lnbiBpbmNsdWRlZCAqKVxuICB0aGVuIChcbiAgICAoKiBUaGUgc21hbGxlc3QgZmxvYXQgdGhhdCByb3VuZHMgdG93YXJkcyB6ZXJvIHRvIFttaW5faW50XSBpc1xuICAgICAgIFttaW5faW50IC0gMSArIGVwc2lsb25dICopXG4gICAgYXNzZXJ0IChpc194X21pbnVzX29uZV9leGFjdCBtaW5faW50X2FzX2Zsb2F0KTtcbiAgICBvbmVfdWxwIGBVcCAobWluX2ludF9hc19mbG9hdCAtLiAxLikpXG4gIGVsc2UgKFxuICAgICgqIFttaW5faW50X2FzX2Zsb2F0XSBpcyBhbHJlYWR5IHRoZSBzbWFsbGVzdCBmbG9hdCBbZl0gc2F0aXNmeWluZyBbZiA+IG1pbl9pbnQgLSAxXS4gKilcbiAgICBhc3NlcnQgKG5vdCAoaXNfeF9taW51c19vbmVfZXhhY3QgbWluX2ludF9hc19mbG9hdCkpO1xuICAgIG1pbl9pbnRfYXNfZmxvYXQpXG47O1xuXG4oKiBGbG9hdCBjbGFtcGluZyBpcyBzdHJ1Y3R1cmVkIHNsaWdodGx5IGRpZmZlcmVudGx5IHRoYW4gY2xhbXBpbmcgZm9yIG90aGVyIHR5cGVzLCBzb1xuICAgdGhhdCB3ZSBnZXQgdGhlIGJlaGF2aW9yIG9mIFtjbGFtcF91bmNoZWNrZWQgbmFuIH5taW4gfm1heCA9IG5hbl0gKGZvciBhbnkgW21pbl0gYW5kXG4gICBbbWF4XSkgZm9yIGZyZWUuXG4qKVxubGV0IGNsYW1wX3VuY2hlY2tlZCAodCA6IGZsb2F0KSB+bWluIH5tYXggPVxuICBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgbWF4IDwgdCB0aGVuIG1heCBlbHNlIHRcbjs7XG5cbmxldCBib3ggPVxuICAoKiBQcmV2ZW50IHBvdGVudGlhbCBjb25zdGFudCBmb2xkaW5nIG9mIFsrLiAwLl0gaW4gdGhlIG5lYXIgb2NhbWxvcHQgZnV0dXJlLiAqKVxuICBsZXQgeCA9IFN5czAub3BhcXVlX2lkZW50aXR5IDAuIGluXG4gIGZ1biBmIC0+IGYgKy4geFxuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2OTYxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiQmFzZV9IYXNoIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NleHAiLCJCYXNlX0Vycm9yIiwiU3RkbGliX0Zvcm1hdCIsIkJhc2VfU3RyaW5nMCIsIkJhc2VfQ2hhcjAiLCJCYXNlX0lkZW50aWZpYWJsZSIsIkJhc2VfQXJyYXkwIiwiQmFzZV9Db21wYXJhYmxlIiwiZmFpbHdpdGhmIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwiY29tcGFyZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJ0b19zdHJpbmciLCJ0Iiwib2Zfc3RyaW5nIiwicyIsImluY2x1ZGUiLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwiaGFzaGFibGUiLCJwcCIsImZtdCIsImMiLCJpbnZhcmlhbnQiLCJwYXJhbSIsImFsbCIsImNzdF9jaGFyIiwiY3N0X0NoYXJfZ2V0X2hleF9kaWdpdF9leG5fbm90IiwiaXNfbG93ZXJjYXNlIiwiaXNfdXBwZXJjYXNlIiwiaXNfcHJpbnQiLCJpc193aGl0ZXNwYWNlIiwiaXNfZGlnaXQiLCJpc19hbHBoYSIsImlzX2FscGhhbnVtIiwiZ2V0X2RpZ2l0X3Vuc2FmZSIsImdldF9kaWdpdF9leG4iLCJnZXRfZGlnaXQiLCJpc19oZXhfZGlnaXQiLCJpc19oZXhfZGlnaXRfbG93ZXIiLCJpc19oZXhfZGlnaXRfdXBwZXIiLCJnZXRfaGV4X2RpZ2l0X2V4biIsImdldF9oZXhfZGlnaXQiLCJzeW1ib2wiLCJPIiwiYzEiLCJjMiIsInN0YXRlIiwiZXF1YWwiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiQmFzZV9DaGFyIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvY2hhci5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFB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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURsRDFEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbmluY2x1ZGUgQ2hhcjBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9jaGFyIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2NoYXJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2NoYXIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID0gKGdsb2JhbGl6ZV9jaGFyIDogKHRbQG9jYW1sLmxvY2FsXSkgLT4gdClcbiAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IFN0cmluZy5tYWtlIDEgdFxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgbWF0Y2ggU3RyaW5nLmxlbmd0aCBzIHdpdGhcbiAgICB8IDEgLT4gcy5bMF1cbiAgICB8IF8gLT4gZmFpbHdpdGhmIFwiQ2hhci5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5DaGFyXCJcbiAgZW5kKVxuXG5sZXQgcHAgZm10IGMgPSBTdGRsaWIuRm9ybWF0LmZwcmludGYgZm10IFwiJUNcIiBjXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYWxsID0gQXJyYXkuaW5pdCAyNTYgfmY6dW5zYWZlX29mX2ludCB8PiBBcnJheS50b19saXN0XG5cbmxldCBpc19sb3dlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc191cHBlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19wcmludCA9IGZ1bmN0aW9uXG4gIHwgJyAnIC4uICd+JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3doaXRlc3BhY2UgPSBmdW5jdGlvblxuICB8ICdcXHQnIHwgJ1xcbicgfCAnXFwwMTEnICgqIHZlcnRpY2FsIHRhYiAqKSB8ICdcXDAxMicgKCogZm9ybSBmZWVkICopIHwgJ1xccicgfCAnICcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2FscGhhID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxuKCogV3JpdGluZyB0aGVzZSBvdXQsIGluc3RlYWQgb2YgY2FsbGluZyBbaXNfYWxwaGFdIGFuZCBbaXNfZGlnaXRdLCByZWR1Y2VzXG4gICBydW50aW1lIGJ5IGFwcHJveC4gMzAlICopXG5sZXQgaXNfYWxwaGFudW0gPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGdldF9kaWdpdF91bnNhZmUgdCA9IHRvX2ludCB0IC0gdG9faW50ICcwJ1xuXG5sZXQgZ2V0X2RpZ2l0X2V4biB0ID1cbiAgaWYgaXNfZGlnaXQgdFxuICB0aGVuIGdldF9kaWdpdF91bnNhZmUgdFxuICBlbHNlIGZhaWx3aXRoZiBcIkNoYXIuZ2V0X2RpZ2l0X2V4biAlQzogbm90IGEgZGlnaXRcIiB0ICgpXG47O1xuXG5sZXQgZ2V0X2RpZ2l0IHQgPSBpZiBpc19kaWdpdCB0IHRoZW4gU29tZSAoZ2V0X2RpZ2l0X3Vuc2FmZSB0KSBlbHNlIE5vbmVcblxubGV0IGlzX2hleF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfaGV4X2RpZ2l0X2xvd2VyID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2hleF9kaWdpdF91cHBlciA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfaGV4X2RpZ2l0X2V4biA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICcwJ1xuICB8ICdhJyAuLiAnZicgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnYScgKyAxMFxuICB8ICdBJyAuLiAnRicgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnQScgKyAxMFxuICB8IHQgLT5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIkNoYXIuZ2V0X2hleF9kaWdpdF9leG46IG5vdCBhIGhleGFkZWNpbWFsIGRpZ2l0XCJcbiAgICAgICAgIFsgXCJjaGFyXCIsIHNleHBfb2ZfdCB0IF0pXG47O1xuXG5sZXQgZ2V0X2hleF9kaWdpdCB0ID0gaWYgaXNfaGV4X2RpZ2l0IHQgdGhlbiBTb21lIChnZXRfaGV4X2RpZ2l0X2V4biB0KSBlbHNlIE5vbmVcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgbGV0ICggPj0gKSA9ICggPj0gKVxuICBsZXQgKCA8PSApID0gKCA8PSApXG4gIGxldCAoID0gKSA9ICggPSApXG4gIGxldCAoID4gKSA9ICggPiApXG4gIGxldCAoIDwgKSA9ICggPCApXG4gIGxldCAoIDw+ICkgPSAoIDw+IClcbmVuZFxuXG5tb2R1bGUgQ2FzZWxlc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBjaGFyIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKGNoYXJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9jaGFyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY29tcGFyZSBjMSBjMiA9IGNvbXBhcmUgKGxvd2VyY2FzZSBjMSkgKGxvd2VyY2FzZSBjMilcbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IGhhc2hfZm9sZF9jaGFyIHN0YXRlIChsb3dlcmNhc2UgdClcbiAgICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTczMDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQ2hhciIsIkJhc2VfQnl0ZXMwIiwiQmFzZV9JbXBvcnQwIiwidHJfY3JlYXRlX21hcCIsInRhcmdldCIsInJlcGxhY2VtZW50IiwidHJfbWFwIiwiaSIsImluZGV4IiwibGFzdF9yZXBsYWNlbWVudCIsImZpcnN0X3RhcmdldCIsIkJhc2VfQnl0ZXNfdHIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9ieXRlc190ci5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsY0FBQUMsUUFBQUM7QUFBQUEsUUFBQUMsU0NZZSxpQ0FBQUMsTUFDYjtBQUFBO0FBQUEsS0FDK0MsbUNBQW5CO0FBQUEsZUFBbUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FFbEM7QUFBQTtBQUFBLFNBQWI7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFtRTtBQUFBO0FBQUEsU0FBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQztBQUFBQSxTQUNyRCwwQkFBWjtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUFDO0FBQUFBLE9BRUY7QUFBQTtBQUFBO0FBQUEsT0FFTTtBQUFBO0FBQUEsU0FETjtBQUFBO0FBQUEsV0FDNEQ7QUFBQTtBQUFBLFNBQUFGLE1BQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUMsUUFFOUMsMEJBQVo7QUFBQSxNQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBQUUsZUFVaUI7QUFBQTtBQUFBLE9BQ2dELDhCQUExQjtBQUFBLElBQXRDO0FBQUEsU0FBQUgsSUFDQTtBQUFBO0FBQUEsTUFURDtBQUFBLGlCQUNLO0FBQUE7QUFBQSxpQkFDNEM7QUFBQSxPQUFtQixLQUE1RCwwQkFBNEQsNENBQUFBLE1BRS9EO0FBQUEsaUJBREE7QUFBQTtBQUFBLE1BTXVCO0FBQUEsTUFFekI7QUFBQTtBQUFBO0FBQUEsSUFEQTtBQUFBLEdBQ0k7QUFBQSxPQUFBSSxnQkR2Q1giLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydDAuSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG4oKiBDb25zdHJ1Y3QgYSBieXRlIHN0cmluZyBvZiBsZW5ndGggMjU2LCBtYXBwaW5nIGV2ZXJ5IGlucHV0IGNoYXJhY3RlciBjb2RlIHRvXG4gICBpdHMgY29ycmVzcG9uZGluZyBvdXRwdXQgY2hhcmFjdGVyLlxuXG4gICBCZW5jaG1hcmtzIGluZGljYXRlIHRoYXQgdGhpcyBpcyBmYXN0ZXIgdGhhbiB0aGUgbGFtYmRhIChpbmNsdWRpbmcgY29zdCBvZlxuICAgdGhpcyBmdW5jdGlvbiksIGV2ZW4gaWYgdGFyZ2V0L3JlcGxhY2VtZW50IGFyZSBqdXN0IDIgY2hhcmFjdGVycyBlYWNoLlxuXG4gICBSZXR1cm4gTm9uZSBpZiB0aGUgdHJhbnNsYXRpb24gbWFwIGlzIGVxdWl2YWxlbnQgdG8ganVzdCB0aGUgaWRlbnRpdHkuICopXG5sZXQgdHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGxldCB0cl9tYXAgPSBCeXRlcy5jcmVhdGUgMjU2IGluXG4gIGZvciBpID0gMCB0byAyNTUgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG1pbiAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSAtIDEgZG9cbiAgICBsZXQgaW5kZXggPSBDaGFyLnRvX2ludCAoU3RyaW5nLnVuc2FmZV9nZXQgdGFyZ2V0IGkpIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaW5kZXggKFN0cmluZy51bnNhZmVfZ2V0IHJlcGxhY2VtZW50IGkpXG4gIGRvbmU7XG4gIGxldCBsYXN0X3JlcGxhY2VtZW50ID0gU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQgLSAxKSBpblxuICBmb3JcbiAgICBpID0gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIHRvIFN0cmluZy5sZW5ndGggdGFyZ2V0IC0gMVxuICBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCBsYXN0X3JlcGxhY2VtZW50XG4gIGRvbmU7XG4gIGxldCByZWMgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCBpID1cbiAgICBpZiBpID0gMjU2XG4gICAgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgQ2hhci4oIDw+ICkgKEJ5dGVzMC51bnNhZmVfZ2V0IHRyX21hcCBpKSAoQ2hhci5vZl9pbnRfZXhuIGkpXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIChpICsgMSlcbiAgaW5cbiAgKCogcXVpY2sgY2hlY2sgb24gdGhlIGZpcnN0IHRhcmdldCBjaGFyYWN0ZXIgd2hpY2ggd2lsbCA5OSUgYmUgdHJ1ZSAqKVxuICBsZXQgZmlyc3RfdGFyZ2V0ID0gdGFyZ2V0LlswXSBpblxuICBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBmaXJzdF90YXJnZXQpKSBmaXJzdF90YXJnZXRcbiAgfHwgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCAwXG4gIHRoZW4gU29tZSAoQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dHJfbWFwKVxuICBlbHNlIE5vbmVcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTc0MDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwic3RhZ2UiLCJ1bnN0YWdlIiwiQmFzZV9TdGFnZWQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxNQUFBO0FBQUEsWUFBQUMsUUFBQTtBQUFBLE9BQUFDLGNBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzQxNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfY2FzZV9zZW5zaXRpdmUiLCJjc3RfY2hhciIsImNzdF9lc2NhcGVfY2hhciIsImNzdF9wYXR0ZXJuIiwiY3N0X3BvcyIsImNzdF9zcmNfc3RyaW5nX21sIiwiY3N0X3N0ciIsImNhbWxfYmxpdF9zdHJpbmciLCJjYW1sX2J5dGVzX3NldCIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0NoYXIiLCJCYXNlX0ltcG9ydCIsIkJhc2VfU2V4cCIsIkJhc2VfT3JfZXJyb3IiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfT3B0aW9uIiwiQmFzZV9MaXN0IiwiQmFzZV9CeXRlczAiLCJCYXNlX0FycmF5MCIsIkJhc2VfSW50MCIsIlN0ZGxpYl9Gb3JtYXQiLCJCYXNlX0J5dGVzX3RyIiwiQmFzZV9JbmRleGVkX2NvbnRhaW5lciIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9IYXNoIiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIiwiQmFzZV9TdHJpbmcwIiwiQmFzZV9QcmludGYiLCJCYXNlX0Vycm9yIiwiQmFzZV9TdGFnZWQiLCJCYXNlX0NvbXBhcmF0b3IiLCJCYXNlX0NvbXBhcmFibGUiLCJtYXhfbGVuZ3RoIiwic3ltYm9sX2NvbmNhdCIsImNhcGl0YWxpemUiLCJjb21wYXJlIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsIm1ha2UiLCJ1bmNhcGl0YWxpemUiLCJ1cHBlcmNhc2UiLCJjb25jYXQiLCJpdGVyIiwiaW52YWxpZF9hcmdmIiwicmFpc2VfcyIsInN0YWdlIiwiZ2xvYmFsaXplIiwiaGFzaF9mb2xkX3QiLCJmdW5jIiwiaGFzaCIsIngiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsImhhc2hhYmxlIiwiaW5jbHVkZSIsImNvbXBhcmF0b3IiLCJpbnZhcmlhbnQiLCJwYXJhbSIsInVuc2FmZV9zdWIiLCJzcmMiLCJwb3MiLCJsZW4iLCJkc3QiLCJzdWIiLCJzdWJvIiwib3B0IiwiaSIsImNvbnRhaW5zIiwidCIsImNoYXIiLCJ0b3RhbF9sZW5ndGgiLCJlbmQiLCJpc19lbXB0eSIsImluZGV4X2Zyb21fZXhuX2ludGVybmFsIiwic3RyaW5nIiwibm90X2ZvdW5kIiwiaW5kZXhfZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuIiwiY3N0X1N0cmluZ19pbmRleF9mcm9tX2V4biIsImluZGV4X2Zyb21fZXhuIiwicmluZGV4X2Zyb21fZXhuX2ludGVybmFsIiwicmluZGV4X2V4bl9pbnRlcm5hbCIsInJpbmRleF9leG4iLCJjc3RfU3RyaW5nX3JpbmRleF9mcm9tX2V4biIsImNzdF9zdWJzdHJpbmciLCJjc3RfU3Vic3RyaW5nX25vdF9mb3VuZCIsInJpbmRleF9mcm9tX2V4biIsImluZGV4IiwicmluZGV4IiwiaW5kZXhfZnJvbSIsInJpbmRleF9mcm9tIiwiY2FzZV9zZW5zaXRpdmUiLCJwYXR0ZXJuIiwia21wX2ludGVybmFsX2xvb3AiLCJtYXRjaGVkX2NoYXJzIiwibmV4dF90ZXh0X2NoYXIiLCJrbXBfYXJyYXkiLCJjaGFyX2VxdWFsIiwiZ2V0X2NoYXJfZXF1YWwiLCJjcmVhdGUiLCJuIiwiaW5kZXhfaW50ZXJuYWwiLCJ0ZXh0IiwiaiIsImsiLCJtYXRjaGVzIiwic3RyIiwiaW4iLCJwIiwiaW5kZXhfYWxsIiwibWF5X292ZXJsYXAiLCJmb3VuZCIsInJlcGxhY2VfZmlyc3QiLCJzIiwid2l0aCIsIm1hdGNoIiwibGVuX3MiLCJsZW5fdCIsImxlbl93aXRoIiwicmVwbGFjZV9hbGwiLCJudW1fbWF0Y2hlcyIsIm5leHRfZHN0X3BvcyIsIm5leHRfc3JjX3BvcyIsInNwbGl0X29uIiwicGF0dGVybl9sZW4iLCJlcXVhbCIsImFfMDAzIiwiYl8wMDQiLCJrbXBfYXJyYXlfMDEyIiwiY2FzZV9zZW5zaXRpdmVfMDEwIiwicGF0dGVybl8wMDgiLCJhcmdfMDEzIiwiYm5kc18wMDciLCJhcmdfMDExIiwiYXJnXzAwOSIsInJlcHJlc2VudGF0aW9uIiwiUHJpdmF0ZSIsInN1YnN0cl9pbmRleF9nZW4iLCJzdWJzdHJfaW5kZXhfZXhuX2dlbiIsInN1YnN0cl9pbmRleF9hbGxfZ2VuIiwic3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIiwic3Vic3RyX3JlcGxhY2VfYWxsX2dlbiIsImlzX3N1YnN0cmluZ19nZW4iLCJzdWJzdHJpbmciLCJzdWJzdHJfaW5kZXgiLCJzdWJzdHJfaW5kZXhfZXhuIiwic3Vic3RyX2luZGV4X2FsbCIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0Iiwic3Vic3RyX3JlcGxhY2VfYWxsIiwiaXNfc3Vic3RyaW5nIiwiaXNfc3Vic3RyaW5nX2F0X2dlbiIsInN0cl9wb3MiLCJzdHJfbGVuIiwic3ViX2xlbiIsInN1Yl9wb3MiLCJpc19zdWZmaXhfZ2VuIiwic3VmZml4Iiwic3RyaW5nX2xlbiIsInN1ZmZpeF9sZW4iLCJpc19wcmVmaXhfZ2VuIiwicHJlZml4IiwicHJlZml4X2xlbiIsInN0cmluZzEiLCJzdHJpbmcyIiwibGVuMiIsImxlbjEiLCJjMiIsImMxIiwiYyIsInN0YXRlIiwiaXNfc3VmZml4IiwiaXNfcHJlZml4IiwiaXNfc3Vic3RyaW5nX2F0Iiwic3ltYm9sIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsIm9mX3N0cmluZyIsInRvX3N0cmluZyIsImluaXQiLCJ0b19saXN0IiwiYWNjIiwidG9fbGlzdF9yZXYiLCJyZXYiLCJyZXMiLCJsc3BsaXQyX2V4biIsImxpbmUiLCJkZWxpbSIsImNzdF9leHBlY3Rpbmdfbm9ubmVnYXRpdmVfYXJndSIsImNzdF9kcm9wX3ByZWZpeCIsImNzdF9kcm9wX3N1ZmZpeCIsImNzdF9wcmVmaXgiLCJjc3Rfc3VmZml4IiwiY3N0X3RyX211bHRpX3JlcGxhY2VtZW50X2lzX2VtIiwiY3N0X2VzY2FwZXdvcnRoeV9tYXAiLCJjc3RfY190byIsImNzdF9jX2Zyb20iLCJjc3RfZXNjYXBld29ydGh5X21hcF9ub3Rfb25lX3QiLCJjc3RfaXNfY2hhcl9lc2NhcGluZyIsImNzdF9pc19jaGFyX2VzY2FwZWQiLCJjc3RfaXNfY2hhcl9saXRlcmFsIiwiY3N0X2luZGV4X2Zyb20iLCJjc3RfaW5kZXhfZnJvbV9leG5fbm90X2ZvdW5kIiwiY3N0X3JpbmRleF9mcm9tIiwiY3N0X3JpbmRleF9mcm9tX2V4bl9ub3RfZm91bmQiLCJjc3RfbWF4IiwiY3N0X21pbiIsImNzdF9jbGFtcF9yZXF1aXJlc19taW5fbWF4IiwiZHVtbXkiLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJvbiIsInJzcGxpdDIiLCJjaGFyX2xpc3RfbWVtIiwibCIsInRsIiwiaGQiLCJzcGxpdF9nZW4iLCJpc19kZWxpbSIsImxhc3RfcG9zIiwicG9zMSIsInN1Yl9zdHIiLCJzcGxpdCIsInNwbGl0X29uX2NoYXJzIiwiY2hhcnMiLCJiYWNrX3VwX2F0X25ld2xpbmUiLCJlb2wiLCJzcGxpdF9saW5lcyIsImFjIiwic3RhcnQiLCJ3cmFwX3N1Yl9uIiwibmFtZSIsIm9uX2Vycm9yIiwiZHJvcF9wcmVmaXgiLCJkcm9wX3N1ZmZpeCIsImxmaW5kaSIsImZpbmQiLCJmaW5kX21hcCIsInJmaW5kaSIsImxhc3Rfbm9uX2Ryb3AiLCJkcm9wIiwicnN0cmlwIiwiZmlyc3Rfbm9uX2Ryb3AiLCJsc3RyaXAiLCJzdHJpcCIsImxlbmd0aCIsImZpcnN0IiwibGFzdCIsIm1hcGkiLCJtYXAiLCJ0b19hcnJheSIsImV4aXN0cyIsImZvcl9hbGwiLCJmb2xkIiwiZm9sZGkiLCJpdGVyaSIsImNvdW50Iiwic3VtIiwibSIsIm1pbl9lbHQiLCJtYXhfZWx0IiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZmluaXNoIiwiZmluZF9tYXBpIiwiZmluZGkiLCJjb3VudGkiLCJmb3JfYWxsaSIsImV4aXN0c2kiLCJtZW0iLCJ0ciIsInRhcmdldCIsInJlcGxhY2VtZW50IiwidHJfbXVsdGkiLCJ0cl9tYXAiLCJjb25jYXRfYXJyYXkiLCJzZXAiLCJhciIsImNvbmNhdF9tYXAiLCJjb25jYXRfbWFwaSIsImNvbmNhdF9saW5lcyIsImxpbmVzIiwiY3JsZiIsIm5ld2xpbmVfbGVuIiwiYnVmIiwid3JpdHRlbiIsImZpbHRlciIsIm91dCIsIm91dF9wb3MiLCJmaWx0ZXJpIiwiY2hvcF9wcmVmaXgiLCJjaG9wX3ByZWZpeF9pZl9leGlzdHMiLCJjaG9wX3ByZWZpeF9leG4iLCJjaG9wX3N1ZmZpeCIsImNob3Bfc3VmZml4X2lmX2V4aXN0cyIsImNob3Bfc3VmZml4X2V4biIsInNob3J0ZXIiLCJhIiwiYiIsInNob3J0ZXN0IiwibGlzdCIsInJlc3QiLCJwb3NfZnJvbV9sZWZ0IiwicG9zX2Zyb21fcmlnaHQiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AiLCJnZXRfcG9zIiwibWF4X2xlbiIsImxlbl9zb19mYXIiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AiLCJzZWNvbmQiLCJjb21tb25fZ2VuZXJpY19sZW5ndGgiLCJjb21tb25fZ2VuZXJpYzIiLCJ0YWtlIiwiY29tbW9uX2dlbmVyaWMiLCJjb21tb25fcHJlZml4IiwiY29tbW9uX3N1ZmZpeCIsImNvbW1vbl9wcmVmaXgyIiwiY29tbW9uX3N1ZmZpeDIiLCJjb21tb25fcHJlZml4X2xlbmd0aCIsImNvbW1vbl9zdWZmaXhfbGVuZ3RoIiwiY29tbW9uX3ByZWZpeDJfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIiwicHAiLCJwcGYiLCJvZl9jaGFyIiwib2ZfY2hhcl9saXN0Iiwib2ZfYXJyYXkiLCJwYWRfcmlnaHQiLCJzcmNfbGVuIiwicGFkX2xlZnQiLCJsb2NhbF9jb3B5X3ByZWZpeCIsImJ1ZmZlcl9sZW4iLCJsb2NhbF9jb3B5X3RvX3N0cmluZyIsImZpbHRlcl9tYXBpIiwic3JjX3BvcyIsIm9wdGlvbiIsImNvcHkiLCJkc3RfcG9zIiwiZmlsdGVyX21hcCIsInBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZSIsImZzdF9wb3MiLCJzbmRfcG9zIiwiZWl0aGVyIiwiZnN0cyIsInNuZHMiLCJwYXJ0aXRpb25fbWFwIiwicGFydGl0aW9uX3RmIiwiYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoIiwiZXNjYXBld29ydGh5X21hcCIsImVzY2FwZV9jaGFyIiwiYXJyIiwidmFscyIsImNfdG8iLCJjX2Zyb20iLCJ2IiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJ0b19lc2NhcGUiLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsImVzY2FwZWRfY2hhciIsImVzY2FwZV9nZW5fZXhuIiwiZXNjYXBlIiwidW5lc2NhcGVfZ2VuIiwic3RhdHVzIiwidG9fdW5lc2NhcGUiLCJpZHgiLCJsb29wIiwidW5lc2NhcGVfZ2VuX2V4biIsInVuZXNjYXBlIiwicHJlY2VkaW5nX2VzY2FwZV9jaGFycyIsImNudCIsInVwZGF0ZV9lc2NhcGVfc3RhdHVzIiwiZXNjYXBlX3N0YXR1cyIsIm9kZCIsImNoZWNrX2JvdW5kIiwiZnVuY3Rpb25fbmFtZSIsImlzX2NoYXJfZXNjYXBpbmciLCJpc19jaGFyX2VzY2FwZWQiLCJpc19jaGFyX2xpdGVyYWwiLCJlc2NhcGVfY2hhcnMiLCJzcGxpdF9hdCIsImxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCIsImZpcnN0X25vbl9kcm9wX2xpdGVyYWwiLCJyc3RyaXBfbGl0ZXJhbCIsImxzdHJpcF9saXRlcmFsIiwic3RyaXBfbGl0ZXJhbCIsImxvdyIsImhpZ2giLCJjbGFtcF91bmNoZWNrZWQiLCJCYXNlX1N0cmluZyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL3N0cmluZy5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUE5QixTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FB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LFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFHLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQS9JLFlBQUE7QUFBQSxJQUFBMkYsVUFBQTtBQUFBLElBQUFrRCxRQUFBO0FBQUEsSUFBQUQsUUFBQTtBQUFBLElBQUE4TjtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEbjZCRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIEludCA9IEludDBcbmluY2x1ZGUgU3RyaW5nMFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5sZXQgc3RhZ2UgPSBTdGFnZWQuc3RhZ2VcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID0gKGdsb2JhbGl6ZV9zdHJpbmcgOiAodFtAb2NhbWwubG9jYWxdKSAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfc3RyaW5nXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9zdHJpbmcgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKHN0cmluZ19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9zdHJpbmcgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gc3RyaW5nX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG50eXBlIGVsdCA9IGNoYXJcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcblxuKCogVGhpcyBpcyBjb3BpZWQvYWRhcHRlZCBmcm9tICdibGl0Lm1sJy5cbiAgIFtzdWJdLCBbc3Vib10gY291bGQgYmUgaW1wbGVtZW50ZWQgdXNpbmcgW0JsaXQuTWFrZShCeXRlcyldIHBsdXMgdW5zYWZlIGNhc3RzIHRvL2Zyb21cbiAgIHN0cmluZyBidXQgd2VyZSBpbmxpbmVkIGhlcmUgdG8gYXZvaWQgdXNpbmcgW0J5dGVzLnVuc2FmZV9vZl9zdHJpbmddIGFzIG11Y2ggYXMgcG9zc2libGUuXG4qKVxubGV0IHVuc2FmZV9zdWIgc3JjIH5wb3MgfmxlbiA9XG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBcIlwiXG4gIGVsc2UgKFxuICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6cG9zIH5kc3QgfmRzdF9wb3M6MCB+bGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KVxuOztcblxubGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgaWYgcG9zID0gMCAmJiBsZW4gPSBTdHJpbmcubGVuZ3RoIHNyY1xuICB0aGVuIHNyY1xuICBlbHNlIChcbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggc3JjKTtcbiAgICB1bnNhZmVfc3ViIHNyYyB+cG9zIH5sZW4pXG47O1xuXG5sZXQgc3VibyA/KHBvcyA9IDApID9sZW4gc3JjID1cbiAgc3ViXG4gICAgc3JjXG4gICAgfnBvc1xuICAgIH5sZW46XG4gICAgICAobWF0Y2ggbGVuIHdpdGhcbiAgICAgICB8IFNvbWUgaSAtPiBpXG4gICAgICAgfCBOb25lIC0+IGxlbmd0aCBzcmMgLSBwb3MpXG47O1xuXG5sZXQgcmVjIGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3MgfmVuZF8gY2hhciA9XG4gIHBvcyA8IGVuZF9cbiAgJiYgKENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgdCBwb3MpIGNoYXIgfHwgY29udGFpbnNfdW5zYWZlIHQgfnBvczoocG9zICsgMSkgfmVuZF8gY2hhcilcbjs7XG5cbmxldCBjb250YWlucyA/KHBvcyA9IDApID9sZW4gdCBjaGFyID1cbiAgbGV0IHRvdGFsX2xlbmd0aCA9IFN0cmluZy5sZW5ndGggdCBpblxuICBsZXQgbGVuID0gT3B0aW9uLnZhbHVlIGxlbiB+ZGVmYXVsdDoodG90YWxfbGVuZ3RoIC0gcG9zKSBpblxuICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoO1xuICBjb250YWluc191bnNhZmUgdCB+cG9zIH5lbmRfOihwb3MgKyBsZW4pIGNoYXJcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCByZWMgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXIgPVxuICBpZiBwb3MgPj0gbGVuXG4gIHRoZW4gcmFpc2Ugbm90X2ZvdW5kXG4gIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gIHRoZW4gcG9zXG4gIGVsc2UgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3M6KHBvcyArIDEpIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyID1cbiAgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zOjAgfmxlbjoobGVuZ3RoIHQpIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IGluZGV4X2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5pbmRleF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgaW5kZXhfZXhuIHQgY2hhciA9IGluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGluZGV4X2V4blxuOztcblxubGV0IGluZGV4X2Zyb21fZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IDAgfHwgcG9zID4gbGVuXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBpbmRleF9mcm9tX2V4blxuOztcblxubGV0IHJlYyByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXIgPVxuICBpZiBwb3MgPCAwXG4gIHRoZW4gcmFpc2Ugbm90X2ZvdW5kXG4gIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gIHRoZW4gcG9zXG4gIGVsc2UgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHN0cmluZyB+cG9zOihwb3MgLSAxKSB+bGVuIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IHJpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvczoobGVuIC0gMSkgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCByaW5kZXhfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmluZGV4X2V4biB0IGNoYXIgPSByaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcmluZGV4X2V4blxuOztcblxubGV0IHJpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5yaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IC0xIHx8IHBvcyA+PSBsZW5cbiAgICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcmluZGV4X2Zyb21fZXhuXG47O1xuXG5sZXQgaW5kZXggdCBjaGFyID1cbiAgdHJ5IFNvbWUgKGluZGV4X2V4biB0IGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmluZGV4IHQgY2hhciA9XG4gIHRyeSBTb21lIChyaW5kZXhfZXhuIHQgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBTdGRsaWIuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCBpbmRleF9mcm9tIHQgcG9zIGNoYXIgPVxuICB0cnkgU29tZSAoaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBTdGRsaWIuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCByaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgdHJ5IFNvbWUgKHJpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuMCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcGF0dGVybiA6IHN0cmluZ1xuICAgIDsgY2FzZV9zZW5zaXRpdmUgOiBib29sXG4gICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICB9XG5cbiAgbGV0IHNleHBfb2ZfdCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgPSBfIH0gOiBTZXhwLnQgPVxuICAgIExpc3RcbiAgICAgIFsgTGlzdCBbIEF0b20gXCJwYXR0ZXJuXCI7IHNleHBfb2Zfc3RyaW5nIHBhdHRlcm4gXVxuICAgICAgOyBMaXN0IFsgQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IHNleHBfb2ZfYm9vbCBjYXNlX3NlbnNpdGl2ZSBdXG4gICAgICBdXG4gIDs7XG5cbiAgbGV0IHBhdHRlcm4gdCA9IHQucGF0dGVyblxuICBsZXQgY2FzZV9zZW5zaXRpdmUgdCA9IHQuY2FzZV9zZW5zaXRpdmVcblxuICAoKiBGaW5kIG1heCBudW1iZXIgb2YgbWF0Y2hlZCBjaGFyYWN0ZXJzIGF0IFtuZXh0X3RleHRfY2hhcl0sIGdpdmVuIHRoZSBjdXJyZW50XG4gICAgIFttYXRjaGVkX2NoYXJzXS4gVHJ5IHRvIGV4dGVuZCB0aGUgY3VycmVudCBtYXRjaCwgaWYgY2hhcnMgZG9uJ3QgbWF0Y2gsIHRyeSB0byBtYXRjaFxuICAgICBmZXdlciBjaGFycy4gSWYgY2hhcnMgbWF0Y2ggdGhlbiBleHRlbmQgdGhlIG1hdGNoLiAqKVxuICBsZXQga21wX2ludGVybmFsX2xvb3Agfm1hdGNoZWRfY2hhcnMgfm5leHRfdGV4dF9jaGFyIH5wYXR0ZXJuIH5rbXBfYXJyYXkgfmNoYXJfZXF1YWwgPVxuICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIG1hdGNoZWRfY2hhcnMgaW5cbiAgICB3aGlsZVxuICAgICAgIW1hdGNoZWRfY2hhcnMgPiAwXG4gICAgICAmJiBub3QgKGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycykpXG4gICAgZG9cbiAgICAgIG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKCFtYXRjaGVkX2NoYXJzIC0gMSlcbiAgICBkb25lO1xuICAgIGlmIGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycylcbiAgICB0aGVuIG1hdGNoZWRfY2hhcnMgOj0gIW1hdGNoZWRfY2hhcnMgKyAxO1xuICAgICFtYXRjaGVkX2NoYXJzXG4gIDs7XG5cbiAgbGV0IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbWF0Y2ggY2FzZV9zZW5zaXRpdmUgd2l0aFxuICAgIHwgdHJ1ZSAtPiBDaGFyLmVxdWFsXG4gICAgfCBmYWxzZSAtPiBDaGFyLkNhc2VsZXNzLmVxdWFsXG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVAgcHJlLXByb2Nlc3Npbmcgb2YgdGhlIHBhdHRlcm46IGJ1aWxkIHRoZSBpbnQgYXJyYXksIHdoaWNoLCBmb3IgZWFjaCBpLFxuICAgICBjb250YWlucyB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IG5vbi10cml2aWFsIHByZWZpeCBvZiBzIHdoaWNoIGlzIGVxdWFsIHRvIGEgc3VmZml4XG4gICAgIGVuZGluZyBhdCBzLltpXSAqKVxuICBsZXQgY3JlYXRlIHBhdHRlcm4gfmNhc2Vfc2Vuc2l0aXZlID1cbiAgICBsZXQgbiA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgbGV0IGttcF9hcnJheSA9IEFycmF5LmNyZWF0ZSB+bGVuOm4gKC0xKSBpblxuICAgIGlmIG4gPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgQXJyYXkudW5zYWZlX3NldCBrbXBfYXJyYXkgMCAwO1xuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhcjoodW5zYWZlX2dldCBwYXR0ZXJuIGkpXG4gICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IGkgIW1hdGNoZWRfY2hhcnNcbiAgICAgIGRvbmUpO1xuICAgIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9XG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVA6IHVzZSB0aGUgcHJlLXByb2Nlc3NlZCBwYXR0ZXJuIHRvIG9wdGltaXplIGxvb2stYmVoaW5kcyBvbiBub24tbWF0Y2hlcy5cbiAgICAgV2UgcmV0dXJuIGludCB0byBhdm9pZCBhbGxvY2F0aW9uIGluIFtpbmRleF9leG5dLiAtMSBtZWFucyBubyBtYXRjaC4gKilcbiAgbGV0IGluZGV4X2ludGVybmFsID8ocG9zID0gMCkgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH0gfmluXzp0ZXh0ID1cbiAgICBpZiBwb3MgPCAwIHx8IHBvcyA+IGxlbmd0aCB0ZXh0IC0gbGVuZ3RoIHBhdHRlcm5cbiAgICB0aGVuIC0xXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IGogPSByZWYgcG9zIGluXG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBsZXQgayA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgICBsZXQgbiA9IGxlbmd0aCB0ZXh0IGluXG4gICAgICB3aGlsZSAhaiA8IG4gJiYgIW1hdGNoZWRfY2hhcnMgPCBrIGRvXG4gICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCAhaiBpblxuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICB+Y2hhcl9lcXVhbDtcbiAgICAgICAgaiA6PSAhaiArIDFcbiAgICAgIGRvbmU7XG4gICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGsgdGhlbiAhaiAtIGsgZWxzZSAtMSlcbiAgOztcblxuICBsZXQgbWF0Y2hlcyB0IHN0ciA9IGluZGV4X2ludGVybmFsIHQgfmluXzpzdHIgPj0gMFxuXG4gIGxldCBpbmRleCA/cG9zIHQgfmluXyA9XG4gICAgbGV0IHAgPSBpbmRleF9pbnRlcm5hbCA/cG9zIHQgfmluXyBpblxuICAgIGlmIHAgPCAwIHRoZW4gTm9uZSBlbHNlIFNvbWUgcFxuICA7O1xuXG4gIGxldCBpbmRleF9leG4gP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwID49IDBcbiAgICB0aGVuIHBcbiAgICBlbHNlXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJTdWJzdHJpbmcgbm90IGZvdW5kXCIgWyBcInN1YnN0cmluZ1wiLCBzZXhwX29mX3N0cmluZyB0LnBhdHRlcm4gXSlcbiAgOztcblxuICBsZXQgaW5kZXhfYWxsIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5tYXlfb3ZlcmxhcCB+aW5fOnRleHQgPVxuICAgIGlmIGxlbmd0aCBwYXR0ZXJuID0gMFxuICAgIHRoZW4gTGlzdC5pbml0ICgxICsgbGVuZ3RoIHRleHQpIH5mOkZuLmlkXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgbGV0IGZvdW5kID0gcmVmIFtdIGluXG4gICAgICBmb3IgaiA9IDAgdG8gbiBkb1xuICAgICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGtcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgZm91bmQgOj0gKGogLSBrKSA6OiAhZm91bmQ7XG4gICAgICAgICAgKCogd2UganVzdCBmb3VuZCBhIG1hdGNoIGluIHRoZSBwcmV2aW91cyBpdGVyYXRpb24gKilcbiAgICAgICAgICBtYXRjaCBtYXlfb3ZlcmxhcCB3aXRoXG4gICAgICAgICAgfCB0cnVlIC0+IG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKGsgLSAxKVxuICAgICAgICAgIHwgZmFsc2UgLT4gbWF0Y2hlZF9jaGFycyA6PSAwKTtcbiAgICAgICAgaWYgaiA8IG5cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IG5leHRfdGV4dF9jaGFyID0gdW5zYWZlX2dldCB0ZXh0IGogaW5cbiAgICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgICB+Y2hhcl9lcXVhbClcbiAgICAgIGRvbmU7XG4gICAgICBMaXN0LnJldiAhZm91bmQpXG4gIDs7XG5cbiAgbGV0IHJlcGxhY2VfZmlyc3QgP3BvcyB0IH5pbl86cyB+d2l0aF8gPVxuICAgIG1hdGNoIGluZGV4ID9wb3MgdCB+aW5fOnMgd2l0aFxuICAgIHwgTm9uZSAtPiBzXG4gICAgfCBTb21lIGkgLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgbGVuX3dpdGggLSBsZW5fdCkgaW5cbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmk7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOndpdGhfIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczppIH5sZW46bGVuX3dpdGg7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOnNcbiAgICAgICAgfnNyY19wb3M6KGkgKyBsZW5fdClcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczooaSArIGxlbl93aXRoKVxuICAgICAgICB+bGVuOihsZW5fcyAtIGkgLSBsZW5fdCk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG5cbiAgbGV0IHJlcGxhY2VfYWxsIHQgfmluXzpzIH53aXRoXyA9XG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgbWF0Y2ggbWF0Y2hlcyB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCBfIDo6IF8gLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBudW1fbWF0Y2hlcyA9IExpc3QubGVuZ3RoIG1hdGNoZXMgaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgKChsZW5fd2l0aCAtIGxlbl90KSAqIG51bV9tYXRjaGVzKSkgaW5cbiAgICAgIGxldCBuZXh0X2RzdF9wb3MgPSByZWYgMCBpblxuICAgICAgbGV0IG5leHRfc3JjX3BvcyA9IHJlZiAwIGluXG4gICAgICBMaXN0Lml0ZXIgbWF0Y2hlcyB+ZjooZnVuIGkgLT5cbiAgICAgICAgbGV0IGxlbiA9IGkgLSAhbmV4dF9zcmNfcG9zIGluXG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczohbmV4dF9zcmNfcG9zIH5kc3QgfmRzdF9wb3M6IW5leHRfZHN0X3BvcyB+bGVuO1xuICAgICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICAgIH5zcmM6d2l0aF9cbiAgICAgICAgICB+c3JjX3BvczowXG4gICAgICAgICAgfmRzdFxuICAgICAgICAgIH5kc3RfcG9zOighbmV4dF9kc3RfcG9zICsgbGVuKVxuICAgICAgICAgIH5sZW46bGVuX3dpdGg7XG4gICAgICAgIG5leHRfZHN0X3BvcyA6PSAhbmV4dF9kc3RfcG9zICsgbGVuICsgbGVuX3dpdGg7XG4gICAgICAgIG5leHRfc3JjX3BvcyA6PSAhbmV4dF9zcmNfcG9zICsgbGVuICsgbGVuX3QpO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOiFuZXh0X3NyY19wb3NcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczohbmV4dF9kc3RfcG9zXG4gICAgICAgIH5sZW46KGxlbl9zIC0gIW5leHRfc3JjX3Bvcyk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG4gIGxldCBzcGxpdF9vbiB0IHMgPVxuICAgIGxldCBwYXR0ZXJuX2xlbiA9IFN0cmluZy5sZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgTGlzdC5tYXAyX2V4blxuICAgICAgKC1wYXR0ZXJuX2xlbiA6OiBtYXRjaGVzKVxuICAgICAgKG1hdGNoZXMgQCBbIFN0cmluZy5sZW5ndGggcyBdKVxuICAgICAgfmY6KGZ1biBpIGogLT4gc3ViIHMgfnBvczooaSArIHBhdHRlcm5fbGVuKSB+bGVuOihqIC0gaSAtIHBhdHRlcm5fbGVuKSlcbiAgOztcblxuICBtb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgcHVibGljID0gdFxuXG4gICAgdHlwZSBub25yZWMgdCA9IHQgPVxuICAgICAgeyBwYXR0ZXJuIDogc3RyaW5nXG4gICAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICBsZXQgZXF1YWwgPVxuICAgICAgKGZ1biBhX18wMDNfIGJfXzAwNF8gLT5cbiAgICAgICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDAzXyBiX18wMDRfXG4gICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgIGVsc2VcbiAgICAgICAgICAgU3RkbGliLiggJiYgKVxuICAgICAgICAgICAgIChlcXVhbF9zdHJpbmcgYV9fMDAzXy5wYXR0ZXJuIGJfXzAwNF8ucGF0dGVybilcbiAgICAgICAgICAgICAoU3RkbGliLiggJiYgKVxuICAgICAgICAgICAgICAgIChlcXVhbF9ib29sIGFfXzAwM18uY2FzZV9zZW5zaXRpdmUgYl9fMDA0Xy5jYXNlX3NlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICAoZXF1YWxfYXJyYXkgZXF1YWxfaW50IGFfXzAwM18ua21wX2FycmF5IGJfXzAwNF8ua21wX2FycmF5KSlcbiAgICAgICAgICAgOiB0IC0+IHQgLT4gYm9vbClcbiAgICA7O1xuXG4gICAgbGV0IHNleHBfb2ZfdCA9XG4gICAgICAoZnVuIHsgcGF0dGVybiA9IHBhdHRlcm5fXzAwOF9cbiAgICAgICAgICAgOyBjYXNlX3NlbnNpdGl2ZSA9IGNhc2Vfc2Vuc2l0aXZlX18wMTBfXG4gICAgICAgICAgIDsga21wX2FycmF5ID0ga21wX2FycmF5X18wMTJfXG4gICAgICAgICAgIH0gLT5cbiAgICAgICAgbGV0IGJuZHNfXzAwN18gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gICAgICAgIGxldCBibmRzX18wMDdfID1cbiAgICAgICAgICBsZXQgYXJnX18wMTNfID0gc2V4cF9vZl9hcnJheSBzZXhwX29mX2ludCBrbXBfYXJyYXlfXzAxMl8gaW5cbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwia21wX2FycmF5XCI7IGFyZ19fMDEzXyBdIDo6IGJuZHNfXzAwN19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDdfID1cbiAgICAgICAgICBsZXQgYXJnX18wMTFfID0gc2V4cF9vZl9ib29sIGNhc2Vfc2Vuc2l0aXZlX18wMTBfIGluXG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IGFyZ19fMDExXyBdXG4gICAgICAgICAgIDo6IGJuZHNfXzAwN19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDdfID1cbiAgICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9zdHJpbmcgcGF0dGVybl9fMDA4XyBpblxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwYXR0ZXJuXCI7IGFyZ19fMDA5XyBdIDo6IGJuZHNfXzAwN19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDdfXG4gICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgcmVwcmVzZW50YXRpb24gPSBGbi5pZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm5faGVscGVyID0gc3RydWN0XG4gIG1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IFNlYXJjaF9wYXR0ZXJuMFxuZW5kXG5cbm9wZW4gU2VhcmNoX3BhdHRlcm5faGVscGVyXG5cbmxldCBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleCA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleF9leG4gP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+bWF5X292ZXJsYXAgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleF9hbGxcbiAgICAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKVxuICAgIH5tYXlfb3ZlcmxhcFxuICAgIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4ucmVwbGFjZV9maXJzdCA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5yZXBsYWNlX2FsbCAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5zdWJzdHJpbmcgPVxuICBPcHRpb24uaXNfc29tZSAoc3Vic3RyX2luZGV4X2dlbiB0IH5wYXR0ZXJuOnN1YnN0cmluZyB+Y2FzZV9zZW5zaXRpdmUpXG47O1xuXG5sZXQgc3Vic3RyX2luZGV4ID0gc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9pbmRleF9leG4gPSBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9pbmRleF9hbGwgPSBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0ID0gc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX3JlcGxhY2VfYWxsID0gc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IGlzX3N1YnN0cmluZyA9IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcblxubGV0IGlzX3N1YnN0cmluZ19hdF9nZW4gPVxuICBsZXQgcmVjIGxvb3AgfnN0ciB+c3RyX3BvcyB+c3ViIH5zdWJfcG9zIH5zdWJfbGVuIH5jaGFyX2VxdWFsID1cbiAgICBpZiBzdWJfcG9zID0gc3ViX2xlblxuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgY2hhcl9lcXVhbCAodW5zYWZlX2dldCBzdHIgc3RyX3BvcykgKHVuc2FmZV9nZXQgc3ViIHN1Yl9wb3MpXG4gICAgdGhlbiBsb29wIH5zdHIgfnN0cl9wb3M6KHN0cl9wb3MgKyAxKSB+c3ViIH5zdWJfcG9zOihzdWJfcG9zICsgMSkgfnN1Yl9sZW4gfmNoYXJfZXF1YWxcbiAgICBlbHNlIGZhbHNlXG4gIGluXG4gIGZ1biBzdHIgfnBvczpzdHJfcG9zIH5zdWJzdHJpbmc6c3ViIH5jaGFyX2VxdWFsIC0+XG4gICAgbGV0IHN0cl9sZW4gPSBsZW5ndGggc3RyIGluXG4gICAgbGV0IHN1Yl9sZW4gPSBsZW5ndGggc3ViIGluXG4gICAgaWYgc3RyX3BvcyA8IDAgfHwgc3RyX3BvcyA+IHN0cl9sZW5cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJTdHJpbmcuaXNfc3Vic3RyaW5nX2F0OiBpbnZhbGlkIGluZGV4ICVkIGZvciBzdHJpbmcgb2YgbGVuZ3RoICVkXCJcbiAgICAgICAgc3RyX3Bvc1xuICAgICAgICBzdHJfbGVuXG4gICAgICAgICgpO1xuICAgIHN0cl9wb3MgKyBzdWJfbGVuIDw9IHN0cl9sZW5cbiAgICAmJiBsb29wIH5zdHIgfnN0cl9wb3MgfnN1YiB+c3ViX3BvczowIH5zdWJfbGVuIH5jaGFyX2VxdWFsXG47O1xuXG5sZXQgaXNfc3VmZml4X2dlbiBzdHJpbmcgfnN1ZmZpeCB+Y2hhcl9lcXVhbCA9XG4gIGxldCBzdHJpbmdfbGVuID0gbGVuZ3RoIHN0cmluZyBpblxuICBsZXQgc3VmZml4X2xlbiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgc3RyaW5nX2xlbiA+PSBzdWZmaXhfbGVuXG4gICYmIGlzX3N1YnN0cmluZ19hdF9nZW5cbiAgICAgICBzdHJpbmdcbiAgICAgICB+cG9zOihzdHJpbmdfbGVuIC0gc3VmZml4X2xlbilcbiAgICAgICB+c3Vic3RyaW5nOnN1ZmZpeFxuICAgICAgIH5jaGFyX2VxdWFsXG47O1xuXG5sZXQgaXNfcHJlZml4X2dlbiBzdHJpbmcgfnByZWZpeCB+Y2hhcl9lcXVhbCA9XG4gIGxldCBzdHJpbmdfbGVuID0gbGVuZ3RoIHN0cmluZyBpblxuICBsZXQgcHJlZml4X2xlbiA9IGxlbmd0aCBwcmVmaXggaW5cbiAgc3RyaW5nX2xlbiA+PSBwcmVmaXhfbGVuXG4gICYmIGlzX3N1YnN0cmluZ19hdF9nZW4gc3RyaW5nIH5wb3M6MCB+c3Vic3RyaW5nOnByZWZpeCB+Y2hhcl9lcXVhbFxuOztcblxubW9kdWxlIENhc2VsZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKHN0cmluZ19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3N0cmluZyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY2hhcl9jb21wYXJlX2Nhc2VsZXNzIGMxIGMyID0gQ2hhci5jb21wYXJlIChDaGFyLmxvd2VyY2FzZSBjMSkgKENoYXIubG93ZXJjYXNlIGMyKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2xvb3AgfnBvcyB+c3RyaW5nMSB+bGVuMSB+c3RyaW5nMiB+bGVuMiA9XG4gICAgICBpZiBwb3MgPSBsZW4xXG4gICAgICB0aGVuIGlmIHBvcyA9IGxlbjIgdGhlbiAwIGVsc2UgLTFcbiAgICAgIGVsc2UgaWYgcG9zID0gbGVuMlxuICAgICAgdGhlbiAxXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMgPSBjaGFyX2NvbXBhcmVfY2FzZWxlc3MgKHVuc2FmZV9nZXQgc3RyaW5nMSBwb3MpICh1bnNhZmVfZ2V0IHN0cmluZzIgcG9zKSBpblxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAwIC0+IGNvbXBhcmVfbG9vcCB+cG9zOihwb3MgKyAxKSB+c3RyaW5nMSB+bGVuMSB+c3RyaW5nMiB+bGVuMlxuICAgICAgICB8IF8gLT4gYylcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgc3RyaW5nMSBzdHJpbmcyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgc3RyaW5nMSBzdHJpbmcyXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgY29tcGFyZV9sb29wXG4gICAgICAgICAgfnBvczowXG4gICAgICAgICAgfnN0cmluZzFcbiAgICAgICAgICB+bGVuMTooU3RyaW5nLmxlbmd0aCBzdHJpbmcxKVxuICAgICAgICAgIH5zdHJpbmcyXG4gICAgICAgICAgfmxlbjI6KFN0cmluZy5sZW5ndGggc3RyaW5nMilcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPVxuICAgICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgICBsZXQgc3RhdGUgPSByZWYgKGhhc2hfZm9sZF9pbnQgc3RhdGUgbGVuKSBpblxuICAgICAgZm9yIHBvcyA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBzdGF0ZSA6PSBoYXNoX2ZvbGRfY2hhciAhc3RhdGUgKENoYXIubG93ZXJjYXNlICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgICAgIGRvbmU7XG4gICAgICAhc3RhdGVcbiAgICA7O1xuXG4gICAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgICBsZXQgaXNfc3VmZml4IHMgfnN1ZmZpeCA9IGlzX3N1ZmZpeF9nZW4gcyB+c3VmZml4IH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgICBsZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgICBsZXQgc3Vic3RyX2luZGV4ID0gc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX2luZGV4X2V4biA9IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfaW5kZXhfYWxsID0gc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0ID0gc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfcmVwbGFjZV9hbGwgPSBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBpc19zdWJzdHJpbmcgPSBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBpc19zdWJzdHJpbmdfYXQgPSBpc19zdWJzdHJpbmdfYXRfZ2VuIH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgPSBGbi5pZFxubGV0IHRvX3N0cmluZyA9IEZuLmlkXG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIlN0cmluZy5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICBCeXRlcy5zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dFxuOztcblxubGV0IHRvX2xpc3QgcyA9XG4gIGxldCByZWMgbG9vcCBhY2MgaSA9IGlmIGkgPCAwIHRoZW4gYWNjIGVsc2UgbG9vcCAocy5baV0gOjogYWNjKSAoaSAtIDEpIGluXG4gIGxvb3AgW10gKGxlbmd0aCBzIC0gMSlcbjs7XG5cbmxldCB0b19saXN0X3JldiBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBhY2MgaSA9IGlmIGkgPSBsZW4gdGhlbiBhY2MgZWxzZSBsb29wIChzLltpXSA6OiBhY2MpIChpICsgMSkgaW5cbiAgbG9vcCBbXSAwXG47O1xuXG5sZXQgcmV2IHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyBpICh1bnNhZmVfZ2V0IHQgKGxlbiAtIDEgLSBpKSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpyZXNcbjs7XG5cbigqKiBFZmZpY2llbnQgc3RyaW5nIHNwbGl0dGluZyAqKVxuXG5sZXQgbHNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcubHNwbGl0Ml9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgbHNwbGl0Ml9leG4gbGluZSB+b246ZGVsaW0gPVxuICAgIGxldCBwb3MgPSBpbmRleF9leG5faW50ZXJuYWwgbGluZSB+bm90X2ZvdW5kIGRlbGltIGluXG4gICAgc3ViIGxpbmUgfnBvczowIH5sZW46cG9zLCBzdWIgbGluZSB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggbGluZSAtIHBvcyAtIDEpXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgbHNwbGl0Ml9leG5cbjs7XG5cbmxldCByc3BsaXQyX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5yc3BsaXQyX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByc3BsaXQyX2V4biBsaW5lIH5vbjpkZWxpbSA9XG4gICAgbGV0IHBvcyA9IHJpbmRleF9leG5faW50ZXJuYWwgbGluZSB+bm90X2ZvdW5kIGRlbGltIGluXG4gICAgc3ViIGxpbmUgfnBvczowIH5sZW46cG9zLCBzdWIgbGluZSB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggbGluZSAtIHBvcyAtIDEpXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcnNwbGl0Ml9leG5cbjs7XG5cbmxldCBsc3BsaXQyIGxpbmUgfm9uID1cbiAgdHJ5IFNvbWUgKGxzcGxpdDJfZXhuIGxpbmUgfm9uKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJzcGxpdDIgbGluZSB+b24gPVxuICB0cnkgU29tZSAocnNwbGl0Ml9leG4gbGluZSB+b24pIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNoYXJfbGlzdF9tZW0gbCAoYyA6IGNoYXIpID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCBoZCA6OiB0bCAtPiBDaGFyLmVxdWFsIGhkIGMgfHwgY2hhcl9saXN0X21lbSB0bCBjXG47O1xuXG5sZXQgc3BsaXRfZ2VuIHN0ciB+b24gPVxuICBsZXQgaXNfZGVsaW0gPVxuICAgIG1hdGNoIG9uIHdpdGhcbiAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gIGxldCByZWMgbG9vcCBhY2MgbGFzdF9wb3MgcG9zID1cbiAgICBpZiBwb3MgPSAtMVxuICAgIHRoZW4gc3ViIHN0ciB+cG9zOjAgfmxlbjpsYXN0X3BvcyA6OiBhY2NcbiAgICBlbHNlIGlmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvczEgPSBwb3MgKyAxIGluXG4gICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpwb3MxIH5sZW46KGxhc3RfcG9zIC0gcG9zMSkgaW5cbiAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBwb3MgKHBvcyAtIDEpKVxuICAgIGVsc2UgbG9vcCBhY2MgbGFzdF9wb3MgKHBvcyAtIDEpXG4gIGluXG4gIGxvb3AgW10gbGVuIChsZW4gLSAxKVxuOztcblxubGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG5sZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG5sZXQgc3BsaXRfbGluZXMgPVxuICBsZXQgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbCA9XG4gICAgcG9zIDo9ICFwb3MgLSBpZiAhcG9zID4gMCAmJiBDaGFyLmVxdWFsIHQuWyFwb3MgLSAxXSAnXFxyJyB0aGVuIDIgZWxzZSAxO1xuICAgIGVvbCA6PSAhcG9zICsgMVxuICBpblxuICBmdW4gdCAtPlxuICAgIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBuID0gMFxuICAgIHRoZW4gW11cbiAgICBlbHNlIChcbiAgICAgICgqIEludmFyaWFudDogWy0xIDw9IHBvcyA8IGVvbF0uICopXG4gICAgICBsZXQgcG9zID0gcmVmIChuIC0gMSkgaW5cbiAgICAgIGxldCBlb2wgPSByZWYgbiBpblxuICAgICAgbGV0IGFjID0gcmVmIFtdIGluXG4gICAgICAoKiBXZSB0cmVhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgc3BlY2lhbGx5LCBiZWNhdXNlIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGFcbiAgICAgICAgIG5ld2xpbmUsIHdlIGRvbid0IHdhbnQgYW4gZXh0cmEgZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmQgb2YgdGhlIG91dHB1dC4gKilcbiAgICAgIGlmIENoYXIuZXF1YWwgdC5bIXBvc10gJ1xcbicgdGhlbiBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sO1xuICAgICAgd2hpbGUgIXBvcyA+PSAwIGRvXG4gICAgICAgIGlmIENoYXIuKCA8PiApIHQuWyFwb3NdICdcXG4nXG4gICAgICAgIHRoZW4gZGVjciBwb3NcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogQmVjYXVzZSBbcG9zIDwgZW9sXSwgd2Uga25vdyB0aGF0IFtzdGFydCA8PSBlb2xdLiAqKVxuICAgICAgICAgIGxldCBzdGFydCA9ICFwb3MgKyAxIGluXG4gICAgICAgICAgYWMgOj0gc3ViIHQgfnBvczpzdGFydCB+bGVuOighZW9sIC0gc3RhcnQpIDo6ICFhYztcbiAgICAgICAgICBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sKVxuICAgICAgZG9uZTtcbiAgICAgIHN1YiB0IH5wb3M6MCB+bGVuOiFlb2wgOjogIWFjKVxuOztcblxubGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5sZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcblxubGV0IGlzX3N1YnN0cmluZ19hdCBzIH5wb3MgfnN1YnN0cmluZyA9XG4gIGlzX3N1YnN0cmluZ19hdF9nZW4gcyB+cG9zIH5zdWJzdHJpbmcgfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxuOztcblxubGV0IHdyYXBfc3ViX24gdCBuIH5uYW1lIH5wb3MgfmxlbiB+b25fZXJyb3IgPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIChuYW1lIF4gXCIgZXhwZWN0aW5nIG5vbm5lZ2F0aXZlIGFyZ3VtZW50XCIpXG4gIGVsc2UgKFxuICAgIHRyeSBzdWIgdCB+cG9zIH5sZW4gd2l0aFxuICAgIHwgXyAtPiBvbl9lcnJvcilcbjs7XG5cbmxldCBkcm9wX3ByZWZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9wcmVmaXhcIiB0IG4gfnBvczpuIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBkcm9wX3N1ZmZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9zdWZmaXhcIiB0IG4gfnBvczowIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBwcmVmaXggdCBuID0gd3JhcF9zdWJfbiB+bmFtZTpcInByZWZpeFwiIHQgbiB+cG9zOjAgfmxlbjpuIH5vbl9lcnJvcjp0XG5sZXQgc3VmZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJzdWZmaXhcIiB0IG4gfnBvczoobGVuZ3RoIHQgLSBuKSB+bGVuOm4gfm9uX2Vycm9yOnRcblxubGV0IGxmaW5kaSA/KHBvcyA9IDApIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA9IG4gdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gIGxvb3AgcG9zIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBmIGMpIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGkgLT4gU29tZSB0LltpXVxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gblxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZiB0LltpXSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gcmVzKVxuICBpblxuICBsb29wIDAgW0Bub250YWlsXVxuOztcblxubGV0IHJmaW5kaSA/cG9zIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgLSAxKSBpblxuICBsZXQgcG9zID1cbiAgICBtYXRjaCBwb3Mgd2l0aFxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gICAgfCBOb25lIC0+IGxlbmd0aCB0IC0gMVxuICBpblxuICBsb29wIHBvcyBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbGFzdF9ub25fZHJvcCB+ZHJvcCB0ID0gcmZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKSBbQG5vbnRhaWxdXG5cbmxldCByc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbWF0Y2ggbGFzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgfCBOb25lIC0+IFwiXCJcbiAgfCBTb21lIGkgLT4gaWYgaSA9IGxlbmd0aCB0IC0gMSB0aGVuIHQgZWxzZSBwcmVmaXggdCAoaSArIDEpXG47O1xuXG5sZXQgZmlyc3Rfbm9uX2Ryb3AgfmRyb3AgdCA9IGxmaW5kaSB0IH5mOihmdW4gXyBjIC0+IG5vdCAoZHJvcCBjKSkgW0Bub250YWlsXVxuXG5sZXQgbHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGZpcnN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgMCAtPiB0XG4gIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuOztcblxuKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgIGZpbmFsIHJlc3VsdC4gIFRoaXMgYWxzbyBzYXZlcyBzb21lIGFtb3VudCBvZiB0aW1lLiAqKVxubGV0IHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwIHx8IG5vdCAoZHJvcCB0LlswXSB8fCBkcm9wIHQuW2xlbmd0aCAtIDFdKVxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgIChtYXRjaCBsYXN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiBpIHQuW2ldKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnQnXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IG1hcCB0IH5mID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBsZXQgdCcgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHQnIGkgKGYgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbmxldCB0b19hcnJheSBzID0gQXJyYXkuaW5pdCAobGVuZ3RoIHMpIH5mOihmdW4gaSAtPiBzLltpXSlcblxubGV0IGV4aXN0cyA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPCBsZW4gJiYgKGYgcy5baV0gfHwgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9yX2FsbCA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPSBsZW4gfHwgKGYgcy5baV0gJiYgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgYWMgdC5baV0pIH5mIH5sZW5cbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IDAgaW5pdCB+ZiB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgaSBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHRcbmxldCBtYXhfZWx0IHQgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0XG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcbmxldCBmaW5kX21hcGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxubGV0IGZpbmRpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kaSB+aXRlcmkgdCB+ZlxubGV0IGNvdW50aSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuY291bnRpIH5mb2xkaSB0IH5mXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZvcl9hbGxpIH5pdGVyaSB0IH5mXG5sZXQgZXhpc3RzaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZXhpc3RzaSB+aXRlcmkgdCB+ZlxuXG5sZXQgbWVtID1cbiAgbGV0IHJlYyBsb29wIHQgYyB+cG9zOmkgfmxlbiA9XG4gICAgaSA8IGxlbiAmJiAoQ2hhci5lcXVhbCBjICh1bnNhZmVfZ2V0IHQgaSkgfHwgbG9vcCB0IGMgfnBvczooaSArIDEpIH5sZW4pXG4gIGluXG4gIGZ1biB0IGMgLT4gbG9vcCB0IGMgfnBvczowIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBpZiBDaGFyLmVxdWFsIHRhcmdldCByZXBsYWNlbWVudFxuICB0aGVuIHNcbiAgZWxzZSBpZiBtZW0gcyB0YXJnZXRcbiAgdGhlbiBtYXAgcyB+ZjooZnVuIGMgLT4gaWYgQ2hhci5lcXVhbCBjIHRhcmdldCB0aGVuIHJlcGxhY2VtZW50IGVsc2UgYylcbiAgZWxzZSBzXG47O1xuXG5sZXQgdHJfbXVsdGkgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBpZiBpc19lbXB0eSB0YXJnZXRcbiAgdGhlbiBzdGFnZSBGbi5pZFxuICBlbHNlIGlmIGlzX2VtcHR5IHJlcGxhY2VtZW50XG4gIHRoZW4gaW52YWxpZF9hcmcgXCJ0cl9tdWx0aSByZXBsYWNlbWVudCBpcyBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgRm4uaWRcbiAgICB8IFNvbWUgdHJfbWFwIC0+XG4gICAgICBzdGFnZSAoZnVuIHMgLT5cbiAgICAgICAgaWYgZXhpc3RzIHMgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgKHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSkpXG4gICAgICAgIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSlcbiAgICAgICAgZWxzZSBzKSlcbjs7XG5cbigqIGZhc3QgdmVyc2lvbiwgaWYgd2UgZXZlciBuZWVkIGl0OlxuICAge1tcbiAgICAgbGV0IGNvbmNhdF9hcnJheSB+c2VwIGFyID1cbiAgICAgICBsZXQgYXJfbGVuID0gQXJyYXkubGVuZ3RoIGFyIGluXG4gICAgICAgaWYgYXJfbGVuID0gMCB0aGVuIFwiXCJcbiAgICAgICBlbHNlXG4gICAgICAgICBsZXQgc2VwX2xlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgIGxldCByZXNfbGVuX3JlZiA9IHJlZiAoc2VwX2xlbiAqIChhcl9sZW4gLSAxKSkgaW5cbiAgICAgICAgIGZvciBpID0gMCB0byBhcl9sZW4gLSAxIGRvXG4gICAgICAgICAgIHJlc19sZW5fcmVmIDo9ICFyZXNfbGVuX3JlZiArIGxlbmd0aCBhci4oaSlcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICBsZXQgcmVzID0gY3JlYXRlICFyZXNfbGVuX3JlZiBpblxuICAgICAgICAgbGV0IHN0cl8wID0gYXIuKDApIGluXG4gICAgICAgICBsZXQgbGVuXzAgPSBsZW5ndGggc3RyXzAgaW5cbiAgICAgICAgIGJsaXQgfnNyYzpzdHJfMCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOjAgfmxlbjpsZW5fMDtcbiAgICAgICAgIGxldCBwb3NfcmVmID0gcmVmIGxlbl8wIGluXG4gICAgICAgICBmb3IgaSA9IDEgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICBsZXQgcG9zID0gIXBvc19yZWYgaW5cbiAgICAgICAgICAgYmxpdCB+c3JjOnNlcCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOnBvcyB+bGVuOnNlcF9sZW47XG4gICAgICAgICAgIGxldCBuZXdfcG9zID0gcG9zICsgc2VwX2xlbiBpblxuICAgICAgICAgICBsZXQgc3RyX2kgPSBhci4oaSkgaW5cbiAgICAgICAgICAgbGV0IGxlbl9pID0gbGVuZ3RoIHN0cl9pIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzdHJfaSB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOm5ld19wb3MgfmxlbjpsZW5faTtcbiAgICAgICAgICAgcG9zX3JlZiA6PSBuZXdfcG9zICsgbGVuX2lcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICByZXNcbiAgIF19ICopXG5cbmxldCBjb25jYXRfYXJyYXkgP3NlcCBhciA9IGNvbmNhdCA/c2VwIChBcnJheS50b19saXN0IGFyKVxubGV0IGNvbmNhdF9tYXAgP3NlcCBzIH5mID0gY29uY2F0X2FycmF5ID9zZXAgKEFycmF5Lm1hcCAodG9fYXJyYXkgcykgfmYpXG5sZXQgY29uY2F0X21hcGkgP3NlcCB0IH5mID0gY29uY2F0X2FycmF5ID9zZXAgKEFycmF5Lm1hcGkgKHRvX2FycmF5IHQpIH5mKVxuXG5sZXQgY29uY2F0X2xpbmVzID1cbiAgbGV0IHJlYyBsaW5lX2xlbmd0aHMgfmxpbmVzIH5uZXdsaW5lX2xlbiB+c3VtID1cbiAgICBtYXRjaCBsaW5lcyB3aXRoXG4gICAgfCBbXSAtPiBzdW1cbiAgICB8IGxpbmUgOjogbGluZXMgLT5cbiAgICAgIGxldCBzdW0gPSBzdW0gKyBTdHJpbmcubGVuZ3RoIGxpbmUgKyBuZXdsaW5lX2xlbiBpblxuICAgICAgbGluZV9sZW5ndGhzIH5saW5lcyB+bmV3bGluZV9sZW4gfnN1bVxuICBpblxuICBsZXQgcmVjIHdyaXRlX2xpbmVzIH5idWYgfmxpbmVzIH5jcmxmIH5wb3MgPVxuICAgIG1hdGNoIGxpbmVzIHdpdGhcbiAgICB8IFtdIC0+IHBvc1xuICAgIHwgbGluZSA6OiBsaW5lcyAtPlxuICAgICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgICAgIH5zcmM6bGluZVxuICAgICAgICB+c3JjX3BvczowXG4gICAgICAgIH5kc3Q6YnVmXG4gICAgICAgIH5kc3RfcG9zOnBvc1xuICAgICAgICB+bGVuOihTdHJpbmcubGVuZ3RoIGxpbmUpO1xuICAgICAgbGV0IHBvcyA9IHBvcyArIFN0cmluZy5sZW5ndGggbGluZSBpblxuICAgICAgbGV0IHBvcyA9XG4gICAgICAgIGlmIGNybGZcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgcG9zICdcXHInO1xuICAgICAgICAgIHBvcyArIDEpXG4gICAgICAgIGVsc2UgcG9zXG4gICAgICBpblxuICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgcG9zICdcXG4nO1xuICAgICAgbGV0IHBvcyA9IHBvcyArIDEgaW5cbiAgICAgIHdyaXRlX2xpbmVzIH5idWYgfmxpbmVzIH5jcmxmIH5wb3NcbiAgaW5cbiAgZnVuID8oY3JsZiA9IGZhbHNlKSBsaW5lcyAtPlxuICAgIGxldCBuZXdsaW5lX2xlbiA9IGlmIGNybGYgdGhlbiAyIGVsc2UgMSBpblxuICAgIGxldCBsZW4gPSBsaW5lX2xlbmd0aHMgfm5ld2xpbmVfbGVuIH5saW5lcyB+c3VtOjAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCB3cml0dGVuID0gd3JpdGVfbGluZXMgfmJ1ZiB+bGluZXMgfmNybGYgfnBvczowIGluXG4gICAgYXNzZXJ0ICh3cml0dGVuID0gbGVuKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ1ZlxuOztcblxuKCogW2ZpbHRlciB0IGZdIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLlxuXG4gICBMZXQgW24gPSBsZW5ndGggdF0uXG5cbiAgIDEuIEZpbmQgdGhlIGxvd2VzdCBbaV0gc3VjaCB0aGF0IFtub3QgKGYgdC5baV0pXS5cblxuICAgMi4gSWYgdGhlcmUgaXMgbm8gc3VjaCBbaV0sIHRoZW4gcmV0dXJuIFt0XS5cblxuICAgMy4gSWYgdGhlcmUgaXMgc3VjaCBhbiBbaV0sIGFsbG9jYXRlIGEgc3RyaW5nLCBbb3V0XSwgdG8gaG9sZCB0aGUgcmVzdWx0LiAgW291dF0gaGFzXG4gICBsZW5ndGggW24gLSAxXSwgd2hpY2ggaXMgdGhlIG1heGltdW0gcG9zc2libGUgb3V0cHV0IHNpemUgZ2l2ZW4gdGhhdCB0aGVyZSBpcyBhdCBsZWFzdFxuICAgb25lIGNoYXJhY3RlciBub3Qgc2F0aXNmeWluZyBbZl0uXG5cbiAgIDQuIENvcHkgY2hhcmFjdGVycyBhdCBpbmRpY2VzIDAgLi4uIFtpIC0gMV0gZnJvbSBbdF0gdG8gW291dF0uXG5cbiAgIDUuIFdhbGsgdGhyb3VnaCBjaGFyYWN0ZXJzIGF0IGluZGljZXMgW2krMV0gLi4uIFtuLTFdIG9mIFt0XSwgY29weWluZyB0aG9zZSB0aGF0XG4gICBzYXRpc2Z5IFtmXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNi4gSWYgd2UgY29tcGxldGVseSBmaWxsZWQgW291dF0sIHRoZW4gcmV0dXJuIGl0LiAgSWYgbm90LCByZXR1cm4gdGhlIHByZWZpeCBvZiBbb3V0XVxuICAgdGhhdCB3ZSBkaWQgZmlsbCBpbi5cblxuICAgVGhpcyBhbGdvcml0aG0gaGFzIHRoZSBwcm9wZXJ0eSB0aGF0IGl0IGRvZXNuJ3QgYWxsb2NhdGUgYSBuZXcgc3RyaW5nIGlmIHRoZXJlJ3NcbiAgIG5vdGhpbmcgdG8gZmlsdGVyLCB3aGljaCBpcyBhIGNvbW1vbiBjYXNlLiAqKVxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbiAmJiBmIHQuWyFpXSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBpZiAhaSA9IG5cbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCBvdXQgPSBCeXRlcy5jcmVhdGUgKG4gLSAxKSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6dCB+c3JjX3BvczowIH5kc3Q6b3V0IH5kc3RfcG9zOjAgfmxlbjohaTtcbiAgICBsZXQgb3V0X3BvcyA9IHJlZiAhaSBpblxuICAgIGluY3IgaTtcbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjID0gdC5bIWldIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0ICFvdXRfcG9zIGM7XG4gICAgICAgIGluY3Igb3V0X3Bvcyk7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGxldCBvdXQgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dCBpblxuICAgIGlmICFvdXRfcG9zID0gbiAtIDEgdGhlbiBvdXQgZWxzZSBzdWIgb3V0IH5wb3M6MCB+bGVuOiFvdXRfcG9zKVxuOztcblxuKCogcmVwZWF0ZWQgY29kZSB0byBhdm9pZCByZXF1aXJpbmcgYW4gZXh0cmEgYWxsb2NhdGlvbiBmb3IgYSBjbG9zdXJlIG9uIGVhY2ggY2FsbC4gKilcbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgIWkgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgIWkgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG5sZXQgY2hvcF9wcmVmaXggcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIFNvbWUgKGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3ByZWZpeF9pZl9leGlzdHMgcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3BfcHJlZml4X2V4biBzIH5wcmVmaXggPVxuICBtYXRjaCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3BfcHJlZml4X2V4biAlUyAlU1wiIHMgcHJlZml4ICgpXG47O1xuXG5sZXQgY2hvcF9zdWZmaXggcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIFNvbWUgKGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeF9pZl9leGlzdHMgcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3Bfc3VmZml4X2V4biBzIH5zdWZmaXggPVxuICBtYXRjaCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3Bfc3VmZml4X2V4biAlUyAlU1wiIHMgc3VmZml4ICgpXG47O1xuXG5tb2R1bGUgRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeCA9IHN0cnVjdFxuICAoKiBXaGVuIHRha2luZyBhIHN0cmluZyBwcmVmaXggb3Igc3VmZml4LCB3ZSBleHRyYWN0IGZyb20gdGhlIHNob3J0ZXN0IGlucHV0IGF2YWlsYWJsZVxuICAgICBpbiBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiBvbmUgb2Ygb3VyIGlucHV0cyB3aXRob3V0IGFsbG9jYXRpbmcgYSBuZXcgc3RyaW5nLiAqKVxuXG4gIGxldCBzaG9ydGVyIGEgYiA9IGlmIGxlbmd0aCBhIDw9IGxlbmd0aCBiIHRoZW4gYSBlbHNlIGJcblxuICBsZXQgc2hvcnRlc3QgbGlzdCA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBcIlwiXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+IExpc3QuZm9sZCByZXN0IH5pbml0OmZpcnN0IH5mOnNob3J0ZXJcbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgZm9yIGNvbW1vbiBwcmVmaXgvc3VmZml4IGFic3RyYWN0IG92ZXIgW2dldF9wb3NdLCB3aGljaCBpc1xuICAgICBlaXRoZXIgW3Bvc19mcm9tX2xlZnRdIG9yIFtwb3NfZnJvbV9yaWdodF0uICopXG5cbiAgbGV0IHBvc19mcm9tX2xlZnQgKF8gOiB0KSAoaSA6IGludCkgPSBpXG4gIGxldCBwb3NfZnJvbV9yaWdodCB0IGkgPSBsZW5ndGggdCAtIGkgLSAxXG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyID1cbiAgICBpZiBsZW5fc29fZmFyID49IG1heF9sZW5cbiAgICB0aGVuIG1heF9sZW5cbiAgICBlbHNlIGlmIENoYXIuZXF1YWxcbiAgICAgICAgICAgICAgKHVuc2FmZV9nZXQgYSAoZ2V0X3BvcyBhIGxlbl9zb19mYXIpKVxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBiIChnZXRfcG9zIGIgbGVuX3NvX2ZhcikpXG4gICAgdGhlbiBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOihsZW5fc29fZmFyICsgMSlcbiAgICBlbHNlIGxlbl9zb19mYXJcbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgPVxuICAgIGxldCBtYXhfbGVuID0gbWluIChsZW5ndGggYSkgKGxlbmd0aCBiKSBpblxuICAgIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6MFxuICA7O1xuXG4gIGxldCByZWMgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgbGlzdCB+Z2V0X3BvcyB+bWF4X2xlbiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBtYXhfbGVuXG4gICAgfCBzZWNvbmQgOjogcmVzdCAtPlxuICAgICAgbGV0IG1heF9sZW4gPVxuICAgICAgICAoKiBXZSBjYWxsIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3BdIHJhdGhlciB0aGFuIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoXSBzb1xuICAgICAgICAgICB0aGF0IFttYXhfbGVuXSBsaW1pdHMgb3VyIHRyYXZlcnNhbCBvZiBbZmlyc3RdIGFuZCBbc2Vjb25kXS4gKilcbiAgICAgICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGZpcnN0IHNlY29uZCB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gICAgICBpblxuICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3Agc2Vjb25kIHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3MgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gMFxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogUHJlY29tcHV0aW5nIFttYXhfbGVuXSBiYXNlZCBvbiBbc2hvcnRlc3QgbGlzdF0gc2F2ZXMgdXMgd29yayBpbiBsb25nZXIgc3RyaW5ncyxcbiAgICAgICAgIGF0IHRoZSBjb3N0IG9mIGFuIGV4dHJhIHBhc3Mgb3ZlciB0aGUgc3BpbmUgb2YgW2xpc3RdLlxuXG4gICAgICAgICBGb3IgZXhhbXBsZSwgaWYgeW91J3JlIGxvb2tpbmcgZm9yIHRoZSBsb25nZXN0IHByZWZpeCBvZiB0aGUgc3RyaW5nczpcblxuICAgICAgICAge3ZcbiAgICAgICAgICAgIGxldCBsb25nX2EgPSBMaXN0LmluaXQgMTAwMCB+ZjooRm4uY29uc3QgJ2EnKVxuICAgICAgICAgICAgWyBsb25nX2E7IGxvbmdfYTsgJ2FhJyBdXG4gICAgICAgICB2fVxuXG4gICAgICAgICB0aGUgYXBwcm9hY2ggYmVsb3cgd2lsbCBqdXN0IGNoZWNrIHRoZSBmaXJzdCB0d28gY2hhcmFjdGVycyBvZiBhbGwgdGhlIHN0cmluZ3MuXG4gICAgICAqKVxuICAgICAgbGV0IG1heF9sZW4gPSBsZW5ndGggKHNob3J0ZXN0IGxpc3QpIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gIDs7XG5cbiAgKCogT3VyIGdlbmVyaWMgYWNjZXNzb3JzIHRoYXQgcHJvZHVjZSBhIHN0cmluZyBhYnN0cmFjdCBvdmVyIFt0YWtlXSwgd2hpY2ggaXMgZWl0aGVyXG4gICAgIFtwcmVmaXhdIG9yIFtzdWZmaXhdLiAqKVxuXG4gIGxldCBjb21tb25fZ2VuZXJpYzIgYSBiIH5nZXRfcG9zIH50YWtlID1cbiAgICBsZXQgbGVuID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgaW5cbiAgICAoKiBVc2UgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBzdHJpbmdzLCBzbyB0aGF0IGlmIHRoZSBzaG9ydGVyIG9uZSBpcyB0aGUgc2hhcmVkXG4gICAgICAgcHJlZml4LCBbdGFrZV0gd29uJ3QgYWxsb2NhdGUgYW5vdGhlciBzdHJpbmcuICopXG4gICAgdGFrZSAoc2hvcnRlciBhIGIpIGxlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYyBsaXN0IH5nZXRfcG9zIH50YWtlID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT5cbiAgICAgICgqIEFzIHdpdGggW2NvbW1vbl9nZW5lcmljX2xlbmd0aF0sIHdlIGJhc2UgW21heF9sZW5dIG9uIFtzaG9ydGVzdCBsaXN0XS4gV2UgYWxzb1xuICAgICAgICAgdXNlIHRoaXMgcmVzdWx0IGZvciBbdGFrZV0sIGJlbG93LCB0byBwb3RlbnRpYWxseSBhdm9pZCBhbGxvY2F0aW5nIGEgc3RyaW5nLiAqKVxuICAgICAgbGV0IHMgPSBzaG9ydGVzdCBsaXN0IGluXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCBzIGluXG4gICAgICBpZiBtYXhfbGVuID0gMFxuICAgICAgdGhlbiBcIlwiXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxlbiA9XG4gICAgICAgICAgKCogV2UgY2FsbCBkaXJlY3RseSBpbnRvIFtjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW5cbiAgICAgICAgICAgICBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSB0byBhdm9pZCByZWNvbXB1dGluZyBbc2hvcnRlc3QgbGlzdF0uICopXG4gICAgICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICAgICAgICBpblxuICAgICAgICB0YWtlIHMgbGVuKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeFxuXG4gIGxldCBjb21tb25fcHJlZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpwcmVmaXggfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpzdWZmaXggfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4X2xlbmd0aCBsaXN0ID0gY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4Ml9sZW5ndGggYSBiID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbmVuZFxuXG4oKiBUaGVyZSB1c2VkIHRvIGJlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIHRoYXQgd2FzIGZhc3RlciBmb3IgdmVyeSBzaG9ydCBzdHJpbmdzXG4gICAocGVha2luZyBhdCA0MCUgZmFzdGVyIGZvciA0LTYgY2hhciBsb25nIHN0cmluZ3MpLlxuICAgVGhpcyBuZXcgZnVuY3Rpb24gaXMgYXJvdW5kIDIwJSBmYXN0ZXIgdGhhbiB0aGUgZGVmYXVsdCBoYXNoIGZ1bmN0aW9uLCBidXQgc2xvd2VyXG4gICB0aGFuIHRoZSBwcmV2aW91cyBjdXN0b20gaW1wbGVtZW50YXRpb24uIEhvd2V2ZXIsIHRoZSBuZXcgT0NhbWwgZnVuY3Rpb24gaXMgd2VsbFxuICAgYmVoYXZlZCwgYW5kIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbGVzcyBsaWtlbHkgdG8gZGl2ZXJnZSBmcm9tIHRoZSBkZWZhdWx0IE9DYW1sXG4gICBpbXBsZW1lbnRhdGlvbiBkb2VzLCB3aGljaCBpcyBhIGRlc2lyYWJsZSBwcm9wZXJ0eS4gKFRoZSBvbmx5IHdheSB0byBhdm9pZCB0aGVcbiAgIGRpdmVyZ2VuY2UgaXMgdG8gZXhwb3NlIHRoZSBtYWNybyByZWRlZmluZWQgaW4gaGFzaF9zdHVicy5jIGluIHRoZSBoYXNoLmggaGVhZGVyIG9mXG4gICB0aGUgT0NhbWwgY29tcGlsZXIuKSAqKVxubW9kdWxlIEhhc2ggPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgaGFzaCA6IHN0cmluZyAtPiBpbnQgPSBcIkJhc2VfaGFzaF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZW5kXG5cbigqIFtpbmNsdWRlIEhhc2hdIHRvIG1ha2UgdGhlIFtleHRlcm5hbF0gdmVyc2lvbiBvdmVycmlkZSB0aGUgW2hhc2hdIGZyb21cbiAgIFtIYXNoYWJsZS5NYWtlX2JpbmFibGVdLCBzbyB0aGF0IHdlIGdldCBhIGxpdHRsZSBiaXQgb2YgYSBzcGVlZHVwIGJ5IGV4cG9zaW5nIGl0IGFzXG4gICBleHRlcm5hbCBpbiB0aGUgbWxpLiAqKVxubGV0IF8gPSBoYXNoXG5cbmluY2x1ZGUgSGFzaFxuXG4oKiBmb3IgaW50ZXJhY3RpdmUgdG9wLWxldmVscyAtLSBtb2R1bGVzIGRlcml2aW5nIGZyb20gU3RyaW5nIHNob3VsZCBoYXZlIFN0cmluZydzIHByZXR0eVxuICAgcHJpbnRlci4gKilcbmxldCBwcCBwcGYgc3RyaW5nID0gU3RkbGliLkZvcm1hdC5mcHJpbnRmIHBwZiBcIiVTXCIgc3RyaW5nXG5sZXQgb2ZfY2hhciBjID0gbWFrZSAxIGNcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBCeXRlcy5zZXQgdCBpIGMpO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbmxldCBvZl9saXN0ID0gb2ZfY2hhcl9saXN0XG5sZXQgb2ZfYXJyYXkgYSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhKSB+ZjooQXJyYXkuZ2V0IGEpXG5sZXQgYXBwZW5kID0gKCBeIClcblxubGV0IHBhZF9yaWdodCA/KGNoYXIgPSAnICcpIHMgfmxlbiA9XG4gIGxldCBzcmNfbGVuID0gbGVuZ3RoIHMgaW5cbiAgaWYgc3JjX2xlbiA+PSBsZW5cbiAgdGhlbiBzXG4gIGVsc2UgKFxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzpzIH5kc3Q6cmVzIH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOnNyY19sZW47XG4gICAgQnl0ZXMuZmlsbCB+cG9zOnNyY19sZW4gfmxlbjoobGVuIC0gc3JjX2xlbikgcmVzIGNoYXI7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpyZXMpXG47O1xuXG5sZXQgcGFkX2xlZnQgPyhjaGFyID0gJyAnKSBzIH5sZW4gPVxuICBsZXQgc3JjX2xlbiA9IGxlbmd0aCBzIGluXG4gIGlmIHNyY19sZW4gPj0gbGVuXG4gIHRoZW4gc1xuICBlbHNlIChcbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+ZHN0OnJlcyB+c3JjX3BvczowIH5kc3RfcG9zOihsZW4gLSBzcmNfbGVuKSB+bGVuOnNyY19sZW47XG4gICAgQnl0ZXMuZmlsbCB+cG9zOjAgfmxlbjoobGVuIC0gc3JjX2xlbikgcmVzIGNoYXI7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpyZXMpXG47O1xuXG4oKiBDYWxsZWQgdXBvbiBmaXJzdCBkaWZmZXJlbmNlIGdlbmVyYXRlZCBieSBmaWx0ZXJpbmcuIEFsbG9jYXRlcyBbYnVmZmVyX2xlbl0gYnl0ZXNcbiAgIGZvciBuZXcgcmVzdWx0LCBhbmQgY29waWVzIFtwcmVmaXhfbGVuXSB1bmNoYW5nZWQgY2hhcmFjdGVycyBmcm9tIFtzcmNdLlxuICAgQWx3YXlzIHJldHVybnMgYSBsb2NhbCBidWZmZXIuICopXG5sZXQgbG9jYWxfY29weV9wcmVmaXggKHNyYyBbQGxvY2FsXSkgfnByZWZpeF9sZW4gfmJ1ZmZlcl9sZW4gPVxuICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlX2xvY2FsIGJ1ZmZlcl9sZW4gaW5cbiAgQnl0ZXMuUHJpbWl0aXZlcy51bnNhZmVfYmxpdF9zdHJpbmcgfnNyYyB+ZHN0IH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOnByZWZpeF9sZW47XG4gICBkc3Rcbjs7XG5cbigqIENvcGllcyBhIHBlcmhhcHMtbG9jYWwgYnVmZmVyIGludG8gYSBkZWZpbml0ZWx5LWdsb2JhbCBzdHJpbmcuICopXG5sZXQgbG9jYWxfY29weV90b19zdHJpbmcgKGJ1ZiBbQGxvY2FsXSkgfnBvcyA9XG4gIGxldCBzdHIgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ1ZiBpblxuICB1bnNhZmVfc3ViIHN0ciB+cG9zOjAgfmxlbjpwb3MgW0Bub250YWlsXVxuOztcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBzdHJ1Y3RcbiAgICAoKiBmaWx0ZXJfbWFwIGhlbHBlcnMgKilcblxuICAgICgqIEZpbHRlcnMgZnJvbSBzdHJpbmcgW3NyY10gaW50byBhbiBhbGxvY2F0ZWQgYnVmZmVyIFtkc3RdO1xuICAgICAgIGNvcGllcyB0aGUgYWxsb2NhdGVkIGJ1ZmZlciB0byBhIGhlYXAtYWxsb2NhdGVkIHJlc3VsdCBzdHJpbmcuXG5cbiAgICAgICBQcmUtY29uZGl0aW9uczpcbiAgICAgICBbc3JjX2xlbiA9IGxlbmd0aCBzcmNdXG4gICAgICAgW3NyYyAhPSBkc3RdXG4gICAgICAgWzAgPD0gc3JjX3BvcyA8IHNyY19sZW5dXG4gICAgICAgWzAgPD0gZHN0X3BvcyA8IGxlbmd0aCBkc3RdXG4gICAgKilcbiAgICBsZXQgZmlsdGVyX21hcGlfaW50byBzcmMgKGRzdCBbQGxvY2FsXSkgfmYgfnNyY19wb3MgfmRzdF9wb3MgfnNyY19sZW4gPVxuICAgICAgbGV0IGRzdF9wb3MgPSAgKHJlZiBkc3RfcG9zKSBpblxuICAgICAgZm9yIHNyY19wb3MgPSBzcmNfcG9zIHRvIHNyY19sZW4gLSAxIGRvXG4gICAgICAgIG1hdGNoIGYgc3JjX3BvcyAodW5zYWZlX2dldCBzcmMgc3JjX3Bvcykgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIGMgLT5cbiAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IGRzdCAhZHN0X3BvcyBjO1xuICAgICAgICAgIGluY3IgZHN0X3Bvc1xuICAgICAgZG9uZTtcbiAgICAgIGxvY2FsX2NvcHlfdG9fc3RyaW5nIGRzdCB+cG9zOiFkc3RfcG9zXG4gICAgOztcblxuICAgICgqIEZpbHRlcnMgW3RdLiBJZiB0aGUgcmVzdWx0IHR1cm5zIG91dCB0byBiZSBpZGVudGljYWwgdG8gdGhlIGlucHV0LCByZXR1cm5zIFt0XVxuICAgICAgIGRpcmVjdGx5IHdpdGhvdXQgbmVlZGluZyB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBhbmQgdHJhdmVyc2UgdGhlIHN0cmluZyB0d2ljZS5cblxuICAgICAgIFByZS1jb25kaXRpb246IFtsZW4gPT0gbGVuZ3RoIHRdXG4gICAgICAgUHJlLWNvbmRpdGlvbjogWzAgPD0gcG9zIDw9IGxlbl0gKilcbiAgICBsZXQgcmVjIGZpbHRlcl9tYXBpX21heWJlX2lkIHQgfmYgfnBvcyB+bGVuID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiB0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCB0IHBvcyBpblxuICAgICAgICBsZXQgbmV4dCA9IEludC5zdWNjIHBvcyBpblxuICAgICAgICBtYXRjaCBmIHBvcyBjMSB3aXRoXG4gICAgICAgIHwgU29tZSBjMiB3aGVuIENoYXIuZXF1YWwgYzEgYzIgLT5cbiAgICAgICAgICAoKiBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCBjb250aW51ZSAqKVxuICAgICAgICAgIGZpbHRlcl9tYXBpX21heWJlX2lkIHQgfmYgfnBvczpuZXh0IH5sZW5cbiAgICAgICAgfCBvcHRpb24gLT5cbiAgICAgICAgICAoKiBJZiBhIGNoYXJhY3RlciBoYXMgYmVlbiBjaGFuZ2VkIG9yIGRyb3BwZWQsIGJlZ2luIGFuIG91dHB1dCBidWZmZXIgdXAgdG9cbiAgICAgICAgICAgICBbcG9zXSwgYW5kIHdyaXRlIHRoZSBuZXcgY2hhcmFjdGVyIGludG8gaXQuICopXG4gICAgICAgICAgbGV0IGNvcHkgPSBsb2NhbF9jb3B5X3ByZWZpeCB0IH5wcmVmaXhfbGVuOnBvcyB+YnVmZmVyX2xlbjpsZW4gaW5cbiAgICAgICAgICBsZXQgZHN0X3BvcyA9XG4gICAgICAgICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHBvc1xuICAgICAgICAgICAgfCBTb21lIGMgLT5cbiAgICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBjb3B5IHBvcyBjO1xuICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgaW5cbiAgICAgICAgICBmaWx0ZXJfbWFwaV9pbnRvIHQgY29weSB+ZiB+c3JjX3BvczpuZXh0IH5kc3RfcG9zIH5zcmNfbGVuOmxlbiBbQG5vbnRhaWxdKVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGZpbHRlcl9tYXAgZnVuY3Rpb25zICopXG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPSBmaWx0ZXJfbWFwaV9tYXliZV9pZCB0IH5mIH5wb3M6MCB+bGVuOihsZW5ndGggdClcbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfIGMgLT4gZiBjKSBbQG5vbnRhaWxdXG5lbmRcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBzdHJ1Y3RcbiAgICAoKiBwYXJ0aXRpb24gaGVscGVycyAqKVxuXG4gICAgbGV0IHBhcnRpdGlvbl9tYXBfaW50byBzcmMgfmZzdHMgfnNuZHMgfmYgfmxlbiB+c3JjX3BvcyB+ZnN0X3BvcyB+c25kX3BvcyA9XG4gICAgICBsZXQgZnN0X3BvcyA9ICAocmVmIGZzdF9wb3MpIGluXG4gICAgICBsZXQgc25kX3BvcyA9ICAocmVmIHNuZF9wb3MpIGluXG4gICAgICBmb3Igc3JjX3BvcyA9IHNyY19wb3MgdG8gbGVuIC0gMSBkb1xuICAgICAgICBtYXRjaCAgKGYgKHVuc2FmZV9nZXQgc3JjIHNyY19wb3MpIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgYyAtPlxuICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgZnN0cyAhZnN0X3BvcyBjO1xuICAgICAgICAgIGluY3IgZnN0X3Bvc1xuICAgICAgICB8IFNlY29uZCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzbmRzICFzbmRfcG9zIGM7XG4gICAgICAgICAgaW5jciBzbmRfcG9zXG4gICAgICBkb25lO1xuICAgICAgbG9jYWxfY29weV90b19zdHJpbmcgZnN0cyB+cG9zOiFmc3RfcG9zLCBsb2NhbF9jb3B5X3RvX3N0cmluZyBzbmRzIH5wb3M6IXNuZF9wb3NcbiAgICA7O1xuXG4gICAgbGV0IHBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZSBzcmMgfmYgfmxlbiB+cG9zOnNyY19wb3MgfmZzdF9wb3MgfnNuZF9wb3MgZWl0aGVyID1cbiAgICAgIGxldCBmc3RzID0gbG9jYWxfY29weV9wcmVmaXggc3JjIH5wcmVmaXhfbGVuOmZzdF9wb3MgfmJ1ZmZlcl9sZW46bGVuIGluXG4gICAgICBsZXQgc25kcyA9IGxvY2FsX2NvcHlfcHJlZml4IHNyYyB+cHJlZml4X2xlbjpzbmRfcG9zIH5idWZmZXJfbGVuOmxlbiBpblxuICAgICAgbGV0IGZzdF9wb3MsIHNuZF9wb3MgPVxuICAgICAgICBtYXRjaCAoZWl0aGVyIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgYyAtPlxuICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgZnN0cyBmc3RfcG9zIGM7XG4gICAgICAgICAgIChmc3RfcG9zICsgMSwgc25kX3BvcylcbiAgICAgICAgfCBTZWNvbmQgYyAtPlxuICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgc25kcyBzbmRfcG9zIGM7XG4gICAgICAgICAgIChmc3RfcG9zLCBzbmRfcG9zICsgMSlcbiAgICAgIGluXG4gICAgICBwYXJ0aXRpb25fbWFwX2ludG9cbiAgICAgICAgc3JjXG4gICAgICAgIH5mc3RzXG4gICAgICAgIH5zbmRzXG4gICAgICAgIH5mXG4gICAgICAgIH5sZW5cbiAgICAgICAgfnNyY19wb3M6KHNyY19wb3MgKyAxKVxuICAgICAgICB+ZnN0X3Bvc1xuICAgICAgICB+c25kX3BvcyBbQG5vbnRhaWxdXG4gICAgOztcblxuICAgIGxldCByZWMgcGFydGl0aW9uX21hcF9maXJzdF9tYXliZV9pZCBzcmMgfmYgfnBvcyB+bGVuID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiBzcmMsIFwiXCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYzEgPSB1bnNhZmVfZ2V0IHNyYyBwb3MgaW5cbiAgICAgICAgbWF0Y2ggIChmIGMxIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgYzIgd2hlbiBDaGFyLmVxdWFsIGMxIGMyIC0+XG4gICAgICAgICAgcGFydGl0aW9uX21hcF9maXJzdF9tYXliZV9pZCBzcmMgfmYgfmxlbiB+cG9zOihwb3MgKyAxKVxuICAgICAgICB8IGVpdGhlciAtPlxuICAgICAgICAgIHBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZVxuICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICB+ZlxuICAgICAgICAgICAgfmxlblxuICAgICAgICAgICAgfnBvc1xuICAgICAgICAgICAgfmZzdF9wb3M6cG9zXG4gICAgICAgICAgICB+c25kX3BvczowXG4gICAgICAgICAgICBlaXRoZXIgW0Bub250YWlsXSlcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb25fbWFwX3NlY29uZF9tYXliZV9pZCBzcmMgfmYgfnBvcyB+bGVuID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiBcIlwiLCBzcmNcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYzEgPSB1bnNhZmVfZ2V0IHNyYyBwb3MgaW5cbiAgICAgICAgbWF0Y2ggIChmIGMxIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgU2Vjb25kIGMyIHdoZW4gQ2hhci5lcXVhbCBjMSBjMiAtPlxuICAgICAgICAgIHBhcnRpdGlvbl9tYXBfc2Vjb25kX21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpXG4gICAgICAgIHwgZWl0aGVyIC0+XG4gICAgICAgICAgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlXG4gICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIH5mXG4gICAgICAgICAgICB+bGVuXG4gICAgICAgICAgICB+cG9zXG4gICAgICAgICAgICB+ZnN0X3BvczowXG4gICAgICAgICAgICB+c25kX3Bvczpwb3NcbiAgICAgICAgICAgIGVpdGhlciBbQG5vbnRhaWxdKVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIHBhcnRpdGlvbiBmdW5jdGlvbnMgKilcblxuICBsZXQgcGFydGl0aW9uX21hcCBzcmMgfmYgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggc3JjIGluXG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gXCJcIiwgXCJcIlxuICAgIGVsc2UgKFxuICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCBzcmMgMCBpblxuICAgICAgbWF0Y2ggIChmIGMxIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICB8IEZpcnN0IGMyIHdoZW4gQ2hhci5lcXVhbCBjMSBjMiAtPiBwYXJ0aXRpb25fbWFwX2ZpcnN0X21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6MVxuICAgICAgfCBTZWNvbmQgYzIgd2hlbiBDaGFyLmVxdWFsIGMxIGMyIC0+XG4gICAgICAgIHBhcnRpdGlvbl9tYXBfc2Vjb25kX21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6MVxuICAgICAgfCBlaXRoZXIgLT5cbiAgICAgICAgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlXG4gICAgICAgICAgc3JjXG4gICAgICAgICAgfmZcbiAgICAgICAgICB+bGVuXG4gICAgICAgICAgfnBvczowXG4gICAgICAgICAgfmZzdF9wb3M6MFxuICAgICAgICAgIH5zbmRfcG9zOjBcbiAgICAgICAgICBlaXRoZXIgW0Bub250YWlsXSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIHBhcnRpdGlvbl9tYXAgdCB+ZjooZnVuIGMgLT4gaWYgZiBjIHRoZW4gIChGaXJzdCBjKSBlbHNlICAoU2Vjb25kIGMpKSBbQG5vbnRhaWxcbiAgICBdXG4gIDs7XG5lbmRcblxubW9kdWxlIEVzY2FwaW5nID0gc3RydWN0XG4gICgqIElmIHRoaXMgaXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRvIHVwZGF0ZSBbZXNjYXBlXSwgd2hpY2ggYXR0ZW1wdHMgdG8gZW5zdXJlIGFsbCB0aGVcbiAgICAgaW52YXJpYW50cyBjaGVja2VkIGhlcmUuICAqKVxuICBsZXQgYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoeV9tYXAgZXNjYXBld29ydGh5X21hcCBlc2NhcGVfY2hhciBmdW5jID1cbiAgICBsZXQgZXNjYXBld29ydGh5X21hcCA9XG4gICAgICBpZiBMaXN0LkFzc29jLm1lbSBlc2NhcGV3b3J0aHlfbWFwIH5lcXVhbDpDaGFyLmVxdWFsIGVzY2FwZV9jaGFyXG4gICAgICB0aGVuIGVzY2FwZXdvcnRoeV9tYXBcbiAgICAgIGVsc2UgKGVzY2FwZV9jaGFyLCBlc2NhcGVfY2hhcikgOjogZXNjYXBld29ydGh5X21hcFxuICAgIGluXG4gICAgbGV0IGFyciA9IEFycmF5LmNyZWF0ZSB+bGVuOjI1NiAoLTEpIGluXG4gICAgbGV0IHZhbHMgPSBBcnJheS5jcmVhdGUgfmxlbjoyNTYgZmFsc2UgaW5cbiAgICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBPayBhcnJcbiAgICAgIHwgKGNfZnJvbSwgY190bykgOjogbCAtPlxuICAgICAgICBsZXQgaywgdiA9XG4gICAgICAgICAgbWF0Y2ggZnVuYyB3aXRoXG4gICAgICAgICAgfCBgRXNjYXBlIC0+IENoYXIudG9faW50IGNfZnJvbSwgY190b1xuICAgICAgICAgIHwgYFVuZXNjYXBlIC0+IENoYXIudG9faW50IGNfdG8sIGNfZnJvbVxuICAgICAgICBpblxuICAgICAgICBpZiBhcnIuKGspIDw+IC0xIHx8IHZhbHMuKENoYXIudG9faW50IHYpXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgICBcImVzY2FwZXdvcnRoeV9tYXAgbm90IG9uZS10by1vbmVcIlxuICAgICAgICAgICAgICAgWyBcImNfZnJvbVwiLCBzZXhwX29mX2NoYXIgY19mcm9tXG4gICAgICAgICAgICAgICA7IFwiY190b1wiLCBzZXhwX29mX2NoYXIgY190b1xuICAgICAgICAgICAgICAgOyAoIFwiZXNjYXBld29ydGh5X21hcFwiXG4gICAgICAgICAgICAgICAgICwgc2V4cF9vZl9saXN0IChzZXhwX29mX3BhaXIgc2V4cF9vZl9jaGFyIHNleHBfb2ZfY2hhcikgZXNjYXBld29ydGh5X21hcFxuICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICBdKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBhcnIuKGspIDwtIENoYXIudG9faW50IHY7XG4gICAgICAgICAgdmFscy4oQ2hhci50b19pbnQgdikgPC0gdHJ1ZTtcbiAgICAgICAgICBsb29wIGwpXG4gICAgaW5cbiAgICBsb29wIGVzY2FwZXdvcnRoeV9tYXBcbiAgOztcblxuICBsZXQgZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgYEVzY2FwZSB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgZXNjYXBld29ydGh5IC0+XG4gICAgICBPa1xuICAgICAgICAoZnVuIHNyYyAtPlxuICAgICAgICAgICAoKiBjYWxjdWxhdGUgYSBsaXN0IG9mIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgZmlyc3QsIHRoZSBvcmRlclxuICAgICAgICAgICAgICBpcyBmcm9tIHRhaWwgdG8gaGVhZCAqKVxuICAgICAgICAgICBsZXQgdG9fZXNjYXBlX2xlbiA9IHJlZiAwIGluXG4gICAgICAgICAgIGxldCB0b19lc2NhcGUgPVxuICAgICAgICAgICAgIGZvbGRpIHNyYyB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGMgLT5cbiAgICAgICAgICAgICAgIG1hdGNoIGVzY2FwZXdvcnRoeS4oQ2hhci50b19pbnQgYykgd2l0aFxuICAgICAgICAgICAgICAgfCAtMSAtPiBhY2NcbiAgICAgICAgICAgICAgIHwgbiAtPlxuICAgICAgICAgICAgICAgICAoKiAoaW5kZXggb2YgY2hhciB0byBlc2NhcGUgKiBlc2NhcGVkIGNoYXIpICopXG4gICAgICAgICAgICAgICAgIGluY3IgdG9fZXNjYXBlX2xlbjtcbiAgICAgICAgICAgICAgICAgKGksIENoYXIudW5zYWZlX29mX2ludCBuKSA6OiBhY2MpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIG1hdGNoIHRvX2VzY2FwZSB3aXRoXG4gICAgICAgICAgIHwgW10gLT4gc3JjXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICgqIFt0b19lc2NhcGVdIGRpdmlkZSBbc3JjXSB0byBbTGlzdC5sZW5ndGggdG9fZXNjYXBlICsgMV0gcGllY2VzIHNlcGFyYXRlZCBieVxuICAgICAgICAgICAgICAgIHRoZSBjaGFycyB0byBlc2NhcGUuXG5cbiAgICAgICAgICAgICAgICBMZXRzIHRha2VcbiAgICAgICAgICAgICAgICB7W1xuICAgICAgICAgICAgICAgICAgZXNjYXBlX2dlbl9leG5cbiAgICAgICAgICAgICAgICAgICAgfmVzY2FwZXdvcnRoeV9tYXA6WygnYScsICdBJyk7ICgnYicsICdCJyk7ICgnYycsICdDJyldXG4gICAgICAgICAgICAgICAgICAgIH5lc2NhcGVfY2hhcjonXydcbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCBhbmQgYXNzdW1lIHRoZSBzdHJpbmcgdG8gZXNjYXBlIGlzXG5cbiAgICAgICAgICAgICAgICBcIjAwMGExMTFiMjIyYzMzM1wiXG5cbiAgICAgICAgICAgICAgICB0aGVuIFt0b19lc2NhcGVdIGlzIFsoMTEsICdDJyk7ICg3LCAnQicpOyAoMywgJ0EnKV0uXG5cbiAgICAgICAgICAgICAgICBUaGVuIHdlIGNyZWF0ZSBhIFtkc3RdIG9mIGxlbmd0aCBbbGVuZ3RoIHNyYyArIDNdIHRvIHN0b3JlIHRoZVxuICAgICAgICAgICAgICAgIHJlc3VsdCwgY29weSBwaWVjZSBcIjMzM1wiIHRvIFtkc3RdIGRpcmVjdGx5LCB0aGVuIGNvcHkgJ18nIGFuZCAnQycgdG8gW2RzdF07XG4gICAgICAgICAgICAgICAgdGhlbiBtb3ZlIG9uIHRvIG5leHQ7IGFmdGVyIDMgaXRlcmF0aW9ucywgY29weSBwaWVjZSBcIjAwMFwiIGFuZCB3ZSBhcmUgZG9uZS5cblxuICAgICAgICAgICAgICAgIEZpbmFsbHkgdGhlIHJlc3VsdCB3aWxsIGJlXG5cbiAgICAgICAgICAgICAgICBcIjAwMF9BMTExX0IyMjJfQzMzM1wiICopXG4gICAgICAgICAgICAgbGV0IHNyY19sZW4gPSBsZW5ndGggc3JjIGluXG4gICAgICAgICAgICAgbGV0IGRzdF9sZW4gPSBzcmNfbGVuICsgIXRvX2VzY2FwZV9sZW4gaW5cbiAgICAgICAgICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGRzdF9sZW4gaW5cbiAgICAgICAgICAgICBsZXQgcmVjIGxvb3AgbGFzdF9pZHggbGFzdF9kc3RfcG9zID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgW10gLT5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjAwMFwiIGF0IGxhc3QgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmxhc3RfaWR4XG4gICAgICAgICAgICAgICB8IChpZHgsIGVzY2FwZWRfY2hhcikgOjogdG9fZXNjYXBlIC0+XG4gICAgICAgICAgICAgICAgICgqW2lkeF0gPSB0aGUgY2hhciB0byBlc2NhcGUqKVxuICAgICAgICAgICAgICAgICAoKiB0YWtlIGZpcnN0IGl0ZXJhdGlvbiBmb3IgZXhhbXBsZSAqKVxuICAgICAgICAgICAgICAgICAoKiBjYWxjdWxhdGUgbGVuZ3RoIG9mIFwiMzMzXCIsIG1pbnVzIDEgYmVjYXVzZSB3ZSBkb24ndCBjb3B5ICdjJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgbGVuID0gbGFzdF9pZHggLSBpZHggLSAxIGluXG4gICAgICAgICAgICAgICAgICgqIHNldCB0aGUgZHN0X3BvcyB0byBjb3B5IHRvICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gbGFzdF9kc3RfcG9zIC0gbGVuIGluXG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIzMzNcIiwgc2V0IFtzcmNfcG9zXSB0byBbaWR4ICsgMV0gdG8gc2tpcCAnYycgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczooaWR4ICsgMSkgfmRzdCB+ZHN0X3BvcyB+bGVuO1xuICAgICAgICAgICAgICAgICAoKiBiYWNrb2ZmIFtkc3RfcG9zXSBieSAyIHRvIGNvcHkgJ18nIGFuZCAnQycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBkc3RfcG9zIC0gMiBpblxuICAgICAgICAgICAgICAgICBCeXRlcy5zZXQgZHN0IGRzdF9wb3MgZXNjYXBlX2NoYXI7XG4gICAgICAgICAgICAgICAgIEJ5dGVzLnNldCBkc3QgKGRzdF9wb3MgKyAxKSBlc2NhcGVkX2NoYXI7XG4gICAgICAgICAgICAgICAgIGxvb3AgaWR4IGRzdF9wb3MgdG9fZXNjYXBlXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBzZXQgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gdG8gbGVuZ3RoIG9mIFtkc3RdIGFuZCBbc3JjXSBmaXJzdCAqKVxuICAgICAgICAgICAgIGxvb3Agc3JjX2xlbiBkc3RfbGVuIHRvX2VzY2FwZTtcbiAgICAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbiAgOztcblxuICBsZXQgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyKSB8PiBzdGFnZVxuICA7O1xuXG4gIGxldCBlc2NhcGUgfmVzY2FwZXdvcnRoeSB+ZXNjYXBlX2NoYXIgPVxuICAgICgqIEZvciBbZXNjYXBlX2dlbl9leG5dLCB3ZSBkb24ndCBrbm93IGhvdyB0byBmaXggaW52YWxpZCBlc2NhcGV3b3J0aHlfbWFwIHNvIHdlIGhhdmVcbiAgICAgICB0byByYWlzZSBleGNlcHRpb247IGJ1dCBpbiB0aGlzIGNhc2UsIHdlIGtub3cgaG93IHRvIGZpeCBkdXBsaWNhdGVkIGVsZW1lbnRzIGluXG4gICAgICAgZXNjYXBld29ydGh5IGxpc3QsIHNvIHdlIGp1c3QgZml4IGl0IGluc3RlYWQgb2YgcmFpc2luZyBleGNlcHRpb24gdG8gbWFrZSB0aGlzXG4gICAgICAgZnVuY3Rpb24gZWFzaWVyIHRvIHVzZS4gICopXG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgZXNjYXBld29ydGh5XG4gICAgICB8PiBMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOkNoYXIuY29tcGFyZVxuICAgICAgfD4gTGlzdC5tYXAgfmY6KGZ1biBjIC0+IGMsIGMpXG4gICAgaW5cbiAgICBlc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXJcbiAgOztcblxuICAoKiBJbiBhbiBlc2NhcGVkIHN0cmluZywgYW55IGNoYXIgaXMgZWl0aGVyIGBFc2NhcGluZywgYEVzY2FwZWQgb3IgYExpdGVyYWwuIEZvclxuICAgICBleGFtcGxlLCB0aGUgZXNjYXBlIHN0YXR1c2VzIG9mIGNoYXJzIGluIHN0cmluZyBcImFfYV9fXCIgd2l0aCBlc2NhcGVfY2hhciA9ICdfJyBhcmVcblxuICAgICBhIDogYExpdGVyYWxcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBhIDogYEVzY2FwZWRcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBfIDogYEVzY2FwZWRcblxuICAgICBbdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHByZXZpb3VzX3N0YXR1c10gZ2V0cyBlc2NhcGUgc3RhdHVzIG9mXG4gICAgIHN0ci5baV0gYmFzaW5nIG9uIGVzY2FwZSBzdGF0dXMgb2Ygc3RyLltpIC0gMV0gKilcbiAgbGV0IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSA9IGZ1bmN0aW9uXG4gICAgfCBgRXNjYXBpbmcgLT4gYEVzY2FwZWRcbiAgICB8IGBMaXRlcmFsIHwgYEVzY2FwZWQgLT5cbiAgICAgIGlmIENoYXIuZXF1YWwgc3RyLltpXSBlc2NhcGVfY2hhciB0aGVuIGBFc2NhcGluZyBlbHNlIGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgYFVuZXNjYXBlIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayBlc2NhcGV3b3J0aHkgLT5cbiAgICAgIE9rXG4gICAgICAgIChmdW4gc3JjIC0+XG4gICAgICAgICAgICgqIENvbnRpbnVlIHRoZSBleGFtcGxlIGluIFtlc2NhcGVfZ2VuX2V4bl0sIG5vdyB3ZSB1bmVzY2FwZVxuXG4gICAgICAgICAgICAgIFwiMDAwX0ExMTFfQjIyMl9DMzMzXCJcblxuICAgICAgICAgICAgICBiYWNrIHRvXG5cbiAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgIFRoZW4gW3RvX3VuZXNjYXBlXSBpcyBbMTQ7IDk7IDRdLCB3aGljaCBpcyBpbmRleGVzIG9mICdfJ3MuXG5cbiAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBzdHJpbmcgW2RzdF0gdG8gc3RvcmUgdGhlIHJlc3VsdCwgY29weSBcIjMzM1wiIHRvIGl0LCB0aGVuIGNvcHlcbiAgICAgICAgICAgICAgJ2MnLCB0aGVuIG1vdmUgb24gdG8gbmV4dCBpdGVyYXRpb24uIEFmdGVyIDMgaXRlcmF0aW9ucyBjb3B5IFwiMDAwXCIgYW5kIHdlIGFyZVxuICAgICAgICAgICAgICBkb25lLiAgKilcbiAgICAgICAgICAgKCogaW5kZXhlcyBvZiBlc2NhcGUgY2hhcnMgKilcbiAgICAgICAgICAgbGV0IHRvX3VuZXNjYXBlID1cbiAgICAgICAgICAgICBsZXQgcmVjIGxvb3AgaSBzdGF0dXMgYWNjID1cbiAgICAgICAgICAgICAgIGlmIGkgPj0gbGVuZ3RoIHNyY1xuICAgICAgICAgICAgICAgdGhlbiBhY2NcbiAgICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzID0gdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3JjIH5lc2NhcGVfY2hhciBpIHN0YXR1cyBpblxuICAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgICAgICAgICAgIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IGBFc2NhcGluZyAtPiBpIDo6IGFjY1xuICAgICAgICAgICAgICAgICAgICB8IGBFc2NhcGVkIHwgYExpdGVyYWwgLT4gYWNjKSlcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGxvb3AgMCBgTGl0ZXJhbCBbXVxuICAgICAgICAgICBpblxuICAgICAgICAgICBtYXRjaCB0b191bmVzY2FwZSB3aXRoXG4gICAgICAgICAgIHwgW10gLT4gc3JjXG4gICAgICAgICAgIHwgaWR4IDo6IHRvX3VuZXNjYXBlJyAtPlxuICAgICAgICAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbmd0aCBzcmMgLSBMaXN0Lmxlbmd0aCB0b191bmVzY2FwZSkgaW5cbiAgICAgICAgICAgICBsZXQgcmVjIGxvb3AgbGFzdF9pZHggbGFzdF9kc3RfcG9zID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgW10gLT5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjAwMFwiIGF0IGxhc3QgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmxhc3RfaWR4XG4gICAgICAgICAgICAgICB8IGlkeCA6OiB0b191bmVzY2FwZSAtPlxuICAgICAgICAgICAgICAgICAoKiBbaWR4XSA9IGluZGV4IG9mIGVzY2FwaW5nIGNoYXIgKilcbiAgICAgICAgICAgICAgICAgKCogdGFrZSAxc3QgaXRlcmF0aW9uIGFzIGV4YW1wbGUsIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIFwiMzMzXCIsIG1pbnVzIDIgdG9cbiAgICAgICAgICAgICAgICAgICAgc2tpcCAnX0MnICopXG4gICAgICAgICAgICAgICAgIGxldCBsZW4gPSBsYXN0X2lkeCAtIGlkeCAtIDIgaW5cbiAgICAgICAgICAgICAgICAgKCogcG9pbnQgW2RzdF9wb3NdIHRvIHRoZSBwb3NpdGlvbiB0byBjb3B5IFwiMzMzXCIgdG8gKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBsYXN0X2RzdF9wb3MgLSBsZW4gaW5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjMzM1wiICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDIpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAgKCogYmFja29mZiBbZHN0X3Bvc10gYnkgMSB0byBjb3B5ICdjJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGRzdF9wb3MgLSAxIGluXG4gICAgICAgICAgICAgICAgIEJ5dGVzLnNldFxuICAgICAgICAgICAgICAgICAgIGRzdFxuICAgICAgICAgICAgICAgICAgIGRzdF9wb3NcbiAgICAgICAgICAgICAgICAgICAobWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBzcmMuW2lkeCArIDFdKSB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgLTEgLT4gc3JjLltpZHggKyAxXVxuICAgICAgICAgICAgICAgICAgICB8IG4gLT4gQ2hhci51bnNhZmVfb2ZfaW50IG4pO1xuICAgICAgICAgICAgICAgICAoKiB1cGRhdGUgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gKilcbiAgICAgICAgICAgICAgICAgbG9vcCBpZHggZHN0X3BvcyB0b191bmVzY2FwZVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgaWYgaWR4IDwgbGVuZ3RoIHNyYyAtIDFcbiAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAoKiBzZXQgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gdG8gbGVuZ3RoIG9mIFtkc3RdIGFuZCBbc3JjXSAqKVxuICAgICAgICAgICAgICAgbG9vcCAobGVuZ3RoIHNyYykgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgKCogZm9yIGVzY2FwZWQgc3RyaW5nIGVuZGluZyB3aXRoIGFuIGVzY2FwaW5nIGNoYXIgbGlrZSBcIjAwMF9cIiwganVzdCBpZ25vcmVcbiAgICAgICAgICAgICAgICAgIHRoZSBsYXN0IGVzY2FwaW5nIGNoYXIgKilcbiAgICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMgLSAxKSAoQnl0ZXMubGVuZ3RoIGRzdCkgdG9fdW5lc2NhcGUnO1xuICAgICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KVxuICA7O1xuXG4gIGxldCB1bmVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgT3JfZXJyb3Iub2tfZXhuICh1bmVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyKSB8PiBzdGFnZVxuICA7O1xuXG4gIGxldCB1bmVzY2FwZSB+ZXNjYXBlX2NoYXIgPSB1bmVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwOltdIH5lc2NhcGVfY2hhclxuXG4gIGxldCBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBsZXQgcmVjIGxvb3AgcCBjbnQgPVxuICAgICAgaWYgcCA8IDAgfHwgQ2hhci4oIDw+ICkgc3RyLltwXSBlc2NhcGVfY2hhciB0aGVuIGNudCBlbHNlIGxvb3AgKHAgLSAxKSAoY250ICsgMSlcbiAgICBpblxuICAgIGxvb3AgKHBvcyAtIDEpIDBcbiAgOztcblxuICAoKiBJbiBhbiBlc2NhcGVkIHN0cmluZywgYW55IGNoYXIgaXMgZWl0aGVyIGBFc2NhcGluZywgYEVzY2FwZWQgb3IgYExpdGVyYWwuIEZvclxuICAgICBleGFtcGxlLCB0aGUgZXNjYXBlIHN0YXR1c2VzIG9mIGNoYXJzIGluIHN0cmluZyBcImFfYV9fXCIgd2l0aCBlc2NhcGVfY2hhciA9ICdfJyBhcmVcblxuICAgICBhIDogYExpdGVyYWxcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBhIDogYEVzY2FwZWRcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBfIDogYEVzY2FwZWRcblxuICAgICBbdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHByZXZpb3VzX3N0YXR1c10gZ2V0cyBlc2NhcGUgc3RhdHVzIG9mXG4gICAgIHN0ci5baV0gYmFzaW5nIG9uIGVzY2FwZSBzdGF0dXMgb2Ygc3RyLltpIC0gMV0gKilcbiAgbGV0IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSA9IGZ1bmN0aW9uXG4gICAgfCBgRXNjYXBpbmcgLT4gYEVzY2FwZWRcbiAgICB8IGBMaXRlcmFsIHwgYEVzY2FwZWQgLT5cbiAgICAgIGlmIENoYXIuZXF1YWwgc3RyLltpXSBlc2NhcGVfY2hhciB0aGVuIGBFc2NhcGluZyBlbHNlIGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGxldCBvZGQgPSBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIG1vZCAyID0gMSBpblxuICAgIG1hdGNoIG9kZCwgQ2hhci5lcXVhbCBzdHIuW3Bvc10gZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgdHJ1ZSwgKHRydWUgfCBmYWxzZSkgLT4gYEVzY2FwZWRcbiAgICB8IGZhbHNlLCB0cnVlIC0+IGBFc2NhcGluZ1xuICAgIHwgZmFsc2UsIGZhbHNlIC0+IGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IGNoZWNrX2JvdW5kIHN0ciBwb3MgZnVuY3Rpb25fbmFtZSA9XG4gICAgaWYgcG9zID49IGxlbmd0aCBzdHIgfHwgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIiVzOiBvdXQgb2YgYm91bmRzXCIgZnVuY3Rpb25fbmFtZSAoKVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2VzY2FwaW5nIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9lc2NhcGluZ1wiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYEVzY2FwaW5nIC0+IHRydWVcbiAgICB8IGBFc2NhcGVkIHwgYExpdGVyYWwgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaXNfY2hhcl9lc2NhcGVkIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9lc2NhcGVkXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgRXNjYXBlZCAtPiB0cnVlXG4gICAgfCBgRXNjYXBpbmcgfCBgTGl0ZXJhbCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2xpdGVyYWwgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2xpdGVyYWxcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImluZGV4X2Zyb21cIjtcbiAgICBsZXQgcmVjIGxvb3AgaSBzdGF0dXMgPVxuICAgICAgaWYgaSA+PSBwb3NcbiAgICAgICYmIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgICAgICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2UpXG4gICAgICAmJiBDaGFyLmVxdWFsIHN0ci5baV0gY2hhclxuICAgICAgdGhlbiBTb21lIGlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaSA9IGkgKyAxIGluXG4gICAgICAgIGlmIGkgPj0gbGVuZ3RoIHN0clxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSBsb29wIGkgKHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMpKVxuICAgIGluXG4gICAgbG9vcCBwb3MgKGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3MpXG4gIDs7XG5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIG1hdGNoIGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCJcbiAgICAgICAgICAgWyBcInN0clwiLCBzZXhwX29mX3Qgc3RyXG4gICAgICAgICAgIDsgXCJlc2NhcGVfY2hhclwiLCBzZXhwX29mX2NoYXIgZXNjYXBlX2NoYXJcbiAgICAgICAgICAgOyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3NcbiAgICAgICAgICAgOyBcImNoYXJcIiwgc2V4cF9vZl9jaGFyIGNoYXJcbiAgICAgICAgICAgXSlcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICA7O1xuXG4gIGxldCBpbmRleCBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPSBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgMCBjaGFyXG4gIGxldCBpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBjaGFyID0gaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciAwIGNoYXJcblxuICBsZXQgcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcInJpbmRleF9mcm9tXCI7XG4gICAgKCogaWYgdGhlIHRhcmdldCBjaGFyIGlzIHRoZSBzYW1lIGFzIFtlc2NhcGVfY2hhcl0sIHdlIGhhdmUgbm8gd2F5IHRvIGRldGVybWluZSB3aGljaFxuICAgICAgIGVzY2FwZV9jaGFyIGlzIGxpdGVyYWwsIHNvIGp1c3QgcmV0dXJuIE5vbmUgKilcbiAgICBpZiBDaGFyLmVxdWFsIGNoYXIgZXNjYXBlX2NoYXJcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBwb3MgPVxuICAgICAgICBpZiBwb3MgPCAwXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgZXNjYXBlX2NoYXJzID0gcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBpblxuICAgICAgICAgIGlmIGVzY2FwZV9jaGFycyBtb2QgMiA9IDAgJiYgQ2hhci5lcXVhbCBzdHIuW3Bvc10gY2hhclxuICAgICAgICAgIHRoZW4gU29tZSBwb3NcbiAgICAgICAgICBlbHNlIGxvb3AgKHBvcyAtIGVzY2FwZV9jaGFycyAtIDEpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgcG9zKVxuICA7O1xuXG4gIGxldCByaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgbWF0Y2ggcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJyaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiXG4gICAgICAgICAgIFsgXCJzdHJcIiwgc2V4cF9vZl90IHN0clxuICAgICAgICAgICA7IFwiZXNjYXBlX2NoYXJcIiwgc2V4cF9vZl9jaGFyIGVzY2FwZV9jaGFyXG4gICAgICAgICAgIDsgXCJwb3NcIiwgc2V4cF9vZl9pbnQgcG9zXG4gICAgICAgICAgIDsgXCJjaGFyXCIsIHNleHBfb2ZfY2hhciBjaGFyXG4gICAgICAgICAgIF0pXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgOztcblxuICBsZXQgcmluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9XG4gICAgaWYgaXNfZW1wdHkgc3RyIHRoZW4gTm9uZSBlbHNlIHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgKGxlbmd0aCBzdHIgLSAxKSBjaGFyXG4gIDs7XG5cbiAgbGV0IHJpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBjaGFyID1cbiAgICByaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciAobGVuZ3RoIHN0ciAtIDEpIGNoYXJcbiAgOztcblxuICAoKiBbc3BsaXRfZ2VuIHN0ciB+ZXNjYXBlX2NoYXIgfm9uXSB3b3JrcyBzaW1pbGFybHkgdG8gW1N0cmluZy5zcGxpdF9nZW5dLCB3aXRoIGFuXG4gICAgIGFkZGl0aW9uYWwgcmVxdWlyZW1lbnQ6IG9ubHkgc3BsaXQgb24gbGl0ZXJhbCBjaGFycywgbm90IGVzY2FwaW5nIG9yIGVzY2FwZWQgKilcbiAgbGV0IHNwbGl0X2dlbiBzdHIgfmVzY2FwZV9jaGFyIH5vbiA9XG4gICAgbGV0IGlzX2RlbGltID1cbiAgICAgIG1hdGNoIG9uIHdpdGhcbiAgICAgIHwgYGNoYXIgYycgLT4gZnVuIGMgLT4gQ2hhci5lcXVhbCBjIGMnXG4gICAgICB8IGBjaGFyX2xpc3QgbCAtPiBmdW4gYyAtPiBjaGFyX2xpc3RfbWVtIGwgY1xuICAgIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGxvb3AgYWNjIHN0YXR1cyBsYXN0X3BvcyBwb3MgPVxuICAgICAgaWYgcG9zID0gbGVuXG4gICAgICB0aGVuIExpc3QucmV2IChzdWIgc3RyIH5wb3M6bGFzdF9wb3MgfmxlbjoobGVuIC0gbGFzdF9wb3MpIDo6IGFjYylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgc3RhdHVzID0gdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgc3RhdHVzIGluXG4gICAgICAgIGlmIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgICAgICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2UpXG4gICAgICAgICYmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihwb3MgLSBsYXN0X3BvcykgaW5cbiAgICAgICAgICBsb29wIChzdWJfc3RyIDo6IGFjYykgc3RhdHVzIChwb3MgKyAxKSAocG9zICsgMSkpXG4gICAgICAgIGVsc2UgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIChwb3MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgW10gYExpdGVyYWwgMCAwXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG4gIGxldCBzcGxpdF9vbl9jaGFycyBzdHIgfm9uOmNoYXJzID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyX2xpc3QgY2hhcnMpXG5cbiAgbGV0IHNwbGl0X2F0IHN0ciBwb3MgPVxuICAgIHN1YiBzdHIgfnBvczowIH5sZW46cG9zLCBzdWIgc3RyIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBzdHIgLSBwb3MgLSAxKVxuICA7O1xuXG4gIGxldCBsc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IHJzcGxpdDIgc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPVxuICAgIE9wdGlvbi5tYXAgKHJpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IGxzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBvbilcbiAgbGV0IHJzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChyaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG5cbiAgKCogW2xhc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYW5kIFtmaXJzdF9ub25fZHJvcF9saXRlcmFsXSBhcmUgZWl0aGVyIGJvdGggW05vbmVdIG9yIGJvdGhcbiAgICAgW1NvbWVdLiBJZiBbU29tZV0sIHRoZW4gdGhlIGZvcm1lciBpcyA+PSB0aGUgbGF0dGVyLiAqKVxuICBsZXQgbGFzdF9ub25fZHJvcF9saXRlcmFsIH5kcm9wIH5lc2NhcGVfY2hhciB0ID1cbiAgICByZmluZGkgdCB+ZjooZnVuIGkgYyAtPlxuICAgICAgKG5vdCAoZHJvcCBjKSlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBpbmcgdCB+ZXNjYXBlX2NoYXIgaVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGVkIHQgfmVzY2FwZV9jaGFyIGkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgbGZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbiAgOztcblxuICBsZXQgbHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgMCAtPiB0XG4gICAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG4gIDs7XG5cbiAgKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbiAgbGV0IHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gICAgKCogcGVyZm9ybWFuY2UgaGFjazogYXZvaWQgY29weWluZyBbdF0gaW4gY29tbW9uIGNhc2VzICopXG4gICAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuICA7O1xuZW5kXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuKCogT3ZlcnJpZGUgW1NlYXJjaF9wYXR0ZXJuXSB3aXRoIGRlZmF1bHQgY2FzZS1zZW5zaXRpdml0eSBhcmd1bWVudCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgZmlsZSwgc28gdGhhdCBjYWxsIHNpdGVzIGFib3ZlIGFyZSBmb3JjZWQgdG8gc3VwcGx5IGNhc2Utc2Vuc2l0aXZpdHkgZXhwbGljaXRseS4gKilcbm1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IHN0cnVjdFxuICBpbmNsdWRlIFNlYXJjaF9wYXR0ZXJuMFxuXG4gIGxldCBjcmVhdGUgPyhjYXNlX3NlbnNpdGl2ZSA9IHRydWUpIHBhdHRlcm4gPSBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmVcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5ODU2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJtb2R1bGVfbmFtZSIsIkJhc2VfQ2hhciIsIkJhc2VfSW1wb3J0IiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIiwiQmFzZV9TZXhwIiwiQmFzZV9Pcl9lcnJvciIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9CeXRlc190ciIsIkJhc2VfQXJyYXkwIiwiQmFzZV9MaXN0IiwiQmFzZV9QcmludGYiLCJTdGRsaWJfRm9ybWF0IiwiQmFzZV9TdGFnZWQiLCJCYXNlX0J5dGVzMCIsIkJhc2VfQmxpdCIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJzdGFnZSIsImdsb2JhbGl6ZSIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsInRfc2V4cF9ncmFtbWFyIiwibWF4X2xlbmd0aCIsImNvbXBhcmUiLCJjb3B5IiwiY3JlYXRlIiwiY3JlYXRlX2xvY2FsIiwiZmlsbCIsIm1ha2UiLCJtYXAiLCJtYXBpIiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nIiwicHAiLCJmbXQiLCJ0IiwibGVuIiwiVG9fYnl0ZXMiLCJibGl0IiwiYmxpdG8iLCJ1bnNhZmVfYmxpdCIsInN1YiIsInN1Ym8iLCJjb21wYXJhdG9yIiwiaW5jbHVkZSIsIlRvX3N0cmluZyIsImxlbmd0aCIsIkZyb21fc3RyaW5nIiwiY3N0X3RyX211bHRpX3JlcGxhY2VtZW50X2lzX3RoIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsImludmFyaWFudCIsInBhcmFtIiwiaW5pdCIsIm4iLCJpIiwib2ZfY2hhcl9saXN0IiwibCIsImMiLCJ0b19saXN0IiwiYWNjIiwidG9fYXJyYXkiLCJmb2xkIiwicG9zIiwiZm9sZGkiLCJ0ciIsInRhcmdldCIsInJlcGxhY2VtZW50IiwicyIsInRyX211bHRpIiwibWF0Y2giLCJ0cl9tYXAiLCJiZXR3ZWVuIiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsIm1pbiIsIm1heCIsImNsYW1wX2V4biIsImNsYW1wIiwiY29udGFpbnMiLCJjaGFyIiwibGFzdCIsInN5bWJvbCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJlcXVhbCIsIkJhc2VfQnl0ZXMiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9ieXRlcy5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFD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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHBHRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxubGV0IHN0YWdlID0gU3RhZ2VkLnN0YWdlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJ5dGVzIFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID0gKGdsb2JhbGl6ZV9ieXRlcyA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpXG4gIGxldCB0X29mX3NleHAgPSAoYnl0ZXNfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfYnl0ZXMgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gYnl0ZXNfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIEJ5dGVzMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5CeXRlc1wiXG4gIGxldCBwcCBmbXQgdCA9IFN0ZGxpYi5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlU1wiICh0b19zdHJpbmcgdClcbmVuZFxuXG5pbmNsdWRlIFRcblxubW9kdWxlIFRvX2J5dGVzID0gQmxpdC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgZW5kKVxuXG5pbmNsdWRlIFRvX2J5dGVzXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKFQpIChUb19ieXRlcylcblxubW9kdWxlIEZyb21fc3RyaW5nID1cbiAgQmxpdC5NYWtlX2Rpc3RpbmN0XG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIGVuZClcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgbiAwXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIkJ5dGVzLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gc2V0IHQgaSBjKTtcbiAgdFxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGkgMFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgKGkgLSAxKSAodW5zYWZlX2dldCB0IGkgOjogYWNjKVxuICBpblxuICBsb29wIHQgKGxlbmd0aCB0IC0gMSkgW11cbjs7XG5cbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcbmxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mXG5sZXQgbWFwaSB0IH5mID0gbWFwaSB0IH5mXG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgfmxlbiB+cG9zIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpIChmIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBwb3MgYWNjICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IH5mIH5sZW46KGxlbmd0aCB0KSB+cG9zOjAgaW5pdFxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzIGkpIHRhcmdldCB0aGVuIHVuc2FmZV9zZXQgcyBpIHJlcGxhY2VtZW50XG4gIGRvbmVcbjs7XG5cbmxldCB0cl9tdWx0aSB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAwXG4gIHRoZW4gc3RhZ2UgaWdub3JlXG4gIGVsc2UgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgMFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGk6IHJlcGxhY2VtZW50IGlzIHRoZSBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgaWdub3JlXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IHMgaSAoU3RyaW5nLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCAodW5zYWZlX2dldCBzIGkpKSlcbiAgICAgICAgZG9uZSkpXG47O1xuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgY29udGFpbnMgP3BvcyA/bGVuIHQgY2hhciA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbGFzdCA9IHBvcyArIGxlbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIGxhc3RcbiAgICAmJiAoQ2hhci5lcXVhbCAoZ2V0IHQgaSkgY2hhciB8fCBsb29wIChpICsgMSkpXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjAyMDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDMiLCJhMSIsImEyIiwiZ2xvYmFsX2RhdGEiLCJvY2FtbF9sZXhfdGFibGVzIiwiU3RkbGliX0xleGluZyIsInBhcnNlX2hleCIsImxleGJ1ZiIsIm9jYW1sX2xleF9zdGF0ZSIsImJvZHkiLCJCYXNlX0hleF9sZXhlciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2hleF9sZXhlci5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLE1BQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxZQUFBQyxVQUFBQztBQUFBQSxRQUFBQyxrQkM4SEc7QUFBQTtBQUFBO0FBQUEsTUFBQUE7QUFBQUEsUUFFSztBQUFBO0FBQUEsS0FBeUQ7QUFBQTtBQUFBLE9BQUFDO0FBQUFBLFNBTS9EO0FBQUEsTUR0SUY7QUFBQTtBQUFBLEtDZ0lpRTtBQUFBO0FBQUEsT0FBQUE7QUFBQUEsU0FnQi9EO0FBQUEsTURoSkY7QUFBQTtBQUFBLEtDcUp5QjtBQUFBLEtBQWdDO0FBQUE7QUFBQSxHQXZCcEI7QUFBQSxPQUFBQyxpQkQ5SHJDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIjIDEgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gXG50eXBlIHJlc3VsdCA9XG58IE5lZyBvZiBzdHJpbmdcbnwgUG9zIG9mIHN0cmluZ1xuXG4jIDggXCJzcmMvaGV4X2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAwXFwwMjdcXDAwMFxcMDgyXFwwMDBcXDEwNVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAxXFwwMDBcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X2NoZWNrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9iYXNlX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0X2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF90cmFuc19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY2hlY2tfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NvZGUgPVxuICAgXCJcIjtcbn1cblxubGV0IHJlYyBwYXJzZV9oZXggbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxMzUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAzKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBOZWcgYm9keSApXG4jIDEzOSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxubGV0XG4jIDggXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4jIDE0NSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZSBsZXhidWYgKGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyArIDIpIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcG9zIGluXG4jIDE1IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoIFBvcyBib2R5IClcbiMgMTQ5IFwic3JjL2hleF9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMDI2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfaW50IiwiY3N0X2ludDMyIiwiY3N0X2ludDY0IiwiY3N0X25hdGl2ZWludCIsImNzdF9zcmNfaW50X2NvbnZlcnNpb25zX21sIiwiY2FtbF9ieXRlc19zZXQiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSGV4X2xleGVyIiwiU3RkbGliX0xleGluZyIsIkJhc2VfT3B0aW9uIiwiQmFzZV9DaGFyIiwiQmFzZV9TdHJpbmciLCJCYXNlX1ByaW50ZiIsIkJhc2VfSW1wb3J0IiwiQmFzZV9TZXhwYWJsZSIsIkJhc2VfQnl0ZXMiLCJCYXNlX1N5czAiLCJCYXNlX1dvcmRfc2l6ZSIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0ludDMyIiwiU3RkbGliX0ludDY0IiwiU3RkbGliX05hdGl2ZWludCIsIkJhc2VfSW50MCIsIkJhc2VfU2V4cCIsImNvbnZlcnRfZmFpbHVyZSIsIngiLCJhIiwiYiIsInRvX3N0cmluZyIsIm51bV9iaXRzX2ludCIsIm51bV9iaXRzX25hdGl2ZWludCIsImNzdF8weCIsImNzdF9pbnQ2MyIsIm51bV9iaXRzX2ludDMyIiwibnVtX2JpdHNfaW50NjQiLCJtaW5faW50MzIiLCJtYXhfaW50MzIiLCJtaW5faW50NjQiLCJtYXhfaW50NjQiLCJtaW5fbmF0aXZlaW50IiwibWF4X25hdGl2ZWludCIsImludDY0X3RvX3N0cmluZyIsIm5hdGl2ZWludF90b19zdHJpbmciLCJpbnQzMl90b19pbnRfdHJ1bmMiLCJpbnRfdG9faW50MzJfdHJ1bmMiLCJpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiIsInBhcmFtIiwibWluIiwibWF4IiwiaW50X3RvX2ludDMyIiwiaW50MzJfdG9faW50IiwiaW50X3RvX2ludDMyX2V4biIsImludDMyX3RvX2ludF9leG4iLCJpbnRfdG9faW50NjQiLCJpbnQ2NF90b19pbnRfdHJ1bmMiLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCIsImludDY0X3RvX2ludCIsImludDY0X3RvX2ludF9leG4iLCJpbnRfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludF90cnVuYyIsIm5hdGl2ZWludF90b19pbnQiLCJuYXRpdmVpbnRfdG9faW50X2V4biIsImludDMyX3RvX2ludDY0IiwiaW50NjRfdG9faW50MzJfdHJ1bmMiLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMiLCJpbnQ2NF90b19pbnQzMiIsImludDY0X3RvX2ludDMyX2V4biIsImludDMyX3RvX25hdGl2ZWludCIsIm5hdGl2ZWludF90b19pbnQzMl90cnVuYyIsIm5hdGl2ZWludF90b19pbnQzMiIsIm5hdGl2ZWludF90b19pbnQzMl9leG4iLCJpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMiLCJuYXRpdmVpbnRfdG9faW50NjQiLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGkiLCJpbnQ2NF90b19uYXRpdmVpbnQiLCJpbnQ2NF90b19uYXRpdmVpbnRfZXhuIiwiaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2IiwiaW50NjRfZml0X29uX2ludDYzX2V4biIsImluc2VydF9kZWxpbWl0ZXJfZXZlcnkiLCJpbnB1dCIsImRlbGltaXRlciIsImNoYXJzX3Blcl9kZWxpbWl0ZXIiLCJpbnB1dF9sZW5ndGgiLCJtYXRjaCIsImhhc19zaWduIiwibnVtX2RpZ2l0cyIsIm51bV9kZWxpbWl0ZXJzIiwib3V0cHV0X2xlbmd0aCIsIm91dHB1dCIsImlucHV0X3BvcyIsIm91dHB1dF9wb3MiLCJudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyIiwiZmlyc3RfZGlnaXRfcG9zIiwiaW5zZXJ0X2RlbGltaXRlciIsImluc2VydF91bmRlcnNjb3JlcyIsInNleHBfb2ZfaW50X3N0eWxlIiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJJIiwidG9fc3RyaW5nX2h1bSIsIm9wdCIsInQiLCJzZXhwX29mX3QiLCJzIiwiY29tcGFyZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJtYWtlX3N1ZmZpeCIsImludmFsaWQiLCJzdHIiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJjIiwib2Zfc3RyaW5nIiwibGV4IiwicmVzdWx0IiwiYm9keSIsImluY2x1ZGUiLCJ0X3NleHBfZ3JhbW1hciIsInRfb2Zfc2V4cCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2ludF9jb252ZXJzaW9ucy5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVAsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElB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Q0FBdUI7QUFBQTtBQUFBLGlCQUFBNEIsUUFBQUM7QUFBQUEsU0FHOUQsb0RBQXNFO0FBQUE7QUFBQSxpQkFBQUMseUJBQUFEO0FBQUFBO0FBQUFBLFVBQUE7QUFBQSxZQUkxRDtBQUFBO0FBQUE7QUFBQSx1QkFBQUUsR0FBZ0MsdUNBQWlCO0FBQUEsU0FBRTtBQUFBO0FBQUEsaUJBQUFDLFVBQUFIO0FBQUFBO0FBQUFBLFVBQUFJLE1BS3JEO0FBQUEsVUFBQUM7QUFBQUEsWUFDRztBQUFBO0FBQUEsdUJBQUFwRSxPQUEyQix5Q0FBZTtBQUFBLFNBQ3ZELHNCQU1LLG1CQUFXO0FBQUEsU0FMWCxhQUVPLG1CQUdJO0FBQUEsYUFBQXFDLFFBTFg7QUFBQTtBQUFBLGNBQUFnQyxPQUFBLGdCQUd3QjtBQUFBLFVBQStCLDRCQUU1QztBQUFBO0FBQUEsYUFBQUEsU0FMWDtBQUFBLFNBSWtCLHVDQUNQO0FBQUE7QUFBQTtBQUFBLFNBQUFDLFVBdENoQjtBQUFBLFNBQUFDLGlCQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFqQixZQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQWxHSjtBQUFBO0FBQUE7QUFBQSxFRC9NRiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGNvbnZlcnRfZmFpbHVyZSB4IGEgYiB0b19zdHJpbmcgPVxuICBQcmludGYuZmFpbHdpdGhmXG4gICAgXCJjb252ZXJzaW9uIGZyb20gJXMgdG8gJXMgZmFpbGVkOiAlcyBpcyBvdXQgb2YgcmFuZ2VcIlxuICAgIGFcbiAgICBiXG4gICAgKHRvX3N0cmluZyB4KVxuICAgICgpXG5bQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuOztcblxubGV0IG51bV9iaXRzX2ludCA9IFN5cy5pbnRfc2l6ZV9pbl9iaXRzXG5sZXQgbnVtX2JpdHNfaW50MzIgPSAzMlxubGV0IG51bV9iaXRzX2ludDY0ID0gNjRcbmxldCBudW1fYml0c19uYXRpdmVpbnQgPSBXb3JkX3NpemUubnVtX2JpdHMgV29yZF9zaXplLndvcmRfc2l6ZVxubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQgPSA2MyB8fCBudW1fYml0c19pbnQgPSAzMSB8fCBudW1fYml0c19pbnQgPSAzMilcbmxldCBtaW5faW50MzIgPSBTdGRsaWIuSW50MzIubWluX2ludFxubGV0IG1heF9pbnQzMiA9IFN0ZGxpYi5JbnQzMi5tYXhfaW50XG5sZXQgbWluX2ludDY0ID0gU3RkbGliLkludDY0Lm1pbl9pbnRcbmxldCBtYXhfaW50NjQgPSBTdGRsaWIuSW50NjQubWF4X2ludFxubGV0IG1pbl9uYXRpdmVpbnQgPSBTdGRsaWIuTmF0aXZlaW50Lm1pbl9pbnRcbmxldCBtYXhfbmF0aXZlaW50ID0gU3RkbGliLk5hdGl2ZWludC5tYXhfaW50XG5sZXQgaW50X3RvX3N0cmluZyA9IFN0ZGxpYi5zdHJpbmdfb2ZfaW50XG5sZXQgaW50MzJfdG9fc3RyaW5nID0gU3RkbGliLkludDMyLnRvX3N0cmluZ1xubGV0IGludDY0X3RvX3N0cmluZyA9IFN0ZGxpYi5JbnQ2NC50b19zdHJpbmdcbmxldCBuYXRpdmVpbnRfdG9fc3RyaW5nID0gU3RkbGliLk5hdGl2ZWludC50b19zdHJpbmdcblxuKCogaW50IDwtPiBpbnQzMiAqKVxuXG5sZXQgaW50X3RvX2ludDMyX2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50XCIgXCJpbnQzMlwiIGludF90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQzMlwiIFwiaW50XCIgaW50MzJfdG9fc3RyaW5nXG5sZXQgaW50MzJfdG9faW50X3RydW5jID0gU3RkbGliLkludDMyLnRvX2ludFxubGV0IGludF90b19pbnQzMl90cnVuYyA9IFN0ZGxpYi5JbnQzMi5vZl9pbnRcblxubGV0IGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9faW50X3RydW5jIG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19pbnRfdHJ1bmMgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludCB4IG1heCA8PSAwKVxuOztcblxubGV0IGludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgaWYgbnVtX2JpdHNfaW50MzIgPD0gbnVtX2JpdHNfaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50X3RvX2ludDMyX3RydW5jIEludC5taW5fdmFsdWUgaW5cbiAgICBsZXQgbWF4ID0gaW50X3RvX2ludDMyX3RydW5jIEludC5tYXhfdmFsdWUgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX2ludDMyIG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQzMiB4IG1heCA8PSAwKVxuOztcblxubGV0IGludF90b19pbnQzMiB4ID1cbiAgaWYgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeCB0aGVuIFNvbWUgKGludF90b19pbnQzMl90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQzMl90b19pbnQgeCA9XG4gIGlmIGludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBTb21lIChpbnQzMl90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50X3RvX2ludDMyX2V4biB4ID1cbiAgaWYgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeCB0aGVuIGludF90b19pbnQzMl90cnVuYyB4IGVsc2UgaW50X3RvX2ludDMyX2ZhaWx1cmUgeFxuOztcblxubGV0IGludDMyX3RvX2ludF9leG4geCA9XG4gIGlmIGludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQzMl90b19pbnRfdHJ1bmMgeCBlbHNlIGludDMyX3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gaW50NjQgKilcblxubGV0IGludDY0X3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnRcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50IDwgbnVtX2JpdHNfaW50NjQpXG5sZXQgaW50X3RvX2ludDY0ID0gU3RkbGliLkludDY0Lm9mX2ludFxubGV0IGludDY0X3RvX2ludF90cnVuYyA9IFN0ZGxpYi5JbnQ2NC50b19pbnRcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgbGV0IG1pbiA9IGludF90b19pbnQ2NCBJbnQubWluX3ZhbHVlIGluXG4gIGxldCBtYXggPSBpbnRfdG9faW50NjQgSW50Lm1heF92YWx1ZSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQ2NF90b19pbnRfdHJ1bmMgeCBlbHNlIGludDY0X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnRcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50X3RvX25hdGl2ZWludCA9IFN0ZGxpYi5OYXRpdmVpbnQub2ZfaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludF90cnVuYyA9IFN0ZGxpYi5OYXRpdmVpbnQudG9faW50XG5cbmxldCBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19uYXRpdmVpbnQgPD0gbnVtX2JpdHNfaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50X3RvX25hdGl2ZWludCBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19uYXRpdmVpbnQgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfbmF0aXZlaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9uYXRpdmVpbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50IHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludF9leG4geCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludF90cnVuYyB4XG4gIGVsc2UgbmF0aXZlaW50X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBpbnQ2NCAqKVxuXG5sZXQgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50MzJcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnQzMl90b19pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9pbnQzMlxubGV0IGludDY0X3RvX2ludDMyX3RydW5jID0gU3RkbGliLkludDY0LnRvX2ludDMyXG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgbGV0IG1pbiA9IGludDMyX3RvX2ludDY0IG1pbl9pbnQzMiBpblxuICBsZXQgbWF4ID0gaW50MzJfdG9faW50NjQgbWF4X2ludDMyIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQzMiB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBpbnQ2NF90b19pbnQzMl90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQzMiA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4ID1cbiAgY29udmVydF9mYWlsdXJlIHggXCJuYXRpdmVpbnRcIiBcImludDMyXCIgbmF0aXZlaW50X3RvX3N0cmluZ1xuOztcblxubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50MzJfdG9fbmF0aXZlaW50ID0gU3RkbGliLk5hdGl2ZWludC5vZl9pbnQzMlxubGV0IG5hdGl2ZWludF90b19pbnQzMl90cnVuYyA9IFN0ZGxpYi5OYXRpdmVpbnQudG9faW50MzJcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfbmF0aXZlaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9fbmF0aXZlaW50IG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19uYXRpdmVpbnQgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMiB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQ2NCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwibmF0aXZlaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDY0ID49IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgPSBTdGRsaWIuSW50NjQudG9fbmF0aXZlaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludDY0ID0gU3RkbGliLkludDY0Lm9mX25hdGl2ZWludFxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgPVxuICBpZiBudW1fYml0c19pbnQ2NCA8PSBudW1fYml0c19uYXRpdmVpbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBuYXRpdmVpbnRfdG9faW50NjQgbWluX25hdGl2ZWludCBpblxuICAgIGxldCBtYXggPSBuYXRpdmVpbnRfdG9faW50NjQgbWF4X25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCB4XG4gIHRoZW4gU29tZSAoaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIHgpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX25hdGl2ZWludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX25hdGl2ZWludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDY0IDwtPiBpbnQ2MyAqKVxuXG5sZXQgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50NjNcIiBpbnQ2NF90b19zdHJpbmdcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgPVxuICBsZXQgbWluID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0IG1pbl9pbnQ2NCAxIGluXG4gIGxldCBtYXggPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgbWF4X2ludDY0IDEgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X2ZpdF9vbl9pbnQ2M19leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgeCB0aGVuICgpIGVsc2UgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4XG47O1xuXG4oKiBzdHJpbmcgY29udmVyc2lvbnMgKilcblxubGV0IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlciA9XG4gIGxldCBpbnB1dF9sZW5ndGggPSBTdHJpbmcubGVuZ3RoIGlucHV0IGluXG4gIGlmIGlucHV0X2xlbmd0aCA8PSBjaGFyc19wZXJfZGVsaW1pdGVyXG4gIHRoZW4gaW5wdXRcbiAgZWxzZSAoXG4gICAgbGV0IGhhc19zaWduID1cbiAgICAgIG1hdGNoIGlucHV0LlswXSB3aXRoXG4gICAgICB8ICcrJyB8ICctJyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBudW1fZGlnaXRzID0gaWYgaGFzX3NpZ24gdGhlbiBpbnB1dF9sZW5ndGggLSAxIGVsc2UgaW5wdXRfbGVuZ3RoIGluXG4gICAgbGV0IG51bV9kZWxpbWl0ZXJzID0gKG51bV9kaWdpdHMgLSAxKSAvIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgb3V0cHV0X2xlbmd0aCA9IGlucHV0X2xlbmd0aCArIG51bV9kZWxpbWl0ZXJzIGluXG4gICAgbGV0IG91dHB1dCA9IEJ5dGVzLmNyZWF0ZSBvdXRwdXRfbGVuZ3RoIGluXG4gICAgbGV0IGlucHV0X3BvcyA9IHJlZiAoaW5wdXRfbGVuZ3RoIC0gMSkgaW5cbiAgICBsZXQgb3V0cHV0X3BvcyA9IHJlZiAob3V0cHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgPSByZWYgY2hhcnNfcGVyX2RlbGltaXRlciBpblxuICAgIGxldCBmaXJzdF9kaWdpdF9wb3MgPSBpZiBoYXNfc2lnbiB0aGVuIDEgZWxzZSAwIGluXG4gICAgd2hpbGUgIWlucHV0X3BvcyA+PSBmaXJzdF9kaWdpdF9wb3MgZG9cbiAgICAgIGlmICFudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXRwdXQgIW91dHB1dF9wb3MgZGVsaW1pdGVyO1xuICAgICAgICBkZWNyIG91dHB1dF9wb3M7XG4gICAgICAgIG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgOj0gY2hhcnNfcGVyX2RlbGltaXRlcik7XG4gICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGlucHV0LlshaW5wdXRfcG9zXTtcbiAgICAgIGRlY3IgaW5wdXRfcG9zO1xuICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgZGVjciBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyXG4gICAgZG9uZTtcbiAgICBpZiBoYXNfc2lnbiB0aGVuIEJ5dGVzLnNldCBvdXRwdXQgMCBpbnB1dC5bMF07XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXRwdXQpXG47O1xuXG5sZXQgaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyID1cbiAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBpbnB1dCB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyOjNcbjs7XG5cbmxldCBpbnNlcnRfdW5kZXJzY29yZXMgaW5wdXQgPSBpbnNlcnRfZGVsaW1pdGVyIGlucHV0IH5kZWxpbWl0ZXI6J18nXG5sZXQgc2V4cF9vZl9pbnRfc3R5bGUgPSBTZXhwLm9mX2ludF9zdHlsZVxuXG5tb2R1bGUgTWFrZSAoSSA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gIGVuZCkgPVxuc3RydWN0XG4gIG9wZW4gSVxuXG4gIGxldCBjaGFyc19wZXJfZGVsaW1pdGVyID0gM1xuXG4gIGxldCB0b19zdHJpbmdfaHVtID8oZGVsaW1pdGVyID0gJ18nKSB0ID1cbiAgICBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5ICh0b19zdHJpbmcgdCkgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlclxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgbGV0IHMgPSB0b19zdHJpbmcgdCBpblxuICAgIFNleHAuQXRvbVxuICAgICAgKG1hdGNoICFzZXhwX29mX2ludF9zdHlsZSB3aXRoXG4gICAgICAgfCBgVW5kZXJzY29yZXMgLT4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBzIH5jaGFyc19wZXJfZGVsaW1pdGVyIH5kZWxpbWl0ZXI6J18nXG4gICAgICAgfCBgTm9fdW5kZXJzY29yZXMgLT4gcylcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9oZXggKEkgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2hhc2hfbGliLkhhc2hhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuICAgIHZhbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gdFxuICAgIHZhbCB6ZXJvIDogdFxuICAgIHZhbCAoIDwgKSA6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIG5lZyA6IHQgLT4gdFxuICAgIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgVF9oZXggPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBJLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChJLmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgSS5oYXNoX2ZvbGRfdFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBJLmhhc2ggaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNoYXJzX3Blcl9kZWxpbWl0ZXIgPSA0XG5cbiAgICBsZXQgdG9fc3RyaW5nJyA/ZGVsaW1pdGVyIHQgPVxuICAgICAgbGV0IG1ha2Vfc3VmZml4ID1cbiAgICAgICAgbWF0Y2ggZGVsaW1pdGVyIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEkudG9fc3RyaW5nXG4gICAgICAgIHwgU29tZSBkZWxpbWl0ZXIgLT5cbiAgICAgICAgICBmdW4gdCAtPiBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IChJLnRvX3N0cmluZyB0KSB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyXG4gICAgICBpblxuICAgICAgaWYgSS4oIDwgKSB0IEkuemVybyB0aGVuIFwiLTB4XCIgXiBtYWtlX3N1ZmZpeCAoSS5uZWcgdCkgZWxzZSBcIjB4XCIgXiBtYWtlX3N1ZmZpeCB0XG4gICAgOztcblxuICAgIGxldCB0b19zdHJpbmcgdCA9IHRvX3N0cmluZycgdCA/ZGVsaW1pdGVyOk5vbmVcbiAgICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9IHRvX3N0cmluZycgdCB+ZGVsaW1pdGVyXG5cbiAgICBsZXQgaW52YWxpZCBzdHIgPVxuICAgICAgUHJpbnRmLmZhaWx3aXRoZiBcIiVzLm9mX3N0cmluZzogaW52YWxpZCBpbnB1dCAlU1wiIEkubW9kdWxlX25hbWUgc3RyICgpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIgc3RyID1cbiAgICAgIEkub2Zfc3RyaW5nIChTdHJpbmcuZmlsdGVyIHN0ciB+ZjooZnVuIGMgLT4gQ2hhci4oIDw+ICkgYyAnXycpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nIHN0ciA9XG4gICAgICBsZXQgbW9kdWxlIEwgPSBIZXhfbGV4ZXIgaW5cbiAgICAgIGxldCBsZXggPSBTdGRsaWIuTGV4aW5nLmZyb21fc3RyaW5nIHN0ciBpblxuICAgICAgbGV0IHJlc3VsdCA9IE9wdGlvbi50cnlfd2l0aCAoZnVuICgpIC0+IEwucGFyc2VfaGV4IGxleCkgaW5cbiAgICAgIGlmIGxleC5sZXhfY3Vycl9wb3MgPSBsZXgubGV4X2J1ZmZlcl9sZW5cbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gaW52YWxpZCBzdHJcbiAgICAgICAgfCBTb21lIChOZWcgYm9keSkgLT4gSS5uZWcgKG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgICB8IFNvbWUgKFBvcyBib2R5KSAtPiBvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIgYm9keSlcbiAgICAgIGVsc2UgaW52YWxpZCBzdHJcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgSGV4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBUX2hleFxuICAgIGluY2x1ZGUgU2V4cGFibGUuT2Zfc3RyaW5nYWJsZSAoVF9oZXgpXG4gIGVuZFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjA3MjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9JbnRhYmxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxlQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjA3MzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9JbnRfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZ0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMDc0NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMiIsImYiLCJhMCIsImExIiwiZ2xvYmFsX2RhdGEiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW4iLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUiLCJCYXNlX0ltcG9ydCIsIkJhc2VfSW50X2NvbnZlcnNpb25zIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0FycmF5MCIsImludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsIm92ZXJmbG93X2JvdW5kX21heF9pbnRfdmFsdWUiLCJzd2l0Y2hlciIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQzMl92YWx1ZSIsImludF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMiLCJpbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmwiLCJpbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMiLCJpbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMiLCJCYXNlX1Bvd19vdmVyZmxvd19ib3VuZHMiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9wb3dfb3ZlcmZsb3dfYm91bmRzLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLCtCQ2dGRTtBQUFBLElBQUFDLFdBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUE7QUFBQTtBQUFBLEtBeUlIO0FBQUE7QUFBQSxLQUFBQztBQUFBQSxPQW5JTDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBQUE7QUFBQUEsT0FOUTtBQUFBLFVBSUY7QUFBQTtBQUFBO0FBQUEseUJEcEZWO0FBQUEsVUN3Skk7QUFBQTtBQUFBLElBQUFDLGlDQXhFUTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURoRloiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSB3YXMgYXV0b2dlbmVyYXRlZCBieSAuLi9nZW5lcmF0ZS9nZW5lcmF0ZV9wb3dfb3ZlcmZsb3dfYm91bmRzLmV4ZSAqKVxuXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbigqIFdlIGhhdmUgdG8gdXNlIEludDY0LnRvX2ludF9leG4gaW5zdGVhZCBvZiBpbnQgY29uc3RhbnRzIHRvIG1ha2VcbiAgIHN1cmUgdGhhdCBmaWxlIGNhbiBiZSBwcmVwcm9jZXNzZWQgb24gMzItYml0IG1hY2hpbmVzLiAqKVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIDogaW50MzIgPVxuICAyMTQ3NDgzNjQ3bFxuXG5sZXQgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50MzIgYXJyYXkgPVxuICBbfCAyMTQ3NDgzNjQ3bFxuICA7ICAyMTQ3NDgzNjQ3bFxuICA7ICA0NjM0MGxcbiAgOyAgMTI5MGxcbiAgOyAgMjE1bFxuICA7ICA3M2xcbiAgOyAgMzVsXG4gIDsgIDIxbFxuICA7ICAxNGxcbiAgOyAgMTBsXG4gIDsgIDhsXG4gIDsgIDdsXG4gIDsgIDVsXG4gIDsgIDVsXG4gIDsgIDRsXG4gIDsgIDRsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIHxdXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50X3ZhbHVlIDogaW50ID1cbiAgKC0xKSBsc3IgMVxuXG5sZXQgaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludCBhcnJheSA9XG4gIG1hdGNoIEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnQgd2l0aFxuICB8IDMyIC0+IEFycmF5Lm1hcCBpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgfmY6U3RkbGliLkludDMyLnRvX2ludFxuICB8IDYzIC0+XG4gICAgW3wgU3RkbGliLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgIDsgIFN0ZGxpYi5JbnQ2NC50b19pbnQgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgICA7ICBTdGRsaWIuSW50NjQudG9faW50IDIxNDc0ODM2NDdMXG4gICAgOyAgMTY2NDUxMFxuICAgIDsgIDQ2MzQwXG4gICAgOyAgNTQwNFxuICAgIDsgIDEyOTBcbiAgICA7ICA0NjNcbiAgICA7ICAyMTVcbiAgICA7ICAxMThcbiAgICA7ICA3M1xuICAgIDsgIDQ5XG4gICAgOyAgMzVcbiAgICA7ICAyN1xuICAgIDsgIDIxXG4gICAgOyAgMTdcbiAgICA7ICAxNFxuICAgIDsgIDEyXG4gICAgOyAgMTBcbiAgICA7ICA5XG4gICAgOyAgOFxuICAgIDsgIDdcbiAgICA7ICA3XG4gICAgOyAgNlxuICAgIDsgIDVcbiAgICA7ICA1XG4gICAgOyAgNVxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICB8XVxuICB8IDMxIC0+XG4gICAgW3wgMTA3Mzc0MTgyM1xuICAgIDsgIDEwNzM3NDE4MjNcbiAgICA7ICAzMjc2N1xuICAgIDsgIDEwMjNcbiAgICA7ICAxODFcbiAgICA7ICA2M1xuICAgIDsgIDMxXG4gICAgOyAgMTlcbiAgICA7ICAxM1xuICAgIDsgIDEwXG4gICAgOyAgN1xuICAgIDsgIDZcbiAgICA7ICA1XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgfF1cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDYzX29uX2ludDY0X3ZhbHVlIDogaW50NjQgPVxuICA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuXG5sZXQgaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICA7ICA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICA7ICAyMTQ3NDgzNjQ3TFxuICA7ICAxNjY0NTEwTFxuICA7ICA0NjM0MExcbiAgOyAgNTQwNExcbiAgOyAgMTI5MExcbiAgOyAgNDYzTFxuICA7ICAyMTVMXG4gIDsgIDExOExcbiAgOyAgNzNMXG4gIDsgIDQ5TFxuICA7ICAzNUxcbiAgOyAgMjdMXG4gIDsgIDIxTFxuICA7ICAxN0xcbiAgOyAgMTRMXG4gIDsgIDEyTFxuICA7ICAxMExcbiAgOyAgOUxcbiAgOyAgOExcbiAgOyAgN0xcbiAgOyAgN0xcbiAgOyAgNkxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMUxcbiAgOyAgMUxcbiAgfF1cblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQ2NF92YWx1ZSA6IGludDY0ID1cbiAgOTIyMzM3MjAzNjg1NDc3NTgwN0xcblxubGV0IGludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgMzAzNzAwMDQ5OUxcbiAgOyAgMjA5NzE1MUxcbiAgOyAgNTUxMDhMXG4gIDsgIDYyMDhMXG4gIDsgIDE0NDhMXG4gIDsgIDUxMUxcbiAgOyAgMjM0TFxuICA7ICAxMjdMXG4gIDsgIDc4TFxuICA7ICA1MkxcbiAgOyAgMzhMXG4gIDsgIDI4TFxuICA7ICAyMkxcbiAgOyAgMThMXG4gIDsgIDE1TFxuICA7ICAxM0xcbiAgOyAgMTFMXG4gIDsgIDlMXG4gIDsgIDhMXG4gIDsgIDdMXG4gIDsgIDdMXG4gIDsgIDZMXG4gIDsgIDZMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDFMXG4gIHxdXG5cbmxldCBpbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAtOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgLTMwMzcwMDA0OTlMXG4gIDsgIC0yMDk3MTUxTFxuICA7ICAtNTUxMDhMXG4gIDsgIC02MjA4TFxuICA7ICAtMTQ0OExcbiAgOyAgLTUxMUxcbiAgOyAgLTIzNExcbiAgOyAgLTEyN0xcbiAgOyAgLTc4TFxuICA7ICAtNTJMXG4gIDsgIC0zOExcbiAgOyAgLTI4TFxuICA7ICAtMjJMXG4gIDsgIC0xOExcbiAgOyAgLTE1TFxuICA7ICAtMTNMXG4gIDsgIC0xMUxcbiAgOyAgLTlMXG4gIDsgIC04TFxuICA7ICAtN0xcbiAgOyAgLTdMXG4gIDsgIC02TFxuICA7ICAtNkxcbiAgOyAgLTVMXG4gIDsgIC01TFxuICA7ICAtNUxcbiAgOyAgLTRMXG4gIDsgIC00TFxuICA7ICAtNExcbiAgOyAgLTRMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMUxcbiAgfF1cbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMTIwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfZXhwb25lbnRfY2FuX25vdF9iZV9uZWdhdGkiLCJjc3RfaW50ZWdlcl9vdmVyZmxvd19pbl9wb3ciLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDQiLCJhMiIsImEzIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfUG93X292ZXJmbG93X2JvdW5kcyIsIkJhc2VfUHJpbnRmIiwiU3RkbGliX0ludDY0IiwiaW52YWxpZF9hcmdmIiwibmVnYXRpdmVfZXhwb25lbnQiLCJwYXJhbSIsIm92ZXJmbG93IiwiaW50X3BvdyIsImJhc2UiLCJleHBvbmVudCIsImFicyIsImludDY0X3BvdyIsImludDYzX3Bvd19vbl9pbnQ2NCIsIlByaXZhdGUiLCJCYXNlX0ludF9tYXRoIiwiWCIsInN5bWJvbCIsIngiLCJ5IiwicnZhbCIsIm9uZSIsInJvdW5kX2Rvd24iLCJpIiwibW9kdWx1cyIsInJvdW5kX3VwIiwicmVtYWluZGVyIiwicm91bmRfdG93YXJkc196ZXJvIiwidG9fbXVsdGlwbGVfb2YiLCJyb3VuZF9uZWFyZXN0IiwibW9kdWx1c19taW51c19yZW1haW5kZXIiLCJyb3VuZCIsIm9wdCIsImRpciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2ludF9tYXRoLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLGtCQUFBQztBQUFBQSxJQ0cyQix5Q0FBcUQ7QUFBQTtBQUFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdEM0Z4QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5sZXQgbmVnYXRpdmVfZXhwb25lbnQgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiZXhwb25lbnQgY2FuIG5vdCBiZSBuZWdhdGl2ZVwiICgpXG5sZXQgb3ZlcmZsb3cgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiaW50ZWdlciBvdmVyZmxvdyBpbiBwb3dcIiAoKVxuXG4oKiBUbyBpbXBsZW1lbnQgW2ludDY0X3Bvd10sIHdlIHVzZSBDIGNvZGUgcmF0aGVyIHRoYW4gT0NhbWwgdG8gZWxpbWluYXRlIGFsbG9jYXRpb24uICopXG5leHRlcm5hbCBpbnRfbWF0aF9pbnRfcG93IDogaW50IC0+IGludCAtPiBpbnQgPSBcIkJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGludF9tYXRoX2ludDY0X3BvdyA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViXCJcblxubGV0IGludF9wb3cgYmFzZSBleHBvbmVudCA9XG4gIGlmIGV4cG9uZW50IDwgMCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFcbiAgJiYgKGV4cG9uZW50ID4gNjNcbiAgICAgIHx8IGFicyBiYXNlID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLihleHBvbmVudCkpXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIEludDY0X3dpdGhfY29tcGFyaXNvbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdGRsaWIuSW50NjRcblxuICBleHRlcm5hbCAoIDwgKSA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoID4gKSA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoID49ICkgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5lbmRcblxuKCogd2UgZG9uJ3QgZG8gW2Fic10gaW4gaW50NjQgY2FzZSB0byBhdm9pZCBhbGxvY2F0aW9uICopXG5sZXQgaW50NjRfcG93IGJhc2UgZXhwb25lbnQgPVxuICBsZXQgb3BlbiBJbnQ2NF93aXRoX2NvbXBhcmlzb25zIGluXG4gIGlmIGV4cG9uZW50IDwgMEwgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgKGJhc2UgPiAxTCB8fCBiYXNlIDwgLTFMKVxuICAmJiAoZXhwb25lbnQgPiA2M0xcbiAgICAgIHx8IChiYXNlID49IDBMXG4gICAgICAgICAgJiYgYmFzZVxuICAgICAgICAgICAgID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudCkpXG4gICAgICB8fCAoYmFzZSA8IDBMXG4gICAgICAgICAgJiYgYmFzZVxuICAgICAgICAgICAgIDwgUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudCkpKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubGV0IGludDYzX3Bvd19vbl9pbnQ2NCBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIGFicyBiYXNlID4gMUxcbiAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICB8fCBhYnMgYmFzZVxuICAgICAgICAgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICApXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludDY0X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5tb2R1bGUgdHlwZSBNYWtlX2FyZyA9IHNpZ1xuICB0eXBlIHRcblxuICBpbmNsdWRlIEZsb2F0YWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBTdHJpbmdhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoICogKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC8gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIH4tICkgOiB0IC0+IHRcblxuICBpbmNsdWRlIENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgYWJzIDogdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCBvZl9pbnRfZXhuIDogaW50IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG5lbmRcblxubW9kdWxlIE1ha2UgKFggOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgb3BlbiBYXG5cbiAgbGV0ICggJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gWC5yZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgb25lID0gb2ZfaW50X2V4biAxXG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gICgqKiBmbG9hdCBkaXZpc2lvbiBvZiBpbnRlZ2VycyAqKVxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGxldCByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPSBpIC0gKGkgJSBtb2R1bHVzKVxuXG4gIGxldCByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBpZiByZW1haW5kZXIgPSB6ZXJvIHRoZW4gaSBlbHNlIGkgKyBtb2R1bHVzIC0gcmVtYWluZGVyXG4gIDs7XG5cbiAgbGV0IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZiA9XG4gICAgaWYgaSA9IHplcm9cbiAgICB0aGVuIHplcm9cbiAgICBlbHNlIGlmIGkgPiB6ZXJvXG4gICAgdGhlbiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgZWxzZSByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuXG4gIGxldCByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPVxuICAgIGxldCByZW1haW5kZXIgPSBpICUgbW9kdWx1cyBpblxuICAgIGxldCBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA9IG1vZHVsdXMgLSByZW1haW5kZXIgaW5cbiAgICBpZiBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA8PSByZW1haW5kZXJcbiAgICB0aGVuIGkgKyBtb2R1bHVzX21pbnVzX3JlbWFpbmRlclxuICAgIGVsc2UgaSAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIG1hdGNoIGRpciB3aXRoXG4gICAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgRG93biAtPiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgVXAgLT4gcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBpbnRfcG93ID0gaW50X3Bvd1xuICBsZXQgaW50NjRfcG93ID0gaW50NjRfcG93XG4gIGxldCBpbnQ2M19wb3dfb25faW50NjQgPSBpbnQ2M19wb3dfb25faW50NjRcblxuICBtb2R1bGUgUG93X292ZXJmbG93X2JvdW5kcyA9IFBvd19vdmVyZmxvd19ib3VuZHNcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxNDQ4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9hbmQiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiZ2xvYmFsX2RhdGEiLCJtMSIsIm0yIiwibTQiLCJoMDEiLCJtYXNrIiwiU3RkbGliX05hdGl2ZWludCIsIkFzc2VydF9mYWlsdXJlIiwiaW50NjRfcG9wY291bnQiLCJ4IiwiaW50MzJfcG9wY291bnQiLCJuYXRpdmVpbnRfcG9wY291bnQiLCJCYXNlX1BvcGNvdW50Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvcG9wY291bnQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxlQUFBQztBQUFBQTtBQUFBQSxLQUFBQTtBQUFBQSxPQ3lCWTtBQUFBLGNBQUksZUFBQztBQUFBLEtBQUFBO0FBQUFBLE9BRUw7QUFBQTtBQUFBLFNBQWMsZUFBQztBQUFBLEtBQUFBO0FBQUFBLE9BRWY7QUFBQSwyQkFBSztBQUFBLElBRUwsT0FBaUI7QUFBQSxhQUFsQjtBQUFBLGVBQUMsc0NBQWlCO0FBQUE7QUFBQSxZQUFBQyxlQUFBRDtBQUFBQSxJQU00QixPQUErQixlQUFwRCxlQUFxQiw4QkFBK0I7QUFBQTtBQUFBLGFBQXRGO0FBQUE7QUFBQSxRQUFBRSxxQkFLUSxTQUFBRixHQUFtQix3QkFBNEM7QUFBQTtBQUFBLElBTHZFO0FBQUEsS0FPTztBQUFBO0FBQUEsS0FBQUU7QUFBQUEsT0FEQyxTQUFBRixHQUFrQyxPQUE2QixlQUE3Qix1QkFBNkI7QUFBQTtBQUFBO0FBQUEsSUFBQUc7QUFBQUEsTUFOdkU7QUFBQSxxQkRyQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQ3FDRTtBQUFBO0FBQUEsRURyQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG4oKiBDIHN0dWIgZm9yIGludCBwb3Bjb3VudCB0byB1c2UgdGhlIFBPUENOVCBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuZXh0ZXJuYWwgaW50X3BvcGNvdW50IDogaW50IC0+IGludCA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnRcIiBbQEBub2FsbG9jXVxuXG4oKiBUbyBtYWludGFpbiBqYXZhc2NyaXB0IGNvbXBhdGliaWxpdHkgYW5kIGVuYWJsZSB1bmJveGluZywgd2UgaW1wbGVtZW50IHBvcGNvdW50IGluXG4gICBPQ2FtbCByYXRoZXIgdGhhbiB1c2UgQyBzdHVicy4gSW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tOlxuICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFtbWluZ193ZWlnaHQjRWZmaWNpZW50X2ltcGxlbWVudGF0aW9uICopXG5sZXQgaW50NjRfcG9wY291bnQgPVxuICBsZXQgb3BlbiBTdGRsaWIuSW50NjQgaW5cbiAgbGV0ICggKyApID0gYWRkIGluXG4gIGxldCAoIC0gKSA9IHN1YiBpblxuICBsZXQgKCAqICkgPSBtdWwgaW5cbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGluXG4gIGxldCAoIGxhbmQgKSA9IGxvZ2FuZCBpblxuICBsZXQgbTEgPSAweDU1NTU1NTU1NTU1NTU1NTVMIGluXG4gICgqIDBiMDEwMTAxMDEuLi4gKilcbiAgbGV0IG0yID0gMHgzMzMzMzMzMzMzMzMzMzMzTCBpblxuICAoKiAwYjAwMTEwMDExLi4uICopXG4gIGxldCBtNCA9IDB4MGYwZjBmMGYwZjBmMGYwZkwgaW5cbiAgKCogMGIwMDAwMTExMS4uLiAqKVxuICBsZXQgaDAxID0gMHgwMTAxMDEwMTAxMDEwMTAxTCBpblxuICAoKiAxIGJpdCBzZXQgcGVyIGJ5dGUgKilcbiAgZnVuIFtAaW5saW5lXSB4IC0+XG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IHBhaXIgb2YgYml0cyAqKVxuICAgIGxldCB4ID0geCAtICgoeCBsc3IgMSkgbGFuZCBtMSkgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgNCBiaXRzICopXG4gICAgbGV0IHggPSAoeCBsYW5kIG0yKSArICgoeCBsc3IgMikgbGFuZCBtMikgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgYnl0ZSAqKVxuICAgIGxldCB4ID0gKHggKyAoeCBsc3IgNCkpIGxhbmQgbTQgaW5cbiAgICAoKiBzdW0gdGhlIGJpdCBjb3VudHMgaW4gdGhlIHRvcCBieXRlIGFuZCBzaGlmdCBpdCBkb3duICopXG4gICAgdG9faW50ICgoeCAqIGgwMSkgbHNyIDU2KVxuOztcblxubGV0IGludDMyX3BvcGNvdW50ID1cbiAgKCogT24gNjQtYml0IHN5c3RlbXMsIHRoaXMgaXMgZmFzdGVyIHRoYW4gaW1wbGVtZW50aW5nIHVzaW5nIFtpbnQzMl0gYXJpdGhtZXRpYy4gKilcbiAgbGV0IG1hc2sgPSAweGZmZmZfZmZmZkwgaW5cbiAgZnVuIFtAaW5saW5lXSB4IC0+IGludDY0X3BvcGNvdW50IChTdGRsaWIuSW50NjQubG9nYW5kIChTdGRsaWIuSW50NjQub2ZfaW50MzIgeCkgbWFzaylcbjs7XG5cbmxldCBuYXRpdmVpbnRfcG9wY291bnQgPVxuICBtYXRjaCBTdGRsaWIuTmF0aXZlaW50LnNpemUgd2l0aFxuICB8IDMyIC0+IGZ1biBbQGlubGluZV0geCAtPiBpbnQzMl9wb3Bjb3VudCAoU3RkbGliLk5hdGl2ZWludC50b19pbnQzMiB4KVxuICB8IDY0IC0+IGZ1biBbQGlubGluZV0geCAtPiBpbnQ2NF9wb3Bjb3VudCAoU3RkbGliLkludDY0Lm9mX25hdGl2ZWludCB4KVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxNTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9TaWduMCIsIkJhc2VfSWRlbnRpZmlhYmxlIiwidF9zZXhwX2dyYW1tYXIiLCJhbGwiLCJSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUiLCJ0b19pbnQiLCJvZl9pbnQiLCJoYXNoX2ZvbGRfdCIsImhhc2giLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwicHAiLCJoYXNoYWJsZSIsImNzdF9uZWdhdGl2ZSIsImNzdF96ZXJvIiwiY3N0X3Bvc2l0aXZlIiwidG9fc3RyaW5nX2h1bSIsInBhcmFtIiwidG9fZmxvYXQiLCJmbGlwIiwic3ltYm9sIiwidCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJjb21wYXJlIiwiZXF1YWwiLCJtYXgiLCJtaW4iLCJCYXNlX1NpZ24iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9zaWduLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxjQUFBQztBQUFBQSxJQ1NvQjtBQUFBO0FBQUEsT0FDVDtBQUFBO0FBQUEsT0FDQztBQUFBLGVBQ0Q7QUFBQTtBQUFBLEdBQVU7QUFBQSxZQUFBQyxTQUFBRDtBQUFBQSxJQUdOLHNCQUNKLG1CQUNDLG1CQUNEO0FBQUE7QUFBQSxHQUFFO0FBQUEsWUFBQUUsS0FBQUY7QUFBQUEsSUFHRixzQkFDQSxpQkFDQyxrQkFDRDtBQUFBO0FBQUEsR0FBRztBQUFBLFlBQUFHLE9BQUFDLEtBQUFBO0FBQUFBLFFBQUEsTUFHc0IsNkJBQVg7QUFBQSxJQUFELE9BQXNCLG1CQUF0QixzQ0FBc0I7QUFBQTtBQUFBO0FBQUEsSUFBQUQsV0QzQjlDO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBRSxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2lnbjBcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFNpZ24wKVxuXG4oKiBPcGVuIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IHRvX3N0cmluZ19odW0gPSBmdW5jdGlvblxuICB8IE5lZyAtPiBcIm5lZ2F0aXZlXCJcbiAgfCBaZXJvIC0+IFwiemVyb1wiXG4gIHwgUG9zIC0+IFwicG9zaXRpdmVcIlxuOztcblxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTEuXG4gIHwgWmVybyAtPiAwLlxuICB8IFBvcyAtPiAxLlxuOztcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9IG9mX2ludCAodG9faW50IHQgKiB0b19pbnQgdCcpXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGF0IHRoZSBlbmQsIGFmdGVyIGFueVxuICAgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc29cbiAgIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpc1xuICAgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMTYzNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfeCIsImNzdF9hcmd1bWVudF9tdXN0X2JlX3N0cmljdGx5XyIsImNhbWxfZGl2IiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1ByaW50ZiIsIkJhc2VfU2V4cCIsIkJhc2VfT3JfZXJyb3IiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYl9TY2FuZiIsIkJhc2VfRmxvYXQwIiwiQmFzZV9JbnQwIiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJCYXNlX0NvbXBhcmF0b3IiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiQmFzZV9JbnRfbWF0aCIsIkJhc2VfRXJyb3IiLCJCYXNlX1NpZ24iLCJCYXNlX1BvcGNvdW50IiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJoYXNoYWJsZSIsImNvbXBhcmUiLCJzIiwibnVtX2JpdHMiLCJmbG9hdF9sb3dlcl9ib3VuZCIsImZsb2F0X3VwcGVyX2JvdW5kIiwidG9fZmxvYXQiLCJvZl9mbG9hdF91bmNoZWNrZWQiLCJvZl9mbG9hdCIsInplcm8iLCJjb21wYXJhdG9yIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsImluY2x1ZGUiLCJ0b19zdHJpbmdfaHVtIiwibmVnIiwic3ltYm9sIiwiaSIsIkhleCIsInBwIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsImludmFyaWFudCIsInBhcmFtIiwiYmV0d2VlbiIsInQiLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwibWluIiwibWF4IiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJwcmVkIiwic3VjYyIsInRvX2ludCIsIm9mX2ludF9leG4iLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJvZl9pbnQzMiIsIm9mX2ludDMyX2V4biIsInRvX2ludDMyIiwidG9faW50MzJfZXhuIiwib2ZfaW50NjQiLCJvZl9pbnQ2NF9leG4iLCJ0b19pbnQ2NCIsIm9mX25hdGl2ZWludCIsIm9mX25hdGl2ZWludF9leG4iLCJ0b19uYXRpdmVpbnQiLCJhYnMiLCJyZW0iLCJhIiwiYiIsImluY3IiLCJkZWNyIiwic2hpZnRfcmlnaHQiLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwic2hpZnRfbGVmdCIsImJpdF9ub3QiLCJiaXRfb3IiLCJiaXRfYW5kIiwiYml0X3hvciIsInBvdyIsImUiLCJyYWlzZV9zIiwiY3N0X0ludF9mbG9vcl9sb2cyX2dvdF9pbnZhbGlkIiwiY3N0X0ludF9jZWlsX2xvZzJfZ290X2ludmFsaWRfIiwibm9uX3Bvc2l0aXZlX2FyZ3VtZW50IiwiY2VpbF9wb3cyIiwiZmxvb3JfcG93MiIsImlzX3BvdzIiLCJmbG9vcl9sb2cyIiwiY2VpbF9sb2cyIiwic2lnbiIsInBvcGNvdW50IiwiRiIsInJvdW5kIiwicm91bmRfdG93YXJkc196ZXJvIiwicm91bmRfZG93biIsInJvdW5kX3VwIiwicm91bmRfbmVhcmVzdCIsInkiLCJydmFsIiwibG5vdCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJCYXNlX0ludCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2ludC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQWYsUUFBQTtBQUFBLElBQUFBLE1BQUE7QUFBQSxJQUFBZ0IsY0FBQTtBQUFBLElBQUFBLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLFlBQUFDLEtBQUFDLEdDY2EsMEJBQU07QUFBQTtBQUFBLElBQUFDLFlBQWY7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBO0FBQUEsWUFBQVgsWUFBQVk7QUFBQUEsSUFhQSxlQUFJO0FBQUEsZ0JBQ0csNENBQXlDO0FBQUE7QUFBQTtBQUFBLElBQUFDLFdBZGhEO0FBQUEsSUFBQUMsb0JBcUJvQjtBQUFBLElBQUFDLG9CQUNBO0FBQUE7QUFBQSxNQUFtQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsU0FBQSxNRHBDM0Q7QUFBQSxZQUFBQyxtQkFBQTtBQUFBLFlBQUFDLFNBQUE3QztBQUFBQSxJQ3lDSztBQUFBO0FBQUEsU0FDQTtBQUFBLEtBQ0U7QUFBQSxlQUlEO0FBQUEsSUFBYywrQ0FDWjtBQUFBO0FBQUE7QUFBQSxJQUFBOEMsT0FabUQ7QUFBQSxJQUFBQyxhQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBbEIsY0FBQTtBQUFBLElBQUFHLFlBQUE7QUFBQSxJQUFBUixnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxZQUFBQyxPQUFBQyxHQTJDNUMsNEJBQU07QUFBQTtBQUFBLElBQUFxQixNQUFmO0FBQUE7QUFBQTtBQUFBLFlBQUFDLE9BQUEsWUQvRU47QUFBQSxZQUFBN0IsWUFBQThCLEdDdUZzQix5Q0FBcUI7QUFBQSxZQUFBN0IsWUFBQVk7QUFBQUEsSUFDckIsMEREeEZ0QixjQ3dGc0Q7QUFBQTtBQUFBO0FBQUEsSUFBQWE7QUFBQUEsTUFUaEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUssTUFBQTtBQUFBLElBQUFMO0FBQUFBLE1BQUE7QUFBQSxJQUFBTSxLQUFBO0FBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsWUFBQUMsVUFBQUMsT0F5QmtCLFNBQUU7QUFBQSxZQUFBQyxRQUFBQyxHQUFBQyxLQUFBQztBQUFBQSxRQUFBLE9BQ0M7QUFBQTtBQUFBLEdBQXFCO0FBQUEsWUFBQUMsZ0JBQUFILEdBQUFJLEtBQUFDO0FBQUFBLElBQ2QseUNBQW9EO0FBQUE7QUFBQSxZQUFBQyxVQUFBTixHQUFBSSxLQUFBQztBQUFBQSxJQUdwRixlQUNBLG1DQUEyQjtBQUFBLElBRDNCO0FBQUEsR0FDMkI7QUFBQSxZQUFBRSxNQUFBUCxHQUFBSSxLQUFBQztBQUFBQSxJQUkzQixlQU1RLHdDQUE2QjtBQUFBO0FBQUEsWUFERztBQUFBLFlBQXhCO0FBQUEsWUFGWjtBQUFBLElBRXNELDBDQUNyQjtBQUFBO0FBQUEsWUFBQUcsS0FBQWpCLEdBUTFCLHdDQUFLO0FBQUEsWUFBQWtCLEtBQUFsQixHQUNMLHdDQUFLO0FBQUEsWUFBQW1CLE9BQUFuQixHQUNILFNBQUM7QUFBQSxZQUFBb0IsV0FBQXBCLEdBRUQsU0FBQztBQUFBO0FBQUEsSUFBQXFCLFlBckRWO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsSUFBQXhELEdBcUVNLHNDQUFLO0FBQUEsWUFBQXlELElBQUFDLEdBQUFDLEdBR0gseUNBQU87QUFBQSxZQUFBQyxLQUFBLE1EdkpyQjtBQUFBLFlBQUFDLEtBQUE7QUFBQSxZQUFBQyxZQUFBSixHQUFBQyxHQzBKc0IseUNBQU87QUFBQSxZQUFBSSxvQkFBQUwsR0FBQUM7QUFBQUEsSUFDQyx5Q0FBTztBQUFBO0FBQUEsWUFBQUssV0FBQU4sR0FBQUMsR0FDaEIseUNBQU87QUFBQSxZQUFBTSxRQUFBUCxHQUNaLHNDQUFNO0FBQUEsWUFBQVEsT0FBQVIsR0FBQUMsR0FDTCx5Q0FBTztBQUFBLFlBQUFRLFFBQUFULEdBQUFDLEdBQ04seUNBQVE7QUFBQSxZQUFBUyxRQUFBVixHQUFBQyxHQUNSLHlDQUFRO0FBQUEsT0FBQVUsTUFqRnBCO0FBQUEsWUFBQS9DLFNBQUFxQyxHQUFBVyxHQW1GVyw0QkFBTztBQUFBO0FBQUEsSUFBQUMsVUFuRmxCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsWUFBQUMsc0JBQUE1QztBQUFBQSxJQTJGRix5Q0FBMkQ7QUFBQTtBQUFBLFlBQUE2QyxVQUFBM0U7QUFBQUEsSUFNM0QsV0FBZTtBQUFBO0FBQUEsS0FBQUEsTUFDUDtBQUFBLFdBQ007QUFBQSxLQUFBQSxNQUFOO0FBQUEsV0FDTTtBQUFBLEtBQUFBLE1BQU47QUFBQSxXQUNNO0FBQUEsS0FBQUEsTUFBTjtBQUFBLFdBQ007QUFBQSxLQUFBQSxNQUFOO0FBQUEsV0FDTTtBQUFBLEtBQUFBLE1BQU47QUFBQSxXQUdNO0FBQUEsS0FBQUEsTUFBTjtBQUFBLElBQ1IsMENBQUs7QUFBQTtBQUFBLFlBQUE0RSxXQUFBNUU7QUFBQUEsSUFLTCxXQUFlO0FBQUE7QUFBQSxXQUNEO0FBQUEsS0FBQUEsTUFBTjtBQUFBLFdBQ007QUFBQSxLQUFBQSxNQUFOO0FBQUEsV0FDTTtBQUFBLEtBQUFBLE1BQU47QUFBQSxXQUNNO0FBQUEsS0FBQUEsTUFBTjtBQUFBLFdBQ007QUFBQSxLQUFBQSxNQUFOO0FBQUEsV0FHTTtBQUFBLEtBQUFBLE1BQU47QUFBQSxXQUNKO0FBQUEsSUFBUztBQUFBO0FBQUEsWUFBQTZFLFFBQUE3RTtBQUFBQSxJQUliLFdBQWU7QUFBQSxjQUNSO0FBQUEsSUFBUCx5REFBYztBQUFBLEdBQUk7QUFBQSxZQUFBOEUsV0FBQXZEO0FBQUFBLElBb0JsQjtBQUFBLGVBQ3NFO0FBQUEsS0FBakU7QUFBQSxnQkFBUTtBQUFBO0FBQUE7QUFBQSxXQUNFO0FBQUEsV0FBZjtBQUFBLElBQVksNENBQVE7QUFBQTtBQUFBLFlBQUF3RCxVQUFBeEQ7QUFBQUEsSUFJcEI7QUFBQSxlQUNxRTtBQUFBLEtBQWhFO0FBQUEsZ0JBQVE7QUFBQTtBQUFBLElBQ2IsWUFBYztBQUFBO0FBQUEsV0FBa0IsOEJBQUk7QUFBQSxJQUFPO0FBQUE7QUFBQTtBQUFBLElBQUF5RCxPQTFKekM7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDRCRC9FTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFDK0VNO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQWpFLFNBQUF0QixHQUFBd0Y7QUFBQUEsSUFvTkY7QUFBQSxlQUtJLGdDQURBO0FBQUEsS0FGRjtBQUFBO0FBQUEsUUFBQUMsT0FLUztBQUFBLElBQ1gscUNBQXNDO0FBQUE7QUFBQSxZQUFBbkUsU0FBQXRCLEdBQUF3RjtBQUFBQSxJQUl0QztBQUFBLGVBS0ksZ0NBREE7QUFBQSxLQUZGO0FBQUE7QUFBQSxJQUtGLGVBQWlCLGlDQUEyQixjQUFLO0FBQUE7QUFBQSxZQUFBbEUsU0FBQXRCLEdBQUF3RixHQUd4Qix3Q0FBYztBQUFBO0FBQUEsSUFBQUUsT0ExT3JDO0FBQUEsSUFBQXZFLFlBQUE7QUFBQSxJQUFBd0UsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBdkQsTUFBQTtBQUFBLElBQUFELE1BQUE7QUFBQSxJQUFBeUQ7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBCRC9FTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdDK0VNO0FBQUE7QUFBQSxFRC9FTiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludF9pbnRmXG5pbmNsdWRlIEludDBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID0gKGdsb2JhbGl6ZV9pbnQgOiAodFtAb2NhbWwubG9jYWxdKSAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSB4IHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgeCB5XG5cbiAgbGV0IG9mX3N0cmluZyBzID1cbiAgICB0cnkgb2Zfc3RyaW5nIHMgd2l0aFxuICAgIHwgXyAtPiBQcmludGYuZmFpbHdpdGhmIFwiSW50Lm9mX3N0cmluZzogJVNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuZW5kXG5cbmxldCBudW1fYml0cyA9IEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnRcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHRvX2Zsb2F0ID0gU3RkbGliLmZsb2F0X29mX2ludFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IFN0ZGxpYi5pbnRfb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gU3RkbGliLmludF9vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiV4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIiV4XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50LkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50XCJcbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5leHRlcm5hbCB0b19pbnQzMl90cnVuYyA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAoaW50MzJbQGxvY2FsX29wdF0pID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIG9mX2ludDMyX3RydW5jIDogKGludDMyW0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2ludDY0X3RydW5jIDogKGludDY0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX25hdGl2ZWludF90cnVuYyA6IChuYXRpdmVpbnRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcblxubGV0IHByZWQgaSA9IGkgLSAxXG5sZXQgc3VjYyBpID0gaSArIDFcbmxldCB0b19pbnQgaSA9IGlcbmxldCB0b19pbnRfZXhuID0gdG9faW50XG5sZXQgb2ZfaW50IGkgPSBpXG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IG1heF92YWx1ZSA9IFN0ZGxpYi5tYXhfaW50XG5sZXQgbWluX3ZhbHVlID0gU3RkbGliLm1pbl9pbnRcbmxldCBtYXhfdmFsdWVfMzBfYml0cyA9IDB4M0ZGRl9GRkZGXG5sZXQgb2ZfaW50MzIgPSBDb252LmludDMyX3RvX2ludFxubGV0IG9mX2ludDMyX2V4biA9IENvbnYuaW50MzJfdG9faW50X2V4blxubGV0IHRvX2ludDMyID0gQ29udi5pbnRfdG9faW50MzJcbmxldCB0b19pbnQzMl9leG4gPSBDb252LmludF90b19pbnQzMl9leG5cbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9faW50XG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19pbnRfZXhuXG5sZXQgdG9faW50NjQgPSBDb252LmludF90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnRfZXhuXG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnRfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IGFicyB4ID0gYWJzIHhcblxuKCogbm90ZSB0aGF0IHJlbSBpcyBub3Qgc2FtZSBhcyAlICopXG5sZXQgcmVtIGEgYiA9IGEgbW9kIGJcbmxldCBpbmNyID0gU3RkbGliLmluY3JcbmxldCBkZWNyID0gU3RkbGliLmRlY3JcbmxldCBzaGlmdF9yaWdodCBhIGIgPSBhIGFzciBiXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCBhIGIgPSBhIGxzciBiXG5sZXQgc2hpZnRfbGVmdCBhIGIgPSBhIGxzbCBiXG5sZXQgYml0X25vdCBhID0gbG5vdCBhXG5sZXQgYml0X29yIGEgYiA9IGEgbG9yIGJcbmxldCBiaXRfYW5kIGEgYiA9IGEgbGFuZCBiXG5sZXQgYml0X3hvciBhIGIgPSBhIGx4b3IgYlxubGV0IHBvdyA9IEludF9tYXRoLlByaXZhdGUuaW50X3Bvd1xubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IC0gMSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgeCArIDFcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIHggLSAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kICh4IC0gMSkgPSAwXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogICgqIE5vdGUgdGhhdCB3ZSBwYXNzIHRoZSB0YWdnZWQgaW50IGhlcmUuIFNlZSBpbnRfbWF0aF9zdHVicy5jIGZvciBkZXRhaWxzIG9uIHdoeVxuICAgICAgICAgIHRoaXMgaXMgY29ycmVjdC4gKilcbiAgICBpbnRcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6X3VudGFnZ2VkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50W0B1bnRhZ2dlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludF9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50X2N0el91bnRhZ2dlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIGlmIGkgPSAxIHRoZW4gMCBlbHNlIG51bV9iaXRzIC0gY2x6IChpIC0gMSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcblxubGV0IHNpZ24gPSBTaWduLm9mX2ludFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50X3BvcGNvdW50XG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBleHRlcm5hbCAoICsgKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJWFkZGludFwiXG4gIGV4dGVybmFsICggLSApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlc3ViaW50XCJcbiAgZXh0ZXJuYWwgKCAqICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVtdWxpbnRcIlxuICBleHRlcm5hbCAoIC8gKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJWRpdmludFwiXG4gIGV4dGVybmFsICggfi0gKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlbmVnaW50XCJcblxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFicyA9IGFic1xuXG4gIGV4dGVybmFsIG5lZyA6ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlbmVnaW50XCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIG1vZHVsZSBGID0gSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBGXG5cbiAgZXh0ZXJuYWwgYnN3YXAxNiA6IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWJzd2FwMTZcIlxuXG4gICgqIFRoZXNlIGlubGluZWQgdmVyc2lvbnMgb2YgKCUpLCAoLyUpLCBhbmQgKC8vKSBwZXJmb3JtIGJldHRlciB0aGFuIHRoZWlyIGZ1bmN0b3JpemVkXG4gICAgIGNvdW50ZXJwYXJ0cyBpbiBbRl0gKHNlZSBiZW5jaG1hcmtzIGJlbG93KS5cblxuICAgICBUaGUgcmVhc29uIHRoZXNlIGZ1bmN0aW9ucyBhcmUgaW5saW5lZCBpbiBbSW50XSBidXQgbm90IGluIGFueSBvZiB0aGUgb3RoZXIgaW50ZWdlclxuICAgICBtb2R1bGVzIGlzIHRoYXQgdGhleSBleGlzdGVkIGluIFtJbnRdIGFuZCBbSW50XSBhbG9uZSBwcmlvciB0byB0aGUgaW50cm9kdWN0aW9uIG9mXG4gICAgIHRoZSBbSW50X21hdGguTWFrZV0gZnVuY3RvciwgYW5kIHdlIGRpZG4ndCB3YW50IHRvIGRlZ3JhZGUgdGhlaXIgcGVyZm9ybWFuY2UuXG5cbiAgICAgV2Ugd29uJ3QgcHJlLWVtcHRpdmVseSBkbyB0aGUgc2FtZSBmb3IgbmV3IGZ1bmN0aW9ucywgdW5sZXNzIHNvbWVvbmUgY2FyZXMsIG9uIGEgY2FzZVxuICAgICBieSBjYXNlIGZhc2hpb24uICAqKVxuXG4gIGxldCAoICUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAlJSAlcyBpbiBjb3JlX2ludC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgbGV0IHJ2YWwgPSByZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgKCAvJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gIGxldCAoIC8vICkgeCB5ID0gdG9fZmxvYXQgeCAvLiB0b19mbG9hdCB5XG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuICBleHRlcm5hbCAoIGxvciApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlb3JpbnRcIlxuICBleHRlcm5hbCAoIGx4b3IgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJXhvcmludFwiXG5cbiAgbGV0IGxub3QgPSBsbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWxzbGludFwiXG4gIGV4dGVybmFsICggbHNyICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuICBleHRlcm5hbCAoIGFzciApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYXNyaW50XCJcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludF0gYW5kIFtJbnQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgT19GID0gTy5GXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yXG4gICBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMDc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9VIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiQmFzZV9VY2hhcjAiLCJTdGRsaWIiLCJTdGRsaWJfU2NhbmYiLCJCYXNlX0ltcG9ydCIsIkJhc2VfUHJpbnRmIiwiQmFzZV9IYXNoIiwiQmFzZV9TdHJpbmciLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiQmFzZV9Db21wYXJhYmxlIiwiZmFpbHdpdGhmIiwiaXNfdmFsaWQiLCJpc19jaGFyIiwidW5zYWZlX3RvX2NoYXIiLCJ1bnNhZmVfb2ZfaW50IiwidG9faW50Iiwib2ZfY2hhciIsImNvbXBhcmUiLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJjc3RfVWNoYXJfdF9vZl9zZXhwX2F0b21fb2ZfdGgiLCJjc3RfVWNoYXJfdF9vZl9zZXhwX2F0b21fbmVlZGUiLCJoYXNoX2ZvbGRfdCIsInN0YXRlIiwidCIsImhhc2giLCJ0b19zdHJpbmciLCJzZXhwX29mX3QiLCJ0X29mX3NleHAiLCJzZXhwIiwicyIsImkiLCJ0X3NleHBfZ3JhbW1hciIsInBwIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsImludmFyaWFudCIsInBhcmFtIiwic3VjY19leG4iLCJjIiwiZXhuIiwibXNnIiwic3VjYyIsInByZWRfZXhuIiwicHJlZCIsIm9mX3NjYWxhciIsIm9mX3NjYWxhcl9leG4iLCJ0b19zY2FsYXIiLCJ0b19jaGFyIiwidG9fY2hhcl9leG4iLCJ1dGY4X2J5dGVfbGVuZ3RoIiwidWNoYXIiLCJjb2RlcG9pbnQiLCJpbmNsdWRlIiwic3ltYm9sIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImVxdWFsIiwibWF4IiwibWluIiwiQmFzZV9VY2hhciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL3VjaGFyLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEs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SUFDaEI7QUFBQTtBQUFBLGVBTU07QUFBQTtBQUFBO0FBQUEsSUFBQUMsVUE3RDhDO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBekMsWUFBQTtBQUFBLElBQUEwQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHpCdEQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICBpbmNsdWRlIFVjaGFyMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhclwiXG4gIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gSGFzaC5mb2xkX2ludCBzdGF0ZSAodG9faW50IHQpXG4gIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gIGxldCB0b19zdHJpbmcgdCA9IFByaW50Zi5zcHJpbnRmIFwiVSslMDRYXCIgKHRvX2ludCB0KVxuXG4gICgqIERvIG5vdCBhY3R1YWxseSBleHBvcnQgdGhpcy4gU2VlIGRpc2N1c3Npb24gaW4gdGhlIC5tbGkgKilcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuXG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIlUrJVhcIiAoZnVuIGkgLT4gVWNoYXIwLm9mX2ludCBpKSB3aXRoXG4gICAgICAgfCBfIC0+IG9mX3NleHBfZXJyb3IgXCJVY2hhci50X29mX3NleHA6IGF0b20gb2YgdGhlIGZvcm0gVStYWFhYIG5lZWRlZFwiIHNleHApXG4gIDs7XG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5pbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgaW50X2lzX3NjYWxhciA9IGlzX3ZhbGlkXG5cbmxldCBzdWNjX2V4biBjID1cbiAgdHJ5IFVjaGFyMC5zdWNjIGMgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+IGZhaWx3aXRoZiBcIlVjaGFyLnN1Y2NfZXhuOiAlc1wiIG1zZyAoKVxuOztcblxubGV0IHN1Y2MgYyA9XG4gIHRyeSBTb21lIChVY2hhcjAuc3VjYyBjKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcbjs7XG5cbmxldCBwcmVkX2V4biBjID1cbiAgdHJ5IFVjaGFyMC5wcmVkIGMgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+IGZhaWx3aXRoZiBcIlVjaGFyLnByZWRfZXhuOiAlc1wiIG1zZyAoKVxuOztcblxubGV0IHByZWQgYyA9XG4gIHRyeSBTb21lIChVY2hhcjAucHJlZCBjKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcbjs7XG5cbmxldCBvZl9zY2FsYXIgaSA9IGlmIGludF9pc19zY2FsYXIgaSB0aGVuIFNvbWUgKHVuc2FmZV9vZl9pbnQgaSkgZWxzZSBOb25lXG5cbmxldCBvZl9zY2FsYXJfZXhuIGkgPVxuICBpZiBpbnRfaXNfc2NhbGFyIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJVY2hhci5vZl9pbnRfZXhuIGdvdCBhIGludmFsaWQgVW5pY29kZSBzY2FsYXIgdmFsdWU6ICUwNFhcIiBpICgpXG47O1xuXG5sZXQgdG9fc2NhbGFyIHQgPSBVY2hhcjAudG9faW50IHRcbmxldCB0b19jaGFyIGMgPSBpZiBpc19jaGFyIGMgdGhlbiBTb21lICh1bnNhZmVfdG9fY2hhciBjKSBlbHNlIE5vbmVcblxubGV0IHRvX2NoYXJfZXhuIGMgPVxuICBpZiBpc19jaGFyIGNcbiAgdGhlbiB1bnNhZmVfdG9fY2hhciBjXG4gIGVsc2UgZmFpbHdpdGhmIFwiVWNoYXIudG9fY2hhcl9leG4gZ290IGEgbm9uIGxhdGluLTEgY2hhcmFjdGVyOiBVKyUwNFhcIiAodG9faW50IGMpICgpXG47O1xuXG5sZXQgdXRmOF9ieXRlX2xlbmd0aCB1Y2hhciA9XG4gIGxldCBjb2RlcG9pbnQgPSB0b19zY2FsYXIgdWNoYXIgaW5cbiAgaWYgSW50LiggPCApIGNvZGVwb2ludCAweDgwXG4gIHRoZW4gMVxuICBlbHNlIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHg4MDBcbiAgdGhlbiAyXG4gIGVsc2UgaWYgSW50LiggPCApIGNvZGVwb2ludCAweDEwMDAwXG4gIHRoZW4gM1xuICBlbHNlIDRcbjs7XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMjI5MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJzb21lX3QiLCJCYXNlX0ltcG9ydCIsIkJhc2VfU2V4cCIsIkJhc2VfRXJyb3IiLCJCYXNlX09wdGlvbiIsIlN0ZGxpYl9PYmoiLCJCYXNlX0ludCIsInNleHBfb2ZfdCIsIm9mX2FfMDAxIiwib2ZfYl8wMDIiLCJwYXJhbSIsImNzdF9LZXkiLCJjc3RfVHlwZV9lcXVhbF9JZF9zYW1lX3dpdG5lc3MiLCJzeW0iLCJ0cmFucyIsImNvbnYiLCJhIiwiTGlmdCIsIlgiLCJsaWZ0IiwiTGlmdDIiLCJMaWZ0MyIsImRldHVwbGUyIiwidHVwbGUyIiwiQ29tcG9zaXRpb25fcHJlc2VydmVzX2luamVjdGl2IiwiTTEiLCJNMiIsInN0cmlwIiwiZSIsIm5hbWUiLCJ3aXRuZXNzIiwidCIsInZfMDA1IiwidG9fc2V4cCIsImNyZWF0ZSIsIktleSIsInVpZCIsIk0iLCJoYXNoIiwiaGFzaF9mb2xkX3QiLCJzIiwic2FtZV93aXRuZXNzIiwidDEiLCJ0MiIsImIiLCJzYW1lIiwic2FtZV93aXRuZXNzX2V4biIsIm1hdGNoIiwidyIsIkJhc2VfVHlwZV9lcXVhbCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL3R5cGVfZXF1YWwubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQTtBQUFBLFlBQUFDLFVBQUFDLFVBQUFDLFVBQUFDLE9DV3FDLFdBQXNCO0FBQUE7QUFBQSxVRFgzRDtBQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsSUFBQUgsT0NtQitDLFNBQUM7QUFBQSxZQUFBSSxNQUFBLEtBQUFKLE9BQ2tCLFNBQUM7QUFBQSxZQUFBSyxLQUFBTCxPQUFBTSxHQUNsQixTQUFDO0FBQUEsWUFBQUMsS0FBQUMsWUFBQUMsS0FBQVQsT0FNUSxTQUFDLEVEM0IzRDtBQUFBLFlBQUFVLE1BQUFGLFlBQUFDLEtBQUEsS0FBQVQsT0NxQ0ksU0FBQyxFRHJDTDtBQUFBLFlBQUFXLE1BQUFIO0FBQUFBLGFBQUFDLEtBQUEsVUFBQVQsT0NnREksU0FBQztBQUFBLElEaERMO0FBQUE7QUFBQSxZQUFBWSxTQUFBWixPQ3FERSxXQUFJO0FBQUEsWUFBQWEsT0FBQSxLQUFBYixPQUdtRixTQUFDO0FBQUEsWUFBQWMsK0JBQUFDLElBQUFDO0FBQUFBLGFBQUFDLE1BQUFDO0FBQUFBLFNBQUEsTUFpQmpFO0FBQUEsS0FBWTtBQUFBO0FBQUEsSUR6RXJDO0FBQUE7QUFBQSxZQUFBckIsWUFBQSxLQUFBRztBQUFBQSxRQUFBbUIsT0NrSmdCLFVBQUFDLFVBQUE7QUFBQSxJQUNaLHFCQUNLO0FBQUE7QUFBQSxLQUFBQyxJQXhDSDtBQUFBLFdBYk87QUFBQSxLQUFBQyxRQURIO0FBQUEsSUFSeUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFrRUU7QUFBQSxHQUM1RDtBQUFBLFlBQUFDLFFBQUFGLEdBR1MsWUFBUztBQUFBLFlBQUFGLEtBQUFFLEdBQ1osWUFBTTtBQUFBLFlBQUFHLE9BQUFMLE1BQUFJO0FBQUFBLFFBQUFFLE1BN0NmO0FBQUEsSUE4Q29EO0FBQUEsR0FBaUI7QUFBQSxZQUFBQyxJQUFBTDtBQUFBQSxRQUFBTSxJQUM3RCxZQXRDNEI7QUFBQSxJQUErQyx5Q0FzQ3REO0FBQUE7QUFBQSxZQUFBQyxLQUFBUCxHQUNwQixhQUFLO0FBQUEsWUFBQVEsWUFBQUMsR0FBQVQ7QUFBQUEsUUFBQSxNQUNvQjtBQUFBLElBQU87QUFBQTtBQUFBLFlBQUFVLGFBQUFDLElBQUFDO0FBQUFBLFFBQUFDLElBQ3BCLE9BQUE1QixJQUFBO0FBQUEsSUEvQnJCLGlDQStCdUQ7QUFBQTtBQUFBLFlBQUE2QixLQUFBSCxJQUFBQztBQUFBQSxRQUFBLE1BQzNCO0FBQUEsSUFBb0I7QUFBQTtBQUFBLFlBQUFHLGlCQUFBSixJQUFBQztBQUFBQSxRQUFBSSxRQUc1QztBQUFBLElBQWtCLGNBQUFDLElBQUEsVUFDWjtBQUFBO0FBQUEsV0FNdUM7QUFBQSxXQUEzQjtBQUFBO0FBQUEsT0FBYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEseUJBQWE7QUFBQSx5QkFBMkI7QUFBQTtBQUFBO0FBQUEsV0FIL0M7QUFBQSxJQUtLO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EL0tiIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICdiKSB0ID0gVCA6ICgnYSwgJ2EpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDAzXyBiX18wMDRfKVxuICAgICAgOiAgKChhX18wMDNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMDNfLCBiX18wMDRfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAwMV8gX29mX2JfXzAwMl8gVCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJUXCJcbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgKCdhLCAnYikgZXF1YWwgPSAoJ2EsICdiKSB0XG5cbmxldCByZWZsID0gVFxubGV0IHN5bSAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGIsIGEpIHQgPSBUXG5sZXQgdHJhbnMgKHR5cGUgYSBiIGMpIChUIDogKGEsIGIpIHQpIChUIDogKGIsIGMpIHQpIDogKGEsIGMpIHQgPSBUXG5sZXQgY29udiAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIChhIDogYSkgOiBiID0gYVxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGEgWC50LCBiIFgudCkgdCA9IFRcbmVuZFxuXG5tb2R1bGUgTGlmdDIgKFggOiBzaWdcbiAgICB0eXBlICgnYTEsICdhMikgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhMSBiMSBhMiBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpXG4gICAgOiAoKGExLCBhMikgWC50LCAoYjEsIGIyKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbm1vZHVsZSBMaWZ0MyAoWCA6IHNpZ1xuICAgIHR5cGUgKCdhMSwgJ2EyLCAnYTMpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIgYTMgYjMpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSAoVCA6IChhMywgYjMpIHQpXG4gICAgOiAoKGExLCBhMiwgYTMpIFgudCwgKGIxLCBiMiwgYjMpIFgudCkgdFxuICAgID1cbiAgICBUXG4gIDs7XG5lbmRcblxubGV0IGRldHVwbGUyICh0eXBlIGExIGEyIGIxIGIyKSAoVCA6IChhMSAqIGEyLCBiMSAqIGIyKSB0KSA6IChhMSwgYjEpIHQgKiAoYTIsIGIyKSB0ID1cbiAgVCwgVFxuOztcblxubGV0IHR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpIDogKGExICogYTIsIGIxICogYjIpIHQgPSBUXG5cbm1vZHVsZSB0eXBlIEluamVjdGl2ZSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgc3RyaXAgOiAoJ2EgdCwgJ2IgdCkgZXF1YWwgLT4gKCdhLCAnYikgZXF1YWxcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmplY3RpdmUyID0gc2lnXG4gIHR5cGUgKCdhMSwgJ2EyKSB0XG5cbiAgdmFsIHN0cmlwIDogKCgnYTEsICdhMikgdCwgKCdiMSwgJ2IyKSB0KSBlcXVhbCAtPiAoJ2ExLCAnYjEpIGVxdWFsICogKCdhMiwgJ2IyKSBlcXVhbFxuZW5kXG5cbm1vZHVsZSBDb21wb3NpdGlvbl9wcmVzZXJ2ZXNfaW5qZWN0aXZpdHkgKE0xIDogSW5qZWN0aXZlKSAoTTIgOiBJbmplY3RpdmUpID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIE0xLnQgTTIudFxuXG4gIGxldCBzdHJpcCBlID0gTTEuc3RyaXAgKE0yLnN0cmlwIGUpXG5lbmRcblxubW9kdWxlIElkID0gc3RydWN0XG4gIG1vZHVsZSBVaWQgPSBJbnRcblxuICBtb2R1bGUgV2l0bmVzcyA9IHN0cnVjdFxuICAgIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgXyB0ID0gLi5cbiAgICAgIHR5cGUgdHlwZV93aXRuZXNzX2ludCA9IFsgYHR5cGVfd2l0bmVzcyBvZiBpbnQgXSBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgbGV0IHNleHBfb2ZfdHlwZV93aXRuZXNzX2ludCA9XG4gICAgICAgIChmdW4gKGB0eXBlX3dpdG5lc3Mgdl9fMDA1XykgLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwidHlwZV93aXRuZXNzXCI7IHNleHBfb2ZfaW50IHZfXzAwNV8gXVxuICAgICAgICAgICA6IHR5cGVfd2l0bmVzc19pbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgOztcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgbGV0IHNleHBfb2ZfdCBfc2V4cF9vZl9hIHQgPVxuICAgICAgICBgdHlwZV93aXRuZXNzXG4gICAgICAgICAgKFN0ZGxpYi5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG4gICAgICAgICAgICAgKFN0ZGxpYi5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCB0KSlcbiAgICAgICAgfD4gc2V4cF9vZl90eXBlX3dpdG5lc3NfaW50XG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIF8gS2V5LnQgKz0gS2V5IDogdCBLZXkudFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICBsZXQgc2V4cF9vZl90ICh0eXBlIGEpIHNleHBfb2ZfYSAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICAgICAgTS5LZXkgfD4gS2V5LnNleHBfb2ZfdCBzZXhwX29mX2FcbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZSAodHlwZSB0KSAoKSA9XG4gICAgICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBub25yZWMgdCA9IHRcbiAgICAgICAgdHlwZSBfIEtleS50ICs9IEtleSA6IHQgS2V5LnRcbiAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSB0KVxuICAgIDs7XG5cbiAgICBsZXQgdWlkICh0eXBlIGEpIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgICBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZCAoU3RkbGliLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIE0uS2V5KVxuICAgIDs7XG5cbiAgICAoKiBXZSB3YW50IGEgY29uc3RhbnQgYWxsb2NhdGVkIG9uY2UgdGhhdCBbc2FtZV0gY2FuIHJldHVybiB3aGVuZXZlciBpdCBnZXRzIHRoZSBzYW1lXG4gICAgICAgd2l0bmVzc2VzLiAgSWYgd2Ugd3JpdGUgdGhlIGNvbnN0YW50IGluc2lkZSB0aGUgYm9keSBvZiBbc2FtZV0sIHRoZSBuYXRpdmUtY29kZVxuICAgICAgIGNvbXBpbGVyIHdpbGwgZG8gdGhlIHJpZ2h0IHRoaW5nIGFuZCBsaWZ0IGl0IG91dC4gIEJ1dCBmb3IgY2xhcml0eSBhbmQgcm9idXN0bmVzcyxcbiAgICAgICB3ZSBkbyBpdCBvdXJzZWx2ZXMuICopXG4gICAgbGV0IHNvbWVfdCA9IFNvbWUgVFxuXG4gICAgbGV0IHNhbWUgKHR5cGUgYSBiKSAoYSA6IGEgdCkgKGIgOiBiIHQpIDogKGEsIGIpIGVxdWFsIG9wdGlvbiA9XG4gICAgICBsZXQgbW9kdWxlIEEgPSAodmFsIGEgOiBTIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQiA9ICh2YWwgYiA6IFMgd2l0aCB0eXBlIHQgPSBiKSBpblxuICAgICAgbWF0Y2ggQS5LZXkgd2l0aFxuICAgICAgfCBCLktleSAtPiBzb21lX3RcbiAgICAgIHwgXyAtPiBOb25lXG4gICAgOztcbiAgZW5kXG5cblxuICB0eXBlICdhIHQgPVxuICAgIHsgd2l0bmVzcyA6ICdhIFdpdG5lc3MudFxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIDsgdG9fc2V4cCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICBsZXQgc2V4cF9vZl90IF8geyB3aXRuZXNzOyBuYW1lOyB0b19zZXhwIH0gOiBTZXhwLnQgPVxuICAgIGlmIGFtX3Rlc3RpbmdcbiAgICB0aGVuIEF0b20gbmFtZVxuICAgIGVsc2VcbiAgICAgIExpc3RcbiAgICAgICAgWyBMaXN0IFsgQXRvbSBcIm5hbWVcIjsgQXRvbSBuYW1lIF1cbiAgICAgICAgOyBMaXN0IFsgQXRvbSBcIndpdG5lc3NcIjsgd2l0bmVzcyB8PiBXaXRuZXNzLnNleHBfb2ZfdCB0b19zZXhwIF1cbiAgICAgICAgXVxuICA7O1xuXG4gIGxldCB0b19zZXhwIHQgPSB0LnRvX3NleHBcbiAgbGV0IG5hbWUgdCA9IHQubmFtZVxuICBsZXQgY3JlYXRlIH5uYW1lIHRvX3NleHAgPSB7IHdpdG5lc3MgPSBXaXRuZXNzLmNyZWF0ZSAoKTsgbmFtZTsgdG9fc2V4cCB9XG4gIGxldCB1aWQgdCA9IFdpdG5lc3MudWlkIHQud2l0bmVzc1xuICBsZXQgaGFzaCB0ID0gdWlkIHRcbiAgbGV0IGhhc2hfZm9sZF90IHMgdCA9IGhhc2hfZm9sZF9pbnQgcyAodWlkIHQpXG4gIGxldCBzYW1lX3dpdG5lc3MgdDEgdDIgPSBXaXRuZXNzLnNhbWUgdDEud2l0bmVzcyB0Mi53aXRuZXNzXG4gIGxldCBzYW1lIHQxIHQyID0gT3B0aW9uLmlzX3NvbWUgKHNhbWVfd2l0bmVzcyB0MSB0MilcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biB0MSB0MiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIHQxIHQyIHdpdGhcbiAgICB8IFNvbWUgdyAtPiB3XG4gICAgfCBOb25lIC0+XG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJUeXBlX2VxdWFsLklkLnNhbWVfd2l0bmVzc19leG4gZ290IGRpZmZlcmVudCBpZHNcIlxuICAgICAgICAgICBbICggXCJcIlxuICAgICAgICAgICAgICwgc2V4cF9vZl9wYWlyIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpICh0MSwgdDIpXG4gICAgICAgICAgICAgKVxuICAgICAgICAgICBdKVxuICA7O1xuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjI0NjYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9TdGFja19pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxrQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyNDc3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQXJyYXkiLCJCYXNlX0ltcG9ydCIsIkJhc2VfVW5pZm9ybV9hcnJheSIsIkJhc2VfT3B0aW9uIiwiU2V4cGxpYjBfU2V4cF9ncmFtbWFyIiwiU3RkbGliX09iaiIsIkJhc2VfU2V4cGFibGUiLCJCYXNlX0luZGV4ZWRfY29udGFpbmVyIiwiQmFzZV9CbGl0Iiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsImNzdF9PcHRpb25fYXJyYXlfZ2V0X3NvbWVfZXhuXyIsImlzX25vbmUiLCJ4IiwiaXNfc29tZSIsInNvbWUiLCJ2YWx1ZV91bnNhZmUiLCJ2YWx1ZV9leG4iLCJvZl9zZXhwYWJsZSIsInBhcmFtIiwidG9fc2V4cGFibGUiLCJpbmNsdWRlIiwidF9vZl9zZXhwIiwic2V4cF9vZl90Iiwib2ZfYV8wMDEiLCJ4XzAwMyIsIm9mX2FfMDA0IiwieF8wMDUiLCJ0X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiZW1wdHkiLCJjcmVhdGUiLCJsZW4iLCJpbml0IiwibiIsImkiLCJpbml0X3NvbWUiLCJnZXQiLCJ0IiwiZ2V0X3NvbWVfZXhuIiwic2V0Iiwic2V0X3NvbWUiLCJzZXRfbm9uZSIsInN3YXAiLCJqIiwidW5zYWZlX2dldCIsInVuc2FmZV9nZXRfc29tZV9leG4iLCJ1bnNhZmVfZ2V0X3NvbWVfYXNzdW1pbmdfc29tZSIsInVuc2FmZV9pc19zb21lIiwidW5zYWZlX3NldCIsInVuc2FmZV9zZXRfc29tZSIsInVuc2FmZV9zZXRfbm9uZSIsImNsZWFyIiwiaW5wdXQiLCJhY2MiLCJlbGVtIiwiZm9sZCIsImZvbGRpIiwiaXRlciIsIml0ZXJpIiwibGVuZ3RoIiwiaXNfZW1wdHkiLCJtZW0iLCJmb2xkX3Jlc3VsdCIsImZvbGRfdW50aWwiLCJleGlzdHMiLCJmb3JfYWxsIiwiY291bnQiLCJzdW0iLCJmaW5kIiwiZmluZF9tYXAiLCJ0b19saXN0IiwibWluX2VsdCIsIm1heF9lbHQiLCJleGlzdHNpIiwiZm9yX2FsbGkiLCJjb3VudGkiLCJmaW5kaSIsImZpbmRfbWFwaSIsIm1hcCIsIm91dHB1dCIsIm1hcF9zb21lIiwib3B0Iiwib2ZfYXJyYXkiLCJhcnJheSIsIm9mX2FycmF5X3NvbWUiLCJ0b19hcnJheSIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQiLCJibGl0IiwiYmxpdG8iLCJzdWIiLCJzdWJvIiwiY29weSIsIkJhc2VfT3B0aW9uX2FycmF5Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvb3B0aW9uX2FycmF5Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxrQkM2Q3FCO0FBQUEsSUFBQUMsT0FBZ0Q7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsUUFBQUMsR0FrQmpELDRDQUFpQjtBQUFBLFlBQUFDLFFBQUFELEdBQ2IsZ0RBQW1CO0FBQUEsWUFBQUUsS0FBQUY7QUFBQUEsSUE1Q0Usa0VBK0N5QjtBQUFBO0FBQUEsWUFBQUcsYUFBQUg7QUFBQUEsSUFJ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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEN0NyRSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbigqKiBbJ2EgQ2hlYXBfb3B0aW9uLnRdIGlzIGxpa2UgWydhIG9wdGlvbl0sIGJ1dCBpdCBkb2Vzbid0IGJveCBbc29tZSBfXSB2YWx1ZXMuXG5cbiAgICBUaGVyZSBhcmUgc2V2ZXJhbCB0aGluZ3MgdGhhdCBhcmUgdW5zYWZlIGFib3V0IGl0OlxuXG4gICAgLSBbZmxvYXQgdCBhcnJheV0gKG9yIGFueSBhcnJheS1iYWNrZWQgY29udGFpbmVyKSBpcyBub3QgbWVtb3J5LXNhZmVcbiAgICAgIGJlY2F1c2UgZmxvYXQgYXJyYXkgb3B0aW1pemF0aW9uIGlzIGluY29tcGF0aWJsZSB3aXRoIHVuYm94ZWQgb3B0aW9uXG4gICAgICBvcHRpbWl6YXRpb24uIFlvdSBoYXZlIHRvIHVzZSBbVW5pZm9ybV9hcnJheS50XSBpbnN0ZWFkIG9mIFthcnJheV0uXG5cbiAgICAtIE5lc3RlZCBvcHRpb25zIChbJ2EgdCB0XSkgZG9uJ3Qgd29yay4gVGhleSBhcmUgYmVsaWV2ZWQgdG8gYmVcbiAgICAgIG1lbW9yeS1zYWZlLCBidXQgbm90IHBhcmFtZXRyaWMuXG5cbiAgICAtIEEgcmVjb3JkIHdpdGggW2Zsb2F0IHRdcyBpbiBpdCBzaG91bGQgYmUgc2FmZSwgYnV0IGl0J3Mgb25seSBbdF0gYmVpbmdcbiAgICAgIGFic3RyYWN0IHRoYXQgZ2l2ZXMgeW91IHNhZmV0eS4gSWYgdGhlIGNvbXBpbGVyIHdhcyBzbWFydCBlbm91Z2ggdG8gcGVla1xuICAgICAgdGhyb3VnaCB0aGUgbW9kdWxlIHNpZ25hdHVyZSB0aGVuIGl0IGNvdWxkIGRlY2lkZSB0byBjb25zdHJ1Y3QgYSBmbG9hdFxuICAgICAgYXJyYXkgaW5zdGVhZC4gKilcbm1vZHVsZSBDaGVhcF9vcHRpb24gPSBzdHJ1Y3RcbiAgKCogVGhpcyBpcyB0YWtlbiBmcm9tIGNvcmUuIFJhdGhlciB0aGFuIGV4cG9zZSBpdCBpbiB0aGUgcHVibGljIGludGVyZmFjZSBvZiBiYXNlLCBqdXN0XG4gICAgIGtlZXAgYSBjb3B5IGFyb3VuZCBoZXJlLiAqKVxuICBsZXQgcGh5c19zYW1lICh0eXBlIGEgYikgKGEgOiBhKSAoYiA6IGIpID0gcGh5c19lcXVhbCBhIChTdGRsaWIuT2JqLm1hZ2ljIGIgOiBhKVxuXG4gIG1vZHVsZSBUMCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIG5vbmUgOiBfIHRcbiAgICB2YWwgc29tZSA6ICdhIC0+ICdhIHRcbiAgICB2YWwgaXNfbm9uZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIGlzX3NvbWUgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCB2YWx1ZV9leG4gOiAnYSB0IC0+ICdhXG4gICAgdmFsIHZhbHVlX3Vuc2FmZSA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgaXRlcl9zb21lIDogJ2EgdCAtPiBmOigoJ2EgLT4gdW5pdClbQGxvY2FsXSkgLT4gdW5pdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICsnYSB0XG5cbiAgICAoKiBCZWluZyBhIHBvaW50ZXIsIG5vIG9uZSBvdXRzaWRlIHRoaXMgbW9kdWxlIGNhbiBjb25zdHJ1Y3QgYSB2YWx1ZSB0aGF0IGlzXG4gICAgICAgW3BoeXNfc2FtZV0gYXMgdGhpcyBvbmUuXG5cbiAgICAgICBJdCB3b3VsZCBiZSBzaW1wbGVyIHRvIHVzZSB0aGlzIHZhbHVlIGFzIFtub25lXSwgYnV0IHdlIHVzZSBhbiBpbW1lZGlhdGUgaW5zdGVhZFxuICAgICAgIGJlY2F1c2UgaXQgbGV0cyB1cyBhdm9pZCBjYW1sX21vZGlmeSB3aGVuIHNldHRpbmcgdG8gW25vbmVdLCBtYWtpbmcgY2VydGFpblxuICAgICAgIGJlbmNobWFya3Mgc2lnbmlmaWNhbnRseSBmYXN0ZXIgKGUuZy4gLi4vYmVuY2gvYXJyYXlfcXVldWUuZXhlKS5cblxuICAgICAgIHRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIGluIE1vcHRpb24sIGFuZCBpZiB3ZSBmaW5kIHlldCBhbm90aGVyIHBsYWNlIHdoZXJlIHdlIHdhbnRcbiAgICAgICBpdCB3ZSBzaG91bGQgcmVjb25zaWRlciBtYWtpbmcgaXQgc2hhcmVkLiAqKVxuICAgIGxldCBub25lX3N1YnN0aXR1dGUgOiBfIHQgPVxuICAgICAgU3RkbGliLk9iai5vYmogKFN0ZGxpYi5PYmoubmV3X2Jsb2NrIFN0ZGxpYi5PYmouYWJzdHJhY3RfdGFnIDEpXG4gICAgOztcblxuICAgIGxldCBub25lIDogXyB0ID1cbiAgICAgICgqIFRoZSBudW1iZXIgd2FzIHByb2R1Y2VkIGJ5XG4gICAgICAgICBbPCAvZGV2L3VyYW5kb20gdHIgLWMgLWQgJzEyMzQ1Njc4OTBhYmNkZWYnIHwgaGVhZCAtYyAxNl0uXG5cbiAgICAgICAgIFRoZSBpZGVhIGlzIHRoYXQgYSByYW5kb20gbnVtYmVyIHdpbGwgaGF2ZSBsb3dlciBwcm9iYWJpbGl0eSB0byBjb2xsaWRlIHdpdGhcbiAgICAgICAgIGFueXRoaW5nIHRoYW4gYW55IG51bWJlciB3ZSBjYW4gY2hvb3NlIG91cnNlbHZlcy5cblxuICAgICAgICAgV2UgYXJlIHVzaW5nIGEgcG9seW1vcnBoaWMgdmFyaWFudCBpbnN0ZWFkIG9mIGFuIGludGVnZXIgY29uc3RhbnQgYmVjYXVzZSB0aGVyZVxuICAgICAgICAgaXMgYSBjb21waWxlciBidWcgd2hlcmUgaXQgd3JvbmdseSBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdCBvZiBbaWYgXyB0aGVuIGMgZWxzZVxuICAgICAgICAgeV0gaXMgbm90IGEgcG9pbnRlciBpZiBbY10gaXMgYW4gaW50ZWdlciBjb21waWxlLXRpbWUgY29uc3RhbnQuICBUaGlzIGlzIGJlaW5nXG4gICAgICAgICBmaXhlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvcHVsbC81NTUuICBUaGUgXCJtZW1vcnkgY29ycnVwdGlvblwiIHRlc3RcbiAgICAgICAgIGJlbG93IGRlbW9uc3RyYXRlcyB0aGUgaXNzdWUuICAqKVxuICAgICAgU3RkbGliLk9iai5tYWdpYyBgeDZlOGVlMzQ3OGUxZDc0NDlcbiAgICA7O1xuXG4gICAgbGV0IGlzX25vbmUgeCA9IHBoeXNfZXF1YWwgeCBub25lXG4gICAgbGV0IGlzX3NvbWUgeCA9IG5vdCAocGh5c19lcXVhbCB4IG5vbmUpXG5cbiAgICBsZXQgc29tZSAodHlwZSBhKSAoeCA6IGEpIDogYSB0ID1cbiAgICAgIGlmIHBoeXNfc2FtZSB4IG5vbmUgdGhlbiBub25lX3N1YnN0aXR1dGUgZWxzZSBTdGRsaWIuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX3Vuc2FmZSAodHlwZSBhKSAoeCA6IGEgdCkgOiBhID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgeCBub25lX3N1YnN0aXR1dGUgdGhlbiBTdGRsaWIuT2JqLm1hZ2ljIG5vbmUgZWxzZSBTdGRsaWIuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX2V4biB4ID1cbiAgICAgIGlmIGlzX3NvbWUgeFxuICAgICAgdGhlbiB2YWx1ZV91bnNhZmUgeFxuICAgICAgZWxzZSBmYWlsd2l0aCBcIk9wdGlvbl9hcnJheS5nZXRfc29tZV9leG46IHRoZSBlbGVtZW50IGlzIFtOb25lXVwiXG4gICAgOztcblxuICAgIGxldCBpdGVyX3NvbWUgdCB+ZiA9IGlmIGlzX3NvbWUgdCB0aGVuIGYgKHZhbHVlX3Vuc2FmZSB0KVxuICBlbmRcblxuICBtb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG5cbiAgICBsZXQgb2Zfb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBub25lXG4gICAgICB8IFNvbWUgeCAtPiBzb21lIHhcbiAgICA7O1xuXG4gICAgbGV0W0BpbmxpbmVdIHRvX29wdGlvbiB4ID0gaWYgaXNfc29tZSB4IHRoZW4gU29tZSAodmFsdWVfdW5zYWZlIHgpIGVsc2UgTm9uZVxuICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX29wdGlvblxuICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX29wdGlvblxuXG4gICAgbGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICAgIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICA9XG4gICAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChPcHRpb24udF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFQxXG4gIGluY2x1ZGUgU2V4cGFibGUuT2Zfc2V4cGFibGUxIChPcHRpb24pIChUMSlcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBDaGVhcF9vcHRpb24udCBVbmlmb3JtX2FycmF5LnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB4X18wMDNfIC0+XG4gIFVuaWZvcm1fYXJyYXkudF9vZl9zZXhwIChDaGVhcF9vcHRpb24udF9vZl9zZXhwIF9vZl9hX18wMDFfKSB4X18wMDNfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDRfIHhfXzAwNV8gLT5cbiAgVW5pZm9ybV9hcnJheS5zZXhwX29mX3QgKENoZWFwX29wdGlvbi5zZXhwX29mX3QgX29mX2FfXzAwNF8pIHhfXzAwNV9cbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgVW5pZm9ybV9hcnJheS50X3NleHBfZ3JhbW1hciAoQ2hlYXBfb3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZW1wdHkgPSBVbmlmb3JtX2FycmF5LmVtcHR5XG5sZXQgY3JlYXRlIH5sZW4gPSBVbmlmb3JtX2FycmF5LmNyZWF0ZSB+bGVuIENoZWFwX29wdGlvbi5ub25lXG5sZXQgaW5pdCBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5vZl9vcHRpb24gKGYgaSkpIFtAbm9udGFpbF1cbmxldCBpbml0X3NvbWUgbiB+ZiA9IFVuaWZvcm1fYXJyYXkuaW5pdCBuIH5mOihmdW4gaSAtPiBDaGVhcF9vcHRpb24uc29tZSAoZiBpKSkgW0Bub250YWlsXVxubGV0IGxlbmd0aCA9IFVuaWZvcm1fYXJyYXkubGVuZ3RoXG5sZXRbQGlubGluZV0gZ2V0IHQgaSA9IENoZWFwX29wdGlvbi50b19vcHRpb24gKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBnZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX25vbmUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX25vbmUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBpc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgc2V0IHQgaSB4ID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5zb21lIHgpXG5sZXQgc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5sZXQgc3dhcCB0IGkgaiA9IFVuaWZvcm1fYXJyYXkuc3dhcCB0IGkgalxubGV0IHVuc2FmZV9nZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbmxldCB1bnNhZmVfZ2V0X3NvbWVfZXhuIHQgaSA9IENoZWFwX29wdGlvbi52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5cbmxldCB1bnNhZmVfZ2V0X3NvbWVfYXNzdW1pbmdfc29tZSB0IGkgPVxuICBDaGVhcF9vcHRpb24udmFsdWVfdW5zYWZlIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxuOztcblxubGV0IHVuc2FmZV9pc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9zZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgdW5zYWZlX3NldF9zb21lIHQgaSB4ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCB1bnNhZmVfc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSBDaGVhcF9vcHRpb24ubm9uZVxuXG5sZXQgY2xlYXIgdCA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICB1bnNhZmVfc2V0X25vbmUgdCBpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBpbnB1dCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggaW5wdXQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IGlucHV0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyIGlucHV0IH5mID0gaXRlcmkgaW5wdXQgfmY6KGZ1biAoXyA6IGludCkgeCAtPiBmIHgpIFtAbm9udGFpbF1cblxubGV0IGZvbGRpIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IGFjYyA6PSBmIGkgIWFjYyBlbGVtKTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGQgaW5wdXQgfmluaXQgfmYgPSBmb2xkaSBpbnB1dCB+aW5pdCB+ZjooZnVuIChfIDogaW50KSBhY2MgeCAtPiBmIGFjYyB4KSBbQG5vbnRhaWxdXG5cbmluY2x1ZGUgSW5kZXhlZF9jb250YWluZXIuTWFrZV9nZW4gKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgXykgdCA9ICdhIHRcbiAgICB0eXBlICdhIGVsdCA9ICdhIG9wdGlvblxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBsZW5ndGggPSBVbmlmb3JtX2FycmF5Lmxlbmd0aFxuXG5sZXQgbWFwaSBpbnB1dCB+ZiA9XG4gIGxldCBvdXRwdXQgPSBjcmVhdGUgfmxlbjoobGVuZ3RoIGlucHV0KSBpblxuICBpdGVyaSBpbnB1dCB+ZjooZnVuIGkgZWxlbSAtPiB1bnNhZmVfc2V0IG91dHB1dCBpIChmIGkgZWxlbSkpO1xuICBvdXRwdXRcbjs7XG5cbmxldCBtYXAgaW5wdXQgfmYgPSBtYXBpIGlucHV0IH5mOihmdW4gKF8gOiBpbnQpIGVsZW0gLT4gZiBlbGVtKSBbQG5vbnRhaWxdXG5cbmxldCBtYXBfc29tZSBpbnB1dCB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXQgaW5cbiAgbGV0IG91dHB1dCA9IGNyZWF0ZSB+bGVuIGluXG4gIGxldCAoKSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBvcHQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgaW5wdXQgaSBpblxuICAgICAgQ2hlYXBfb3B0aW9uLml0ZXJfc29tZSBvcHQgfmY6KGZ1biB4IC0+IHVuc2FmZV9zZXRfc29tZSBvdXRwdXQgaSAoZiB4KSlcbiAgICBkb25lXG4gIGluXG4gIG91dHB1dFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID0gaW5pdCAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuXG5sZXQgb2ZfYXJyYXlfc29tZSBhcnJheSA9XG4gIGluaXRfc29tZSAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuOztcblxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTFfZ2VuZXJpYyAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGNvcHkgPSBVbmlmb3JtX2FycmF5LmNvcHlcblxubW9kdWxlIEZvcl90ZXN0aW5nID0gc3RydWN0XG4gIG1vZHVsZSBVbnNhZmVfY2hlYXBfb3B0aW9uID0gQ2hlYXBfb3B0aW9uXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMjgyNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfc3JjX3N0YWNrX21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw1IiwiYTMiLCJhNCIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX09wdGlvbl9hcnJheSIsIkJhc2VfRXhuIiwiQmFzZV9FcnJvciIsIkJhc2VfTGlzdCIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9TZXhwIiwiQmFzZV9Db250YWluZXIiLCJyYWlzZV9zIiwiY3N0X3N0YWNrIiwiY3N0X2V4biIsImNzdF9TdGFja19pbnZhcmlhbnRfZmFpbGVkIiwiY2FwYWNpdHkiLCJ0IiwiaW52YXJpYW50IiwiaW52YXJpYW50X2EiLCJsZW5ndGgiLCJlbHRzIiwiaSIsImV4biIsIm9mX2FfMDAxIiwibGVuZ3RoXzAwMyIsImVsdHNfMDA1IiwiYXJnXzAwNiIsImJuZHNfMDAyIiwiYXJnXzAwNCIsImNyZWF0ZSIsInBhcmFtIiwiaXNfZW1wdHkiLCJmb2xkIiwiaW5pdCIsInIiLCJpdGVyIiwiQyIsIm1lbSIsImV4aXN0cyIsImZvcl9hbGwiLCJjb3VudCIsInN1bSIsImZpbmQiLCJmaW5kX21hcCIsInRvX2xpc3QiLCJ0b19hcnJheSIsIm1pbl9lbHQiLCJtYXhfZWx0IiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwib2ZfbGlzdCIsImwiLCJtYXRjaCIsImEiLCJzZXhwX29mX3QiLCJzZXhwX29mX2EiLCJ0X29mX3NleHAiLCJhX29mX3NleHAiLCJzZXhwIiwidF9zZXhwX2dyYW1tYXIiLCJncmFtbWFyIiwicmVzaXplIiwic2l6ZSIsImFyciIsInNldF9jYXBhY2l0eSIsIm5ld19jYXBhY2l0eSIsInB1c2giLCJwb3Bfbm9uZW1wdHkiLCJyZXN1bHQiLCJwb3BfZXJyb3IiLCJwb3AiLCJwb3BfZXhuIiwidG9wX25vbmVtcHR5IiwidG9wX2Vycm9yIiwidG9wIiwidG9wX2V4biIsImNvcHkiLCJjbGVhciIsInVudGlsX2VtcHR5IiwiZmlsdGVyX21hcCIsInRfcmVzdWx0IiwieCIsImZpbHRlciIsImZpbHRlcl9pbnBsYWNlIiwid3JpdGVfaW5kZXgiLCJyZWFkX2luZGV4Iiwic2luZ2xldG9uIiwiQmFzZV9TdGFjayJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL3N0YWNrLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFNBQUFDLEdDb0NpQiw4Q0FBMEI7QUFBQSxZQUFBQyxVQUFBQyxhQUFBRjtBQUFBQSxRQUFBRyxTQUU3QixNQUFBQyxPQUFBO0FBQUEsSUFDWjtBQUFBLGlDQUNtQztBQUFBLGdCQUNw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QUE7QUFBQTtBQUFBLEVEMUoxRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFN0YWNrX2ludGZcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgc2ltaWxhciB0byBbRGVxdWVdIGluIHRoYXQgaXQgdXNlcyBhbiBhcnJheSBvZiBbJ2FdIGFuZFxuICAgYSBtdXRhYmxlIFtpbnRdIHRvIGluZGljYXRlIHdoYXQgaW4gdGhlIGFycmF5IGlzIHVzZWQuICBXZSBjaG9vc2UgdG8gaW1wbGVtZW50IFtTdGFja11cbiAgIGRpcmVjdGx5IHJhdGhlciB0aGFuIG9uIHRvcCBvZiBbRGVxdWVdIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgRS5nLiBhIHNpbXBsZVxuICAgbWljcm9iZW5jaG1hcmsgc2hvd3MgdGhhdCBwdXNoL3BvcCBpcyBhYm91dCAyMCUgZmFzdGVyLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICA7IG11dGFibGUgZWx0cyA6ICdhIE9wdGlvbl9hcnJheS50XG4gIH1cbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDFfIHsgbGVuZ3RoID0gbGVuZ3RoX18wMDNfOyBlbHRzID0gZWx0c19fMDA1XyB9IC0+XG4gIGxldCBibmRzX18wMDJfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA2XyA9IE9wdGlvbl9hcnJheS5zZXhwX29mX3QgX29mX2FfXzAwMV8gZWx0c19fMDA1XyBpblxuICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJlbHRzXCI7IGFyZ19fMDA2XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDNfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxlbmd0aFwiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxubGV0IHNleHBfb2ZfdCA9IGBSZWJvdW5kX2xhdGVyXG5sZXQgXyA9IHNleHBfb2ZfdFxubGV0IGNhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c1xuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hICh7IGxlbmd0aDsgZWx0cyB9IGFzIHQpIDogdW5pdCA9XG4gIHRyeVxuICAgIGFzc2VydCAoMCA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyk7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICAgIGludmFyaWFudF9hIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgaSlcbiAgICBkb25lO1xuICAgICgqIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB1bnVzZWQgZWxlbWVudHMgYXJlIHVuc2V0IHRvIGF2b2lkIGEgc3BhY2VcbiAgICAgICBsZWFrLiAqKVxuICAgIGZvciBpID0gbGVuZ3RoIHRvIE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyAtIDEgZG9cbiAgICAgIGFzc2VydCAobm90IChPcHRpb25fYXJyYXkuaXNfc29tZSBlbHRzIGkpKVxuICAgIGRvbmVcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiU3RhY2suaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiZXhuXCIsIGV4biB8PiBFeG4uc2V4cF9vZl90OyBcInN0YWNrXCIsIHQgfD4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2Zfb3BhcXVlIF0pXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpICgpIDogYSB0ID0geyBsZW5ndGggPSAwOyBlbHRzID0gT3B0aW9uX2FycmF5LmVtcHR5IH1cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG4oKiBUaGUgb3JkZXIgaW4gd2hpY2ggZWxlbWVudHMgYXJlIHZpc2l0ZWQgaGFzIGJlZW4gY2hvc2VuIHNvIGFzIHRvIGJlIGJhY2t3YXJkc1xuICAgY29tcGF0aWJsZSB3aXRoIFtTdGRsaWIuU3RhY2tdICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAhciAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIGYgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmVcbjs7XG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBtZW0gPSBDLm1lbVxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCB0b19hcnJheSA9IEMudG9fYXJyYXlcbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcblxubGV0IG9mX2xpc3QgKHR5cGUgYSkgKGwgOiBhIGxpc3QpID1cbiAgaWYgTGlzdC5pc19lbXB0eSBsXG4gIHRoZW4gY3JlYXRlICgpXG4gIGVsc2UgKFxuICAgIGxldCBsZW5ndGggPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46KDIgKiBsZW5ndGgpIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgIGZvciBpID0gbGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIE9wdGlvbl9hcnJheS5zZXRfc29tZSBlbHRzIGkgYTtcbiAgICAgICAgciA6PSBsXG4gICAgZG9uZTtcbiAgICB7IGxlbmd0aDsgZWx0cyB9KVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IExpc3Quc2V4cF9vZl90IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKExpc3QudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmxldCByZXNpemUgdCBzaXplID1cbiAgbGV0IGFyciA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpzaXplIGluXG4gIE9wdGlvbl9hcnJheS5ibGl0IH5zcmM6dC5lbHRzIH5kc3Q6YXJyIH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOnQubGVuZ3RoO1xuICB0LmVsdHMgPC0gYXJyXG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5IHQgbmV3X2NhcGFjaXR5ID1cbiAgbGV0IG5ld19jYXBhY2l0eSA9IG1heCBuZXdfY2FwYWNpdHkgKGxlbmd0aCB0KSBpblxuICBpZiBuZXdfY2FwYWNpdHkgPD4gY2FwYWNpdHkgdCB0aGVuIHJlc2l6ZSB0IG5ld19jYXBhY2l0eVxuOztcblxubGV0IHB1c2ggdCBhID1cbiAgaWYgdC5sZW5ndGggPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyB0aGVuIHJlc2l6ZSB0ICgyICogKHQubGVuZ3RoICsgMSkpO1xuICBPcHRpb25fYXJyYXkuc2V0X3NvbWUgdC5lbHRzIHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHBvcF9ub25lbXB0eSB0ID1cbiAgbGV0IGkgPSB0Lmxlbmd0aCAtIDEgaW5cbiAgbGV0IHJlc3VsdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkgaW5cbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpO1xuICB0Lmxlbmd0aCA8LSBpO1xuICByZXN1bHRcbjs7XG5cbmxldCBwb3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay5wb3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHBvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChwb3Bfbm9uZW1wdHkgdClcbmxldCBwb3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgcG9wX2Vycm9yIGVsc2UgcG9wX25vbmVtcHR5IHRcbmxldCB0b3Bfbm9uZW1wdHkgdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzICh0Lmxlbmd0aCAtIDEpXG5sZXQgdG9wX2Vycm9yID0gRXJyb3Iub2Zfc3RyaW5nIFwiU3RhY2sudG9wIG9mIGVtcHR5IHN0YWNrXCJcbmxldCB0b3AgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAodG9wX25vbmVtcHR5IHQpXG5sZXQgdG9wX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIEVycm9yLnJhaXNlIHRvcF9lcnJvciBlbHNlIHRvcF9ub25lbXB0eSB0XG5sZXQgY29weSB7IGxlbmd0aDsgZWx0cyB9ID0geyBsZW5ndGg7IGVsdHMgPSBPcHRpb25fYXJyYXkuY29weSBlbHRzIH1cblxubGV0IGNsZWFyIHQgPVxuICBpZiB0Lmxlbmd0aCA+IDBcbiAgdGhlbiAoXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwKVxuOztcblxubGV0IHVudGlsX2VtcHR5IHQgZiA9XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgaWYgdC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBmIChwb3Bfbm9uZW1wdHkgdCk7XG4gICAgICBsb29wICgpKVxuICBpblxuICBsb29wICgpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgIG1hdGNoIGYgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgeCAtPiBwdXNoIHRfcmVzdWx0IHhcbiAgZG9uZTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgbGV0IHggPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpIGluXG4gICAgaWYgZiB4IHRoZW4gcHVzaCB0X3Jlc3VsdCB4XG4gIGRvbmU7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB3cml0ZV9pbmRleCA9IHJlZiAwIGluXG4gIEV4bi5wcm90ZWN0XG4gICAgfmY6KGZ1biAoKSAtPlxuICAgICAgZm9yIHJlYWRfaW5kZXggPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgICBsZXQgeCA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfYXNzdW1pbmdfc29tZSB0LmVsdHMgcmVhZF9pbmRleCBpblxuICAgICAgICBpZiBmIHhcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgaWYgIXdyaXRlX2luZGV4IDwgcmVhZF9pbmRleFxuICAgICAgICAgIHRoZW4gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgIXdyaXRlX2luZGV4IHg7XG4gICAgICAgICAgaW5jciB3cml0ZV9pbmRleClcbiAgICAgIGRvbmUpXG4gICAgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgICAgZm9yIGkgPSAhd3JpdGVfaW5kZXggdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgdC5lbHRzIGlcbiAgICAgIGRvbmU7XG4gICAgICB0Lmxlbmd0aCA8LSAhd3JpdGVfaW5kZXgpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIHB1c2ggdCB4O1xuICB0XG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMjA1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW50IiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NvdXJjZV9jb2RlX3Bvc2l0aW9uMCIsIkJhc2VfQ29tcGFyYWJsZSIsImhhc2hfb3ZlcnJpZGUiLCJwYXJhbSIsInBvc19jbnVtIiwicG9zX2JvbCIsInBvc19sbnVtIiwicG9zX2ZuYW1lIiwiaGFzaF9mb2xkX3QiLCJjb21wYXJhdG9yIiwidG9fc3RyaW5nIiwic2V4cF9vZl90IiwiaW5jbHVkZSIsInN5bWJvbCIsImVxdWFsIiwiY29tcGFyZSIsIm1pbiIsIm1heCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJvZl9wb3MiLCJCYXNlX1NvdXJjZV9jb2RlX3Bvc2l0aW9uIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24ubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxZQUFBQyxjQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxXQ0lrQjtBQUFBLEtBQUFDLFVBQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsWUFBQTtBQUFBLFdBSVg7QUFBQSxXQURBO0FBQUEsV0FEQTtBQUFBLFdBREw7QUFBQTtBQUFBO0FBQUEsSUFFcUIsNkNBQ0M7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0RSeEI7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQWIsZUFBQTtBQUFBLFlBQUFjLE9BQUFwQjtBQUFBQSxRQUFBQyxXQ29CVyxVQUFBRSxXQUFBLFVBQUFDLFlBQUE7QUFBQSxJQUNUO0FBQUEsR0FBOEM7QUFBQTtBQUFBLElBQUFpQjtBQUFBQSxNRHJCaEQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG4oKiBUaGlzIGlzIGxpZnRlZCBvdXQgb2YgW01dIGJlY2F1c2UgW1NvdXJjZV9jb2RlX3Bvc2l0aW9uMF0gZXhwb3J0cyBbU3RyaW5nMF1cbiAgIGFzIFtTdHJpbmddLCB3aGljaCBkb2VzIG5vdCBleHBvcnQgYSBoYXNoIGZ1bmN0aW9uLiAqKVxubGV0IGhhc2hfb3ZlcnJpZGUgeyBTdGRsaWIuTGV4aW5nLnBvc19mbmFtZTsgcG9zX2xudW07IHBvc19ib2w7IHBvc19jbnVtIH0gPVxuICBTdHJpbmcuaGFzaCBwb3NfZm5hbWVcbiAgbHhvciBJbnQuaGFzaCBwb3NfbG51bVxuICBseG9yIEludC5oYXNoIHBvc19ib2xcbiAgbHhvciBJbnQuaGFzaCBwb3NfY251bVxuOztcblxubW9kdWxlIE0gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTb3VyY2VfY29kZV9wb3NpdGlvbjBcblxuICBsZXQgaGFzaCA9IGhhc2hfb3ZlcnJpZGVcbmVuZFxuXG5pbmNsdWRlIE1cbmluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlX3VzaW5nX2NvbXBhcmF0b3IgKE0pXG5cbmxldCBvZl9wb3MgKHBvc19mbmFtZSwgcG9zX2xudW0sIHBvc19jbnVtLCBfKSA9XG4gIHsgcG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgPSAwIH1cbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjMyOTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X05hbiIsImNzdF9OZWciLCJjc3RfUG9zIiwiY3N0X1plcm8iLCJjc3RfbmFuIiwiY3N0X25lZyIsImNzdF9wb3MiLCJjc3RfemVybyIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJlcnJvcl9zb3VyY2VfMDAzIiwidF9zZXhwX2dyYW1tYXIiLCJhbGwiLCJtb2R1bGVfbmFtZSIsIkJhc2VfU2lnbiIsIkJhc2VfSW1wb3J0IiwiQmFzZV9Qb2x5MCIsIkJhc2VfSGFzaCIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsIkJhc2VfSWRlbnRpZmlhYmxlIiwidF9vZl9zZXhwIiwic2V4cF8wMDQiLCJzZXhwX29mX3QiLCJwYXJhbSIsImNvbXBhcmUiLCJoYXNoX2ZvbGRfdCIsImhzdiIsImFyZyIsImhhc2giLCJvZl9zdHJpbmciLCJzIiwidG9fc3RyaW5nIiwidCIsInN5bWJvbCIsIngiLCJ5IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImVxdWFsIiwibWF4IiwibWluIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsInBwIiwiaGFzaGFibGUiLCJjc3RfQmFzZV9TaWduX29yX25hbl90b19zaWduX2UiLCJjc3RfbmVnYXRpdmUiLCJjc3RfcG9zaXRpdmUiLCJjc3Rfbm90X2FfbnVtYmVyIiwib2Zfc2lnbiIsInRvX3NpZ25fZXhuIiwib2ZfaW50IiwibiIsInRvX2ludF9leG4iLCJmbGlwIiwidG9fc3RyaW5nX2h1bSIsIkJhc2VfU2lnbl9vcl9uYW4iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9zaWduX29yX25hbi5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxVQ1lLO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUE7QUFBQUE7QUFBQUEsS0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FFMEM7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Q0M7QUFBQTtBQUFBLE9BQ0Q7QUFBQSxlQUNBO0FBQUE7QUFBQSxHQUFHO0FBQUEsWUFBQVUsU0FBQUQsS0FBQUE7QUFBQUEsSUFJWjtBQUFBLGVBRTJDLHNCQUFoQjtBQUFBLEtBQVosT0FBNkMsUUFBN0Msb0NBQTZDO0FBQUE7QUFBQSxJQUR2QztBQUFBLEdBQ3VDO0FBQUEsWUFBQXlCLGNBQUFsQztBQUFBQSxJQUcxQztBQUFBO0FBQUEsT0FDVDtBQUFBO0FBQUEsT0FDQztBQUFBO0FBQUEsT0FDRDtBQUFBLGVBQ0E7QUFBQTtBQUFBLEdBQWM7QUFBQTtBQUFBLElBQUFtQztBQUFBQSxNQXBFckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQzRUoiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmVnXG4gICAgfCBaZXJvXG4gICAgfCBQb3NcbiAgICB8IE5hblxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcInNpZ25fb3JfbmFuLm1sLlQudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgLT4gTmVnXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgPSAoU3RkbGliLmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgIHwgTmVnIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICAgIHwgWmVybyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgICB8IFBvcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICB8IE5hbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDNcbiAgICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3M7IE5hbiBdIDogdCBsaXN0KVxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TaWduX29yX25hblwiXG5lbmRcblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogVC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogVC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogVC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IFQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogVC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBULnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBvZl9zaWduID0gZnVuY3Rpb25cbiAgfCBTaWduLk5lZyAtPiBOZWdcbiAgfCBTaWduLlplcm8gLT4gWmVyb1xuICB8IFNpZ24uUG9zIC0+IFBvc1xuOztcblxubGV0IHRvX3NpZ25fZXhuID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gU2lnbi5OZWdcbiAgfCBaZXJvIC0+IFNpZ24uWmVyb1xuICB8IFBvcyAtPiBTaWduLlBvc1xuICB8IE5hbiAtPiBpbnZhbGlkX2FyZyBcIkJhc2UuU2lnbl9vcl9uYW4udG9fc2lnbl9leG46IE5hblwiXG47O1xuXG5sZXQgb2ZfaW50IG4gPSBvZl9zaWduIChTaWduLm9mX2ludCBuKVxubGV0IHRvX2ludF9leG4gdCA9IFNpZ24udG9faW50ICh0b19zaWduX2V4biB0KVxuXG5sZXQgZmxpcCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFBvc1xuICB8IFplcm8gLT4gWmVyb1xuICB8IFBvcyAtPiBOZWdcbiAgfCBOYW4gLT4gTmFuXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOYW4sIF8gfCBfLCBOYW4gLT4gTmFuXG4gIHwgXyAtPiBvZl9zaWduIChTaWduLiggKiApICh0b19zaWduX2V4biB0KSAodG9fc2lnbl9leG4gdCcpKVxuOztcblxubGV0IHRvX3N0cmluZ19odW0gPSBmdW5jdGlvblxuICB8IE5lZyAtPiBcIm5lZ2F0aXZlXCJcbiAgfCBaZXJvIC0+IFwiemVyb1wiXG4gIHwgUG9zIC0+IFwicG9zaXRpdmVcIlxuICB8IE5hbiAtPiBcIm5vdC1hLW51bWJlclwiXG47O1xuXG4oKiBJbmNsdWRlIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyIGFueSBmdW5jdG9yIGFwcGxpY2F0aW9ucyB0aGF0XG4gICBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNTcyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIkJhc2VfU2V4cCIsIkJhc2VfQ29tcGFyYWJsZSIsImhhc2hfZm9sZF90IiwiaGFzaCIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsIk5vdF9mb3VuZF9zIiwiT2Zfc2V4cF9lcnJvciIsIm1lc3NhZ2UiLCJkZWZhdWx0X2luZGVudCIsInBwX2h1bSIsInBwX2h1bV9pbmRlbnQiLCJwcF9tYWNoIiwicHAiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJ0b19zdHJpbmciLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsInRfc2V4cF9ncmFtbWFyIiwiaW52YXJpYW50Iiwib2Zfc3RyaW5nIiwiaW5jbHVkZSIsInN5bWJvbCIsImVxdWFsIiwiY29tcGFyZSIsIm1pbiIsIm1heCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwiQmFzZV9TZXhwX3dpdGhfY29tcGFyYWJsZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMzY2NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0hhc2hlciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsY0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNjc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9BYm92ZV91cHBlcl9ib3VuZCIsImNzdF9CZWxvd19sb3dlcl9ib3VuZCIsImNzdF9FeGNsIiwiY3N0X0luX3JhbmdlIiwiY3N0X0luY2wiLCJjc3RfVW5ib3VuZGVkIiwiY3N0X2Fib3ZlX3VwcGVyX2JvdW5kIiwiY3N0X2JlbG93X2xvd2VyX2JvdW5kIiwiY3N0X2V4Y2wiLCJjc3RfaW5fcmFuZ2UiLCJjc3RfaW5jbCIsImNzdF91bmJvdW5kZWQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAyNyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9IYXNoIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiQmFzZV9MaXN0IiwiYWxsIiwiYWxsX29mX2EiLCJsIiwiYWNjIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJ0X29mX3NleHAiLCJvZl9hXzAwMyIsInNleHBfMDA4IiwidGFnXzAwOSIsInNleHBfYXJnc18wMTAiLCJhcmcwXzAxMSIsInJlczBfMDEyIiwic2V4cF9hcmdzXzAxNSIsImFyZzBfMDE2IiwicmVzMF8wMTciLCJzZXhwX29mX3QiLCJvZl9hXzAxOSIsInBhcmFtIiwiYXJnMF8wMjAiLCJyZXMwXzAyMSIsImFyZzBfMDIyIiwicmVzMF8wMjMiLCJ0X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwIiwic2V4cF8wMjgiLCJzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24iLCJjc3RfTWF5YmVfYm91bmRfY29tcGFyZV90b19pbnQiLCJoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImhzdiIsImFyZyIsImhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiIsIm1hcCIsInQiLCJpbmNsIiwiZXhjbCIsImlzX2xvd2VyX2JvdW5kIiwiYSIsImNvbXBhcmUiLCJpc191cHBlcl9ib3VuZCIsImJvdW5kc19jcm9zc2VkIiwibG93ZXIiLCJ1cHBlciIsImNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIiwiaW50ZXJ2YWxfY29udGFpbnNfZXhuIiwiQmFzZV9NYXliZV9ib3VuZCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL21heWJlX2JvdW5kLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFB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QUFBO0FBQUEsWUFBQU0sc0JBQUFILE9BQUFDLE9BQUFMLEdBQUFDO0FBQUFBLElBSVAsc0VBRTBDO0FBQUE7QUFBQTtBQUFBLElBQUFPO0FBQUFBLE1BcERoRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEL0tGIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID1cbiAgfCBJbmNsIG9mICdhXG4gIHwgRXhjbCBvZiAnYVxuICB8IFVuYm91bmRlZFxuW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgYWxsIDogJ2EuICdhIGxpc3QgLT4gJ2EgdCBsaXN0ID1cbiAgZnVuIF9hbGxfb2ZfYSAtPlxuICBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LmFwcGVuZFxuICAgIChsZXQgcmVjIG1hcCBsIGFjYyA9XG4gICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgfCBbXSAtPiBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LnJldiBhY2NcbiAgICAgICB8IGVudW1lcmF0ZV9fMDAxXyA6OiBsIC0+IG1hcCBsIChJbmNsIGVudW1lcmF0ZV9fMDAxXyA6OiBhY2MpXG4gICAgIGluXG4gICAgIG1hcCBfYWxsX29mX2EgW10pXG4gICAgKFBweF9lbnVtZXJhdGVfbGliLkxpc3QuYXBwZW5kXG4gICAgICAgKGxldCByZWMgbWFwIGwgYWNjID1cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IFBweF9lbnVtZXJhdGVfbGliLkxpc3QucmV2IGFjY1xuICAgICAgICAgIHwgZW51bWVyYXRlX18wMDJfIDo6IGwgLT4gbWFwIGwgKEV4Y2wgZW51bWVyYXRlX18wMDJfIDo6IGFjYylcbiAgICAgICAgaW5cbiAgICAgICAgbWFwIF9hbGxfb2ZfYSBbXSlcbiAgICAgICBbIFVuYm91bmRlZCBdKVxuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMThfKSA6ICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxOF8pIC0+IFNleHBsaWIwLlNleHAudCAtPiBhX18wMThfIHQpIC0+XG4gIGxldCBlcnJvcl9zb3VyY2VfXzAwNl8gPSBcIm1heWJlX2JvdW5kLm1sLnRcIiBpblxuICBmdW4gX29mX2FfXzAwM18gLT4gZnVuY3Rpb25cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgX3RhZ19fMDA5XykgOjogc2V4cF9hcmdzX18wMTBfKSBhc1xuICAgICAgX3NleHBfXzAwOF8gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxMF8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTFfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTJfID0gX29mX2FfXzAwM18gYXJnMF9fMDExXyBpblxuICAgICAgICAgSW5jbCByZXMwX18wMTJfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA2X1xuICAgICAgICAgICBfdGFnX18wMDlfXG4gICAgICAgICAgIF9zZXhwX18wMDhfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBfdGFnX18wMTRfKSA6OiBzZXhwX2FyZ3NfXzAxNV8pIGFzXG4gICAgICBfc2V4cF9fMDEzXyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxNl8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxN18gPSBfb2ZfYV9fMDAzXyBhcmcwX18wMTZfIGluXG4gICAgICAgICBFeGNsIHJlczBfXzAxN19cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDZfXG4gICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgX3NleHBfXzAxM18pXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwidW5ib3VuZGVkXCIgfCBcIlVuYm91bmRlZFwiKSAtPiBVbmJvdW5kZWRcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ1bmJvdW5kZWRcIiB8IFwiVW5ib3VuZGVkXCIpIDo6IF8pIGFzXG4gICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICB8IHNleHBfXzAwNV8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biAodHlwZSBhX18wMjRfKSA6ICgoYV9fMDI0XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAyNF8gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfYV9fMDE5XyAtPiBmdW5jdGlvblxuICAgIHwgSW5jbCBhcmcwX18wMjBfIC0+XG4gICAgICBsZXQgcmVzMF9fMDIxXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMF8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkluY2xcIjsgcmVzMF9fMDIxXyBdXG4gICAgfCBFeGNsIGFyZzBfXzAyMl8gLT5cbiAgICAgIGxldCByZXMwX18wMjNfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXhjbFwiOyByZXMwX18wMjNfIF1cbiAgICB8IFVuYm91bmRlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmJvdW5kZWRcIlxuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiSW5jbFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRXhjbFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlVuYm91bmRlZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuXG50eXBlIGludGVydmFsX2NvbXBhcmlzb24gPVxuICB8IEJlbG93X2xvd2VyX2JvdW5kXG4gIHwgSW5fcmFuZ2VcbiAgfCBBYm92ZV91cHBlcl9ib3VuZFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgaGFzaF1cblxubGV0IGludGVydmFsX2NvbXBhcmlzb25fb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMjdfID0gXCJtYXliZV9ib3VuZC5tbC5pbnRlcnZhbF9jb21wYXJpc29uXCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJiZWxvd19sb3dlcl9ib3VuZFwiIHwgXCJCZWxvd19sb3dlcl9ib3VuZFwiKSAtPiBCZWxvd19sb3dlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5fcmFuZ2VcIiB8IFwiSW5fcmFuZ2VcIikgLT4gSW5fcmFuZ2VcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImFib3ZlX3VwcGVyX2JvdW5kXCIgfCBcIkFib3ZlX3VwcGVyX2JvdW5kXCIpIC0+IEFib3ZlX3VwcGVyX2JvdW5kXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgOjogXykgYXMgc2V4cF9fMDI4X1xuICAgICAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIDo6IF8pIGFzIHNleHBfXzAyOF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImFib3ZlX3VwcGVyX2JvdW5kXCIgfCBcIkFib3ZlX3VwcGVyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAyOF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMjZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjZfXG4gICB8IHNleHBfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgICAgICAgICAgICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IGludGVydmFsX2NvbXBhcmlzb24pXG47O1xuXG5sZXQgc2V4cF9vZl9pbnRlcnZhbF9jb21wYXJpc29uID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBCZWxvd19sb3dlcl9ib3VuZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJCZWxvd19sb3dlcl9ib3VuZFwiXG4gICAgfCBJbl9yYW5nZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJJbl9yYW5nZVwiXG4gICAgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJBYm92ZV91cHBlcl9ib3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0IChpbnRlcnZhbF9jb21wYXJpc29uX3NleHBfZ3JhbW1hciA6IGludGVydmFsX2NvbXBhcmlzb24gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJCZWxvd19sb3dlcl9ib3VuZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiSW5fcmFuZ2VcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkFib3ZlX3VwcGVyX2JvdW5kXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24gPVxuICAoU3RkbGliLmNvbXBhcmUgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50KVxuOztcblxubGV0IChoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiA6XG4gICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICB8IEluX3JhbmdlIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoX2ludGVydmFsX2NvbXBhcmlzb24gOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBJbmNsIChmIGluY2wpXG4gIHwgRXhjbCBleGNsIC0+IEV4Y2wgKGYgZXhjbClcbiAgfCBVbmJvdW5kZWQgLT4gVW5ib3VuZGVkXG47O1xuXG5sZXQgaXNfbG93ZXJfYm91bmQgdCB+b2ZfOmEgfmNvbXBhcmUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gY29tcGFyZSBpbmNsIGEgPD0gMFxuICB8IEV4Y2wgZXhjbCAtPiBjb21wYXJlIGV4Y2wgYSA8IDBcbiAgfCBVbmJvdW5kZWQgLT4gdHJ1ZVxuOztcblxubGV0IGlzX3VwcGVyX2JvdW5kIHQgfm9mXzphIH5jb21wYXJlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IGNvbXBhcmUgYSBpbmNsIDw9IDBcbiAgfCBFeGNsIGV4Y2wgLT4gY29tcGFyZSBhIGV4Y2wgPCAwXG4gIHwgVW5ib3VuZGVkIC0+IHRydWVcbjs7XG5cbmxldCBib3VuZHNfY3Jvc3NlZCB+bG93ZXIgfnVwcGVyIH5jb21wYXJlID1cbiAgbWF0Y2ggbG93ZXIgd2l0aFxuICB8IFVuYm91bmRlZCAtPiBmYWxzZVxuICB8IEluY2wgbG93ZXIgfCBFeGNsIGxvd2VyIC0+XG4gICAgKG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgfCBVbmJvdW5kZWQgLT4gZmFsc2VcbiAgICAgfCBJbmNsIHVwcGVyIHwgRXhjbCB1cHBlciAtPiBjb21wYXJlIGxvd2VyIHVwcGVyID4gMClcbjs7XG5cbmxldCBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZSA9XG4gIGlmIGJvdW5kc19jcm9zc2VkIH5sb3dlciB+dXBwZXIgfmNvbXBhcmVcbiAgdGhlbiBmYWlsd2l0aCBcIk1heWJlX2JvdW5kLmNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuOiBsb3dlciBib3VuZCA+IHVwcGVyIGJvdW5kXCJcbjs7XG5cbmxldCBjb21wYXJlX3RvX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgPVxuICBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZTtcbiAgaWYgbm90IChpc19sb3dlcl9ib3VuZCBsb3dlciB+b2ZfOmEgfmNvbXBhcmUpXG4gIHRoZW4gQmVsb3dfbG93ZXJfYm91bmRcbiAgZWxzZSBpZiBub3QgKGlzX3VwcGVyX2JvdW5kIHVwcGVyIH5vZl86YSB+Y29tcGFyZSlcbiAgdGhlbiBBYm92ZV91cHBlcl9ib3VuZFxuICBlbHNlIEluX3JhbmdlXG47O1xuXG5sZXQgaW50ZXJ2YWxfY29udGFpbnNfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSA9XG4gIG1hdGNoIGNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSB3aXRoXG4gIHwgSW5fcmFuZ2UgLT4gdHJ1ZVxuICB8IEJlbG93X2xvd2VyX2JvdW5kIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gZmFsc2Vcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjM5OTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0xlZnQiLCJjc3RfUmlnaHQiLCJjc3RfVW5lcXVhbCIsImNhbWxfY29tcGFyZSIsImNhbWxfZXF1YWwiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsImVycm9yX3NvdXJjZV8wNTciLCJhbGwiLCJTZXhwbGliMF9TZXhwX2NvbnZfZXJyb3IiLCJjb21wYXJlIiwiY21wX2EiLCJhXzAwMSIsImJfMDAyIiwicmlnaHRfMDA0IiwibGVmdF8wMDMiLCJlcXVhbCIsImFfMDA1IiwiYl8wMDYiLCJyaWdodF8wMDgiLCJsZWZ0XzAwNyIsInNleHBfb2ZfdCIsIm9mX2FfMDA5IiwicGFyYW0iLCJ2XzAxMCIsIk9yX2R1cGxpY2F0ZSIsIldpdGhvdXRfY29tcGFyYXRvciIsIldpdGhfY29tcGFyYXRvciIsIldpdGhfZmlyc3RfY2xhc3NfbW9kdWxlIiwiY21wX2siLCJjbXBfdiIsImFfMDExIiwiYl8wMTIiLCJ0XzAxNCIsInRfMDEzIiwidF8wMTYiLCJ0XzAxNSIsIm4iLCJyaWdodF8wMTgiLCJsZWZ0XzAxNyIsInJpZ2h0XzAyMiIsImxlZnRfMDIxIiwidF8wMjQiLCJ0XzAyMyIsInRfMDI2IiwidF8wMjUiLCJyaWdodF8wMjAiLCJsZWZ0XzAxOSIsImFfMDI3IiwiYl8wMjgiLCJ0XzAzMCIsInRfMDI5IiwidF8wMzIiLCJ0XzAzMSIsInJpZ2h0XzAzNCIsImxlZnRfMDMzIiwicmlnaHRfMDM4IiwibGVmdF8wMzciLCJ0XzA0MCIsInRfMDM5IiwidF8wNDIiLCJ0XzA0MSIsInJpZ2h0XzAzNiIsImxlZnRfMDM1IiwidF9vZl9zZXhwIiwib2Zfa18wNDMiLCJvZl92XzA0NCIsInNleHBfMDcxIiwiYXJnMV8wNjgiLCJhcmcwXzA2NyIsInJlczBfMDY5IiwiYXRvbV8wNDciLCJtYXRjaCIsInNleHBfYXJnc18wNTAiLCJhcmcwXzA1OCIsImFyZzFfMDUzIiwiYXJnMF8wNTIiLCJyZXMwXzA1NCIsInJlczFfMDU1IiwicmVzMF8wNTkiLCJhcmcwXzA2MSIsInJlczBfMDYyIiwiYXJnMF8wNjQiLCJyZXMwXzA2NSIsInJlczFfMDcwIiwib2Zfa18wNzIiLCJvZl92XzA3MyIsImFyZzFfMDgyIiwiYXJnMF8wODEiLCJyZXMwXzA4MyIsInZfMDc0IiwicmVzMV8wODQiLCJ2XzA3NiIsImFyZzFfMDc4IiwiYXJnMF8wNzciLCJyZXMwXzA3OSIsInJlczFfMDgwIiwidl8wNzUiLCJ0X3NleHBfZ3JhbW1hciIsImtfc2V4cF9ncmFtbWFyIiwidl9zZXhwX2dyYW1tYXIiLCJTeW1tZXRyaWNfZGlmZl9lbGVtZW50IiwiY21wX2xlZnQiLCJjbXBfcmlnaHQiLCJhXzA4NSIsImJfMDg2IiwicmlnaHRfMDkyIiwibGVmdF8wOTEiLCJ0XzA5NCIsInRfMDkzIiwidF8wOTYiLCJ0XzA5NSIsInJpZ2h0XzA4OCIsImxlZnRfMDg3IiwicmlnaHRfMDkwIiwibGVmdF8wODkiLCJhXzA5NyIsImJfMDk4IiwicmlnaHRfMTA0IiwibGVmdF8xMDMiLCJ0XzEwNiIsInRfMTA1IiwidF8xMDgiLCJ0XzEwNyIsInJpZ2h0XzEwMCIsImxlZnRfMDk5IiwicmlnaHRfMTAyIiwibGVmdF8xMDEiLCJvZl9sZWZ0XzEwOSIsIm9mX3JpZ2h0XzExMCIsInZfMTEzIiwiYXJnMV8xMTUiLCJhcmcwXzExNCIsInJlczBfMTE2IiwicmVzMV8xMTciLCJ2XzExMSIsInZfMTEyIiwiTWVyZ2VfZWxlbWVudCIsIkNvbnRpbnVlX29yX3N0b3AiLCJGaW5pc2hlZF9vcl91bmZpbmlzaGVkIiwiQmFzZV9NYXBfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL21hcF9pbnRmLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtB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QjtBQUFBLEdBUXJFO0FBQUE7QUFBQSxJQUFBQyxnQkF0T1A7QUFBQSxJQUFBL0gsWUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBTSxRQUFBLFVEL0dKO0FBQUEsWUFBQUssWUFBQUUsT0N1V0ssd0JBRW9DO0FBQUE7QUFBQSxJQUFBbUgsbUJBMVByQztBQUFBLElBQUFoSSxZQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFNLFFBQUEsVUQvR0o7QUFBQSxZQUFBSyxZQUFBRSxPQzRYSyx3QkFFZ0Q7QUFBQTtBQUFBLElBQUFvSCx5QkEvUWpEO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQvR0oiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxub3BlbiEgVFxuXG5tb2R1bGUgT3JfZHVwbGljYXRlID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgWyBgT2sgb2YgJ2FcbiAgICB8IGBEdXBsaWNhdGVcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwMV8gYl9fMDAyX1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgICB8IGBPayBfbGVmdF9fMDAzXywgYE9rIF9yaWdodF9fMDA0XyAtPiBfY21wX19hIF9sZWZ0X18wMDNfIF9yaWdodF9fMDA0X1xuICAgICAgfCBgRHVwbGljYXRlLCBgRHVwbGljYXRlIC0+IDBcbiAgICAgIHwgeCwgeSAtPiBTdGRsaWIuY29tcGFyZSB4IHkpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDA1XyBiX18wMDZfIC0+XG4gICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwNV8gYl9fMDA2X1xuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggYV9fMDA1XywgYl9fMDA2XyB3aXRoXG4gICAgICAgIHwgYE9rIF9sZWZ0X18wMDdfLCBgT2sgX3JpZ2h0X18wMDhfIC0+IF9jbXBfX2EgX2xlZnRfXzAwN18gX3JpZ2h0X18wMDhfXG4gICAgICAgIHwgYER1cGxpY2F0ZSwgYER1cGxpY2F0ZSAtPiB0cnVlXG4gICAgICAgIHwgeCwgeSAtPiBTdGRsaWIuKCA9ICkgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDA5XyAtPiBmdW5jdGlvblxuICAgICAgfCBgT2sgdl9fMDEwXyAtPiBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyBfb2ZfYV9fMDA5XyB2X18wMTBfIF1cbiAgICAgIHwgYER1cGxpY2F0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJEdXBsaWNhdGVcIlxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9IGNvbXBhcmF0b3I6KCdrZXksICdjbXApIENvbXBhcmF0b3IudCAtPiAnelxuZW5kXG5cbm1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICd6XG5lbmRcblxubW9kdWxlIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnayAndi4gKCdrIC0+ICdrIC0+IGludCkgLT4gKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGxldCB0X18wMTNfLCB0X18wMTRfID0gYV9fMDExXyBpblxuICAgIGxldCB0X18wMTVfLCB0X18wMTZfID0gYl9fMDEyXyBpblxuICAgIG1hdGNoIF9jbXBfX2sgdF9fMDEzXyB0X18wMTVfIHdpdGhcbiAgICB8IDAgLT5cbiAgICAgIGlmIFN0ZGxpYi4oID09ICkgdF9fMDE0XyB0X18wMTZfXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0X18wMTRfLCB0X18wMTZfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDE3XywgYExlZnQgX3JpZ2h0X18wMThfIC0+IF9jbXBfX3YgX2xlZnRfXzAxN18gX3JpZ2h0X18wMThfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMTlfLCBgUmlnaHQgX3JpZ2h0X18wMjBfIC0+IF9jbXBfX3YgX2xlZnRfXzAxOV8gX3JpZ2h0X18wMjBfXG4gICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAyMV8sIGBVbmVxdWFsIF9yaWdodF9fMDIyXyAtPlxuICAgICAgICAgIGxldCB0X18wMjNfLCB0X18wMjRfID0gX2xlZnRfXzAyMV8gaW5cbiAgICAgICAgICBsZXQgdF9fMDI1XywgdF9fMDI2XyA9IF9yaWdodF9fMDIyXyBpblxuICAgICAgICAgIChtYXRjaCBfY21wX192IHRfXzAyM18gdF9fMDI1XyB3aXRoXG4gICAgICAgICAgIHwgMCAtPiBfY21wX192IHRfXzAyNF8gdF9fMDI2X1xuICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgfCB4LCB5IC0+IFN0ZGxpYi5jb21wYXJlIHggeSlcbiAgICB8IG4gLT4gblxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2sgJ3YuXG4gICAgKCdrIC0+ICdrIC0+IGJvb2wpIC0+ICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAyN18gYl9fMDI4XyAtPlxuICAgICAgbGV0IHRfXzAyOV8sIHRfXzAzMF8gPSBhX18wMjdfIGluXG4gICAgICBsZXQgdF9fMDMxXywgdF9fMDMyXyA9IGJfXzAyOF8gaW5cbiAgICAgIFN0ZGxpYi4oICYmIClcbiAgICAgICAgKF9jbXBfX2sgdF9fMDI5XyB0X18wMzFfKVxuICAgICAgICAoaWYgU3RkbGliLiggPT0gKSB0X18wMzBfIHRfXzAzMl9cbiAgICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgIG1hdGNoIHRfXzAzMF8sIHRfXzAzMl8gd2l0aFxuICAgICAgICAgICB8IGBMZWZ0IF9sZWZ0X18wMzNfLCBgTGVmdCBfcmlnaHRfXzAzNF8gLT4gX2NtcF9fdiBfbGVmdF9fMDMzXyBfcmlnaHRfXzAzNF9cbiAgICAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzAzNV8sIGBSaWdodCBfcmlnaHRfXzAzNl8gLT4gX2NtcF9fdiBfbGVmdF9fMDM1XyBfcmlnaHRfXzAzNl9cbiAgICAgICAgICAgfCBgVW5lcXVhbCBfbGVmdF9fMDM3XywgYFVuZXF1YWwgX3JpZ2h0X18wMzhfIC0+XG4gICAgICAgICAgICAgbGV0IHRfXzAzOV8sIHRfXzA0MF8gPSBfbGVmdF9fMDM3XyBpblxuICAgICAgICAgICAgIGxldCB0X18wNDFfLCB0X18wNDJfID0gX3JpZ2h0X18wMzhfIGluXG4gICAgICAgICAgICAgU3RkbGliLiggJiYgKSAoX2NtcF9fdiB0X18wMzlfIHRfXzA0MV8pIChfY21wX192IHRfXzA0MF8gdF9fMDQyXylcbiAgICAgICAgICAgfCB4LCB5IC0+IFN0ZGxpYi4oID0gKSB4IHkpKVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICdrICd2LlxuICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2spXG4gICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAndilcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgPVxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzA1N18gPSBcIm1hcF9pbnRmLm1sLlN5bW1ldHJpY19kaWZmX2VsZW1lbnQudFwiIGluXG4gICAgZnVuIF9vZl9rX18wNDNfIF9vZl92X18wNDRfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzA2N187IGFyZzFfXzA2OF8gXSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDY5XyA9IF9vZl9rX18wNDNfIGFyZzBfXzA2N19cbiAgICAgICAgYW5kIHJlczFfXzA3MF8gPVxuICAgICAgICAgIGxldCBzZXhwX18wNjZfID0gYXJnMV9fMDY4XyBpblxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbWF0Y2ggc2V4cF9fMDY2XyB3aXRoXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIGFzIF9zZXhwX18wNDlfIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBhdG9tX18wNDdfIHdpdGhcbiAgICAgICAgICAgICAgIHwgXCJMZWZ0XCIgLT5cbiAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gX3NleHBfXzA0OV9cbiAgICAgICAgICAgICAgIHwgXCJSaWdodFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiVW5lcXVhbFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIGF0b21fXzA0N18gOjogc2V4cF9hcmdzX18wNTBfKSBhc1xuICAgICAgICAgICAgICBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIGFzIF90YWdfXzA2M18gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDY0XyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNjVfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDY0XyBpblxuICAgICAgICAgICAgICAgICAgICBgTGVmdCByZXMwX18wNjVfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA2M19cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXCJSaWdodFwiIGFzIF90YWdfXzA2MF8gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDYxXyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNjJfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDYxXyBpblxuICAgICAgICAgICAgICAgICAgICBgUmlnaHQgcmVzMF9fMDYyX1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjBfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiVW5lcXVhbFwiIGFzIF90YWdfXzA1MV8gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDU4XyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTlfID1cbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhcmcwX18wNThfIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzA1Ml87IGFyZzFfXzA1M18gXSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA1NF8gPSBfb2Zfdl9fMDQ0XyBhcmcwX18wNTJfXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmQgcmVzMV9fMDU1XyA9IF9vZl92X18wNDRfIGFyZzFfXzA1M18gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlczBfXzA1NF8sIHJlczFfXzA1NV9cbiAgICAgICAgICAgICAgICAgICAgICB8IHNleHBfXzA1Nl8gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V4cF9fMDU2X1xuICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICBgVW5lcXVhbCByZXMwX18wNTlfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA1MV9cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fdmFyaWFudF9tYXRjaCAoKSlcbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wNDhfIC0+XG4gICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyXG4gICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgc2V4cF9fMDQ4X1xuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyXG4gICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgc2V4cF9fMDQ4X1xuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5Ob192YXJpYW50X21hdGNoIC0+XG4gICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZFxuICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgc2V4cF9fMDY2X1xuICAgICAgICBpblxuICAgICAgICByZXMwX18wNjlfLCByZXMxX18wNzBfXG4gICAgICB8IHNleHBfXzA3MV8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBlcnJvcl9zb3VyY2VfXzA1N18gMiBzZXhwX18wNzFfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2sgJ3YuXG4gICAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9rX18wNzJfIF9vZl92X18wNzNfIChhcmcwX18wODFfLCBhcmcxX18wODJfKSAtPlxuICAgICAgbGV0IHJlczBfXzA4M18gPSBfb2Zfa19fMDcyXyBhcmcwX18wODFfXG4gICAgICBhbmQgcmVzMV9fMDg0XyA9XG4gICAgICAgIG1hdGNoIGFyZzFfXzA4Ml8gd2l0aFxuICAgICAgICB8IGBMZWZ0IHZfXzA3NF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IF9vZl92X18wNzNfIHZfXzA3NF8gXVxuICAgICAgICB8IGBSaWdodCB2X18wNzVfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3ZfXzA3M18gdl9fMDc1XyBdXG4gICAgICAgIHwgYFVuZXF1YWwgdl9fMDc2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmVxdWFsXCJcbiAgICAgICAgICAgIDsgKGxldCBhcmcwX18wNzdfLCBhcmcxX18wNzhfID0gdl9fMDc2XyBpblxuICAgICAgICAgICAgICAgbGV0IHJlczBfXzA3OV8gPSBfb2Zfdl9fMDczXyBhcmcwX18wNzdfXG4gICAgICAgICAgICAgICBhbmQgcmVzMV9fMDgwXyA9IF9vZl92X18wNzNfIGFyZzFfXzA3OF8gaW5cbiAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzA3OV87IHJlczFfXzA4MF8gXSlcbiAgICAgICAgICAgIF1cbiAgICAgIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wODNfOyByZXMxX18wODRfIF1cbiAgOztcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOlxuICAgICdrICd2LlxuICAgICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2ssICd2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2tfc2V4cF9ncmFtbWFyIF8ndl9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgTGlzdFxuICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICggXydrX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAsIENvbnNcbiAgICAgICAgICAgICAgICAgICAoIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJMZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlVuZXF1YWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgRW1wdHkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAsIEVtcHR5ICkgKSlcbiAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBNZXJnZV9lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdsZWZ0LCAncmlnaHQpIHQgPVxuICAgIFsgYExlZnQgb2YgJ2xlZnRcbiAgICB8IGBSaWdodCBvZiAncmlnaHRcbiAgICB8IGBCb3RoIG9mICdsZWZ0ICogJ3JpZ2h0XG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdsZWZ0ICdyaWdodC5cbiAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gaW50KVxuICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGludClcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19sZWZ0IF9jbXBfX3JpZ2h0IGFfXzA4NV8gYl9fMDg2XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDg1XyBiX18wODZfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wODVfLCBiX18wODZfIHdpdGhcbiAgICAgIHwgYExlZnQgX2xlZnRfXzA4N18sIGBMZWZ0IF9yaWdodF9fMDg4XyAtPiBfY21wX19sZWZ0IF9sZWZ0X18wODdfIF9yaWdodF9fMDg4X1xuICAgICAgfCBgUmlnaHQgX2xlZnRfXzA4OV8sIGBSaWdodCBfcmlnaHRfXzA5MF8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzA4OV8gX3JpZ2h0X18wOTBfXG4gICAgICB8IGBCb3RoIF9sZWZ0X18wOTFfLCBgQm90aCBfcmlnaHRfXzA5Ml8gLT5cbiAgICAgICAgbGV0IHRfXzA5M18sIHRfXzA5NF8gPSBfbGVmdF9fMDkxXyBpblxuICAgICAgICBsZXQgdF9fMDk1XywgdF9fMDk2XyA9IF9yaWdodF9fMDkyXyBpblxuICAgICAgICAobWF0Y2ggX2NtcF9fbGVmdCB0X18wOTNfIHRfXzA5NV8gd2l0aFxuICAgICAgICAgfCAwIC0+IF9jbXBfX3JpZ2h0IHRfXzA5NF8gdF9fMDk2X1xuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICB8IHgsIHkgLT4gU3RkbGliLmNvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGJvb2wpXG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDk3XyBiX18wOThfIC0+XG4gICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzA5N18gYl9fMDk4X1xuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggYV9fMDk3XywgYl9fMDk4XyB3aXRoXG4gICAgICAgIHwgYExlZnQgX2xlZnRfXzA5OV8sIGBMZWZ0IF9yaWdodF9fMTAwXyAtPiBfY21wX19sZWZ0IF9sZWZ0X18wOTlfIF9yaWdodF9fMTAwX1xuICAgICAgICB8IGBSaWdodCBfbGVmdF9fMTAxXywgYFJpZ2h0IF9yaWdodF9fMTAyXyAtPiBfY21wX19yaWdodCBfbGVmdF9fMTAxXyBfcmlnaHRfXzEwMl9cbiAgICAgICAgfCBgQm90aCBfbGVmdF9fMTAzXywgYEJvdGggX3JpZ2h0X18xMDRfIC0+XG4gICAgICAgICAgbGV0IHRfXzEwNV8sIHRfXzEwNl8gPSBfbGVmdF9fMTAzXyBpblxuICAgICAgICAgIGxldCB0X18xMDdfLCB0X18xMDhfID0gX3JpZ2h0X18xMDRfIGluXG4gICAgICAgICAgU3RkbGliLiggJiYgKSAoX2NtcF9fbGVmdCB0X18xMDVfIHRfXzEwN18pIChfY21wX19yaWdodCB0X18xMDZfIHRfXzEwOF8pXG4gICAgICAgIHwgeCwgeSAtPiBTdGRsaWIuKCA9ICkgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdsZWZ0ICdyaWdodC5cbiAgICAoJ2xlZnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgncmlnaHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfbGVmdF9fMTA5XyBfb2ZfcmlnaHRfXzExMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgdl9fMTExXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IF9vZl9sZWZ0X18xMDlfIHZfXzExMV8gXVxuICAgICAgfCBgUmlnaHQgdl9fMTEyXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyBfb2ZfcmlnaHRfXzExMF8gdl9fMTEyXyBdXG4gICAgICB8IGBCb3RoIHZfXzExM18gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJCb3RoXCJcbiAgICAgICAgICA7IChsZXQgYXJnMF9fMTE0XywgYXJnMV9fMTE1XyA9IHZfXzExM18gaW5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMTE2XyA9IF9vZl9sZWZ0X18xMDlfIGFyZzBfXzExNF9cbiAgICAgICAgICAgICBhbmQgcmVzMV9fMTE3XyA9IF9vZl9yaWdodF9fMTEwXyBhcmcxX18xMTVfIGluXG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMTE2XzsgcmVzMV9fMTE3XyBdKVxuICAgICAgICAgIF1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuTWFwLkNvbnRpbnVlX29yX3N0b3AgKilcbm1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb250aW51ZVxuICAgIHwgU3RvcFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9IChTdGRsaWIuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBDb250aW51ZTsgU3RvcCBdIDogdCBsaXN0KVxuICBsZXQgZXF1YWwgPSAoU3RkbGliLiggPSApIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IENvbnRpbnVlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkNvbnRpbnVlXCJcbiAgICAgIHwgU3RvcCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdG9wXCJcbiAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAuRmluaXNoZWRfb3JfdW5maW5pc2hlZCAqKVxubW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEZpbmlzaGVkXG4gICAgfCBVbmZpbmlzaGVkXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEZpbmlzaGVkOyBVbmZpbmlzaGVkIF0gOiB0IGxpc3QpXG4gIGxldCBlcXVhbCA9IChTdGRsaWIuKCA9ICkgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRmluaXNoZWQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRmluaXNoZWRcIlxuICAgICAgfCBVbmZpbmlzaGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZmluaXNoZWRcIlxuICAgICAgICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG4gIHR5cGUgJ2Ega2V5XG4gIHR5cGUgJ2NtcCBjbXBcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50IClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYWRkX2V4blxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBzZXRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCByZW1vdmVfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3YgbGlzdCkgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgY2hhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gJ2sga2V5XG4gICAgICAtPiBmOigoJ3Ygb3B0aW9uIC0+ICd2IG9wdGlvbilbQGxvY2FsXSlcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCB1cGRhdGVcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigoJ3Ygb3B0aW9uIC0+ICd2KVtAbG9jYWxdKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZpbmQgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IG9wdGlvbikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIGZpbmRfZXhuIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIG1lbSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBib29sKSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCgnayBrZXkgLT4gdW5pdClbQGxvY2FsXSkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAndiwgXykgdCAtPiBmOigoJ3YgLT4gdW5pdClbQGxvY2FsXSkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KChrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdClbQGxvY2FsXSkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOigoa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IENvbnRpbnVlX29yX3N0b3AudClbQGxvY2FsXSlcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGY6KChrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClbQGxvY2FsXSlcbiAgICAgIC0+IHVuaXQgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigoJ3YxIC0+ICd2MilbQGxvY2FsXSkgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICB2YWwgbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooKGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIGZvbGRcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooKGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpW0Bsb2NhbF0pXG4gICAgLT4gJ2FjY1xuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6XG4gICAgICAgICAoKGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYWNjIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgICAgICAgW0Bsb2NhbF0pXG4gICAgLT4gZmluaXNoOigoJ2FjYyAtPiAnZmluYWwpW0Bsb2NhbF0pXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHRcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooKGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpW0Bsb2NhbF0pXG4gICAgLT4gJ2FjY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAtPiBmOigoa2V5OidrIGtleSAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICdhY2MgLT4gJ2FjYylbQGxvY2FsXSlcbiAgICAgIC0+ICdhY2MgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooKCdrIGtleSAtPiBib29sKVtAbG9jYWxdKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gIHZhbCBmaWx0ZXIgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCgndiAtPiBib29sKVtAbG9jYWxdKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcmlcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooKGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooKCd2MSAtPiAndjIgb3B0aW9uKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigoa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigoa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooKCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOigoa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpW0Bsb2NhbF0pXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCgndiAtPiBib29sKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiBPcl9lcnJvci50LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGVxdWFsXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCd2IC0+ICd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBib29sIClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBrZXkgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sga2V5ICogJ3YpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGY6KChrZXk6J2sga2V5IC0+ICgndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pW0Bsb2NhbF0pXG4gICAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbWJpbmU6KChrZXk6J2sga2V5IC0+ICd2IC0+ICd2IC0+ICd2KVtAbG9jYWxdKVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgIC0+ICgnayBrZXksICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBkYXRhX2VxdWFsOigoJ3YgLT4gJ3YgLT4gYm9vbClbQGxvY2FsXSlcbiAgICAgIC0+IGluaXQ6J2FjY1xuICAgICAgLT4gZjooKCdhY2MgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYWNjKVtAbG9jYWxdKVxuICAgICAgLT4gJ2FjYyApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIGZvcl9hbGwgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCgndiAtPiBib29sKVtAbG9jYWxdKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooKGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKVtAbG9jYWxdKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCgndiAtPiBib29sKVtAbG9jYWxdKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOigoa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpW0Bsb2NhbF0pIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdrLCAndiwgXykgdCAtPiBmOigoJ3YgLT4gYm9vbClbQGxvY2FsXSkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KChrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbClbQGxvY2FsXSkgLT4gaW50XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gJ2sga2V5XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrIGtleSAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3BsaXRfbGVfZ3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHNwbGl0X2x0X2dlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IHVwcGVyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF0gKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGxvd2VyX2JvdW5kOidrIGtleSBNYXliZV9ib3VuZC50XG4gICAgICAtPiB1cHBlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gbWluOidrIGtleVxuICAgICAgLT4gbWF4OidrIGtleVxuICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAtPiBmOigoa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylbQGxvY2FsXSlcbiAgICAgIC0+ICdhY2MgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCByYW5nZV90b19hbGlzdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gbWluOidrIGtleSAtPiBtYXg6J2sga2V5IC0+ICgnayBrZXkgKiAndikgbGlzdCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgICAgLT4gJ2sga2V5XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG50aCA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIHJhbmsgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gaW50IG9wdGlvbikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnayBrZXksICd2LCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2sga2V5XG4gICAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidrIGtleVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KChrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpW0Bsb2NhbF0pXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgIC0+ICdrZXlcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBzZWdtZW50X29mOigoa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlbQGxvY2FsXSlcbiAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KChrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClbQGxvY2FsXSlcbiAgICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgbW9kdWxlIE1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSA6IEFwcGxpY2F0aXZlLkxhenlfYXBwbGljYXRpdmUpIDogc2lnXG4gICAgdmFsIG1hcGlcbiAgICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MiBBLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCBBLnRcblxuICAgIHZhbCBmaWx0ZXJfbWFwaVxuICAgICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbiBBLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCBBLnRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnaywgJ3YsICdjbXApIHRcbiAgdHlwZSAoJ2ssICd2LCAnY21wKSB0cmVlXG4gIHR5cGUgJ2sga2V5XG4gIHR5cGUgKCdhLCAnY21wLCAneikgY3JlYXRlX29wdGlvbnNcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBhY2Nlc3Nfb3B0aW9uc1xuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGVtcHR5IDogKCdrLCAnY21wLCAoJ2ssIF8sICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2ssICdjbXAsICdrIGtleSAtPiAndiAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogKCAnazJcbiAgICAgICwgJ2NtcDJcbiAgICAgICwgKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgICAtPiBmOigoJ2sxIGtleSAtPiAnazIga2V5KVtAbG9jYWxdKVxuICAgICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIGtleSBdIClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAoICdrMlxuICAgICAgLCAnY21wMlxuICAgICAgLCAoJ2sxLCAndiwgJ2NtcDEpIHQgLT4gZjooKCdrMSBrZXkgLT4gJ2syIGtleSlbQGxvY2FsXSkgLT4gKCdrMiwgJ3YsICdjbXAyKSB0IClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgdHJhbnNwb3NlX2tleXNcbiAgICA6ICggJ2sxXG4gICAgICAsICdjbXAxXG4gICAgICAsICggJ2syXG4gICAgICAgICwgJ2NtcDJcbiAgICAgICAgLCAoJ2sxLCAoJ2syLCAnYSwgJ2NtcDIpIHQsICdjbXAxKSB0IC0+ICgnazIsICgnazEsICdhLCAnY21wMSkgdCwgJ2NtcDIpIHQgKVxuICAgICAgICAgIGNyZWF0ZV9vcHRpb25zIClcbiAgICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgYXJyYXkgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgYXJyYXkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBsZW46aW50IC0+IGY6KChpbnQgLT4gJ2sga2V5ICogJ3YpW0Bsb2NhbF0pIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgbGlzdCAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF0gKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2MSkgbGlzdFxuICAgICAgLT4gaW5pdDondjJcbiAgICAgIC0+IGY6KCgndjIgLT4gJ3YxIC0+ICd2MilbQGxvY2FsXSlcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBsaXN0IC0+IGY6KCgndiAtPiAndiAtPiAndilbQGxvY2FsXSkgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdXG4gICAgICApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX2V4blxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIFNlcXVlbmNlLnRcbiAgICAgIC0+IGluaXQ6J3YyXG4gICAgICAtPiBmOigoJ3YyIC0+ICd2MSAtPiAndjIpW0Bsb2NhbF0pXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiBmOigoJ3YgLT4gJ3YgLT4gJ3YpW0Bsb2NhbF0pIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdFxuICAgICAgLT4gZ2V0X2tleTooKCd2IC0+ICdrIGtleSlbQGxvY2FsXSlcbiAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAndiBsaXN0IC0+IGdldF9rZXk6KCgndiAtPiAnayBrZXkpW0Bsb2NhbF0pIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfZXhuXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdCAtPiBnZXRfa2V5OigoJ3YgLT4gJ2sga2V5KVtAbG9jYWxdKSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9tdWx0aVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICd2IGxpc3QgLT4gZ2V0X2tleTooKCd2IC0+ICdrIGtleSlbQGxvY2FsXSkgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0IClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBpdGVyaTooKGY6KChrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdClbQGxvY2FsXSkgLT4gdW5pdClbQGxvY2FsXSlcbiAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOigoZjooKGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KVtAbG9jYWxdKSAtPiB1bml0KVtAbG9jYWxdKVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3RyZWUgOiAoJ2ssICdjbXAsICgnayBrZXksICd2LCAnY21wKSB0cmVlIC0+ICgnaywgJ3YsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcbiAgdHlwZSAoJ2EsICdiLCAnYykgdHJlZVxuICB0eXBlICdhIGtleVxuICB0eXBlICdhIGNtcFxuICB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9uc1xuICB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0cmVlXG4gICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgICB3aXRoIHR5cGUgJ2EgY21wIDo9ICdhIGNtcFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIGNyZWF0ZV9vcHRpb25zXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnNcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbiAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgY21wXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3BvbHkgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgKCdhLCAnYikgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYikgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG4gICAgd2l0aCB0eXBlICdrIGtleSA6PSAna1xuICAgIHdpdGggdHlwZSAnYyBjbXAgOj0gY29tcGFyYXRvcl93aXRuZXNzXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRob3V0X2NvbXBhcmF0b3IudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxuICB2YWwgc2V4cF9vZl9tX190XG4gICAgOiAgKG1vZHVsZSBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoJ3YgLT4gU2V4cC50KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBTZXhwLnRcblxuICB2YWwgbV9fdF9vZl9zZXhwXG4gICAgOiAgKG1vZHVsZSBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSAnayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgY29tcGFyZV9tX190XG4gICAgOiAgKG1vZHVsZSBDb21wYXJlX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGludClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbF9tX190XG4gICAgOiAgKG1vZHVsZSBFcXVhbF9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gYm9vbFxuXG4gIHZhbCBoYXNoX2ZvbGRfbV9fdFxuICAgIDogIChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoSGFzaC5zdGF0ZSAtPiAndiAtPiBIYXNoLnN0YXRlKVxuICAgIC0+IEhhc2guc3RhdGVcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gSGFzaC5zdGF0ZVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1hcCA9IHNpZ1xuICAoKiogW01hcF0gaXMgYSBmdW5jdGlvbmFsIGRhdGEgc3RydWN0dXJlIChiYWxhbmNlZCBiaW5hcnkgdHJlZSkgaW1wbGVtZW50aW5nIGZpbml0ZSBtYXBzXG4gICAgICBvdmVyIGEgdG90YWxseS1vcmRlcmVkIGRvbWFpbiwgY2FsbGVkIGEgXCJrZXlcIi4gKilcblxuICB0eXBlICghJ2tleSwgKyEndmFsdWUsICEnY21wKSB0XG5cbiAgbW9kdWxlIE9yX2R1cGxpY2F0ZSA9IE9yX2R1cGxpY2F0ZVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IENvbnRpbnVlX29yX3N0b3BcblxuICBtb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA6IHNpZ1xuICAgIHR5cGUgdCA9IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudCA9XG4gICAgICB8IEZpbmlzaGVkXG4gICAgICB8IFVuZmluaXNoZWRcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfZW51bWVyYXRlX2xpYi5FbnVtZXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgKCoqIE1hcHMgW0NvbnRpbnVlXSB0byBbRmluaXNoZWRdIGFuZCBbU3RvcF0gdG8gW1VuZmluaXNoZWRdLiAqKVxuICAgIHZhbCBvZl9jb250aW51ZV9vcl9zdG9wIDogQ29udGludWVfb3Jfc3RvcC50IC0+IHRcblxuICAgICgqKiBNYXBzIFtGaW5pc2hlZF0gdG8gW0NvbnRpbnVlXSBhbmQgW1VuZmluaXNoZWRdIHRvIFtTdG9wXS4gKilcbiAgICB2YWwgdG9fY29udGludWVfb3Jfc3RvcCA6IHQgLT4gQ29udGludWVfb3Jfc3RvcC50XG4gIGVuZFxuXG4gIG1vZHVsZSBNZXJnZV9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgICBbIGBMZWZ0IG9mICdsZWZ0XG4gICAgICB8IGBSaWdodCBvZiAncmlnaHRcbiAgICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICAgIF1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICB2YWwgY29tcGFyZVxuICAgICAgOiAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGludClcbiAgICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGludClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gaW50XG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gYm9vbClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gYm9vbFxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdsZWZ0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgncmlnaHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBsZWZ0IDogKCdsZWZ0LCBfKSB0IC0+ICdsZWZ0IG9wdGlvblxuICAgIHZhbCByaWdodCA6IChfLCAncmlnaHQpIHQgLT4gJ3JpZ2h0IG9wdGlvblxuICAgIHZhbCBsZWZ0X3ZhbHVlIDogKCdsZWZ0LCBfKSB0IC0+IGRlZmF1bHQ6J2xlZnQgLT4gJ2xlZnRcbiAgICB2YWwgcmlnaHRfdmFsdWUgOiAoXywgJ3JpZ2h0KSB0IC0+IGRlZmF1bHQ6J3JpZ2h0IC0+ICdyaWdodFxuXG4gICAgdmFsIHZhbHVlc1xuICAgICAgOiAgKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGxlZnRfZGVmYXVsdDonbGVmdFxuICAgICAgLT4gcmlnaHRfZGVmYXVsdDoncmlnaHRcbiAgICAgIC0+ICdsZWZ0ICogJ3JpZ2h0XG4gIGVuZFxuXG4gIHR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID0gKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMS0xMl0gdXNlIFtDb21wYXJhdG9yLk1vZHVsZS50XSBpbnN0ZWFkXCJdXG5cbiAgKCoqIFRlc3QgaWYgdGhlIGludmFyaWFudHMgb2YgdGhlIGludGVybmFsIEFWTCBzZWFyY2ggdHJlZSBob2xkLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjLlxuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBUaGUgZW1wdHkgbWFwLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBBIG1hcCB3aXRoIG9uZSAoa2V5LCBkYXRhKSBwYWlyLiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuIFRoZSBhY2N1bXVsYXRvciBpcyBwZXIta2V5LlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICAjIGxldCBtYXAgPSBTdHJpbmcuTWFwLm9mX2FsaXN0X2ZvbGRcbiAgICAgICAgICAgICAgICAgICAgICBbIFwiYVwiLCAxOyBcImFcIiwgMTA7IFwiYlwiLCAyOyBcImJcIiwgMjA7IFwiYlwiLCAyMDAgXVxuICAgICAgICAgICAgICAgICAgICAgIH5pbml0OkludC5TZXQuZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICB+ZjpTZXQuYWRkXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwcmludF9zIFslc2V4cCAobWFwIDogSW50LlNldC50IFN0cmluZy5NYXAudCldOztcbiAgICAgICAgKChhICgxIDEwKSkgKGIgKDIgMjAgMjAwKSkpXG4gICAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIF19XG4gICopXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooKCdjIC0+ICdiIC0+ICdjKVtAbG9jYWxdKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBpbnRvIGEgbWFwLCByZWR1Y2luZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuICopXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IGY6KCgnYiAtPiAnYiAtPiAnYilbQGxvY2FsXSlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pdGVyaSB+aXRlcmldIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RdLCBleGNlcHQgdGhhdCBpbnN0ZWFkIG9mIHRha2luZyBhIGNvbmNyZXRlXG4gICAgICBkYXRhIHN0cnVjdHVyZSwgaXQgdGFrZXMgYW4gaXRlcmF0aW9uIGZ1bmN0aW9uLiAgRm9yIGluc3RhbmNlLCB0byBjb252ZXJ0IGEgc3RyaW5nIHRhYmxlXG4gICAgICBpbnRvIGEgbWFwOiBbb2ZfaXRlcmkgKG1vZHVsZSBTdHJpbmcpIH5mOihIYXNodGJsLml0ZXJpIHRhYmxlKV0uICBJdCBpcyBmYXN0ZXIgdGhhblxuICAgICAgYWRkaW5nIHRoZSBlbGVtZW50cyBvbmUgYnkgb25lLiAqKVxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooKGY6KChrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KVtAbG9jYWxdKSAtPiB1bml0KVtAbG9jYWxdKVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgKCoqIExpa2UgW29mX2l0ZXJpXSBleGNlcHQgdGhhdCBpdCByYWlzZXMgYW4gZXhjZXB0aW9uIGlmIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfaXRlcmlfZXhuXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KChmOigoa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdClbQGxvY2FsXSkgLT4gdW5pdClbQGxvY2FsXSlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhIHNvcnRlZCBhcnJheSBvZiBrZXktZGF0YSBwYWlycy4gVGhlIGlucHV0IGFycmF5IG11c3QgYmUgc29ydGVkXG4gICAgICAoZWl0aGVyIGluIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyKSwgYXMgZ2l2ZW4gYnkgdGhlIHJlbGV2YW50IGNvbXBhcmF0b3IsIGFuZFxuICAgICAgbXVzdCBub3QgY29udGFpbiBkdXBsaWNhdGUga2V5cy4gSWYgZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgZG9lcyBub3QgaG9sZCxcbiAgICAgIGFuIGVycm9yIGlzIHJldHVybmVkLiAgKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9zb3J0ZWRfYXJyYXldIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgYSBtYXAgd2l0aCBicm9rZW4gaW52YXJpYW50cyB3aGVuIGFuXG4gICAgICBbRXJyb3JdIHdvdWxkIGhhdmUgYmVlbiByZXR1cm5lZC4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooKGludCAtPiAnYSAqICdiKVtAbG9jYWxdKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfc2VxdWVuY2UgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5IGMgKFNlcXVlbmNlLnRvX2FycmF5XG4gICAgICBzZXEpXSwgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgYXJyYXkuXG5cbiAgICAgIFRoZSBzZXF1ZW5jZSB3aWxsIGJlIGZvbGRlZCBvdmVyIG9uY2UsIGFuZCB0aGUgYWRkaXRpb25hbCB0aW1lIGNvbXBsZXhpdHkgaXMge2UgTyhuKX0uXG4gICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuXG4gICAgICBJZiB5b3VyIHNlcXVlbmNlIGlzIGluY3JlYXNpbmcsIHVzZSBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZV0uXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIF1cblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMsIHJldHVybmluZyBhbiBlcnJvciBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9vcl9lcnJvciBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9vcl9lcnJvciBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmFpc2luZyBhbiBleGNlcHRpb24gaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfZXhuIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9tdWx0aSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9leG4gYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXSBidXRcbiAgICAgIGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9mb2xkIGMgc2VxIH5pbml0IH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2ZvbGQgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpIH5pbml0IH5mXVxuICAgICAgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOigoJ2MgLT4gJ2IgLT4gJ2MpW0Bsb2NhbF0pXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCByZWR1Y2luZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9yZWR1Y2UgYyBzZXEgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfcmVkdWNlIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKSB+Zl1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBmOigoJ2IgLT4gJ2IgLT4gJ2IpW0Bsb2NhbF0pXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDb25zdHJ1Y3RzIGEgbWFwIGZyb20gYSBsaXN0IG9mIHZhbHVlcywgd2hlcmUgW2dldF9rZXldIGV4dHJhY3RzIGEga2V5IGZyb20gYSB2YWx1ZS5cbiAgKilcbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooKCd2IC0+ICdrKVtAbG9jYWxdKVxuICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBdXG5cbiAgKCoqIExpa2UgW29mX2xpc3Rfd2l0aF9rZXldOyByZXR1cm5zIFtFcnJvcl0gb24gZHVwbGljYXRlIGtleS4gKilcbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooKCd2IC0+ICdrKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcmFpc2VzIG9uIGR1cGxpY2F0ZSBrZXkuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X2V4blxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IGxpc3RcbiAgICAtPiBnZXRfa2V5OigoJ3YgLT4gJ2spW0Bsb2NhbF0pXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcHJvZHVjZXMgbGlzdHMgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZWFjaCBrZXkuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X211bHRpXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ3YgbGlzdFxuICAgIC0+IGdldF9rZXk6KCgndiAtPiAnaylbQGxvY2FsXSlcbiAgICAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogVGVzdHMgd2hldGhlciBhIG1hcCBpcyBlbXB0eS4gKilcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBbbGVuZ3RoIG1hcF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIFttYXBdLiAgTygxKSwgYnV0IFtUcmVlLmxlbmd0aF0gaXNcbiAgICAgIE8obikuICopXG4gIHZhbCBsZW5ndGggOiAoXywgXywgXykgdCAtPiBpbnRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCB0aGUgc3BlY2lmaWVkIG5ldyBiaW5kaW5nOyBpZiB0aGUga2V5IHdhcyBhbHJlYWR5IGJvdW5kLCBpdHNcbiAgICAgIHByZXZpb3VzIGJpbmRpbmcgZGlzYXBwZWFycy4gKilcbiAgdmFsIHNldCA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbYWRkIHQgfmtleSB+ZGF0YV0gYWRkcyBhIG5ldyBlbnRyeSB0byBbdF0gbWFwcGluZyBba2V5XSB0byBbZGF0YV0gYW5kIHJldHVybnMgW2BPa11cbiAgICAgIHdpdGggdGhlIG5ldyBtYXAsIG9yIGlmIFtrZXldIGlzIGFscmVhZHkgcHJlc2VudCBpbiBbdF0sIHJldHVybnMgW2BEdXBsaWNhdGVdLiAqKVxuICB2YWwgYWRkIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG5cbiAgdmFsIGFkZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogSWYgW2tleV0gaXMgbm90IHByZXNlbnQgdGhlbiBhZGQgYSBzaW5nbGV0b24gbGlzdCwgb3RoZXJ3aXNlLCBjb25zIGRhdGEgb250byB0aGVcbiAgICAgIGhlYWQgb2YgdGhlIGV4aXN0aW5nIGxpc3QuICopXG4gIHZhbCBhZGRfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIElmIHRoZSBrZXkgaXMgcHJlc2VudCwgdGhlbiByZW1vdmUgaXRzIGhlYWQgZWxlbWVudDsgaWYgdGhlIHJlc3VsdCBpcyBlbXB0eSwgcmVtb3ZlXG4gICAgICB0aGUga2V5LiAqKVxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciB0aGUgZW1wdHkgbGlzdCBpZiB0aGVyZSBpcyBub25lLiAqKVxuICB2YWwgZmluZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayAtPiAndiBsaXN0XG5cbiAgKCoqIFtjaGFuZ2UgdCBrZXkgfmZdIHJldHVybnMgYSBuZXcgbWFwIFttXSB0aGF0IGlzIHRoZSBzYW1lIGFzIFt0XSBvbiBhbGwga2V5cyBleGNlcHRcbiAgICAgIGZvciBba2V5XSwgYW5kIHdob3NlIHZhbHVlIGZvciBba2V5XSBpcyBkZWZpbmVkIGJ5IFtmXSwgaS5lLiwgW2ZpbmQgbSBrZXkgPSBmIChmaW5kXG4gICAgICB0IGtleSldLiAqKVxuICB2YWwgY2hhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICdrXG4gICAgLT4gZjooKCd2IG9wdGlvbiAtPiAndiBvcHRpb24pW0Bsb2NhbF0pXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbdXBkYXRlIHQga2V5IH5mXSBpcyBbY2hhbmdlIHQga2V5IH5mOihmdW4gbyAtPiBTb21lIChmIG8pKV0uICopXG4gIHZhbCB1cGRhdGUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCgndiBvcHRpb24gLT4gJ3YpW0Bsb2NhbF0pIC0+ICgnaywgJ3YsICdjbXApIHRcblxuXG4gICgqKiBSZXR1cm5zIFtTb21lIHZhbHVlXSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciBbTm9uZV0gaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAndiBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgdmFsdWUgYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgcmFpc2luZyBbU3RkbGliLk5vdF9mb3VuZF0gb3IgW05vdF9mb3VuZF9zXVxuICAgICAgaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gJ3ZcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBhbnkgYmluZGluZyBmb3IgdGhlIGtleSBpbiBxdWVzdGlvbiByZW1vdmVkLiAqKVxuICB2YWwgcmVtb3ZlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFttZW0gbWFwIGtleV0gdGVzdHMgd2hldGhlciBbbWFwXSBjb250YWlucyBhIGJpbmRpbmcgZm9yIFtrZXldLiAqKVxuICB2YWwgbWVtIDogKCdrLCBfLCAnY21wKSB0IC0+ICdrIC0+IGJvb2xcblxuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCgnayAtPiB1bml0KVtAbG9jYWxdKSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCgndiAtPiB1bml0KVtAbG9jYWxdKSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooKGtleTonayAtPiBkYXRhOid2IC0+IHVuaXQpW0Bsb2NhbF0pIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZXMgdW50aWwgdGhlIGZpcnN0IHRpbWUgW2ZdIHJldHVybnMgW1N0b3BdLiBJZiBbZl0gcmV0dXJucyBbU3RvcF0sIHRoZSBmaW5hbFxuICAgICAgcmVzdWx0IGlzIFtVbmZpbmlzaGVkXS4gT3RoZXJ3aXNlLCB0aGUgZmluYWwgcmVzdWx0IGlzIFtGaW5pc2hlZF0uICopXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOigoa2V5OidrIC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVtAbG9jYWxdKVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gICgqKiBJdGVyYXRlcyB0d28gbWFwcyBzaWRlIGJ5IHNpZGUuIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgTyhNICsgTikuICBJZiB0d29cbiAgICAgIGlucHV0cyBhcmUgW1soMCwgYSk7ICgxLCBhKV1dIGFuZCBbWygxLCBiKTsgKDIsIGIpXV0sIFtmXSB3aWxsIGJlIGNhbGxlZCB3aXRoIFtbKDAsXG4gICAgICBgTGVmdCBhKTsgKDEsIGBCb3RoIChhLCBiKSk7ICgyLCBgUmlnaHQgYildXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KChrZXk6J2sgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVtAbG9jYWxdKVxuICAgIC0+IHVuaXRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBib3VuZCB2YWx1ZXMgcmVwbGFjZWQgYnkgW2ZdIGFwcGxpZWQgdG8gdGhlIGJvdW5kIHZhbHVlcy4qKVxuICB2YWwgbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooKCd2MSAtPiAndjIpW0Bsb2NhbF0pIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgW21hcF0sIGJ1dCB0aGUgcGFzc2VkIGZ1bmN0aW9uIHRha2VzIGJvdGggW2tleV0gYW5kIFtkYXRhXSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBtYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigoa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MilbQGxvY2FsXSlcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBDb252ZXJ0IG1hcCB3aXRoIGtleXMgb2YgdHlwZSBbJ2syXSB0byBhIG1hcCB3aXRoIGtleXMgb2YgdHlwZSBbJ2syXSB1c2luZyBbZl0uICopXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooKCdrMSAtPiAnazIpW0Bsb2NhbF0pXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIF1cblxuICAoKiogTGlrZSBbbWFwX2tleXNdLCBidXQgcmFpc2VzIG9uIGR1cGxpY2F0ZSBrZXkuICopXG4gIHZhbCBtYXBfa2V5c19leG5cbiAgICA6ICAoJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCgnazEgLT4gJ2syKVtAbG9jYWxdKVxuICAgIC0+ICgnazIsICd2LCAnY21wMikgdFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOigoa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVtAbG9jYWxdKVxuICAgIC0+ICdhY2NcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBba2V5XSwgdW50aWwgdGhlIGZpcnN0XG4gICAgICB0aW1lIHRoYXQgW2ZdIHJldHVybnMgW1N0b3AgX10uIElmIFtmXSByZXR1cm5zIFtTdG9wIGZpbmFsXSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zXG4gICAgICBpbW1lZGlhdGVseSB3aXRoIHRoZSB2YWx1ZSBbZmluYWxdLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgYW5kIHRoZSBmaW5hbFxuICAgICAgY2FsbCB0byBbZl0gcmV0dXJucyBbQ29udGludWUgbGFzdF0sIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBbZmluaXNoIGxhc3RdLiAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOlxuICAgICAgICAgKChrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgICAgICAgW0Bsb2NhbF0pXG4gICAgLT4gZmluaXNoOigoJ2FjYyAtPiAnZmluYWwpW0Bsb2NhbF0pXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGRlY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0uICopXG4gIHZhbCBmb2xkX3JpZ2h0XG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KChrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpW0Bsb2NhbF0pXG4gICAgLT4gJ2FjY1xuXG4gICgqKiBGb2xkcyBvdmVyIHR3byBtYXBzIHNpZGUgYnkgc2lkZSwgbGlrZSBbaXRlcjJdLiAqKVxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooKGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICdhY2MgLT4gJ2FjYylbQGxvY2FsXSlcbiAgICAtPiAnYWNjXG5cbiAgKCoqIFtmaWx0ZXJdLCBbZmlsdGVyaV0sIFtmaWx0ZXJfa2V5c10sIFtmaWx0ZXJfbWFwXSwgYW5kIFtmaWx0ZXJfbWFwaV0gcnVuIGluIE8obilcbiAgICAgIHRpbWUuXG5cbiAgICAgIFtmaWx0ZXJdLCBbZmlsdGVyaV0sIFtmaWx0ZXJfa2V5c10sIFtwYXJ0aXRpb25fdGZdIGFuZCBbcGFydGl0aW9uaV90Zl0ga2VlcCBhIGxvdFxuICAgICAgb2Ygc2hhcmluZyBiZXR3ZWVuIHRoZWlyIHJlc3VsdCBhbmQgdGhlIG9yaWdpbmFsIG1hcC4gIERyb3BwaW5nIG9yIGtlZXBpbmcgYSBydW4gb2ZcbiAgICAgIFtrXSBjb25zZWN1dGl2ZSBlbGVtZW50cyBjb3N0cyBbTyhsb2coaykpXSBleHRyYSBtZW1vcnkuIEtlZXBpbmcgdGhlIGVudGlyZSBtYXBcbiAgICAgIGNvc3RzIG5vIGV4dHJhIG1lbW9yeSBhdCBhbGw6IFtmaWx0ZXIgfmY6KGZ1biBfIC0+IHRydWUpXSByZXR1cm5zIHRoZSBvcmlnaW5hbCBtYXAuXG4gICopXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooKCdrIC0+IGJvb2wpW0Bsb2NhbF0pIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgZmlsdGVyIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigoJ3YgLT4gYm9vbClbQGxvY2FsXSkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJpXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KChrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBib3VuZCB2YWx1ZXMgZmlsdGVyZWQgYnkgW2ZdIGFwcGxpZWQgdG8gdGhlIGJvdW5kIHZhbHVlcy4gKilcbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KCgndjEgLT4gJ3YyIG9wdGlvbilbQGxvY2FsXSlcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzXG4gICAgICBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooKGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fbWFwaSB0IH5mXSByZXR1cm5zIHR3byBuZXcgW3Rdcywgd2l0aCBlYWNoIGtleSBpbiBbdF0gYXBwZWFyaW5nIGluXG4gICAgICBleGFjdGx5IG9uZSBvZiB0aGUgcmVzdWx0aW5nIG1hcHMgZGVwZW5kaW5nIG9uIGl0cyBtYXBwaW5nIGluIFtmXS4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigoa2V5OidrIC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpW0Bsb2NhbF0pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooKCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKipcbiAgICAge1tcbiAgICAgICBwYXJ0aXRpb25pX3RmIHQgfmZcbiAgICAgICA9XG4gICAgICAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgIGlmIGYgfmtleSB+ZGF0YVxuICAgICAgICAgdGhlbiBGaXJzdCBkYXRhXG4gICAgICAgICBlbHNlIFNlY29uZCBkYXRhKVxuICAgICBdfSAqKVxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOigoa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClbQGxvY2FsXSlcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOigoJ3YgLT4gYm9vbClbQGxvY2FsXSlcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBQcm9kdWNlcyBbT2tdIG9mIGEgbWFwIGluY2x1ZGluZyBhbGwga2V5cyBpZiBhbGwgZGF0YSBpcyBbT2tdLCBvciBhbiBbRXJyb3JdXG4gICAgICBpbmNsdWRpbmcgYWxsIGVycm9ycyBvdGhlcndpc2UuICopXG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICgnaywgJ3YgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogUmV0dXJucyBhIHRvdGFsIG9yZGVyaW5nIGJldHdlZW4gbWFwcy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgdG90YWwgb3JkZXJpbmcgdXNlZFxuICAgICAgdG8gY29tcGFyZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBlcXVhbCBrZXlzIGluIHRoZSB0d28gbWFwcy4gKilcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludFxuXG4gICgqKiBIYXNoIGZ1bmN0aW9uOiBhIGJ1aWxkaW5nIGJsb2NrIHRvIHVzZSB3aGVuIGhhc2hpbmcgZGF0YSBzdHJ1Y3R1cmVzIGNvbnRhaW5pbmcgbWFwcyBpblxuICAgICAgdGhlbS4gW2hhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFtjb21wYXJlX2RpcmVjdF0gaWZmXG4gICAgICBbaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFsoY29tcGFyYXRvciBtKS5jb21wYXJlXSBvZiB0aGUgbWFwIFttXSBiZWluZ1xuICAgICAgaGFzaGVkLiAqKVxuICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdrIEhhc2guZm9sZGVyIC0+ICd2IEhhc2guZm9sZGVyIC0+ICgnaywgJ3YsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAoKiogW2VxdWFsIGNtcCBtMSBtMl0gdGVzdHMgd2hldGhlciB0aGUgbWFwcyBbbTFdIGFuZCBbbTJdIGFyZSBlcXVhbCwgdGhhdCBpcywgY29udGFpblxuICAgICAgdGhlIHNhbWUga2V5cyBhbmQgYXNzb2NpYXRlIGVhY2gga2V5IHdpdGggdGhlIHNhbWUgdmFsdWUuICBbY21wXSBpcyB0aGUgZXF1YWxpdHlcbiAgICAgIHByZWRpY2F0ZSB1c2VkIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleXMuICopXG4gIHZhbCBlcXVhbCA6ICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUga2V5cyBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBsaXN0XG5cbiAgKCoqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBkYXRhIGluIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCBkYXRhIDogKF8sICd2LCBfKSB0IC0+ICd2IGxpc3RcblxuICAoKiogQ3JlYXRlcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGZyb20gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXSAoKiogZGVmYXVsdCBpcyBbYEluY3JlYXNpbmddICopXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIHsyIEFkZGl0aW9uYWwgb3BlcmF0aW9ucyBvbiBtYXBzfSAqKVxuXG4gICgqKiBNZXJnZXMgdHdvIG1hcHMuIFRoZSBydW50aW1lIGlzIE8obGVuZ3RoKHQxKSArIGxlbmd0aCh0MikpLiBZb3Ugc2hvdWxkbid0IHVzZSB0aGlzXG4gICAgICBmdW5jdGlvbiB0byBtZXJnZSBhIGxpc3Qgb2YgbWFwczsgY29uc2lkZXIgdXNpbmcgW21lcmdlX3NrZXdlZF0gaW5zdGVhZC4gKilcbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KChrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilbQGxvY2FsXSlcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBBIHNwZWNpYWwgY2FzZSBvZiBbbWVyZ2VdLCBbbWVyZ2Vfc2tld2VkIHQxIHQyXSBpcyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGVcbiAgICAgIGJpbmRpbmdzIG9mIFt0MV0gYW5kIFt0Ml0uIEJpbmRpbmdzIHRoYXQgYXBwZWFyIGluIGJvdGggW3QxXSBhbmQgW3QyXSBhcmVcbiAgICAgIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgdmFsdWUgdXNpbmcgdGhlIFtjb21iaW5lXSBmdW5jdGlvbi4gSW4gYSBjYWxsXG4gICAgICBbY29tYmluZSB+a2V5IHYxIHYyXSwgdGhlIHZhbHVlIFt2MV0gY29tZXMgZnJvbSBbdDFdIGFuZCBbdjJdIGZyb20gW3QyXS5cblxuICAgICAgVGhlIHJ1bnRpbWUgb2YgW21lcmdlX3NrZXdlZF0gaXMgW08obWluKGwxLCBsMikgKiBsb2cobWF4KGwxLCBsMikpKV0sIHdoZXJlIFtsMV0gaXNcbiAgICAgIHRoZSBsZW5ndGggb2YgW3QxXSBhbmQgW2wyXSB0aGUgbGVuZ3RoIG9mIFt0Ml0uIFRoaXMgaXMgbGlrZWx5IHRvIGJlIGZhc3RlciB0aGFuXG4gICAgICBbbWVyZ2VdIHdoZW4gb25lIG9mIHRoZSBtYXBzIGlzIGEgbG90IHNtYWxsZXIsIG9yIHdoZW4geW91IG1lcmdlIGEgbGlzdCBvZiBtYXBzLiAqKVxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOigoa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVtAbG9jYWxdKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICBtb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdrLCAndikgdCA9ICdrICogWyBgTGVmdCBvZiAndiB8IGBSaWdodCBvZiAndiB8IGBVbmVxdWFsIG9mICd2ICogJ3YgXVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuICAgIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyXG4gICAgICA6ICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gICgqKiBbc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIHJldHVybnMgYSBsaXN0IG9mIGNoYW5nZXMgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLlxuICAgICAgSXQgaXMgaW50ZW5kZWQgdG8gYmUgZWZmaWNpZW50IGluIHRoZSBjYXNlIHdoZXJlIFt0MV0gYW5kIFt0Ml0gc2hhcmUgYSBsYXJnZSBhbW91bnRcbiAgICAgIG9mIHN0cnVjdHVyZS4gVGhlIGtleXMgaW4gdGhlIG91dHB1dCBzZXF1ZW5jZSB3aWxsIGJlIGluIHNvcnRlZCBvcmRlci5cblxuICAgICAgSXQgaXMgYXNzdW1lZCB0aGF0IFtkYXRhX2VxdWFsXSBpcyBhdCBsZWFzdCBhcyBlcXVhdGluZyBhcyBwaHlzaWNhbCBlcXVhbGl0eTogdGhhdFxuICAgICAgW3BoeXNfZXF1YWwgeCB5XSBpbXBsaWVzIFtkYXRhX2VxdWFsIHggeV0uIE90aGVyd2lzZSwgW3N5bW1ldHJpY19kaWZmXSBtYXkgYmVoYXZlIGluXG4gICAgICB1bmV4cGVjdGVkIHdheXMuIEZvciBleGFtcGxlLCB3aXRoIFt+ZGF0YV9lcXVhbDooZnVuIF8gXyAtPiBmYWxzZSldIGl0IGlzIE5PVFxuICAgICAgbmVjZXNzYXJpbHkgdGhlIGNhc2UgdGhlIHJlc3VsdGluZyBjaGFuZ2Ugc2VxdWVuY2Ugd2lsbCBjb250YWluIGFuIGVsZW1lbnRcbiAgICAgIFsoaywgYFVuZXF1YWwgXyldIGZvciBldmVyeSBrZXkgW2tdIHNoYXJlZCBieSBib3RoIG1hcHMuXG5cbiAgICAgIFdhcm5pbmc6IEZsb2F0IGVxdWFsaXR5IHZpb2xhdGVzIHRoaXMgcHJvcGVydHkhIFtwaHlzX2VxdWFsIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzXG4gICAgICB0cnVlLCBidXQgW0Zsb2F0Lig9KSBGbG9hdC5uYW4gRmxvYXQubmFuXSBpcyBmYWxzZS4gKilcbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgKCoqIFtmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsXSBmb2xkcyBhY3Jvc3MgYW4gaW1wbGljaXQgc2VxdWVuY2Ugb2YgY2hhbmdlc1xuICAgICAgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLCBpbiBzb3J0ZWQgb3JkZXIgYnkga2V5cy4gRXF1aXZhbGVudCB0b1xuICAgICAgW1NlcXVlbmNlLmZvbGQgKHN5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsKV0sIGFuZCBtb3JlIGVmZmljaWVudC4gKilcbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCgndiAtPiAndiAtPiBib29sKVtAbG9jYWxdKVxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCgnYWNjIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYWNjKVtAbG9jYWxdKVxuICAgIC0+ICdhY2NcblxuICAoKiogW21pbl9lbHQgbWFwXSByZXR1cm5zIFtTb21lIChrZXksIGRhdGEpXSBwYWlyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1pbmltdW0ga2V5IGluXG4gICAgICBbbWFwXSwgb3IgW05vbmVdIGlmIGVtcHR5LiAqKVxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgKiAndlxuXG4gICgqKiBbbWF4X2VsdCBtYXBdIHJldHVybnMgW1NvbWUgKGtleSwgZGF0YSldIHBhaXIgY29ycmVzcG9uZGluZyB0byB0aGUgbWF4aW11bSBrZXkgaW5cbiAgICAgIFttYXBdLCBvciBbTm9uZV0gaWYgW21hcF0gaXMgZW1wdHkuICopXG4gIHZhbCBtYXhfZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayAqICd2XG5cbiAgKCoqIFN3YXAgdGhlIGlubmVyIGFuZCBvdXRlciBrZXlzIG9mIG5lc3RlZCBtYXBzLiBJZiBbdHJhbnNwb3NlX2tleXMgbSBhID0gYl0sIHRoZW5cbiAgICAgIFtmaW5kX2V4biAoZmluZF9leG4gYSBpKSBqID0gZmluZF9leG4gKGZpbmRfZXhuIGIgaikgaV0uICopXG4gIHZhbCB0cmFuc3Bvc2Vfa2V5c1xuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgKCdrMiwgJ3YsICdjbXAyKSB0LCAnY21wMSkgdFxuICAgIC0+ICgnazIsICgnazEsICd2LCAnY21wMSkgdCwgJ2NtcDIpIHRcblxuICAoKiogVGhlc2UgZnVuY3Rpb25zIGhhdmUgdGhlIHNhbWUgc2VtYW50aWNzIGFzIHNpbWlsYXIgZnVuY3Rpb25zIGluIFtMaXN0XS4gKilcblxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooKCd2IC0+IGJvb2wpW0Bsb2NhbF0pIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdrLCAndiwgXykgdCAtPiBmOigoa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClbQGxvY2FsXSkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigoJ3YgLT4gYm9vbClbQGxvY2FsXSkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooKGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpW0Bsb2NhbF0pIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdrLCAndiwgXykgdCAtPiBmOigoJ3YgLT4gYm9vbClbQGxvY2FsXSkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KChrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVtAbG9jYWxdKSAtPiBpbnRcblxuXG4gICgqKiBbc3BsaXQgdCBrZXldIHJldHVybnMgYSBtYXAgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tleV0sIHRoZSBtYXBwaW5nIG9mIFtrZXldIGlmXG4gICAgICBhbnksIGFuZCBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiBba2V5XS5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBvdXRwdXQgbWFwcy4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IG1hcHMuICopXG4gIHZhbCBzcGxpdFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAna1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sgKiAndikgb3B0aW9uICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbc3BsaXRfbGVfZ3QgdCBrZXldIHJldHVybnMgYSBtYXAgb2Yga2V5cyB0aGF0IGFyZSBsZXNzIG9yIGVxdWFsIHRvIFtrZXldIGFuZCBhXG4gICAgICBtYXAgb2Yga2V5cyBzdHJpY3RseSBncmVhdGVyIHRoYW4gW2tleV0uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhtICsgbG9nIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBpbnB1dCBtYXAgYW5kIG0gaXMgdGhlIHNpemUgb2ZcbiAgICAgIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gb3V0cHV0IG1hcHMuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGVcbiAgICAgIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBtYXBzLiAqKVxuICB2YWwgc3BsaXRfbGVfZ3QgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtzcGxpdF9sdF9nZSB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba2V5XSBhbmQgYSBtYXAgb2ZcbiAgICAgIGtleXMgdGhhdCBhcmUgZ3JlYXRlciBvciBlcXVhbCB0byBba2V5XS5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBvdXRwdXQgbWFwcy4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IG1hcHMuICopXG4gIHZhbCBzcGxpdF9sdF9nZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2FwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydF0gcmV0dXJucyBbYE9rIG1hcF0gd2hlcmUgW21hcF0gY29udGFpbnMgYWxsIHRoZVxuICAgICAgWyhrZXksIHZhbHVlKV0gcGFpcnMgZnJvbSB0aGUgdHdvIGlucHV0IG1hcHMgaWYgYWxsIHRoZSBrZXlzIGZyb20gW2xvd2VyX3BhcnRdIGFyZVxuICAgICAgbGVzcyB0aGFuIGFsbCB0aGUga2V5cyBmcm9tIFt1cHBlcl9wYXJ0XS4gIE90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICBbYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNdLlxuXG4gICAgICBSdW50aW1lIGlzIE8obG9nIG4pIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGxhcmdlciBpbnB1dCBtYXAuICBUaGlzIGNhbiBiZVxuICAgICAgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiBbTWFwLm1lcmdlXSBvciByZXBlYXRlZCBbTWFwLmFkZF0uXG5cbiAgICAgIHtbXG4gICAgICAgIGFzc2VydCAobWF0Y2ggTWFwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB3aXRoXG4gICAgICAgICAgfCBgT2sgd2hvbGVfbWFwIC0+XG4gICAgICAgICAgICBNYXAudG9fYWxpc3Qgd2hvbGVfbWFwXG4gICAgICAgICAgICA9IExpc3QuYXBwZW5kICh0b19hbGlzdCBsb3dlcl9wYXJ0KSAodG9fYWxpc3QgdXBwZXJfcGFydClcbiAgICAgICAgICB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIC0+IHRydWUpO1xuICAgICAgXX0gKilcbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgKCoqIFtzdWJyYW5nZSB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRdIHJldHVybnMgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGVudHJpZXMgZnJvbVxuICAgICAgW3RdIHdob3NlIGtleXMgbGllIGluc2lkZSB0aGUgaW50ZXJ2YWwgaW5kaWNhdGVkIGJ5IFt+bG93ZXJfYm91bmRdIGFuZFxuICAgICAgW351cHBlcl9ib3VuZF0uICBJZiB0aGlzIGludGVydmFsIGlzIGVtcHR5LCBhbiBlbXB0eSBtYXAgaXMgcmV0dXJuZWQuXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhtICsgbG9nIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBpbnB1dCBtYXAgYW5kIG0gaXMgdGhlIHNpemUgb2ZcbiAgICAgIHRoZSBvdXRwdXQgbWFwLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICBvdXRwdXQgbWFwLiAqKVxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gbG93ZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtmb2xkX3JhbmdlX2luY2x1c2l2ZSB0IH5taW4gfm1heCB+aW5pdCB+Zl0gZm9sZHMgW2ZdICh3aXRoIGluaXRpYWwgdmFsdWUgW35pbml0XSlcbiAgICAgIG92ZXIgYWxsIGtleXMgKGFuZCB0aGVpciBhc3NvY2lhdGVkIHZhbHVlcykgdGhhdCBhcmUgaW4gdGhlIHJhbmdlIFtbbWluLCBtYXhdXVxuICAgICAgKGluY2x1c2l2ZSkuICAqKVxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gbWluOidrXG4gICAgLT4gbWF4OidrXG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooKGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylbQGxvY2FsXSlcbiAgICAtPiAnYWNjXG5cbiAgKCoqIFtyYW5nZV90b19hbGlzdCB0IH5taW4gfm1heF0gcmV0dXJucyBhbiBhc3NvY2lhdGl2ZSBsaXN0IG9mIHRoZSBlbGVtZW50cyB3aG9zZSBrZXlzXG4gICAgICBsaWUgaW4gW1ttaW4sIG1heF1dIChpbmNsdXNpdmUpLCB3aXRoIHRoZSBzbWFsbGVzdCBrZXkgYmVpbmcgYXQgdGhlIGhlYWQgb2YgdGhlXG4gICAgICBsaXN0LiAqKVxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAoJ2ssICd2LCAnY21wKSB0IC0+IG1pbjonayAtPiBtYXg6J2sgLT4gKCdrICogJ3YpIGxpc3RcblxuICAoKiogW2Nsb3Nlc3Rfa2V5IHQgZGlyIGtdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgaW4gW3RdIHdpdGggW2tleV0gY2xvc2VzdCB0b1xuICAgICAgW2tdIHRoYXQgc2F0aXNmaWVzIHRoZSBnaXZlbiBpbmVxdWFsaXR5IGJvdW5kLlxuXG4gICAgICBGb3IgZXhhbXBsZSwgW2Nsb3Nlc3Rfa2V5IHQgYExlc3NfdGhhbiBrXSB3b3VsZCBiZSB0aGUgcGFpciB3aXRoIHRoZSBjbG9zZXN0IGtleSB0b1xuICAgICAgW2tdIHdoZXJlIFtrZXkgPCBrXS5cblxuICAgICAgW3RvX3NlcXVlbmNlXSBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIHNhbWUgcmVzdWx0cyBhcyBbY2xvc2VzdF9rZXldLiAgSXQgaXMgbGVzc1xuICAgICAgZWZmaWNpZW50IGZvciBpbmRpdmlkdWFsIGxvb2t1cHMgYnV0IG1vcmUgZWZmaWNpZW50IGZvciBmaW5kaW5nIG1hbnkgZWxlbWVudHMgc3RhcnRpbmdcbiAgICAgIGF0IHNvbWUgdmFsdWUuICopXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4gJ2tcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtudGggdCBuXSBmaW5kcyB0aGUgKGtleSwgdmFsdWUpIHBhaXIgb2YgcmFuayBuIChpLmUuLCBzdWNoIHRoYXQgdGhlcmUgYXJlIGV4YWN0bHkgblxuICAgICAga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gdGhlIGZvdW5kIGtleSksIGlmIG9uZSBleGlzdHMuICBPKGxvZyhsZW5ndGggdCkgKyBuKSB0aW1lLiAqKVxuICB2YWwgbnRoIDogKCdrLCAndiwgXykgdCAtPiBpbnQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgXykgdCAtPiBpbnQgLT4gJ2sgKiAndlxuXG4gICgqKiBbcmFuayB0IGtdIElmIFtrXSBpcyBpbiBbdF0sIHJldHVybnMgdGhlIG51bWJlciBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba10gaW5cbiAgICAgIFt0XSwgYW5kIFtOb25lXSBvdGhlcndpc2UuICopXG4gIHZhbCByYW5rIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBpbnQgb3B0aW9uXG5cblxuXG4gICgqKiBbdG9fc2VxdWVuY2UgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XVxuICAgICAgZ2l2ZXMgYSBzZXF1ZW5jZSBvZiBrZXktdmFsdWUgcGFpcnMgYmV0d2VlbiBba2V5c19sZXNzX29yX2VxdWFsX3RvXSBhbmRcbiAgICAgIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGluY2x1c2l2ZSwgcHJlc2VudGVkIGluIFtvcmRlcl0uICBJZlxuICAgICAgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA+IGtleXNfbGVzc19vcl9lcXVhbF90b10sIHRoZSBzZXF1ZW5jZSBpc1xuICAgICAgZW1wdHkuXG5cbiAgICAgIFdoZW4gbmVpdGhlciBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXSBub3IgW2tleXNfbGVzc19vcl9lcXVhbF90b10gYXJlXG4gICAgICBwcm92aWRlZCwgdGhlIGNvc3QgaXMgTyhsb2cgbikgdXAgZnJvbnQgYW5kIGFtb3J0aXplZCBPKDEpIHRvIHByb2R1Y2VcbiAgICAgIGVhY2ggZWxlbWVudC4gSWYgZWl0aGVyIGlzIHByb3ZpZGVkIChhbmQgaXMgdXNlZCBieSB0aGUgb3JkZXIgcGFyYW1ldGVyXG4gICAgICBwcm92aWRlZCksIHRoZW4gdGhlIHRoZSBjb3N0IGlzIE8obikgdXAgZnJvbnQsIGFuZCBhbW9ydGl6ZWQgTygxKSB0b1xuICAgICAgcHJvZHVjZSBlYWNoIGVsZW1lbnQuICopXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzona1xuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcblxuICAoKiogW2JpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSB3aGljaCBlbHRdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgaW4gW3RdXG4gICAgICBzcGVjaWZpZWQgYnkgW2NvbXBhcmVdIGFuZCBbd2hpY2hdLCBpZiBvbmUgZXhpc3RzLlxuXG4gICAgICBbdF0gbXVzdCBiZSBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBhY2NvcmRpbmcgdG8gW2NvbXBhcmVdLCB3aGVyZSBbY29tcGFyZV0gYW5kXG4gICAgICBbZWx0XSBkaXZpZGUgW3RdIGludG8gdGhyZWUgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCAgPCBlbHQgIHwgID0gZWx0ICB8ICA+IGVsdCAgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIHJldHVybnMgYW4gZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2Ygc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5XG4gICAgICBbd2hpY2hdLiAgU2VlIHRoZSBkaWFncmFtIGJlbG93IG5leHQgdG8gdGhlIFt3aGljaF0gdmFyaWFudHMuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtjb21wYXJlXSBvcmRlcnMgW3RdLCBhbmQgYmVoYXZpb3IgaXNcbiAgICAgIHVuc3BlY2lmaWVkIGlmIFtjb21wYXJlXSBkb2Vzbid0IG9yZGVyIFt0XS4gIEJlaGF2aW9yIGlzIGFsc28gdW5zcGVjaWZpZWQgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooKGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVtAbG9jYWxdKVxuICAgIC0+IFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgICAgIF1cbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiB3aGljaF0gdGFrZXMgYSBbc2VnbWVudF9vZl0gZnVuY3Rpb24gdGhhdFxuICAgICAgZGl2aWRlcyBbdF0gaW50byB0d28gKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCBzZWdtZW50X29mIGVsdCA9IGBMZWZ0IHwgc2VnbWVudF9vZiBlbHQgPSBgUmlnaHQgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIG9uIHRoZSBib3VuZGFyeSBvZiB0aGVcbiAgICAgIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieSBbd2hpY2hdOiBbYExhc3Rfb25fbGVmdF0geWllbGRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlXG4gICAgICBsZWZ0IHNlZ21lbnQsIHdoaWxlIFtgRmlyc3Rfb25fcmlnaHRdIHlpZWxkcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmlnaHQgc2VnbWVudC5cbiAgICAgIEl0IHJldHVybnMgW05vbmVdIGlmIHRoZSBzZWdtZW50IGlzIGVtcHR5LlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGRvZXMgbm90IGNoZWNrIHRoYXQgW3NlZ21lbnRfb2ZdIHNlZ21lbnRzIFt0XSBhcyBpbiB0aGVcbiAgICAgIGRpYWdyYW0sIGFuZCBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gZG9lc24ndCBzZWdtZW50IFt0XS4gIEJlaGF2aW9yXG4gICAgICBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KChrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pW0Bsb2NhbF0pXG4gICAgLT4gWyBgTGFzdF9vbl9sZWZ0IHwgYEZpcnN0X29uX3JpZ2h0IF1cbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXSB0YWtlcyBhIFtjb21wYXJlXSBmdW5jdGlvbiB0aGF0IGRpdmlkZXMgW3RdIGludG8gdGhyZWVcbiAgICAgIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHMgd2l0aCByZXNwZWN0IHRvIFtsb3dlcl9ib3VuZF0gYW5kIFt1cHBlcl9ib3VuZF06XG5cbiAgICAgIHt2XG4gICAgICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgfCBJbl9yYW5nZSB8IEFib3ZlX3VwcGVyX2JvdW5kIHxcbiAgICAgIHZ9XG5cbiAgICAgIGFuZCByZXR1cm5zIGEgbWFwIG9mIHRoZSBbSW5fcmFuZ2VdIHNlZ21lbnQuXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbSArIG4pIHdoZXJlIFttXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBtYXAgYW5kIFtuXSBpcyB0aGVcbiAgICAgIGxlbmd0aCBvZiB0aGUgb3V0cHV0LiBUaGUgbGluZWFyIHRlcm0gaW4gW25dIGlzIHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0LlxuXG4gICAgICBCZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgW2NvbXBhcmVdIGRvZXMgbm90IHNlZ21lbnQgW3RdIGFzIHNob3duIGFib3ZlLCBvciBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgaXRzIGlucHV0cy4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooKGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpW0Bsb2NhbF0pXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyB0cmF2ZXJzYWxzIHRvIHJlY29uc3RydWN0IGEgbWFwIHdpdGhpbiBhbiBhcHBsaWNhdGl2ZS4gVXNlc1xuICAgICAgW0xhenlfYXBwbGljYXRpdmVdIHNvIHRoYXQgdGhlIG1hcCBjYW4gYmUgdHJhdmVyc2VkIHdpdGhpbiB0aGUgYXBwbGljYXRpdmUsIHJhdGhlclxuICAgICAgdGhhbiBuZWVkaW5nIHRvIGJlIHRyYXZlcnNlZCBhbGwgYXQgb25jZSwgb3V0c2lkZSB0aGUgYXBwbGljYXRpdmUuICopXG4gIG1vZHVsZSBNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEgOiBBcHBsaWNhdGl2ZS5MYXp5X2FwcGxpY2F0aXZlKSA6IHNpZ1xuICAgIHZhbCBtYXBpXG4gICAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBBLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCBBLnRcblxuICAgIHZhbCBmaWx0ZXJfbWFwaVxuICAgICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uIEEudClcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IEEudFxuICBlbmRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfbWFwID0gaW50IE1hcC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X21hcCA9IChTdHJpbmcudCwgaW50LCBTdHJpbmcuY29tcGFyYXRvcl93aXRuZXNzKSBNYXAudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW2ludCBNYXAuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmQgc3ludGF4XG4gICAgICBkb2Vzbid0IChiZWNhdXNlIHRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgYXMsIHNheSwgW1N0cmluZy5zZXhwX29mX2NvbXBhcmF0b3Jfd2l0bmVzc11cbiAgICAgIC0tIGluc3RlYWQgeW91IHdvdWxkIHdhbnQgdG8gcGFzcyB0aGUgY29tcGFyYXRvciBkaXJlY3RseSkuXG5cbiAgICAgIEluIGFkZGl0aW9uLCB3aGVuIHVzaW5nIFtAQGRlcml2aW5nXSwgdGhlIHJlcXVpcmVtZW50cyBvbiB0aGUga2V5IG1vZHVsZSBhcmUgb25seVxuICAgICAgdGhvc2UgbmVlZGVkIHRvIHNhdGlzZnkgd2hhdCB5b3UgYXJlIHRyeWluZyB0byBkZXJpdmUgb24gdGhlIG1hcCBpdHNlbGYuIFNheSB5b3VcbiAgICAgIHdyaXRlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHQgPSBpbnQgTWFwLk0oWCkudCBbQEBkZXJpdmluZyBoYXNoXVxuICAgICAgXX1cblxuICAgICAgdGhlbiB0aGlzIHdpbGwgYmUgd2VsbCB0eXBlZCBleGFjdGx5IGlmIFtYXSBjb250YWlucyBhdCBsZWFzdDpcbiAgICAgIC0gYSB0eXBlIFt0XSB3aXRoIG5vIHBhcmFtZXRlcnNcbiAgICAgIC0gYSBjb21wYXJhdG9yIHdpdG5lc3NcbiAgICAgIC0gYSBbaGFzaF9mb2xkX3RdIGZ1bmN0aW9uIHdpdGggdGhlIHJpZ2h0IHR5cGUgKilcbiAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICAgIHR5cGUgdFxuICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdrZXksICd2YWx1ZSwgJ2NtcCkgdCA6PSAoJ2tleSwgJ3ZhbHVlLCAnY21wKSB0XG5cbiAgKCoqIFtVc2luZ19jb21wYXJhdG9yXSBpcyBhIHNpbWlsYXIgaW50ZXJmYWNlIGFzIHRoZSB0b3BsZXZlbCBvZiBbTWFwXSwgZXhjZXB0IHRoZVxuICAgICAgZnVuY3Rpb25zIHRha2UgYSBbfmNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRdLCB3aGVyZWFzIHRoZSBmdW5jdGlvbnMgYXQgdGhlXG4gICAgICB0b3BsZXZlbCBvZiBbTWFwXSB0YWtlIGEgWygnaywgJ2NtcCkgY29tcGFyYXRvcl0uICopXG4gIG1vZHVsZSBVc2luZ19jb21wYXJhdG9yIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdrLCArJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgICAtPiBTZXhwLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgIG1vZHVsZSBUcmVlIDogc2lnXG4gICAgICB0eXBlICgrJ2ssICsndiwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgdmFsIHNleHBfb2ZfdFxuICAgICAgICA6ICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgICAgLT4gKFNleHAudCAtPiAndilcbiAgICAgICAgLT4gU2V4cC50XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgICAgaW5jbHVkZVxuICAgICAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICAgIHdpdGggdHlwZSAnYyBjbXAgOj0gJ2NcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXywgXykgdFxuXG4gICAgICAoKiogW0J1aWxkX2luY3JlYXNpbmddIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIG1hcCBpbmNyZW1lbnRhbGx5IGZyb20gYVxuICAgICAgICAgIHNlcXVlbmNlIHRoYXQgaXMga25vd24gdG8gYmUgaW5jcmVhc2luZy5cblxuICAgICAgICAgIFRoZSB0b3RhbCB0aW1lIGNvbXBsZXhpdHkgb2YgY29uc3RydWN0aW5nIGEgbWFwIHRoaXMgd2F5IGlzIE8obiksIHdoaWNoIGlzIG1vcmVcbiAgICAgICAgICBlZmZpY2llbnQgdGhhbiB1c2luZyBbTWFwLmFkZF0gYnkgYSBsb2dhcml0aG1pYyBmYWN0b3IuXG5cbiAgICAgICAgICBUaGlzIGludGVyZmFjZSBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIGR1YWwgb2YgW3RvX3NlcXVlbmNlXSwgYnV0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICBhbiBlcXVhbGx5IG5lYXQgaWRpb20gZm9yIHRoZSBkdWFscyBvZiBzZXF1ZW5jZXMgKFtvZl9zZXF1ZW5jZV0gaXMgbXVjaCBsZXNzXG4gICAgICAgICAgZ2VuZXJhbCBiZWNhdXNlIGl0IGRvZXMgbm90IGFsbG93IHRoZSBzZXF1ZW5jZSB0byBiZSBwcm9kdWNlZCBhc3luY2hyb25vdXNseSkuICopXG4gICAgICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHR5cGUgKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICB2YWwgZW1wdHkgOiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgb2YgW2FkZF9leG5dIGlzIGFtb3J0aXplZCBjb25zdGFudC10aW1lIChpZiBbdF0gaXMgdXNlZFxuICAgICAgICAgICAgbGluZWFybHkpLCB3aXRoIGEgd29yc3QtY2FzZSBPKGxvZyhuKSkgdGltZS4gKilcbiAgICAgICAgdmFsIGFkZF9leG5cbiAgICAgICAgICA6ICAoJ2ssICd2LCAndykgdFxuICAgICAgICAgIC0+IGNvbXBhcmF0b3I6KCdrLCAndykgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4ga2V5OidrXG4gICAgICAgICAgLT4gZGF0YTondlxuICAgICAgICAgIC0+ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBpcyBPKGxvZyhuKSkuICopXG4gICAgICAgIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ3cpIHQgLT4gKCdrLCAndiwgJ3cpIHRyZWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG4gICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICB3aXRoIHR5cGUgJ2MgY21wIDo9ICdjXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRob3V0X2NvbXBhcmF0b3IudFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdFxuICAgICAgOiAgJ2sgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICd2IEhhc2guZm9sZGVyXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICAoKiogVG8gZ2V0IGFyb3VuZCB0aGUgdmFsdWUgcmVzdHJpY3Rpb24sIGFwcGx5IHRoZSBmdW5jdG9yIGFuZCBpbmNsdWRlIGl0LiBZb3VcbiAgICAgICAgY2FuIHNlZSBhbiBleGFtcGxlIG9mIHRoaXMgaW4gdGhlIFtQb2x5XSBzdWJtb2R1bGUgYmVsb3cuICopXG4gICAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEsgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiBBIHBvbHltb3JwaGljIE1hcC4gKilcbiAgbW9kdWxlIFBvbHkgOlxuICAgIFNfcG9seVxuICAgIHdpdGggdHlwZSAoJ2tleSwgKyd2YWx1ZSkgdCA9ICgna2V5LCAndmFsdWUsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICAgYW5kIHR5cGUgKCdrZXksICsndmFsdWUpIHRyZWUgPVxuICAgICAgICAgICAoJ2tleSwgJ3ZhbHVlLCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgICBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgKCoqIENyZWF0ZSBhIG1hcCBmcm9tIGEgdHJlZSB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyYXRvci4gKilcbiAgdmFsIG9mX3RyZWVcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogRXh0cmFjdCBhIHRyZWUgZnJvbSBhIG1hcC4gKilcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG5cblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW01hcF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gQWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNDQ1MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJOYW1lZCIsIkJhc2VfU2V0X2ludGYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZ0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNDQ2NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfb2Zfc29ydGVkX2FycmF5X2R1cGxpY2F0ZWQiLCJjc3Rfc3JjX3NldF9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSGFzaCIsIkJhc2VfSW1wb3J0IiwiU2V4cGxpYjBfU2V4cF9ncmFtbWFyIiwiQmFzZV9Pcl9lcnJvciIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9MaXN0IiwiQmFzZV9TZXhwIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0FycmF5IiwiQmFzZV9TZXF1ZW5jZSIsIkJhc2VfRm4iLCJCYXNlX09wdGlvbiIsIkJhc2VfRXhuIiwiQmFzZV9XaXRoX3JldHVybiIsIlNleHBsaWIwX1NleHBfY29udiIsIkJhc2VfQ29tcGFyYXRvciIsIndpdGhfcmV0dXJuIiwiY3N0X29mX3NvcnRlZF9hcnJheV9lbGVtZW50c19hIiwiaGVpZ2h0IiwicGFyYW0iLCJoIiwibGVuZ3RoIiwicyIsImluX3JhbmdlIiwibG93ZXIiLCJ1cHBlciIsImNvbXBhcmVfZWx0IiwidiIsImxvb3AiLCJ0IiwibiIsInIiLCJsIiwiaGwiLCJociIsImludmFyaWFudHMiLCJpc19lbXB0eSIsImNyZWF0ZSIsInNsIiwic3IiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2siLCJsZW4iLCJpIiwiayIsImtsIiwia3IiLCJsZWZ0X2xlbmd0aCIsInJpZ2h0X2xlbmd0aCIsImxlZnQiLCJyaWdodCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQiLCJhcnJheSIsImFycmF5X2xlbmd0aCIsIm5leHQiLCJvZl9zb3J0ZWRfYXJyYXkiLCJpbmNyZWFzaW5nIiwiYmFsIiwibHIiLCJsdiIsImxsIiwibHJyIiwibHJ2IiwibHJsIiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2IiwicmxsIiwiU2FtZSIsImFkZCIsIngiLCJhdXgiLCJjIiwiYWRkX21pbiIsImFkZF9tYXgiLCJqb2luIiwibGgiLCJyaCIsIm1pbl9lbHQiLCJTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IiwiU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldCIsImNzdF9TZXRfcmVtb3ZlX21pbl9lbHQiLCJtaW5fZWx0X2V4biIsIm1hdGNoIiwiZm9sZF91bnRpbCIsImluaXQiLCJmaW5pc2giLCJmb2xkX3VudGlsX2hlbHBlciIsImFjYyIsInZhbHVlIiwibWF4X2VsdCIsIm1heF9lbHRfZXhuIiwicmVtb3ZlX21pbl9lbHQiLCJtZXJnZSIsInQxIiwidDIiLCJjb25jYXQiLCJzcGxpdCIsIm1heWJlX2VsdCIsInNwbGl0X2xlX2d0Iiwic3BsaXRfbHRfZ2UiLCJlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW8iLCJtZW0iLCJyZW1vdmUiLCJyZW1vdmVfaW5kZXgiLCJsX3NpemUiLCJ1bmlvbiIsInMxIiwiczIiLCJoMSIsInIxIiwidjEiLCJsMSIsInYyIiwiaDIiLCJyMiIsImwyIiwidW5pb25fbGlzdCIsImNvbXBhcmF0b3IiLCJ0b190cmVlIiwieHMiLCJhYyIsImludGVyIiwib3RoZXJfc2V0Iiwic2luZ2xldG9uIiwiZWx0IiwiZGlmZiIsImNvbnMiLCJlIiwiY29uc19yaWdodCIsIm9mX3NldCIsIml0ZXIiLCJlbnVtIiwidHJlZSIsImEiLCJzeW1tZXRyaWNfZGlmZiIsInN0ZXAiLCJzdGF0ZSIsImVudW0xIiwidHJlZTEiLCJlbnVtMiIsInRyZWUyIiwiY29tcGFyZV9yZXN1bHQiLCJuZXh0X3N0YXRlIiwidG9fc2VxdWVuY2UiLCJvcHQiLCJncmVhdGVyX29yX2VxdWFsX3RvIiwibGVzc19vcl9lcXVhbF90byIsIm9yZGVyIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsImJvdW5kIiwibWF5YmUiLCJrZXkiLCJjb21wYXJlIiwiZmluZF9maXJzdF9zYXRpc2Z5aW5nIiwiZmluZF9sYXN0X3NhdGlzZnlpbmciLCJiaW5hcnlfc2VhcmNoIiwiaG93IiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQiLCJzZWdtZW50X29mIiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwibWVyZ2VfdG9fc2VxdWVuY2UiLCJlMiIsImUxIiwiaXRlcjIiLCJlcXVhbCIsImlzX3N1YnNldCIsImFyZV9kaXNqb2ludCIsImZvbGQiLCJhY2N1IiwiY291bnQiLCJzdW0iLCJtIiwiZm9sZF9yaWdodCIsImZvcl9hbGwiLCJwIiwiZXhpc3RzIiwiZmlsdGVyIiwiZmlsdCIsImtlZXBfdiIsImZpbHRlcl9tYXAiLCJwYXJ0aXRpb25fdGYiLCJsX2YiLCJsX3QiLCJrZWVwX3ZfdCIsInJfZiIsInJfdCIsIm1rIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJub3RfZm91bmQiLCJjc3RfU2V0X2ZpbmRfZXhuX2ZhaWxlZF90b19maW4iLCJjc3RfU2V0X3Rfb2Zfc2V4cF9saXN0X25lZWRlZCIsImNzdF9TZXRfdF9vZl9zZXhwX2R1cGxpY2F0ZV9lbCIsImNzdF9pbnZhbGlkX2VsZW1lbnRzIiwiY3N0X2lzX25vdF9hX3N1YnNldF9vZiIsImNob29zZV9leG4iLCJvZl9saXN0IiwibHN0Iiwib2Zfc2VxdWVuY2UiLCJzZXF1ZW5jZSIsIm9mX2FycmF5IiwidG9fYXJyYXkiLCJyZXMiLCJwb3NfcmVmIiwibWFwIiwiZ3JvdXBfYnkiLCJzZXQiLCJlcXVpdiIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJmaW5kIiwiZmluZF9tYXAiLCJmaW5kX2V4biIsIm50aCIsInN0YWJsZV9kZWR1cF9saXN0IiwibGVmdG92ZXJzIiwiYWxyZWFkeV9zZWVuIiwidGwiLCJoZCIsInRfb2Zfc2V4cF9kaXJlY3QiLCJhX29mX3NleHAiLCJzZXhwIiwiZWx0X2xzdCIsImVsX3NleHAiLCJlbCIsInNleHBfb2ZfdCIsInNleHBfb2ZfYSIsInN1YnNldCIsInN1cGVyc2V0Iiwic2V4cF9vZl9lbHQiLCJpbnZhbGlkX2VsZW1lbnRzIiwiaW52YWxpZF9lbGVtZW50c19zZXhwIiwibGlrZSIsImxpa2VfbWF5YmVfbm9fb3AiLCJvbGRfdCIsIm9sZF90cmVlIiwiY29tcGFyYXRvcl9zIiwidG9fbGlzdCIsImZvbGRfcmVzdWx0IiwiYiIsImNvbXBhcmVfZGlyZWN0Iiwib2YiLCJ0b19uYW1lZF90cmVlIiwibmFtZWQiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJoYXNoX2ZvbGRfZGlyZWN0IiwiaGFzaF9mb2xkX2VsZW0iLCJlbXB0eSIsIm9mX3RyZWUiLCJOYW1lZCIsIkVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsIkVsdCIsIk0iLCJzZXhwX29mX21fdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbV90IiwiZXF1YWxfbV90IiwiaGFzaF9mb2xkX21fdCIsImhhc2hfbV90IiwiZm9sZGVyIiwiaW5jbHVkZSIsIkJhc2VfU2V0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2Uvc2V0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1DQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRGwrQkoiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gU2VlIC4uL1RISVJELVBBUlRZLnR4dCAgKilcbigqICBmb3IgZGV0YWlscy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNldF9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBFbXB0eVxuICAgICgqIChMZWFmIHgpIGlzIHRoZSBzYW1lIGFzIChOb2RlIChFbXB0eSwgeCwgRW1wdHksIDEsIDEpKSBidXQgdXNlcyBsZXNzIHNwYWNlLiAqKVxuICAgIHwgTGVhZiBvZiAnYVxuICAgICgqIGZpcnN0IGludCBpcyBoZWlnaHQsIHNlY29uZCBpcyBzdWItdHJlZSBzaXplICopXG4gICAgfCBOb2RlIG9mICdhIHQgKiAnYSAqICdhIHQgKiBpbnQgKiBpbnRcblxuICB0eXBlICdhIHRyZWUgPSAnYSB0XG5cbiAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGUgY2hpbGRyZW4gZGlmZmVyIGJ5XG4gICAgIGF0IG1vc3QgMi4gKilcbiAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICA7O1xuXG4gIGxldCBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHYgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2VsdCBsb3dlciB2IDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfZWx0IHYgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIHYgLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBoLCBuKSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgbiA9IGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gICAgICAgICYmIGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHZcbiAgICAgICAgJiYgbG9vcCBsb3dlciAoU29tZSB2KSBjb21wYXJlX2VsdCBsXG4gICAgICAgICYmIGxvb3AgKFNvbWUgdikgdXBwZXIgY29tcGFyZV9lbHQgclxuICAgIGluXG4gICAgZnVuIHQgfmNvbXBhcmVfZWx0IC0+IGxvb3AgTm9uZSBOb25lIGNvbXBhcmVfZWx0IHRcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiBfIHwgTm9kZSBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgIGxldCBobCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaHIgPVxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgbGV0IGggPSBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSBpblxuICAgIGlmIGggPSAxXG4gICAgdGhlbiBMZWFmIHZcbiAgICBlbHNlIChcbiAgICAgIGxldCBzbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBsZXQgc3IgPVxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgTm9kZSAobCwgdiwgciwgaCwgc2wgKyBzciArIDEpKVxuICA7O1xuXG4gICgqIFdlIG11c3QgY2FsbCBbZl0gd2l0aCBpbmNyZWFzaW5nIGluZGV4ZXMsIGJlY2F1c2UgdGhlIGJpbl9wcm90IHJlYWRlciBpblxuICAgICBDb3JlLlNldCBuZWVkcyBpdC4gKilcbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIGxldCByZWMgbG9vcCBuIH5mIGkgPVxuICAgICAgbWF0Y2ggbiB3aXRoXG4gICAgICB8IDAgLT4gRW1wdHlcbiAgICAgIHwgMSAtPlxuICAgICAgICBsZXQgayA9IGYgaSBpblxuICAgICAgICBMZWFmIGtcbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wgPSBmIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIChMZWFmIGtsKSBrIEVtcHR5XG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsID0gZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYga2wpIGsgKExlYWYga3IpXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICAoKiBXZSBkb24ndCBjaGVjayBpZiB0aGUgYXJyYXkgaXMgc29ydGVkIG9yIGtleXMgYXJlIGR1cGxpY2F0ZWQsIGJlY2F1c2UgdGhhdFxuICAgICAgICAgY2hlY2tpbmcgaXMgc2xvd2VyIHRoYW4gdGhlIHdob2xlIFtvZl9zb3J0ZWRfYXJyYXldIGZ1bmN0aW9uICopXG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyIHx8IGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuOmFycmF5X2xlbmd0aCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+IFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKGkpIGFycmF5LihpICsgMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZWxlbWVudHMgYXJlIG5vdCBvcmRlcmVkXCIpXG4gICAgICAgIGRvbmU7XG4gICAgICAgIFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpKVxuICA7O1xuXG4gICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICBsZXQgYmFsIGwgdiByID1cbiAgICBsZXQgaGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgbGV0IGhyID1cbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICB8IExlYWYgXyAtPiAxXG4gICAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgICBpblxuICAgIGlmIGhsID4gaHIgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogYmVjYXVzZSBoKGwpPmgocikrMiBhbmQgaChsZWFmKT0xICopXG4gICAgICB8IE5vZGUgKGxsLCBsdiwgbHIsIF8sIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTGVhZiBscnYgLT5cbiAgICAgICAgICAgIGFzc2VydCAoaXNfZW1wdHkgbGwpO1xuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgRW1wdHkpIGxydiAoY3JlYXRlIEVtcHR5IHYgcilcbiAgICAgICAgICB8IE5vZGUgKGxybCwgbHJ2LCBscnIsIF8sIF8pIC0+IGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcikpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgocik+aChsKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSAocmwsIHJ2LCByciwgXywgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybFxuICAgICAgICB0aGVuIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIHJsdiAtPlxuICAgICAgICAgICAgYXNzZXJ0IChpc19lbXB0eSBycik7XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgRW1wdHkpIHJsdiAoY3JlYXRlIEVtcHR5IHJ2IHJyKVxuICAgICAgICAgIHwgTm9kZSAocmxsLCBybHYsIHJsciwgXywgXykgLT4gY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKSkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgaCA9IGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxIGluXG4gICAgICBsZXQgc2wgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgbGV0IHNyID1cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgICB8IExlYWYgXyAtPiAxXG4gICAgICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICAgICAgaW5cbiAgICAgIGlmIGggPSAxIHRoZW4gTGVhZiB2IGVsc2UgTm9kZSAobCwgdiwgciwgaCwgc2wgKyBzciArIDEpKVxuICA7O1xuXG4gICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gIGV4Y2VwdGlvbiBTYW1lXG5cbiAgbGV0IGFkZCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IExlYWYgeFxuICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgU2FtZVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gY3JlYXRlIChMZWFmIHgpIHYgRW1wdHlcbiAgICAgICAgZWxzZSBjcmVhdGUgRW1wdHkgdiAoTGVhZiB4KVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBiYWwgKGF1eCBsKSB2IHJcbiAgICAgICAgZWxzZSBiYWwgbCB2IChhdXggcilcbiAgICBpblxuICAgIHRyeSBhdXggdCB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICAoKiBzcGVjaWFsaXphdGlvbiBvZiBbYWRkXSB0aGF0IGFzc3VtZXMgdGhhdCBbeF0gaXMgbGVzcyB0aGFuIGFsbCBleGlzdGluZyBlbGVtZW50cyAqKVxuICBsZXQgcmVjIGFkZF9taW4geCB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IExlYWYgeFxuICAgIHwgTGVhZiBfIC0+IE5vZGUgKEVtcHR5LCB4LCB0LCAyLCAyKVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gYmFsIChhZGRfbWluIHggbCkgdiByXG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW2FkZF0gdGhhdCBhc3N1bWVzIHRoYXQgW3hdIGlzIGdyZWF0ZXIgdGhhbiBhbGwgZXhpc3RpbmcgZWxlbWVudHMgKilcbiAgbGV0IHJlYyBhZGRfbWF4IHQgeCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmIHhcbiAgICB8IExlYWYgXyAtPiBOb2RlICh0LCB4LCBFbXB0eSwgMiwgMilcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGJhbCBsIHYgKGFkZF9tYXggciB4KVxuICA7O1xuXG4gICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGUgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZFxuICAgICByLiAqKVxuICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgIG1hdGNoIGwsIHIgd2l0aFxuICAgIHwgRW1wdHksIF8gLT4gYWRkX21pbiB2IHJcbiAgICB8IF8sIEVtcHR5IC0+IGFkZF9tYXggbCB2XG4gICAgfCBMZWFmIGx2LCBfIC0+IGFkZF9taW4gbHYgKGFkZF9taW4gdiByKVxuICAgIHwgXywgTGVhZiBydiAtPiBhZGRfbWF4IChhZGRfbWF4IGwgdikgcnZcbiAgICB8IE5vZGUgKGxsLCBsdiwgbHIsIGxoLCBfKSwgTm9kZSAocmwsIHJ2LCByciwgcmgsIF8pIC0+XG4gICAgICBpZiBsaCA+IHJoICsgMlxuICAgICAgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKVxuICAgICAgZWxzZSBpZiByaCA+IGxoICsgMlxuICAgICAgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByclxuICAgICAgZWxzZSBjcmVhdGUgbCB2IHJcbiAgOztcblxuICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IHwgTm9kZSAoRW1wdHksIHYsIF8sIF8sIF8pIC0+IFNvbWUgdlxuICAgIHwgTm9kZSAobCwgXywgXywgXywgXykgLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgYWNjID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiB2YWx1ZSAtPiBmIGFjYyB2YWx1ZSBbQG5vbnRhaWxdXG4gICAgICB8IE5vZGUgKGxlZnQsIHZhbHVlLCByaWdodCwgXywgXykgLT5cbiAgICAgICAgKG1hdGNoIGZvbGRfdW50aWxfaGVscGVyIH5mIGxlZnQgYWNjIHdpdGhcbiAgICAgICAgIHwgU3RvcCBfYSBhcyB4IC0+IHhcbiAgICAgICAgIHwgQ29udGludWUgYWNjIC0+XG4gICAgICAgICAgIChtYXRjaCBmIGFjYyB2YWx1ZSB3aXRoXG4gICAgICAgICAgICB8IFN0b3AgX2EgYXMgeCAtPiB4XG4gICAgICAgICAgICB8IENvbnRpbnVlIGEgLT4gZm9sZF91bnRpbF9oZWxwZXIgfmYgcmlnaHQgYSkpXG4gICAgaW5cbiAgICBtYXRjaCBmb2xkX3VudGlsX2hlbHBlciB+ZiB0IGluaXQgd2l0aFxuICAgIHwgQ29udGludWUgeCAtPiBmaW5pc2ggeCBbQG5vbnRhaWxdXG4gICAgfCBTdG9wIHggLT4geFxuICA7O1xuXG4gIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgfCBOb2RlIChfLCB2LCBFbXB0eSwgXywgXykgLT4gU29tZSB2XG4gICAgfCBOb2RlIChfLCBfLCByLCBfLCBfKSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiBfIC0+IEVtcHR5XG4gICAgfCBOb2RlIChFbXB0eSwgXywgciwgXywgXykgLT4gclxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcbiAgOztcblxuICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS4gIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gYmFsIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG4gIGxldCBjb25jYXQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gam9pbiB0MSAobWluX2VsdF9leG4gdDIpIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICBsZXQgc3BsaXQgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBzcGxpdCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFbXB0eSwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gRW1wdHksIFNvbWUgdiwgRW1wdHlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIEVtcHR5LCBOb25lLCBMZWFmIHZcbiAgICAgICAgZWxzZSBMZWFmIHYsIE5vbmUsIEVtcHR5XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbCwgU29tZSB2LCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGxsLCBtYXliZV9lbHQsIHJsID0gc3BsaXQgbCBpblxuICAgICAgICAgIGxsLCBtYXliZV9lbHQsIGpvaW4gcmwgdiByKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbHIsIG1heWJlX2VsdCwgcnIgPSBzcGxpdCByIGluXG4gICAgICAgICAgam9pbiBsIHYgbHIsIG1heWJlX2VsdCwgcnIpXG4gICAgaW5cbiAgICBzcGxpdCB0XG4gIDs7XG5cbiAgbGV0IHJlYyBzcGxpdF9sZV9ndCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5LCBFbXB0eVxuICAgIHwgTGVhZiB2IC0+IGlmIGNvbXBhcmVfZWx0IHggdiA+PSAwIHRoZW4gTGVhZiB2LCBFbXB0eSBlbHNlIEVtcHR5LCBMZWFmIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gYWRkX21heCBsIHYsIHJcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIHJsID0gc3BsaXRfbGVfZ3QgbCB4IH5jb21wYXJlX2VsdCBpblxuICAgICAgICBsbCwgam9pbiBybCB2IHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxyLCByciA9IHNwbGl0X2xlX2d0IHIgeCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgam9pbiBsIHYgbHIsIHJyKVxuICA7O1xuXG4gIGxldCByZWMgc3BsaXRfbHRfZ2UgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eSwgRW1wdHlcbiAgICB8IExlYWYgdiAtPiBpZiBjb21wYXJlX2VsdCB4IHYgPiAwIHRoZW4gTGVhZiB2LCBFbXB0eSBlbHNlIEVtcHR5LCBMZWFmIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gbCwgYWRkX21pbiB2IHJcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIHJsID0gc3BsaXRfbHRfZ2UgbCB4IH5jb21wYXJlX2VsdCBpblxuICAgICAgICBsbCwgam9pbiBybCB2IHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxyLCByciA9IHNwbGl0X2x0X2dlIHIgeCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgam9pbiBsIHYgbHIsIHJyKVxuICA7O1xuXG4gICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IHJlYyBtZW0gdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB2IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDBcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDAgfHwgbWVtIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzaW5nbGV0b24geCA9IExlYWYgeFxuXG4gIGxldCByZW1vdmUgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTGVhZiB2IC0+IGlmIGNvbXBhcmVfZWx0IHggdiA9IDAgdGhlbiBFbXB0eSBlbHNlIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByIGVsc2UgaWYgYyA8IDAgdGhlbiBiYWwgKGF1eCBsKSB2IHIgZWxzZSBiYWwgbCB2IChhdXggcilcbiAgICBpblxuICAgIHRyeSBhdXggdCB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgcmVtb3ZlX2luZGV4IHQgaSB+Y29tcGFyZV9lbHQ6XyA9XG4gICAgbGV0IHJlYyBhdXggdCBpID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgU2FtZVxuICAgICAgfCBMZWFmIF8gLT4gaWYgaSA9IDAgdGhlbiBFbXB0eSBlbHNlIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBsX3NpemUgPSBsZW5ndGggbCBpblxuICAgICAgICBsZXQgYyA9IFBvbHkuY29tcGFyZSBpIGxfc2l6ZSBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIG1lcmdlIGwgclxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gYmFsIChhdXggbCBpKSB2IHJcbiAgICAgICAgZWxzZSBiYWwgbCB2IChhdXggciAoaSAtIGxfc2l6ZSAtIDEpKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IGkgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHVuaW9uIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIHMxXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgdCB8IHQsIEVtcHR5IC0+IHRcbiAgICAgICAgfCBMZWFmIHYxLCBfIC0+IHVuaW9uIChOb2RlIChFbXB0eSwgdjEsIEVtcHR5LCAxLCAxKSkgczJcbiAgICAgICAgfCBfLCBMZWFmIHYyIC0+IHVuaW9uIHMxIChOb2RlIChFbXB0eSwgdjIsIEVtcHR5LCAxLCAxKSlcbiAgICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBoMSwgXyksIE5vZGUgKGwyLCB2MiwgcjIsIGgyLCBfKSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxXG4gICAgICAgICAgICB0aGVuIGFkZCBzMSB2MiB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICBsZXQgbDIsIF8sIHIyID0gc3BsaXQgczIgdjEgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpKVxuICAgICAgICAgIGVsc2UgaWYgaDEgPSAxXG4gICAgICAgICAgdGhlbiBhZGQgczIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbDEsIF8sIHIxID0gc3BsaXQgczEgdjIgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKSkpXG4gICAgaW5cbiAgICB1bmlvbiBzMSBzMlxuICA7O1xuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIHhzID1cbiAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgIExpc3QuZm9sZCB4cyB+aW5pdDplbXB0eSB+ZjooZnVuIGFjIHggLT4gdW5pb24gYWMgKHRvX3RyZWUgeCkgfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBpbnRlciBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBzMVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gfCBfLCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IChMZWFmIGVsdCBhcyBzaW5nbGV0b24pLCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIChMZWFmIGVsdCBhcyBzaW5nbGV0b24pIC0+XG4gICAgICAgICAgaWYgbWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0IHRoZW4gc2luZ2xldG9uIGVsc2UgRW1wdHlcbiAgICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgICB8IGwyLCBTb21lIHYxLCByMiAtPiBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKSkpXG4gICAgaW5cbiAgICBpbnRlciBzMSBzMlxuICA7O1xuXG4gIGxldCBkaWZmIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gRW1wdHlcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIC0+IEVtcHR5XG4gICAgICAgIHwgdDEsIEVtcHR5IC0+IHQxXG4gICAgICAgIHwgTGVhZiB2MSwgdDIgLT4gZGlmZiAoTm9kZSAoRW1wdHksIHYxLCBFbXB0eSwgMSwgMSkpIHQyXG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgICB8IGwyLCBTb21lIF8sIHIyIC0+IGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpKSlcbiAgICBpblxuICAgIGRpZmYgczEgczJcbiAgOztcblxuICBtb2R1bGUgRW51bSA9IHN0cnVjdFxuICAgIHR5cGUgaW5jcmVhc2luZ1xuICAgIHR5cGUgZGVjcmVhc2luZ1xuXG4gICAgdHlwZSAoJ2EsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnYSAqICdhIHRyZWUgKiAoJ2EsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyBzIChlIDogKF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB2IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBjb25zIGwgKE1vcmUgKHYsIHIsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbnNfcmlnaHQgcyAoZSA6IChfLCBkZWNyZWFzaW5nKSB0KSA6IChfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgdiAtPiBNb3JlICh2LCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gY29uc19yaWdodCByIChNb3JlICh2LCBsLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3NldCBzIDogKF8sIGluY3JlYXNpbmcpIHQgPSBjb25zIHMgRW5kXG4gICAgbGV0IG9mX3NldF9yaWdodCBzIDogKF8sIGRlY3JlYXNpbmcpIHQgPSBjb25zX3JpZ2h0IHMgRW5kXG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHYgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIEVtcHR5LCAxLCAxKSkgZVxuICAgICAgICB8IE5vZGUgKF8sIHYsIHIsIF8sIF8pIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBsb29wIGwgKE1vcmUgKHYsIHIsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB2IC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBFbXB0eSwgMSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBfLCBfLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPiAwIC0+IGxvb3AgbCBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gbG9vcCByIChNb3JlICh2LCBsLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGUxIGUyID1cbiAgICAgIGxldCByZWMgbG9vcCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIGUxLCBlMiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gMFxuICAgICAgICB8IEVuZCwgXyAtPiAtMVxuICAgICAgICB8IF8sIEVuZCAtPiAxXG4gICAgICAgIHwgTW9yZSAodjEsIHIxLCBlMSksIE1vcmUgKHYyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgaWYgcGh5c19lcXVhbCByMSByMlxuICAgICAgICAgIHRoZW4gbG9vcCBlMSBlMlxuICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpXG4gICAgICBpblxuICAgICAgbG9vcCBlMSBlMlxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGl0ZXIgfmYgPSBmdW5jdGlvblxuICAgICAgfCBFbmQgLT4gKClcbiAgICAgIHwgTW9yZSAoYSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgZiBhO1xuICAgICAgICBpdGVyIChjb25zIHRyZWUgZW51bSkgfmZcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIyIGNvbXBhcmVfZWx0IHQxIHQyIH5mID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gKClcbiAgICAgICAgfCBFbmQsIF8gLT4gaXRlciB0MiB+ZjooZnVuIGEgLT4gZiAoYFJpZ2h0IGEpKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgXywgRW5kIC0+IGl0ZXIgdDEgfmY6KGZ1biBhIC0+IGYgKGBMZWZ0IGEpKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBCb3RoIChhMSwgYTIpKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgZiAoYExlZnQgYTEpO1xuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBmIChgUmlnaHQgYTIpO1xuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MiBbQG5vbnRhaWxdXG4gICAgOztcblxuICAgIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQgPVxuICAgICAgbGV0IHN0ZXAgc3RhdGUgOiAoKF8sIF8pIEVpdGhlci50LCBfKSBTZXF1ZW5jZS5TdGVwLnQgPVxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gRG9uZVxuICAgICAgICB8IEVuZCwgTW9yZSAoZWx0LCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBTZWNvbmQgZWx0OyBzdGF0ZSA9IEVuZCwgY29ucyB0cmVlIGVudW0gfVxuICAgICAgICB8IE1vcmUgKGVsdCwgdHJlZSwgZW51bSksIEVuZCAtPlxuICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBGaXJzdCBlbHQ7IHN0YXRlID0gY29ucyB0cmVlIGVudW0sIEVuZCB9XG4gICAgICAgIHwgKE1vcmUgKGExLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoYTIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0X3N0YXRlID1cbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgICB0aGVuIGVudW0xLCBlbnVtMlxuICAgICAgICAgICAgICBlbHNlIGNvbnMgdHJlZTEgZW51bTEsIGNvbnMgdHJlZTIgZW51bTJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBTa2lwIHsgc3RhdGUgPSBuZXh0X3N0YXRlIH0pXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBGaXJzdCBhMTsgc3RhdGUgPSBjb25zIHRyZWUxIGVudW0xLCByaWdodCB9XG4gICAgICAgICAgZWxzZSBZaWVsZCB7IHZhbHVlID0gU2Vjb25kIGEyOyBzdGF0ZSA9IGxlZnQsIGNvbnMgdHJlZTIgZW51bTIgfVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl9zZXQgdDEsIG9mX3NldCB0MikgfmY6c3RlcFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGs7IHN0YXRlID0gRW51bS5jb25zIHQgZSB9XG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPlxuICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrOyBzdGF0ZSA9IEVudW0uY29uc19yaWdodCB0IGUgfVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0X3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nKVxuICAgICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2VsdCA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2VsdCBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSBlbHQgLT4gYWRkIHQgZWx0IH5jb21wYXJlX2VsdFxuICAgIGluXG4gICAgbWF0Y2ggb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQgbGVzc19vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgZnN0KSBpblxuICAgICAgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdDpncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nIC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGdyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQ6bGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgdlxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIGwgfmZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8IDApIFtAbm9udGFpbF1cbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMCkgW0Bub250YWlsXVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMCkgW0Bub250YWlsXVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID4gMCkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgbGV0IGlzX2xlZnQgeCA9XG4gICAgICBtYXRjaCBzZWdtZW50X29mIHggd2l0aFxuICAgICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgICB8IGBSaWdodCAtPiBmYWxzZVxuICAgIGluXG4gICAgbGV0IGlzX3JpZ2h0IHggPSBub3QgKGlzX2xlZnQgeCkgaW5cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfb25fbGVmdCAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOmlzX2xlZnQgW0Bub250YWlsXVxuICAgIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOmlzX3JpZ2h0IFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICAgICAgY29tcGFyYXRvclxuICAgICAgICA/KG9yZGVyID0gYEluY3JlYXNpbmcpXG4gICAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICAgIHRcbiAgICAgICAgdCdcbiAgICA9XG4gICAgU2VxdWVuY2UubWVyZ2Vfd2l0aF9kdXBsaWNhdGVzXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdClcbiAgICAgICh0b19zZXF1ZW5jZSBjb21wYXJhdG9yIH5vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0JylcbiAgICAgIH5jb21wYXJlOlxuICAgICAgICAobWF0Y2ggb3JkZXIgd2l0aFxuICAgICAgICAgfCBgSW5jcmVhc2luZyAtPiBjb21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgIHwgYERlY3JlYXNpbmcgLT4gRm4uZmxpcCBjb21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgczEgczIgPVxuICAgIEVudW0uY29tcGFyZSBjb21wYXJlX2VsdCAoRW51bS5vZl9zZXQgczEpIChFbnVtLm9mX3NldCBzMilcbiAgOztcblxuICBsZXQgaXRlcjIgczEgczIgfmNvbXBhcmVfZWx0IH5mID1cbiAgICBFbnVtLml0ZXIyIGNvbXBhcmVfZWx0IChFbnVtLm9mX3NldCBzMSkgKEVudW0ub2Zfc2V0IHMyKSB+ZlxuICA7O1xuXG4gIGxldCBlcXVhbCBzMSBzMiB+Y29tcGFyZV9lbHQgPSBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID0gMFxuXG4gIGxldCBpc19zdWJzZXQgczEgfm9mXzpzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaXNfc3Vic2V0IHMxIH5vZl86czIgPVxuICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgIHwgRW1wdHksIF8gLT4gdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBMZWFmIHYxLCB0MiAtPiBtZW0gdDIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCBMZWFmIHYyIC0+XG4gICAgICAgIChtYXRjaCBsMSwgcjEgd2l0aFxuICAgICAgICAgfCBFbXB0eSwgRW1wdHkgLT5cbiAgICAgICAgICAgKCogVGhpcyBjYXNlIHNob3VsZG4ndCBvY2N1ciBpbiBwcmFjdGljZSBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgIGEgTGVhZiByYXRoZXIgdGhhbiBhIE5vZGUgd2l0aCB0d28gRW1wdHkgc3VidHJlZXMgKilcbiAgICAgICAgICAgY29tcGFyZV9lbHQgdjEgdjIgPSAwXG4gICAgICAgICB8IF8sIF8gLT4gZmFsc2UpXG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCAoTm9kZSAobDIsIHYyLCByMiwgXywgXykgYXMgdDIpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIHBoeXNfZXF1YWwgczEgczIgfHwgKGlzX3N1YnNldCBsMSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnIyKVxuICAgICAgICAgICgqIE5vdGUgdGhhdCBoZWlnaHQgYW5kIHNpemUgZG9uJ3QgbWF0dGVyIGhlcmUuICopXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBpc19zdWJzZXQgKE5vZGUgKGwxLCB2MSwgRW1wdHksIDAsIDApKSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnQyXG4gICAgICAgIGVsc2UgaXNfc3Vic2V0IChOb2RlIChFbXB0eSwgdjEsIHIxLCAwLCAwKSkgfm9mXzpyMiAmJiBpc19zdWJzZXQgbDEgfm9mXzp0MlxuICAgIGluXG4gICAgaXNfc3Vic2V0IHMxIH5vZl86czJcbiAgOztcblxuICBsZXQgcmVjIGFyZV9kaXNqb2ludCBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgfCBFbXB0eSwgXyB8IF8sIEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgZWx0LCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIExlYWYgZWx0IC0+IG5vdCAobWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0KVxuICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIGZhbHNlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT5cbiAgICAgICAgICBhcmVfZGlzam9pbnQgbDEgbDIgfmNvbXBhcmVfZWx0ICYmIGFyZV9kaXNqb2ludCByMSByMiB+Y29tcGFyZV9lbHRcbiAgICAgICAgfCBfLCBTb21lIF8sIF8gLT4gZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9XG4gICAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgTGVhZiB2IC0+IGYgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBpdGVyIGw7XG4gICAgICAgIGYgdjtcbiAgICAgICAgaXRlciByXG4gICAgaW5cbiAgICBpdGVyIHQgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgcmVjIGZvbGQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiBmIGFjY3UgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZm9sZCB+ZiByIH5pbml0OihmIChmb2xkIH5mIGwgfmluaXQ6YWNjdSkgdilcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9lbGVtIHN0YXRlIHQgPVxuICAgIGZvbGQgdCB+aW5pdDooaGFzaF9mb2xkX2ludCBzdGF0ZSAobGVuZ3RoIHQpKSB+ZjpoYXNoX2ZvbGRfZWxlbVxuICA7O1xuXG4gIGxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxuXG4gIGxldCByZWMgZm9sZF9yaWdodCBzIH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB2IC0+IGYgdiBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBmb2xkX3JpZ2h0IH5mIGwgfmluaXQ6KGYgdiAoZm9sZF9yaWdodCB+ZiByIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCByZWMgZm9yX2FsbCB0IH5mOnAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiB2IC0+IHAgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gcCB2ICYmIGZvcl9hbGwgfmY6cCBsICYmIGZvcl9hbGwgfmY6cCByXG4gIDs7XG5cbiAgbGV0IHJlYyBleGlzdHMgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHYgLT4gcCB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBwIHYgfHwgZXhpc3RzIH5mOnAgbCB8fCBleGlzdHMgfmY6cCByXG4gIDs7XG5cbiAgbGV0IGZpbHRlciBzIH5mOnAgPVxuICAgIGxldCByZWMgZmlsdCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IExlYWYgdiBhcyB0IC0+IGlmIHAgdiB0aGVuIHQgZWxzZSBFbXB0eVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSBhcyB0IC0+XG4gICAgICAgIGxldCBsJyA9IGZpbHQgbCBpblxuICAgICAgICBsZXQga2VlcF92ID0gcCB2IGluXG4gICAgICAgIGxldCByJyA9IGZpbHQgciBpblxuICAgICAgICBpZiBrZWVwX3YgJiYgcGh5c19lcXVhbCBsIGwnICYmIHBoeXNfZXF1YWwgciByJ1xuICAgICAgICB0aGVuIHRcbiAgICAgICAgZWxzZSBpZiBrZWVwX3ZcbiAgICAgICAgdGhlbiBqb2luIGwnIHYgcidcbiAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcbiAgICBpblxuICAgIGZpbHQgcyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBmaWx0IGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgdiAtPlxuICAgICAgICAobWF0Y2ggcCB2IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhY2N1XG4gICAgICAgICB8IFNvbWUgdiAtPiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdClcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgZmlsdFxuICAgICAgICAgIChmaWx0XG4gICAgICAgICAgICAgKG1hdGNoIHAgdiB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0KVxuICAgICAgICAgICAgIGwpXG4gICAgICAgICAgclxuICAgIGluXG4gICAgZmlsdCBFbXB0eSBzIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHMgfmY6cCA9XG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHksIEVtcHR5XG4gICAgICB8IExlYWYgdiBhcyB0IC0+IGlmIHAgdiB0aGVuIHQsIEVtcHR5IGVsc2UgRW1wdHksIHRcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgYXMgdCAtPlxuICAgICAgICBsZXQgbCd0LCBsJ2YgPSBsb29wIGwgaW5cbiAgICAgICAgbGV0IGtlZXBfdl90ID0gcCB2IGluXG4gICAgICAgIGxldCByJ3QsIHInZiA9IGxvb3AgciBpblxuICAgICAgICBsZXQgbWsga2VlcF92IGwnIHInID1cbiAgICAgICAgICBpZiBrZWVwX3YgJiYgcGh5c19lcXVhbCBsIGwnICYmIHBoeXNfZXF1YWwgciByJ1xuICAgICAgICAgIHRoZW4gdFxuICAgICAgICAgIGVsc2UgaWYga2VlcF92XG4gICAgICAgICAgdGhlbiBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuICAgICAgICBpblxuICAgICAgICBtayBrZWVwX3ZfdCBsJ3Qgcid0LCBtayAobm90IGtlZXBfdl90KSBsJ2YgcidmXG4gICAgaW5cbiAgICBsb29wIHMgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB2IC0+IHYgOjogYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcbiAgOztcblxuICBsZXQgZWxlbWVudHMgcyA9IGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgbGV0IGNob29zZSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBTb21lIHZcbiAgICB8IE5vZGUgKF8sIHYsIF8sIF8sIF8pIC0+IFNvbWUgdlxuICA7O1xuXG4gIGxldCBjaG9vc2VfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTZXQuY2hvb3NlX2V4bjogZW1wdHkgc2V0XCIpIGluXG4gICAgbGV0IGNob29zZV9leG4gdCA9XG4gICAgICBtYXRjaCBjaG9vc2UgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgICB8IFNvbWUgdiAtPiB2XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgY2hvb3NlX2V4blxuICA7O1xuXG4gIGxldCBvZl9saXN0IGxzdCB+Y29tcGFyZV9lbHQgPVxuICAgIExpc3QuZm9sZCBsc3QgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlIH5jb21wYXJlX2VsdCA9XG4gICAgU2VxdWVuY2UuZm9sZCBzZXF1ZW5jZSB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgdG9fbGlzdCBzID0gZWxlbWVudHMgc1xuXG4gIGxldCBvZl9hcnJheSBhIH5jb21wYXJlX2VsdCA9XG4gICAgQXJyYXkuZm9sZCBhIH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gICgqIGZhc3RlciBidXQgZXF1aXZhbGVudCB0byBbQXJyYXkub2ZfbGlzdCAodG9fbGlzdCB0KV0gKilcbiAgbGV0IHRvX2FycmF5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IFt8fF1cbiAgICB8IExlYWYgdiAtPiBbfCB2IHxdXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBzKSAtPlxuICAgICAgbGV0IHJlcyA9IEFycmF5LmNyZWF0ZSB+bGVuOnMgdiBpblxuICAgICAgbGV0IHBvc19yZWYgPSByZWYgMCBpblxuICAgICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgICAgKCogSW52YXJpYW50OiBvbiBlbnRyeSBhbmQgb24gZXhpdCB0byBbbG9vcF0sICFwb3NfcmVmIGlzIHRoZSBuZXh0XG4gICAgICAgICAgIGF2YWlsYWJsZSBjZWxsIGluIHRoZSBhcnJheS4gKilcbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IExlYWYgdiAtPlxuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmXG4gICAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgICBsb29wIGw7XG4gICAgICAgICAgcmVzLighcG9zX3JlZikgPC0gdjtcbiAgICAgICAgICBpbmNyIHBvc19yZWY7XG4gICAgICAgICAgbG9vcCByXG4gICAgICBpblxuICAgICAgbG9vcCBsO1xuICAgICAgKCogcmVzLighcG9zX3JlZikgaXMgYWxyZWFkeSBpbml0aWFsaXplZCAoYnkgQXJyYXkuY3JlYXRlIH5sZW46YWJvdmUpLiAqKVxuICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgbG9vcCByO1xuICAgICAgcmVzXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mIH5jb21wYXJlX2VsdCA9XG4gICAgZm9sZCB0IH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IChmIHgpIH5jb21wYXJlX2VsdCkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBncm91cF9ieSBzZXQgfmVxdWl2ID1cbiAgICBsZXQgcmVjIGxvb3Agc2V0IGVxdWl2X2NsYXNzZXMgPVxuICAgICAgaWYgaXNfZW1wdHkgc2V0XG4gICAgICB0aGVuIGVxdWl2X2NsYXNzZXNcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeCA9IGNob29zZV9leG4gc2V0IGluXG4gICAgICAgIGxldCBlcXVpdl94LCBub3RfZXF1aXZfeCA9XG4gICAgICAgICAgcGFydGl0aW9uX3RmIHNldCB+ZjooZnVuIGVsdCAtPiBwaHlzX2VxdWFsIHggZWx0IHx8IGVxdWl2IHggZWx0KVxuICAgICAgICBpblxuICAgICAgICBsb29wIG5vdF9lcXVpdl94IChlcXVpdl94IDo6IGVxdWl2X2NsYXNzZXMpKVxuICAgIGluXG4gICAgbG9vcCBzZXQgW10gW0Bub250YWlsXVxuICA7O1xuXG5cbiAgbGV0IHJlYyBmaW5kIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gU29tZSB2XG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggZmluZCBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbmQgciB+ZlxuICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX21hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBmIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAobWF0Y2ggZiB2IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIChtYXRjaCBmaW5kX21hcCBsIH5mIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgciB+ZlxuICAgICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcikpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2V0LmZpbmRfZXhuIGZhaWxlZCB0byBmaW5kIGEgbWF0Y2hpbmcgZWxlbWVudFwiXG4gICAgfCBTb21lIGUgLT4gZVxuICA7O1xuXG4gIGxldCByZWMgbnRoIHQgaSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gaWYgaSA9IDAgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBzKSAtPlxuICAgICAgaWYgaSA+PSBzXG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbF9zaXplID0gbGVuZ3RoIGwgaW5cbiAgICAgICAgbGV0IGMgPSBQb2x5LmNvbXBhcmUgaSBsX3NpemUgaW5cbiAgICAgICAgaWYgYyA8IDAgdGhlbiBudGggbCBpIGVsc2UgaWYgYyA9IDAgdGhlbiBTb21lIHYgZWxzZSBudGggciAoaSAtIGxfc2l6ZSAtIDEpKVxuICA7O1xuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgbG9vcCB4cyBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuID1cbiAgICAgIG1hdGNoIHhzIHdpdGhcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgbGVmdG92ZXJzXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGlmIG1lbSBhbHJlYWR5X3NlZW4gaGQgfmNvbXBhcmVfZWx0XG4gICAgICAgIHRoZW4gbG9vcCB0bCBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuXG4gICAgICAgIGVsc2UgbG9vcCB0bCAoaGQgOjogbGVmdG92ZXJzKSAoYWRkIGFscmVhZHlfc2VlbiBoZCB+Y29tcGFyZV9lbHQpXG4gICAgaW5cbiAgICBsb29wIHhzIFtdIGVtcHR5XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgYV9vZl9zZXhwIHNleHAgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuTGlzdCBsc3QgLT5cbiAgICAgIGxldCBlbHRfbHN0ID0gTGlzdC5tYXAgbHN0IH5mOmFfb2Zfc2V4cCBpblxuICAgICAgbGV0IHNldCA9IG9mX2xpc3QgZWx0X2xzdCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGlmIGxlbmd0aCBzZXQgPSBMaXN0Lmxlbmd0aCBsc3RcbiAgICAgIHRoZW4gc2V0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHNldCA9IHJlZiBlbXB0eSBpblxuICAgICAgICBMaXN0Lml0ZXIyX2V4biBsc3QgZWx0X2xzdCB+ZjooZnVuIGVsX3NleHAgZWwgLT5cbiAgICAgICAgICBpZiBtZW0gIXNldCBlbCB+Y29tcGFyZV9lbHRcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJTZXQudF9vZl9zZXhwOiBkdXBsaWNhdGUgZWxlbWVudCBpbiBzZXRcIiBlbF9zZXhwXG4gICAgICAgICAgZWxzZSBzZXQgOj0gYWRkICFzZXQgZWwgfmNvbXBhcmVfZWx0KTtcbiAgICAgICAgYXNzZXJ0IGZhbHNlKVxuICAgIHwgc2V4cCAtPiBvZl9zZXhwX2Vycm9yIFwiU2V0LnRfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgU2V4cC5MaXN0IChmb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biBlbCBhY2MgLT4gc2V4cF9vZl9hIGVsIDo6IGFjYykpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgbGV0IGlzX3N1YnNldFxuICAgICAgICAgIChzdWJzZXQgOiBfIE5hbWVkLnQpXG4gICAgICAgICAgfm9mXzooc3VwZXJzZXQgOiBfIE5hbWVkLnQpXG4gICAgICAgICAgfnNleHBfb2ZfZWx0XG4gICAgICAgICAgfmNvbXBhcmVfZWx0XG4gICAgICA9XG4gICAgICBsZXQgaW52YWxpZF9lbGVtZW50cyA9IGRpZmYgc3Vic2V0LnNldCBzdXBlcnNldC5zZXQgfmNvbXBhcmVfZWx0IGluXG4gICAgICBpZiBpc19lbXB0eSBpbnZhbGlkX2VsZW1lbnRzXG4gICAgICB0aGVuIE9rICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGludmFsaWRfZWxlbWVudHNfc2V4cCA9IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBpbnZhbGlkX2VsZW1lbnRzIGluXG4gICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgKHN1YnNldC5uYW1lIF4gXCIgaXMgbm90IGEgc3Vic2V0IG9mIFwiIF4gc3VwZXJzZXQubmFtZSlcbiAgICAgICAgICAgICBbIFwiaW52YWxpZF9lbGVtZW50c1wiLCBpbnZhbGlkX2VsZW1lbnRzX3NleHAgXSkpXG4gICAgOztcblxuICAgIGxldCBlcXVhbCBzMSBzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0ID1cbiAgICAgIE9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXRcbiAgICAgICAgWyBpc19zdWJzZXQgczEgfm9mXzpzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0XG4gICAgICAgIDsgaXNfc3Vic2V0IHMyIH5vZl86czEgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdFxuICAgICAgICBdXG4gICAgOztcbiAgZW5kXG5lbmRcblxudHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2EsICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogJ2EgVHJlZTAudFxuICB9XG5cbnR5cGUgKCdhLCAnY29tcGFyYXRvcikgdHJlZSA9ICdhIFRyZWUwLnRcblxubGV0IGxpa2UgeyB0cmVlID0gXzsgY29tcGFyYXRvciB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3IgfVxuXG5sZXQgbGlrZV9tYXliZV9ub19vcCAoeyB0cmVlID0gb2xkX3RyZWU7IGNvbXBhcmF0b3IgfSBhcyBvbGRfdCkgdHJlZSA9XG4gIGlmIHBoeXNfZXF1YWwgb2xkX3RyZWUgdHJlZSB0aGVuIG9sZF90IGVsc2UgeyB0cmVlOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCBjb21wYXJlX2VsdCB0ID0gdC5jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBjb21wYXJhdG9yIHQgPSB0LmNvbXBhcmF0b3JcblxuICBsZXQgY29tcGFyYXRvcl9zICh0eXBlIGsgY21wKSB0IDogKGssIGNtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCA9XG4gICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IGtcbiAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wXG5cbiAgICAgIGxldCBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yXG4gICAgZW5kKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnRzIHQgPSBUcmVlMC5pbnZhcmlhbnRzIHQudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0LnRyZWVcbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0LnRyZWVcbiAgbGV0IGVsZW1lbnRzIHQgPSBUcmVlMC5lbGVtZW50cyB0LnRyZWVcbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdC50cmVlXG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdC50cmVlXG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHQudHJlZVxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHQudHJlZVxuICBsZXQgY2hvb3NlIHQgPSBUcmVlMC5jaG9vc2UgdC50cmVlXG4gIGxldCBjaG9vc2VfZXhuIHQgPSBUcmVlMC5jaG9vc2VfZXhuIHQudHJlZVxuICBsZXQgdG9fbGlzdCB0ID0gVHJlZTAudG9fbGlzdCB0LnRyZWVcbiAgbGV0IHRvX2FycmF5IHQgPSBUcmVlMC50b19hcnJheSB0LnRyZWVcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IFRyZWUwLmZvbGRfdW50aWwgdC50cmVlIH5pbml0IH5mIH5maW5pc2hcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdC50cmVlIH5mXG4gIGxldCBpdGVyMiBhIGIgfmYgPSBUcmVlMC5pdGVyMiBhLnRyZWUgYi50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgYSlcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQudHJlZSB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0LnRyZWUgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0LnRyZWUgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0LnRyZWUgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IFRyZWUwLmZpbmQgdC50cmVlIH5mXG4gIGxldCBmaW5kX2V4biB0IH5mID0gVHJlZTAuZmluZF9leG4gdC50cmVlIH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdC50cmVlIH5mXG4gIGxldCBtZW0gdCBhID0gVHJlZTAubWVtIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcbiAgbGV0IGZpbHRlciB0IH5mID0gbGlrZV9tYXliZV9ub19vcCB0IChUcmVlMC5maWx0ZXIgdC50cmVlIH5mKVxuICBsZXQgYWRkIHQgYSA9IGxpa2UgdCAoVHJlZTAuYWRkIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCByZW1vdmUgdCBhID0gbGlrZSB0IChUcmVlMC5yZW1vdmUgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHVuaW9uIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAudW5pb24gdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuICBsZXQgaW50ZXIgdDEgdDIgPSBsaWtlIHQxIChUcmVlMC5pbnRlciB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG4gIGxldCBkaWZmIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAuZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgdDEgdDIgPSBUcmVlMC5jb21wYXJlIChjb21wYXJlX2VsdCB0MSkgdDEudHJlZSB0Mi50cmVlXG4gIGxldCBlcXVhbCB0MSB0MiA9IFRyZWUwLmVxdWFsIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICBsZXQgaXNfc3Vic2V0IHQgfm9mXyA9IFRyZWUwLmlzX3N1YnNldCB0LnRyZWUgfm9mXzpvZl8udHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG5cbiAgbGV0IGFyZV9kaXNqb2ludCB0MSB0MiA9XG4gICAgVHJlZTAuYXJlX2Rpc2pvaW50IHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICA7O1xuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIGxldCB0b19uYW1lZF90cmVlIChuYW1lZCA6IChfLCBfKSB0IE5hbWVkLnQpID0geyBuYW1lZCB3aXRoIHNldCA9IG5hbWVkLnNldC50cmVlIH1cblxuICAgIGxldCBpc19zdWJzZXQgc3Vic2V0IH5vZl86c3VwZXJzZXQgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgICh0b19uYW1lZF90cmVlIHN1YnNldClcbiAgICAgICAgfm9mXzoodG9fbmFtZWRfdHJlZSBzdXBlcnNldClcbiAgICAgICAgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCBzdWJzZXQuc2V0KVxuICAgICAgICB+c2V4cF9vZl9lbHQ6c3Vic2V0LnNldC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgdDEgdDIgPVxuICAgICAgT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdCBbIGlzX3N1YnNldCB0MSB+b2ZfOnQyOyBpc19zdWJzZXQgdDIgfm9mXzp0MSBdXG4gICAgOztcblxuICAgIGluY2x1ZGUgTmFtZWRcbiAgZW5kXG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgICBsZXQgdHJlZV90LCB0cmVlX2YgPSBUcmVlMC5wYXJ0aXRpb25fdGYgdC50cmVlIH5mIGluXG4gICAgbGlrZV9tYXliZV9ub19vcCB0IHRyZWVfdCwgbGlrZV9tYXliZV9ub19vcCB0IHRyZWVfZlxuICA7O1xuXG4gIGxldCBzcGxpdCB0IGEgPVxuICAgIGxldCB0cmVlMSwgYiwgdHJlZTIgPSBUcmVlMC5zcGxpdCB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpIGluXG4gICAgbGlrZSB0IHRyZWUxLCBiLCBsaWtlIHQgdHJlZTJcbiAgOztcblxuICBsZXQgc3BsaXRfbGVfZ3QgdCBhID1cbiAgICBsZXQgdHJlZTEsIHRyZWUyID0gVHJlZTAuc3BsaXRfbGVfZ3QgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlMSwgbGlrZSB0IHRyZWUyXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2x0X2dlIHQgYSA9XG4gICAgbGV0IHRyZWUxLCB0cmVlMiA9IFRyZWUwLnNwbGl0X2x0X2dlIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZTEsIGxpa2UgdCB0cmVlMlxuICA7O1xuXG4gIGxldCBncm91cF9ieSB0IH5lcXVpdiA9IExpc3QubWFwIChUcmVlMC5ncm91cF9ieSB0LnRyZWUgfmVxdWl2KSB+ZjoobGlrZSB0KVxuICBsZXQgbnRoIHQgaSA9IFRyZWUwLm50aCB0LnRyZWUgaVxuICBsZXQgcmVtb3ZlX2luZGV4IHQgaSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlX2luZGV4IHQudHJlZSBpIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2EgdC50cmVlXG5cbiAgbGV0IHRvX3NlcXVlbmNlID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSB0LmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQudHJlZSB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdC50cmVlIH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2VcbiAgICAgIHQuY29tcGFyYXRvclxuICAgICAgP29yZGVyXG4gICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgIHQudHJlZVxuICAgICAgdCcudHJlZVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXkgc3RhdGUgdCA9XG4gICAgVHJlZTAuaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgc3RhdGUgdC50cmVlXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNvbXBhcmUgXyBfIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcblxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID0gKCdhLCAnY29tcGFyYXRvcikgdHJlZVxuXG4gIGxldCBjZSBjb21wYXJhdG9yID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBhX29mX3NleHAgc2V4cCA9XG4gICAgVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpIGFfb2Zfc2V4cCBzZXhwXG4gIDs7XG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvcjpfIGUgPSBUcmVlMC5zaW5nbGV0b24gZVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdFxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID0gVHJlZTAuaW52YXJpYW50cyB0IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdFxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgY2hvb3NlIHQgPSBUcmVlMC5jaG9vc2UgdFxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0XG4gIGxldCB0b19saXN0IHQgPSBUcmVlMC50b19saXN0IHRcbiAgbGV0IHRvX2FycmF5IHQgPSBUcmVlMC50b19hcnJheSB0XG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0IH5mXG4gIGxldCBmaW5kIHQgfmYgPSBUcmVlMC5maW5kIHQgfmZcbiAgbGV0IGZpbmRfZXhuIHQgfmYgPSBUcmVlMC5maW5kX2V4biB0IH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdCB+ZlxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0IH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IFRyZWUwLmZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQgfmluaXQgfmZcbiAgbGV0IG1hcCB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAubWFwIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZmlsdGVyIHQgfmYgPSBUcmVlMC5maWx0ZXIgdCB+ZlxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gVHJlZTAucGFydGl0aW9uX3RmIHQgfmZcbiAgbGV0IGl0ZXIyIH5jb21wYXJhdG9yIGEgYiB+ZiA9IFRyZWUwLml0ZXIyIGEgYiB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBtZW0gfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAubWVtIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuYWRkIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCByZW1vdmUgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAucmVtb3ZlIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCB1bmlvbiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLnVuaW9uIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGludGVyIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuaW50ZXIgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmRpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNlIGNvbXBhcmF0b3IpIHQxIHQyXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmVxdWFsIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX3N1YnNldCB+Y29tcGFyYXRvciB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdCB+b2ZfIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgYXJlX2Rpc2pvaW50IH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPSBUcmVlMC5vZl9saXN0IGwgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgcyA9IFRyZWUwLm9mX3NlcXVlbmNlIHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2ZfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGEgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl8gfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgbCA9IFRyZWUwLnVuaW9uX2xpc3QgbCB+dG9fdHJlZTpGbi5pZCB+Y29tcGFyYXRvclxuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciB4cyA9XG4gICAgVHJlZTAuc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBncm91cF9ieSB0IH5lcXVpdiA9IFRyZWUwLmdyb3VwX2J5IHQgfmVxdWl2XG4gIGxldCBzcGxpdCB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5zcGxpdCB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc3BsaXRfbGVfZ3QgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuc3BsaXRfbGVfZ3QgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNwbGl0X2x0X2dlIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnNwbGl0X2x0X2dlIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBudGggdCBpID0gVHJlZTAubnRoIHQgaVxuICBsZXQgcmVtb3ZlX2luZGV4IH5jb21wYXJhdG9yIHQgaSA9IFRyZWUwLnJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9hIHRcbiAgbGV0IHRvX3RyZWUgdCA9IHRcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0ID0gdFxuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIH5jb21wYXJhdG9yOl8gdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB+Y29tcGFyYXRvcjpfIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0J1xuICA7O1xuXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRyZWUwLk5hbWVkXG5cbiAgICBsZXQgaXNfc3Vic2V0IH5jb21wYXJhdG9yIHQxIH5vZl86dDIgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgIHQxXG4gICAgICAgIH5vZl86dDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgICAgVHJlZTAuTmFtZWQuZXF1YWxcbiAgICAgICAgdDFcbiAgICAgICAgdDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3IgYV9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWVcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5jb21wYXJlIGFfb2Zfc2V4cCBzZXhwKVxuICA7O1xuXG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvciA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IGNvbXBhcmF0b3IgPSBFbHQuY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cbiAgZW5kXG5cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvciBlID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGUgfVxuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgfnRvX3RyZWUgbClcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgbGV0IHRyZWUgPVxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgT3JfZXJyb3IuTW9uYWRfaW5maXguKFxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgPj58IGZ1biB0cmVlIC0+IHsgY29tcGFyYXRvcjsgdHJlZSB9KVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2xpc3QgbCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9zZXF1ZW5jZSBzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2FycmF5IH5jb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgeHMgPVxuICAgIFRyZWUwLnN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAubWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIHsgY29tcGFyYXRvclxuICAgIDsgdHJlZSA9IFRyZWUwLmZpbHRlcl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIH1cbiAgOztcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG50eXBlICgnZWx0LCAnY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSAnZWx0IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG5cbmxldCB0b19jb21wYXJhdG9yICh0eXBlIGVsdCBjbXApICgobW9kdWxlIE0pIDogKGVsdCwgY21wKSBjb21wYXJhdG9yKSA9IE0uY29tcGFyYXRvclxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCB1bmlvbl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB+bGVuIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2Zfc2VxdWVuY2UgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBzdGFibGVfZGVkdXBfbGlzdCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBtYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxubGV0IGZpbHRlcl9tYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbmxldCB0b190cmVlID0gVXNpbmdfY29tcGFyYXRvci50b190cmVlXG5sZXQgb2ZfdHJlZSBtIHQgPSBVc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdFxuXG5tb2R1bGUgTSAoRWx0IDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IChFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIHRcbjs7XG5cbmxldCBtX190X29mX3NleHBcbiAgICAgICh0eXBlIGVsdCBjbXApXG4gICAgICAobW9kdWxlIEVsdCA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGVsdCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOkVsdC5jb21wYXJhdG9yIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdClcbiAgOiAoZWx0LCBfKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAobGlzdF9zZXhwX2dyYW1tYXIgRWx0LnRfc2V4cF9ncmFtbWFyKVxuOztcblxubGV0IGNvbXBhcmVfbV9fdCAobW9kdWxlIF8gOiBDb21wYXJlX20pIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubGV0IGhhc2hfZm9sZF9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGVsdCkgc3RhdGUgPVxuICBoYXNoX2ZvbGRfZGlyZWN0IEVsdC5oYXNoX2ZvbGRfdCBzdGF0ZVxuOztcblxubGV0IGhhc2hfbV9fdCBmb2xkZXIgdCA9XG4gIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9tX190IGZvbGRlciAoSGFzaC5jcmVhdGUgKCkpIHQgaW5cbiAgSGFzaC5nZXRfaGFzaF92YWx1ZSBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG4gIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSBzZXQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICdlbHQgdCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgJ2VsdCB0cmVlID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgdHJlZVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvclxuXG4gIGluY2x1ZGUgVXNpbmdfY29tcGFyYXRvci5FbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChDb21wYXJhdG9yLlBvbHkpXG5cbiAgbGV0IHNpbmdsZXRvbiBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3IgYVxuICBsZXQgdW5pb25fbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci51bmlvbl9saXN0IH5jb21wYXJhdG9yIGFcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2Zfc2VxdWVuY2UgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYXJyYXkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgbWFwIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcCB+Y29tcGFyYXRvciBhIH5mXG4gIGxldCBmaWx0ZXJfbWFwIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLmZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgb2ZfdHJlZSB0cmVlID0geyBjb21wYXJhdG9yOyB0cmVlIH1cbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjY3MjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9FeG4iLCJCYXNlX0xpc3QiLCJCYXNlX0ltcG9ydCIsImNvbXBhcmUiLCJlcXVhbCIsImdsb2JhbGl6ZSIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsInRfc2V4cF9ncmFtbWFyIiwiYV9zZXhwX2dyYW1tYXIiLCJzd2FwIiwidDEiLCJ0MiIsInRtcCIsInJlcGxhY2UiLCJ0Iiwic2V0X3RlbXBvcmFyaWx5IiwiYSIsInJlc3RvcmVfdG8iLCJwYXJhbSIsInNldCIsInIiLCJzZXRzIiwidHMiLCJzbmFwc2hvdCIsInNldHNfdGVtcG9yYXJpbHkiLCJhbmRfdmFsdWVzIiwiQmFzZV9SZWYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9yZWYubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLFlBQUFDLGVBQUFDO0FBQUFBLElDbUI0QixtREFBaUM7QUFBQTtBQUFBLFlBQUFDLEtBQUFDLElBQUFDO0FBQUFBLFFBQUFDLE1BK0IzRDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUE7QUFBQSxHQUFTO0FBQUEsWUFBQUMsUUFBQUMsR0FBQXBCLEdBR1ksNEJBQUk7QUFBQSxZQUFBcUIsZ0JBQUFELEdBQUFFLEdBQUF0QjtBQUFBQSxRQUFBdUIsYUFHekI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLHVDQUFBQyxPQUFtQyw0QkFBZSxFQUFDO0FBQUE7QUFBQSxZQUFBQyxJQUFBRCxXQUFBRixJQU0zQyxVQUFBSSxJQUFBLFVBQWEsbUJBQU07QUFBQSxZQUFBQyxLQUFBQyxJQUNiLHlDQUFtQjtBQUFBLFlBQUFDLFNBQUFMLFdBQUFFLElBQ3BCLFVBQWEsb0JBQVM7QUFBQSxZQUFBSSxpQkFBQUMsWUFBQS9CO0FBQUFBLFFBQUF1QixhQUNoQjtBQUFBLElBS25CO0FBQUEsSUFBeUI7QUFBQSx1Q0FBQUMsT0FDVSx1QkFBeUIsR0FBQztBQUFBO0FBQUE7QUFBQSxJQUFBUTtBQUFBQSxNRDNFL0QiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbnN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSByZWYgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9yZWZcbiAgbGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9IGVxdWFsX3JlZlxuXG4gIGxldCBnbG9iYWxpemUgOiAnYS4gKCgnYVtAb2NhbWwubG9jYWxdKSAtPiAnYSkgLT4gKCdhIHRbQG9jYW1sLmxvY2FsXSkgLT4gJ2EgdCA9XG4gICAgZnVuICh0eXBlIGFfXzAwOV8pXG4gICAgICAgIDogKCgoYV9fMDA5X1tAb2NhbWwubG9jYWxdKSAtPiBhX18wMDlfKSAtPiAoYV9fMDA5XyB0W0BvY2FtbC5sb2NhbF0pIC0+IGFfXzAwOV8gdCkgLT5cbiAgICAgIGdsb2JhbGl6ZV9yZWZcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gcmVmX29mX3NleHBcbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfcmVmXG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IHJlZl9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmQgOlxuc2lnXG4gIHR5cGUgJ2EgdCA9ICdhIHJlZiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIGdsb2JhbGl6ZSA6ICgoJ2FbQG9jYW1sLmxvY2FsXSkgLT4gJ2EpIC0+ICgnYSB0W0BvY2FtbC5sb2NhbF0pIC0+ICdhIHRcblxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZClcblxuKCogSW4gdGhlIGRlZmluaXRpb24gb2YgW3RdLCB3ZSBkbyBub3QgaGF2ZSBbW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1dIGJlY2F1c2VcbiAgIGluIGdlbmVyYWwsIHN5bnRheCBleHRlbnNpb25zIHRlbmQgdG8gdXNlIHRoZSBpbXBsZW1lbnRhdGlvbiB3aGVuIGF2YWlsYWJsZSByYXRoZXIgdGhhblxuICAgdXNpbmcgdGhlIGFsaWFzLiAgSGVyZSB0aGF0IHdvdWxkIGxlYWQgdG8gdXNlIHRoZSByZWNvcmQgcmVwcmVzZW50YXRpb24gWyB7IG11dGFibGVcbiAgIGNvbnRlbnRzIDogJ2EgfSBdIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBkaWZmZXJlbnQgKGFuZCB1bndhbnRlZCkgYmVoYXZpb3IuICAqKVxudHlwZSAnYSB0ID0gJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG5leHRlcm5hbCBjcmVhdGUgOiAnYSAtPiAoJ2EgdFtAbG9jYWxfb3B0XSkgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICgnYSB0W0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAoJ2EgdFtAbG9jYWxfb3B0XSkgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbmxldCBzd2FwIHQxIHQyID1cbiAgbGV0IHRtcCA9ICF0MSBpblxuICB0MSA6PSAhdDI7XG4gIHQyIDo9IHRtcFxuOztcblxubGV0IHJlcGxhY2UgdCBmID0gdCA6PSBmICF0XG5cbmxldCBzZXRfdGVtcG9yYXJpbHkgdCBhIH5mID1cbiAgbGV0IHJlc3RvcmVfdG8gPSAhdCBpblxuICB0IDo9IGE7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gdCA6PSByZXN0b3JlX3RvKVxuOztcblxubW9kdWxlIEFuZF92YWx1ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBUIDogJ2EgcmVmICogJ2EgLT4gdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBzZXQgKFQgKHIsIGEpKSA9IHIgOj0gYVxuICBsZXQgc2V0cyB0cyA9IExpc3QuaXRlciB0cyB+ZjpzZXRcbiAgbGV0IHNuYXBzaG90IChUIChyLCBfKSkgPSBUIChyLCAhcilcbiAgbGV0IHNuYXBzaG90cyB0cyA9IExpc3QubWFwIHRzIH5mOnNuYXBzaG90XG5lbmRcblxubGV0IHNldHNfdGVtcG9yYXJpbHkgYW5kX3ZhbHVlcyB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gQW5kX3ZhbHVlLnNuYXBzaG90cyBhbmRfdmFsdWVzIGluXG4gIEFuZF92YWx1ZS5zZXRzIGFuZF92YWx1ZXM7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gQW5kX3ZhbHVlLnNldHMgcmVzdG9yZV90bylcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjY3OTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9RdWV1ZV9pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxrQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2ODAzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9sZW5ndGgiLCJjc3Rfc3JjX3F1ZXVlX21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJCYXNlX0xpc3QiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJCYXNlX0ltcG9ydCIsIkJhc2VfT3B0aW9uX2FycmF5IiwiQmFzZV9BcnJheSIsIkJhc2VfSW50IiwiQmFzZV9TZXhwIiwiQmFzZV9FcnJvciIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX1F1ZXVlIiwiQmFzZV9JbmRleGVkX2NvbnRhaW5lciIsImNzdF9pbmRleCIsImNzdF9RdWV1ZV9pbmRleF9vdXRfb2ZfYm91bmRzIiwiY3N0X211dGF0aW9uX29mX3F1ZXVlX2R1cmluZ19pIiwiY3N0X2NhcGFjaXR5IiwiY3N0X2Nhbm5vdF9oYXZlX3F1ZXVlX3dpdGhfbmVnIiwiY3N0X1F1ZXVlX2JsaXRfdHJhbnNmZXJfbmVnYXRpIiwiZHVtbXkiLCJpbmNfbnVtX211dGF0aW9ucyIsInQiLCJjYXBhY2l0eSIsImVsdHNfaW5kZXgiLCJpIiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXQiLCJhIiwiY2hlY2tfaW5kZXhfZXhuIiwiZ2V0Iiwic2V0IiwiaXNfZW1wdHkiLCJsZW5ndGgiLCJwYXJhbSIsImVuc3VyZV9ub19tdXRhdGlvbiIsIm51bV9tdXRhdGlvbnMiLCJvZl9hXzAwMSIsIm51bV9tdXRhdGlvbnNfMDAzIiwiZnJvbnRfMDA1IiwibWFza18wMDciLCJsZW5ndGhfMDA5IiwiZWx0c18wMTEiLCJhcmdfMDEyIiwiYm5kc18wMDIiLCJhcmdfMDEwIiwiYXJnXzAwOCIsImFyZ18wMDYiLCJhcmdfMDA0IiwiY29tcGFyZSIsImNvbXBhcmVfZWx0IiwidDEiLCJ0MiIsIm11dDIiLCJtdXQxIiwibGVuMiIsImxlbjEiLCJwb3MiLCJtYXRjaCIsIngiLCJlcXVhbCIsImVxdWFsX2VsdCIsImIiLCJpbnZhcmlhbnQiLCJpbnZhcmlhbnRfYSIsImZyb250IiwiZWx0cyIsImNyZWF0ZSIsImJsaXRfdG9fYXJyYXkiLCJzcmMiLCJkc3QiLCJmcm9udF9sZW4iLCJyZXN0X2xlbiIsInNldF9jYXBhY2l0eV9pbnRlcm5hbCIsIm5ld19jYXBhY2l0eSIsInNldF9jYXBhY2l0eSIsImRlc2lyZWRfY2FwYWNpdHkiLCJlbnF1ZXVlIiwiZGVxdWV1ZV9ub25lbXB0eSIsInJlcyIsImRlcXVldWVfZXhuIiwiZGVxdWV1ZSIsImRlcXVldWVfYW5kX2lnbm9yZV9leG4iLCJmcm9udF9ub25lbXB0eSIsImxhc3Rfbm9uZW1wdHkiLCJwZWVrIiwicGVla19leG4iLCJsYXN0IiwibGFzdF9leG4iLCJjbGVhciIsImJsaXRfdHJhbnNmZXIiLCJsZW4iLCJkc3Rfc3RhcnQiLCJzcmNfaSIsImRzdF9pIiwiZW5xdWV1ZV9hbGwiLCJsIiwiZm9sZCIsImluaXQiLCJyIiwiZm9sZGkiLCJhY2MiLCJpdGVyIiwiaXRlcmkiLCJ0b19saXN0IiwicmVzdWx0IiwiQyIsImNvdW50IiwiZXhpc3RzIiwiZmluZCIsImZpbmRfbWFwIiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZm9yX2FsbCIsIm1heF9lbHQiLCJtZW0iLCJtaW5fZWx0Iiwic3VtIiwiY291bnRpIiwiZXhpc3RzaSIsImZpbmRfbWFwaSIsImZpbmRpIiwiZm9yX2FsbGkiLCJjc3RfUXVldWVfaW5pdF9uZWdhdGl2ZV9sZW5ndGgiLCJjb25jYXRfbWFwIiwidF9yZXN1bHQiLCJjb25jYXRfbWFwaSIsImZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwaSIsImZpbHRlciIsImZpbHRlcmkiLCJmaWx0ZXJfaW5wbGFjZSIsImZpbHRlcmlfaW5wbGFjZSIsImNvcHkiLCJvZl9saXN0Iiwib2ZfYXJyYXkiLCJ0b19hcnJheSIsIm1hcCIsInRhIiwidGIiLCJtYXBpIiwic2luZ2xldG9uIiwic2V4cF9vZl90Iiwic2V4cF9vZl9hIiwidF9vZl9zZXhwIiwiYV9vZl9zZXhwIiwic2V4cCIsInRfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsIkJhc2VfUXVldWUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9xdWV1ZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsVUMwSUU7QUFBQTtB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KCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuXG4oKiBbdF0gc3RvcmVzIHRoZSBbdC5sZW5ndGhdIHF1ZXVlIGVsZW1lbnRzIGF0IGNvbnNlY3V0aXZlIGluY3JlYXNpbmcgaW5kaWNlcyBvZiBbdC5lbHRzXSxcbiAgIG1vZCB0aGUgY2FwYWNpdHkgb2YgW3RdLCB3aGljaCBpcyBbT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAgVGhlIGNhcGFjaXR5IGlzXG4gICByZXF1aXJlZCB0byBiZSBhIHBvd2VyIG9mIHR3byAodXNlci1yZXF1ZXN0ZWQgY2FwYWNpdGllcyBhcmUgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdFxuICAgcG93ZXIpLCBzbyB0aGF0IG1vZCBjYW4gcXVpY2tseSBiZSBjb21wdXRlZCB1c2luZyBbbGFuZCB0Lm1hc2tdLCB3aGVyZSBbdC5tYXNrID1cbiAgIGNhcGFjaXR5IHQgLSAxXS4gIFNvLCBxdWV1ZSBlbGVtZW50IFtpXSBpcyBhdCBbdC5lbHRzLiggKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFzayApXS5cblxuICAgW251bV9tdXRhdGlvbnNdIGlzIHVzZWQgdG8gZGV0ZWN0IG1vZGlmaWNhdGlvbiBkdXJpbmcgaXRlcmF0aW9uLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBtdXRhYmxlIG51bV9tdXRhdGlvbnMgOiBpbnRcbiAgOyBtdXRhYmxlIGZyb250IDogaW50XG4gIDsgbXV0YWJsZSBtYXNrIDogaW50XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxX1xuICAgIHsgbnVtX211dGF0aW9ucyA9IG51bV9tdXRhdGlvbnNfXzAwM19cbiAgICA7IGZyb250ID0gZnJvbnRfXzAwNV9cbiAgICA7IG1hc2sgPSBtYXNrX18wMDdfXG4gICAgOyBsZW5ndGggPSBsZW5ndGhfXzAwOV9cbiAgICA7IGVsdHMgPSBlbHRzX18wMTFfXG4gICAgfSAtPlxuICAgIGxldCBibmRzX18wMDJfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAxMl8gPSBPcHRpb25fYXJyYXkuc2V4cF9vZl90IF9vZl9hX18wMDFfIGVsdHNfXzAxMV8gaW5cbiAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJlbHRzXCI7IGFyZ19fMDEyXyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAxMF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwOV8gaW5cbiAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsZW5ndGhcIjsgYXJnX18wMTBfIF0gOjogYm5kc19fMDAyX1xuICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA4XyA9IHNleHBfb2ZfaW50IG1hc2tfXzAwN18gaW5cbiAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXNrXCI7IGFyZ19fMDA4XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAwNl8gPSBzZXhwX29mX2ludCBmcm9udF9fMDA1XyBpblxuICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImZyb250XCI7IGFyZ19fMDA2XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBudW1fbXV0YXRpb25zX18wMDNfIGluXG4gICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibnVtX211dGF0aW9uc1wiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubW9kdWxlIHR5cGUgUyA9IFF1ZXVlX2ludGYuU1xuXG5sZXQgaW5jX251bV9tdXRhdGlvbnMgdCA9IHQubnVtX211dGF0aW9ucyA8LSB0Lm51bV9tdXRhdGlvbnMgKyAxXG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcbmxldCBlbHRzX2luZGV4IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2tcbmxldCB1bnNhZmVfZ2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5sZXQgdW5zYWZlX2lzX3NldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX2lzX3NvbWUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfc2V0IHQgaSBhID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKSBhXG5sZXQgdW5zYWZlX3Vuc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcblxubGV0IGNoZWNrX2luZGV4X2V4biB0IGkgPVxuICBpZiBpIDwgMCB8fCBpID49IHQubGVuZ3RoXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlF1ZXVlIGluZGV4IG91dCBvZiBib3VuZHNcIlxuICAgICAgICAgWyBcImluZGV4XCIsIGkgfD4gSW50LnNleHBfb2ZfdDsgXCJsZW5ndGhcIiwgdC5sZW5ndGggfD4gSW50LnNleHBfb2ZfdCBdKVxuOztcblxubGV0IGdldCB0IGkgPVxuICBjaGVja19pbmRleF9leG4gdCBpO1xuICB1bnNhZmVfZ2V0IHQgaVxuOztcblxubGV0IHNldCB0IGkgYSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIHVuc2FmZV9zZXQgdCBpIGFcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gdC5sZW5ndGggPSAwXG5sZXQgbGVuZ3RoIHsgbGVuZ3RoOyBfIH0gPSBsZW5ndGhcblxubGV0IGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMgPVxuICBpZiB0Lm51bV9tdXRhdGlvbnMgPD4gbnVtX211dGF0aW9uc1xuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJtdXRhdGlvbiBvZiBxdWV1ZSBkdXJpbmcgaXRlcmF0aW9uXCJcbiAgICAgICAgIFsgXCJcIiwgdCB8PiBzZXhwX29mX3QgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgXSlcbjs7XG5cbmxldCBjb21wYXJlID1cbiAgbGV0IHJlYyB1bnNhZmVfY29tcGFyZV9mcm9tIGNvbXBhcmVfZWx0IHBvcyB+dDEgfnQyIH5sZW4xIH5sZW4yIH5tdXQxIH5tdXQyID1cbiAgICBtYXRjaCBwb3MgPSBsZW4xLCBwb3MgPSBsZW4yIHdpdGhcbiAgICB8IHRydWUsIHRydWUgLT4gMFxuICAgIHwgdHJ1ZSwgZmFsc2UgLT4gLTFcbiAgICB8IGZhbHNlLCB0cnVlIC0+IDFcbiAgICB8IGZhbHNlLCBmYWxzZSAtPlxuICAgICAgbGV0IHggPSBjb21wYXJlX2VsdCAodW5zYWZlX2dldCB0MSBwb3MpICh1bnNhZmVfZ2V0IHQyIHBvcykgaW5cbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgICAobWF0Y2ggeCB3aXRoXG4gICAgICAgfCAwIC0+IHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgKHBvcyArIDEpIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDJcbiAgICAgICB8IG4gLT4gbilcbiAgaW5cbiAgZnVuIGNvbXBhcmVfZWx0IHQxIHQyIC0+XG4gICAgaWYgcGh5c19lcXVhbCB0MSB0MlxuICAgIHRoZW4gMFxuICAgIGVsc2VcbiAgICAgIHVuc2FmZV9jb21wYXJlX2Zyb21cbiAgICAgICAgY29tcGFyZV9lbHRcbiAgICAgICAgMFxuICAgICAgICB+dDFcbiAgICAgICAgfnQyXG4gICAgICAgIH5sZW4xOnQxLmxlbmd0aFxuICAgICAgICB+bGVuMjp0Mi5sZW5ndGhcbiAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICB+bXV0Mjp0Mi5udW1fbXV0YXRpb25zXG47O1xuXG5sZXQgZXF1YWwgPVxuICBsZXQgcmVjIHVuc2FmZV9lcXVhbF9mcm9tIGVxdWFsX2VsdCBwb3MgfnQxIH50MiB+bXV0MSB+bXV0MiB+bGVuID1cbiAgICBwb3MgPSBsZW5cbiAgICB8fFxuICAgIGxldCBiID0gZXF1YWxfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MiBtdXQyO1xuICAgIGIgJiYgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IChwb3MgKyAxKSB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW5cbiAgaW5cbiAgZnVuIGVxdWFsX2VsdCB0MSB0MiAtPlxuICAgIHBoeXNfZXF1YWwgdDEgdDJcbiAgICB8fFxuICAgIGxldCBsZW4xID0gdDEubGVuZ3RoIGluXG4gICAgbGV0IGxlbjIgPSB0Mi5sZW5ndGggaW5cbiAgICBsZW4xID0gbGVuMlxuICAgICYmIHVuc2FmZV9lcXVhbF9mcm9tXG4gICAgICAgICBlcXVhbF9lbHRcbiAgICAgICAgIDBcbiAgICAgICAgIH50MVxuICAgICAgICAgfnQyXG4gICAgICAgICB+bGVuOmxlbjFcbiAgICAgICAgIH5tdXQxOnQxLm51bV9tdXRhdGlvbnNcbiAgICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIGxldCB7IG51bV9tdXRhdGlvbnM7IG1hc2sgPSBfOyBlbHRzOyBmcm9udDsgbGVuZ3RoIH0gPSB0IGluXG4gIGFzc2VydCAoZnJvbnQgPj0gMCk7XG4gIGFzc2VydCAoZnJvbnQgPCBjYXBhY2l0eSB0KTtcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHkgdCBpblxuICBhc3NlcnQgKGNhcGFjaXR5ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzKTtcbiAgYXNzZXJ0IChjYXBhY2l0eSA+PSAxKTtcbiAgYXNzZXJ0IChJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gIGFzc2VydCAobGVuZ3RoID49IDApO1xuICBhc3NlcnQgKGxlbmd0aCA8PSBjYXBhY2l0eSk7XG4gIGZvciBpID0gMCB0byBjYXBhY2l0eSAtIDEgZG9cbiAgICBpZiBpIDwgdC5sZW5ndGhcbiAgICB0aGVuIChcbiAgICAgIGludmFyaWFudF9hICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zKVxuICAgIGVsc2UgYXNzZXJ0IChub3QgKHVuc2FmZV9pc19zZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSA/Y2FwYWNpdHkgKCkgOiBhIHQgPVxuICBsZXQgY2FwYWNpdHkgPVxuICAgIG1hdGNoIGNhcGFjaXR5IHdpdGhcbiAgICB8IE5vbmUgLT4gMlxuICAgIHwgU29tZSBjYXBhY2l0eSAtPlxuICAgICAgaWYgY2FwYWNpdHkgPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJjYW5ub3QgaGF2ZSBxdWV1ZSB3aXRoIG5lZ2F0aXZlIGNhcGFjaXR5XCJcbiAgICAgICAgICAgICBbIFwiY2FwYWNpdHlcIiwgY2FwYWNpdHkgfD4gSW50LnNleHBfb2ZfdCBdKVxuICAgICAgZWxzZSBpZiBjYXBhY2l0eSA9IDBcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSBJbnQuY2VpbF9wb3cyIGNhcGFjaXR5XG4gIGluXG4gIHsgbnVtX211dGF0aW9ucyA9IDBcbiAgOyBmcm9udCA9IDBcbiAgOyBtYXNrID0gY2FwYWNpdHkgLSAxXG4gIDsgbGVuZ3RoID0gMFxuICA7IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46Y2FwYWNpdHlcbiAgfVxuOztcblxubGV0IGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QgPVxuICBhc3NlcnQgKHNyYy5sZW5ndGggPD0gT3B0aW9uX2FycmF5Lmxlbmd0aCBkc3QpO1xuICBsZXQgZnJvbnRfbGVuID0gSW50Lm1pbiBzcmMubGVuZ3RoIChjYXBhY2l0eSBzcmMgLSBzcmMuZnJvbnQpIGluXG4gIGxldCByZXN0X2xlbiA9IHNyYy5sZW5ndGggLSBmcm9udF9sZW4gaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfmxlbjpmcm9udF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczpzcmMuZnJvbnQgfmRzdCB+ZHN0X3BvczowO1xuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOnJlc3RfbGVuIH5zcmM6c3JjLmVsdHMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOmZyb250X2xlblxuOztcblxubGV0IHNldF9jYXBhY2l0eV9pbnRlcm5hbCB0IG5ld19jYXBhY2l0eSA9XG4gIGxldCBkc3QgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46bmV3X2NhcGFjaXR5IGluXG4gIGJsaXRfdG9fYXJyYXkgfnNyYzp0IGRzdDtcbiAgdC5mcm9udCA8LSAwO1xuICB0Lm1hc2sgPC0gbmV3X2NhcGFjaXR5IC0gMTtcbiAgdC5lbHRzIDwtIGRzdFxuOztcblxubGV0IHNldF9jYXBhY2l0eSB0IGRlc2lyZWRfY2FwYWNpdHkgPVxuICAoKiBXZSBhbGxvdyBhcmd1bWVudHMgbGVzcyB0aGFuIDEgdG8gW3NldF9jYXBhY2l0eV0sIGJ1dCB0cmFuc2xhdGUgdGhlbSB0byAxIHRvIHNpbXBsaWZ5XG4gICAgIHRoZSBjb2RlIHRoYXQgcmVsaWVzIG9uIHRoZSBhcnJheSBsZW5ndGggYmVpbmcgYSBwb3dlciBvZiAyLiAqKVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgbmV3X2NhcGFjaXR5ID0gSW50LmNlaWxfcG93MiAobWF4IDEgKG1heCBkZXNpcmVkX2NhcGFjaXR5IHQubGVuZ3RoKSkgaW5cbiAgaWYgbmV3X2NhcGFjaXR5IDw+IGNhcGFjaXR5IHQgdGhlbiBzZXRfY2FwYWNpdHlfaW50ZXJuYWwgdCBuZXdfY2FwYWNpdHlcbjs7XG5cbmxldCBlbnF1ZXVlIHQgYSA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID0gY2FwYWNpdHkgdCB0aGVuIHNldF9jYXBhY2l0eV9pbnRlcm5hbCB0ICgyICogdC5sZW5ndGgpO1xuICB1bnNhZmVfc2V0IHQgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgZGVxdWV1ZV9ub25lbXB0eSB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgbGV0IGVsdHMgPSB0LmVsdHMgaW5cbiAgbGV0IGZyb250ID0gdC5mcm9udCBpblxuICBsZXQgcmVzID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGZyb250IGluXG4gIE9wdGlvbl9hcnJheS5zZXRfbm9uZSBlbHRzIGZyb250O1xuICB0LmZyb250IDwtIGVsdHNfaW5kZXggdCAxO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gIHJlc1xuOztcblxubGV0IGRlcXVldWVfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgU3RkbGliLlF1ZXVlLkVtcHR5IGVsc2UgZGVxdWV1ZV9ub25lbXB0eSB0XG5sZXQgZGVxdWV1ZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChkZXF1ZXVlX25vbmVtcHR5IHQpXG5sZXQgZGVxdWV1ZV9hbmRfaWdub3JlX2V4biAodHlwZSBlbHQpICh0IDogZWx0IHQpID0gaWdub3JlIChkZXF1ZXVlX2V4biB0IDogZWx0KVxubGV0IGZyb250X25vbmVtcHR5IHQgPSBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biB0LmVsdHMgdC5mcm9udFxubGV0IGxhc3Rfbm9uZW1wdHkgdCA9IHVuc2FmZV9nZXQgdCAodC5sZW5ndGggLSAxKVxubGV0IHBlZWsgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZnJvbnRfbm9uZW1wdHkgdClcbmxldCBwZWVrX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIFN0ZGxpYi5RdWV1ZS5FbXB0eSBlbHNlIGZyb250X25vbmVtcHR5IHRcbmxldCBsYXN0IHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGxhc3Rfbm9uZW1wdHkgdClcbmxldCBsYXN0X2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIFN0ZGxpYi5RdWV1ZS5FbXB0eSBlbHNlIGxhc3Rfbm9uZW1wdHkgdFxuXG5sZXQgY2xlYXIgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICB1bnNhZmVfdW5zZXQgdCBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwO1xuICAgIHQuZnJvbnQgPC0gMClcbjs7XG5cbmxldCBibGl0X3RyYW5zZmVyIH5zcmMgfmRzdCA/bGVuICgpID1cbiAgaW5jX251bV9tdXRhdGlvbnMgc3JjO1xuICBpbmNfbnVtX211dGF0aW9ucyBkc3Q7XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IHNyYy5sZW5ndGhcbiAgICB8IFNvbWUgbGVuIC0+XG4gICAgICBpZiBsZW4gPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJRdWV1ZS5ibGl0X3RyYW5zZmVyOiBuZWdhdGl2ZSBsZW5ndGhcIlxuICAgICAgICAgICAgIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gICAgICBtaW4gbGVuIHNyYy5sZW5ndGhcbiAgaW5cbiAgaWYgbGVuID4gMFxuICB0aGVuIChcbiAgICBzZXRfY2FwYWNpdHkgZHN0IChtYXggKGNhcGFjaXR5IGRzdCkgKGRzdC5sZW5ndGggKyBsZW4pKTtcbiAgICBsZXQgZHN0X3N0YXJ0ID0gZHN0LmZyb250ICsgZHN0Lmxlbmd0aCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAoKiBUaGlzIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gc2ltcGx5IFtlbnF1ZXVlIGRzdCAoZGVxdWV1ZV9ub25lbXB0eSBzcmMpXSAqKVxuICAgICAgbGV0IHNyY19pID0gKHNyYy5mcm9udCArIGkpIGxhbmQgc3JjLm1hc2sgaW5cbiAgICAgIGxldCBkc3RfaSA9IChkc3Rfc3RhcnQgKyBpKSBsYW5kIGRzdC5tYXNrIGluXG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lXG4gICAgICAgIGRzdC5lbHRzXG4gICAgICAgIGRzdF9pXG4gICAgICAgIChPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biBzcmMuZWx0cyBzcmNfaSk7XG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIHNyYy5lbHRzIHNyY19pXG4gICAgZG9uZTtcbiAgICBkc3QubGVuZ3RoIDwtIGRzdC5sZW5ndGggKyBsZW47XG4gICAgc3JjLmZyb250IDwtIChzcmMuZnJvbnQgKyBsZW4pIGxhbmQgc3JjLm1hc2s7XG4gICAgc3JjLmxlbmd0aCA8LSBzcmMubGVuZ3RoIC0gbGVuKVxuOztcblxubGV0IGVucXVldWVfYWxsIHQgbCA9XG4gICgqIFRyYXZlcnNpbmcgdGhlIGxpc3QgdXAgZnJvbnQgdG8gY29tcHV0ZSBpdHMgbGVuZ3RoIGlzIHByb2JhYmx5IChidXQgbm90IGRlZmluaXRlbHkpXG4gICAgIGJldHRlciB0aGFuIGRvdWJsaW5nIHRoZSB1bmRlcmx5aW5nIGFycmF5IHNpemUgc2V2ZXJhbCB0aW1lcyBmb3IgbGFyZ2UgcXVldWVzLiAqKVxuICBzZXRfY2FwYWNpdHkgdCAoSW50Lm1heCAoY2FwYWNpdHkgdCkgKHQubGVuZ3RoICsgTGlzdC5sZW5ndGggbCkpO1xuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICAgIGxldCByID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgICBkb25lO1xuICAgICFyKVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBhIC0+XG4gICAgbGV0IGFjYyA9IGYgIWkgYWNjIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICBhY2MpIFtAbm9udGFpbF1cbjs7XG5cblxuKCogW2l0ZXJdIGlzIGltcGxlbWVudGVkIGRpcmVjdGx5IGJlY2F1c2UgaW1wbGVtZW50aW5nIGl0IGluIHRlcm1zIG9mIFtmb2xkXSBpc1xuICAgc2xvd2VyLiAqKVxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gIGRvbmVcbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBsZXQgcmVzdWx0ID0gcmVmIFtdIGluXG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgcmVzdWx0IDo9IHVuc2FmZV9nZXQgdCBpIDo6ICFyZXN1bHRcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubW9kdWxlIEMgPSBJbmRleGVkX2NvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gICAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuICBlbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5cblxuKCogRm9yIFtjb25jYXRfbWFwXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl0sIHdlIGRvbid0IGNyZWF0ZSBbdF9yZXN1bHRdIHdpdGggW3RdJ3NcbiAgIGNhcGFjaXR5IGJlY2F1c2Ugd2UgaGF2ZSBubyBpZGVhIGhvdyBtYW55IGVsZW1lbnRzIFt0X3Jlc3VsdF0gd2lsbCB1bHRpbWF0ZWx5IGhvbGQuICopXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgdF9yZXN1bHQgYikpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSB0X3Jlc3VsdCBhKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlciB0IH5mIGluXG4gIGNsZWFyIHQ7XG4gIGJsaXRfdHJhbnNmZXIgfnNyYzp0MiB+ZHN0OnQgKClcbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlcmkgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgY29weSBzcmMgPVxuICBsZXQgZHN0ID0gY3JlYXRlIH5jYXBhY2l0eTpzcmMubGVuZ3RoICgpIGluXG4gIGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QuZWx0cztcbiAgZHN0Lmxlbmd0aCA8LSBzcmMubGVuZ3RoO1xuICBkc3Rcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICAoKiBUcmF2ZXJzaW5nIHRoZSBsaXN0IHVwIGZyb250IHRvIGNvbXB1dGUgaXRzIGxlbmd0aCBpcyBwcm9iYWJseSAoYnV0IG5vdCBkZWZpbml0ZWx5KVxuICAgICBiZXR0ZXIgdGhhbiBkb3VibGluZyB0aGUgdW5kZXJseWluZyBhcnJheSBzaXplIHNldmVyYWwgdGltZXMgZm9yIGxhcmdlIHF1ZXVlcy4gKilcbiAgbGV0IHQgPSBjcmVhdGUgfmNhcGFjaXR5OihMaXN0Lmxlbmd0aCBsKSAoKSBpblxuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG4oKiBUaGUgcXVldWUgW3RdIHJldHVybmVkIGJ5IFtjcmVhdGVdIHdpbGwgaGF2ZSBbdC5sZW5ndGggPSAwXSwgW3QuZnJvbnQgPSAwXSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IEludC5jZWlsX3BvdzIgbGVuXS4gIFNvLCB3ZSBvbmx5IGhhdmUgdG8gc2V0IFt0Lmxlbmd0aF0gdG8gW2xlbl0gYWZ0ZXJcbiAgIHRoZSBibGl0IHRvIG1haW50YWluIGFsbCB0aGUgaW52YXJpYW50czogW3QubGVuZ3RoXSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICBpbiB0aGUgcXVldWUsIFt0LmZyb250XSBpcyB0aGUgYXJyYXkgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHF1ZXVlLCBhbmRcbiAgIFtjYXBhY2l0eSB0ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAqKVxubGV0IGluaXQgbGVuIH5mID1cbiAgaWYgbGVuIDwgMFxuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIlF1ZXVlLmluaXQ6IG5lZ2F0aXZlIGxlbmd0aFwiIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTpsZW4gKCkgaW5cbiAgYXNzZXJ0IChPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyA+PSBsZW4pO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdC5lbHRzIGkgKGYgaSlcbiAgZG9uZTtcbiAgdC5sZW5ndGggPC0gbGVuO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhKSB+ZjooQXJyYXkudW5zYWZlX2dldCBhKVxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IHQubGVuZ3RoIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IG1hcCB0YSB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdGEubnVtX211dGF0aW9ucyBpblxuICBsZXQgdGIgPSBjcmVhdGUgfmNhcGFjaXR5OnRhLmxlbmd0aCAoKSBpblxuICB0Yi5sZW5ndGggPC0gdGEubGVuZ3RoO1xuICBmb3IgaSA9IDAgdG8gdGEubGVuZ3RoIC0gMSBkb1xuICAgIGxldCBiID0gZiAodW5zYWZlX2dldCB0YSBpKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0YSBudW1fbXV0YXRpb25zO1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdGIuZWx0cyBpIGJcbiAgZG9uZTtcbiAgdGJcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIG1hcCB0IH5mOihmdW4gYSAtPlxuICAgIGxldCByZXN1bHQgPSBmICFpIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICByZXN1bHQpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eToxICgpIGluXG4gIGVucXVldWUgdCB4O1xuICB0XG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gdG9fbGlzdCB0IHw+IExpc3Quc2V4cF9vZl90IHNleHBfb2ZfYVxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IExpc3QudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwIHw+IG9mX2xpc3RcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NTI0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsInRfc2V4cF9ncmFtbWFyIiwibW9kdWxlX25hbWUiLCJCYXNlX0ltcG9ydCIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsIk1hdGNoX2ZhaWx1cmUiLCJCYXNlX0lkZW50aWZpYWJsZSIsInVucmVhY2hhYmxlX2NvZGUiLCJwYXJhbSIsImNzdF9CYXNlX05vdGhpbmdfdCIsImNzdF9CYXNlX05vdGhpbmdfb2Zfc3RyaW5nX25vdCIsImhhc2hfZm9sZF90IiwidCIsImNvbXBhcmUiLCJhIiwidF9vZl9zZXhwIiwic2V4cCIsIm9mX3N0cmluZyIsImluY2x1ZGUiLCJoYXNoIiwic2V4cF9vZl90IiwidG9fc3RyaW5nIiwic3ltYm9sIiwiZXF1YWwiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsInBwIiwiaGFzaGFibGUiLCJCYXNlX05vdGhpbmciXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9ub3RoaW5nLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUE7QUFBQSxZQUFBQyxpQkFBQUM7QUFBQUEsSUNLeUI7QUFBQSxHQUNQO0FBQUE7QUFBQSxJQUFBQyxxQkRObEI7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLFlBQUFDLFlBQUFILE9BQUFJLEdDVXdCLDBCQUFrQjtBQUFBLFlBQUFDLFFBQUFDLEdBQUFOLE9BRXRCLDBCQUFrQjtBQUFBLFlBQUFPLFVBQUFDO0FBQUFBLElBRWYseUVBQXlEO0FBQUE7QUFBQSxZQUFBQyxVQUFBVDtBQUFBQSxJQUdqRCxtRUFBZ0Q7QUFBQTtBQUFBO0FBQUEsSUFBQVU7QUFBQUEsTURqQi9FO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBUCxnQkFBQTtBQUFBLElBQUFRLE9BQUE7QUFBQSxJQUFBSixjQUFBO0FBQUEsSUFBQUssWUFBQTtBQUFBLElBQUFILGNBQUE7QUFBQSxJQUFBSSxZQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFWLFlBQUE7QUFBQSxJQUFBVyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHxcblxuICBsZXQgdW5yZWFjaGFibGVfY29kZSA9IGZ1bmN0aW9uXG4gICAgfCAoXyA6IHQpIC0+IC5cbiAgOztcblxuICBsZXQgYWxsID0gW11cbiAgbGV0IGhhc2hfZm9sZF90IF8gdCA9IHVucmVhY2hhYmxlX2NvZGUgdFxuICBsZXQgaGFzaCA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IGNvbXBhcmUgYSBfID0gdW5yZWFjaGFibGVfY29kZSBhXG4gIGxldCBzZXhwX29mX3QgPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCB0X29mX3NleHAgc2V4cCA9IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV90eXBlIFwiQmFzZS5Ob3RoaW5nLnRcIiBzZXhwXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbiAgbGV0IHRvX3N0cmluZyA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IG9mX3N0cmluZyAoXyA6IHN0cmluZykgPSBmYWlsd2l0aCBcIkJhc2UuTm90aGluZy5vZl9zdHJpbmc6IG5vdCBzdXBwb3J0ZWRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Ob3RoaW5nXCJcbiAgZW5kKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NjM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9ueCIsImNzdF9hcmd1bWVudF9tdXN0X2JlX3N0cmljdGx5XyIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwibW9kdWxlX25hbWUiLCJCYXNlX0ludF9tYXRoIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfTmF0aXZlaW50IiwiQmFzZV9QcmludGYiLCJCYXNlX0Zsb2F0MCIsIlN0ZGxpYl9TY2FuZiIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfQ29tcGFyYWJsZSIsIkJhc2VfSW50X2NvbnZlcnNpb25zIiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsIkJhc2VfV29yZF9zaXplIiwiQmFzZV9FcnJvciIsIkJhc2VfUG9wY291bnQiLCJpbmNsdWRlIiwiY29tcGFyZSIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJoYXNoYWJsZSIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJjb21wYXJhdG9yIiwiemVybyIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwidG9fc3RyaW5nX2h1bSIsIm5lZyIsInN5bWJvbCIsImkiLCJzIiwiSGV4IiwicHAiLCJpbnZhcmlhbnQiLCJwYXJhbSIsIm51bV9iaXRzIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJzaGlmdF9yaWdodCIsInNoaWZ0X2xlZnQiLCJiaXRfbm90IiwiYml0X3hvciIsImJpdF9vciIsImJpdF9hbmQiLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJhYnMiLCJwcmVkIiwic3VjYyIsInJlbSIsIm1pbnVzX29uZSIsIm9uZSIsInRvX2Zsb2F0Iiwib2ZfZmxvYXRfdW5jaGVja2VkIiwib2ZfZmxvYXQiLCJyYWlzZV9zIiwiY3N0X05hdGl2ZWludF9mbG9vcl9sb2cyX2dvdF9pIiwiY3N0X05hdGl2ZWludF9jZWlsX2xvZzJfZ290X2luIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImNlaWxfcG93MiIsImZsb29yX3BvdzIiLCJpc19wb3cyIiwiZmxvb3JfbG9nMiIsImNlaWxfbG9nMiIsImJldHdlZW4iLCJ0IiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsIm1pbiIsIm1heCIsImNsYW1wX2V4biIsImNsYW1wIiwiaW5jciIsInIiLCJkZWNyIiwib2ZfbmF0aXZlaW50IiwidG9fbmF0aXZlaW50IiwicG9wY291bnQiLCJvZl9pbnRfZXhuIiwidG9faW50IiwidG9faW50X2V4biIsInRvX2ludF90cnVuYyIsIm9mX2ludDMyIiwidG9faW50MzIiLCJ0b19pbnQzMl9leG4iLCJ0b19pbnQzMl90cnVuYyIsIm9mX2ludDY0Iiwib2ZfaW50NjRfZXhuIiwib2ZfaW50NjRfdHJ1bmMiLCJ0b19pbnQ2NCIsInBvdyIsImIiLCJlIiwicm91bmQiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJyb3VuZF9kb3duIiwicm91bmRfdXAiLCJyb3VuZF9uZWFyZXN0IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImVxdWFsIiwiQmFzZV9OYXRpdmVpbnQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9uYXRpdmVpbnQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEs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V0FBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQXZCO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUF1QixZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBc0UsUUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFqRyxZQUFBO0FBQUEsSUFBQXVCLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUEyRSxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFsRyxZQUFBO0FBQUEsSUFBQW1HLFFBQUE7QUFBQSxJQUFBL0IsTUFBQTtBQUFBLElBQUFELE1BQUE7QUFBQSxJQUFBaUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJEcEYzRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQ29GMkQ7QUFBQTtBQUFBLEVEcEYzRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5vcGVuISBTdGRsaWIuTmF0aXZlaW50XG5pbmNsdWRlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID1cbiAgICAoZ2xvYmFsaXplX25hdGl2ZWludCA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAobmF0aXZlaW50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX25hdGl2ZWludCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nX29wdCA9IG9mX3N0cmluZ19vcHRcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAgIHR5cGUgdCA9IG5hdGl2ZWludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfbmF0aXZlaW50IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9uYXRpdmVpbnQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9IG5lZ1xuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbnhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gU3RkbGliLlNjYW5mLnNzY2FuZiBzIFwiJW54XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50LkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50XCJcbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgbnVtX2JpdHMgPSBXb3JkX3NpemUubnVtX2JpdHMgV29yZF9zaXplLndvcmRfc2l6ZVxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IG9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIG9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiTmF0aXZlaW50Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gU3RkbGliLk5hdGl2ZWludC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IFN0ZGxpYi5OYXRpdmVpbnQuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBTdGRsaWIuTmF0aXZlaW50LmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiAoeCA6IG5hdGl2ZWludCkgPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBTdGRsaWIuTmF0aXZlaW50LnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgU3RkbGliLk5hdGl2ZWludC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBTdGRsaWIuTmF0aXZlaW50LnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIFN0ZGxpYi5OYXRpdmVpbnQucHJlZCB4ID0gMG5cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBuYXRpdmVpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHpcIiBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2Nsel91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBTdGRsaWIuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgU3RkbGliLk5hdGl2ZWludC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiW05hdGl2ZWludC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIGlmIFN0ZGxpYi5OYXRpdmVpbnQuZXF1YWwgaSBTdGRsaWIuTmF0aXZlaW50Lm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKFN0ZGxpYi5OYXRpdmVpbnQucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX25hdGl2ZWludCB0ID0gdFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgdCA9IHRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5uYXRpdmVpbnRfcG9wY291bnRcbmxldCBvZl9pbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgdG9faW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5sZXQgdG9faW50MzJfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl90cnVuY1xubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X3RydW5jXG5sZXQgdG9faW50NjQgPSBDb252Lm5hdGl2ZWludF90b19pbnQ2NFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW05hdGl2ZWludF0gYW5kIFtOYXRpdmVpbnQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5leHRlcm5hbCBic3dhcCA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVic3dhcF9uYXRpdmVcIlxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MDkyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9NYXBfYmFsIiwiY3N0X01hcF9vZiIsImNzdF9rZXkiLCJjc3Rfb2Zfc29ydGVkX2FycmF5X2R1cGxpY2F0ZWQiLCJjc3Rfc3JjX21hcF9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsImVtcHR5IiwibmFtZSIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciIsIkJhc2VfUmVzdWx0IiwiQmFzZV9Pcl9lcnJvciIsIkJhc2VfRXJyb3IiLCJCYXNlX09wdGlvbiIsIkJhc2VfSW1wb3J0IiwiQmFzZV9FeG4iLCJCYXNlX1NleHAiLCJCYXNlX0xpc3QwIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX1VuaWZvcm1fYXJyYXkiLCJCYXNlX1NlcXVlbmNlIiwiQmFzZV9NYXliZV9ib3VuZCIsIkJhc2VfTWFwX2ludGYiLCJCYXNlX1dpdGhfcmV0dXJuIiwiU2V4cGxpYjBfU2V4cF9jb252IiwiQmFzZV9Db21wYXJhdG9yIiwiU3ltbWV0cmljX2RpZmZfZWxlbWVudCIsImluY2x1ZGUiLCJjb21wYXJlIiwiYWxsIiwiZXF1YWwiLCJzZXhwX29mX3QiLCJvZl9jb250aW51ZV9vcl9zdG9wIiwidG9fY29udGludWVfb3Jfc3RvcCIsIkZpbmlzaGVkX29yX3VuZmluaXNoZWQiLCJsZWZ0IiwicGFyYW0iLCJyaWdodCIsImxlZnRfdmFsdWUiLCJ0IiwiZGVmYXVsdCIsInJpZ2h0X3ZhbHVlIiwidmFsdWVzIiwibGVmdF9kZWZhdWx0IiwicmlnaHRfZGVmYXVsdCIsIm1hdGNoIiwiTWVyZ2VfZWxlbWVudCIsIndpdGhfcmV0dXJuIiwiRHVwbGljYXRlIiwiY3N0X29mX3NvcnRlZF9hcnJheV9lbGVtZW50c19hIiwiZ2xvYmFsaXplIiwibGVuZ3RoIiwidHJlZSIsImhlaWdodCIsImgiLCJpbl9yYW5nZSIsImxvd2VyIiwidXBwZXIiLCJjb21wYXJlX2tleSIsImsiLCJsb29wIiwiciIsImwiLCJobCIsImhyIiwiaW52YXJpYW50cyIsImNyZWF0ZSIsIngiLCJkIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrIiwibGVuIiwibiIsImkiLCJ2IiwidmwiLCJrbCIsInZyIiwia3IiLCJsZWZ0X2xlbmd0aCIsInJpZ2h0X2xlbmd0aCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQiLCJhcnJheSIsImFycmF5X2xlbmd0aCIsImswIiwiazEiLCJuZXh0Iiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibGQiLCJsdiIsImxsIiwibHJkIiwibHJ2IiwibHJyIiwibHJsIiwicnIiLCJyZCIsInJ2IiwicmwiLCJybGQiLCJybHYiLCJybHIiLCJybGwiLCJlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW8iLCJjc3RfTWFwX2FkZF9leG5fZ290X2tleV9hbHJlYWQiLCJjc3RfTWFwX3NpbmdsZXRvbl90b190cmVlX2V4bl8iLCJjc3Rfb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZV9ub24iLCJpc19lbXB0eSIsInJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQiLCJrZXkiLCJzZXhwX29mX2tleSIsImZpbmRfYW5kX2FkZF9vcl9zZXQiLCJkYXRhIiwiYWRkX29yX3NldCIsImMiLCJzZXRfbWluIiwic2V0X21heCIsImFkZF9leG4iLCJhZGRfZXhuX2ludGVybmFsIiwic2V0Iiwic2luZ2xldG9uX3RvX3RyZWVfZXhuIiwiY29sbGFwc2UiLCJqb2luIiwiZ28iLCJ5IiwieiIsImFkZF91bmNoZWNrZWQiLCJ0b190cmVlX3VuY2hlY2tlZCIsIm1heF9rZXkiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIiwic2VxIiwiYnVpbGRlciIsInByZXZfa2V5IiwibGgiLCJsayIsInJrIiwicmgiLCJzcGxpdF9nZW4iLCJjbXAiLCJtYXliZSIsInNwbGl0Iiwic3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IiwiaW50byIsInJlcyIsImJvdW5kYXJ5X29wdCIsInNwbGl0X3JhbmdlIiwibG93ZXJfYm91bmQiLCJ1cHBlcl9ib3VuZCIsIm1pZF9hbmRfcmlnaHQiLCJsYiIsIm1pZCIsImZpbmQiLCJhZGRfbXVsdGkiLCJmaW5kX211bHRpIiwiaWZfbm90X2ZvdW5kIiwiZmluZF9leG4iLCJtZW0iLCJtaW5fZWx0IiwiTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCIsIk1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAiLCJjc3RfTWFwX3JlbW92ZV9taW5fZWx0IiwibWluX2VsdF9leG4iLCJtYXhfZWx0IiwibWF4X2VsdF9leG4iLCJyZW1vdmVfbWluX2VsdCIsImFwcGVuZCIsImxvd2VyX3BhcnQiLCJ1cHBlcl9wYXJ0IiwibWluX3VwcGVyIiwibWF4X2xvd2VyIiwidXBwZXJfcGFydF93aXRob3V0X21pbiIsIm1pbiIsIm1heCIsImluaXQiLCJjX21pbiIsImNfbWF4IiwiZm9sZF9yYW5nZV9pbmNsdXNpdmUiLCJyYW5nZV90b19hbGlzdCIsImNvbmNhdF91bmNoZWNrZWQiLCJ0MSIsInQyIiwiY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCIsIlJlbW92ZV9ub19vcCIsInJlbW92ZSIsInJlbW92ZV9sb29wIiwiQ2hhbmdlX25vX29wIiwiY3N0X29yX2Vycm9yX2R1cGxpY2F0ZV9rZXkiLCJjc3RfZXhuX2R1cGxpY2F0ZV9rZXkiLCJjaGFuZ2UiLCJjaGFuZ2VfY29yZSIsInVwZGF0ZSIsInVwZGF0ZV9jb3JlIiwicmVtb3ZlX211bHRpIiwibm9uX2VtcHR5X3RhaWwiLCJpdGVyX2tleXMiLCJpdGVyIiwiaXRlcmkiLCJpdGVyaV91bnRpbF9sb29wIiwiaXRlcmlfdW50aWwiLCJtYXAiLCJtYXBpIiwiZm9sZCIsImFjY3UiLCJmb2xkX3VudGlsIiwiZmluaXNoIiwiZm9sZF91bnRpbF9sb29wIiwiYWNjIiwiZmluYWwiLCJzdG9wIiwiZm9sZF9yaWdodCIsImZpbHRlcl9tYXBpIiwibmV3X2RhdGEiLCJmaWx0ZXJpIiwia2VlcF9kYXRhIiwiZmlsdGVyIiwiZmlsdGVyX2tleXMiLCJmaWx0ZXJfbWFwIiwicGFydGl0aW9uX21hcGkiLCJwYXJ0aXRpb25fbWFwIiwicGFydGl0aW9uaV90ZiIsImxfZiIsImxfdCIsImtlZXBfZGF0YV90Iiwicl9mIiwicl90IiwibWsiLCJwYXJ0aXRpb25fdGYiLCJjb25zIiwiZSIsImNvbnNfcmlnaHQiLCJvZl90cmVlIiwic3RlcF9kZWVwZXJfZXhuIiwiZHJvcF9waHlzX2VxdWFsX3ByZWZpeCIsInRyZWUxIiwiYWNjMSIsInRyZWUyIiwiYWNjMiIsImgyIiwiaDEiLCJlbnVtIiwiZm9sZDIiLCJjdXJyIiwiZW51bTIiLCJ2MiIsImsyIiwiZW51bTEiLCJ2MSIsImNvbXBhcmVfcmVzdWx0Iiwic3ltbWV0cmljX2RpZmYiLCJkYXRhX2VxdWFsIiwic3RlcCIsInN0YXRlIiwibmV4dF9zdGF0ZSIsInRvX3NlcXVlbmNlIiwiY29tcGFyYXRvciIsIm9wdCIsImtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byIsImtleXNfbGVzc19vcl9lcXVhbF90byIsIm9yZGVyIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsImJvdW5kIiwiY29tcGFyZV9kYXRhIiwiZTIiLCJlMSIsInIyIiwiZDIiLCJyMSIsImQxIiwiaXRlcjIiLCJmb2xkX3N5bW1ldHJpY19kaWZmIiwiYWRkIiwiZGVsdGEiLCJrZXlzIiwibGlzdCIsIm9mX2ZvbGRhYmxlIiwiZm9sZGFibGUiLCJhY2N1bSIsInByZXYiLCJwcmV2X2RhdGEiLCJPZl9mb2xkYWJsZSIsIk0iLCJvZl9mb2xkYWJsZV9mb2xkIiwib2ZfZm9sZGFibGVfcmVkdWNlIiwib2ZfZm9sZGFibGVfb3JfZXJyb3IiLCJvZl9mb2xkYWJsZV9leG4iLCJvZl9mb2xkYWJsZV9tdWx0aSIsImFsaXN0IiwiT2ZfYWxpc3QiLCJvZl9hbGlzdF9mb2xkIiwib2ZfYWxpc3RfcmVkdWNlIiwib2ZfYWxpc3QiLCJvZl9hbGlzdF9vcl9lcnJvciIsIm9mX2FsaXN0X2V4biIsIm9mX2FsaXN0X211bHRpIiwiT2Zfc2VxdWVuY2UiLCJvZl9zZXF1ZW5jZV9mb2xkIiwib2Zfc2VxdWVuY2VfcmVkdWNlIiwib2Zfc2VxdWVuY2UiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciIsIm9mX3NlcXVlbmNlX2V4biIsIm9mX3NlcXVlbmNlX211bHRpIiwiY3N0X01hcF9vZl9saXN0X3dpdGhfa2V5X29yX2VyIiwiY3N0X01hcF9vZl9saXN0X3dpdGhfa2V5X2V4bl9kIiwiY3N0X01hcF9vZl9pdGVyaV9leG5fZHVwbGljYXRlIiwiY3N0X01hcF90X29mX3NleHBfZGlyZWN0X2R1cGxpIiwiY3N0X01hcF9tYXBfa2V5c19leG5fZHVwbGljYXRlIiwiZHVtbXkiLCJvZl9saXN0X3dpdGhfa2V5IiwiZ2V0X2tleSIsIm5ld19sZW5ndGgiLCJvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIiwib2ZfbGlzdF93aXRoX2tleV9leG4iLCJvZl9saXN0X3dpdGhfa2V5X211bHRpIiwib3B0aW9uIiwiZm9yX2FsbCIsImZvcl9hbGxpIiwiZXhpc3RzIiwiZXhpc3RzaSIsImNvdW50IiwiY291bnRpIiwidG9fYWxpc3QiLCJrZXlfb3JkZXIiLCJtZXJnZSIsImVsdHMiLCJ2YWx1ZSIsImdldCIsIm1lcmdlX2xhcmdlX2ZpcnN0IiwibGVuZ3RoX2xhcmdlIiwidF9sYXJnZSIsInRfc21hbGwiLCJjYWxsIiwiY29tYmluZSIsInN3YXAiLCJtZXJnZV9za2V3ZWQiLCJsZW5ndGgxIiwibGVuZ3RoMiIsInJlcGFja2FnZSIsIm1hcmtlciIsImNsb3Nlc3Rfa2V5IiwiZGlyIiwiZm91bmRfbWFya2VyIiwiZm91bmRfa2V5IiwiZm91bmRfdmFsdWUiLCJyYW5rIiwibnRoIiwibnVtX3RvX3NlYXJjaCIsInNvbWUiLCJmaW5kX2ZpcnN0X3NhdGlzZnlpbmciLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJwYWlyIiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQiLCJzZWdtZW50X29mIiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwiYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmQiLCJtYXliZV9ib3VuZCIsImlmX2V4Y2x1c2l2ZSIsImlmX2luY2x1c2l2ZSIsImZpbmRfYm91bmQiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJvZl9pdGVyaSIsIm9mX2l0ZXJpX2V4biIsInRfb2Zfc2V4cF9kaXJlY3QiLCJrZXlfb2Zfc2V4cCIsInZhbHVlX29mX3NleHAiLCJzZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdmFsdWUiLCJjb21iaW5lX2Vycm9ycyIsImVycm9ycyIsIm9rcyIsIm1hcF9rZXlzIiwibWFwX2tleXNfZXhuIiwicmVzdWx0IiwidHJhbnNwb3NlX2tleXMiLCJvdXRlcl9jb21wYXJhdG9yIiwiaW5uZXJfY29tcGFyYXRvciIsIm91dGVyX3QiLCJvdXRlcl9rZXkiLCJpbm5lcl90IiwiaW5uZXJfa2V5IiwiYWNjX2xlbiIsImVsdF9sZW4iLCJlbHQiLCJNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMiLCJBIiwidHJlZV9maWx0ZXJfbWFwaSIsInJfbGVuIiwibF9sZW4iLCJsaWtlIiwibGlrZV9tYXliZV9ub19vcCIsIm9sZF90Iiwib2xkX3RyZWUiLCJ3aXRoX3NhbWVfbGVuZ3RoIiwib2ZfbGlrZV90cmVlIiwib2ZfbGlrZV90cmVlX21heWJlX25vX29wIiwidG9fdHJlZSIsIm9mX2xpa2VfdHJlZTIiLCJvZl9saWtlX3RyZWUyX21heWJlX25vX29wIiwiY29tcGFyZV9kaXJlY3QiLCJib3RoX2xlbiIsInNwbGl0X2xlX2d0Iiwic3BsaXRfbHRfZ2UiLCJzdWJyYW5nZSIsImhfbCIsImhfciIsIm91dGVyX2pvaW5lZF9oZWlnaHQiLCJtaWRfbGVuZ3RoIiwibnRoX2V4biIsInNleHBfb2ZfayIsInNleHBfb2ZfdiIsImhhc2hfZm9sZF9kaXJlY3QiLCJoYXNoX2ZvbGRfa2V5IiwiaGFzaF9mb2xkX2RhdGEiLCJiaW5hcnlfc2VhcmNoX3N1YnJhbmdlIiwiVHJlZV90cmF2ZXJzYWxzIiwibmV3X3RyZWUiLCJuZXdfdHJlZV93aXRoX2xlbmd0aCIsInNpbmdsZXRvbiIsInJlcXVpcmVkX2J5X2ludGYiLCJyZXQiLCJrX29mX3NleHAiLCJ2X29mX3NleHAiLCJkdXAiLCJCdWlsZF9pbmNyZWFzaW5nIiwib2ZfdHJlZTAiLCJ0cmVlX2xlbmd0aCIsIkVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsIksiLCJjb21wYXJhdG9yX3MiLCJtIiwiYSIsInMiLCJzZXhwX29mX21fdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsInZfZ3JhbW1hciIsImNvbXBhcmVfbV90IiwiY29tcGFyZV92IiwiZXF1YWxfbV90IiwiZXF1YWxfdiIsImhhc2hfZm9sZF9tX3QiLCJoYXNoX2ZvbGRfdiIsIkJhc2VfTWFwIiwiVHJlZTBfdHJhdmVyc2FscyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL21hcC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFB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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0Nza0RJO0FBQUE7QUFBQSxFRHRrREoiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gU2VlIC4uL1RISVJELVBBUlRZLnR4dCAgKilcbigqICBmb3IgZGV0YWlscy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIE1hcF9pbnRmXG5cbm1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkID0gc3RydWN0XG4gIGluY2x1ZGUgTWFwX2ludGYuRmluaXNoZWRfb3JfdW5maW5pc2hlZFxuXG4gICgqIFRoZXNlIHR3byBmdW5jdGlvbnMgYXJlIHRlc3RlZCBpbiBbdGVzdF9tYXAubWxdIHRvIG1ha2Ugc3VyZSBvdXIgdXNlIG9mXG4gICAgIFtTdGRsaWIuT2JqLm1hZ2ljXSBpcyBjb3JyZWN0IGFuZCBzYWZlLiAqKVxuICBsZXQgb2ZfY29udGludWVfb3Jfc3RvcCA6IENvbnRpbnVlX29yX3N0b3AudCAtPiB0ID0gU3RkbGliLk9iai5tYWdpY1xuICBsZXQgdG9fY29udGludWVfb3Jfc3RvcCA6IHQgLT4gQ29udGludWVfb3Jfc3RvcC50ID0gU3RkbGliLk9iai5tYWdpY1xuZW5kXG5cbm1vZHVsZSBNZXJnZV9lbGVtZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgTWFwX2ludGYuTWVyZ2VfZWxlbWVudFxuXG4gIGxldCBsZWZ0ID0gZnVuY3Rpb25cbiAgICB8IGBSaWdodCBfIC0+IE5vbmVcbiAgICB8IGBMZWZ0IGxlZnQgfCBgQm90aCAobGVmdCwgXykgLT4gU29tZSBsZWZ0XG4gIDs7XG5cbiAgbGV0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgIHwgYFJpZ2h0IHJpZ2h0IHwgYEJvdGggKF8sIHJpZ2h0KSAtPiBTb21lIHJpZ2h0XG4gIDs7XG5cbiAgbGV0IGxlZnRfdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgUmlnaHQgXyAtPiBkZWZhdWx0XG4gICAgfCBgTGVmdCBsZWZ0IHwgYEJvdGggKGxlZnQsIF8pIC0+IGxlZnRcbiAgOztcblxuICBsZXQgcmlnaHRfdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgTGVmdCBfIC0+IGRlZmF1bHRcbiAgICB8IGBSaWdodCByaWdodCB8IGBCb3RoIChfLCByaWdodCkgLT4gcmlnaHRcbiAgOztcblxuICBsZXQgdmFsdWVzIHQgfmxlZnRfZGVmYXVsdCB+cmlnaHRfZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgTGVmdCBsZWZ0IC0+IGxlZnQsIHJpZ2h0X2RlZmF1bHRcbiAgICB8IGBSaWdodCByaWdodCAtPiBsZWZ0X2RlZmF1bHQsIHJpZ2h0XG4gICAgfCBgQm90aCAobGVmdCwgcmlnaHQpIC0+IGxlZnQsIHJpZ2h0XG4gIDs7XG5lbmRcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxuZXhjZXB0aW9uIER1cGxpY2F0ZSBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIER1cGxpY2F0ZV0gKGZ1bmN0aW9uXG4gICAgfCBEdXBsaWNhdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLkR1cGxpY2F0ZVwiXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbigqIFtXaXRoX2xlbmd0aC50XSBhbGxvd3MgdXMgdG8gc3RvcmUgbGVuZ3RoIGluZm9ybWF0aW9uIG9uIHRoZSBzdGFjayB3aGlsZVxuICAga2VlcGluZyB0aGUgdHJlZSBnbG9iYWwuIFRoaXMgc2F2ZXMgdXAgdG8gTyhsb2cgbikgYmxvY2tzIG9mIGhlYXAgYWxsb2NhdGlvbi4gKilcbm1vZHVsZSBXaXRoX2xlbmd0aCA6IHNpZ1xuICB0eXBlICdhIHQgPSBwcml2YXRlXG4gICAgeyB0cmVlIDogJ2FcbiAgICAgICAgICAgICBbQGdsb2JhbF1cbiAgICA7IGxlbmd0aCA6IGludCBbQGdsb2JhbF1cbiAgICB9XG5cbiAgdmFsIHdpdGhfbGVuZ3RoIDogJ2EgLT4gaW50IC0+ICgnYSB0W0Bsb2NhbF0pXG4gIHZhbCB3aXRoX2xlbmd0aF9nbG9iYWwgOiAnYSAtPiBpbnQgLT4gJ2EgdFxuICB2YWwgZ2xvYmFsaXplIDogKCdhIHRbQGxvY2FsXSkgLT4gJ2EgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyB0cmVlIDogJ2EgW0BnbG9iYWxdXG4gICAgOyBsZW5ndGggOiBpbnQgW0BnbG9iYWxdXG4gICAgfVxuXG4gIGxldCB3aXRoX2xlbmd0aCB0cmVlIGxlbmd0aCA9ICB7IHRyZWU7IGxlbmd0aCB9XG4gIGxldCB3aXRoX2xlbmd0aF9nbG9iYWwgdHJlZSBsZW5ndGggPSB7IHRyZWU7IGxlbmd0aCB9XG4gIGxldCBnbG9iYWxpemUgKHsgdHJlZTsgbGVuZ3RoIH0gW0Bsb2NhbF0pID0geyB0cmVlOyBsZW5ndGggfVxuZW5kXG5cbm9wZW4gV2l0aF9sZW5ndGhcblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndikgdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgTGVhZiBvZiAnayAqICd2XG4gICAgfCBOb2RlIG9mICgnaywgJ3YpIHQgKiAnayAqICd2ICogKCdrLCAndikgdCAqIGludFxuXG4gIHR5cGUgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIHRcblxuICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChfLCBfLCBfLCBfLCBoKSAtPiBoXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudHMgPVxuICAgIGxldCBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrID1cbiAgICAgIChtYXRjaCBsb3dlciB3aXRoXG4gICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICB8IFNvbWUgbG93ZXIgLT4gY29tcGFyZV9rZXkgbG93ZXIgayA8IDApXG4gICAgICAmJlxuICAgICAgbWF0Y2ggdXBwZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgIHwgU29tZSB1cHBlciAtPiBjb21wYXJlX2tleSBrIHVwcGVyIDwgMFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTGVhZiAoaywgXykgLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgfCBOb2RlIChsLCBrLCBfLCByLCBoKSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIGspIGNvbXBhcmVfa2V5IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSBrKSB1cHBlciBjb21wYXJlX2tleSByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9rZXkgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9rZXkgdFxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMiAqKVxuICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA9IDAgJiYgaHIgPSAwXG4gICAgdGhlbiBMZWFmICh4LCBkKVxuICAgIGVsc2UgTm9kZSAobCwgeCwgZCwgciwgaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpXG4gIDs7XG5cbiAgbGV0IHNpbmdsZXRvbiBrZXkgZGF0YSA9IExlYWYgKGtleSwgZGF0YSlcblxuICAoKiBXZSBtdXN0IGNhbGwgW2ZdIHdpdGggaW5jcmVhc2luZyBpbmRleGVzLCBiZWNhdXNlIHRoZSBiaW5fcHJvdCByZWFkZXIgaW5cbiAgICAgQ29yZS5NYXAgbmVlZHMgaXQuICopXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBsZXQgcmVjIGxvb3AgbiB+ZiBpIDogKF8sIF8pIHQgPVxuICAgICAgbWF0Y2ggbiB3aXRoXG4gICAgICB8IDAgLT4gRW1wdHlcbiAgICAgIHwgMSAtPlxuICAgICAgICBsZXQgaywgdiA9IGYgaSBpblxuICAgICAgICBMZWFmIChrLCB2KVxuICAgICAgfCAyIC0+XG4gICAgICAgIGxldCBrbCwgdmwgPSBmIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgMSkgaW5cbiAgICAgICAgTm9kZSAoTGVhZiAoa2wsIHZsKSwgaywgdiwgRW1wdHksIDIpXG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsLCB2bCA9IGYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyAxKSBpblxuICAgICAgICBsZXQga3IsIHZyID0gZiAoaSArIDIpIGluXG4gICAgICAgIE5vZGUgKExlYWYgKGtsLCB2bCksIGssIHYsIExlYWYgKGtyLCB2ciksIDIpXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgdiByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDJcbiAgICAgICAgIHx8XG4gICAgICAgICBsZXQgazAsIF8gPSBhcnJheS4oMCkgaW5cbiAgICAgICAgIGxldCBrMSwgXyA9IGFycmF5LigxKSBpblxuICAgICAgICAgY29tcGFyZV9rZXkgazAgazEgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBcbiAgICAgICh3aXRoX2xlbmd0aFxuICAgICAgICAgKG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHQpXG4gICAgICAgICBhcnJheV9sZW5ndGgpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+XG4gICAgICBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5IHw+IGdsb2JhbGl6ZSlcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oMCkpIChmc3QgYXJyYXkuKDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2tleSAoZnN0IGFycmF5LihpKSkgKGZzdCBhcnJheS4oaSArIDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSB8PiBnbG9iYWxpemUpKVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMyAqKVxuICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsIGluXG4gICAgbGV0IGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBociArIDIgKilcbiAgICAgIHwgTm9kZSAobGwsIGx2LCBsZCwgbHIsIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgKGxydiwgbHJkKSAtPiBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBFbXB0eSkgbHJ2IGxyZCAoY3JlYXRlIEVtcHR5IHggZCByKVxuICAgICAgICAgIHwgTm9kZSAobHJsLCBscnYsIGxyZCwgbHJyLCBfKSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKSkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBobCArIDIgKilcbiAgICAgIHwgTm9kZSAocmwsIHJ2LCByZCwgcnIsIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmxcbiAgICAgICAgdGhlbiBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgKHJsdiwgcmxkKSAtPiBjcmVhdGUgKGNyZWF0ZSBsIHggZCBFbXB0eSkgcmx2IHJsZCAoY3JlYXRlIEVtcHR5IHJ2IHJkIHJyKVxuICAgICAgICAgIHwgTm9kZSAocmxsLCBybHYsIHJsZCwgcmxyLCBfKSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKSkpXG4gICAgZWxzZSBjcmVhdGUgbCB4IGQgclxuICA7O1xuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5IH5zZXhwX29mX2tleSA9XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIltNYXAuYWRkX2V4bl0gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuXG4gIG1vZHVsZSBBZGRfb3Jfc2V0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbFxuICAgICAgfCBBZGRfZXhuXG4gICAgICB8IFNldFxuICBlbmRcblxuICBsZXQgcmVjIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgICAgICAgIHRcbiAgICAgICAgICAgIH5sZW5ndGhcbiAgICAgICAgICAgIH5rZXk6eFxuICAgICAgICAgICAgfmRhdGFcbiAgICAgICAgICAgIH5jb21wYXJlX2tleVxuICAgICAgICAgICAgfnNleHBfb2Zfa2V5XG4gICAgICAgICAgICB+KGFkZF9vcl9zZXQgOiBBZGRfb3Jfc2V0LnQpXG4gICAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gICh3aXRoX2xlbmd0aCAoTGVhZiAoeCwgZGF0YSkpIChsZW5ndGggKyAxKSlcbiAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBhZGRfb3Jfc2V0IHdpdGhcbiAgICAgICAgfCBBZGRfZXhuX2ludGVybmFsIC0+ICAoRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZSlcbiAgICAgICAgfCBBZGRfZXhuIC0+ICAocmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5KVxuICAgICAgICB8IFNldCAtPiAgKHdpdGhfbGVuZ3RoIChMZWFmICh4LCBkYXRhKSkgbGVuZ3RoKSlcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gICh3aXRoX2xlbmd0aCAoTm9kZSAoTGVhZiAoeCwgZGF0YSksIHYsIGQsIEVtcHR5LCAyKSkgKGxlbmd0aCArIDEpKVxuICAgICAgZWxzZSAgKHdpdGhfbGVuZ3RoIChOb2RlIChFbXB0eSwgdiwgZCwgTGVhZiAoeCwgZGF0YSksIDIpKSAobGVuZ3RoICsgMSkpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggYWRkX29yX3NldCB3aXRoXG4gICAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbCAtPiAgKEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBEdXBsaWNhdGUpXG4gICAgICAgIHwgQWRkX2V4biAtPiAgKHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleTp4IH5zZXhwX29mX2tleSlcbiAgICAgICAgfCBTZXQgLT4gICh3aXRoX2xlbmd0aCAoTm9kZSAobCwgeCwgZGF0YSwgciwgaCkpIGxlbmd0aCkpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGw7IGxlbmd0aCB9ID1cbiAgICAgICAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IH5sZW5ndGggfmtleTp4IH5kYXRhIGwgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB+YWRkX29yX3NldFxuICAgICAgICBpblxuICAgICAgICAgKHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoKSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeyB0cmVlID0gcjsgbGVuZ3RoIH0gPVxuICAgICAgICAgIGZpbmRfYW5kX2FkZF9vcl9zZXQgfmxlbmd0aCB+a2V5OnggfmRhdGEgciB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0XG4gICAgICAgIGluXG4gICAgICAgICAod2l0aF9sZW5ndGggKGJhbCBsIHYgZCByKSBsZW5ndGgpKVxuICA7O1xuXG4gICgqIHNwZWNpYWxpemF0aW9uIG9mIFtzZXQnXSBmb3IgdGhlIGNhc2Ugd2hlbiBba2V5XSBpcyBsZXNzIHRoYW4gYWxsIHRoZSBleGlzdGluZyBrZXlzICopXG4gIGxldCByZWMgc2V0X21pbiBrZXkgZGF0YSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IExlYWYgKGtleSwgZGF0YSlcbiAgICB8IExlYWYgKHYsIGQpIC0+IE5vZGUgKExlYWYgKGtleSwgZGF0YSksIHYsIGQsIEVtcHR5LCAyKVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgIGxldCBsID0gc2V0X21pbiBrZXkgZGF0YSBsIGluXG4gICAgICBiYWwgbCB2IGQgclxuICA7O1xuXG4gICgqIHNwZWNpYWxpemF0aW9uIG9mIFtzZXQnXSBmb3IgdGhlIGNhc2Ugd2hlbiBba2V5XSBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZVxuICAgICBleGlzdGluZyBrZXlzICAqKVxuICBsZXQgcmVjIHNldF9tYXggdCBrZXkgZGF0YSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmIChrZXksIGRhdGEpXG4gICAgfCBMZWFmICh2LCBkKSAtPiBOb2RlIChFbXB0eSwgdiwgZCwgTGVhZiAoa2V5LCBkYXRhKSwgMilcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgciA9IHNldF9tYXggciBrZXkgZGF0YSBpblxuICAgICAgYmFsIGwgdiBkIHJcbiAgOztcblxuICBsZXQgYWRkX2V4biB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBcbiAgICAgIChmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICAgICB0XG4gICAgICAgICB+bGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICAgICB+c2V4cF9vZl9rZXlcbiAgICAgICAgIH5hZGRfb3Jfc2V0OkFkZF9leG4pXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgXG4gICAgICAoZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgICAgdFxuICAgICAgICAgfmxlbmd0aFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5jb21wYXJlX2tleVxuICAgICAgICAgfnNleHBfb2Zfa2V5XG4gICAgICAgICB+YWRkX29yX3NldDpBZGRfZXhuX2ludGVybmFsKVxuICA7O1xuXG4gIGxldCBzZXQgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBcbiAgICAgIChmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICAgICB0XG4gICAgICAgICB+bGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICAgICB+c2V4cF9vZl9rZXk6KGZ1biBfIC0+IExpc3QgW10pXG4gICAgICAgICB+YWRkX29yX3NldDpTZXQpXG4gIDs7XG5cbiAgbGV0IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXkgPSAoc2V0IHQgfmxlbmd0aDowIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5KS50cmVlXG5cbiAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRnJhZ21lbnQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnaywgJ3YpIHQgPVxuICAgICAgICB7IGxlZnRfc3VidHJlZSA6ICgnaywgJ3YpIHRcbiAgICAgICAgOyBrZXkgOiAna1xuICAgICAgICA7IGRhdGEgOiAndlxuICAgICAgICB9XG5cbiAgICAgIGxldCBzaW5nbGV0b25fdG9fdHJlZV9leG4gPSBmdW5jdGlvblxuICAgICAgICB8IHsgbGVmdF9zdWJ0cmVlID0gRW1wdHk7IGtleTsgZGF0YSB9IC0+IHNpbmdsZXRvbiBrZXkgZGF0YVxuICAgICAgICB8IF8gLT4gZmFpbHdpdGggXCJNYXAuc2luZ2xldG9uX3RvX3RyZWVfZXhuOiBub3QgYSBzaW5nbGV0b25cIlxuICAgICAgOztcblxuICAgICAgbGV0IHNpbmdsZXRvbiB+a2V5IH5kYXRhID0geyBsZWZ0X3N1YnRyZWUgPSBFbXB0eTsga2V5OyBkYXRhIH1cblxuICAgICAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwubGVmdF9zdWJ0cmVlKSAtIGhlaWdodChyKXwgPD0gMixcbiAgICAgICAgIG1heF9rZXkobCkgPCBtaW5fa2V5KHIpXG4gICAgICAqKVxuICAgICAgbGV0IGNvbGxhcHNlIGwgciA9IGNyZWF0ZSBsLmxlZnRfc3VidHJlZSBsLmtleSBsLmRhdGEgclxuXG4gICAgICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobC5sZWZ0X3N1YnRyZWUpIC0gaGVpZ2h0KHIubGVmdF9zdWJ0cmVlKXwgPD0gMixcbiAgICAgICAgIG1heF9rZXkobCkgPCBtaW5fa2V5KHIpXG4gICAgICAqKVxuICAgICAgbGV0IGpvaW4gbCByID0geyByIHdpdGggbGVmdF9zdWJ0cmVlID0gY29sbGFwc2UgbCByLmxlZnRfc3VidHJlZSB9XG4gICAgICBsZXQgbWF4X2tleSB0ID0gdC5rZXlcbiAgICBlbmRcblxuICAgICgqKiBCdWlsZCB0cmVlcyBmcm9tIHNpbmdsZXRvbnMgaW4gYSBiYWxhbmNlZCB3YXkgYnkgdXNpbmcgc2tldyBiaW5hcnkgZW5jb2RpbmcuXG4gICAgICAgIEVhY2ggbGV2ZWwgY29udGFpbnMgdHJlZXMgb2YgdGhlIHNhbWUgaGVpZ2h0LCBjb25zZWN1dGl2ZSBsZXZlbHMgaGF2ZSBjb25zZWN1dGl2ZVxuICAgICAgICBoZWlnaHRzLiBUaGVyZSBhcmUgbm8gZ2Fwcy4gVGhlIGZpcnN0IGxldmVsIGFyZSBzaW5nbGUga2V5cy5cbiAgICAqKVxuICAgIHR5cGUgKCdrLCAndikgdCA9XG4gICAgICB8IFplcm8gb2YgdW5pdFxuICAgICAgKCogW3VuaXRdIHRvIG1ha2UgcGF0dGVybiBtYXRjaGluZyBmYXN0ZXIgKilcbiAgICAgIHwgT25lIG9mICgnaywgJ3YpIHQgKiAoJ2ssICd2KSBGcmFnbWVudC50XG4gICAgICB8IFR3byBvZiAoJ2ssICd2KSB0ICogKCdrLCAndikgRnJhZ21lbnQudCAqICgnaywgJ3YpIEZyYWdtZW50LnRcblxuICAgIGxldCBlbXB0eSA9IFplcm8gKClcblxuICAgIGxldCBhZGRfdW5jaGVja2VkID1cbiAgICAgIGxldCByZWMgZ28gdCB4ID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgWmVybyAoKSAtPiBPbmUgKHQsIHgpXG4gICAgICAgIHwgT25lICh0LCB5KSAtPiBUd28gKHQsIHksIHgpXG4gICAgICAgIHwgVHdvICh0LCB6LCB5KSAtPiBPbmUgKGdvIHQgKEZyYWdtZW50LmpvaW4geiB5KSwgeClcbiAgICAgIGluXG4gICAgICBmdW4gdCB+a2V5IH5kYXRhIC0+IGdvIHQgKEZyYWdtZW50LnNpbmdsZXRvbiB+a2V5IH5kYXRhKVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdHJlZV91bmNoZWNrZWQgPVxuICAgICAgbGV0IHJlYyBnbyB0IHIgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBaZXJvICgpIC0+IHJcbiAgICAgICAgfCBPbmUgKHQsIGwpIC0+IGdvIHQgKEZyYWdtZW50LmNvbGxhcHNlIGwgcilcbiAgICAgICAgfCBUd28gKHQsIGxsLCBsKSAtPiBnbyB0IChGcmFnbWVudC5jb2xsYXBzZSAoRnJhZ21lbnQuam9pbiBsbCBsKSByKVxuICAgICAgaW5cbiAgICAgIGZ1bmN0aW9uXG4gICAgICB8IFplcm8gKCkgLT4gRW1wdHlcbiAgICAgIHwgT25lICh0LCByKSAtPiBnbyB0IChGcmFnbWVudC5zaW5nbGV0b25fdG9fdHJlZV9leG4gcilcbiAgICAgIHwgVHdvICh0LCBsLCByKSAtPiBnbyAoT25lICh0LCBsKSkgKEZyYWdtZW50LnNpbmdsZXRvbl90b190cmVlX2V4biByKVxuICAgIDs7XG5cbiAgICBsZXQgbWF4X2tleSA9IGZ1bmN0aW9uXG4gICAgICB8IFplcm8gKCkgLT4gTm9uZVxuICAgICAgfCBPbmUgKF8sIHIpIHwgVHdvIChfLCBfLCByKSAtPiBTb21lIChGcmFnbWVudC5tYXhfa2V5IHIpXG4gICAgOztcbiAgZW5kXG5cblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5ID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgIGxldCB7IHRyZWUgPSBidWlsZGVyOyBsZW5ndGggfSA9XG4gICAgICAgIFNlcXVlbmNlLmZvbGRcbiAgICAgICAgICBzZXFcbiAgICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIEJ1aWxkX2luY3JlYXNpbmcuZW1wdHkgMClcbiAgICAgICAgICB+ZjooZnVuIHsgdHJlZSA9IGJ1aWxkZXI7IGxlbmd0aCB9IChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgICBtYXRjaCBCdWlsZF9pbmNyZWFzaW5nLm1heF9rZXkgYnVpbGRlciB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJlX2tleSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICAgICAgICByZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX2luY3JlYXNpbmdfc2VxdWVuY2U6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIHdpdGhfbGVuZ3RoX2dsb2JhbFxuICAgICAgICAgICAgICAgIChCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgYnVpbGRlciB+a2V5IH5kYXRhKVxuICAgICAgICAgICAgICAgIChsZW5ndGggKyAxKSlcbiAgICAgIGluXG4gICAgICBPayAod2l0aF9sZW5ndGhfZ2xvYmFsIChCdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWVfdW5jaGVja2VkIGJ1aWxkZXIpIGxlbmd0aCkpXG4gIDs7XG5cbiAgKCogTGlrZSBbYmFsXSBidXQgYWxsb3dzIGFueSBkaWZmZXJlbmNlIGluIGhlaWdodCBiZXR3ZWVuIFtsXSBhbmQgW3JdLlxuXG4gICAgIE8ofGhlaWdodCBsIC0gaGVpZ2h0IHJ8KSAqKVxuICBsZXQgcmVjIGpvaW4gbCBrIGQgciA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBzZXRfbWluIGsgZCByXG4gICAgfCBfLCBFbXB0eSAtPiBzZXRfbWF4IGwgayBkXG4gICAgfCBMZWFmIChsaywgbGQpLCBfIC0+IHNldF9taW4gbGsgbGQgKHNldF9taW4gayBkIHIpXG4gICAgfCBfLCBMZWFmIChyaywgcmQpIC0+IHNldF9tYXggKHNldF9tYXggbCBrIGQpIHJrIHJkXG4gICAgfCBOb2RlIChsbCwgbGssIGxkLCBsciwgbGgpLCBOb2RlIChybCwgcmssIHJkLCByciwgcmgpIC0+XG4gICAgICAoKiBbYmFsXSByZXF1aXJlcyBoZWlnaHQgZGlmZmVyZW5jZSA8PSAzLiAqKVxuICAgICAgaWYgbGggPiByaCArIDNcbiAgICAgICgqIFtoZWlnaHQgbHIgPj0gaGVpZ2h0IHJdLFxuICAgICAgICAgdGhlcmVmb3JlIFtoZWlnaHQgKGpvaW4gbHIgayBkIHIgLi4uKV0gaXMgW2hlaWdodCBybCArIDFdIG9yIFtoZWlnaHQgcmxdXG4gICAgICAgICB0aGVyZWZvcmUgdGhlIGhlaWdodCBkaWZmZXJlbmNlIHdpdGggW2xsXSB3aWxsIGJlIDw9IDMgKilcbiAgICAgIHRoZW4gYmFsIGxsIGxrIGxkIChqb2luIGxyIGsgZCByKVxuICAgICAgZWxzZSBpZiByaCA+IGxoICsgM1xuICAgICAgdGhlbiBiYWwgKGpvaW4gbCBrIGQgcmwpIHJrIHJkIHJyXG4gICAgICBlbHNlIGJhbCBsIGsgZCByXG4gIDs7XG5cbiAgbGV0W0BpbmxpbmVdIHJlYyBzcGxpdF9nZW4gdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eSwgTm9uZSwgRW1wdHlcbiAgICB8IExlYWYgKGssIGQpIC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBFbXB0eSwgU29tZSAoaywgZCksIEVtcHR5XG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gRW1wdHksIE5vbmUsIHRcbiAgICAgIGVsc2UgdCwgTm9uZSwgRW1wdHlcbiAgICB8IE5vZGUgKGwsIGssIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBsLCBTb21lIChrLCBkKSwgclxuICAgICAgZWxzZSBpZiBjbXAgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxsLCBtYXliZSwgbHIgPSBzcGxpdF9nZW4gbCB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBsbCwgbWF5YmUsIGpvaW4gbHIgayBkIHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJsLCBtYXliZSwgcnIgPSBzcGxpdF9nZW4gciB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBqb2luIGwgayBkIHJsLCBtYXliZSwgcnIpXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgeCB+Y29tcGFyZV9rZXkgPSBzcGxpdF9nZW4gdCB4IH5jb21wYXJlX2tleTooZnVuIHkgLT4gY29tcGFyZV9rZXkgeCB5KVxuXG4gICgqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmVhbGx5IHJlaW5zZXJ0IFt4XSwgYnV0IGp1c3QgYXJyYW5nZXMgc28gdGhhdCBbc3BsaXRdXG4gICAgIHByb2R1Y2VzIHRoZSBlcXVpdmFsZW50IHRyZWUgaW4gdGhlIGZpcnN0IHBsYWNlLiAqKVxuICBsZXQgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG8geCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBsZWZ0LCBib3VuZGFyeV9vcHQsIHJpZ2h0ID1cbiAgICAgIHNwbGl0X2dlblxuICAgICAgICB0XG4gICAgICAgIHhcbiAgICAgICAgfmNvbXBhcmVfa2V5OlxuICAgICAgICAgIChtYXRjaCBpbnRvIHdpdGhcbiAgICAgICAgICAgfCBgTGVmdCAtPlxuICAgICAgICAgICAgIGZ1biB5IC0+XG4gICAgICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9rZXkgeCB5IHdpdGhcbiAgICAgICAgICAgICAgICB8IDAgLT4gMVxuICAgICAgICAgICAgICAgIHwgcmVzIC0+IHJlcylcbiAgICAgICAgICAgfCBgUmlnaHQgLT5cbiAgICAgICAgICAgICBmdW4geSAtPlxuICAgICAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfa2V5IHggeSB3aXRoXG4gICAgICAgICAgICAgICAgfCAwIC0+IC0xXG4gICAgICAgICAgICAgICAgfCByZXMgLT4gcmVzKSlcbiAgICBpblxuICAgIGFzc2VydCAoT3B0aW9uLmlzX25vbmUgYm91bmRhcnlfb3B0KTtcbiAgICBsZWZ0LCByaWdodFxuICA7O1xuXG4gIGxldCBzcGxpdF9yYW5nZVxuICAgICAgICB0XG4gICAgICAgIH4obG93ZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgICAgICB+KHVwcGVyX2JvdW5kIDogJ2EgTWF5YmVfYm91bmQudClcbiAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgPVxuICAgIGlmIE1heWJlX2JvdW5kLmJvdW5kc19jcm9zc2VkXG4gICAgICAgICB+Y29tcGFyZTpjb21wYXJlX2tleVxuICAgICAgICAgfmxvd2VyOmxvd2VyX2JvdW5kXG4gICAgICAgICB+dXBwZXI6dXBwZXJfYm91bmRcbiAgICB0aGVuIGVtcHR5LCBlbXB0eSwgZW1wdHlcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZWZ0LCBtaWRfYW5kX3JpZ2h0ID1cbiAgICAgICAgbWF0Y2ggbG93ZXJfYm91bmQgd2l0aFxuICAgICAgICB8IFVuYm91bmRlZCAtPiBlbXB0eSwgdFxuICAgICAgICB8IEluY2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBSaWdodCB0IGxiIH5jb21wYXJlX2tleVxuICAgICAgICB8IEV4Y2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBMZWZ0IHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgbGV0IG1pZCwgcmlnaHQgPVxuICAgICAgICBtYXRjaCB1cHBlcl9ib3VuZCB3aXRoXG4gICAgICAgIHwgVW5ib3VuZGVkIC0+IG1pZF9hbmRfcmlnaHQsIGVtcHR5XG4gICAgICAgIHwgSW5jbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YExlZnQgbWlkX2FuZF9yaWdodCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgICAgfCBFeGNsIGxiIC0+XG4gICAgICAgICAgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBSaWdodCBtaWRfYW5kX3JpZ2h0IGxiIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGxlZnQsIG1pZCwgcmlnaHQpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kIHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAodiwgZCkgLT4gaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIFNvbWUgZCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGQgZWxzZSBmaW5kIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZGF0YSA9IGRhdGEgOjogT3B0aW9uLnZhbHVlIChmaW5kIHQga2V5IH5jb21wYXJlX2tleSkgfmRlZmF1bHQ6W10gaW5cbiAgICAgKHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgdCB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggZmluZCB0IHggfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gW11cbiAgICB8IFNvbWUgbCAtPiBsXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuID1cbiAgICBsZXQgaWZfbm90X2ZvdW5kIGtleSB+c2V4cF9vZl9rZXkgPVxuICAgICAgcmFpc2UgKE5vdF9mb3VuZF9zIChMaXN0IFsgQXRvbSBcIk1hcC5maW5kX2V4bjogbm90IGZvdW5kXCI7IHNleHBfb2Zfa2V5IGtleSBdKSlcbiAgICBpblxuICAgIGxldCByZWMgZmluZF9leG4gdCB4IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGlmX25vdF9mb3VuZCB4IH5zZXhwX29mX2tleVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gZCBlbHNlIGlmX25vdF9mb3VuZCB4IH5zZXhwX29mX2tleVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIGQgZWxzZSBmaW5kX2V4biAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgZmluZF9leG5cbiAgOztcblxuICBsZXQgbWVtIHQgeCB+Y29tcGFyZV9rZXkgPSBPcHRpb24uaXNfc29tZSAoZmluZCB0IHggfmNvbXBhcmVfa2V5KVxuXG4gIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCBkKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoRW1wdHksIGssIGQsIF8sIF8pIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChsLCBfLCBfLCBfLCBfKSAtPiBtaW5fZWx0IGxcbiAgOztcblxuICBleGNlcHRpb24gTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBleGNlcHRpb24gTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgbWluX2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWluX2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgZCkgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKF8sIGssIGQsIEVtcHR5LCBfKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoXywgXywgXywgciwgXykgLT4gbWF4X2VsdCByXG4gIDs7XG5cbiAgbGV0IG1heF9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1heF9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICB8IExlYWYgXyAtPiBFbXB0eVxuICAgIHwgTm9kZSAoRW1wdHksIF8sIF8sIHIsIF8pIC0+IHJcbiAgICB8IE5vZGUgKGwsIHgsIGQsIHIsIF8pIC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgeCBkIHJcbiAgOztcblxuICBsZXQgYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggbWF4X2VsdCBsb3dlcl9wYXJ0LCBtaW5fZWx0IHVwcGVyX3BhcnQgd2l0aFxuICAgIHwgTm9uZSwgXyAtPiBgT2sgdXBwZXJfcGFydFxuICAgIHwgXywgTm9uZSAtPiBgT2sgbG93ZXJfcGFydFxuICAgIHwgU29tZSAobWF4X2xvd2VyLCBfKSwgU29tZSAobWluX3VwcGVyLCB2KSB3aGVuIGNvbXBhcmVfa2V5IG1heF9sb3dlciBtaW5fdXBwZXIgPCAwIC0+XG4gICAgICBsZXQgdXBwZXJfcGFydF93aXRob3V0X21pbiA9IHJlbW92ZV9taW5fZWx0IHVwcGVyX3BhcnQgaW5cbiAgICAgIGBPayAoam9pbiBsb3dlcl9wYXJ0IG1pbl91cHBlciB2IHVwcGVyX3BhcnRfd2l0aG91dF9taW4pXG4gICAgfCBfIC0+IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlID1cbiAgICAoKiBUaGlzIGFzc3VtZXMgdGhhdCBtaW4gPD0gbWF4LCB3aGljaCBpcyBjaGVja2VkIGJ5IHRoZSBvdXRlciBmdW5jdGlvbi4gKilcbiAgICBsZXQgcmVjIGdvIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW5pdFxuICAgICAgfCBMZWFmIChrLCBkKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIG1pbiA8IDAgfHwgY29tcGFyZV9rZXkgayBtYXggPiAwXG4gICAgICAgIHRoZW4gKCogayA8IG1pbiB8fCBrID4gbWF4ICopXG4gICAgICAgICAgaW5pdFxuICAgICAgICBlbHNlIGYgfmtleTprIH5kYXRhOmQgaW5pdFxuICAgICAgfCBOb2RlIChsLCBrLCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgY19taW4gPSBjb21wYXJlX2tleSBrIG1pbiBpblxuICAgICAgICBpZiBjX21pbiA8IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPCBtaW4sIHRoZW4gdGhpcyBub2RlIGFuZCBpdHMgbGVmdCBicmFuY2ggYXJlIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgaWYgY19taW4gPSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBpZiBrID0gbWluLCB0aGVuIHRoaXMgbm9kZSdzIGxlZnQgYnJhbmNoIGlzIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQ6KGYgfmtleTprIH5kYXRhOmQgaW5pdCkgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGsgPiBtaW4gKilcbiAgICAgICAgICBsZXQgeiA9IGdvIGwgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGxldCBjX21heCA9IGNvbXBhcmVfa2V5IGsgbWF4IGluXG4gICAgICAgICAgKCogaWYgayA+IG1heCwgd2UncmUgZG9uZSAqKVxuICAgICAgICAgIGlmIGNfbWF4ID4gMFxuICAgICAgICAgIHRoZW4gelxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHogPSBmIH5rZXk6ayB+ZGF0YTpkIHogaW5cbiAgICAgICAgICAgICgqIGlmIGsgPSBtYXgsIHRoZW4gd2UgZm9sZCBpbiB0aGlzIG9uZSBsYXN0IHZhbHVlIGFuZCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgICBpZiBjX21heCA9IDAgdGhlbiB6IGVsc2UgZ28gciB+bWluIH5tYXggfmluaXQ6eiB+ZiB+Y29tcGFyZV9rZXkpKVxuICAgIGluXG4gICAgZnVuIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSAtPlxuICAgICAgaWYgY29tcGFyZV9rZXkgbWluIG1heCA8PSAwIHRoZW4gZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGVsc2UgaW5pdFxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXkgPVxuICAgIExpc3QucmV2XG4gICAgICAoZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgICAgIHRcbiAgICAgICAgIH5taW5cbiAgICAgICAgIH5tYXhcbiAgICAgICAgIH5pbml0OltdXG4gICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgbCAtPiAoa2V5LCBkYXRhKSA6OiBsKVxuICAgICAgICAgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbnM6XG4gICAgIC0gYWxsIGVsZW1lbnRzIGluIHQxIGFyZSBsZXNzIHRoYW4gZWxlbWVudHMgaW4gdDJcbiAgICAgLSB8aGVpZ2h0KHQxKSAtIGhlaWdodCh0Mil8IDw9IDIgKilcbiAgbGV0IGNvbmNhdF91bmNoZWNrZWQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgeCwgZCA9IG1pbl9lbHRfZXhuIHQyIGluXG4gICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICAoKiBzaW1pbGFyIHRvIFtjb25jYXRfdW5jaGVja2VkXSwgYW5kIGJhbGFuY2VzIHRyZWVzIG9mIGFyYml0cmFyeSBoZWlnaHQgZGlmZmVyZW5jZXMgKilcbiAgbGV0IGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgeCwgZCA9IG1pbl9lbHRfZXhuIHQyIGluXG4gICAgICBqb2luIHQxIHggZCAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFJlbW92ZV9ub19vcFxuXG4gIGxldCByZW1vdmUgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIHJlbW92ZV9sb29wIHQgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gIChFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgUmVtb3ZlX25vX29wKVxuICAgICAgfCBMZWFmICh2LCBfKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSB4IHYgPSAwXG4gICAgICAgIHRoZW4gICh3aXRoX2xlbmd0aCBFbXB0eSAobGVuZ3RoIC0gMSkpXG4gICAgICAgIGVsc2UgIChFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgUmVtb3ZlX25vX29wKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuICAod2l0aF9sZW5ndGggKGNvbmNhdF91bmNoZWNrZWQgbCByKSAobGVuZ3RoIC0gMSkpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHsgdHJlZSA9IGw7IGxlbmd0aCB9ID0gcmVtb3ZlX2xvb3AgbCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgICh3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIHIpIGxlbmd0aCkpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCB7IHRyZWUgPSByOyBsZW5ndGggfSA9IHJlbW92ZV9sb29wIHIgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgICAod2l0aF9sZW5ndGggKGJhbCBsIHYgZCByKSBsZW5ndGgpKVxuICAgIGluXG4gICAgdHJ5ICAocmVtb3ZlX2xvb3AgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5KSB3aXRoXG4gICAgfCBSZW1vdmVfbm9fb3AgLT4gICh3aXRoX2xlbmd0aCB0IGxlbmd0aClcbiAgOztcblxuICAoKiBVc2UgZXhjZXB0aW9uIHRvIGF2b2lkIHRyZWUtcmVidWlsZCBpbiBuby1vcCBjYXNlICopXG4gIGV4Y2VwdGlvbiBDaGFuZ2Vfbm9fb3BcblxuICBsZXQgY2hhbmdlIHQga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIGNoYW5nZV9jb3JlIHQga2V5IGYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgIChtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICgqIGVxdWl2YWxlbnQgdG8gcmV0dXJuaW5nOiBFbXB0eSAqKVxuICAgICAgICAgICAgKEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBDaGFuZ2Vfbm9fb3ApXG4gICAgICAgICB8IFNvbWUgZGF0YSAtPiAgKHdpdGhfbGVuZ3RoIChMZWFmIChrZXksIGRhdGEpKSAobGVuZ3RoICsgMSkpKVxuICAgICAgfCBMZWFmICh2LCBkKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAgKHdpdGhfbGVuZ3RoIEVtcHR5IChsZW5ndGggLSAxKSlcbiAgICAgICAgICB8IFNvbWUgZCcgLT4gICh3aXRoX2xlbmd0aCAoTGVhZiAodiwgZCcpKSBsZW5ndGgpKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB7IHRyZWUgPSBsOyBsZW5ndGggfSA9IGNoYW5nZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgICh3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIEVtcHR5KSBsZW5ndGgpKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgeyB0cmVlID0gcjsgbGVuZ3RoIH0gPSBjaGFuZ2VfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgICAod2l0aF9sZW5ndGggKGJhbCBFbXB0eSB2IGQgcikgbGVuZ3RoKSlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gICh3aXRoX2xlbmd0aCAoY29uY2F0X3VuY2hlY2tlZCBsIHIpIChsZW5ndGggLSAxKSlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiAgKHdpdGhfbGVuZ3RoIChOb2RlIChsLCBrZXksIGRhdGEsIHIsIGgpKSBsZW5ndGgpKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB7IHRyZWUgPSBsOyBsZW5ndGggfSA9IGNoYW5nZV9jb3JlIGwga2V5IGYgaW5cbiAgICAgICAgICAgKHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoKSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHsgdHJlZSA9IHI7IGxlbmd0aCB9ID0gY2hhbmdlX2NvcmUgciBrZXkgZiBpblxuICAgICAgICAgICAod2l0aF9sZW5ndGggKGJhbCBsIHYgZCByKSBsZW5ndGgpKVxuICAgIGluXG4gICAgdHJ5ICAoY2hhbmdlX2NvcmUgdCBrZXkgZikgd2l0aFxuICAgIHwgQ2hhbmdlX25vX29wIC0+ICAod2l0aF9sZW5ndGggdCBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IHJlYyB1cGRhdGVfY29yZSB0IGtleSBmID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICBsZXQgZGF0YSA9IGYgTm9uZSBpblxuICAgICAgICAgKHdpdGhfbGVuZ3RoIChMZWFmIChrZXksIGRhdGEpKSAobGVuZ3RoICsgMSkpXG4gICAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGQnID0gZiAoU29tZSBkKSBpblxuICAgICAgICAgICAod2l0aF9sZW5ndGggKExlYWYgKHYsIGQnKSkgbGVuZ3RoKSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgeyB0cmVlID0gbDsgbGVuZ3RoIH0gPSB1cGRhdGVfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgICAod2l0aF9sZW5ndGggKGJhbCBsIHYgZCBFbXB0eSkgbGVuZ3RoKSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHsgdHJlZSA9IHI7IGxlbmd0aCB9ID0gdXBkYXRlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICAgKHdpdGhfbGVuZ3RoIChiYWwgRW1wdHkgdiBkIHIpIGxlbmd0aCkpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGRhdGEgPSBmIChTb21lIGQpIGluXG4gICAgICAgICAgICh3aXRoX2xlbmd0aCAoTm9kZSAobCwga2V5LCBkYXRhLCByLCBoKSkgbGVuZ3RoKSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgeyB0cmVlID0gbDsgbGVuZ3RoIH0gPSB1cGRhdGVfY29yZSBsIGtleSBmIGluXG4gICAgICAgICAgICh3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIHIpIGxlbmd0aCkpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCB7IHRyZWUgPSByOyBsZW5ndGggfSA9IHVwZGF0ZV9jb3JlIHIga2V5IGYgaW5cbiAgICAgICAgICAgKHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoKSlcbiAgICBpblxuICAgICAodXBkYXRlX2NvcmUgdCBrZXkgZilcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBcbiAgICAgIChjaGFuZ2UgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICB8IE5vbmUgfCBTb21lIChbXSB8IFsgXyBdKSAtPiBOb25lXG4gICAgICAgICB8IFNvbWUgKF8gOjogKF8gOjogXyBhcyBub25fZW1wdHlfdGFpbCkpIC0+IFNvbWUgbm9uX2VtcHR5X3RhaWwpKVxuICA7O1xuXG4gIGxldCByZWMgaXRlcl9rZXlzIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgKHYsIF8pIC0+IGYgdlxuICAgIHwgTm9kZSAobCwgdiwgXywgciwgXykgLT5cbiAgICAgIGl0ZXJfa2V5cyB+ZiBsO1xuICAgICAgZiB2O1xuICAgICAgaXRlcl9rZXlzIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiAoXywgZCkgLT4gZiBkXG4gICAgfCBOb2RlIChsLCBfLCBkLCByLCBfKSAtPlxuICAgICAgaXRlciB+ZiBsO1xuICAgICAgZiBkO1xuICAgICAgaXRlciB+ZiByXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyaSB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgaXRlcmkgfmYgbDtcbiAgICAgIGYgfmtleTp2IH5kYXRhOmQ7XG4gICAgICBpdGVyaSB+ZiByXG4gIDs7XG5cbiAgbGV0IGl0ZXJpX3VudGlsID1cbiAgICBsZXQgcmVjIGl0ZXJpX3VudGlsX2xvb3AgdCB+ZiA6IENvbnRpbnVlX29yX3N0b3AudCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGludWVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZFxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICAobWF0Y2ggaXRlcmlfdW50aWxfbG9vcCB+ZiBsIHdpdGhcbiAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICB8IENvbnRpbnVlIC0+XG4gICAgICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICAgICB8IENvbnRpbnVlIC0+IGl0ZXJpX3VudGlsX2xvb3AgfmYgcikpXG4gICAgaW5cbiAgICBmdW4gdCB+ZiAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLm9mX2NvbnRpbnVlX29yX3N0b3AgKGl0ZXJpX3VudGlsX2xvb3AgdCB+ZilcbiAgOztcblxuICBsZXQgcmVjIG1hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmICh2LCBkKSAtPiBMZWFmICh2LCBmIGQpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGwnID0gbWFwIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgbGV0IHInID0gbWFwIH5mIHIgaW5cbiAgICAgIE5vZGUgKGwnLCB2LCBkJywgcicsIGgpXG4gIDs7XG5cbiAgbGV0IHJlYyBtYXBpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgKHYsIGQpIC0+IExlYWYgKHYsIGYgfmtleTp2IH5kYXRhOmQpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGwnID0gbWFwaSB+ZiBsIGluXG4gICAgICBsZXQgZCcgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBtYXBpIH5mIHIgaW5cbiAgICAgIE5vZGUgKGwnLCB2LCBkJywgcicsIGgpXG4gIDs7XG5cbiAgbGV0IHJlYyBmb2xkIHQgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGZvbGQgfmYgciB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2xvb3AgdCB+YWNjIH5mIDogKF8sIF8pIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRpbnVlIGFjY1xuICAgICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY1xuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9sb29wIGwgfmFjYyB+ZiB3aXRoXG4gICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgYWNjIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBmaW5hbCAtPiBTdG9wIGZpbmFsXG4gICAgICAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBmb2xkX3VudGlsX2xvb3AgciB+YWNjIH5mKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfbG9vcCB0IH5hY2M6aW5pdCB+ZiB3aXRoXG4gICAgfCBDb250aW51ZSBhY2MgLT4gZmluaXNoIGFjYyBbQG5vbnRhaWxdXG4gICAgfCBTdG9wIHN0b3AgLT4gc3RvcFxuICA7O1xuXG4gIGxldCByZWMgZm9sZF9yaWdodCB0IH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIH5rZXk6diB+ZGF0YTpkIChmb2xkX3JpZ2h0IH5mIHIgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaWx0ZXJfbWFwaSB0IH5mIH5sZW4gPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCB3aXRoXG4gICAgICAgfCBTb21lIG5ld19kYXRhIC0+IExlYWYgKHYsIG5ld19kYXRhKVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgZGVjciBsZW47XG4gICAgICAgICBFbXB0eSlcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwaSBsIH5mIH5sZW4gaW5cbiAgICAgIGxldCBuZXdfZGF0YSA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgIGxldCByJyA9IGZpbHRlcl9tYXBpIHIgfmYgfmxlbiBpblxuICAgICAgKG1hdGNoIG5ld19kYXRhIHdpdGhcbiAgICAgICB8IFNvbWUgbmV3X2RhdGEgLT4gam9pbiBsJyB2IG5ld19kYXRhIHInXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBkZWNyIGxlbjtcbiAgICAgICAgIGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaWx0ZXJpIHQgfmYgfmxlbiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICB8IHRydWUgLT4gdFxuICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgIGRlY3IgbGVuO1xuICAgICAgICAgRW1wdHkpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgbGV0IGwnID0gZmlsdGVyaSBsIH5mIH5sZW4gaW5cbiAgICAgIGxldCBrZWVwX2RhdGEgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBmaWx0ZXJpIHIgfmYgfmxlbiBpblxuICAgICAgaWYgcGh5c19lcXVhbCBsIGwnICYmIGtlZXBfZGF0YSAmJiBwaHlzX2VxdWFsIHIgcidcbiAgICAgIHRoZW4gdFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGtlZXBfZGF0YSB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPiBqb2luIGwnIHYgZCByJ1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgZGVjciBsZW47XG4gICAgICAgICAgY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCBsJyByJylcbiAgOztcblxuICBsZXQgZmlsdGVyIHQgfmYgfmxlbiA9IGZpbHRlcmkgdCB+bGVuIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiB+bGVuID0gZmlsdGVyaSB0IH5sZW4gfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiB+bGVuID0gZmlsdGVyX21hcGkgdCB+bGVuIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgICBsZXQgdDEsIHQyID1cbiAgICAgIGZvbGRcbiAgICAgICAgdFxuICAgICAgICB+aW5pdDooQnVpbGRfaW5jcmVhc2luZy5lbXB0eSwgQnVpbGRfaW5jcmVhc2luZy5lbXB0eSlcbiAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhICh0MSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggKGYgfmtleSB+ZGF0YSA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgICB8IEZpcnN0IHggLT4gQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIHQxIH5rZXkgfmRhdGE6eCwgdDJcbiAgICAgICAgICB8IFNlY29uZCB5IC0+IHQxLCBCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgdDIgfmtleSB+ZGF0YTp5KVxuICAgIGluXG4gICAgQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0MSwgQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0MlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICAgIGxldCByZWMgbG9vcCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFbXB0eSwgRW1wdHlcbiAgICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgICAgfCB0cnVlIC0+IHQsIEVtcHR5XG4gICAgICAgICB8IGZhbHNlIC0+IEVtcHR5LCB0KVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgbCd0LCBsJ2YgPSBsb29wIGwgfmYgaW5cbiAgICAgICAgbGV0IGtlZXBfZGF0YV90ID0gZiB+a2V5OnYgfmRhdGE6ZCBpblxuICAgICAgICBsZXQgcid0LCByJ2YgPSBsb29wIHIgfmYgaW5cbiAgICAgICAgbGV0IG1rIGwnIGtlZXBfZGF0YSByJyA9XG4gICAgICAgICAgaWYgcGh5c19lcXVhbCBsIGwnICYmIGtlZXBfZGF0YSAmJiBwaHlzX2VxdWFsIHIgcidcbiAgICAgICAgICB0aGVuIHRcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIG1hdGNoIGtlZXBfZGF0YSB3aXRoXG4gICAgICAgICAgICB8IHRydWUgLT4gam9pbiBsJyB2IGQgcidcbiAgICAgICAgICAgIHwgZmFsc2UgLT4gY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCBsJyByJylcbiAgICAgICAgaW5cbiAgICAgICAgbWsgbCd0IGtlZXBfZGF0YV90IHIndCwgbWsgbCdmIChub3Qga2VlcF9kYXRhX3QpIHInZlxuICAgIGluXG4gICAgbG9vcCB0IH5mXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnaywgJ3YsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnayAqICd2ICogKCdrLCAndikgdHJlZSAqICgnaywgJ3YsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyB0IChlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGNvbnMgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCB0IChlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGNvbnNfcmlnaHQgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl90cmVlIHRyZWUgOiAoXywgXywgaW5jcmVhc2luZykgdCA9IGNvbnMgdHJlZSBFbmRcbiAgICBsZXQgb2ZfdHJlZV9yaWdodCB0cmVlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPSBjb25zX3JpZ2h0IHRyZWUgRW5kXG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmICh2LCBkKSAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgZCwgRW1wdHksIDEpKSBlXG4gICAgICAgIHwgTm9kZSAoXywgdiwgXywgciwgXykgd2hlbiBjb21wYXJlIHYga2V5IDwgMCAtPiBsb29wIHIgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGxvb3AgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmICh2LCBkKSAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgZCwgRW1wdHksIDEpKSBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgXywgXywgXykgd2hlbiBjb21wYXJlIHYga2V5ID4gMCAtPiBsb29wIGwgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGxvb3AgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RlcF9kZWVwZXJfZXhuIHRyZWUgZSA9XG4gICAgICBtYXRjaCB0cmVlIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IEVtcHR5LCBNb3JlICh2LCBkLCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gbCwgTW9yZSAodiwgZCwgciwgZSlcbiAgICA7O1xuXG4gICAgKCogW2Ryb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgYWNjMSB0cmVlMiBhY2MyXSBkcm9wcyB0aGUgbGFyZ2VzdCBwaHlzaWNhbGx5LWVxdWFsXG4gICAgICAgcHJlZml4IG9mIHRyZWUxIGFuZCB0cmVlMiB0aGF0IHRoZXkgc2hhcmUsIGFuZCB0aGVuIHByZXBlbmRzIHRoZSByZW1haW5pbmcgZGF0YVxuICAgICAgIGludG8gYWNjMSBhbmQgYWNjMiwgcmVzcGVjdGl2ZWx5LlxuICAgICAgIFRoaXMgY2FuIGJlIGFzeW1wdG90aWNhbGx5IGZhc3RlciB0aGFuIFtjb25zXSBldmVuIGlmIGl0IHNraXBzIGEgc21hbGwgcHJvcG9ydGlvblxuICAgICAgIG9mIHRoZSB0cmVlIGJlY2F1c2UgW2NvbnNdIGlzIGFsd2F5cyBPKGxvZyhuKSkgaW4gdGhlIHNpemUgb2YgdGhlIHRyZWUsIHdoaWxlXG4gICAgICAgdGhpcyBmdW5jdGlvbiBpcyBPKGxvZyhuL20pKSB3aGVyZSBbbV0gaXMgdGhlIHNpemUgb2YgdGhlIHBhcnQgb2YgdGhlIHRyZWUgdGhhdFxuICAgICAgIGlzIHNraXBwZWQuICopXG4gICAgbGV0IHJlYyBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICB0aGVuIGFjYzEsIGFjYzJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaDIgPSBoZWlnaHQgdHJlZTIgaW5cbiAgICAgICAgbGV0IGgxID0gaGVpZ2h0IHRyZWUxIGluXG4gICAgICAgIGlmIGgyID0gaDFcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHRyZWUxLCBhY2MxID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUxIGFjYzEgaW5cbiAgICAgICAgICBsZXQgdHJlZTIsIGFjYzIgPSBzdGVwX2RlZXBlcl9leG4gdHJlZTIgYWNjMiBpblxuICAgICAgICAgIGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgYWNjMSB0cmVlMiBhY2MyKVxuICAgICAgICBlbHNlIGlmIGgyID4gaDFcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHRyZWUyLCBhY2MyID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUyIGFjYzIgaW5cbiAgICAgICAgICBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHRyZWUxLCBhY2MxID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUxIGFjYzEgaW5cbiAgICAgICAgICBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMikpXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSAodjIsIGQyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2RhdGEgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbGV0IGUxLCBlMiA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggcjEgZTEgcjIgZTIgaW5cbiAgICAgICAgICAgICAgbG9vcCBlMSBlMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgZGF0YV9lcXVhbCB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IHRydWVcbiAgICAgICAgfCBFbmQsIF8gfCBfLCBFbmQgLT4gZmFsc2VcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGNvbXBhcmVfa2V5IHYxIHYyID0gMFxuICAgICAgICAgICYmIGRhdGFfZXF1YWwgZDEgZDJcbiAgICAgICAgICAmJlxuICAgICAgICAgIGxldCBlMSwgZTIgPSBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHIxIGUxIHIyIGUyIGluXG4gICAgICAgICAgbG9vcCBlMSBlMlxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBmb2xkIH5pbml0IH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+IGluaXRcbiAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBsZXQgbmV4dCA9IGYgfmtleSB+ZGF0YSBpbml0IGluXG4gICAgICAgIGZvbGQgKGNvbnMgdHJlZSBlbnVtKSB+aW5pdDpuZXh0IH5mXG4gICAgOztcblxuICAgIGxldCBmb2xkMiBjb21wYXJlX2tleSB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgY3VyciA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gY3VyclxuICAgICAgICB8IEVuZCwgXyAtPlxuICAgICAgICAgIGZvbGQgdDIgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYFJpZ2h0IGRhdGEpIGFjYykgW0Bub250YWlsXG4gICAgICAgICAgXVxuICAgICAgICB8IF8sIEVuZCAtPlxuICAgICAgICAgIGZvbGQgdDEgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYExlZnQgZGF0YSkgYWNjKSBbQG5vbnRhaWxcbiAgICAgICAgICBdXG4gICAgICAgIHwgTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpLCBNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azEgfmRhdGE6KGBCb3RoICh2MSwgdjIpKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikgbmV4dClcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azEgfmRhdGE6KGBMZWZ0IHYxKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSB0MiBuZXh0KVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azIgfmRhdGE6KGBSaWdodCB2MikgY3VyciBpblxuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikgbmV4dClcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyIGluaXQgW0Bub250YWlsXVxuICAgIDs7XG5cbiAgICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsID1cbiAgICAgIGxldCBzdGVwIHN0YXRlID1cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgICB8IEVuZCwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGtleSwgYFJpZ2h0IGRhdGE7IHN0YXRlID0gRW5kLCBjb25zIHRyZWUgZW51bSB9XG4gICAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSwgRW5kIC0+XG4gICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0ga2V5LCBgTGVmdCBkYXRhOyBzdGF0ZSA9IGNvbnMgdHJlZSBlbnVtLCBFbmQgfVxuICAgICAgICB8IChNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0X3N0YXRlID0gZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0cmVlMSBlbnVtMSB0cmVlMiBlbnVtMiBpblxuICAgICAgICAgICAgaWYgZGF0YV9lcXVhbCB2MSB2MlxuICAgICAgICAgICAgdGhlbiBTZXF1ZW5jZS5TdGVwLlNraXAgeyBzdGF0ZSA9IG5leHRfc3RhdGUgfVxuICAgICAgICAgICAgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrMSwgYFVuZXF1YWwgKHYxLCB2Mik7IHN0YXRlID0gbmV4dF9zdGF0ZSB9KVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gazEsIGBMZWZ0IHYxOyBzdGF0ZSA9IGNvbnMgdHJlZTEgZW51bTEsIHJpZ2h0IH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrMiwgYFJpZ2h0IHYyOyBzdGF0ZSA9IGxlZnQsIGNvbnMgdHJlZTIgZW51bTIgfVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0Oihkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHQxIEVuZCB0MiBFbmQpIH5mOnN0ZXBcbiAgICA7O1xuXG4gICAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICAgIGxldCBhZGQgYWNjIGsgdiA9IGYgYWNjIChrLCBgUmlnaHQgdikgaW5cbiAgICAgIGxldCByZW1vdmUgYWNjIGsgdiA9IGYgYWNjIChrLCBgTGVmdCB2KSBpblxuICAgICAgbGV0IHJlYyBsb29wIGxlZnQgcmlnaHQgYWNjID1cbiAgICAgICAgbWF0Y2ggbGVmdCwgcmlnaHQgd2l0aFxuICAgICAgICB8IEVuZCwgZW51bSAtPlxuICAgICAgICAgIGZvbGQgZW51bSB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBhZGQgYWNjIGtleSBkYXRhKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgZW51bSwgRW5kIC0+XG4gICAgICAgICAgZm9sZCBlbnVtIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSBhY2Mga2V5IGRhdGEpIFtAbm9udGFpbF1cbiAgICAgICAgfCAoTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgYWNjID0gaWYgZGF0YV9lcXVhbCB2MSB2MiB0aGVuIGFjYyBlbHNlIGYgYWNjIChrMSwgYFVuZXF1YWwgKHYxLCB2MikpIGluXG4gICAgICAgICAgICBsZXQgZW51bTEsIGVudW0yID0gZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0cmVlMSBlbnVtMSB0cmVlMiBlbnVtMiBpblxuICAgICAgICAgICAgbG9vcCBlbnVtMSBlbnVtMiBhY2MpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIGsxIHYxIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSByaWdodCBhY2MpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBrMiB2MiBpblxuICAgICAgICAgICAgbG9vcCBsZWZ0IChjb25zIHRyZWUyIGVudW0yKSBhY2MpXG4gICAgICBpblxuICAgICAgbGV0IGxlZnQsIHJpZ2h0ID0gZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0MSBFbmQgdDIgRW5kIGluXG4gICAgICBsb29wIGxlZnQgcmlnaHQgaW5pdCBbQG5vbnRhaWxdXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXkgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdiwgdCwgZSkgLT5cbiAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gaywgdjsgc3RhdGUgPSBFbnVtLmNvbnMgdCBlIH1cbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fa2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3RyZWUgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleSB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB2LCB0LCBlKSAtPlxuICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrLCB2OyBzdGF0ZSA9IEVudW0uY29uc19yaWdodCB0IGUgfVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9rZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2ZfdHJlZV9yaWdodCB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZVxuICAgICAgICBjb21wYXJhdG9yXG4gICAgICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZ19rZXkpXG4gICAgICAgID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2tleSBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSAtPiBzZXQnIHQga2V5IGRhdGEgfmNvbXBhcmVfa2V5XG4gICAgaW5cbiAgICBtYXRjaCBvcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19sZXNzX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBmc3QpIGluXG4gICAgICB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byB0XG4gICAgfCBgRGVjcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBzbmQpIGluXG4gICAgICB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBsZXQgZTEsIGUyID0gRW51bS5kcm9wX3BoeXNfZXF1YWxfcHJlZml4IHQxIEVuZCB0MiBFbmQgaW5cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIGUxIGUyXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgbGV0IGUxLCBlMiA9IEVudW0uZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0MSBFbmQgdDIgRW5kIGluXG4gICAgRW51bS5lcXVhbCBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgZTEgZTJcbiAgOztcblxuICBsZXQgaXRlcjIgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBFbnVtLmZvbGQyXG4gICAgICBjb21wYXJlX2tleVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MSlcbiAgICAgIChFbnVtLm9mX3RyZWUgdDIpXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhICgpIC0+IGYgfmtleSB+ZGF0YSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDIgY29tcGFyZV9rZXkgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MikgfmYgfmluaXRcbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICAoKiBbRW51bS5mb2xkX2RpZmZzXSBpcyBhIGNvcnJlY3QgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGlzIGNvbnNpZGVyYWJseVxuICAgICAgIHNsb3dlciwgYXMgd2UgaGF2ZSB0byBhbGxvY2F0ZSBxdWl0ZSBhIGxvdCBvZiBzdGF0ZSB0byB0cmFjayBlbnVtZXJhdGlvbiBvZiBhIHRyZWUuXG4gICAgICAgQXZvaWQgaWYgd2UgY2FuLlxuICAgICopXG4gICAgbGV0IHNsb3cgeCB5IH5pbml0ID0gRW51bS5mb2xkX3N5bW1ldHJpY19kaWZmIHggeSB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmYgfmluaXQgaW5cbiAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgbGV0IHJlbW92ZSBhY2MgayB2ID0gZiBhY2MgKGssIGBMZWZ0IHYpIGluXG4gICAgbGV0IGRlbHRhIGFjYyBrIHYgdicgPSBpZiBkYXRhX2VxdWFsIHYgdicgdGhlbiBhY2MgZWxzZSBmIGFjYyAoaywgYFVuZXF1YWwgKHYsIHYnKSkgaW5cbiAgICAoKiBJZiB0d28gdHJlZXMgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXQgdGhlIHJvb3QgKGFuZCB0aGUgc2FtZSBrZXksIGlmIHRoZXkncmVcbiAgICAgICBbTm9kZV1zKSB3ZSBjYW4gdHJpdmlhbGx5IGRpZmYgZWFjaCBzdWJwYXJ0IGluIG9idmlvdXMgd2F5cy4gKilcbiAgICBsZXQgcmVjIGxvb3AgdCB0JyBhY2MgPVxuICAgICAgaWYgcGh5c19lcXVhbCB0IHQnXG4gICAgICB0aGVuIGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQsIHQnIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgbmV3X3ZhbHMgLT5cbiAgICAgICAgICBmb2xkIG5ld192YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCBhY2Mga2V5IGRhdGEpIFtAbm9udGFpbF1cbiAgICAgICAgfCBvbGRfdmFscywgRW1wdHkgLT5cbiAgICAgICAgICBmb2xkIG9sZF92YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSBhY2Mga2V5IGRhdGEpIFtAbm9udGFpbF1cbiAgICAgICAgfCBMZWFmIChrLCB2KSwgTGVhZiAoaycsIHYnKSAtPlxuICAgICAgICAgIChtYXRjaCBjb21wYXJlX2tleSBrIGsnIHdpdGhcbiAgICAgICAgICAgfCB4IHdoZW4geCA9IDAgLT4gZGVsdGEgYWNjIGsgdiB2J1xuICAgICAgICAgICB8IHggd2hlbiB4IDwgMCAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIGsgdiBpblxuICAgICAgICAgICAgIGFkZCBhY2MgaycgdidcbiAgICAgICAgICAgfCBfICgqIHdoZW4geCA+IDAgKikgLT5cbiAgICAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBrJyB2JyBpblxuICAgICAgICAgICAgIHJlbW92ZSBhY2MgayB2KVxuICAgICAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pLCBOb2RlIChsJywgaycsIHYnLCByJywgXykgd2hlbiBjb21wYXJlX2tleSBrIGsnID0gMCAtPlxuICAgICAgICAgIGxldCBhY2MgPSBsb29wIGwgbCcgYWNjIGluXG4gICAgICAgICAgbGV0IGFjYyA9IGRlbHRhIGFjYyBrIHYgdicgaW5cbiAgICAgICAgICBsb29wIHIgcicgYWNjXG4gICAgICAgICgqIE91ciByb290cyBhcmVuJ3QgdGhlIHNhbWUga2V5LiBGYWxsYmFjayB0byB0aGUgc2xvdyBtb2RlLiBUcmVlcyB3aXRoIHNtYWxsXG4gICAgICAgICAgIGRpZmZzIHdpbGwgb25seSBkbyB0aGlzIG9uIHZlcnkgc21hbGwgcGFydHMgb2YgdGhlIHRyZWUgKGhvcGVmdWxseSAtIGlmIHRoZVxuICAgICAgICAgICBvdmVyYWxsIHJvb3QgaXMgcmViYWxhbmNlZCwgd2UnbGwgZWF0IHRoZSB3aG9sZSBjb3N0LCB1bmZvcnR1bmF0ZWx5LikgKilcbiAgICAgICAgfCBOb2RlIF8sIE5vZGUgXyB8IE5vZGUgXywgTGVhZiBfIHwgTGVhZiBfLCBOb2RlIF8gLT4gc2xvdyB0IHQnIH5pbml0OmFjYylcbiAgICBpblxuICAgIGxvb3AgdDEgdDIgaW5pdCBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJlYyBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKGwsIF8sIF8sIHIsIF8pIC0+IGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQgPVxuICAgIGZvbGRcbiAgICAgIHRcbiAgICAgIH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgc3RhdGUgLT4gaGFzaF9mb2xkX2RhdGEgKGhhc2hfZm9sZF9rZXkgc3RhdGUga2V5KSBkYXRhKVxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpfIGxpc3QgLT4ga2V5IDo6IGxpc3QpIHQgfmluaXQ6W11cbiAgbGV0IGRhdGEgdCA9IGZvbGRfcmlnaHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIHQgfmluaXQ6W11cblxuICBtb2R1bGUgdHlwZSBGb2xkYWJsZSA9IHNpZ1xuICAgIHZhbCBuYW1lIDogc3RyaW5nXG5cbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2MgLT4gZjooKCdhY2MgLT4gJ2EgLT4gJ2FjYylbQGxvY2FsXSkgLT4gJ2FjY1xuICBlbmRcblxuICBsZXRbQGlubGluZSBhbHdheXNdIG9mX2ZvbGRhYmxlJyB+Zm9sZCBmb2xkYWJsZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIChmb2xkIFtAaW5saW5lZCBoaW50XSlcbiAgICAgIGZvbGRhYmxlXG4gICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICB+ZjooZnVuIHsgdHJlZSA9IGFjY3VtOyBsZW5ndGggfSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICBsZXQgcHJldl9kYXRhID1cbiAgICAgICAgICBtYXRjaCBmaW5kIGFjY3VtIGtleSB+Y29tcGFyZV9rZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBpbml0XG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gcHJldlxuICAgICAgICBpblxuICAgICAgICBsZXQgZGF0YSA9IGYgcHJldl9kYXRhIGRhdGEgaW5cbiAgICAgICAgKHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IHw+IGdsb2JhbGl6ZSkgW0Bub250YWlsXSkgW0Bub250YWlsXVxuICA7O1xuXG4gIG1vZHVsZSBPZl9mb2xkYWJsZSAoTSA6IEZvbGRhYmxlKSA9IHN0cnVjdFxuICAgIGxldCBvZl9mb2xkYWJsZV9mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBvZl9mb2xkYWJsZScgfmZvbGQ6TS5mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfcmVkdWNlIGZvbGRhYmxlIH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBNLmZvbGRcbiAgICAgICAgZm9sZGFibGVcbiAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICB+ZjooZnVuIHsgdHJlZSA9IGFjY3VtOyBsZW5ndGggfSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgIGxldCBuZXdfZGF0YSA9XG4gICAgICAgICAgICBtYXRjaCBmaW5kIGFjY3VtIGtleSB+Y29tcGFyZV9rZXkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgICAgICAgIHwgU29tZSBwcmV2IC0+IGYgcHJldiBkYXRhXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoc2V0IGFjY3VtIH5sZW5ndGggfmtleSB+ZGF0YTpuZXdfZGF0YSB+Y29tcGFyZV9rZXkgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxcbiAgICAgIF1cbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleSA9XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IG1hcCA9XG4gICAgICAgICAgTS5mb2xkXG4gICAgICAgICAgICBmb2xkYWJsZVxuICAgICAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICAgICAgfmY6KGZ1biB7IHRyZWUgPSB0OyBsZW5ndGggfSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgICBsZXQgKHsgdHJlZSA9IF87IGxlbmd0aCA9IGxlbmd0aCcgfSBhcyBhY2MpID1cbiAgICAgICAgICAgICAgICBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIHQgfmNvbXBhcmVfa2V5XG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCdcbiAgICAgICAgICAgICAgdGhlbiByLnJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KVxuICAgICAgICAgICAgICBlbHNlIGdsb2JhbGl6ZSBhY2MgW0Bub250YWlsXSlcbiAgICAgICAgaW5cbiAgICAgICAgYE9rIG1hcClcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX29yX2Vycm9yIGZvbGRhYmxlIH5jb21wYXJhdG9yID1cbiAgICAgIG1hdGNoIG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgICB8IGBPayB4IC0+IFJlc3VsdC5PayB4XG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgICBPcl9lcnJvci5lcnJvclxuICAgICAgICAgIChcIk1hcC5vZl9cIiBeIE0ubmFtZSBeIFwiX29yX2Vycm9yOiBkdXBsaWNhdGUga2V5XCIpXG4gICAgICAgICAga2V5XG4gICAgICAgICAgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX2V4biBmb2xkYWJsZSB+Y29tcGFyYXRvciA9XG4gICAgICBtYXRjaCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgICAgfCBgT2sgeCAtPiB4XG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgICBFcnJvci5jcmVhdGUgKFwiTWFwLm9mX1wiIF4gTS5uYW1lIF4gXCJfZXhuOiBkdXBsaWNhdGUga2V5XCIpIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgICB8PiBFcnJvci5yYWlzZVxuICAgIDs7XG5cbiAgICAoKiBSZXZlcnNlIHRoZSBpbnB1dCwgdGhlbiBmb2xkIGZyb20gbGVmdCB0byByaWdodC4gVGhlIHJlc3VsdGluZyBtYXAgdXNlcyB0aGUgZmlyc3RcbiAgICAgICBpbnN0YW5jZSBvZiBlYWNoIGtleSBmcm9tIHRoZSBpbnB1dCBsaXN0LiBUaGUgcmVsYXRpdmUgb3JkZXJpbmcgb2YgZWxlbWVudHMgaW4gZWFjaFxuICAgICAgIG91dHB1dCBsaXN0IGlzIHRoZSBzYW1lIGFzIGluIHRoZSBpbnB1dCBsaXN0LiAqKVxuICAgIGxldCBvZl9mb2xkYWJsZV9tdWx0aSBmb2xkYWJsZSB+Y29tcGFyZV9rZXkgPVxuICAgICAgbGV0IGFsaXN0ID0gTS5mb2xkIGZvbGRhYmxlIH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbCkgaW5cbiAgICAgIG9mX2ZvbGRhYmxlJyBhbGlzdCB+Zm9sZDpMaXN0LmZvbGQgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKSB+Y29tcGFyZV9rZXlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgT2ZfYWxpc3QgPSBPZl9mb2xkYWJsZSAoc3RydWN0XG4gICAgICBsZXQgbmFtZSA9IFwiYWxpc3RcIlxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgIGxldCBmb2xkID0gTGlzdC5mb2xkXG4gICAgZW5kKVxuXG4gIGxldCBvZl9hbGlzdF9mb2xkID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfZm9sZFxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfcmVkdWNlXG4gIGxldCBvZl9hbGlzdCA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX29yX2Vycm9yXG4gIGxldCBvZl9hbGlzdF9leG4gPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9leG5cbiAgbGV0IG9mX2FsaXN0X211bHRpID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfbXVsdGlcblxuICBtb2R1bGUgT2Zfc2VxdWVuY2UgPSBPZl9mb2xkYWJsZSAoc3RydWN0XG4gICAgICBsZXQgbmFtZSA9IFwic2VxdWVuY2VcIlxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBTZXF1ZW5jZS50XG5cbiAgICAgIGxldCBmb2xkID0gU2VxdWVuY2UuZm9sZFxuICAgIGVuZClcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2ZvbGRcbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX3JlZHVjZVxuICBsZXQgb2Zfc2VxdWVuY2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZVxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9vcl9lcnJvclxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfZXhuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX211bHRpXG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXkgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgbGV0IG1hcCA9XG4gICAgICAgIExpc3QuZm9sZFxuICAgICAgICAgIGxpc3RcbiAgICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICAgICAgfmY6KGZ1biB7IHRyZWUgPSB0OyBsZW5ndGggfSBkYXRhIC0+XG4gICAgICAgICAgICBsZXQga2V5ID0gZ2V0X2tleSBkYXRhIGluXG4gICAgICAgICAgICBsZXQgKHsgdHJlZSA9IF87IGxlbmd0aCA9IG5ld19sZW5ndGggfSBhcyBhY2MpID1cbiAgICAgICAgICAgICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGlmIGxlbmd0aCA9IG5ld19sZW5ndGhcbiAgICAgICAgICAgIHRoZW4gci5yZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSlcbiAgICAgICAgICAgIGVsc2UgZ2xvYmFsaXplIGFjYyBbQG5vbnRhaWxdKVxuICAgICAgaW5cbiAgICAgIGBPayBtYXApIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yID1cbiAgICBtYXRjaCBvZl9saXN0X3dpdGhfa2V5IGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB4IC0+IFJlc3VsdC5PayB4XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIE9yX2Vycm9yLmVycm9yXG4gICAgICAgIFwiTWFwLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3I6IGR1cGxpY2F0ZSBrZXlcIlxuICAgICAgICBrZXlcbiAgICAgICAgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9leG4gbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvciA9XG4gICAgbWF0Y2ggb2ZfbGlzdF93aXRoX2tleSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgeCAtPiB4XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIEVycm9yLmNyZWF0ZSBcIk1hcC5vZl9saXN0X3dpdGhfa2V5X2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgfD4gRXJyb3IucmFpc2VcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9tdWx0aSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGxpc3QgPSBMaXN0LnJldiBsaXN0IGluXG4gICAgTGlzdC5mb2xkIGxpc3QgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKSB+ZjooZnVuIHsgdHJlZSA9IHQ7IGxlbmd0aCB9IGRhdGEgLT5cbiAgICAgIGxldCBrZXkgPSBnZXRfa2V5IGRhdGEgaW5cbiAgICAgICh1cGRhdGUgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1biBvcHRpb24gLT5cbiAgICAgICAgIGxldCBsaXN0ID0gT3B0aW9uLnZhbHVlIG9wdGlvbiB+ZGVmYXVsdDpbXSBpblxuICAgICAgICAgZGF0YSA6OiBsaXN0KVxuICAgICAgIHw+IGdsb2JhbGl6ZSkgW0Bub250YWlsXSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmb3JfYWxsIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlciB0IH5mOihmdW4gZGF0YSAtPiBpZiBub3QgKGYgZGF0YSkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgICB0cnVlKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGxpIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgbm90IChmIH5rZXkgfmRhdGEpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgICAgdHJ1ZSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBleGlzdHMgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyIHQgfmY6KGZ1biBkYXRhIC0+IGlmIGYgZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgICAgZmFsc2UpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZXhpc3RzaSB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgICAgZmFsc2UpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgY291bnQgdCB+ZiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgY291bnRpIHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYykgW0Bub250YWlsXG4gICAgXVxuICA7O1xuXG4gIGxldCB0b19hbGlzdCA/KGtleV9vcmRlciA9IGBJbmNyZWFzaW5nKSB0ID1cbiAgICBtYXRjaCBrZXlfb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT4gZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gICAgfCBgRGVjcmVhc2luZyAtPiBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIHggLT4gKGtleSwgZGF0YSkgOjogeClcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZWx0cyA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46KGxlbmd0aCB0MSArIGxlbmd0aCB0MikgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlcjIgdDEgdDIgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleSB+ZGF0YTp2YWx1ZXMgLT5cbiAgICAgIG1hdGNoIGYgfmtleSB2YWx1ZXMgd2l0aFxuICAgICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICAgIFVuaWZvcm1fYXJyYXkuc2V0IGVsdHMgIWkgKGtleSwgdmFsdWUpO1xuICAgICAgICBpbmNyIGlcbiAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgbGV0IGxlbiA9ICFpIGluXG4gICAgbGV0IGdldCBpID0gVW5pZm9ybV9hcnJheS5nZXQgZWx0cyBpIGluXG4gICAgbGV0IHRyZWUgPSBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mOmdldCBpblxuICAgICAod2l0aF9sZW5ndGggdHJlZSBsZW4pXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCA9XG4gICAgbGV0IG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aF9sYXJnZSB0X2xhcmdlIHRfc21hbGwgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIGZvbGRcbiAgICAgICAgdF9zbWFsbFxuICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIHRfbGFyZ2UgbGVuZ3RoX2xhcmdlKVxuICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGE6ZGF0YScgeyB0cmVlID0gdDsgbGVuZ3RoIH0gLT5cbiAgICAgICAgICAodXBkYXRlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgICAgIHwgTm9uZSAtPiBkYXRhJ1xuICAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+IGNhbGwgY29tYmluZSB+a2V5IGRhdGEgZGF0YScpXG4gICAgICAgICAgIHw+IGdsb2JhbGl6ZSkgW0Bub250YWlsXSkgW0Bub250YWlsXVxuICAgIGluXG4gICAgbGV0IGNhbGwgZiB+a2V5IHggeSA9IGYgfmtleSB4IHkgaW5cbiAgICBsZXQgc3dhcCBmIH5rZXkgeCB5ID0gZiB+a2V5IHkgeCBpblxuICAgIGZ1biB0MSB0MiB+bGVuZ3RoMSB+bGVuZ3RoMiB+Y29tYmluZSB+Y29tcGFyZV9rZXkgLT5cbiAgICAgIGlmIGxlbmd0aDIgPD0gbGVuZ3RoMVxuICAgICAgdGhlbiBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGgxIHQxIHQyIH5jYWxsIH5jb21iaW5lIH5jb21wYXJlX2tleVxuICAgICAgZWxzZSBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGgyIHQyIHQxIH5jYWxsOnN3YXAgfmNvbWJpbmUgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbW9kdWxlIENsb3Nlc3Rfa2V5X2ltcGwgPSBzdHJ1Y3RcbiAgICAoKiBbbWFya2VyXSBhbmQgW3JlcGFja2FnZV0gYWxsb3cgdXMgdG8gY3JlYXRlIFwibG9naWNhbFwiIG9wdGlvbnMgd2l0aG91dCBhY3R1YWxseVxuICAgICAgIGFsbG9jYXRpbmcgYW55IG9wdGlvbnMuIFBhc3NpbmcgW0ZvdW5kIGtleSB2YWx1ZV0gdG8gYSBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgcGFzc2luZyBbU29tZSAoa2V5LCB2YWx1ZSldOyBwYXNzaW5nIFtNaXNzaW5nICgpICgpXSBpcyBlcXVpdmFsZW50IHRvIHBhc3NpbmdcbiAgICAgICBbTm9uZV0uICopXG4gICAgdHlwZSAoJ2ssICd2LCAna19vcHQsICd2X29wdCkgbWFya2VyID1cbiAgICAgIHwgTWlzc2luZyA6ICgnaywgJ3YsIHVuaXQsIHVuaXQpIG1hcmtlclxuICAgICAgfCBGb3VuZCA6ICgnaywgJ3YsICdrLCAndikgbWFya2VyXG5cbiAgICBsZXQgcmVwYWNrYWdlXG4gICAgICAgICAgKHR5cGUgayB2IGtfb3B0IHZfb3B0KVxuICAgICAgICAgIChtYXJrZXIgOiAoaywgdiwga19vcHQsIHZfb3B0KSBtYXJrZXIpXG4gICAgICAgICAgKGsgOiBrX29wdClcbiAgICAgICAgICAodiA6IHZfb3B0KVxuICAgICAgOiAoayAqIHYpIG9wdGlvblxuICAgICAgPVxuICAgICAgbWF0Y2ggbWFya2VyIHdpdGhcbiAgICAgIHwgTWlzc2luZyAtPiBOb25lXG4gICAgICB8IEZvdW5kIC0+IFNvbWUgKGssIHYpXG4gICAgOztcblxuICAgICgqIFRoZSB0eXBlIHNpZ25hdHVyZSBpcyBleHBsaWNpdCBoZXJlIHRvIGFsbG93IHBvbHltb3JwaGljIHJlY3Vyc2lvbi4gKilcbiAgICBsZXQgcmVjIGxvb3AgOlxuICAgICAgJ2sgJ3YgJ2tfb3B0ICd2X29wdC5cbiAgICAgICgnaywgJ3YpIHRyZWVcbiAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgIC0+ICdrXG4gICAgICAtPiBjb21wYXJlX2tleTooJ2sgLT4gJ2sgLT4gaW50KVxuICAgICAgLT4gKCdrLCAndiwgJ2tfb3B0LCAndl9vcHQpIG1hcmtlclxuICAgICAgLT4gJ2tfb3B0XG4gICAgICAtPiAndl9vcHRcbiAgICAgIC0+ICgnayAqICd2KSBvcHRpb25cbiAgICAgID1cbiAgICAgIGZ1biB0IGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIC0+XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgIHwgTGVhZiAoaycsIHYnKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgICAgIGlmIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIC0+IGMgPj0gMFxuICAgICAgICAgICAgfCBgR3JlYXRlcl90aGFuIC0+IGMgPiAwXG4gICAgICAgICAgICB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IGMgPD0gMFxuICAgICAgICAgICAgfCBgTGVzc190aGFuIC0+IGMgPCAwXG4gICAgICAgICAgdGhlbiBTb21lIChrJywgdicpXG4gICAgICAgICAgZWxzZSByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICB8IE5vZGUgKGwsIGsnLCB2JywgciwgXykgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgICAgICBpZiBjID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgKCogVGhpcyBpcyBhIGJhc2UgY2FzZSAobm8gcmVjdXJzaXZlIGNhbGwpLiAqKVxuICAgICAgICAgICAgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgTGVzc19vcl9lcXVhbF90byAtPiBTb21lIChrJywgdicpXG4gICAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgaXNfZW1wdHkgciB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWluX2VsdCByXG4gICAgICAgICAgICB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgaXNfZW1wdHkgbCB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWF4X2VsdCBsKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgKCogV2UgYXJlIGd1YXJhbnRlZWQgaGVyZSB0aGF0IGsnIDw+IGsuICopXG4gICAgICAgICAgICAoKiBUaGlzIGlzIHRoZSBvbmx5IHJlY3Vyc2l2ZSBjYXNlLiAqKVxuICAgICAgICAgICAgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGMgPiAwXG4gICAgICAgICAgICAgIHRoZW4gbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBGb3VuZCBrJyB2J1xuICAgICAgICAgICAgICBlbHNlIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgICAgICAgdGhlbiBsb29wIHIgZGlyIGsgfmNvbXBhcmVfa2V5IEZvdW5kIGsnIHYnXG4gICAgICAgICAgICAgIGVsc2UgbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlKVxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2VzdF9rZXkgdCBkaXIgayB+Y29tcGFyZV9rZXkgPSBsb29wIHQgZGlyIGsgfmNvbXBhcmVfa2V5IE1pc3NpbmcgKCkgKClcbiAgZW5kXG5cbiAgbGV0IGNsb3Nlc3Rfa2V5ID0gQ2xvc2VzdF9rZXlfaW1wbC5jbG9zZXN0X2tleVxuXG4gIGxldCByZWMgcmFuayB0IGsgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGsnLCBfKSAtPiBpZiBjb21wYXJlX2tleSBrJyBrID0gMCB0aGVuIFNvbWUgMCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGsnLCBfLCByLCBfKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiBTb21lIChsZW5ndGggbClcbiAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgIHRoZW4gcmFuayBsIGsgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIE9wdGlvbi5tYXAgKHJhbmsgciBrIH5jb21wYXJlX2tleSkgfmY6KGZ1biByYW5rIC0+IHJhbmsgKyAxICsgbGVuZ3RoIGwpXG4gIDs7XG5cbiAgKCogdGhpcyBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbU2VxdWVuY2VdIGludGVyZmFjZSBidXQgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICBhbGxvY2F0ZXMgb25seSAyIHdvcmRzIGFuZCBkb2Vzbid0IHJlcXVpcmUgd3JpdGUtYmFycmllciAqKVxuICBsZXQgcmVjIG50aCcgbnVtX3RvX3NlYXJjaCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPlxuICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICBlbHNlIChcbiAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICBOb25lKVxuICAgIHwgTm9kZSAobCwgaywgdiwgciwgXykgLT5cbiAgICAgIChtYXRjaCBudGgnIG51bV90b19zZWFyY2ggbCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiBzb21lXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBpZiAhbnVtX3RvX3NlYXJjaCA9IDBcbiAgICAgICAgIHRoZW4gU29tZSAoaywgdilcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBkZWNyIG51bV90b19zZWFyY2g7XG4gICAgICAgICAgIG50aCcgbnVtX3RvX3NlYXJjaCByKSlcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IG50aCcgKHJlZiBuKSB0XG5cblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIHYpIC0+IGlmIGYgfmtleTprIH5kYXRhOnYgdGhlbiBTb21lIChrLCB2KSBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pIC0+XG4gICAgICBpZiBmIH5rZXk6ayB+ZGF0YTp2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoaywgdilcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgciB+ZlxuICA7O1xuXG4gIGxldCByZWMgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPiBpZiBmIH5rZXk6ayB+ZGF0YTp2IHRoZW4gU29tZSAoaywgdikgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSAtPlxuICAgICAgaWYgZiB+a2V5OmsgfmRhdGE6dlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHIgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoaywgdilcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2xhc3Rfc2F0aXNmeWluZyBsIH5mXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPCAwKSBbQG5vbnRhaWxdXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDw9IDApIFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIChrZXksIGRhdGEpIGFzIHBhaXIgd2hlbiBjb21wYXJlIH5rZXkgfmRhdGEgdiA9IDAgLT4gcGFpclxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIChrZXksIGRhdGEpIGFzIHBhaXIgd2hlbiBjb21wYXJlIH5rZXkgfmRhdGEgdiA9IDAgLT4gcGFpclxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID49IDApIFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+IDApIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIGxldCBpc19sZWZ0IH5rZXkgfmRhdGEgPVxuICAgICAgbWF0Y2ggc2VnbWVudF9vZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBpc19yaWdodCB+a2V5IH5kYXRhID0gbm90IChpc19sZWZ0IH5rZXkgfmRhdGEpIGluXG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+Zjppc19sZWZ0IFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Zjppc19yaWdodCBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgKCogW2JpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXSBmaW5kcyB0aGUga2V5IGluIFt0XSB3aGljaCBzYXRpc2ZpZXMgW21heWJlX2JvdW5kXVxuICAgICBhbmQgdGhlIHJlbGV2YW50IG9uZSBvZiBbaWZfZXhjbHVzaXZlXSBvciBbaWZfaW5jbHVzaXZlXSwgYXMganVkZ2VkIGJ5IFtjb21wYXJlXS4gKilcbiAgbGV0IGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgfmlmX2V4Y2x1c2l2ZSB+aWZfaW5jbHVzaXZlID1cbiAgICBsZXQgZmluZF9ib3VuZCB0IGhvdyBib3VuZCB+Y29tcGFyZSA6IF8gTWF5YmVfYm91bmQudCBvcHRpb24gPVxuICAgICAgbWF0Y2ggYmluYXJ5X3NlYXJjaCB0IGhvdyBib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgICB8IFNvbWUgKGJvdW5kLCBfKSAtPiBTb21lIChJbmNsIGJvdW5kKVxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICBpblxuICAgIG1hdGNoIChtYXliZV9ib3VuZCA6IF8gTWF5YmVfYm91bmQudCkgd2l0aFxuICAgIHwgRXhjbCBib3VuZCAtPiBmaW5kX2JvdW5kIHQgaWZfZXhjbHVzaXZlIGJvdW5kIH5jb21wYXJlXG4gICAgfCBJbmNsIGJvdW5kIC0+IGZpbmRfYm91bmQgdCBpZl9pbmNsdXNpdmUgYm91bmQgfmNvbXBhcmVcbiAgICB8IFVuYm91bmRlZCAtPiBTb21lIFVuYm91bmRlZFxuICA7O1xuXG4gICgqIFtiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHNdIGZpbmRzIHRoZSAobm90IG5lY2Vzc2FyaWx5IGRpc3RpbmN0KSBrZXlzIGluIFt0XVxuICAgICB3aGljaCBtb3N0IGNsb3NlbHkgYXBwcm9hY2ggKGJ1dCBkbyBub3QgY3Jvc3MpIFtsb3dlcl9ib3VuZF0gYW5kIFt1cHBlcl9ib3VuZF0sIGFzXG4gICAgIGp1ZGdlZCBieSBbY29tcGFyZV0uIEl0IHJldHVybnMgW05vbmVdIGlmIG5vIGtleXMgaW4gW3RdIGFyZSB3aXRoaW4gdGhhdCByYW5nZS4gKilcbiAgbGV0IGJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBmaW5kX2xvd2VyX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgPVxuICAgICAgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRcbiAgICAgICAgdFxuICAgICAgICBtYXliZV9ib3VuZFxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICB+aWZfZXhjbHVzaXZlOmBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW5cbiAgICAgICAgfmlmX2luY2x1c2l2ZTpgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgaW5cbiAgICBsZXQgZmluZF91cHBlcl9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlID1cbiAgICAgIGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXG4gICAgICAgIHRcbiAgICAgICAgbWF5YmVfYm91bmRcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgfmlmX2V4Y2x1c2l2ZTpgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW5cbiAgICAgICAgfmlmX2luY2x1c2l2ZTpgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG9cbiAgICBpblxuICAgIG1hdGNoIGZpbmRfbG93ZXJfYm91bmQgdCBsb3dlcl9ib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgbG93ZXJfYm91bmQgLT5cbiAgICAgIChtYXRjaCBmaW5kX3VwcGVyX2JvdW5kIHQgdXBwZXJfYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgfCBTb21lIHVwcGVyX2JvdW5kIC0+IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkpXG4gIDs7XG5cblxuICB0eXBlICgnaywgJ3YpIGFjYyA9XG4gICAgeyBtdXRhYmxlIGJhZF9rZXkgOiAnayBvcHRpb25cbiAgICA7IG11dGFibGUgbWFwX2xlbmd0aCA6ICgnaywgJ3YpIHQgV2l0aF9sZW5ndGgudFxuICAgIH1cblxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFjYyA9IHsgYmFkX2tleSA9IE5vbmU7IG1hcF9sZW5ndGggPSB3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMCB9IGluXG4gICAgaXRlcmkgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBsZXQgeyB0cmVlID0gbWFwOyBsZW5ndGggfSA9IGFjYy5tYXBfbGVuZ3RoIGluXG4gICAgICBsZXQgKHsgdHJlZSA9IF87IGxlbmd0aCA9IGxlbmd0aCcgfSBhcyBwYWlyKSA9XG4gICAgICAgIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgbWFwIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCcgJiYgT3B0aW9uLmlzX25vbmUgYWNjLmJhZF9rZXlcbiAgICAgIHRoZW4gYWNjLmJhZF9rZXkgPC0gU29tZSBrZXlcbiAgICAgIGVsc2UgYWNjLm1hcF9sZW5ndGggPC0gZ2xvYmFsaXplIHBhaXIpO1xuICAgIG1hdGNoIGFjYy5iYWRfa2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gYE9rIGFjYy5tYXBfbGVuZ3RoXG4gICAgfCBTb21lIGtleSAtPiBgRHVwbGljYXRlX2tleSBrZXlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIG1hdGNoIG9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgRXJyb3IuY3JlYXRlIFwiTWFwLm9mX2l0ZXJpX2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgfD4gRXJyb3IucmFpc2VcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwIHNleHAgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBsZXQgYWxpc3QgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwKSBzZXhwIGluXG4gICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgbWF0Y2ggb2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAgICgqIGZpbmQgdGhlIHNleHAgb2YgYSBkdXBsaWNhdGUga2V5LCBzbyB0aGUgZXJyb3IgaXMgbmFycm93ZWQgdG8gYSBrZXkgYW5kIG5vdFxuICAgICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICAgIGxldCBmb3VuZF9maXJzdF9rID0gcmVmIGZhbHNlIGluXG4gICAgICBMaXN0Lml0ZXIyX29rIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgayBrMiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiTWFwLnRfb2Zfc2V4cF9kaXJlY3Q6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgICAgZWxzZSBmb3VuZF9maXJzdF9rIDo9IHRydWUpO1xuICAgICAgYXNzZXJ0IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbHVlIHQgPVxuICAgIGxldCBmIH5rZXkgfmRhdGEgYWNjID0gU2V4cC5MaXN0IFsgc2V4cF9vZl9rZXkga2V5OyBzZXhwX29mX3ZhbHVlIGRhdGEgXSA6OiBhY2MgaW5cbiAgICBTZXhwLkxpc3QgKGZvbGRfcmlnaHQgfmYgdCB+aW5pdDpbXSlcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCB+c2V4cF9vZl9rZXkgPVxuICAgIGxldCBva3MsIGVycm9ycyA9IHBhcnRpdGlvbl9tYXAgdCB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gICAgaWYgaXNfZW1wdHkgZXJyb3JzXG4gICAgdGhlbiBPayBva3NcbiAgICBlbHNlIE9yX2Vycm9yLmVycm9yX3MgKHNleHBfb2ZfdCBzZXhwX29mX2tleSBFcnJvci5zZXhwX29mX3QgZXJyb3JzKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5c1xuICAgICAgICB0MVxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcjooeyBjb21wYXJlID0gY29tcGFyZV9rZXk7IHNleHBfb2ZfdCA9IHNleHBfb2Zfa2V5IH0gOiBfIENvbXBhcmF0b3IudClcbiAgICA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBgT2tcbiAgICAgICAgKGZvbGRcbiAgICAgICAgICAgdDFcbiAgICAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgeyB0cmVlID0gdDI7IGxlbmd0aCB9IC0+XG4gICAgICAgICAgICAgbGV0IGtleSA9IGYga2V5IGluXG4gICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICBhZGRfZXhuX2ludGVybmFsIHQyIH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IHw+IGdsb2JhbGl6ZVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IER1cGxpY2F0ZSAtPiByZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSkpKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiB+Y29tcGFyYXRvciA9XG4gICAgbWF0Y2ggbWFwX2tleXMgdCB+ZiB+Y29tcGFyYXRvciB3aXRoXG4gICAgfCBgT2sgcmVzdWx0IC0+IHJlc3VsdFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBsZXQgc2V4cF9vZl9rZXkgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90IGluXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJNYXAubWFwX2tleXNfZXhuOiBkdXBsaWNhdGUga2V5XCIgWyBcImtleVwiLCBrZXkgfD4gc2V4cF9vZl9rZXkgXSlcbiAgOztcblxuICBsZXQgdHJhbnNwb3NlX2tleXMgfm91dGVyX2NvbXBhcmF0b3IgfmlubmVyX2NvbXBhcmF0b3Igb3V0ZXJfdCA9XG4gICAgZm9sZFxuICAgICAgb3V0ZXJfdFxuICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgfmY6KGZ1biB+a2V5Om91dGVyX2tleSB+ZGF0YTppbm5lcl90IGFjYyAtPlxuICAgICAgICBmb2xkXG4gICAgICAgICAgaW5uZXJfdFxuICAgICAgICAgIH5pbml0OmFjY1xuICAgICAgICAgIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgeyB0cmVlID0gYWNjOyBsZW5ndGggPSBhY2NfbGVuIH0gLT5cbiAgICAgICAgICAgICh1cGRhdGVcbiAgICAgICAgICAgICAgIGFjY1xuICAgICAgICAgICAgICAgaW5uZXJfa2V5XG4gICAgICAgICAgICAgICB+bGVuZ3RoOmFjY19sZW5cbiAgICAgICAgICAgICAgIH5jb21wYXJlX2tleTppbm5lcl9jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgICAgICAgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgIHwgTm9uZSAtPiB3aXRoX2xlbmd0aF9nbG9iYWwgKHNpbmdsZXRvbiBvdXRlcl9rZXkgZGF0YSkgMVxuICAgICAgICAgICAgICAgICB8IFNvbWUgeyB0cmVlID0gZWx0OyBsZW5ndGggPSBlbHRfbGVuIH0gLT5cbiAgICAgICAgICAgICAgICAgICAoc2V0XG4gICAgICAgICAgICAgICAgICAgICAgZWx0XG4gICAgICAgICAgICAgICAgICAgICAgfmtleTpvdXRlcl9rZXlcbiAgICAgICAgICAgICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgICAgICAgICAgIH5sZW5ndGg6ZWx0X2xlblxuICAgICAgICAgICAgICAgICAgICAgIH5jb21wYXJlX2tleTpvdXRlcl9jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgICAgICAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pXG4gICAgICAgICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSlcbiAgOztcblxuICBtb2R1bGUgTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBIDogQXBwbGljYXRpdmUuTGF6eV9hcHBsaWNhdGl2ZSkgPSBzdHJ1Y3RcbiAgICBsZXQgcmVjIG1hcGkgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQS5yZXR1cm4gRW1wdHlcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gQS5tYXAgKGYgfmtleTp2IH5kYXRhOmQpIH5mOihmdW4gbmV3X2RhdGEgLT4gTGVhZiAodiwgbmV3X2RhdGEpKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgICBsZXQgbCcgPSBBLm9mX3RodW5rIChmdW4gKCkgLT4gbWFwaSB+ZiBsKSBpblxuICAgICAgICBsZXQgZCcgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICAgIGxldCByJyA9IEEub2ZfdGh1bmsgKGZ1biAoKSAtPiBtYXBpIH5mIHIpIGluXG4gICAgICAgIEEubWFwMyBsJyBkJyByJyB+ZjooZnVuIGwnIGQnIHInIC0+IE5vZGUgKGwnLCB2LCBkJywgcicsIGgpKVxuICAgIDs7XG5cbiAgICAoKiBJbiB0aGVvcnkgdGhlIGNvbXB1dGF0aW9uIG9mIGxlbmd0aCBvbi10aGUtZmx5IGlzIG5vdCBuZWNlc3NhcnkgaGVyZSBiZWNhdXNlIGl0IGNhblxuICAgICAgIGJlIGRvbmUgYnkgd3JhcHBpbmcgdGhlIGFwcGxpY2F0aXZlIFtBXSB3aXRoIGxlbmd0aC1jb21wdXRpbmcgbG9naWMuIEhvd2V2ZXIsXG4gICAgICAgaW50cm9kdWNpbmcgYW4gYXBwbGljYXRpdmUgdHJhbnNmb3JtZXIgbGlrZSB0aGF0IG1ha2VzIHRoZSBtYXAgYmVuY2htYXJrcyBpblxuICAgICAgIGFzeW5jX2tlcm5lbC9iZW5jaC9zcmMvYmVuY2hfZGVmZXJyZWRfbWFwLm1sIG5vdGljZWFibHkgc2xvd2VyLiAqKVxuICAgIGxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgICAgIGxldCByZWMgdHJlZV9maWx0ZXJfbWFwaSB0IH5mID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gQS5yZXR1cm4gKHdpdGhfbGVuZ3RoX2dsb2JhbCBFbXB0eSAwKVxuICAgICAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICAgICAgQS5tYXAgKGYgfmtleTp2IH5kYXRhOmQpIH5mOihmdW5jdGlvblxuICAgICAgICAgICAgfCBTb21lIG5ld19kYXRhIC0+IHdpdGhfbGVuZ3RoX2dsb2JhbCAoTGVhZiAodiwgbmV3X2RhdGEpKSAxXG4gICAgICAgICAgICB8IE5vbmUgLT4gd2l0aF9sZW5ndGhfZ2xvYmFsIEVtcHR5IDApXG4gICAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgICBBLm1hcDNcbiAgICAgICAgICAgIChBLm9mX3RodW5rIChmdW4gKCkgLT4gdHJlZV9maWx0ZXJfbWFwaSBsIH5mKSlcbiAgICAgICAgICAgIChmIH5rZXk6diB+ZGF0YTpkKVxuICAgICAgICAgICAgKEEub2ZfdGh1bmsgKGZ1biAoKSAtPiB0cmVlX2ZpbHRlcl9tYXBpIHIgfmYpKVxuICAgICAgICAgICAgfmY6XG4gICAgICAgICAgICAgIChmdW5cbiAgICAgICAgICAgICAgICB7IHRyZWUgPSBsJzsgbGVuZ3RoID0gbF9sZW4gfSBuZXdfZGF0YSB7IHRyZWUgPSByJzsgbGVuZ3RoID0gcl9sZW4gfSAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIG5ld19kYXRhIHdpdGhcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2RhdGEgLT5cbiAgICAgICAgICAgICAgICAgIHdpdGhfbGVuZ3RoX2dsb2JhbCAoam9pbiBsJyB2IG5ld19kYXRhIHInKSAobF9sZW4gKyByX2xlbiArIDEpXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICB3aXRoX2xlbmd0aF9nbG9iYWwgKGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpIChsX2xlbiArIHJfbGVuKSlcbiAgICAgIGluXG4gICAgICB0cmVlX2ZpbHRlcl9tYXBpIHQgfmZcbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2ssICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogKCdrLCAndikgVHJlZTAudFxuICA7IGxlbmd0aCA6IGludFxuICB9XG5cbnR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAoJ2ssICd2KSBUcmVlMC50XG5cbmxldCBjb21wYXJlX2tleSB0ID0gdC5jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG5cbmxldCBsaWtlIHsgdHJlZSA9IF87IGxlbmd0aCA9IF87IGNvbXBhcmF0b3IgfSAoeyB0cmVlOyBsZW5ndGggfSA6IF8gV2l0aF9sZW5ndGgudCkgPVxuICB7IHRyZWU7IGxlbmd0aDsgY29tcGFyYXRvciB9XG47O1xuXG5sZXQgbGlrZV9tYXliZV9ub19vcFxuICAgICAgKHsgdHJlZSA9IG9sZF90cmVlOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gYXMgb2xkX3QpXG4gICAgICAoeyB0cmVlOyBsZW5ndGggfSA6IF8gV2l0aF9sZW5ndGgudClcbiAgPVxuICBpZiBwaHlzX2VxdWFsIG9sZF90cmVlIHRyZWUgdGhlbiBvbGRfdCBlbHNlIHsgdHJlZTsgbGVuZ3RoOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCB3aXRoX3NhbWVfbGVuZ3RoIHsgdHJlZSA9IF87IGNvbXBhcmF0b3I7IGxlbmd0aCB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5sZXQgb2ZfbGlrZV90cmVlIHQgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvciA9IHQuY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG5sZXQgb2ZfbGlrZV90cmVlX21heWJlX25vX29wIHQgdHJlZSA9XG4gIGlmIHBoeXNfZXF1YWwgdC50cmVlIHRyZWVcbiAgdGhlbiB0XG4gIGVsc2UgeyB0cmVlOyBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG47O1xuXG5sZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbigqIEV4cG9zaW5nIHRoaXMgZnVuY3Rpb24gd291bGQgbWFrZSBpdCB2ZXJ5IGVhc3kgZm9yIHRoZSBpbnZhcmlhbnRzXG4gICBvZiB0aGlzIG1vZHVsZSB0byBiZSBicm9rZW4uICopXG5sZXQgb2ZfdHJlZV91bnNhZmUgfmNvbXBhcmF0b3Igfmxlbmd0aCB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggfVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBjb21wYXJhdG9yIHQgPSB0LmNvbXBhcmF0b3JcbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuXG4gIGxldCBpbnZhcmlhbnRzIHQgPVxuICAgIFRyZWUwLmludmFyaWFudHMgdC50cmVlIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgJiYgVHJlZTAubGVuZ3RoIHQudHJlZSA9IHQubGVuZ3RoXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0LnRyZWVcbiAgbGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcblxuICBsZXQgc2V0IHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLnNldCB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9leG5cbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmxlbmd0aDp0Lmxlbmd0aFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4bl9pbnRlcm5hbFxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gICAgbWF0Y2ggYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgcmVzdWx0IC0+IGBPayByZXN1bHRcbiAgICB8IGV4Y2VwdGlvbiBEdXBsaWNhdGUgLT4gYER1cGxpY2F0ZVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLnJlbW92ZV9tdWx0aSB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgdCBrZXkgPSBUcmVlMC5maW5kX211bHRpIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCBjaGFuZ2UgdCBrZXkgfmYgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5jaGFuZ2UgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCB1cGRhdGUgdCBrZXkgfmYgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC51cGRhdGUgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHQudHJlZVxuICAgICAga2V5XG4gICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIHQga2V5ID0gVHJlZTAuZmluZCB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcblxuICBsZXQgcmVtb3ZlIHQga2V5ID1cbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICB0XG4gICAgICAoVHJlZTAucmVtb3ZlIHQudHJlZSBrZXkgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1lbSB0IGtleSA9IFRyZWUwLm1lbSB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IGl0ZXJfa2V5cyB0IH5mID0gVHJlZTAuaXRlcl9rZXlzIHQudHJlZSB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpIHQgfmYgPSBUcmVlMC5pdGVyaSB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpX3VudGlsIHQgfmYgPSBUcmVlMC5pdGVyaV91bnRpbCB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIyIHQxIHQyIH5mID0gVHJlZTAuaXRlcjIgdDEudHJlZSB0Mi50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIGxldCBtYXAgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwIHQudHJlZSB+ZilcbiAgbGV0IG1hcGkgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwaSB0LnRyZWUgfmYpXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+aW5pdCB+ZiB+ZmluaXNoXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQudHJlZSB+ZiB+aW5pdFxuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZDIgdDEudHJlZSB0Mi50cmVlIH5pbml0IH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgPVxuICAgIGxldCBsZW4gPSAgKHJlZiB0Lmxlbmd0aCkgaW5cbiAgICBsZXQgdHJlZSA9IFRyZWUwLmZpbHRlcl9rZXlzIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZV9tYXliZV9ub19vcCB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyIHQgfmYgPVxuICAgIGxldCBsZW4gPSAgKHJlZiB0Lmxlbmd0aCkgaW5cbiAgICBsZXQgdHJlZSA9IFRyZWUwLmZpbHRlciB0LnRyZWUgfmYgfmxlbiBpblxuICAgIGxpa2VfbWF5YmVfbm9fb3AgdCAod2l0aF9sZW5ndGggdHJlZSAhbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcmkgdCB+ZiA9XG4gICAgbGV0IGxlbiA9ICAocmVmIHQubGVuZ3RoKSBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyaSB0LnRyZWUgfmYgfmxlbiBpblxuICAgIGxpa2VfbWF5YmVfbm9fb3AgdCAod2l0aF9sZW5ndGggdHJlZSAhbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gICAgbGV0IGxlbiA9ICAocmVmIHQubGVuZ3RoKSBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyX21hcCB0LnRyZWUgfmYgfmxlbiBpblxuICAgIGxpa2UgdCAod2l0aF9sZW5ndGggdHJlZSAhbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgIGxldCBsZW4gPSAgKHJlZiB0Lmxlbmd0aCkgaW5cbiAgICBsZXQgdHJlZSA9IFRyZWUwLmZpbHRlcl9tYXBpIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZSB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2ZfbGlrZV90cmVlMiB0ICh0MSwgdDIpID0gb2ZfbGlrZV90cmVlIHQgdDEsIG9mX2xpa2VfdHJlZSB0IHQyXG5cbiAgbGV0IG9mX2xpa2VfdHJlZTJfbWF5YmVfbm9fb3AgdCAodDEsIHQyKSA9XG4gICAgb2ZfbGlrZV90cmVlX21heWJlX25vX29wIHQgdDEsIG9mX2xpa2VfdHJlZV9tYXliZV9ub19vcCB0IHQyXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPSBvZl9saWtlX3RyZWUyIHQgKFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQudHJlZSB+ZilcbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IG9mX2xpa2VfdHJlZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcCB0LnRyZWUgfmYpXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPSBvZl9saWtlX3RyZWUyX21heWJlX25vX29wIHQgKFRyZWUwLnBhcnRpdGlvbmlfdGYgdC50cmVlIH5mKVxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBvZl9saWtlX3RyZWUyX21heWJlX25vX29wIHQgKFRyZWUwLnBhcnRpdGlvbl90ZiB0LnRyZWUgfmYpXG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIHQgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KG9mX2xpa2VfdHJlZSB0KVxuICAgICAgKFRyZWUwLmNvbWJpbmVfZXJyb3JzIHQudHJlZSB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5jb21wYXJlIChjb21wYXJlX2tleSB0MSkgY29tcGFyZV9kYXRhIHQxLnRyZWUgdDIudHJlZVxuICA7O1xuXG4gIGxldCBlcXVhbCBjb21wYXJlX2RhdGEgdDEgdDIgPSBUcmVlMC5lcXVhbCAoY29tcGFyZV9rZXkgdDEpIGNvbXBhcmVfZGF0YSB0MS50cmVlIHQyLnRyZWVcbiAgbGV0IGtleXMgdCA9IFRyZWUwLmtleXMgdC50cmVlXG4gIGxldCBkYXRhIHQgPSBUcmVlMC5kYXRhIHQudHJlZVxuICBsZXQgdG9fYWxpc3QgP2tleV9vcmRlciB0ID0gVHJlZTAudG9fYWxpc3QgP2tleV9vcmRlciB0LnRyZWVcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSB+ZGF0YV9lcXVhbFxuICA7O1xuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICB0MS50cmVlXG4gICAgICB0Mi50cmVlXG4gICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKVxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA7O1xuXG4gIGxldCBtZXJnZSB0MSB0MiB+ZiA9XG4gICAgbGlrZSB0MSAoVHJlZTAubWVyZ2UgdDEudHJlZSB0Mi50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCB0MSB0MiB+Y29tYmluZSA9XG4gICAgKCogVGhpcyBpcyBvbmx5IGEgbm8tb3AgaW4gdGhlIGNhc2Ugd2hlcmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBtYXBzIGlzIGVtcHR5LiAqKVxuICAgIGxpa2VfbWF5YmVfbm9fb3BcbiAgICAgIChpZiB0Mi5sZW5ndGggPD0gdDEubGVuZ3RoIHRoZW4gdDEgZWxzZSB0MilcbiAgICAgIChUcmVlMC5tZXJnZV9za2V3ZWRcbiAgICAgICAgIHQxLnRyZWVcbiAgICAgICAgIHQyLnRyZWVcbiAgICAgICAgIH5sZW5ndGgxOnQxLmxlbmd0aFxuICAgICAgICAgfmxlbmd0aDI6dDIubGVuZ3RoXG4gICAgICAgICB+Y29tYmluZVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkpXG4gIDs7XG5cbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdC50cmVlXG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdC50cmVlXG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHQudHJlZVxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHQudHJlZVxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0LnRyZWUgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBUcmVlMC5mb3JfYWxsaSB0LnRyZWUgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQudHJlZSB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gVHJlZTAuZXhpc3RzaSB0LnRyZWUgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0LnRyZWUgfmZcbiAgbGV0IGNvdW50aSB0IH5mID0gVHJlZTAuY291bnRpIHQudHJlZSB+ZlxuXG4gIGxldCBzcGxpdCB0IGsgPVxuICAgIGxldCBsLCBtYXliZSwgciA9IFRyZWUwLnNwbGl0IHQudHJlZSBrIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgaW5cbiAgICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgdCBpblxuICAgICgqIFRyeSB0byB0cmF2ZXJzZSB0aGUgbGVhc3QgYW1vdW50IHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoLFxuICAgICAgIHVzaW5nIGhlaWdodCBhcyBhIGhldXJpc3RpYy4gKilcbiAgICBsZXQgYm90aF9sZW4gPSBpZiBPcHRpb24uaXNfc29tZSBtYXliZSB0aGVuIHQubGVuZ3RoIC0gMSBlbHNlIHQubGVuZ3RoIGluXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG1heWJlLCBvZl90cmVlX3Vuc2FmZSByIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIGwpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBvZl90cmVlIHIgfmNvbXBhcmF0b3IgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIGwgfmNvbXBhcmF0b3Igfmxlbmd0aDooYm90aF9sZW4gLSBsZW5ndGggciksIG1heWJlLCByKVxuICA7O1xuXG4gIGxldCBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdCB+aW50byBrID1cbiAgICBsZXQgbCwgciA9XG4gICAgICBUcmVlMC5zcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdC50cmVlIH5pbnRvIGsgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgIGluXG4gICAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHQgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG9mX3RyZWVfdW5zYWZlIHIgfmNvbXBhcmF0b3Igfmxlbmd0aDoodC5sZW5ndGggLSBsZW5ndGggbCkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgciA9IG9mX3RyZWUgciB+Y29tcGFyYXRvciBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbCB+Y29tcGFyYXRvciB+bGVuZ3RoOih0Lmxlbmd0aCAtIGxlbmd0aCByKSwgcilcbiAgOztcblxuICBsZXQgc3BsaXRfbGVfZ3QgdCBrID0gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG86YExlZnQga1xuICBsZXQgc3BsaXRfbHRfZ2UgdCBrID0gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG86YFJpZ2h0IGtcblxuICBsZXQgc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgbGVmdCwgbWlkLCByaWdodCA9XG4gICAgICBUcmVlMC5zcGxpdF9yYW5nZSB0LnRyZWUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IG91dGVyX2pvaW5lZF9oZWlnaHQgPVxuICAgICAgbGV0IGhfbCA9IFRyZWUwLmhlaWdodCBsZWZ0XG4gICAgICBhbmQgaF9yID0gVHJlZTAuaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpZiBoX2wgPSBoX3IgdGhlbiBoX2wgKyAxIGVsc2UgbWF4IGhfbCBoX3JcbiAgICBpblxuICAgIGlmIG91dGVyX2pvaW5lZF9oZWlnaHQgPCBUcmVlMC5oZWlnaHQgbWlkXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbWlkX2xlbmd0aCA9IHQubGVuZ3RoIC0gKFRyZWUwLmxlbmd0aCBsZWZ0ICsgVHJlZTAubGVuZ3RoIHJpZ2h0KSBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpIH5sZW5ndGg6bWlkX2xlbmd0aClcbiAgICBlbHNlIG9mX3RyZWUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgbWF0Y2hcbiAgICAgIFRyZWUwLmFwcGVuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IGxvd2VyX3BhcnQpXG4gICAgICAgIH5sb3dlcl9wYXJ0Omxvd2VyX3BhcnQudHJlZVxuICAgICAgICB+dXBwZXJfcGFydDp1cHBlcl9wYXJ0LnRyZWVcbiAgICB3aXRoXG4gICAgfCBgT2sgdHJlZSAtPlxuICAgICAgYE9rXG4gICAgICAgIChvZl90cmVlX3Vuc2FmZVxuICAgICAgICAgICB0cmVlXG4gICAgICAgICAgIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIGxvd2VyX3BhcnQpXG4gICAgICAgICAgIH5sZW5ndGg6KGxvd2VyX3BhcnQubGVuZ3RoICsgdXBwZXJfcGFydC5sZW5ndGgpKVxuICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQudHJlZSB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCA9XG4gICAgVHJlZTAucmFuZ2VfdG9fYWxpc3QgdC50cmVlIH5taW4gfm1heCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGtleSA9XG4gICAgVHJlZTAuY2xvc2VzdF9rZXkgdC50cmVlIGRpciBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gVHJlZTAubnRoIHQudHJlZSBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIHQga2V5ID0gVHJlZTAucmFuayB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdC50cmVlIH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB3aXRoXG4gICAgfCBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIC0+IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHwgTm9uZSAtPiBsaWtlX21heWJlX25vX29wIHQgKHdpdGhfbGVuZ3RoIFRyZWUwLkVtcHR5IDApIFtAbm9udGFpbF1cbiAgOztcblxuICBtb2R1bGUgTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBIDogQXBwbGljYXRpdmUuTGF6eV9hcHBsaWNhdGl2ZSkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVHJlZV90cmF2ZXJzYWxzID0gVHJlZTAuTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBKVxuXG4gICAgbGV0IG1hcGkgdCB+ZiA9XG4gICAgICBBLm1hcCAoVHJlZV90cmF2ZXJzYWxzLm1hcGkgdC50cmVlIH5mKSB+ZjooZnVuIG5ld190cmVlIC0+XG4gICAgICAgIHdpdGhfc2FtZV9sZW5ndGggdCBuZXdfdHJlZSlcbiAgICA7O1xuXG4gICAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgICAgQS5tYXAgKFRyZWVfdHJhdmVyc2Fscy5maWx0ZXJfbWFwaSB0LnRyZWUgfmYpIH5mOihmdW4gbmV3X3RyZWVfd2l0aF9sZW5ndGggLT5cbiAgICAgICAgbGlrZSB0IG5ld190cmVlX3dpdGhfbGVuZ3RoKVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbigqIFswXSBpcyB1c2VkIGFzIHRoZSBbbGVuZ3RoXSBhcmd1bWVudCBldmVyeXdoZXJlIGluIHRoaXMgbW9kdWxlLCBzaW5jZSB0cmVlcyBkbyBub3RcbiAgIGhhdmUgdGhlaXIgbGVuZ3RocyBzdG9yZWQgYXQgdGhlIHJvb3QsIHVubGlrZSBtYXBzLiBUaGUgdmFsdWVzIGFyZSBkaXNjYXJkZWQgYWx3YXlzLiAqKVxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9ICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0cmVlID0gdHJlZVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gayB2ID0gVHJlZTAuc2luZ2xldG9uIGsgdlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgLnRyZWVcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoID0gXyB9IC0+IGBPayB0cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvclxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9IChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpLnRyZWVcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCA9IF8gfSAtPiBgT2sgdHJlZVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9IChUcmVlMC5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yKS50cmVlXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl9yZXF1aXJlZF9ieV9pbnRmIH5sZW4gfmYgPVxuICAgIFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggPSBfIH0gLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBUcmVlMC5vZl9zZXF1ZW5jZV9vcl9lcnJvciBzZXEgfmNvbXBhcmF0b3JcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID0gKFRyZWUwLm9mX3NlcXVlbmNlX2V4biBzZXEgfmNvbXBhcmF0b3IpLnRyZWVcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICAoVHJlZTAub2Zfc2VxdWVuY2VfbXVsdGkgc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgKFRyZWUwLm9mX3NlcXVlbmNlX2ZvbGQgc2VxIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICAoVHJlZTAub2Zfc2VxdWVuY2VfcmVkdWNlIHNlcSB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAub2ZfbGlzdF93aXRoX2tleSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggPSBfIH0gLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIGxpc3QgfmdldF9rZXkgfmNvbXBhcmF0b3JcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2V4biB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9leG4gbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvcikudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIChUcmVlMC5vZl9saXN0X3dpdGhfa2V5X211bHRpXG4gICAgICAgbGlzdFxuICAgICAgIH5nZXRfa2V5XG4gICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgIC50cmVlXG4gIDs7XG5cbiAgbGV0IHRvX3RyZWUgdCA9IHRcblxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID1cbiAgICBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG5cbiAgbGV0IHNldCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5zZXQgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgYWRkX2V4biB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5hZGRfZXhuXG4gICAgICAgdFxuICAgICAgIH5rZXlcbiAgICAgICB+ZGF0YVxuICAgICAgIH5sZW5ndGg6MFxuICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgICAudHJlZVxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgKFRyZWUwLmFkZF9leG5faW50ZXJuYWxcbiAgICAgICB0XG4gICAgICAgfmtleVxuICAgICAgIH5kYXRhXG4gICAgICAgfmxlbmd0aDowXG4gICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICAgIC50cmVlXG4gIDs7XG5cbiAgbGV0IGFkZCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIHRyeSBgT2sgKGFkZF9leG5faW50ZXJuYWwgdCB+Y29tcGFyYXRvciB+a2V5IH5kYXRhKSB3aXRoXG4gICAgfCBfIC0+IGBEdXBsaWNhdGVcbiAgOztcblxuICBsZXQgYWRkX211bHRpIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgKFRyZWUwLmFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgICAudHJlZVxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIChUcmVlMC5yZW1vdmVfbXVsdGkgdCBrZXkgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX211bHRpIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIChUcmVlMC5jaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCB1cGRhdGUgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIGNoYW5nZSB+Y29tcGFyYXRvciB0IGtleSB+ZjooZnVuIGRhdGEgLT4gU29tZSAoZiBkYXRhKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHRcbiAgICAgIGtleVxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAuZmluZCB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICAoVHJlZTAucmVtb3ZlIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAubWVtIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBpdGVyaSB0IH5mID0gVHJlZTAuaXRlcmkgdCB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQgfmZcblxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIFRyZWUwLml0ZXIyIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mXG4gIGxldCBtYXBpIHQgfmYgPSBUcmVlMC5tYXBpIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQgfmYgfmluaXQgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIH5jb21wYXJhdG9yIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiA9IFRyZWUwLmZpbHRlcl9rZXlzIHQgfmYgfmxlbjooIChyZWYgMCkpIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlciB0IH5mID0gVHJlZTAuZmlsdGVyIHQgfmYgfmxlbjooIChyZWYgMCkpIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcmkgdCB+ZiA9IFRyZWUwLmZpbHRlcmkgdCB+ZiB+bGVuOiggKHJlZiAwKSkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyX21hcCB0IH5mID0gVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5sZW46KCAocmVmIDApKSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mID0gVHJlZTAuZmlsdGVyX21hcGkgdCB+ZiB+bGVuOiggKHJlZiAwKSkgW0Bub250YWlsXVxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQgfmZcbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl9tYXAgdCB+ZlxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mID0gVHJlZTAucGFydGl0aW9uaV90ZiB0IH5mXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mXG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIH5jb21wYXJhdG9yIHQgPVxuICAgIFRyZWUwLmNvbWJpbmVfZXJyb3JzIHQgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgfmNvbXBhcmF0b3IgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5jb21wYXJlIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmVxdWFsIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHRcbiAgbGV0IGRhdGEgdCA9IFRyZWUwLmRhdGEgdFxuICBsZXQgdG9fYWxpc3QgP2tleV9vcmRlciB0ID0gVHJlZTAudG9fYWxpc3QgP2tleV9vcmRlciB0XG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDFcbiAgICAgIHQyXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIChUcmVlMC5tZXJnZSB0MSB0MiB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkIH5jb21wYXJhdG9yIHQxIHQyIH5jb21iaW5lID1cbiAgICAoKiBMZW5ndGggY29tcHV0YXRpb24gbWFrZXMgdGhpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIFttZXJnZV9za2V3ZWRdIG9uIGEgbWFwXG4gICAgICAgd2l0aCBhIFtsZW5ndGhdIGZpZWxkLCBidXQgZG9lcyBwcmVzZXJ2ZSBhbW91bnQgb2YgYWxsb2NhdGlvbi4gKilcbiAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgdDFcbiAgICAgICB0MlxuICAgICAgIH5sZW5ndGgxOihsZW5ndGggdDEpXG4gICAgICAgfmxlbmd0aDI6KGxlbmd0aCB0MilcbiAgICAgICB+Y29tYmluZVxuICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgICAudHJlZVxuICA7O1xuXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHRcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0XG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHRcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0XG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBUcmVlMC5mb3JfYWxsaSB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0IH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBUcmVlMC5leGlzdHNpIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0IH5mXG4gIGxldCBjb3VudGkgdCB+ZiA9IFRyZWUwLmNvdW50aSB0IH5mXG4gIGxldCBzcGxpdCB+Y29tcGFyYXRvciB0IGsgPSBUcmVlMC5zcGxpdCB0IGsgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHNwbGl0X2xlX2d0IH5jb21wYXJhdG9yIHQgayA9XG4gICAgVHJlZTAuc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5XG4gICAgICB0XG4gICAgICB+aW50bzpgTGVmdFxuICAgICAga1xuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2x0X2dlIH5jb21wYXJhdG9yIHQgayA9XG4gICAgVHJlZTAuc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5XG4gICAgICB0XG4gICAgICB+aW50bzpgUmlnaHRcbiAgICAgIGtcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmNvbXBhcmF0b3Igfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgPVxuICAgIFRyZWUwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgXywgcmV0LCBfID1cbiAgICAgIFRyZWUwLnNwbGl0X3JhbmdlXG4gICAgICAgIHRcbiAgICAgICAgfmxvd2VyX2JvdW5kXG4gICAgICAgIH51cHBlcl9ib3VuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHJldFxuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSB+Y29tcGFyYXRvciB0IH5taW4gfm1heCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgIHRcbiAgICAgIH5taW5cbiAgICAgIH5tYXhcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4ID1cbiAgICBUcmVlMC5yYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgY2xvc2VzdF9rZXkgfmNvbXBhcmF0b3IgdCBkaXIga2V5ID1cbiAgICBUcmVlMC5jbG9zZXN0X2tleSB0IGRpciBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBUcmVlMC5udGggdCBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAucmFuayB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHRcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcikudHJlZVxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggfmNvbXBhcmF0b3I6XyB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIH5jb21wYXJhdG9yOl8gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBtYXRjaCBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIHdpdGhcbiAgICB8IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkgLT4gc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgfCBOb25lIC0+IEVtcHR5XG4gIDs7XG5cbiAgbW9kdWxlIE1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSA6IEFwcGxpY2F0aXZlLkxhenlfYXBwbGljYXRpdmUpID0gc3RydWN0XG4gICAgbW9kdWxlIFRyZWUwX3RyYXZlcnNhbHMgPSBUcmVlMC5NYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEpXG5cbiAgICBsZXQgbWFwaSB0IH5mID0gVHJlZTBfdHJhdmVyc2Fscy5tYXBpIHQgfmZcblxuICAgIGxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgICAgIEEubWFwXG4gICAgICAgIChUcmVlMF90cmF2ZXJzYWxzLmZpbHRlcl9tYXBpIHQgfmYpXG4gICAgICAgIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiB3aXRoXG4gICAgfCBgT2sgeyB0cmVlID0gdDsgbGVuZ3RoID0gXyB9IC0+IGBPayB0XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGR1cCAtPiBkdXBcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYgPSAoVHJlZTAubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYpLnRyZWVcblxuICAoKiBUaGlzIGNhbGxpbmcgY29udmVudGlvbiBvZiBbfmNvbXBhcmF0b3IgfmNvbXBhcmF0b3JdIGlzIGNvbmZ1c2luZy4gSXQgaXMgcmVxdWlyZWRcbiAgICAgYmVjYXVzZSBbYWNjZXNzX29wdGlvbnNdIGFuZCBbY3JlYXRlX29wdGlvbnNdIGJvdGggZGVtYW5kIGEgW35jb21wYXJhdG9yXSBhcmd1bWVudCBpblxuICAgICBbTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZV0uXG5cbiAgICAgTWFraW5nIGl0IGxlc3MgY29uZnVzaW5nIHdvdWxkIHJlcXVpcmUgc29tZSB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5IGluIHNpZ25hdHVyZXMuXG4gICAgIEJldHRlciB0byBqdXN0IGxpdmUgd2l0aCBhbiB1bmRlc2lyYWJsZSBpbnRlcmZhY2UgaW4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvYmFibHlcbiAgICAgbmV2ZXIgYmUgY2FsbGVkIGRpcmVjdGx5LiAqKVxuICBsZXQgdHJhbnNwb3NlX2tleXMgfmNvbXBhcmF0b3I6b3V0ZXJfY29tcGFyYXRvciB+Y29tcGFyYXRvcjppbm5lcl9jb21wYXJhdG9yIHQgPVxuICAgIChUcmVlMC50cmFuc3Bvc2Vfa2V5cyB+b3V0ZXJfY29tcGFyYXRvciB+aW5uZXJfY29tcGFyYXRvciB0KS50cmVlXG4gICAgfD4gbWFwIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgOztcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA9IHN0cnVjdFxuICAgIHR5cGUgKCdrLCAndiwgJ3cpIHQgPSAoJ2ssICd2KSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLnRcblxuICAgIGxldCBlbXB0eSA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuZW1wdHlcblxuICAgIGxldCBhZGRfZXhuIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSA9XG4gICAgICBtYXRjaCBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLm1heF9rZXkgdCB3aXRoXG4gICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICBFcnJvci5yYWlzZV9zIChTZXhwLkF0b20gXCJNYXAuQnVpbGRfaW5jcmVhc2luZy5hZGQ6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgfCBfIC0+IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuYWRkX3VuY2hlY2tlZCB0IH5rZXkgfmRhdGFcbiAgICA7O1xuXG4gICAgbGV0IHRvX3RyZWUgdCA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVXNpbmdfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2LCAnY21wKSB0ID0gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yIGsgdiA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLnNpbmdsZXRvbiBrIHY7IGxlbmd0aCA9IDEgfVxuXG4gIGxldCBvZl90cmVlMCB+Y29tcGFyYXRvciAoeyB0cmVlOyBsZW5ndGggfSA6IF8gV2l0aF9sZW5ndGgudCkgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgOztcblxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAod2l0aF9sZW5ndGggdHJlZSAoVHJlZTAubGVuZ3RoIHRyZWUpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHRvX3RyZWUgPSB0b190cmVlXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIChUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgfmY6KGZ1biB0cmVlIC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0IH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBtYXRjaCBUcmVlMC5vZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoIH0gLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBSZXN1bHQubWFwIChUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYWxpc3QgfmluaXQgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYWxpc3QgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfaXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH5pdGVyaSB3aXRoXG4gICAgfCBgT2sgdHJlZV9sZW5ndGggLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlX2xlbmd0aClcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgICh3aXRoX2xlbmd0aCAoVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZikgbGVuKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOihmdW4geCAtPiBvZl90cmVlMCB+Y29tcGFyYXRvciB4KVxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCB9IC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAub2ZfbGlzdF93aXRoX2tleSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHdpdGhcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCB9IC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2V4biB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9leG4gbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9tdWx0aSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5ID1cbiAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5X211bHRpIGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gb2ZfdHJlZTAgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgdC50cmVlIH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayBwYWlyIC0+IGBPayAob2ZfdHJlZTAgfmNvbXBhcmF0b3IgcGFpcilcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm1hcF9rZXlzX2V4biB0LnRyZWUgfmYgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IHRyYW5zcG9zZV9rZXlzIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3IgdCA9XG4gICAgbGV0IG91dGVyX2NvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3IgaW5cbiAgICBUcmVlMC50cmFuc3Bvc2Vfa2V5cyB+b3V0ZXJfY29tcGFyYXRvciB+aW5uZXJfY29tcGFyYXRvciAoVHJlZTAubWFwIHQudHJlZSB+Zjp0b190cmVlKVxuICAgIHw+IG9mX3RyZWUwIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3JcbiAgICB8PiBtYXAgfmY6KGZ1biB4IC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yOm91dGVyX2NvbXBhcmF0b3IgeClcbiAgOztcblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpID0gc3RydWN0XG4gICAgbGV0IGVtcHR5ID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3IgPSBLLmNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBlbmRcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG50eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9XG4gIChtb2R1bGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gJ2sgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcblxubGV0IGNvbXBhcmF0b3JfcyAodHlwZSBrIGNtcCkgdCA6IChrLCBjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgdCA9IGtcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcFxuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3JcbiAgZW5kKVxuOztcblxubGV0IHRvX2NvbXBhcmF0b3IgKHR5cGUgayBjbXApICgobW9kdWxlIE0pIDogKGssIGNtcCkgY29tcGFyYXRvcikgPSBNLmNvbXBhcmF0b3JcblxubGV0IG9mX3RyZWUgKHR5cGUgayBjbXApICgobW9kdWxlIE0pIDogKGssIGNtcCkgY29tcGFyYXRvcikgdHJlZSA9XG4gIG9mX3RyZWUgfmNvbXBhcmF0b3I6TS5jb21wYXJhdG9yIHRyZWVcbjs7XG5cbmxldCBlbXB0eSBtID0gVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxubGV0IHNpbmdsZXRvbiBtIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYWxpc3QgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FsaXN0X211bHRpIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2ZfYWxpc3RfZm9sZCBtIGEgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+aW5pdCB+ZlxuOztcblxubGV0IG9mX2FsaXN0X3JlZHVjZSBtIGEgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfaXRlcmkgbSB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuXG5sZXQgb2ZfaXRlcmlfZXhuIG0gfml0ZXJpID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBtIHNlcSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzZXFcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZSBtIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcblxubGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIG0gcyA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuOztcblxubGV0IG9mX3NlcXVlbmNlX2V4biBtIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG5cbmxldCBvZl9zZXF1ZW5jZV9tdWx0aSBtIHMgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9mb2xkIG0gcyB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzIH5pbml0IH5mXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIG0gcyB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHMgfmZcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5IG0gbCB+Z2V0X2tleSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBsIH5nZXRfa2V5XG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciBtIGwgfmdldF9rZXkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgbCB+Z2V0X2tleVxuOztcblxubGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIG0gbCB+Z2V0X2tleSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgbCB+Z2V0X2tleVxuOztcblxubGV0IG9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgbSBsIH5nZXRfa2V5ID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5X211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXlcbjs7XG5cbmxldCBtYXBfa2V5cyBtIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcbmxldCBtYXBfa2V5c19leG4gbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdCB+ZlxubGV0IHRyYW5zcG9zZV9rZXlzIG0gdCA9IFVzaW5nX2NvbXBhcmF0b3IudHJhbnNwb3NlX2tleXMgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdFxuXG5tb2R1bGUgTSAoSyA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICAgICAodHlwZSBrIGNtcClcbiAgICAgIChtb2R1bGUgSyA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGsgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgdl9vZl9zZXhwXG4gICAgICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOksuY29tcGFyYXRvciBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgICAodHlwZSBrKVxuICAgICAgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKVxuICAgICAgKHZfZ3JhbW1hciA6IF8gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBUYWdnZWRcbiAgICAgICAgeyBrZXkgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2NfdGFnXG4gICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgIDsgZ3JhbW1hciA9XG4gICAgICAgICAgICBMaXN0XG4gICAgICAgICAgICAgIChNYW55XG4gICAgICAgICAgICAgICAgIChMaXN0XG4gICAgICAgICAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICggVGFnZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY19rZXlfdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBncmFtbWFyID0gSy50X3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICwgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBUYWdnZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY192YWx1ZV90YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgZ3JhbW1hciA9IHZfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBFbXB0eSApICkpKSlcbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9tX190IChtb2R1bGUgXyA6IENvbXBhcmVfbSkgY29tcGFyZV92IHQxIHQyID0gY29tcGFyZV9kaXJlY3QgY29tcGFyZV92IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSBlcXVhbF92IHQxIHQyID0gZXF1YWwgZXF1YWxfdiB0MSB0MlxuXG5sZXQgaGFzaF9mb2xkX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBrKSBoYXNoX2ZvbGRfdiBzdGF0ZSA9XG4gIGhhc2hfZm9sZF9kaXJlY3QgSy5oYXNoX2ZvbGRfdCBoYXNoX2ZvbGRfdiBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdCA9ICgnaywgJ3YsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIFRyZWUwLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgY29tcGFyYXRvciA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yXG4gIGxldCBvZl90cmVlIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X2V4biBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZm9sZCBhIH5pbml0IH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGEgfmluaXQgfmZcbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYSB+ZlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3JcbiAgbGV0IG9mX2l0ZXJpX2V4biB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3JcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mIH5jb21wYXJhdG9yXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxID0gVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcVxuICBsZXQgb2Zfc2VxdWVuY2UgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzXG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgcyB+aW5pdCB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHMgfmluaXQgfmZcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIHMgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzIH5mXG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXkgbCB+Z2V0X2tleSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5IH5jb21wYXJhdG9yIGwgfmdldF9rZXlcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2V4biBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yIGwgfmdldF9rZXlcbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9tdWx0aSBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmZcbiAgbGV0IHRyYW5zcG9zZV9rZXlzIHQgPSBVc2luZ19jb21wYXJhdG9yLnRyYW5zcG9zZV9rZXlzIH5jb21wYXJhdG9yIHRcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyMjcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDIiLCJmIiwiYTAiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1F1ZXVlIiwiY3JlYXRlIiwiY2xlYXIiLCJjb3B5IiwiaXNfZW1wdHkiLCJsZW5ndGgiLCJwZWVrIiwicG9wIiwicHVzaCIsInRyYW5zZmVyIiwiaXRlciIsInQiLCJjYW1sX2l0ZXIiLCJmb2xkIiwiaW5pdCIsImNhbWxfZm9sZCIsIkJhc2VfTGlua2VkX3F1ZXVlMCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2xpbmtlZF9xdWV1ZTAubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFILEdBQUFDLElBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0FBQWpCO0FBQUFBLFFBQUFrQixZQ2VFO0FBQUEsSUFHQSxrQ0FBYTtBQUFBO0FBQUEsWUFBQUMsS0FBQUYsR0FBQUcsTUFBQXBCO0FBQUFBLFFBQUFxQixZQUliO0FBQUEsSUFHQSx3Q0FBa0I7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUR6QnBCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnQwXG5cbnR5cGUgJ2EgdCA9ICdhIFN0ZGxpYi5RdWV1ZS50XG5cbmxldCBjcmVhdGUgPSBTdGRsaWIuUXVldWUuY3JlYXRlXG5sZXQgY2xlYXIgPSBTdGRsaWIuUXVldWUuY2xlYXJcbmxldCBjb3B5ID0gU3RkbGliLlF1ZXVlLmNvcHlcbmxldCBpc19lbXB0eSA9IFN0ZGxpYi5RdWV1ZS5pc19lbXB0eVxubGV0IGxlbmd0aCA9IFN0ZGxpYi5RdWV1ZS5sZW5ndGhcbmxldCBwZWVrID0gU3RkbGliLlF1ZXVlLnBlZWtcbmxldCBwb3AgPSBTdGRsaWIuUXVldWUucG9wXG5sZXQgcHVzaCA9IFN0ZGxpYi5RdWV1ZS5wdXNoXG5sZXQgdHJhbnNmZXIgPSBTdGRsaWIuUXVldWUudHJhbnNmZXJcblxubGV0IGl0ZXIgdCB+ZjooKGYgOiBfIC0+IF8pIFtAbG9jYWxdKSA9XG4gIGxldCBjYW1sX2l0ZXIgOiAoKCdhIC0+IHVuaXQpW0Bsb2NhbF0pIC0+ICdhIHQgLT4gdW5pdCA9XG4gICAgU3RkbGliLk9iai5tYWdpYyAoU3RkbGliLlF1ZXVlLml0ZXIgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0KVxuICBpblxuICBjYW1sX2l0ZXIgZiB0XG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mOigoZiA6IF8gLT4gXyAtPiBfKSBbQGxvY2FsXSkgPVxuICBsZXQgY2FtbF9mb2xkIDogKCgnYiAtPiAnYSAtPiAnYilbQGxvY2FsXSkgLT4gJ2IgLT4gJ2EgdCAtPiAnYiA9XG4gICAgU3RkbGliLk9iai5tYWdpYyAoU3RkbGliLlF1ZXVlLmZvbGQgOiAoJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIC0+ICdhIHQgLT4gJ2IpXG4gIGluXG4gIGNhbWxfZm9sZCBmIGluaXQgdFxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMjMyNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0xpc3QiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJCYXNlX0ltcG9ydCIsIkJhc2VfQXJyYXkiLCJCYXNlX0xpbmtlZF9xdWV1ZTAiLCJCYXNlX0luZGV4ZWRfY29udGFpbmVyIiwiY3JlYXRlIiwiY2xlYXIiLCJjb3B5IiwiaXNfZW1wdHkiLCJsZW5ndGgiLCJpdGVyIiwiZm9sZCIsImVucXVldWUiLCJ0IiwieCIsImRlcXVldWUiLCJkZXF1ZXVlX2V4biIsImRlcXVldWVfYW5kX2lnbm9yZV9leG4iLCJwZWVrIiwicGVla19leG4iLCJDIiwiY291bnQiLCJleGlzdHMiLCJmaW5kIiwiZmluZF9tYXAiLCJmb2xkX3Jlc3VsdCIsImZvbGRfdW50aWwiLCJmb3JfYWxsIiwibWF4X2VsdCIsIm1lbSIsIm1pbl9lbHQiLCJzdW0iLCJ0b19saXN0IiwiY291bnRpIiwiZXhpc3RzaSIsImZpbmRfbWFwaSIsImZpbmRpIiwiZm9sZGkiLCJmb3JfYWxsaSIsIml0ZXJpIiwidHJhbnNmZXIiLCJzcmMiLCJkc3QiLCJjb25jYXRfbWFwIiwicmVzIiwiYSIsImIiLCJjb25jYXRfbWFwaSIsImkiLCJmaWx0ZXJfbWFwIiwibWF0Y2giLCJmaWx0ZXJfbWFwaSIsImZpbHRlciIsImZpbHRlcmkiLCJtYXAiLCJtYXBpIiwiZmlsdGVyX2lucGxhY2UiLCJxIiwiZmlsdGVyaV9pbnBsYWNlIiwiZW5xdWV1ZV9hbGwiLCJsaXN0Iiwib2ZfbGlzdCIsIm9mX2FycmF5IiwiYXJyYXkiLCJpbml0IiwibGVuIiwidG9fYXJyYXkiLCJhcnIiLCJ2IiwidF9vZl9zZXhwIiwiYV9vZl9zZXhwIiwic2V4cCIsInNleHBfb2ZfdCIsInNleHBfb2ZfYSIsInRfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsInNpbmdsZXRvbiIsIkJhc2VfTGlua2VkX3F1ZXVlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvbGlua2VkX3F1ZXVlLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLFlBQUFDLFFBQUFDLEdBQUFDLEdDR2tCLDhDQUFzQjtBQUFBLFlBQUFDLFFBQUFGO0FBQUFBLElBQ3JCO0FBQUE7QUFBQSxrQkFBK0IscUNBQXFCO0FBQUE7QUFBQSxPQUFBRyxjREp2RTtBQUFBLFlBQUFDLHVCQUFBSixHQ000RCw0QkFBYSxTQUFP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KSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaW5rZWRfcXVldWUwXG5cbmxldCBlbnF1ZXVlIHQgeCA9IExpbmtlZF9xdWV1ZTAucHVzaCB4IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucG9wIHQpXG5sZXQgZGVxdWV1ZV9leG4gPSBMaW5rZWRfcXVldWUwLnBvcFxubGV0IGRlcXVldWVfYW5kX2lnbm9yZV9leG4gKHR5cGUgZWx0KSAodCA6IGVsdCB0KSA9IGlnbm9yZSAoZGVxdWV1ZV9leG4gdCA6IGVsdClcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucGVlayB0KVxubGV0IHBlZWtfZXhuID0gTGlua2VkX3F1ZXVlMC5wZWVrXG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gICAgbGV0IGZvbGRpID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGl0ZXJpID0gYERlZmluZV91c2luZ19mb2xkXG4gIGVuZClcblxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9sZGkgPSBDLmZvbGRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5sZXQgaXRlcmkgPSBDLml0ZXJpXG5sZXQgdHJhbnNmZXIgfnNyYyB+ZHN0ID0gTGlua2VkX3F1ZXVlMC50cmFuc2ZlciBzcmMgZHN0XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgcmVzIGIpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSByZXMgYSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBlbnF1ZXVlIHJlcyAoZiBhKSk7XG4gIHJlc1xuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBlbnF1ZXVlIHJlcyAoZiBpIGEpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgcSB+ZiA9XG4gIGxldCBxJyA9IGZpbHRlciBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXJpIHEgfmYgaW5cbiAgY2xlYXIgcTtcbiAgdHJhbnNmZXIgfnNyYzpxJyB+ZHN0OnFcbjs7XG5cbmxldCBlbnF1ZXVlX2FsbCB0IGxpc3QgPSBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBBcnJheS5pdGVyIGFycmF5IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbmxldCBpbml0IGxlbiB+ZiA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgZW5xdWV1ZSB0IChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCB0b19hcnJheSB0ID1cbiAgbWF0Y2ggbGVuZ3RoIHQgd2l0aFxuICB8IDAgLT4gW3x8XVxuICB8IGxlbiAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbiAocGVla19leG4gdCkgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlciB0IH5mOihmdW4gdiAtPlxuICAgICAgYXJyLighaSkgPC0gdjtcbiAgICAgIGluY3IgaSk7XG4gICAgYXJyXG47O1xuXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAobGlzdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5sZXQgc2luZ2xldG9uIGEgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBlbnF1ZXVlIHQgYTtcbiAgdFxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMjYxNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfTHgiLCJjc3RfYXJndW1lbnRfbXVzdF9iZV9zdHJpY3RseV8iLCJjYW1sX2VxdWFsIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9hbmQiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiU3RkbGliX1NjYW5mIiwiQmFzZV9QcmludGYiLCJTdGRsaWJfSW50NjQiLCJCYXNlX0ltcG9ydCIsIkJhc2VfU2V4cCIsIkJhc2VfT3JfZXJyb3IiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfRmxvYXQwIiwiQmFzZV9Db21wYXJhdG9yIiwiQmFzZV9JbnRfbWF0aCIsIkJhc2VfQ29tcGFyYWJsZSIsIkJhc2VfUG9wY291bnQiLCJCYXNlX0ludF9jb252ZXJzaW9ucyIsIkJhc2VfRXJyb3IiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiZ2xvYmFsaXplIiwiaGFzaF9mb2xkX3QiLCJmdW5jIiwiaGFzaCIsIngiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsImhhc2hhYmxlIiwiY29tcGFyZSIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJpbmNsdWRlIiwiY29tcGFyYXRvciIsIm51bV9iaXRzIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0Iiwic2hpZnRfcmlnaHRfbG9naWNhbCIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfbGVmdCIsImJpdF9ub3QiLCJiaXRfeG9yIiwiYml0X29yIiwiYml0X2FuZCIsIm1pbl92YWx1ZSIsIm1heF92YWx1ZSIsImFicyIsInByZWQiLCJzdWNjIiwicG93IiwicmVtIiwibmVnIiwibWludXNfb25lIiwib25lIiwiemVybyIsInRvX2Zsb2F0Iiwib2ZfZmxvYXRfdW5jaGVja2VkIiwib2ZfZmxvYXQiLCJzeW1ib2wiLCJiIiwiZSIsImJzd2FwMTYiLCJic3dhcDMyIiwiYnN3YXA0OCIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsImludmFyaWFudCIsInBhcmFtIiwiYmV0d2VlbiIsInQiLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwibWluIiwibWF4IiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJpbmNyIiwiciIsImRlY3IiLCJvZl9pbnQ2NF9leG4iLCJ0b19pbnQ2NCIsInBvcGNvdW50Iiwib2ZfaW50X2V4biIsInRvX2ludCIsInRvX2ludF9leG4iLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsIm9mX25hdGl2ZWludCIsInRvX25hdGl2ZWludCIsInRvX25hdGl2ZWludF9leG4iLCJyYWlzZV9zIiwiY3N0X0ludDY0X2Zsb29yX2xvZzJfZ290X2ludmFsIiwiY3N0X0ludDY0X2NlaWxfbG9nMl9nb3RfaW52YWxpIiwibm9uX3Bvc2l0aXZlX2FyZ3VtZW50IiwiY2VpbF9wb3cyIiwiZmxvb3JfcG93MiIsImlzX3BvdzIiLCJmbG9vcl9sb2cyIiwiaSIsImNlaWxfbG9nMiIsInRvX3N0cmluZ19odW0iLCJzIiwiSGV4IiwicHAiLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiQmFzZV9JbnQ2NCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZy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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0MrT007QUFBQTtBQUFBLEVEL09OIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm9wZW4hIFN0ZGxpYi5JbnQ2NFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiAodFtAb2NhbWwubG9jYWxdKSAtPiB0KSA9IChnbG9iYWxpemVfaW50NjQgOiAodFtAb2NhbWwubG9jYWxdKSAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50NjRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnQ2NF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQ2NF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cblxuICBsZXQgY29tcGFyZSA9IEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nX29wdCA9IG9mX3N0cmluZ19vcHRcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSA2NFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfb2ZfYml0cyA9IGZsb2F0X29mX2JpdHNcbmxldCBiaXRzX29mX2Zsb2F0ID0gYml0c19vZl9mbG9hdFxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCBwb3cgPSBJbnRfbWF0aC5Qcml2YXRlLmludDY0X3Bvd1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBTdGRsaWIuSW50NjQub2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQ2NC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbmV4dGVybmFsIGJzd2FwNjQgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwMTYgeCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDQ4XG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXAzMiB4ID1cbiAgKCogVGhpcyBpcyBzdHJpY3RseSBiZXR0ZXIgdGhhbiBjb2VyY2luZyB0byBhbiBpbnQzMiB0byBwZXJmb3JtIGJ5dGVzd2FwLiBDb2VyY2luZ1xuICAgICBmcm9tIGFuIGludDMyIHdpbGwgYWRkIHVubmVjZXNzYXJ5IHNoaWZ0IG9wZXJhdGlvbnMgdG8gc2lnbiBleHRlbmQgdGhlIG51bWJlclxuICAgICBhcHByb3ByaWF0ZWx5LlxuICAqKVxuICBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSAzMlxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDQ4IHggPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSAxNlxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgaW5jciByID0gciA6PSBhZGQgIXIgb25lXG5sZXQgZGVjciByID0gciA6PSBzdWIgIXIgb25lXG5cbmV4dGVybmFsIG9mX2ludDY0IDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcblxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0XG5sZXQgdG9faW50NjQgdCA9IHRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmV4dGVybmFsIHRvX2ludF90cnVuYyA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQzMltAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludF90cnVuY1xuICA6ICAoaW50NjRbQGxvY2FsX29wdF0pXG4gIC0+IChuYXRpdmVpbnRbQGxvY2FsX29wdF0pXG4gID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxuZXh0ZXJuYWwgb2ZfaW50IDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMiA6IChpbnQzMltAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX2ludDMyXCJcblxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCB0b19pbnQgPSBDb252LmludDY0X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuXG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IFN0ZGxpYi5JbnQ2NC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IFN0ZGxpYi5JbnQ2NC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IFN0ZGxpYi5JbnQ2NC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIFN0ZGxpYi5JbnQ2NC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBTdGRsaWIuSW50NjQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgU3RkbGliLkludDY0LnByZWQgeCA9IFN0ZGxpYi5JbnQ2NC56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludDY0X2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gU3RkbGliLkludDY0Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50NjQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIFN0ZGxpYi5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBpZiBTdGRsaWIuSW50NjQuZXF1YWwgaSBTdGRsaWIuSW50NjQub25lXG4gICAgdGhlbiAwXG4gICAgZWxzZSBudW1fYml0cyAtIGNseiAoU3RkbGliLkludDY0LnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQ2NCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gbmVnXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVMeFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBTdGRsaWIuU2NhbmYuc3NjYW5mIHMgXCIlTHhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2NC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0XCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X2FkZFwiXG4gIGV4dGVybmFsICggLSApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9zdWJcIlxuICBleHRlcm5hbCAoICogKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfbXVsXCJcbiAgZXh0ZXJuYWwgKCAvICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X2RpdlwiXG4gIGV4dGVybmFsICggfi0gKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9uZWdcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhYnMgPSBhYnNcblxuICBleHRlcm5hbCBuZWcgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X2FuZFwiXG4gIGV4dGVybmFsICggbG9yICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29yXCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X3hvclwiXG5cbiAgbGV0IGxub3QgPSBiaXRfbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKVxuICAgIDogICh0W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKHRbQGxvY2FsX29wdF0pXG4gICAgPSBcIiVpbnQ2NF9sc2xcIlxuXG4gIGV4dGVybmFsICggYXNyIClcbiAgICA6ICAodFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+ICh0W0Bsb2NhbF9vcHRdKVxuICAgID0gXCIlaW50NjRfYXNyXCJcblxuICBleHRlcm5hbCAoIGxzciApXG4gICAgOiAgKHRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAodFtAbG9jYWxfb3B0XSlcbiAgICA9IFwiJWludDY0X2xzclwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2NF0gYW5kIFtJbnQ2NC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMzAxNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfc3JjX2ludDYzX2VtdWxfbWwiLCJjYW1sX2VxdWFsIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX25vdGVxdWFsIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJtYXNrIiwibW9kdWxlX25hbWUiLCJCYXNlX0ltcG9ydCIsIkJhc2VfUHJpbnRmIiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0Zsb2F0MCIsIkJhc2VfSW50NjQiLCJCYXNlX1N0cmluZyIsIlN0ZGxpYl9JbnQ2NCIsIkJhc2VfUG9wY291bnQiLCJCYXNlX0NvbXBhcmF0b3IiLCJCYXNlX0ludF9tYXRoIiwiQmFzZV9Db21wYXJhYmxlIiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsImNvbXBhcmUiLCJnbG9iYWxpemUiLCJoYXNoX2ZvbGRfdCIsInNleHBfb2ZfdCIsInRfc2V4cF9ncmFtbWFyIiwiaW5jbHVkZSIsImNvbXBhcmF0b3IiLCJ3cmFwX2V4biIsIngiLCJ1bndyYXAiLCJpbnZhcmlhbnQiLCJ0Iiwic3ltYm9sIiwiYWJzIiwib25lIiwic3VjYyIsImEiLCJwcmVkIiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwiYml0X25vdCIsImJpdF9hbmQiLCJiaXRfeG9yIiwiYml0X29yIiwic2hpZnRfbGVmdCIsInNoaWZ0X3JpZ2h0IiwiaSIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJwb3ciLCJiIiwicmVtIiwicG9wY291bnQiLCJ0b19pbnQ2NCIsIm9mX2ludDY0Iiwib2ZfaW50NjRfZXhuIiwib2ZfaW50NjRfdHJ1bmMiLCJ0X29mX3NleHAiLCJ5IiwiaXNfcG93MiIsImNseiIsImN0eiIsImZsb29yX3BvdzIiLCJjZWlsX3BvdzIiLCJmbG9vcl9sb2cyIiwiY2VpbF9sb2cyIiwiaGFzaCIsImhhc2hhYmxlIiwiaW52YWxpZF9zdHIiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmdfcmF3Iiwic3RyIiwibGVuIiwic3dpdGNoZXIiLCJzaWduIiwicG9zIiwiYzEiLCJjMiIsIm1hdGNoIiwic2lnbmVkbmVzcyIsInBvc19zdHIiLCJpbnQ2NCIsImludDYzIiwib2Zfc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsImJzd2FwMTYiLCJic3dhcDMyIiwiYnN3YXA0OCIsIm51bV9iaXRzIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsIm1pbnVzX29uZSIsInplcm8iLCJ0b19mbG9hdCIsIm9mX2Zsb2F0X3VuY2hlY2tlZCIsIm9mX2Zsb2F0IiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsImNzdF9tYXgiLCJjc3RfbWluIiwiY3N0X2NsYW1wX3JlcXVpcmVzX21pbl9tYXgiLCJiZXR3ZWVuIiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsIm1pbiIsIm1heCIsImNsYW1wX2V4biIsImNsYW1wIiwiZSIsImluY3IiLCJyIiwiZGVjciIsIm9mX2ludCIsIm9mX2ludF9leG4iLCJ0b19pbnQiLCJ0b19pbnRfZXhuIiwidG9faW50X3RydW5jIiwib2ZfaW50MzIiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsInRvX2ludDMyX3RydW5jIiwib2ZfbmF0aXZlaW50Iiwib2ZfbmF0aXZlaW50X2V4biIsIm9mX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludCIsInRvX25hdGl2ZWludF9leG4iLCJ0b19uYXRpdmVpbnRfdHJ1bmMiLCJ0b19zdHJpbmdfaHVtIiwiY3N0XzB4IiwicyIsIkhleCIsInBwIiwicm91bmQiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJyb3VuZF9kb3duIiwicm91bmRfdXAiLCJyb3VuZF9uZWFyZXN0IiwiUmVwciIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJCYXNlX0ludDYzX2VtdWwiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9pbnQ2M19lbXVsLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7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QSxJQUFBMEc7QUFBQUEsTUFyQjNCO0FBQUEsSUFBQXRHLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFQO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFPLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUF1RyxRQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFuSCxZQUFBO0FBQUEsSUFBQW9ILFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQW5DLE1BQUE7QUFBQSxJQUFBRCxNQUFBO0FBQUEsSUFBQXFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBCRDVYTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdDNFhNO0FBQUE7QUFBQSxFRDVYTiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogQSA2M2JpdCBpbnRlZ2VyIGlzIGEgNjRiaXQgaW50ZWdlciB3aXRoIGl0cyBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnRcbiAgIGFuZCBpdHMgbG93ZXN0IGJpdCBzZXQgdG8gMC5cbiAgIFRoaXMgaXMgdGhlIHNhbWUga2luZCBvZiBlbmNvZGluZyBhcyBPQ2FtbCBpbnQgb24gNjRiaXQgYXJjaGl0ZWN0dXJlLlxuICAgVGhlIG9ubHkgZGlmZmVyZW5jZSBiZWluZyB0aGUgbG93ZXN0IGJpdCAoaW1tZWRpYXRlIGJpdCkgc2V0IHRvIDEuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuXG5tb2R1bGUgVDAgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludDY0IDogdCAtPiB0IC0+IGludClcbiAgICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID0gKGdsb2JhbGl6ZV9pbnQ2NCA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuZW5kXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbm1vZHVsZSBXIDogc2lnXG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG4gIGVuZFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgdmFsIHdyYXBfZXhuIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgd3JhcF9tb2R1bG8gOiBTdGRsaWIuSW50NjQudCAtPiB0XG4gIHZhbCB1bndyYXAgOiB0IC0+IFN0ZGxpYi5JbnQ2NC50XG5cbiAgKCoqIFJldHVybnMgYSBub24tbmVnYXRpdmUgaW50NjQgdGhhdCBpcyBlcXVhbCB0byB0aGUgaW5wdXQgaW50NjMgbW9kdWxvIDJeNjMuICopXG4gIHZhbCB1bndyYXBfdW5zaWduZWQgOiB0IC0+IFN0ZGxpYi5JbnQ2NC50XG5cbiAgdmFsIGludmFyaWFudCA6IHQgLT4gdW5pdFxuICB2YWwgYWRkIDogdCAtPiB0IC0+IHRcbiAgdmFsIHN1YiA6IHQgLT4gdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgc3VjYyA6IHQgLT4gdFxuICB2YWwgcHJlZCA6IHQgLT4gdFxuICB2YWwgbXVsIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvdyA6IHQgLT4gdCAtPiB0XG4gIHZhbCBkaXYgOiB0IC0+IHQgLT4gdFxuICB2YWwgcmVtIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvcGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIGJpdF9ub3QgOiB0IC0+IHRcbiAgdmFsIGJpdF94b3IgOiB0IC0+IHQgLT4gdFxuICB2YWwgYml0X29yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9hbmQgOiB0IC0+IHQgLT4gdFxuICB2YWwgc2hpZnRfbGVmdCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIG1pbl92YWx1ZSA6IHRcbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIHRvX2ludDY0IDogdCAtPiBTdGRsaWIuSW50NjQudFxuICB2YWwgb2ZfaW50NjQgOiBTdGRsaWIuSW50NjQudCAtPiB0IG9wdGlvblxuICB2YWwgb2ZfaW50NjRfZXhuIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgb2ZfaW50NjRfdHJ1bmMgOiBTdGRsaWIuSW50NjQudCAtPiB0XG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgY2VpbF9wb3cyIDogdCAtPiB0XG4gIHZhbCBmbG9vcl9wb3cyIDogdCAtPiB0XG4gIHZhbCBjZWlsX2xvZzIgOiB0IC0+IGludFxuICB2YWwgZmxvb3JfbG9nMiA6IHQgLT4gaW50XG4gIHZhbCBpc19wb3cyIDogdCAtPiBib29sXG4gIHZhbCBjbHogOiB0IC0+IGludFxuICB2YWwgY3R6IDogdCAtPiBpbnRcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFQwXG5cbiAgdHlwZSB0ID0gaW50NjRcblxuICBsZXQgd3JhcF9leG4geCA9XG4gICAgKCogUmFpc2VzIGlmIHRoZSBpbnQ2NCB2YWx1ZSBkb2VzIG5vdCBmaXQgb24gaW50NjMuICopXG4gICAgQ29udi5pbnQ2NF9maXRfb25faW50NjNfZXhuIHg7XG4gICAgU3RkbGliLkludDY0Lm11bCB4IDJMXG4gIDs7XG5cbiAgbGV0IHdyYXAgeCA9XG4gICAgaWYgQ29udi5pbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzIHggdGhlbiBTb21lIChTdGRsaWIuSW50NjQubXVsIHggMkwpIGVsc2UgTm9uZVxuICA7O1xuXG4gIGxldCB3cmFwX21vZHVsbyB4ID0gU3RkbGliLkludDY0Lm11bCB4IDJMXG4gIGxldCB1bndyYXAgeCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCB4IDFcbiAgbGV0IHVud3JhcF91bnNpZ25lZCB4ID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCAxXG5cbiAgKCogVGhpcyBkb2VzIG5vdCB1c2Ugd3JhcCBvciB1bndyYXAgdG8gYXZvaWQgZ2VuZXJhdGluZyBleGNlcHRpb25zIGluIHRoZSBjYXNlIG9mXG4gICAgIG92ZXJmbG93cy4gVGhpcyBpcyB0byBwcmVzZXJ2ZSB0aGUgc2VtYW50aWNzIG9mIGludCB0eXBlIG9uIDY0IGJpdCBhcmNoaXRlY3R1cmUuICopXG4gIGxldCBmMiBmIGEgYiA9XG4gICAgU3RkbGliLkludDY0Lm11bCAoZiAoU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0IGEgMSkgKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCBiIDEpKSAyTFxuICA7O1xuXG4gIGxldCBtYXNrID0gMHhmZmZmX2ZmZmZfZmZmZl9mZmZlTFxuICBsZXQgbSB4ID0gU3RkbGliLkludDY0LmxvZ2FuZCB4IG1hc2tcbiAgbGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChtIHQgPSB0KVxuICBsZXQgYWRkIHggeSA9IFN0ZGxpYi5JbnQ2NC5hZGQgeCB5XG4gIGxldCBzdWIgeCB5ID0gU3RkbGliLkludDY0LnN1YiB4IHlcbiAgbGV0IG5lZyB4ID0gU3RkbGliLkludDY0Lm5lZyB4XG4gIGxldCBhYnMgeCA9IFN0ZGxpYi5JbnQ2NC5hYnMgeFxuICBsZXQgb25lID0gd3JhcF9leG4gMUxcbiAgbGV0IHN1Y2MgYSA9IGFkZCBhIG9uZVxuICBsZXQgcHJlZCBhID0gc3ViIGEgb25lXG4gIGxldCBtaW5fdmFsdWUgPSBtIFN0ZGxpYi5JbnQ2NC5taW5faW50XG4gIGxldCBtYXhfdmFsdWUgPSBtIFN0ZGxpYi5JbnQ2NC5tYXhfaW50XG4gIGxldCBiaXRfbm90IHggPSBtIChTdGRsaWIuSW50NjQubG9nbm90IHgpXG4gIGxldCBiaXRfYW5kID0gU3RkbGliLkludDY0LmxvZ2FuZFxuICBsZXQgYml0X3hvciA9IFN0ZGxpYi5JbnQ2NC5sb2d4b3JcbiAgbGV0IGJpdF9vciA9IFN0ZGxpYi5JbnQ2NC5sb2dvclxuICBsZXQgc2hpZnRfbGVmdCB4IGkgPSBTdGRsaWIuSW50NjQuc2hpZnRfbGVmdCB4IGlcbiAgbGV0IHNoaWZ0X3JpZ2h0IHggaSA9IG0gKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCB4IGkpXG4gIGxldCBzaGlmdF9yaWdodF9sb2dpY2FsIHggaSA9IG0gKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggaSlcbiAgbGV0IHBvdyA9IGYyIEludF9tYXRoLlByaXZhdGUuaW50NjNfcG93X29uX2ludDY0XG4gIGxldCBtdWwgYSBiID0gU3RkbGliLkludDY0Lm11bCBhIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgYiAxKVxuICBsZXQgZGl2IGEgYiA9IHdyYXBfbW9kdWxvIChTdGRsaWIuSW50NjQuZGl2IGEgYilcbiAgbGV0IHJlbSBhIGIgPSBTdGRsaWIuSW50NjQucmVtIGEgYlxuICBsZXQgcG9wY291bnQgeCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50IHhcbiAgbGV0IHRvX2ludDY0IHQgPSB1bndyYXAgdFxuICBsZXQgb2ZfaW50NjQgdCA9IHdyYXAgdFxuICBsZXQgb2ZfaW50NjRfZXhuIHQgPSB3cmFwX2V4biB0XG4gIGxldCBvZl9pbnQ2NF90cnVuYyB0ID0gd3JhcF9tb2R1bG8gdFxuICBsZXQgdF9vZl9zZXhwIHggPSB3cmFwX2V4biAoaW50NjRfb2Zfc2V4cCB4KVxuICBsZXQgc2V4cF9vZl90IHggPSBzZXhwX29mX2ludDY0ICh1bndyYXAgeClcbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGlzX3BvdzIgeCA9IEludDY0LmlzX3BvdzIgKHVud3JhcCB4KVxuXG4gIGxldCBjbHogeCA9XG4gICAgKCogV2UgcnVuIEludDY0LmNseiBkaXJlY3RseSBvbiB0aGUgd3JhcHBlZCBpbnQ2MyB2YWx1ZS4gVGhpcyBpcyBjb3JyZWN0IGJlY2F1c2UgdGhlXG4gICAgICAgYml0cyBvZiB0aGUgaW50NjNfZW11bCBhcmUgbGVmdC1hbGlnbmVkIGluIHRoZSBJbnQ2NC4gKilcbiAgICBJbnQ2NC5jbHogeFxuICA7O1xuXG4gIGxldCBjdHogeCA9IEludDY0LmN0eiAodW53cmFwIHgpXG4gIGxldCBmbG9vcl9wb3cyIHggPSBJbnQ2NC5mbG9vcl9wb3cyICh1bndyYXAgeCkgfD4gd3JhcF9leG5cbiAgbGV0IGNlaWxfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBmbG9vcl9sb2cyIHggPSBJbnQ2NC5mbG9vcl9sb2cyICh1bndyYXAgeClcbiAgbGV0IGNlaWxfbG9nMiB4ID0gSW50NjQuY2VpbF9sb2cyICh1bndyYXAgeClcbmVuZFxuXG5vcGVuIFdcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVy50IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6ICh0W0BvY2FtbC5sb2NhbF0pIC0+IHQpID0gKFcuZ2xvYmFsaXplIDogKHRbQG9jYW1sLmxvY2FsXSkgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgVy5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoVy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChXLnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBXLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFcuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBXLmNvbXBhcmF0b3JcbiAgbGV0IGNvbXBhcmUgPSBXLmNvbXBhcmVcbiAgbGV0IGludmFyaWFudCA9IFcuaW52YXJpYW50XG5cbiAgKCogV2UgZG9uJ3QgZXhwZWN0IFtoYXNoXSB0byBmb2xsb3cgdGhlIGJlaGF2aW9yIG9mIGludCBpbiA2NGJpdCBhcmNoaXRlY3R1cmUgKilcbiAgbGV0IF8gPSBoYXNoXG4gIGxldCBoYXNoICh4IDogdCkgPSBTdGRsaWIuSGFzaHRibC5oYXNoIHhcbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgaW52YWxpZF9zdHIgeCA9IFByaW50Zi5mYWlsd2l0aGYgXCJJbnQ2My5vZl9zdHJpbmc6IGludmFsaWQgaW5wdXQgJVNcIiB4ICgpXG5cbiAgKCpcbiAgICAgXCJzaWduXCIgcmVmZXJzIHRvIHdoZXRoZXIgdGhlIG51bWJlciBzdGFydHMgd2l0aCBhICctJ1xuICAgICBcInNpZ25lZG5lc3MgPSBmYWxzZVwiIG1lYW5zIHRoZSByZXN0IG9mIHRoZSBudW1iZXIgaXMgcGFyc2VkIGFzIHVuc2lnbmVkIGFuZCB0aGVuIGNhc3RcbiAgICAgdG8gc2lnbmVkIHdpdGggd3JhcC1hcm91bmQgbW9kdWxvIDJeaVxuICAgICBcInNpZ25lZG5lc3MgPSB0cnVlXCIgbWVhbnMgbm8gc3VjaCBjcmF6aW5lc3MgaGFwcGVuc1xuXG4gICAgIFRoZSB0ZXJtaW5vbG9neSBhbmQgdGhlIGxvZ2ljIGlzIGR1ZSB0byB0aGUgY29kZSBpbiBieXRlcnVuL2ludHMuYyBpbiBvY2FtbCA0LjAzXG4gICAgIChbcGFyc2Vfc2lnbl9hbmRfYmFzZV0gZnVuY3Rpb24pLlxuXG4gICAgIFNpZ25lZG5lc3MgZXF1YWxzIHRydWUgZm9yIHBsYWluIGRlY2ltYWwgbnVtYmVyIChlLmcuIDEyMzUsIC02Nzg5KVxuXG4gICAgIFNpZ25lZG5lc3MgZXF1YWxzIGZhbHNlIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgIC0gWzB4ZmZmZl0sIFstMHhmZmZmXSAoaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzBiMDEwMV0sIFstMGIwMTAxXSAoYmluYXJ5IHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswbzEyMzddLCBbLTBvMTIzN10gKG9jdGFsIHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswdTk4MTJdLCBbLTB1OTgxMl0gKHVuc2lnbmVkIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gLSBhdmFpbGFibGUgZnJvbSBPQ2FtbCA0LjAzKSAqKVxuICBsZXQgc2lnbl9hbmRfc2lnbmVkbmVzcyB4ID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCB4IGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBwb3MsIHNpZ24gPVxuICAgICAgaWYgMCA8IGxlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHguWzBdIHdpdGhcbiAgICAgICAgfCAnLScgLT4gMSwgYE5lZ1xuICAgICAgICB8ICcrJyAtPiAxLCBgUG9zXG4gICAgICAgIHwgXyAtPiAwLCBgUG9zKVxuICAgICAgZWxzZSAwLCBgUG9zXG4gICAgaW5cbiAgICBpZiBwb3MgKyAyIDwgbGVuXG4gICAgdGhlbiAoXG4gICAgICBsZXQgYzEgPSB4Lltwb3NdIGluXG4gICAgICBsZXQgYzIgPSB4Lltwb3MgKyAxXSBpblxuICAgICAgbWF0Y2ggYzEsIGMyIHdpdGhcbiAgICAgIHwgJzAnLCAnMCcgLi4gJzknIC0+IHNpZ24sIHRydWVcbiAgICAgIHwgJzAnLCBfIC0+IHNpZ24sIGZhbHNlXG4gICAgICB8IF8gLT4gc2lnbiwgdHJ1ZSlcbiAgICBlbHNlIHNpZ24sIHRydWVcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nIHggPSBTdGRsaWIuSW50NjQudG9fc3RyaW5nICh1bndyYXAgeClcblxuICBsZXQgb2Zfc3RyaW5nX3JhdyBzdHIgPVxuICAgIGxldCBzaWduLCBzaWduZWRuZXNzID0gc2lnbl9hbmRfc2lnbmVkbmVzcyBzdHIgaW5cbiAgICBpZiBzaWduZWRuZXNzXG4gICAgdGhlbiBvZl9pbnQ2NF9leG4gKFN0ZGxpYi5JbnQ2NC5vZl9zdHJpbmcgc3RyKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHBvc19zdHIgPVxuICAgICAgICBtYXRjaCBzaWduIHdpdGhcbiAgICAgICAgfCBgTmVnIC0+IFN0cmluZy5zdWIgc3RyIH5wb3M6MSB+bGVuOihTdHJpbmcubGVuZ3RoIHN0ciAtIDEpXG4gICAgICAgIHwgYFBvcyAtPiBzdHJcbiAgICAgIGluXG4gICAgICBsZXQgaW50NjQgPSBTdGRsaWIuSW50NjQub2Zfc3RyaW5nIHBvc19zdHIgaW5cbiAgICAgICgqIHVuc2lnbmVkIDYzLWJpdCBpbnQgbXVzdCBwYXJzZSBhcyBhIHBvc2l0aXZlIHNpZ25lZCA2NC1iaXQgaW50ICopXG4gICAgICBpZiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaW50NjQgMEwgdGhlbiBpbnZhbGlkX3N0ciBzdHI7XG4gICAgICBsZXQgaW50NjMgPSB3cmFwX21vZHVsbyBpbnQ2NCBpblxuICAgICAgbWF0Y2ggc2lnbiB3aXRoXG4gICAgICB8IGBOZWcgLT4gbmVnIGludDYzXG4gICAgICB8IGBQb3MgLT4gaW50NjMpXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzdHIgPVxuICAgIHRyeSBvZl9zdHJpbmdfcmF3IHN0ciB3aXRoXG4gICAgfCBfIC0+IGludmFsaWRfc3RyIHN0clxuICA7O1xuXG4gIGxldCBvZl9zdHJpbmdfb3B0IHN0ciA9XG4gICAgbWF0Y2ggb2Zfc3RyaW5nX3JhdyBzdHIgd2l0aFxuICAgIHwgdCAtPiBTb21lIHRcbiAgICB8IGV4Y2VwdGlvbiBfIC0+IE5vbmVcbiAgOztcblxuICBsZXQgYnN3YXAxNiB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwMTYgKHVud3JhcCB0KSlcbiAgbGV0IGJzd2FwMzIgdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDMyICh1bndyYXAgdCkpXG4gIGxldCBic3dhcDQ4IHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXA0OCAodW53cmFwIHQpKVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgbnVtX2JpdHMgPSA2M1xubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gYml0X25vdFxubGV0IGJpdF94b3IgPSBiaXRfeG9yXG5sZXQgYml0X29yID0gYml0X29yXG5sZXQgYml0X2FuZCA9IGJpdF9hbmRcbmxldCBwb3Bjb3VudCA9IHBvcGNvdW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHBvdyA9IHBvd1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1heF92YWx1ZSA9IG1heF92YWx1ZVxubGV0IG1pbl92YWx1ZSA9IG1pbl92YWx1ZVxubGV0IG1pbnVzX29uZSA9IHdyYXBfZXhuIFN0ZGxpYi5JbnQ2NC5taW51c19vbmVcbmxldCBvbmUgPSB3cmFwX2V4biBTdGRsaWIuSW50NjQub25lXG5sZXQgemVybyA9IHdyYXBfZXhuIFN0ZGxpYi5JbnQ2NC56ZXJvXG5sZXQgaXNfcG93MiA9IGlzX3BvdzJcbmxldCBmbG9vcl9wb3cyID0gZmxvb3JfcG93MlxubGV0IGNlaWxfcG93MiA9IGNlaWxfcG93MlxubGV0IGZsb29yX2xvZzIgPSBmbG9vcl9sb2cyXG5sZXQgY2VpbF9sb2cyID0gY2VpbF9sb2cyXG5sZXQgY2x6ID0gY2x6XG5sZXQgY3R6ID0gY3R6XG5sZXQgdG9fZmxvYXQgeCA9IFN0ZGxpYi5JbnQ2NC50b19mbG9hdCAodW53cmFwIHgpXG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkIHggPSB3cmFwX21vZHVsbyAoU3RkbGliLkludDY0Lm9mX2Zsb2F0IHgpXG5cbmxldCBvZl9mbG9hdCB0ID1cbiAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIHQgPj0gZmxvYXRfbG93ZXJfYm91bmQgJiYgdCA8PSBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIHdyYXBfbW9kdWxvIChTdGRsaWIuSW50NjQub2ZfZmxvYXQgdClcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50NjMub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBvZl9pbnQ2NCA9IG9mX2ludDY0XG5sZXQgb2ZfaW50NjRfZXhuID0gb2ZfaW50NjRfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBvZl9pbnQ2NF90cnVuY1xubGV0IHRvX2ludDY0ID0gdG9faW50NjRcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5cbigqIFdlIGNhbiByZXVzZSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20vdG8gaW50NjQgaGVyZS4gKilcbmxldCBvZl9pbnQgeCA9IHdyYXBfZXhuIChDb252LmludF90b19pbnQ2NCB4KVxubGV0IG9mX2ludF9leG4geCA9IG9mX2ludCB4XG5sZXQgdG9faW50IHggPSBDb252LmludDY0X3RvX2ludCAodW53cmFwIHgpXG5sZXQgdG9faW50X2V4biB4ID0gQ29udi5pbnQ2NF90b19pbnRfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnRfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50X3RydW5jICh1bndyYXAgeClcbmxldCBvZl9pbnQzMiB4ID0gd3JhcF9leG4gKENvbnYuaW50MzJfdG9faW50NjQgeClcbmxldCBvZl9pbnQzMl9leG4geCA9IG9mX2ludDMyIHhcbmxldCB0b19pbnQzMiB4ID0gQ29udi5pbnQ2NF90b19pbnQzMiAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfZXhuIHggPSBDb252LmludDY0X3RvX2ludDMyX2V4biAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX25hdGl2ZWludCB4ID0gb2ZfaW50NjQgKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X2V4biB4ID0gd3JhcF9leG4gKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jIHggPSBvZl9pbnQ2NF90cnVuYyAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCB0b19uYXRpdmVpbnQgeCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50ICh1bndyYXAgeClcbmxldCB0b19uYXRpdmVpbnRfZXhuIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgKHVud3JhcCB4KVxuXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChULmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgVC5oYXNoX2ZvbGRfdFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBULmhhc2ggaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG5cbiAgICBsZXQgdG9fc3RyaW5nIGkgPVxuICAgICAgKCogdGhlIHVzZSBvZiBbdW53cmFwX3Vuc2lnbmVkXSBoZXJlIGlzIGltcG9ydGFudCBmb3IgdGhlIGNhc2Ugb2YgW21pbl92YWx1ZV0gKilcbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiJUx4XCIgKHVud3JhcF91bnNpZ25lZCBpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBvZl9zdHJpbmcgKFwiMHhcIiBeIHMpXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzLkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgeCA9IHRvX3N0cmluZyB4XG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzXCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2M10gYW5kIFtJbnQ2My5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIHR5cGUgZW11bGF0ZWQgPSB0XG5cbiAgdHlwZSAoJ3VuZGVybHlpbmdfdHlwZSwgJ2ludGVybWVkaWF0ZV90eXBlKSB0ID1cbiAgICB8IEludCA6IChpbnQsIGludCkgdFxuICAgIHwgSW50NjQgOiAoaW50NjQsIGVtdWxhdGVkKSB0XG5lbmRcblxubGV0IHJlcHIgPSBSZXByLkludDY0XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMzU4MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfbHgiLCJjc3RfYXJndW1lbnRfbXVzdF9iZV9zdHJpY3RseV8iLCJjYW1sX2VxdWFsIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50MzJfYnN3YXAiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJtb2R1bGVfbmFtZSIsIlN0ZGxpYl9TY2FuZiIsIkJhc2VfUHJpbnRmIiwiU3RkbGliX0ludDMyIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NleHAiLCJCYXNlX0ludF9tYXRoIiwiQmFzZV9Pcl9lcnJvciIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9GbG9hdDAiLCJCYXNlX0NvbXBhcmF0b3IiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX1BvcGNvdW50IiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJCYXNlX0Vycm9yIiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJoYXNoYWJsZSIsImFzY2VuZGluZyIsInkiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmciLCJvZl9zdHJpbmdfb3B0IiwiaW5jbHVkZSIsImNvbXBhcmF0b3IiLCJudW1fYml0cyIsImZsb2F0X2xvd2VyX2JvdW5kIiwiZmxvYXRfdXBwZXJfYm91bmQiLCJmbG9hdF9vZl9iaXRzIiwiYml0c19vZl9mbG9hdCIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJzaGlmdF9yaWdodCIsInNoaWZ0X2xlZnQiLCJiaXRfbm90IiwiYml0X3hvciIsImJpdF9vciIsImJpdF9hbmQiLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJhYnMiLCJwcmVkIiwic3VjYyIsInJlbSIsInN5bWJvbCIsIm1pbnVzX29uZSIsIm9uZSIsInplcm8iLCJ0b19mbG9hdCIsIm9mX2Zsb2F0X3VuY2hlY2tlZCIsIm9mX2Zsb2F0IiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24iLCJjc3RfbWF4IiwiY3N0X21pbiIsImNzdF9jbGFtcF9yZXF1aXJlc19taW5fbWF4IiwiZGVzY2VuZGluZyIsIm1pbiIsIm1heCIsImVxdWFsIiwiYmV0d2VlbiIsInQiLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJpbnZhcmlhbnQiLCJwYXJhbSIsImluY3IiLCJyIiwiZGVjciIsIm9mX2ludDMyIiwidG9faW50MzIiLCJwb3Bjb3VudCIsIm9mX2ludCIsIm9mX2ludF9leG4iLCJvZl9pbnRfdHJ1bmMiLCJ0b19pbnQiLCJ0b19pbnRfZXhuIiwidG9faW50X3RydW5jIiwib2ZfaW50NjQiLCJvZl9pbnQ2NF9leG4iLCJvZl9pbnQ2NF90cnVuYyIsInRvX2ludDY0Iiwib2ZfbmF0aXZlaW50Iiwib2ZfbmF0aXZlaW50X2V4biIsIm9mX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludCIsInBvdyIsImIiLCJlIiwiYnN3YXAxNiIsInJhaXNlX3MiLCJjc3RfSW50MzJfZmxvb3JfbG9nMl9nb3RfaW52YWwiLCJjc3RfSW50MzJfY2VpbF9sb2cyX2dvdF9pbnZhbGkiLCJub25fcG9zaXRpdmVfYXJndW1lbnQiLCJjZWlsX3BvdzIiLCJmbG9vcl9wb3cyIiwiaXNfcG93MiIsImZsb29yX2xvZzIiLCJpIiwiY2VpbF9sb2cyIiwidG9fc3RyaW5nX2h1bSIsImNvbXBhcmUiLCJzIiwiSGV4IiwicHAiLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJCYXNlX0ludDMyIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvaW50MzIubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJ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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJEblBOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0NtUE07QUFBQTtBQUFBLEVEblBOIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm9wZW4hIFN0ZGxpYi5JbnQzMlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiAodFtAb2NhbWwubG9jYWxdKSAtPiB0KSA9IChnbG9iYWxpemVfaW50MzIgOiAodFtAb2NhbWwubG9jYWxdKSAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50MzJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnQzMl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQzMiA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQzMl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gIGxldCBvZl9zdHJpbmdfb3B0ID0gb2Zfc3RyaW5nX29wdFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmxldCBudW1fYml0cyA9IDMyXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF9vZl9iaXRzID0gZmxvYXRfb2ZfYml0c1xubGV0IGJpdHNfb2ZfZmxvYXQgPSBiaXRzX29mX2Zsb2F0XG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgY29tcGFyZSA9IGNvbXBhcmVcbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQzMi5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5tb2R1bGUgSW5maXhfY29tcGFyZSA9IHN0cnVjdFxuICBvcGVuIFBvbHlcblxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IHggPj0geVxuICBsZXQgKCA8PSApICh4IDogdCkgeSA9IHggPD0geVxuICBsZXQgKCA9ICkgKHggOiB0KSB5ID0geCA9IHlcbiAgbGV0ICggPiApICh4IDogdCkgeSA9IHggPiB5XG4gIGxldCAoIDwgKSAoeCA6IHQpIHkgPSB4IDwgeVxuICBsZXQgKCA8PiApICh4IDogdCkgeSA9IHggPD4geVxuZW5kXG5cbm1vZHVsZSBDb21wYXJlID0gc3RydWN0XG4gIGluY2x1ZGUgSW5maXhfY29tcGFyZVxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB4IHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWluICh4IDogdCkgeSA9IGlmIHggPCB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID4geSB0aGVuIHggZWxzZSB5XG4gIGxldCBlcXVhbCAoeCA6IHQpIHkgPSB4ID0geVxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcbmVuZFxuXG5pbmNsdWRlIENvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5sZXQgb2ZfaW50MzIgdCA9IHRcbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyIHQgPSB0XG5sZXQgdG9faW50MzJfZXhuID0gdG9faW50MzJcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDMyX3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmxldCBvZl9pbnQgPSBDb252LmludF90b19pbnQzMlxubGV0IG9mX2ludF9leG4gPSBDb252LmludF90b19pbnQzMl9leG5cbmxldCBvZl9pbnRfdHJ1bmMgPSBDb252LmludF90b19pbnQzMl90cnVuY1xubGV0IHRvX2ludCA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYuaW50MzJfdG9faW50X2V4blxubGV0IHRvX2ludF90cnVuYyA9IENvbnYuaW50MzJfdG9faW50X3RydW5jXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX2ludDMyXG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYuaW50MzJfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMlxubGV0IG9mX25hdGl2ZWludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl9leG5cbmxldCBvZl9uYXRpdmVpbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl90cnVuY1xubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxuZXh0ZXJuYWwgYnN3YXAzMiA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVic3dhcF9pbnQzMlwiXG5cbmxldCBic3dhcDE2IHggPSBTdGRsaWIuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXAzMiB4KSAxNlxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBTdGRsaWIuSW50MzIubG9nb3JcbiAgbGV0ICggbHNyICkgPSBTdGRsaWIuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBTdGRsaWIuSW50MzIubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBTdGRsaWIuSW50MzIucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBTdGRsaWIuSW50MzIuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IFN0ZGxpYi5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgU3RkbGliLkludDMyLnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIFN0ZGxpYi5JbnQzMi5wcmVkIHggPSBTdGRsaWIuSW50MzIuemVyb1xuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludDMyIGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDMyX2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50MzJfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludDMyX2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gU3RkbGliLkludDMyLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50MzIuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IFN0ZGxpYi5JbnQzMi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDMyLmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICAoKiBUaGUgW2kgPSAxXSBjaGVjayBpcyBuZWVkZWQgYmVjYXVzZSBjbHooMCkgaXMgdW5kZWZpbmVkICopXG4gICAgaWYgU3RkbGliLkludDMyLmVxdWFsIGkgU3RkbGliLkludDMyLm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKFN0ZGxpYi5JbnQzMi5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50MzIgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbHhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gU3RkbGliLlNjYW5mLnNzY2FuZiBzIFwiJWx4XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50MzIuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQzMlwiXG4gIGVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKENvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDMyXSBhbmQgW0ludDMyLk9dIGFncmVlIHZhbHVlLXdpc2UgKilcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozNDAyNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfcHJvZHVjdCIsImNzdF90IiwiY3N0X3UiLCJjYW1sX2RpdiIsImNhbWxfaW50NjRfb2ZfaW50MzIiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tdWwiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsImNzdCIsIkJhc2VfV29yZF9zaXplIiwiQmFzZV9JbnQiLCJCYXNlX1NleHAiLCJCYXNlX1JhbmRvbSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9Cb29sIiwiQmFzZV9JbnQ2NCIsIkJhc2VfRXJyb3IiLCJCYXNlX0ludDYzX2VtdWwiLCJBc3NlcnRfZmFpbHVyZSIsInJhaXNlX3MiLCJjc3RfSW50X2Zsb29yX2xvZzJfZ290X2ludmFsaWQiLCJjc3RfbmVnX292ZXJmbG93IiwiY3N0X2Fic19vdmVyZmxvdyIsImNzdF9vdmVyZmxvdyIsImNzdF9kaWZmIiwiY3N0X3N1bSIsInJlcHIiLCJ0X3NleHBfZ3JhbW1hciIsIm9mX2Zsb2F0IiwidG9fZmxvYXQiLCJvZl9pbnRfZXhuIiwidG9faW50X2V4biIsImhhc2hfZm9sZF90IiwiaGFzaCIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsIm9mX3N0cmluZyIsInRvX3N0cmluZyIsImVxdWFsIiwiY29tcGFyZSIsIm1pbiIsIm1heCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwicHAiLCJoYXNoYWJsZSIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiaW52YXJpYW50IiwiSGV4Iiwib2Zfc3RyaW5nX29wdCIsInRvX3N0cmluZ19odW0iLCJvbmUiLCJtaW51c19vbmUiLCJyZW0iLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJzdWNjIiwicHJlZCIsInBvdyIsImJpdF9hbmQiLCJiaXRfb3IiLCJiaXRfeG9yIiwiYml0X25vdCIsInBvcGNvdW50Iiwic2hpZnRfbGVmdCIsInNoaWZ0X3JpZ2h0IiwiZGVjciIsImluY3IiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMl9leG4iLCJvZl9pbnQ2NF9leG4iLCJ0b19pbnQ2NCIsIm9mX25hdGl2ZWludF9leG4iLCJ0b19uYXRpdmVpbnRfZXhuIiwib2ZfZmxvYXRfdW5jaGVja2VkIiwibnVtX2JpdHMiLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwiY2VpbF9wb3cyIiwiZmxvb3JfcG93MiIsImNlaWxfbG9nMiIsImlzX3BvdzIiLCJjbHoiLCJjdHoiLCJPIiwic3ltYm9sIiwibG5vdCIsImFicyIsInplcm8iLCJvZl9pbnQiLCJ0b19pbnQzMiIsIm9mX2ludDY0Iiwib2ZfbmF0aXZlaW50IiwidG9faW50IiwieCIsInRvX2ludF90cnVuYyIsInRvX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludCIsImJzd2FwMzIiLCJ0IiwiYnN3YXA0OCIsImluY2x1ZGUiLCJuZWciLCJsYW5kIiwibG9yIiwibHhvciIsImxzbCIsImFzciIsImxzciIsIm9mX2ludDMyIiwidG9faW50MzJfdHJ1bmMiLCJvZl9pbnQ2NF90cnVuYyIsIm9mX25hdGl2ZWludF90cnVuYyIsImJzd2FwMTYiLCJ1Iiwic3VtIiwiZGlmZiIsInBvc19kaWZmIiwibmVnYXRpdmVfb25lIiwiZGl2X3dvdWxkX292ZXJmbG93IiwicHJvZHVjdCIsInJhbmRvbV9vZl9pbnQiLCJvcHQiLCJib3VuZCIsInN0YXRlIiwicmFuZG9tX29mX2ludDY0IiwicmFuZG9tX2luY2xfb2ZfaW50IiwibG8iLCJoaSIsInJhbmRvbV9pbmNsX29mX2ludDY0IiwicmFuZG9tX2luY2wiLCJmbG9vcl9sb2cyIiwiQmFzZV9JbnQ2MyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2ludDYzLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBL0IsZ0JBQUE7QUFBQSxJQUFBRSxVQUFBO0FBQUEsSUFBQUQsVUFBQTtBQUFBLElBQUErQixpQkFBQTtBQUFBLElBQUFoQyxjQUFBO0FBQUEsSUFBQUUsVUFBQTtBQUFBLElBQUFELFVBQUE7QUFBQSxJQUFBK0IsaUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQS9CLFVBQUE7QUFBQSxJQUFBRCxVQUFBO0FBQUEsSUFBQStCLGlCQUFBO0FBQUEsSUFBQUUsVUFBQTtBQUFBLElBQUFoQyxRQUFBO0FBQUEsSUFBQUQsUUFBQTtBQUFBLElBQUErQixlQUFBO0FBQUE7QUFBQSxJQUFBRyxPQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxJQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFILFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFJLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQTtBQUFBLFlBQUFDLE9BQUFDLEdDdUZtQixjQUFNO0FBQUEsWUFBQUMsYUFBQUQsR0FDQSxTQUFDO0FBQUEsWUFBQUUsbUJBQUFGLEdBSUsseUJBQWM7QUFBQSxZQUFBRyxhQUFBSCxHQUNmLDhCQUFnQjtBQUFBLFlBQUFJLFFBQUFDO0FBQUFBLElBRVEsT0FBaUI7QUFBQSxhQUFoQywyQkFBZSx3QkFBaUI7QUFBQTtBQUFBLFlBQUFDLFFBQUFEO0FBQUFBLElBQ2pCLE9BQWlCO0FBQUEsYUFBaEMsMkJBQWUsd0JBQWlCO0FBQUE7QUFBQTtBQUFBLElBQUFyRixTRGhHdkU7QUFBQSxJQUFBdUY7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBdEYsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURwSWhDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBSZXByID0gSW50NjNfZW11bC5SZXByXG5cbigqIEluIGEgd29ybGQgd2hlcmUgdGhlIGNvbXBpbGVyIHdvdWxkIHVuZGVyc3RhbmQgW0BAaW1tZWRpYXRlNjRdIGF0dHJpYnV0ZXMgb24gdHlwZVxuICAgZGVjbGFyYXRpb25zLCB0aGlzIG1vZHVsZSBpcyBob3cgb25lIHdvdWxkIHByb2R1Y2UgYSBbdHlwZSB0XSB3aXRoIHRoaXMgYXR0cmlidXRlLiAqKVxubW9kdWxlIEltbWVkaWF0ZTY0IDogc2lnXG4gIG1vZHVsZSB0eXBlIE5vbl9pbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgSW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZV1cbiAgZW5kXG5cbiAgbW9kdWxlIE1ha2UgKEltbWVkaWF0ZSA6IEltbWVkaWF0ZSkgKE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlKSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGU2NF1cblxuICAgIHR5cGUgJ2EgcmVwciA9XG4gICAgICB8IEltbWVkaWF0ZSA6IEltbWVkaWF0ZS50IHJlcHJcbiAgICAgIHwgTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUudCByZXByXG5cbiAgICB2YWwgcmVwciA6IHQgcmVwclxuICBlbmRcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBOb25faW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGVdXG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlIChJbW1lZGlhdGUgOiBJbW1lZGlhdGUpIChOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZSkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG5cbiAgICB0eXBlICdhIHJlcHIgPVxuICAgICAgfCBJbW1lZGlhdGUgOiBJbW1lZGlhdGUudCByZXByXG4gICAgICB8IE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlLnQgcmVwclxuXG4gICAgZXh0ZXJuYWwgdHJhbnNwYXJlbnRfbWFnaWMgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYltAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5cbiAgICBsZXQgcmVwciA9XG4gICAgICAoKiBbT2JqLm1hZ2ljXSBpbnZvbHZlcyBvcGFxdWVuZXNzIHVuZGVyIEZsYW1iZGEgMiB3aGljaCB3aWxsIGluaGliaXRcbiAgICAgICAgIGF2YWlsYWJpbGl0eSBvZiBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSBmb3IgbGF0ZXIgaW5saW5pbmdcbiAgICAgICAgIChlLmcuIGludG8gZmxvYXQubWwpLiBBcyBzdWNoIHdlIGV4cGxpY2l0bHkgdXNlICVpZGVudGl0eSBoZXJlLiAqKVxuICAgICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgICB8IFc2NCAtPiAodHJhbnNwYXJlbnRfbWFnaWMgSW1tZWRpYXRlIDogdCByZXByKVxuICAgICAgfCBXMzIgLT4gKHRyYW5zcGFyZW50X21hZ2ljIE5vbl9pbW1lZGlhdGUgOiB0IHJlcHIpXG4gICAgOztcbiAgZW5kXG4gIFtAQGlubGluZSBhbHdheXNdXG5lbmRcblxuaW5jbHVkZSBJbW1lZGlhdGU2NC5NYWtlIChJbnQpIChJbnQ2M19lbXVsKVxuXG5tb2R1bGUgQmFja2VuZCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIEludF9pbnRmLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gICAgdmFsIHRvX2ludCA6IHQgLT4gaW50IG9wdGlvblxuICAgIHZhbCB0b19pbnRfdHJ1bmMgOiB0IC0+IGludFxuICAgIHZhbCBvZl9pbnQzMiA6IGludDMyIC0+IHRcbiAgICB2YWwgdG9faW50MzIgOiB0IC0+IEludDMyLnQgb3B0aW9uXG4gICAgdmFsIHRvX2ludDMyX3RydW5jIDogdCAtPiBJbnQzMi50XG4gICAgdmFsIG9mX2ludDY0IDogSW50NjQudCAtPiB0IG9wdGlvblxuICAgIHZhbCBvZl9pbnQ2NF90cnVuYyA6IEludDY0LnQgLT4gdFxuICAgIHZhbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gdCBvcHRpb25cbiAgICB2YWwgdG9fbmF0aXZlaW50IDogdCAtPiBuYXRpdmVpbnQgb3B0aW9uXG4gICAgdmFsIG9mX25hdGl2ZWludF90cnVuYyA6IG5hdGl2ZWludCAtPiB0XG4gICAgdmFsIHRvX25hdGl2ZWludF90cnVuYyA6IHQgLT4gbmF0aXZlaW50XG4gICAgdmFsIG9mX2Zsb2F0X3VuY2hlY2tlZCA6IGZsb2F0IC0+IHRcbiAgICB2YWwgcmVwciA6ICh0LCB0KSBJbnQ2M19lbXVsLlJlcHIudFxuICAgIHZhbCBic3dhcDE2IDogdCAtPiB0XG4gICAgdmFsIGJzd2FwMzIgOiB0IC0+IHRcbiAgICB2YWwgYnN3YXA0OCA6IHQgLT4gdFxuICBlbmRcbiAgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIG1vZHVsZSBOYXRpdmUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEludFxuXG4gICAgbGV0IHRvX2ludCB4ID0gU29tZSB4XG4gICAgbGV0IHRvX2ludF90cnVuYyB4ID0geFxuXG4gICAgKCogW29mX2ludDMyX2V4bl0gaXMgYSBzYWZlIG9wZXJhdGlvbiBvbiBwbGF0Zm9ybXMgd2l0aCA2NC1iaXQgd29yZCBzaXplcy4gKilcbiAgICBsZXQgb2ZfaW50MzIgPSBvZl9pbnQzMl9leG5cbiAgICBsZXQgdG9fbmF0aXZlaW50X3RydW5jIHggPSB0b19uYXRpdmVpbnQgeFxuICAgIGxldCB0b19uYXRpdmVpbnQgeCA9IFNvbWUgKHRvX25hdGl2ZWludCB4KVxuICAgIGxldCByZXByID0gSW50NjNfZW11bC5SZXByLkludFxuICAgIGxldCBic3dhcDMyIHQgPSBJbnQ2NC50b19pbnRfdHJ1bmMgKEludDY0LmJzd2FwMzIgKEludDY0Lm9mX2ludCB0KSlcbiAgICBsZXQgYnN3YXA0OCB0ID0gSW50NjQudG9faW50X3RydW5jIChJbnQ2NC5ic3dhcDQ4IChJbnQ2NC5vZl9pbnQgdCkpXG4gIGVuZFxuXG4gIGxldCBpbXBsIDogKG1vZHVsZSBTKSA9XG4gICAgbWF0Y2ggcmVwciB3aXRoXG4gICAgfCBJbW1lZGlhdGUgLT4gKG1vZHVsZSBOYXRpdmUgOiBTKVxuICAgIHwgTm9uX2ltbWVkaWF0ZSAtPiAobW9kdWxlIEludDYzX2VtdWwgOiBTKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgKHZhbCBCYWNrZW5kLmltcGwgOiBCYWNrZW5kLlMpXG5cbm1vZHVsZSBPdmVyZmxvd19leG4gPSBzdHJ1Y3RcbiAgbGV0ICggKyApIHQgdSA9XG4gICAgbGV0IHN1bSA9IHQgKyB1IGluXG4gICAgaWYgYml0X29yIChiaXRfeG9yIHQgdSkgKGJpdF94b3IgdCAoYml0X25vdCBzdW0pKSA8IHplcm9cbiAgICB0aGVuIHN1bVxuICAgIGVsc2VcbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggKyApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJzdW1cIiwgc2V4cF9vZl90IHN1bSBdKVxuICA7O1xuXG4gIGxldCAoIC0gKSB0IHUgPVxuICAgIGxldCBkaWZmID0gdCAtIHUgaW5cbiAgICBsZXQgcG9zX2RpZmYgPSB0ID4gdSBpblxuICAgIGlmIHQgPD4gdSAmJiBCb29sLiggPD4gKSBwb3NfZGlmZiAoaXNfcG9zaXRpdmUgZGlmZilcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoIC0gKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwiZGlmZlwiLCBzZXhwX29mX3QgZGlmZiBdKVxuICAgIGVsc2UgZGlmZlxuICA7O1xuXG4gIGxldCBuZWdhdGl2ZV9vbmUgPSBvZl9pbnQgKC0xKVxuICBsZXQgZGl2X3dvdWxkX292ZXJmbG93IHQgdSA9IHQgPSBtaW5fdmFsdWUgJiYgdSA9IG5lZ2F0aXZlX29uZVxuXG4gIGxldCAoICogKSB0IHUgPVxuICAgIGxldCBwcm9kdWN0ID0gdCAqIHUgaW5cbiAgICBpZiB1IDw+IHplcm8gJiYgKGRpdl93b3VsZF9vdmVyZmxvdyBwcm9kdWN0IHUgfHwgcHJvZHVjdCAvIHUgPD4gdClcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoICogKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwicHJvZHVjdFwiLCBzZXhwX29mX3QgcHJvZHVjdCBdKVxuICAgIGVsc2UgcHJvZHVjdFxuICA7O1xuXG4gIGxldCAoIC8gKSB0IHUgPVxuICAgIGlmIGRpdl93b3VsZF9vdmVyZmxvdyB0IHVcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoIC8gKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwicHJvZHVjdFwiLCBzZXhwX29mX3QgKHQgLyB1KSBdKVxuICAgIGVsc2UgdCAvIHVcbiAgOztcblxuICBsZXQgYWJzIHQgPSBpZiB0ID0gbWluX3ZhbHVlIHRoZW4gZmFpbHdpdGggXCJhYnMgb3ZlcmZsb3dcIiBlbHNlIGFicyB0XG4gIGxldCBuZWcgdCA9IGlmIHQgPSBtaW5fdmFsdWUgdGhlbiBmYWlsd2l0aCBcIm5lZyBvdmVyZmxvd1wiIGVsc2UgbmVnIHRcbmVuZFxuXG5sZXQgKCkgPSBhc3NlcnQgKEludC4oID0gKSBudW1fYml0cyA2MylcblxubGV0IHJhbmRvbV9vZl9pbnQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBib3VuZCA9XG4gIG9mX2ludCAoUmFuZG9tLlN0YXRlLmludCBzdGF0ZSAodG9faW50X2V4biBib3VuZCkpXG47O1xuXG5sZXQgcmFuZG9tX29mX2ludDY0ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgYm91bmQgPVxuICBvZl9pbnQ2NF9leG4gKFJhbmRvbS5TdGF0ZS5pbnQ2NCBzdGF0ZSAodG9faW50NjQgYm91bmQpKVxuOztcblxubGV0IHJhbmRvbSA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiByYW5kb21fb2ZfaW50XG4gIHwgVzMyIC0+IHJhbmRvbV9vZl9pbnQ2NFxuOztcblxubGV0IHJhbmRvbV9pbmNsX29mX2ludCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxvIGhpID1cbiAgb2ZfaW50IChSYW5kb20uU3RhdGUuaW50X2luY2wgc3RhdGUgKHRvX2ludF9leG4gbG8pICh0b19pbnRfZXhuIGhpKSlcbjs7XG5cbmxldCByYW5kb21faW5jbF9vZl9pbnQ2NCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxvIGhpID1cbiAgb2ZfaW50NjRfZXhuIChSYW5kb20uU3RhdGUuaW50NjRfaW5jbCBzdGF0ZSAodG9faW50NjQgbG8pICh0b19pbnQ2NCBoaSkpXG47O1xuXG5sZXQgcmFuZG9tX2luY2wgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gcmFuZG9tX2luY2xfb2ZfaW50XG4gIHwgVzMyIC0+IHJhbmRvbV9pbmNsX29mX2ludDY0XG47O1xuXG5sZXQgZmxvb3JfbG9nMiB0ID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHQgfD4gdG9faW50X2V4biB8PiBJbnQuZmxvb3JfbG9nMlxuICB8IFczMiAtPlxuICAgIGlmIHQgPD0gemVyb1xuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl90IHQgXSk7XG4gICAgbGV0IGZsb29yX2xvZzIgPSByZWYgKEludC4oIC0gKSBudW1fYml0cyAyKSBpblxuICAgIHdoaWxlIGVxdWFsIHplcm8gKGJpdF9hbmQgdCAoc2hpZnRfbGVmdCBvbmUgIWZsb29yX2xvZzIpKSBkb1xuICAgICAgZmxvb3JfbG9nMiA6PSBJbnQuKCAtICkgIWZsb29yX2xvZzIgMVxuICAgIGRvbmU7XG4gICAgIWZsb29yX2xvZzJcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBSZXByID0gUmVwclxuXG4gIGxldCByZXByID0gcmVwclxuXG4gIG1vZHVsZSBFbXVsID0gSW50NjNfZW11bFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzQ4MTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiS2V5IiwiTWVyZ2VfaW50b19hY3Rpb24iLCJCYXNlX0hhc2h0YmxfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzQ4MjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3NyY19hdmx0cmVlX21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiQmFzZV9TZXhwIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0ltcG9ydCIsIkJhc2VfRXJyb3IiLCJyYWlzZV9zIiwibWF4IiwieCIsInkiLCJjc3RfQXZsdHJlZV9jaG9vc2VfZXhuX29mX2VtcHQiLCJkdW1teSIsImlzX2VtcHR5IiwicGFyYW0iLCJoZWlnaHQiLCJpbnZhcmlhbnQiLCJ0IiwiY29tcGFyZSIsImludiIsImxlZnQiLCJrZXkiLCJoIiwicmlnaHQiLCJociIsImhsIiwibGVmdF9rZXkiLCJyaWdodF9rZXkiLCJ1cGRhdGVfaGVpZ2h0Iiwib2xkX2hlaWdodCIsIm5ld19oZWlnaHQiLCJiYWxhbmNlIiwicm9vdF9ub2RlIiwibGVmdF9ub2RlIiwicmlnaHRfbm9kZSIsImxlZnRfbm9kZV9sZWZ0IiwibGVmdF9ub2RlX3JpZ2h0IiwibHJfbGVmdCIsImxyX3JpZ2h0IiwicmlnaHRfbm9kZV9sZWZ0IiwicmlnaHRfbm9kZV9yaWdodCIsInJsX2xlZnQiLCJybF9yaWdodCIsInNldF9sZWZ0Iiwibm9kZSIsInRyZWUiLCJzZXRfcmlnaHQiLCJhZGQiLCJyZXBsYWNlIiwiYWRkZWQiLCJrIiwidiIsImMiLCJkYXRhIiwiZmlyc3QiLCJsIiwibGFzdCIsInIiLCJmaW5kaV9hbmRfY2FsbF9pbXBsIiwiYXJnMSIsImFyZzIiLCJjYWxsX2lmX2ZvdW5kIiwiY2FsbF9pZl9ub3RfZm91bmQiLCJpZl9mb3VuZCIsImlmX25vdF9mb3VuZCIsImZpbmRfYW5kX2NhbGwiLCJmaW5kaV9hbmRfY2FsbCIsImFyZyIsImZpbmRfYW5kX2NhbGwxIiwiYSIsImZpbmRpX2FuZF9jYWxsMSIsImZpbmRfYW5kX2NhbGwyIiwiYiIsImZpbmRpX2FuZF9jYWxsMiIsImZpbmQiLCJtZW0iLCJyZW1vdmVfbWluX2VsdCIsInJlbW92ZSIsInJlbW92ZWQiLCJ0MiIsImZvbGQiLCJpbml0IiwibWF0Y2giLCJya2V5IiwicmRhdGEiLCJsa2V5IiwibGRhdGEiLCJpdGVyIiwibWFwaV9pbnBsYWNlIiwidmFsdWUiLCJjaG9vc2VfZXhuIiwiQmFzZV9Bdmx0cmVlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvYXZsdHJlZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFB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QUFBLEtBSUU7QUFBQSxLQUNXO0FBQUEsS0FDWDtBQUFBO0FBQUEsR0FBcUI7QUFBQSxZQUFBbUUsV0FBQTVFO0FBQUFBLElBR1I7QUFBQSxLQUNJLE9BQXlEO0FBQUE7QUFBQSxjQUF6RCw0REFDNEM7QUFBQSxJQUZoRDtBQUFBLFNBQUEyRSxRQUFBLFVBQUFwRSxNQUFBO0FBQUE7QUFBQSxTQUFBQSxRQUFBLFVBQUFvRSxVQUFBLFVBQUFBLFFBRXNDLFNBQUFwRSxNQUFBO0FBQUE7QUFBQSxHQUFVO0FBQUE7QUFBQSxJQUFBc0U7QUFBQUEsTUE1RC9EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQ3ZEYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIEEgZmV3IHNtYWxsIHRoaW5ncyBjb3BpZWQgZnJvbSBvdGhlciBwYXJ0cyBvZiBCYXNlIGJlY2F1c2UgdGhleSBkZXBlbmQgb24gdXMsIHNvIHdlXG4gICBjYW4ndCB1c2UgdGhlbS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIEl0cyBpbXBvcnRhbnQgdGhhdCBFbXB0eSBoYXZlIG5vIGFyZ3MuIEl0J3MgdGVtcHRpbmcgdG8gbWFrZSB0aGlzIHR5cGUgYSByZWNvcmRcbiAgIChlLmcuIHRvIGhvbGQgdGhlIGNvbXBhcmUgZnVuY3Rpb24pLCBidXQgYSBsb3Qgb2YgbWVtb3J5IGlzIHNhdmVkIGJ5IEVtcHR5IGJlaW5nIGFuXG4gICBpbW1lZGlhdGUsIHNpbmNlIGFsbCB1bnVzZWQgYnVja2V0cyBpbiB0aGUgaGFzaHRibCBkb24ndCB1c2UgYW55IG1lbW9yeSAoYmVzaWRlcyB0aGVcbiAgIGFycmF5IGNlbGwpICopXG50eXBlICgnaywgJ3YpIHQgPVxuICB8IEVtcHR5XG4gIHwgTm9kZSBvZlxuICAgICAgeyBtdXRhYmxlIGxlZnQgOiAoJ2ssICd2KSB0XG4gICAgICA7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgOyBtdXRhYmxlIGhlaWdodCA6IGludFxuICAgICAgOyBtdXRhYmxlIHJpZ2h0IDogKCdrLCAndikgdFxuICAgICAgfVxuICB8IExlYWYgb2ZcbiAgICAgIHsga2V5IDogJ2tcbiAgICAgIDsgbXV0YWJsZSB2YWx1ZSA6ICd2XG4gICAgICB9XG5cbmxldCBlbXB0eSA9IEVtcHR5XG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gdHJ1ZVxuICB8IExlYWYgXyB8IE5vZGUgXyAtPiBmYWxzZVxuOztcblxubGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gMFxuICB8IExlYWYgXyAtPiAxXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodDsgcmlnaHQgPSBfIH0gLT4gaGVpZ2h0XG47O1xuXG5sZXQgaW52YXJpYW50IGNvbXBhcmUgPVxuICBsZXQgbGVnYWxfbGVmdF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gbGVmdF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+XG4gICAgICBhc3NlcnQgKGNvbXBhcmUgbGVmdF9rZXkga2V5IDwgMClcbiAgaW5cbiAgbGV0IGxlZ2FsX3JpZ2h0X2tleSBrZXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IHJpZ2h0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIHJpZ2h0X2tleSBrZXkgPiAwKVxuICBpblxuICBsZXQgcmVjIGludiA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSB8IExlYWYgXyAtPiAoKVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGs7IHZhbHVlID0gXzsgaGVpZ2h0ID0gaDsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGhsLCBociA9IGhlaWdodCBsZWZ0LCBoZWlnaHQgcmlnaHQgaW5cbiAgICAgIGludiBsZWZ0O1xuICAgICAgaW52IHJpZ2h0O1xuICAgICAgbGVnYWxfbGVmdF9rZXkgayBsZWZ0O1xuICAgICAgbGVnYWxfcmlnaHRfa2V5IGsgcmlnaHQ7XG4gICAgICBhc3NlcnQgKGggPSBJbnQubWF4IGhsIGhyICsgMSk7XG4gICAgICBhc3NlcnQgKGFicyAoaGwgLSBocikgPD0gMilcbiAgaW5cbiAgaW52XG47O1xuXG5sZXQgaW52YXJpYW50IHQgfmNvbXBhcmUgPSBpbnZhcmlhbnQgY29tcGFyZSB0XG5cbigqIEluIHRoZSBmb2xsb3dpbmcgY29tbWVudHMsXG4gICAndCBpcyBiYWxhbmNlZCcgbWVhbnMgdGhhdCAnaW52YXJpYW50IHQnIGRvZXMgbm90XG4gICByYWlzZSBhbiBleGNlcHRpb24uICBUaGlzIGltcGxpZXMgb2YgY291cnNlIHRoYXQgZWFjaCBub2RlJ3MgaGVpZ2h0IGZpZWxkIGlzXG4gICBjb3JyZWN0LlxuICAgJ3QgaXMgYmFsYW5jZWFibGUnIG1lYW5zIHRoYXQgaGVpZ2h0IG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBvZiB0XG4gICBkaWZmZXIgYnkgYXQgbW9zdCAzLiAqKVxuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBoYXZlIGNvcnJlY3QgaGVpZ2h0c1xuICAgQHBvc3Q6IG91dHB1dCBoYXMgdGhlIGNvcnJlY3QgaGVpZ2h0ICopXG5sZXQgdXBkYXRlX2hlaWdodCA9IGZ1bmN0aW9uXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IG9sZF9oZWlnaHQ7IHJpZ2h0IH0gYXMgeCkgLT5cbiAgICBsZXQgbmV3X2hlaWdodCA9IEludC5tYXggKGhlaWdodCBsZWZ0KSAoaGVpZ2h0IHJpZ2h0KSArIDEgaW5cbiAgICBpZiBuZXdfaGVpZ2h0IDw+IG9sZF9oZWlnaHQgdGhlbiB4LmhlaWdodCA8LSBuZXdfaGVpZ2h0XG4gIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBhcmUgYmFsYW5jZWRcbiAgIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwb3N0OiBvdXRwdXQgaXMgYmFsYW5jZWQgKGluIHBhcnRpY3VsYXIsIGhlaWdodCBpcyBjb3JyZWN0KSAqKVxubGV0IGJhbGFuY2UgdHJlZSA9XG4gIG1hdGNoIHRyZWUgd2l0aFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IHRyZWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByb290X25vZGUpIC0+XG4gICAgbGV0IGhsID0gaGVpZ2h0IGxlZnRcbiAgICBhbmQgaHIgPSBoZWlnaHQgcmlnaHQgaW5cbiAgICAoKiArIDIgaXMgY3JpdGljYWxseSBpbXBvcnRhbnQsIGxvd2VyaW5nIGl0IHRvIDEgd2lsbCBicmVhayB0aGUgTGVhZlxuICAgICAgIGFzc3VtcHRpb25zIGluIHRoZSBjb2RlIGJlbG93LCBhbmQgd2lsbCBmb3JjZSB1cyB0byBwcm9tb3RlIGxlYWYgbm9kZXMgaW5cbiAgICAgICB0aGUgYmFsYW5jZSByb3V0aW5lLiBJdCdzIGFsc28gZmFzdGVyLCBzaW5jZSBpdCB3aWxsIGJhbGFuY2UgbGVzcyBvZnRlbi5cbiAgICAgICBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBjb2RlIGlzIGRlbGljYXRlLiAgVGhlIHVwZGF0ZV9oZWlnaHQgY2FsbHMgbXVzdFxuICAgICAgIG9jY3VyIGluIHRoZSBjb3JyZWN0IG9yZGVyLCBzaW5jZSB1cGRhdGVfaGVpZ2h0IGFzc3VtZXMgaXRzIGNoaWxkcmVuIGhhdmVcbiAgICAgICB0aGUgY29ycmVjdCBoZWlnaHRzLiAgKilcbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbGVmdCB3aXRoXG4gICAgICAoKiBJdCBjYW5ub3QgYmUgYSBsZWFmLCBiZWNhdXNlIGV2ZW4gaWYgcmlnaHQgaXMgZW1wdHksIGEgbGVhZlxuICAgICAgICAgaXMgb25seSBoZWlnaHQgMSAqKVxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSBsZWZ0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSBsZWZ0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyBsZWZ0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCBsZWZ0X25vZGVfbGVmdCA+PSBoZWlnaHQgbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgIGxlZnQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGlmIHJpZ2h0IGlzIGEgbGVhZiwgdGhlbiBsZWZ0IG11c3QgYmUgZW1wdHkuIFRoYXQgbWVhbnNcbiAgICAgICAgICAgICBoZWlnaHQgaXMgMi4gRXZlbiBpZiBociBpcyBlbXB0eSB3ZSBzdGlsbCBjYW4ndCBnZXQgaGVyZS4gKilcbiAgICAgICAgICBtYXRjaCBsZWZ0X25vZGVfcmlnaHQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBscl9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gbHJfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICAgbHJfbm9kZSkgLT5cbiAgICAgICAgICAgIGxlZnRfbm9kZS5yaWdodCA8LSBscl9sZWZ0O1xuICAgICAgICAgICAgcm9vdF9ub2RlLmxlZnQgPC0gbHJfcmlnaHQ7XG4gICAgICAgICAgICBscl9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgICBscl9ub2RlLmxlZnQgPC0gbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdF9ub2RlX3JpZ2h0O1xuICAgICAgICAgICAgbGVmdF9ub2RlX3JpZ2h0KSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSByaWdodCBjYW5ub3QgYmUgYSBsZWFmICopXG4gICAgICBtYXRjaCByaWdodCB3aXRoXG4gICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBOb2RlXG4gICAgICAgICAgKHsgbGVmdCA9IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSByaWdodF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgcmlnaHRfbm9kZSkgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJpZ2h0X25vZGVfcmlnaHQgPj0gaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmlnaHRfbm9kZV9sZWZ0O1xuICAgICAgICAgIHJpZ2h0X25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0O1xuICAgICAgICAgIHJpZ2h0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIGNhbm5vdCBiZSBhIGxlYWYgKilcbiAgICAgICAgICBtYXRjaCByaWdodF9ub2RlX2xlZnQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBybF9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gcmxfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICAgcmxfbm9kZSkgLT5cbiAgICAgICAgICAgIHJpZ2h0X25vZGUubGVmdCA8LSBybF9yaWdodDtcbiAgICAgICAgICAgIHJvb3Rfbm9kZS5yaWdodCA8LSBybF9sZWZ0O1xuICAgICAgICAgICAgcmxfbm9kZS5sZWZ0IDwtIHRyZWU7XG4gICAgICAgICAgICBybF9ub2RlLnJpZ2h0IDwtIHJpZ2h0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHRfbm9kZV9sZWZ0O1xuICAgICAgICAgICAgcmlnaHRfbm9kZV9sZWZ0KSlcbiAgICBlbHNlIChcbiAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgIHRyZWUpXG47O1xuXG4oKiBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcHJlOiBhYnMgKGhlaWdodCAocmlnaHQgbm9kZSkgLSBoZWlnaHQgKGJhbGFuY2UgdHJlZSkpIDw9IDNcbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWFibGUgKilcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKHJpZ2h0IG5vZGUpIC0gaGVpZ2h0IChiYWxhbmNlIHRyZWUpKSA8PSAzXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VhYmxlICopXG5sZXQgc2V0X2xlZnQgbm9kZSB0cmVlID1cbiAgbGV0IHRyZWUgPSBiYWxhbmNlIHRyZWUgaW5cbiAgbWF0Y2ggbm9kZSB3aXRoXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIHIpIC0+XG4gICAgaWYgcGh5c19lcXVhbCBsZWZ0IHRyZWUgdGhlbiAoKSBlbHNlIHIubGVmdCA8LSB0cmVlO1xuICAgIHVwZGF0ZV9oZWlnaHQgbm9kZVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcHJlOiBhYnMgKGhlaWdodCAobGVmdCBub2RlKSAtIGhlaWdodCAoYmFsYW5jZSB0cmVlKSkgPD0gM1xuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlYWJsZSAqKVxubGV0IHNldF9yaWdodCBub2RlIHRyZWUgPVxuICBsZXQgdHJlZSA9IGJhbGFuY2UgdHJlZSBpblxuICBtYXRjaCBub2RlIHdpdGhcbiAgfCBOb2RlICh7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcikgLT5cbiAgICBpZiBwaHlzX2VxdWFsIHJpZ2h0IHRyZWUgdGhlbiAoKSBlbHNlIHIucmlnaHQgPC0gdHJlZTtcbiAgICB1cGRhdGVfaGVpZ2h0IG5vZGVcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogdCBpcyBiYWxhbmNlZC5cbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWQsIHdpdGggbmV3IG5vZGUgaW5zZXJ0ZWRcbiAgIEBwb3N0OiAhYWRkZWQgPSB0cnVlIGlmZiB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IHRyZWUgY2hhbmdlZC4gICopXG5sZXQgYWRkID1cbiAgbGV0IHJlYyBhZGQgdCByZXBsYWNlIGFkZGVkIGNvbXBhcmUgayB2ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICBhZGRlZCA6PSB0cnVlO1xuICAgICAgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gICAgfCBMZWFmICh7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsnIGsgaW5cbiAgICAgICgqIFRoaXMgY29tcGFyZSBpcyByZXZlcnNlZCBvbiBwdXJwb3NlLCB3ZSBhcmUgcHJldGVuZGluZ1xuICAgICAgICAgdGhhdCB0aGUgbGVhZiB3YXMganVzdCBpbnNlcnRlZCBpbnN0ZWFkIG9mIHRoZSBvdGhlciB3YXlcbiAgICAgICAgIHJvdW5kLCB0aGF0IHdheSB3ZSBvbmx5IGFsbG9jYXRlIG9uZSBub2RlLiAqKVxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRlZCA6PSBmYWxzZTtcbiAgICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdjtcbiAgICAgICAgdClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZGRlZCA6PSB0cnVlO1xuICAgICAgICBpZiBjIDwgMFxuICAgICAgICB0aGVuIE5vZGUgeyBsZWZ0ID0gdDsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSAyOyByaWdodCA9IEVtcHR5IH1cbiAgICAgICAgZWxzZSBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IDI7IHJpZ2h0ID0gdCB9KVxuICAgIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmUgayBrJyBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRlZCA6PSBmYWxzZTtcbiAgICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdilcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gc2V0X2xlZnQgdCAoYWRkIGxlZnQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdilcbiAgICAgIGVsc2Ugc2V0X3JpZ2h0IHQgKGFkZCByaWdodCByZXBsYWNlIGFkZGVkIGNvbXBhcmUgayB2KTtcbiAgICAgIHRcbiAgaW5cbiAgZnVuIHQgfnJlcGxhY2UgfmNvbXBhcmUgfmFkZGVkIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQgdCA9IGFkZCB0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrZXkgZGF0YSBpblxuICAgIGlmICFhZGRlZCB0aGVuIGJhbGFuY2UgdCBlbHNlIHRcbjs7XG5cbmxldCByZWMgZmlyc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IGZpcnN0IGxcbjs7XG5cbmxldCByZWMgbGFzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IEVtcHR5IH0gLT4gU29tZSAoaywgdilcbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSByIH0gLT4gbGFzdCByXG47O1xuXG5cbmxldFtAaW5saW5lIGFsd2F5c10gcmVjIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y29tcGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnMlxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmlmX2ZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5pZl9ub3RfZm91bmRcbiAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGsgYXJnMSBhcmcyXG4gIHwgTGVhZiB7IGtleSA9IGsnOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlIGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQgayBhcmcxIGFyZzJcbiAgfCBOb2RlIHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgaWYgYyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlXG4gICAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICAgIChpZiBjIDwgMCB0aGVuIGxlZnQgZWxzZSByaWdodClcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAga1xuICAgICAgICBhcmcxXG4gICAgICAgIGFyZzJcbiAgICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICAgIH5pZl9mb3VuZFxuICAgICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCBkYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcgKCkgPSBpZl9mb3VuZCBkYXRhIGFyZyBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnICgpID0gaWZfbm90X2ZvdW5kIGtleSBhcmcgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnICgpID0gaWZfZm91bmQgfmtleSB+ZGF0YSBhcmcgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZyAoKSA9IGlmX25vdF9mb3VuZCBrZXkgYXJnIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwyID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCBkYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDIgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIC0+IGZpbmRfYW5kX2NhbGwgdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgbWVtID1cbiAgbGV0IGlmX2ZvdW5kIF8gPSB0cnVlIGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IGZhbHNlIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgLT4gZmluZF9hbmRfY2FsbCB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCByZW1vdmUgPVxuICBsZXQgcmVjIG1pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiBfIC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gbWluX2VsdCBsZWZ0XG4gIGluXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IExlYWYgXyAtPiBFbXB0eSAoKiBUaGlzIG11c3QgYmUgdGhlIHJvb3QgKilcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPiByaWdodFxuICAgIHwgTm9kZSB7IGxlZnQgPSBMZWFmIF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+XG4gICAgICBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gTGVhZiBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIG5vZGUgLT5cbiAgICAgIHNldF9sZWZ0IG5vZGUgRW1wdHk7XG4gICAgICB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyBub2RlIC0+XG4gICAgICBzZXRfbGVmdCBub2RlIChyZW1vdmVfbWluX2VsdCBsZWZ0KTtcbiAgICAgIHRyZWVcbiAgaW5cbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPlxuICAgICAgbGV0IHRyZWUgPSBtaW5fZWx0IHQyIGluXG4gICAgICAobWF0Y2ggdHJlZSB3aXRoXG4gICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgICAgICAgbGV0IHQyID0gYmFsYW5jZSAocmVtb3ZlX21pbl9lbHQgdDIpIGluXG4gICAgICAgICBOb2RlXG4gICAgICAgICAgIHsgbGVmdCA9IHQxXG4gICAgICAgICAgIDsga2V5ID0ga1xuICAgICAgICAgICA7IHZhbHVlID0gdlxuICAgICAgICAgICA7IGhlaWdodCA9IEludC5tYXggKGhlaWdodCB0MSkgKGhlaWdodCB0MikgKyAxXG4gICAgICAgICAgIDsgcmlnaHQgPSB0MlxuICAgICAgICAgICB9XG4gICAgICAgfCBOb2RlIF8gYXMgbm9kZSAtPlxuICAgICAgICAgc2V0X3JpZ2h0IG5vZGUgKHJlbW92ZV9taW5fZWx0IHQyKTtcbiAgICAgICAgIHNldF9sZWZ0IG5vZGUgdDE7XG4gICAgICAgICBub2RlKVxuICBpblxuICBsZXQgcmVjIHJlbW92ZSB0IHJlbW92ZWQgY29tcGFyZSBrID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICByZW1vdmVkIDo9IGZhbHNlO1xuICAgICAgRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICByZW1vdmVkIDo9IHRydWU7XG4gICAgICAgIEVtcHR5KVxuICAgICAgZWxzZSAoXG4gICAgICAgIHJlbW92ZWQgOj0gZmFsc2U7XG4gICAgICAgIHQpXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBtZXJnZSBsZWZ0IHJpZ2h0KVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHNldF9sZWZ0IHQgKHJlbW92ZSBsZWZ0IHJlbW92ZWQgY29tcGFyZSBrKTtcbiAgICAgICAgdClcbiAgICAgIGVsc2UgKFxuICAgICAgICBzZXRfcmlnaHQgdCAocmVtb3ZlIHJpZ2h0IHJlbW92ZWQgY29tcGFyZSBrKTtcbiAgICAgICAgdClcbiAgaW5cbiAgZnVuIHQgfnJlbW92ZWQgfmNvbXBhcmUgayAtPiBiYWxhbmNlIChyZW1vdmUgdCByZW1vdmVkIGNvbXBhcmUgaylcbjs7XG5cbmxldCByZWMgZm9sZCB0IH5pbml0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gaW5pdFxuICB8IExlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YSBpbml0XG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gRW1wdHlcbiAgICAgIH0gLT4gZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IEVtcHR5XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH1cbiAgICAgIH0gLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSBpbml0KVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfSB9XG4gICAgLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfVxuICAgIC0+IGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdCkpIH5mXG4gIHwgTm9kZSB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgZm9sZCByaWdodCB+aW5pdDooZiB+a2V5IH5kYXRhIChmb2xkIGxlZnQgfmluaXQgfmYpKSB+ZlxuOztcblxubGV0IHJlYyBpdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YVxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGl0ZXIgbGVmdCB+ZjtcbiAgICBmIH5rZXkgfmRhdGE7XG4gICAgaXRlciByaWdodCB+ZlxuOztcblxubGV0IHJlYyBtYXBpX2lucGxhY2UgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+ICgpXG4gIHwgTGVhZiAoeyBrZXk7IHZhbHVlIH0gYXMgdCkgLT4gdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleTsgdmFsdWU7IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgdCkgLT5cbiAgICBtYXBpX2lucGxhY2UgfmYgbGVmdDtcbiAgICB0LnZhbHVlIDwtIGYgfmtleSB+ZGF0YTp2YWx1ZTtcbiAgICBtYXBpX2lucGxhY2UgfmYgcmlnaHRcbjs7XG5cbmxldCBjaG9vc2VfZXhuID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbQXZsdHJlZS5jaG9vc2VfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pXG4gIHwgTGVhZiB7IGtleTsgdmFsdWU7IF8gfSB8IE5vZGUgeyBrZXk7IHZhbHVlOyBfIH0gLT4ga2V5LCB2YWx1ZVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozNTQxNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfc3JjX2hhc2h0YmxfbWwiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJjYW1sX2NhbGw2IiwiYTUiLCJjYW1sX2NhbGw3IiwiYTYiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQXZsdHJlZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9IYXNoYWJsZSIsIkJhc2VfQXJyYXkiLCJCYXNlX0xpc3QiLCJCYXNlX09yX2Vycm9yIiwiQmFzZV9TZXhwIiwiU2V4cGxpYjBfU2V4cF9ncmFtbWFyIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0Vycm9yIiwiQmFzZV9PcHRpb24iLCJCYXNlX1JhbmRvbSIsIkJhc2VfSW50IiwiQmFzZV9XaXRoX3JldHVybiIsIndpdGhfcmV0dXJuIiwiaGFzaF9wYXJhbSIsImhhc2giLCJyYWlzZV9zIiwiY3N0X0hhc2h0YmxfbXV0YXRpb25fbm90X2FsbG93Iiwic2V4cF9vZl9rZXkiLCJ0IiwiY29tcGFyZV9rZXkiLCJlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCIsIndpdGhvdXRfbXV0YXRpbmciLCJ4IiwiZXhuIiwibWF4X3RhYmxlX2xlbmd0aCIsImNzdF9IYXNodGJsX2FkZF9leG5fZ290X2tleV9hbCIsImNzdF9IYXNodGJsX2Nob29zZV9leG5fb2ZfZW1wdCIsImNzdF9IYXNodGJsX2Nob29zZV9yYW5kb21seV9leCIsImNzdF9IYXNodGJsX29mX2FsaXN0X2V4bl9kdXBsaSIsImNzdF9IYXNodGJsX3Rfb2Zfc2V4cF9kdXBsaWNhdCIsImNzdF9rZXlzIiwiY3N0X0hhc2h0YmxfY3JlYXRlX3dpdGhfa2V5X2R1IiwiY3N0X0hhc2h0YmxfbWVyZ2VfZGlmZmVyZW50X2hhIiwiY3JlYXRlIiwib3B0IiwiaGFzaGFibGUiLCJwYXJhbSIsImdyb3d0aF9hbGxvd2VkIiwic2l6ZSIsInNsb3QiLCJrZXkiLCJhZGRfd29ya2VyIiwicmVwbGFjZSIsImRhdGEiLCJpIiwicm9vdCIsImFkZGVkIiwibmV3X3Jvb3QiLCJtYXliZV9yZXNpemVfdGFibGUiLCJsZW4iLCJzaG91bGRfZ3JvdyIsIm5ld19hcnJheV9sZW5ndGgiLCJuZXdfdGFibGUiLCJvbGRfdGFibGUiLCJzZXQiLCJhZGQiLCJhZGRfZXhuIiwiZXJyb3IiLCJjbGVhciIsImZpbmRfYW5kX2NhbGwiLCJpZl9mb3VuZCIsImlmX25vdF9mb3VuZCIsInRyZWUiLCJrIiwidiIsImZpbmRfYW5kX2NhbGwxIiwiYSIsImZpbmRfYW5kX2NhbGwyIiwiYiIsImZpbmRpX2FuZF9jYWxsIiwiZmluZGlfYW5kX2NhbGwxIiwiZmluZGlfYW5kX2NhbGwyIiwiZmluZCIsIm1lbSIsInJlbW92ZSIsImFkZGVkX29yX3JlbW92ZWQiLCJsZW5ndGgiLCJpc19lbXB0eSIsImZvbGQiLCJpbml0IiwibiIsImFjYyIsIm0iLCJidWNrZXQiLCJpdGVyaSIsIml0ZXIiLCJpdGVyX2tleXMiLCJjaG9vc2Vfbm9uZW1wdHkiLCJ0YWJsZSIsImF2bHRyZWUiLCJjaG9vc2VfZXhuIiwiY2hvb3NlIiwiY2hvb3NlX3JhbmRvbWx5X25vbmVtcHR5IiwicmFuZG9tX3N0YXRlIiwic3RhcnRfaWR4IiwiY2hvb3NlX3JhbmRvbWx5IiwiY2hvb3NlX3JhbmRvbWx5X2V4biIsImludmFyaWFudCIsImludmFyaWFudF9rZXkiLCJpbnZhcmlhbnRfZGF0YSIsInJlYWxfbGVuIiwiZmluZF9leG4iLCJleGlzdHNpIiwiciIsImV4aXN0cyIsImZvcl9hbGxpIiwiZm9yX2FsbCIsImNvdW50aSIsImNvdW50IiwibWFwaSIsIm5ld190IiwibWFwIiwiY29weSIsImZpbHRlcl9tYXBpIiwibWF0Y2giLCJuZXdfZGF0YSIsImZpbHRlcl9tYXAiLCJmaWx0ZXJpIiwiZmlsdGVyIiwiZmlsdGVyX2tleXMiLCJwYXJ0aXRpb25fbWFwaSIsInQwIiwidDEiLCJwYXJ0aXRpb25fbWFwIiwicGFydGl0aW9uaV90ZiIsInBhcnRpdGlvbl90ZiIsImZpbmRfb3JfYWRkIiwiaWQiLCJkZWZhdWx0IiwiZmluZGlfb3JfYWRkIiwiZmluZF9hbmRfcmVtb3ZlIiwicmVzdWx0IiwiY2hhbmdlIiwidXBkYXRlX2FuZF9yZXR1cm4iLCJ1cGRhdGUiLCJpbmNyX2J5IiwicmVtb3ZlX2lmX3plcm8iLCJieSIsImluY3IiLCJkZWNyIiwiYWRkX211bHRpIiwibCIsInJlbW92ZV9tdWx0aSIsInRsIiwiZmluZF9tdWx0aSIsImNyZWF0ZV9tYXBwZWQiLCJnZXRfa2V5IiwiZ2V0X2RhdGEiLCJyb3dzIiwicyIsInJlcyIsImR1cGVzIiwia2V5cyIsIm9mX2FsaXN0IiwibHN0Iiwib2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJlIiwib2ZfYWxpc3RfbXVsdGkiLCJ0b19hbGlzdCIsImxpc3QiLCJzZXhwX29mX3QiLCJzZXhwX29mX2RhdGEiLCJrMiIsImsxIiwidF9vZl9zZXhwIiwia19vZl9zZXhwIiwiZF9vZl9zZXhwIiwic2V4cCIsImFsaXN0IiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInRfc2V4cF9ncmFtbWFyIiwia19ncmFtbWFyIiwidl9ncmFtbWFyIiwiZ3JvdXAiLCJjb21iaW5lIiwiZ3JvdXBzIiwicm93Iiwib2xkIiwiY3JlYXRlX3dpdGhfa2V5IiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIiwiY3JlYXRlX3dpdGhfa2V5X2V4biIsIm1heWJlX3NldCIsImQiLCJtZXJnZSIsInRfbGVmdCIsInRfcmlnaHQiLCJsZWZ0IiwicmlnaHQiLCJtZXJnZV9pbnRvIiwic3JjIiwiZHN0IiwiZHN0X2RhdGEiLCJhY3Rpb24iLCJmaWx0ZXJpX2lucGxhY2UiLCJ0b19yZW1vdmUiLCJhYyIsImZpbHRlcl9pbnBsYWNlIiwiZmlsdGVyX2tleXNfaW5wbGFjZSIsImZpbHRlcl9tYXBpX2lucGxhY2UiLCJtYXBfcmVzdWx0cyIsImZpbHRlcl9tYXBfaW5wbGFjZSIsIm1hcGlfaW5wbGFjZSIsIm1hcF9pbnBsYWNlIiwic2ltaWxhciIsImVxdWFsIiwiQ3JlYXRvcnMiLCJLZXkiLCJQcml2YXRlIiwiaGFzaGFibGVfcyIsIk0iLCJLIiwic2V4cF9vZl9tX3QiLCJzZXhwX29mX3YiLCJtX3Rfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsIm1fdF9zZXhwX2dyYW1tYXIiLCJlcXVhbF9tX3QiLCJlcXVhbF92IiwidDIiLCJCYXNlX0hhc2h0YmwiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9oYXNodGJsLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBVixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVosR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFB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O0FBQUFBLE1BNVVyRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURqb0JGIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaHRibF9pbnRmXG5cbm1vZHVsZSB0eXBlIEtleSA9IEtleS5TXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5sZXQgaGFzaF9wYXJhbSA9IEhhc2hhYmxlLmhhc2hfcGFyYW1cbmxldCBoYXNoID0gSGFzaGFibGUuaGFzaFxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbnR5cGUgKCdrLCAndikgdCA9XG4gIHsgbXV0YWJsZSB0YWJsZSA6ICgnaywgJ3YpIEF2bHRyZWUudCBhcnJheVxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgZ3Jvd3RoX2FsbG93ZWQgOiBib29sXG4gIDsgaGFzaGFibGUgOiAnayBIYXNoYWJsZS50XG4gIDsgbXV0YWJsZSBtdXRhdGlvbl9hbGxvd2VkIDogYm9vbCAoKiBTZXQgZHVyaW5nIGFsbCBpdGVyYXRpb24gb3BlcmF0aW9ucyAqKVxuICB9XG5cbnR5cGUgJ2Ega2V5ID0gJ2FcblxubGV0IHNleHBfb2Zfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdFxubGV0IGNvbXBhcmVfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmVcblxubGV0IGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQgPVxuICBpZiBub3QgdC5tdXRhdGlvbl9hbGxvd2VkIHRoZW4gZmFpbHdpdGggXCJIYXNodGJsOiBtdXRhdGlvbiBub3QgYWxsb3dlZCBkdXJpbmcgaXRlcmF0aW9uXCJcbjs7XG5cbmxldCB3aXRob3V0X211dGF0aW5nIHQgZiA9XG4gIGlmIHQubXV0YXRpb25fYWxsb3dlZFxuICB0aGVuIChcbiAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgbWF0Y2ggZiAoKSB3aXRoXG4gICAgfCB4IC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHhcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSB0cnVlO1xuICAgICAgcmFpc2UgZXhuKVxuICBlbHNlIGYgKClcbjs7XG5cbigqKiBJbnRlcm5hbGx5IHVzZSBhIG1heGltdW0gc2l6ZSB0aGF0IGlzIGEgcG93ZXIgb2YgMi4gUmV2ZXJzZXMgdGhlIGFib3ZlIHRvIGZpbmQgdGhlXG4gICAgZmxvb3IgcG93ZXIgb2YgMiBiZWxvdyB0aGUgc3lzdGVtIG1heCBhcnJheSBsZW5ndGggKilcbmxldCBtYXhfdGFibGVfbGVuZ3RoID0gSW50LmZsb29yX3BvdzIgQXJyYXkubWF4X2xlbmd0aFxuXG4oKiBUaGUgZGVmYXVsdCBzaXplIGlzIGNob3NlbiB0byBiZSAwIChhcyBvcHBvc2VkIHRvIDEyOCBhcyBpdCB3YXMgYmVmb3JlKSBiZWNhdXNlOlxuICAgLSAxMjggY2FuIGNyZWF0ZSBzdWJzdGFudGlhbCBtZW1vcnkgb3ZlcmhlYWQgKHgxMCkgd2hlbiBjcmVhdGluZyBtYW55IHRhYmxlcywgbW9zdFxuICAgICBvZiB3aGljaCBhcmUgbm90IGJpZyAoc2F5LCBpZiB5b3UgaGF2ZSBhIGhhc2h0Ymwgb2YgaGFzaHRibCkuIEFuZCBtZW1vcnkgb3ZlcmhlYWQgaXNcbiAgICAgbm90IHRoYXQgZWFzeSB0byBwcm9maWxlLlxuICAgLSBpZiBhIGhhc2h0YmwgaXMgZ29pbmcgdG8gZ3JvdywgaXQncyBub3QgY2xlYXIgd2h5IDEyOCBpcyBtYXJrZWRseSBiZXR0ZXIgdGhhbiBvdGhlclxuICAgICBzaXplcyAoaWYgeW91IGdvaW5nIHRvIHN0aWNrIDEwMDAgZWxlbWVudHMsIHlvdSdyZSBnb2luZyB0byBncm93IHRoZSBoYXNodGFibGUgb25jZVxuICAgICBvciB0d2ljZSBhbnl3YXkpXG4gICAtIGluIG90aGVyIGxhbmd1YWdlcyAobGlrZSBydXN0LCBweXRob24sIGFuZCBhcHBhcmVudGx5IGdvKSwgdGhlIGRlZmF1bHQgaXMgYWxzbyBhXG4gICAgIHNtYWxsIHNpemUuICopXG5sZXQgY3JlYXRlID8oZ3Jvd3RoX2FsbG93ZWQgPSB0cnVlKSA/KHNpemUgPSAwKSB+aGFzaGFibGUgKCkgPVxuICBsZXQgc2l6ZSA9IEludC5taW4gKEludC5tYXggMSBzaXplKSBtYXhfdGFibGVfbGVuZ3RoIGluXG4gIGxldCBzaXplID0gSW50LmNlaWxfcG93MiBzaXplIGluXG4gIHsgdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpzaXplIEF2bHRyZWUuZW1wdHlcbiAgOyBsZW5ndGggPSAwXG4gIDsgZ3Jvd3RoX2FsbG93ZWRcbiAgOyBoYXNoYWJsZVxuICA7IG11dGF0aW9uX2FsbG93ZWQgPSB0cnVlXG4gIH1cbjs7XG5cbigqKiBTdXBwbGVtZW50YWwgaGFzaC4gVGhpcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSwgaXQgaXMgaW50ZW5kZWQgYXMgYSBkZWZlbnNlIGFnYWluc3QgcG9vclxuICAgIGhhc2ggZnVuY3Rpb25zLCBmb3Igd2hpY2ggdGhlIHBvd2VyIG9mIDIgc2l6ZWQgdGFibGUgd2lsbCBiZSBlc3BlY2lhbGx5IHNlbnNpdGl2ZS5cbiAgICBXaXRoIHNvbWUgdGVzdGluZyB3ZSBtYXkgY2hvb3NlIHRvIGFkZCBpdCwgYnV0IHRoaXMgdGFibGUgaXMgZGVzaWduZWQgdG8gYmUgcm9idXN0IHRvXG4gICAgY29sbGlzaW9ucywgYW5kIGluIG1vc3Qgb2YgbXkgdGVzdGluZyB0aGlzIGRlZ3JhZGVzIHBlcmZvcm1hbmNlLiAqKVxubGV0IF9zdXBwbGVtZW50YWxfaGFzaCBoID1cbiAgbGV0IGggPSBoIGx4b3IgKChoIGxzciAyMCkgbHhvciAoaCBsc3IgMTIpKSBpblxuICBoIGx4b3IgKGggbHNyIDcpIGx4b3IgKGggbHNyIDQpXG47O1xuXG5sZXQgc2xvdCB0IGtleSA9XG4gIGxldCBoYXNoID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5oYXNoIGtleSBpblxuICAoKiB0aGlzIGlzIGFsd2F5cyBub24tbmVnYXRpdmUgYmVjYXVzZSB3ZSBkbyBbbGFuZF0gd2l0aCBub24tbmVnYXRpdmUgbnVtYmVyICopXG4gIGhhc2ggbGFuZCAoQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxKVxuOztcblxubGV0IGFkZF93b3JrZXIgdCB+cmVwbGFjZSB+a2V5IH5kYXRhID1cbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IGFkZGVkID0gIChyZWYgZmFsc2UpIGluXG4gIGxldCBuZXdfcm9vdCA9XG4gICAgKCogVGhlIGF2bCB0cmVlIG1pZ2h0IHJlcGxhY2UgdGhlIHZhbHVlIFtyZXBsYWNlPXRydWVdIG9yIGRvIG5vdGhpbmcgW3JlcGxhY2U9ZmFsc2VdXG4gICAgICAgdG8gdGhlIGVudHJ5LCBpbiB0aGF0IGNhc2UgdGhlIHRhYmxlIGRpZCBub3QgZ2V0IGJpZ2dlciwgc28gd2Ugc2hvdWxkIG5vdFxuICAgICAgIGluY3JlbWVudCBsZW5ndGgsIHdlIHBhc3MgaW4gdGhlIGJvb2wgcmVmIHQuYWRkZWQgc28gdGhhdCBpdCBjYW4gdGVsbCB1cyB3aGV0aGVyXG4gICAgICAgaXQgYWRkZWQgb3IgcmVwbGFjZWQuIFdlIGRvIGl0IHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb24uIFNpbmNlIHRoZSBib29sXG4gICAgICAgaXMgYW4gaW1tZWRpYXRlIGl0IGRvZXMgbm90IGdvIHRocm91Z2ggdGhlIHdyaXRlIGJhcnJpZXIuICopXG4gICAgQXZsdHJlZS5hZGQgfnJlcGxhY2Ugcm9vdCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkgfmFkZGVkIH5rZXkgfmRhdGFcbiAgaW5cbiAgaWYgIWFkZGVkIHRoZW4gdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxO1xuICAoKiBUaGlzIGxpdHRsZSBvcHRpbWl6YXRpb24gc2F2ZXMgYSBjYW1sX21vZGlmeSB3aGVuIHRoZSB0cmVlXG4gICAgIGhhc24ndCBiZWVuIHJlYmFsYW5jZWQuICopXG4gIGlmIG5vdCAocGh5c19lcXVhbCBuZXdfcm9vdCByb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290O1xuICAhYWRkZWRcbjs7XG5cbmxldCBtYXliZV9yZXNpemVfdGFibGUgdCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICBsZXQgc2hvdWxkX2dyb3cgPSB0Lmxlbmd0aCA+IGxlbiBpblxuICBpZiBzaG91bGRfZ3JvdyAmJiB0Lmdyb3d0aF9hbGxvd2VkXG4gIHRoZW4gKFxuICAgIGxldCBuZXdfYXJyYXlfbGVuZ3RoID0gSW50Lm1pbiAobGVuICogMikgbWF4X3RhYmxlX2xlbmd0aCBpblxuICAgIGlmIG5ld19hcnJheV9sZW5ndGggPiBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBuZXdfdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpuZXdfYXJyYXlfbGVuZ3RoIEF2bHRyZWUuZW1wdHkgaW5cbiAgICAgIGxldCBvbGRfdGFibGUgPSB0LnRhYmxlIGluXG4gICAgICB0LnRhYmxlIDwtIG5ld190YWJsZTtcbiAgICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgICBsZXQgZiB+a2V5IH5kYXRhID0gaWdub3JlIChhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhIDogYm9vbCkgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggb2xkX3RhYmxlIC0gMSBkb1xuICAgICAgICBBdmx0cmVlLml0ZXIgb2xkX3RhYmxlLihpKSB+ZlxuICAgICAgZG9uZSkpXG47O1xuXG5sZXQgc2V0IHQgfmtleSB+ZGF0YSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGlnbm9yZSAoYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YSA6IGJvb2wpO1xuICBtYXliZV9yZXNpemVfdGFibGUgdFxuOztcblxubGV0IGFkZCB0IH5rZXkgfmRhdGEgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBsZXQgYWRkZWQgPSBhZGRfd29ya2VyIH5yZXBsYWNlOmZhbHNlIHQgfmtleSB+ZGF0YSBpblxuICBpZiBhZGRlZFxuICB0aGVuIChcbiAgICBtYXliZV9yZXNpemVfdGFibGUgdDtcbiAgICBgT2spXG4gIGVsc2UgYER1cGxpY2F0ZVxuOztcblxubGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgbWF0Y2ggYWRkIHQgfmtleSB+ZGF0YSB3aXRoXG4gIHwgYE9rIC0+ICgpXG4gIHwgYER1cGxpY2F0ZSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5IHQgaW5cbiAgICBsZXQgZXJyb3IgPSBFcnJvci5jcmVhdGUgXCJIYXNodGJsLmFkZF9leG4gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBrZXkgc2V4cF9vZl9rZXkgaW5cbiAgICBFcnJvci5yYWlzZSBlcnJvclxuOztcblxubGV0IGNsZWFyIHQgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgdC50YWJsZS4oaSkgPC0gQXZsdHJlZS5lbXB0eVxuICBkb25lO1xuICB0Lmxlbmd0aCA8LSAwXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgZWxzZSBpZl9ub3RfZm91bmQga2V5XG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbCB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGEgZWxzZSBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgYSBiIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMiB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGVsc2UgaWZfbm90X2ZvdW5kIGtleVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBhIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwxIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGEgYiBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwyXG4gICAgICB0cmVlXG4gICAgICB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgICAgIGtleVxuICAgICAgfmFcbiAgICAgIH5iXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCBrZXkgLT4gZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IG1lbSB0IGtleSA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGZhbHNlXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSBfIH0gLT4gY29tcGFyZV9rZXkgdCBrIGtleSA9IDBcbiAgfCB0cmVlIC0+IEF2bHRyZWUubWVtIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleVxuOztcblxubGV0IHJlbW92ZSB0IGtleSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGxldCBpID0gc2xvdCB0IGtleSBpblxuICBsZXQgcm9vdCA9IHQudGFibGUuKGkpIGluXG4gIGxldCBhZGRlZF9vcl9yZW1vdmVkID0gIChyZWYgZmFsc2UpIGluXG4gIGxldCBuZXdfcm9vdCA9XG4gICAgQXZsdHJlZS5yZW1vdmUgcm9vdCB+cmVtb3ZlZDphZGRlZF9vcl9yZW1vdmVkIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXlcbiAgaW5cbiAgaWYgbm90IChwaHlzX2VxdWFsIHJvb3QgbmV3X3Jvb3QpIHRoZW4gdC50YWJsZS4oaSkgPC0gbmV3X3Jvb3Q7XG4gIGlmICFhZGRlZF9vcl9yZW1vdmVkIHRoZW4gdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGlmIGxlbmd0aCB0ID0gMFxuICB0aGVuIGluaXRcbiAgZWxzZSAoXG4gICAgbGV0IG4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICAgIGxldCBtID0gdC5tdXRhdGlvbl9hbGxvd2VkIGluXG4gICAgbWF0Y2hcbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBmYWxzZTtcbiAgICAgIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IHQudGFibGUgaSB3aXRoXG4gICAgICAgIHwgQXZsdHJlZS5FbXB0eSAtPiAoKVxuICAgICAgICB8IEF2bHRyZWUuTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gYWNjIDo9IGYgfmtleSB+ZGF0YSAhYWNjXG4gICAgICAgIHwgYnVja2V0IC0+IGFjYyA6PSBBdmx0cmVlLmZvbGQgYnVja2V0IH5pbml0OiFhY2MgfmZcbiAgICAgIGRvbmVcbiAgICB3aXRoXG4gICAgfCAoKSAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICAhYWNjXG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgIHJhaXNlIGV4bilcbjs7XG5cbmxldCBpdGVyaSB0IH5mID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gKClcbiAgZWxzZSAoXG4gICAgbGV0IG4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBtID0gdC5tdXRhdGlvbl9hbGxvd2VkIGluXG4gICAgbWF0Y2hcbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBmYWxzZTtcbiAgICAgIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IHQudGFibGUgaSB3aXRoXG4gICAgICAgIHwgQXZsdHJlZS5FbXB0eSAtPiAoKVxuICAgICAgICB8IEF2bHRyZWUuTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gZiB+a2V5IH5kYXRhXG4gICAgICAgIHwgYnVja2V0IC0+IEF2bHRyZWUuaXRlciBidWNrZXQgfmZcbiAgICAgIGRvbmVcbiAgICB3aXRoXG4gICAgfCAoKSAtPiB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbVxuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICByYWlzZSBleG4pXG47O1xuXG5sZXQgaXRlciB0IH5mID0gaXRlcmkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbmxldCBpdGVyX2tleXMgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cblxubGV0IHJlYyBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgaSA9XG4gIGxldCBhdmx0cmVlID0gQXJyYXkudW5zYWZlX2dldCB0YWJsZSBpIGluXG4gIGlmIEF2bHRyZWUuaXNfZW1wdHkgYXZsdHJlZVxuICB0aGVuIGNob29zZV9ub25lbXB0eSB0YWJsZSAoKGkgKyAxKSBsYW5kIChBcnJheS5sZW5ndGggdGFibGUgLSAxKSlcbiAgZWxzZSBBdmx0cmVlLmNob29zZV9leG4gYXZsdHJlZVxuOztcblxubGV0IGNob29zZV9leG4gdCA9XG4gIGlmIHQubGVuZ3RoID0gMCB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltIYXNodGJsLmNob29zZV9leG5dIG9mIGVtcHR5IGhhc2h0YmxcIiBbXSk7XG4gIGNob29zZV9ub25lbXB0eSB0LnRhYmxlIDBcbjs7XG5cbmxldCBjaG9vc2UgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoY2hvb3NlX25vbmVtcHR5IHQudGFibGUgMClcblxubGV0IGNob29zZV9yYW5kb21seV9ub25lbXB0eSB+cmFuZG9tX3N0YXRlIHQgPVxuICBsZXQgc3RhcnRfaWR4ID0gUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKSBpblxuICBjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSBzdGFydF9pZHhcbjs7XG5cbmxldCBjaG9vc2VfcmFuZG9tbHkgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoY2hvb3NlX3JhbmRvbWx5X25vbmVtcHR5IH5yYW5kb21fc3RhdGUgdClcbjs7XG5cbmxldCBjaG9vc2VfcmFuZG9tbHlfZXhuID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSGFzaHRibC5jaG9vc2VfcmFuZG9tbHlfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pO1xuICBjaG9vc2VfcmFuZG9tbHlfbm9uZW1wdHkgfnJhbmRvbV9zdGF0ZSB0XG47O1xuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9rZXkgaW52YXJpYW50X2RhdGEgdCA9XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICBBdmx0cmVlLmludmFyaWFudCB0LnRhYmxlLihpKSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgZG9uZTtcbiAgbGV0IHJlYWxfbGVuID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgaSAtPlxuICAgICAgaW52YXJpYW50X2tleSBrZXk7XG4gICAgICBpbnZhcmlhbnRfZGF0YSBkYXRhO1xuICAgICAgaSArIDEpXG4gIGluXG4gIGFzc2VydCAocmVhbF9sZW4gPSB0Lmxlbmd0aClcbjs7XG5cbmxldCBmaW5kX2V4biA9XG4gIGxldCBpZl9mb3VuZCB2IF8gPSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgayB0ID1cbiAgICByYWlzZVxuICAgICAgKE5vdF9mb3VuZF9zIChMaXN0IFsgQXRvbSBcIkhhc2h0YmwuZmluZF9leG46IG5vdCBmb3VuZFwiOyB0Lmhhc2hhYmxlLnNleHBfb2ZfdCBrIF0pKVxuICBpblxuICBsZXQgZmluZF9leG4gdCBrZXkgPSBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YTp0IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSkgW0Bub250YWlsXVxuOztcblxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxubGV0IGZvcl9hbGxpIHQgfmYgPSBub3QgKGV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gbm90IChmIH5rZXkgfmRhdGEpKSlcbmxldCBmb3JfYWxsIHQgfmYgPSBub3QgKGV4aXN0c2kgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBub3QgKGYgZGF0YSkpKVxuXG5sZXQgY291bnRpIHQgfmYgPVxuICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpIFtAbm9udGFpbFxuICBdXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBpZiBmIGRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6KGYgfmtleSB+ZGF0YSkpO1xuICBuZXdfdFxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxubGV0IGNvcHkgdCA9IG1hcCB0IH5mOkZuLmlkXG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgU29tZSBuZXdfZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgTm9uZSAtPiAoKSk7XG4gIG5ld190XG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXJfa2V5cyB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KSBbQG5vbnRhaWxdXG5cbmxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgbGV0IHQwID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgbGV0IHQxID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBtYXRjaCAoZiB+a2V5IH5kYXRhIDogXyBFaXRoZXIudCkgd2l0aFxuICAgIHwgRmlyc3QgbmV3X2RhdGEgLT4gc2V0IHQwIH5rZXkgfmRhdGE6bmV3X2RhdGFcbiAgICB8IFNlY29uZCBuZXdfZGF0YSAtPiBzZXQgdDEgfmtleSB+ZGF0YTpuZXdfZGF0YSk7XG4gIHQwLCB0MVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpIFxuICBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5cblxubGV0IGZpbmRfb3JfYWRkIHQgaWQgfmRlZmF1bHQ6KGRlZmF1bHQgW0Bsb2NhbF0pID1cbiAgZmluZF9hbmRfY2FsbFxuICAgIHRcbiAgICBpZFxuICAgIH5pZl9mb3VuZDooZnVuIGRhdGEgLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQgKCkgaW5cbiAgICAgIHNldCB0IH5rZXkgfmRhdGE6ZGVmYXVsdDtcbiAgICAgIGRlZmF1bHQpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kaV9vcl9hZGQgdCBpZCB+ZGVmYXVsdCA9XG4gIGZpbmRfYW5kX2NhbGxcbiAgICB0XG4gICAgaWRcbiAgICB+aWZfZm91bmQ6KGZ1biBkYXRhIC0+IGRhdGEpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuIGtleSAtPlxuICAgICAgbGV0IGRlZmF1bHQgPSBkZWZhdWx0IGtleSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdCkgW0Bub250YWlsXVxuOztcblxuKCogU29tZSBoYXNodGJsIGltcGxlbWVudGF0aW9ucyBtYXkgYmUgYWJsZSB0byBwZXJmb3JtIHRoaXMgbW9yZSBlZmZpY2llbnRseSB0aGFuIHR3b1xuICAgc2VwYXJhdGUgbG9va3VwcyAqKVxubGV0IGZpbmRfYW5kX3JlbW92ZSB0IGlkID1cbiAgbGV0IHJlc3VsdCA9IGZpbmQgdCBpZCBpblxuICBpZiBPcHRpb24uaXNfc29tZSByZXN1bHQgdGhlbiByZW1vdmUgdCBpZDtcbiAgcmVzdWx0XG47O1xuXG5cbmxldCBjaGFuZ2UgdCBpZCB+ZiA9XG4gIG1hdGNoIGYgKGZpbmQgdCBpZCkgd2l0aFxuICB8IE5vbmUgLT4gcmVtb3ZlIHQgaWRcbiAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleTppZCB+ZGF0YVxuOztcblxubGV0IHVwZGF0ZV9hbmRfcmV0dXJuIHQgaWQgfmYgPVxuICBsZXQgZGF0YSA9IGYgKGZpbmQgdCBpZCkgaW5cbiAgc2V0IHQgfmtleTppZCB+ZGF0YTtcbiAgZGF0YVxuOztcblxubGV0IHVwZGF0ZSB0IGlkIH5mID0gaWdub3JlICh1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mIDogXylcblxubGV0IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5ID1cbiAgaWYgcmVtb3ZlX2lmX3plcm9cbiAgdGhlblxuICAgIGNoYW5nZSB0IGtleSB+ZjooZnVuIG9wdCAtPlxuICAgICAgbWF0Y2ggYnkgKyBPcHRpb24udmFsdWUgb3B0IH5kZWZhdWx0OjAgd2l0aFxuICAgICAgfCAwIC0+IE5vbmVcbiAgICAgIHwgbiAtPiBTb21lIG4pXG4gIGVsc2VcbiAgICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gYnlcbiAgICAgIHwgU29tZSBpIC0+IGJ5ICsgaSlcbjs7XG5cbmxldCBpbmNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgYnlcbmxldCBkZWNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgKC1ieSlcblxubGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IFsgZGF0YSBdXG4gICAgfCBTb21lIGwgLT4gZGF0YSA6OiBsKVxuOztcblxubGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIFtdIHwgU29tZSBbIF8gXSAtPiByZW1vdmUgdCBrZXlcbiAgfCBTb21lIChfIDo6IHRsKSAtPiBzZXQgdCB+a2V5IH5kYXRhOnRsXG47O1xuXG5sZXQgZmluZF9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGwgLT4gbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlIH5zaXplICgpIGluXG4gIGxldCBkdXBlcyA9IHJlZiBbXSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgaWYgbWVtIHJlcyBrZXkgdGhlbiBkdXBlcyA6PSBrZXkgOjogIWR1cGVzIGVsc2Ugc2V0IHJlcyB+a2V5IH5kYXRhKTtcbiAgbWF0Y2ggIWR1cGVzIHdpdGhcbiAgfCBbXSAtPiBgT2sgcmVzXG4gIHwga2V5cyAtPiBgRHVwbGljYXRlX2tleXMgKExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6aGFzaGFibGUuSGFzaGFibGUuY29tcGFyZSBrZXlzKVxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgfmhhc2hhYmxlICgpIGluXG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gciAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IHIgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHIgaW5cbiAgICBhZGRfbXVsdGkgcmVzIH5rZXkgfmRhdGEpO1xuICByZXNcbjs7XG5cbmxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Qgd2l0aFxuICB8IGBPayB0IC0+IGBPayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGsgLT4gYER1cGxpY2F0ZV9rZXkgKExpc3QuaGRfZXhuIGspXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgbWF0Y2ggb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3Qgd2l0aFxuICB8IGBPayB2IC0+IFJlc3VsdC5PayB2XG4gIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3IgXCJIYXNodGJsLm9mX2FsaXN0X2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBzZXhwX29mX2tleVxuOztcblxubGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBSZXN1bHQuT2sgdiAtPiB2XG4gIHwgUmVzdWx0LkVycm9yIGUgLT4gRXJyb3IucmFpc2UgZVxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IHRvX2FsaXN0IHQgPSBmb2xkIH5mOihmdW4gfmtleSB+ZGF0YSBsaXN0IC0+IChrZXksIGRhdGEpIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX2RhdGEgdCA9XG4gIHRcbiAgfD4gdG9fYWxpc3RcbiAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gKGsxLCBfKSAoazIsIF8pIC0+IHQuaGFzaGFibGUuY29tcGFyZSBrMSBrMilcbiAgfD4gc2V4cF9vZl9saXN0IChzZXhwX29mX3BhaXIgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhKVxuOztcblxubGV0IHRfb2Zfc2V4cCB+aGFzaGFibGUga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID1cbiAgbGV0IGFsaXN0ID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCkgc2V4cCBpblxuICBtYXRjaCBvZl9hbGlzdCB+aGFzaGFibGUgYWxpc3QgfnNpemU6KExpc3QubGVuZ3RoIGFsaXN0KSB3aXRoXG4gIHwgYE9rIHYgLT4gdlxuICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAoKiBmaW5kIHRoZSBzZXhwIG9mIGEgZHVwbGljYXRlIGtleSwgc28gdGhlIGVycm9yIGlzIG5hcnJvd2VkIHRvIGEga2V5IGFuZCBub3RcbiAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICBsZXQgZm91bmRfZmlyc3RfayA9IHJlZiBmYWxzZSBpblxuICAgIExpc3QuaXRlcjJfZXhuIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgIGlmIGhhc2hhYmxlLmNvbXBhcmUgayBrMiA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiSGFzaHRibC50X29mX3NleHA6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgIGVsc2UgZm91bmRfZmlyc3RfayA6PSB0cnVlKTtcbiAgICBhc3NlcnQgZmFsc2Vcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hclxuICAgICAgKHR5cGUgayB2KVxuICAgICAgKGtfZ3JhbW1hciA6IGsgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgICAodl9ncmFtbWFyIDogdiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiAoaywgdikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QuQXNzb2MudF9zZXhwX2dyYW1tYXIga19ncmFtbWFyIHZfZ3JhbW1hcilcbjs7XG5cbmxldCBrZXlzIHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhOl8gYWNjIC0+IGtleSA6OiBhY2MpXG5sZXQgZGF0YSB0ID0gZm9sZCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBsaXN0IC0+IGRhdGEgOjogbGlzdCkgfmluaXQ6W10gdFxuXG5sZXQgYWRkX3RvX2dyb3VwcyBncm91cHMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzID1cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByb3cgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByb3cgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHJvdyBpblxuICAgIGxldCBkYXRhID1cbiAgICAgIG1hdGNoIGZpbmQgZ3JvdXBzIGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgfCBTb21lIG9sZCAtPiBjb21iaW5lIG9sZCBkYXRhXG4gICAgaW5cbiAgICBzZXQgZ3JvdXBzIH5rZXkgfmRhdGEpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSByb3dzID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlICgpIGluXG4gIGFkZF90b19ncm91cHMgcmVzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cztcbiAgcmVzXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGE6Rm4uaWQgcm93c1xuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBtYXRjaCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzIHdpdGhcbiAgfCBgT2sgdCAtPiBSZXN1bHQuT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrZXlzIC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJIYXNodGJsLmNyZWF0ZV93aXRoX2tleTogZHVwbGljYXRlIGtleXNcIlxuICAgICAgICAgWyBcImtleXNcIiwgc2V4cF9vZl9saXN0IHNleHBfb2Zfa2V5IGtleXMgXSlcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIE9yX2Vycm9yLm9rX2V4biAoY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cylcbjs7XG5cbmxldCBtZXJnZSA9XG4gIGxldCBtYXliZV9zZXQgdCB+a2V5IH5mIGQgPVxuICAgIG1hdGNoIGYgfmtleSBkIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgdiAtPiBzZXQgdCB+a2V5IH5kYXRhOnZcbiAgaW5cbiAgZnVuIHRfbGVmdCB0X3JpZ2h0IH5mIC0+XG4gICAgaWYgbm90IChIYXNoYWJsZS5lcXVhbCB0X2xlZnQuaGFzaGFibGUgdF9yaWdodC5oYXNoYWJsZSlcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiSGFzaHRibC5tZXJnZTogZGlmZmVyZW50ICdoYXNoYWJsZScgdmFsdWVzXCI7XG4gICAgbGV0IG5ld190ID1cbiAgICAgIGNyZWF0ZVxuICAgICAgICB+Z3Jvd3RoX2FsbG93ZWQ6dF9sZWZ0Lmdyb3d0aF9hbGxvd2VkXG4gICAgICAgIH5oYXNoYWJsZTp0X2xlZnQuaGFzaGFibGVcbiAgICAgICAgfnNpemU6dF9sZWZ0Lmxlbmd0aFxuICAgICAgICAoKVxuICAgIGluXG4gICAgd2l0aG91dF9tdXRhdGluZyB0X2xlZnQgKGZ1biAoKSAtPlxuICAgICAgd2l0aG91dF9tdXRhdGluZyB0X3JpZ2h0IChmdW4gKCkgLT5cbiAgICAgICAgaXRlcmkgdF9sZWZ0IH5mOihmdW4gfmtleSB+ZGF0YTpsZWZ0IC0+XG4gICAgICAgICAgbWF0Y2ggZmluZCB0X3JpZ2h0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgTGVmdCBsZWZ0KVxuICAgICAgICAgIHwgU29tZSByaWdodCAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYEJvdGggKGxlZnQsIHJpZ2h0KSkpO1xuICAgICAgICBpdGVyaSB0X3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpyaWdodCAtPlxuICAgICAgICAgIG1hdGNoIGZpbmQgdF9sZWZ0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgUmlnaHQgcmlnaHQpXG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgICAoKiBhbHJlYWR5IGRvbmUgYWJvdmUgKikpIFtAbm9udGFpbF0pIFtAbm9udGFpbF0pO1xuICAgIG5ld190XG47O1xuXG5sZXQgbWVyZ2VfaW50byB+c3JjIH5kc3QgfmYgPVxuICBpdGVyaSBzcmMgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IGRzdF9kYXRhID0gZmluZCBkc3Qga2V5IGluXG4gICAgbGV0IGFjdGlvbiA9IHdpdGhvdXRfbXV0YXRpbmcgZHN0IChmdW4gKCkgLT4gZiB+a2V5IGRhdGEgZHN0X2RhdGEpIGluXG4gICAgbWF0Y2ggKGFjdGlvbiA6IF8gTWVyZ2VfaW50b19hY3Rpb24udCkgd2l0aFxuICAgIHwgUmVtb3ZlIC0+IHJlbW92ZSBkc3Qga2V5XG4gICAgfCBTZXRfdG8gZGF0YSAtPlxuICAgICAgKG1hdGNoIGRzdF9kYXRhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gc2V0IGRzdCB+a2V5IH5kYXRhXG4gICAgICAgfCBTb21lIGRzdF9kYXRhIC0+IGlmIG5vdCAocGh5c19lcXVhbCBkc3RfZGF0YSBkYXRhKSB0aGVuIHNldCBkc3QgfmtleSB+ZGF0YSkpIFtAbm9udGFpbFxuICBdXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdG9fcmVtb3ZlID1cbiAgICBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIGFjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjIGVsc2Uga2V5IDo6IGFjKVxuICBpblxuICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4ga2V5IC0+IHJlbW92ZSB0IGtleSlcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID0gZmlsdGVyaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5sZXQgZmlsdGVyX2tleXNfaW5wbGFjZSB0IH5mID0gZmlsdGVyaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cblxubGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCBtYXBfcmVzdWx0cyA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gKGtleSwgZiB+a2V5IH5kYXRhKSA6OiBhYykgaW5cbiAgTGlzdC5pdGVyIG1hcF9yZXN1bHRzIH5mOihmdW4gKGtleSwgcmVzdWx0KSAtPlxuICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgfCBOb25lIC0+IHJlbW92ZSB0IGtleVxuICAgIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXkgfmRhdGEpXG47O1xuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIHQgfmYgPVxuICBmaWx0ZXJfbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICB3aXRob3V0X211dGF0aW5nIHQgKGZ1biAoKSAtPlxuICAgIEFycmF5Lml0ZXIgdC50YWJsZSB+ZjooQXZsdHJlZS5tYXBpX2lucGxhY2UgfmYpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID0gbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5cbmxldCBlcXVhbCBlcXVhbCB0IHQnID1cbiAgbGVuZ3RoIHQgPSBsZW5ndGggdCdcbiAgJiYgKHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIHdpdGhvdXRfbXV0YXRpbmcgdCcgKGZ1biAoKSAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgbWF0Y2ggZmluZCB0JyBrZXkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gci5yZXR1cm4gZmFsc2VcbiAgICAgICAgfCBTb21lIGRhdGEnIC0+IGlmIG5vdCAoZXF1YWwgZGF0YSBkYXRhJykgdGhlbiByLnJldHVybiBmYWxzZSkgW0Bub250YWlsXSk7XG4gICAgdHJ1ZSkgW0Bub250YWlsXSlcbjs7XG5cbmxldCBzaW1pbGFyID0gZXF1YWxcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG4gIGxldCBjaG9vc2UgPSBjaG9vc2VcbiAgbGV0IGNob29zZV9leG4gPSBjaG9vc2VfZXhuXG4gIGxldCBjaG9vc2VfcmFuZG9tbHkgPSBjaG9vc2VfcmFuZG9tbHlcbiAgbGV0IGNob29zZV9yYW5kb21seV9leG4gPSBjaG9vc2VfcmFuZG9tbHlfZXhuXG4gIGxldCBjbGVhciA9IGNsZWFyXG4gIGxldCBjb3B5ID0gY29weVxuICBsZXQgcmVtb3ZlID0gcmVtb3ZlXG4gIGxldCBzZXQgPSBzZXRcbiAgbGV0IGFkZCA9IGFkZFxuICBsZXQgYWRkX2V4biA9IGFkZF9leG5cbiAgbGV0IGNoYW5nZSA9IGNoYW5nZVxuICBsZXQgdXBkYXRlID0gdXBkYXRlXG4gIGxldCB1cGRhdGVfYW5kX3JldHVybiA9IHVwZGF0ZV9hbmRfcmV0dXJuXG4gIGxldCBhZGRfbXVsdGkgPSBhZGRfbXVsdGlcbiAgbGV0IHJlbW92ZV9tdWx0aSA9IHJlbW92ZV9tdWx0aVxuICBsZXQgZmluZF9tdWx0aSA9IGZpbmRfbXVsdGlcbiAgbGV0IG1lbSA9IG1lbVxuICBsZXQgaXRlcl9rZXlzID0gaXRlcl9rZXlzXG4gIGxldCBpdGVyID0gaXRlclxuICBsZXQgaXRlcmkgPSBpdGVyaVxuICBsZXQgZXhpc3RzID0gZXhpc3RzXG4gIGxldCBleGlzdHNpID0gZXhpc3RzaVxuICBsZXQgZm9yX2FsbCA9IGZvcl9hbGxcbiAgbGV0IGZvcl9hbGxpID0gZm9yX2FsbGlcbiAgbGV0IGNvdW50ID0gY291bnRcbiAgbGV0IGNvdW50aSA9IGNvdW50aVxuICBsZXQgZm9sZCA9IGZvbGRcbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgaXNfZW1wdHkgPSBpc19lbXB0eVxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXBpID0gbWFwaVxuICBsZXQgZmlsdGVyX21hcCA9IGZpbHRlcl9tYXBcbiAgbGV0IGZpbHRlcl9tYXBpID0gZmlsdGVyX21hcGlcbiAgbGV0IGZpbHRlcl9rZXlzID0gZmlsdGVyX2tleXNcbiAgbGV0IGZpbHRlciA9IGZpbHRlclxuICBsZXQgZmlsdGVyaSA9IGZpbHRlcmlcbiAgbGV0IHBhcnRpdGlvbl9tYXAgPSBwYXJ0aXRpb25fbWFwXG4gIGxldCBwYXJ0aXRpb25fbWFwaSA9IHBhcnRpdGlvbl9tYXBpXG4gIGxldCBwYXJ0aXRpb25fdGYgPSBwYXJ0aXRpb25fdGZcbiAgbGV0IHBhcnRpdGlvbmlfdGYgPSBwYXJ0aXRpb25pX3RmXG4gIGxldCBmaW5kX29yX2FkZCA9IGZpbmRfb3JfYWRkXG4gIGxldCBmaW5kaV9vcl9hZGQgPSBmaW5kaV9vcl9hZGRcbiAgbGV0IGZpbmQgPSBmaW5kXG4gIGxldCBmaW5kX2V4biA9IGZpbmRfZXhuXG4gIGxldCBmaW5kX2FuZF9jYWxsID0gZmluZF9hbmRfY2FsbFxuICBsZXQgZmluZF9hbmRfY2FsbDEgPSBmaW5kX2FuZF9jYWxsMVxuICBsZXQgZmluZF9hbmRfY2FsbDIgPSBmaW5kX2FuZF9jYWxsMlxuICBsZXQgZmluZGlfYW5kX2NhbGwgPSBmaW5kaV9hbmRfY2FsbFxuICBsZXQgZmluZGlfYW5kX2NhbGwxID0gZmluZGlfYW5kX2NhbGwxXG4gIGxldCBmaW5kaV9hbmRfY2FsbDIgPSBmaW5kaV9hbmRfY2FsbDJcbiAgbGV0IGZpbmRfYW5kX3JlbW92ZSA9IGZpbmRfYW5kX3JlbW92ZVxuICBsZXQgdG9fYWxpc3QgPSB0b19hbGlzdFxuICBsZXQgbWVyZ2UgPSBtZXJnZVxuICBsZXQgbWVyZ2VfaW50byA9IG1lcmdlX2ludG9cbiAgbGV0IGtleXMgPSBrZXlzXG4gIGxldCBkYXRhID0gZGF0YVxuICBsZXQgZmlsdGVyX2tleXNfaW5wbGFjZSA9IGZpbHRlcl9rZXlzX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9pbnBsYWNlID0gZmlsdGVyX2lucGxhY2VcbiAgbGV0IGZpbHRlcmlfaW5wbGFjZSA9IGZpbHRlcmlfaW5wbGFjZVxuICBsZXQgbWFwX2lucGxhY2UgPSBtYXBfaW5wbGFjZVxuICBsZXQgbWFwaV9pbnBsYWNlID0gbWFwaV9pbnBsYWNlXG4gIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgPSBmaWx0ZXJfbWFwaV9pbnBsYWNlXG4gIGxldCBlcXVhbCA9IGVxdWFsXG4gIGxldCBzaW1pbGFyID0gc2ltaWxhclxuICBsZXQgaW5jciA9IGluY3JcbiAgbGV0IGRlY3IgPSBkZWNyXG4gIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5XG5lbmRcblxubW9kdWxlIENyZWF0b3JzIChLZXkgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICBlbmQpIDogc2lnXG4gIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgS2V5LnQpIC0+IChTZXhwLnQgLT4gJ2IpIC0+IFNleHAudCAtPiAoJ2EsICdiKSB0X1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdF9cbiAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuZW5kID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEtleS5oYXNoYWJsZVxuXG4gIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgbGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKCkgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSAoKVxuICBsZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPSBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcblxuICBsZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBrX29mX3NleHAgZF9vZl9zZXhwIHNleHAgPSB0X29mX3NleHAgfmhhc2hhYmxlIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cFxuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgICBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGwgPVxuICAgIGdyb3VwID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGxcbiAgOztcbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuICB0eXBlICdhIGtleSA9ICdhXG5cbiAgbGV0IGhhc2hhYmxlID0gSGFzaGFibGUucG9seVxuXG4gIGluY2x1ZGUgQ3JlYXRvcnMgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgICAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gIGxldCB0X3NleHBfZ3JhbW1hciA9IHRfc2V4cF9ncmFtbWFyXG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgSGFzaGFibGUgPSBIYXNoYWJsZS5IYXNoYWJsZVxuXG4gIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlID1cbiAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gIGxldCBoYXNoYWJsZSB0ID0gdC5oYXNoYWJsZVxuZW5kXG5cbmxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gPVxuICBjcmVhdGUgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpXG47O1xuXG5sZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0IH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3Rfb3JfZXJyb3Igfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9tdWx0aSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgfmdldF9kYXRhIGwgPVxuICBjcmVhdGVfbWFwcGVkIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5IH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3Igfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXlfZXhuIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGwgPVxuICBncm91cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGxcbjs7XG5cbmxldCBoYXNoYWJsZV9zIHQgPSBIYXNoYWJsZS50b19rZXkgdC5oYXNoYWJsZVxuXG5tb2R1bGUgTSAoSyA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2KSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIEtleS5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGspIChtb2R1bGUgSyA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGspIHZfb2Zfc2V4cCBzZXhwID1cbiAgdF9vZl9zZXhwIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IChtb2R1bGUgSykpIEsudF9vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXIgKHR5cGUgaykgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKSB2X2dyYW1tYXIgPVxuICB0X3NleHBfZ3JhbW1hciBLLnRfc2V4cF9ncmFtbWFyIHZfZ3JhbW1hclxuOztcblxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgZXF1YWxfdiB0MSB0MiA9IGVxdWFsIGVxdWFsX3YgdDEgdDJcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozNjc2NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0hhc2hfc2V0X2ludGYiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLHFCQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzY3NzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJCYXNlX0xpc3QiLCJCYXNlX0hhc2hhYmxlIiwiQmFzZV9IYXNodGJsIiwiQmFzZV9BcnJheSIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9Pcl9lcnJvciIsIkJhc2VfV2l0aF9yZXR1cm4iLCJoYXNoYWJsZV9zIiwiaGFzaGFibGUiLCJwb2x5X2hhc2hhYmxlIiwid2l0aF9yZXR1cm4iLCJjbGVhciIsImxlbmd0aCIsIm1lbSIsImNzdF9lbGVtZW50X2FscmVhZHlfZXhpc3RzIiwiaXNfZW1wdHkiLCJ0IiwiZmluZF9tYXAiLCJyIiwiZWx0IiwibyIsImZpbmQiLCJhIiwiYWRkIiwiayIsInN0cmljdF9hZGQiLCJzdHJpY3RfYWRkX2V4biIsInJlbW92ZSIsImNzdF9lbGVtZW50X25vdF9pbl9zZXQiLCJzdHJpY3RfcmVtb3ZlIiwic3RyaWN0X3JlbW92ZV9leG4iLCJmb2xkIiwiaW5pdCIsImtleSIsInBhcmFtIiwiYWNjIiwiaXRlciIsImNvdW50Iiwic3VtIiwibSIsIm1pbl9lbHQiLCJjb21wYXJlIiwibWF4X2VsdCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsImZpbmlzaCIsInRvX2xpc3QiLCJjc3RfSGFzaF9zZXRfdF9vZl9zZXhwX3JlcXVpcmUiLCJjc3RfSGFzaF9zZXRfdF9vZl9zZXhwX2dvdF9hX2QiLCJzZXhwX29mX3QiLCJzZXhwX29mX2UiLCJ0b19hcnJheSIsImxlbiIsImluZGV4IiwiZXhpc3RzIiwiZm9yX2FsbCIsImVxdWFsIiwidDEiLCJ0MiIsImNvcHkiLCJmaWx0ZXIiLCJ1bmlvbiIsImRpZmYiLCJpbnRlciIsImxhcmdlciIsInNtYWxsZXIiLCJmaWx0ZXJfaW5wbGFjZSIsInRvX3JlbW92ZSIsImFjIiwieCIsIm9mX2hhc2h0Ymxfa2V5cyIsImhhc2h0YmwiLCJ0b19oYXNodGJsIiwiY3JlYXRlIiwiZ3Jvd3RoX2FsbG93ZWQiLCJzaXplIiwib2ZfbGlzdCIsImwiLCJ0X29mX3NleHAiLCJlX29mX3NleHAiLCJzZXhwIiwibGlzdCIsImUiLCJDcmVhdG9ycyIsIkVsdCIsInRfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsIk0iLCJzZXhwX29mX21fdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsImVxdWFsX21fdCIsIlByaXZhdGUiLCJCYXNlX0hhc2hfc2V0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2Jhc2UvaGFzaF9zZXQubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFB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aF9zZXRfaW50ZlxuXG5sZXQgaGFzaGFibGVfcyA9IEhhc2h0YmwuaGFzaGFibGVfc1xubGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5sZXQgcG9seV9oYXNoYWJsZSA9IEhhc2h0YmwuUG9seS5oYXNoYWJsZVxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAnYSB0ID0gKCdhLCB1bml0KSBIYXNodGJsLnRcbnR5cGUgJ2EgaGFzaF9zZXQgPSAnYSB0XG50eXBlICdhIGVsdCA9ICdhXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgbGV0IGNsZWFyID0gSGFzaHRibC5jbGVhclxuICBsZXQgbGVuZ3RoID0gSGFzaHRibC5sZW5ndGhcbiAgbGV0IG1lbSA9IEhhc2h0YmwubWVtXG4gIGxldCBpc19lbXB0eSB0ID0gSGFzaHRibC5pc19lbXB0eSB0XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgSGFzaHRibC5pdGVyX2tleXMgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgXyBhcyBvIC0+IHIucmV0dXJuIG8pO1xuICAgICAgTm9uZSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmYgPSBmaW5kX21hcCB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBTb21lIGEgZWxzZSBOb25lKSBbQG5vbnRhaWxdXG4gIGxldCBhZGQgdCBrID0gSGFzaHRibC5zZXQgdCB+a2V5OmsgfmRhdGE6KClcblxuICBsZXQgc3RyaWN0X2FkZCB0IGsgPVxuICAgIGlmIG1lbSB0IGtcbiAgICB0aGVuIE9yX2Vycm9yLmVycm9yX3N0cmluZyBcImVsZW1lbnQgYWxyZWFkeSBleGlzdHNcIlxuICAgIGVsc2UgKFxuICAgICAgSGFzaHRibC5zZXQgdCB+a2V5OmsgfmRhdGE6KCk7XG4gICAgICBSZXN1bHQuT2sgKCkpXG4gIDs7XG5cbiAgbGV0IHN0cmljdF9hZGRfZXhuIHQgayA9IE9yX2Vycm9yLm9rX2V4biAoc3RyaWN0X2FkZCB0IGspXG4gIGxldCByZW1vdmUgPSBIYXNodGJsLnJlbW92ZVxuXG4gIGxldCBzdHJpY3RfcmVtb3ZlIHQgayA9XG4gICAgaWYgbWVtIHQga1xuICAgIHRoZW4gKFxuICAgICAgcmVtb3ZlIHQgaztcbiAgICAgIFJlc3VsdC5PayAoKSlcbiAgICBlbHNlIE9yX2Vycm9yLmVycm9yIFwiZWxlbWVudCBub3QgaW4gc2V0XCIgayAoSGFzaHRibC5zZXhwX29mX2tleSB0KVxuICA7O1xuXG4gIGxldCBzdHJpY3RfcmVtb3ZlX2V4biB0IGsgPSBPcl9lcnJvci5va19leG4gKHN0cmljdF9yZW1vdmUgdCBrKVxuXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPVxuICAgIEhhc2h0YmwuZm9sZCB0IH5pbml0IH5mOihmdW4gfmtleSB+ZGF0YTooKSBhY2MgLT4gZiBhY2Mga2V5KSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9IEhhc2h0YmwuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdCB+ZmluaXNoXG4gIGxldCB0b19saXN0ID0gSGFzaHRibC5rZXlzXG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2UgdCA9XG4gICAgc2V4cF9vZl9saXN0IHNleHBfb2ZfZSAodG9fbGlzdCB0IHw+IExpc3Quc29ydCB+Y29tcGFyZTooaGFzaGFibGUgdCkuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgbGV0IGluZGV4ID0gcmVmIChsZW4gLSAxKSBpblxuICAgIGZvbGQgdCB+aW5pdDpbfHxdIH5mOihmdW4gYWNjIGtleSAtPlxuICAgICAgaWYgQXJyYXkubGVuZ3RoIGFjYyA9IDBcbiAgICAgIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4ga2V5XG4gICAgICBlbHNlIChcbiAgICAgICAgaW5kZXggOj0gIWluZGV4IC0gMTtcbiAgICAgICAgYWNjLighaW5kZXgpIDwtIGtleTtcbiAgICAgICAgYWNjKSlcbiAgOztcblxuICBsZXQgZXhpc3RzIHQgfmY6KGYgW0Bsb2NhbF0pID1cbiAgICBIYXNodGJsLmV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZm9yX2FsbCB0IH5mID0gbm90IChIYXNodGJsLmV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gbm90IChmIGtleSkpKVxuICBsZXQgZXF1YWwgdDEgdDIgPSBIYXNodGJsLmVxdWFsIChmdW4gKCkgKCkgLT4gdHJ1ZSkgdDEgdDJcbiAgbGV0IGNvcHkgdCA9IEhhc2h0YmwuY29weSB0XG4gIGxldCBmaWx0ZXIgdCB+ZiA9IEhhc2h0YmwuZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSkgW0Bub250YWlsXVxuICBsZXQgdW5pb24gdDEgdDIgPSBIYXNodGJsLm1lcmdlIHQxIHQyIH5mOihmdW4gfmtleTpfIF8gLT4gU29tZSAoKSlcbiAgbGV0IGRpZmYgdDEgdDIgPSBmaWx0ZXIgdDEgfmY6KGZ1biBrZXkgLT4gbm90IChIYXNodGJsLm1lbSB0MiBrZXkpKVxuXG4gIGxldCBpbnRlciB0MSB0MiA9XG4gICAgbGV0IHNtYWxsZXIsIGxhcmdlciA9IGlmIGxlbmd0aCB0MSA+IGxlbmd0aCB0MiB0aGVuIHQyLCB0MSBlbHNlIHQxLCB0MiBpblxuICAgIEhhc2h0YmwuZmlsdGVyaSBzbWFsbGVyIH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBIYXNodGJsLm1lbSBsYXJnZXIga2V5KVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID1cbiAgICBsZXQgdG9fcmVtb3ZlID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYWMgeCAtPiBpZiBmIHggdGhlbiBhYyBlbHNlIHggOjogYWMpIGluXG4gICAgTGlzdC5pdGVyIHRvX3JlbW92ZSB+ZjooZnVuIHggLT4gcmVtb3ZlIHQgeClcbiAgOztcblxuICBsZXQgb2ZfaGFzaHRibF9rZXlzIGhhc2h0YmwgPSBIYXNodGJsLm1hcCBoYXNodGJsIH5mOmlnbm9yZVxuICBsZXQgdG9faGFzaHRibCB0IH5mID0gSGFzaHRibC5tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KSBbQG5vbnRhaWxdXG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtXG5cbmxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCBsXG4gIGluXG4gIGxldCB0ID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIG0gaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biBrIC0+IGFkZCB0IGspO1xuICB0XG47O1xuXG5sZXQgdF9vZl9zZXhwIG0gZV9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBTZXhwLkF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIHJlcXVpcmVzIGEgbGlzdFwiIHNleHBcbiAgfCBTZXhwLkxpc3QgbGlzdCAtPlxuICAgIGxldCB0ID0gY3JlYXRlIG0gfnNpemU6KExpc3QubGVuZ3RoIGxpc3QpIGluXG4gICAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biBzZXhwIC0+XG4gICAgICBsZXQgZSA9IGVfb2Zfc2V4cCBzZXhwIGluXG4gICAgICBtYXRjaCBzdHJpY3RfYWRkIHQgZSB3aXRoXG4gICAgICB8IE9rICgpIC0+ICgpXG4gICAgICB8IEVycm9yIF8gLT4gb2Zfc2V4cF9lcnJvciBcIkhhc2hfc2V0LnRfb2Zfc2V4cCBnb3QgYSBkdXBsaWNhdGUgZWxlbWVudFwiIHNleHApO1xuICAgIHRcbjs7XG5cbm1vZHVsZSBDcmVhdG9ycyAoRWx0IDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgZW5kKSA6IHNpZ1xuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBFbHQudCkgLT4gU2V4cC50IC0+ICdhIEVsdC50IHRcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIEVsdC50IHRcbiAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgd2l0aCB0eXBlICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKSA9XG4gICAgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGxcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGVfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKSBlX29mX3NleHAgc2V4cFxuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGhhc2hfc2V0XG4gIHR5cGUgJ2EgZWx0ID0gJ2FcblxuICBsZXQgaGFzaGFibGUgPSBwb2x5X2hhc2hhYmxlXG5cbiAgaW5jbHVkZSBDcmVhdG9ycyAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICAgIGVuZClcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgbGV0IHRfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG5lbmRcblxubW9kdWxlIE0gKEVsdCA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IEVsdC50IHRcbmVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQpIHNleHAgPVxuICB0X29mX3NleHAgKG1vZHVsZSBFbHQpIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdCkgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChsaXN0X3NleHBfZ3JhbW1hciBFbHQudF9zZXhwX2dyYW1tYXIpXG47O1xuXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEhhc2h0YmwuUHJpdmF0ZS5oYXNoYWJsZVxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzcxMzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X291dF9vZl9yYW5nZV8wIiwiY3N0X3NfMWUiLCJjc3RfaXNfdG9vX2xhcmdlIiwiY3N0X2lzX3Rvb19zbWFsbF9vcl9OYU4iLCJjc3RfRmxvYXRfaW50NjNfcm91bmRfZG93bl9leG4iLCJjc3RfRmxvYXRfaW50NjNfcm91bmRfbmVhcmVzdF8iLCJjc3RfRmxvYXRfaW50NjNfcm91bmRfdXBfZXhuX2EiLCJjc3RfRmxvYXRfaXJvdW5kX2Rvd25fZXhuX2FyZ3UiLCJjc3RfRmxvYXRfaXJvdW5kX25lYXJlc3RfZXhuX2EiLCJjc3RfRmxvYXRfaXJvdW5kX3VwX2V4bl9hcmd1bWUiLCJjc3RfSW5maW5pdGUiLCJjc3RfTmFuIiwiY3N0X05vcm1hbCIsImNzdF9TdWJub3JtYWwiLCJjc3RfWmVybyIsImNzdF9pbmZpbml0ZSIsImNzdF9uYW4iLCJjc3Rfbm9ybWFsIiwiY3N0X3NyY19mbG9hdF9tbCIsImNzdF9zdWJub3JtYWwiLCJjc3RfemVybyIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9sb2cxMF9mbG9hdCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJhbGwiLCJlcnJvcl9zb3VyY2VfMDA3IiwidF9zZXhwX2dyYW1tYXIiLCJtb2R1bGVfbmFtZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9QcmludGYiLCJCYXNlX09yX2Vycm9yIiwiQmFzZV9JbnQiLCJCYXNlX0ludDYzIiwiU3RkbGliX0ludDY0IiwiQmFzZV9JbnQ2NCIsIkJhc2VfU2V4cCIsIkJhc2VfRXJyb3IiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfU3RyaW5nIiwiQmFzZV9CeXRlczAiLCJCYXNlX0NoYXIiLCJCYXNlX0ludF9jb252ZXJzaW9ucyIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsIkJhc2VfRmxvYXQwIiwiQmFzZV9Db21wYXJhdG9yIiwiQmFzZV9Xb3JkX3NpemUiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwicm91bmRfdXAiLCJyb3VuZF9kb3duIiwibW9kX2Zsb2F0IiwibW9kZiIsImZsb2F0X29mX3N0cmluZyIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJuYW4iLCJtYXhfdmFsdWUiLCJuZWdfaW5maW5pdHkiLCJtYXhfZmluaXRlX3ZhbHVlIiwiZXBzaWxvbl9mbG9hdCIsImNsYXNzaWZ5X2Zsb2F0IiwiYWJzX2Zsb2F0IiwiaXNfaW50ZWdlciIsInN5bWJvbCIsImZyZXhwIiwibGRleHAiLCJpc19uYW4iLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biIsIm9mX2ludDY0X3ByZXNlcnZlX29yZGVyIiwib25lX3VscCIsInVwcGVyX2JvdW5kX2Zvcl9pbnQiLCJsb3dlcl9ib3VuZF9mb3JfaW50IiwiY2xhbXBfdW5jaGVja2VkIiwiYm94IiwiY29tcGFyZSIsInJhaXNlX3MiLCJoYXNoX2ZvbGRfdCIsImZ1bmMiLCJoYXNoIiwieCIsImdsb2JhbGl6ZSIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsImhhc2hhYmxlIiwiaW5jbHVkZSIsImNvbXBhcmF0b3IiLCJpbnZhcmlhbnQiLCJwYXJhbSIsInRvX2Zsb2F0Iiwib2ZfZmxvYXQiLCJvZl9zdHJpbmciLCJzIiwidG9fc3RyaW5nIiwieSIsImwiLCJpIiwibWF0Y2giLCJtaW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlIiwibWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZSIsInplcm8iLCJvZl9pbnQiLCJ0b19pbnQiLCJvZl9pbnQ2MyIsIm9mX2ludDY0IiwidG9faW50NjQiLCJpcm91bmRfbGJvdW5kIiwiaXJvdW5kX3Vib3VuZCIsImlyb3VuZF91cCIsInQiLCJpcm91bmRfdXBfZXhuIiwiaXJvdW5kX2Rvd24iLCJpcm91bmRfZG93bl9leG4iLCJpcm91bmRfdG93YXJkc196ZXJvIiwiaXJvdW5kX3Rvd2FyZHNfemVyb19leG4iLCJyb3VuZF9uZWFyZXN0X2xiIiwicm91bmRfbmVhcmVzdF91YiIsIm9uZV91bHBfbGVzc190aGFuX2hhbGYiLCJhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCIsImlyb3VuZF9uZWFyZXN0XzMyIiwiaXJvdW5kX25lYXJlc3RfNjQiLCJjc3RfRmxvYXRfc2lnbl9leG5fb2ZfTkFOIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsImNzdF90IiwiY3N0X2ciLCJjc3RfbSIsImNzdF9rIiwiY3N0XzAiLCJjc3RfaW5mIiwiY3N0X3NleHAiLCJjc3Rfc2V4cF9vZl9mbG9hdF9wcm9kdWNlZF9zdHIiLCJvbmUiLCJtaW51c19vbmUiLCJwaSIsInNxcnRfcGkiLCJzcXJ0XzJwaSIsImV1bGVyIiwiaXJvdW5kX25lYXJlc3RfZXhuXzMyIiwiaXJvdW5kX25lYXJlc3RfZXhuXzY0IiwiaXJvdW5kX25lYXJlc3RfZXhuIiwiaXJvdW5kX2V4biIsIm9wdCIsImRpciIsImlyb3VuZCIsImlzX2luZiIsImlzX2Zpbml0ZSIsIm1pbl9pbmFuIiwibWF4X2luYW4iLCJhZGQiLCJzdWIiLCJuZWciLCJzY2FsZSIsInNxdWFyZSIsImZyYWN0aW9uYWwiLCJpbnRlZ3JhbCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX25lYXJlc3RfaW5saW5lIiwicm91bmRfbmVhcmVzdCIsInJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuIiwiZmxvb3IiLCJjZWlsX29yX3N1Y2MiLCJkaWZmX2Zsb29yIiwiZGlmZl9jZWlsIiwiaW50NjNfcm91bmRfbGJvdW5kIiwiaW50NjNfcm91bmRfdWJvdW5kIiwiaW50NjNfcm91bmRfdXBfZXhuIiwiaW50NjNfcm91bmRfZG93bl9leG4iLCJpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2EiLCJ0MCIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwicm91bmQiLCJzZXhwXzAwOCIsImNsYXNzaWZ5IiwiaW5zZXJ0X3VuZGVyc2NvcmVzIiwic3RyaW5nIiwiZGVsaW1pdGVyIiwic3RyaXBfemVybyIsInJpZ2h0IiwibGVmdCIsImMiLCJ0b19zdHJpbmdfaHVtIiwiZGVjaW1hbHMiLCJleHBsaWNpdF9wbHVzIiwic2V4cCIsInRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0byIsImtpbG8iLCJtZWdhIiwiZ2lnYSIsInRlcmEiLCJwZXRhIiwicHJlZml4IiwiZ28iLCJjb252IiwibWFnIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJrIiwibG93ZXIiLCJoaWdoZXIiLCJkaWZmX3JpZ2h0IiwiZGlmZl9sZWZ0IiwiZCIsIm4iLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmciLCJpbnRfcG93IiwiYWNjdW0iLCJyb3VuZF9nZW4iLCJob3ciLCJzZCIsImRkIiwiYWJzX2RkIiwib3JkZXIiLCJyb3VuZF9zaWduaWZpY2FudCIsInNpZ25pZmljYW50X2RpZ2l0cyIsInJvdW5kX2RlY2ltYWwiLCJkZWNpbWFsX2RpZ2l0cyIsImJldHdlZW4iLCJsb3ciLCJoaWdoIiwiY2xhbXBfZXhuIiwibWluIiwibWF4IiwiY2xhbXAiLCJzaWduX2V4biIsInNpZ25fb3JfbmFuIiwiaWVlZV9uZWdhdGl2ZSIsImJpdHMiLCJtYW50aXNzYV9iaXRzIiwiZXhwb25lbnRfbWFzazY0IiwiZXhwb25lbnRfbWFzayIsIm1hbnRpc3NhX21hc2siLCJtYW50aXNzYV9tYXNrNjQiLCJpZWVlX2V4cG9uZW50IiwiaWVlZV9tYW50aXNzYSIsImNyZWF0ZV9pZWVlX2V4biIsIm5lZ2F0aXZlIiwiZXhwb25lbnQiLCJtYW50aXNzYSIsInNpZ25fYml0cyIsImV4cHRfYml0cyIsIm1hbnRfYml0cyIsImNyZWF0ZV9pZWVlIiwic2lnbiIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJwcCIsInNwZWNpYWxpemVkX2hhc2giLCJQcml2YXRlIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImVxdWFsIiwiQmFzZV9GbG9hdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9iYXNlL2Zsb2F0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUosUUFBQTtBQUFBLElBQUFLLGlDQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQ3NEJsRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5vcGVuISBQcmludGZcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxuaW5jbHVkZSBGbG9hdDBcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2Zsb2F0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9mbG9hdCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCAoZ2xvYmFsaXplIDogKHRbQG9jYW1sLmxvY2FsXSkgLT4gdCkgPSAoZ2xvYmFsaXplX2Zsb2F0IDogKHRbQG9jYW1sLmxvY2FsXSkgLT4gdClcbiAgbGV0IHRfb2Zfc2V4cCA9IChmbG9hdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9mbG9hdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBmbG9hdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgdG9fZmxvYXQgeCA9IHhcbmxldCBvZl9mbG9hdCB4ID0geFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICB0cnkgZmxvYXRfb2Zfc3RyaW5nIHMgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwiRmxvYXQub2Zfc3RyaW5nICVzXCIgcyAoKVxuOztcblxubGV0IG9mX3N0cmluZ19vcHQgPSBmbG9hdF9vZl9zdHJpbmdfb3B0XG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxuKCogU3RvbGVuIGZyb20gW3BlcnZhc2l2ZXMubWxdLiAgQWRkcyBhIFwiLlwiIGF0IHRoZSBlbmQgaWYgbmVlZGVkLiAgSXQgaXMgaW5cbiAgIFtwZXJ2YXNpdmVzLm1saV0sIGJ1dCBpdCBhbHNvIHNheXMgbm90IHRvIHVzZSBpdCBkaXJlY3RseSwgc28gd2UgY29weSBhbmQgcGFzdGUgdGhlXG4gICBjb2RlLiBJdCBtYWtlcyB0aGUgYXNzdW1wdGlvbiBvbiB0aGUgc3RyaW5nIHBhc3NlZCBpbiBhcmd1bWVudCB0aGF0IGl0IHdhcyByZXR1cm5lZCBieVxuICAgW2Zvcm1hdF9mbG9hdF0uICopXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBpIGxcbiAgICB0aGVuIHMgXiBcIi5cIlxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBfIC0+IHMpXG4gIGluXG4gIGxvb3AgMFxuOztcblxuKCogTGV0IFt5XSBiZSBhIHBvd2VyIG9mIDIuICBUaGVuIHRoZSBuZXh0IHJlcHJlc2VudGFibGUgZmxvYXQgaXM6XG4gICBbeiA9IHkgKiAoMSArIDIgKiogLTUyKV1cbiAgIGFuZCB0aGUgcHJldmlvdXMgb25lIGlzXG4gICBbeCA9IHkgKiAoMSAtIDIgKiogLTUzKV1cblxuICAgSW4gZ2VuZXJhbCwgZXZlcnkgdHdvIGFkamFjZW50IGZsb2F0cyBhcmUgd2l0aGluIGEgZmFjdG9yIG9mIGJldHdlZW4gWzEgKyAyKiotNTNdXG4gICBhbmQgWzEgKyAyKiotNTJdIGZyb20gZWFjaCBvdGhlciwgdGhhdCBpcyB3aXRoaW4gWzEgKyAxLjFlLTE2XSBhbmQgWzEgKyAyLjNlLTE2XS5cblxuICAgU28gaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBmbG9hdCBzdGFydHMgd2l0aCBcIjFcIiwgdGhlbiBpdHMgYWRqYWNlbnQgZmxvYXRzXG4gICB3aWxsIHVzdWFsbHkgZGlmZmVyIGZyb20gaXQgYnkgMSwgYW5kIHNvbWV0aW1lcyBieSAyLCBhdCB0aGUgMTd0aCBzaWduaWZpY2FudCBkaWdpdFxuICAgKGNvdW50aW5nIGZyb20gMSkuXG5cbiAgIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBzdGFydHMgd2l0aCBcIjlcIiwgdGhlbiB0aGUgYWRqYWNlbnRcbiAgIGZsb2F0cyB3aWxsIGJlIG9mZiBieSBubyBtb3JlIHRoYW4gMjMgYXQgdGhlIDE2dGggYW5kIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRzLlxuXG4gICBFLmcuOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjMuOTk5OTk5OTk5OTk5OVwiXG4gICB2fVxuICAgUHJpbnRpbmcgYSBjb3VwbGUgb2YgZXh0cmEgZGlnaXRzIHJldmVhbHMgdGhhdCB0aGUgZGlmZmVyZW5jZSBpbmRlZWQgaXMgcm91Z2hseSAxMSBhdFxuICAgZGlnaXRzIDE3dGggYW5kIDE4dGggKHRoYXQgaXMsIDEzdGggYW5kIDE0dGggYWZ0ZXIgXCIuXCIpOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE5Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1Njc4OVxuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTg4NlwiXG4gICB2fVxuXG4gICBUaGUgdWxwICh0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGFkamFjZW50IGZsb2F0cykgaXMgdHdpY2UgYXMgYmlnIG9uIHRoZSBvdGhlciBzaWRlIG9mXG4gICAxMDI0LjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuICsuIDIuKiogKC01Mi4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyNC4wMDAwMDAwMDAwMDAyMjdcIlxuICAgdn1cblxuICAgTm93IHRha2UgYSBwb3dlciBvZiAyIHdoaWNoIHN0YXJ0cyB3aXRoIDk5OlxuXG4gICB7dlxuICAgICAjIDIuKio5My4gOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAxIDIzNDU2Nzg5MDEyMzQ1Njc4XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQyMmUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuICsuIDIuKiogKC01Mi4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQ0NGUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuIC0uIDIuKiogKC01My4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQxMWUrMjdcbiAgIHZ9XG5cbiAgIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMioqOTMgYW5kIGl0cyB0d28gbmVpZ2hib3JzIGlzIHNsaWdodGx5IG1vcmUgdGhhbiwgcmVzcGVjdGl2ZWx5LFxuICAgMSBhbmQgMiBhdCBzaWduaWZpY2FudCBkaWdpdCAxNi5cblxuICAgVGhvc2UgZXhhbXBsZXMgc2hvdyB0aGF0OlxuICAgLSAxNyBzaWduaWZpY2FudCBkaWdpdHMgaXMgYWx3YXlzIHN1ZmZpY2llbnQgdG8gcmVwcmVzZW50IGEgZmxvYXQgd2l0aG91dCBhbWJpZ3VpdHlcbiAgIC0gMTV0aCBzaWduaWZpY2FudCBkaWdpdCBjYW4gYWx3YXlzIGJlIHJlcHJlc2VudGVkIGFjY3VyYXRlbHlcbiAgIC0gY29udmVydGluZyBhIGRlY2ltYWwgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIGl0cyBuZWFyZXN0IGZsb2F0IGFuZCBiYWNrXG4gICAgIGNhbiBjaGFuZ2UgdGhlIGxhc3QgZGVjaW1hbCBkaWdpdCBieSBubyBtb3JlIHRoYW4gMVxuXG4gICBUbyBtYWtlIHN1cmUgdGhhdCBmbG9hdHMgb2J0YWluZWQgYnkgY29udmVyc2lvbiBmcm9tIGRlY2ltYWwgZnJhY3Rpb25zIChlLmcuIFwiMy4xNFwiKVxuICAgYXJlIHByaW50ZWQgd2l0aG91dCB0cmFpbGluZyBub24temVybyBkaWdpdHMsIG9uZSBzaG91bGQgY2hvb3NlIHRoZSBmaXJzdCBhbW9uZyB0aGVcbiAgICclLjE1ZycsICclLjE2ZycsIGFuZCAnJS4xN2cnIHJlcHJlc2VudGF0aW9ucyB3aGljaCBkb2VzIHJvdW5kLXRyaXA6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIiAgICAgICAgICAgICAgICAgICAgICgqIHBpY2sgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNFwiXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lICopXG5cbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjhcIiAgICAgICAgICAgICAgICAgICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lLS1kb2VzIG5vdCByb3VuZC10cmlwICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMlwiICAgICAgICAoKiBwcmVmZXIgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjguMDAwMDAwMDAwMDAwMDAxOFwiICAgICAgICgqIHRoaXMgb25lIGhhcyBvbmUgZGlnaXQgb2YganVuayBhdCB0aGUgZW5kICopXG4gICB2fVxuXG4gICBTa2lwcGluZyB0aGUgJyUuMTZnJyBpbiB0aGUgYWJvdmUgcHJvY2VkdXJlIHNhdmVzIHVzIHNvbWUgdGltZSwgYnV0IGl0IG1lYW5zIHRoYXQsIGFzXG4gICBzZWVuIGluIHRoZSBzZWNvbmQgZXhhbXBsZSBhYm92ZSwgb2NjYXNpb25hbGx5IG51bWJlcnMgd2l0aCBleGFjdGx5IDE2IHNpZ25pZmljYW50XG4gICBkaWdpdHMgd2lsbCBoYXZlIGFuIGVycm9yIGludHJvZHVjZWQgYXQgdGhlIDE3dGggZGlnaXQuICBUaGF0IGlzIHByb2JhYmx5IE9LIGZvclxuICAgdHlwaWNhbCB1c2UsIGJlY2F1c2UgYSBudW1iZXIgd2l0aCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaXMgXCJ1Z2x5XCIgYWxyZWFkeS4gIEFkZGluZyBvbmVcbiAgIG1vcmUgZG9lc24ndCBtYWtlIGl0IG11Y2ggd29yc2UgZm9yIGEgaHVtYW4gcmVhZGVyLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgd2UgY2Fubm90IHNraXAgJyUuMTVnJyBhbmQgb25seSBsb29rIGF0ICclLjE2ZycgYW5kICclLjE3ZycsIHNpbmNlXG4gICB0aGUgaW5hY2N1cmFjeSBhdCB0aGUgMTZ0aCBkaWdpdCBtaWdodCBpbnRyb2R1Y2UgdGhlIG5vaXNlIHdlIHdhbnQgdG8gYXZvaWQ6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MlwiICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMVwiICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tanVuayBhdCB0aGUgZW5kICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMDlcIlxuICAgdn1cbiopXG5sZXQgdG9fc3RyaW5nIHggPVxuICB2YWxpZF9mbG9hdF9sZXhlbVxuICAgIChsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVnXCIgeCBpblxuICAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN2dcIiB4KVxuOztcblxubGV0IG1heF92YWx1ZSA9IGluZmluaXR5XG5sZXQgbWluX3ZhbHVlID0gbmVnX2luZmluaXR5XG5sZXQgbWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9IDIuICoqIC0xMDc0LlxubGV0IG1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTAyMi5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IHBpID0gMHgzLjI0M0Y2QTg4ODVBMzA4RDMxMzE5OEEyRTAzNzA3M1xubGV0IHNxcnRfcGkgPSAweDEuQzVCRjg5MUI0RUY2QUE3OUMzQjA1MjBENURCOTM4XG5sZXQgc3FydF8ycGkgPSAweDIuODFCMjYzRkVDNEUwQjJDQUY5NDgzRjVDRTQ1OURDXG5sZXQgZXVsZXIgPSAweDAuOTNDNDY3RTM3REIwQzdBNEQxQkUzRjgxMDE1MkNCXG5sZXQgb2ZfaW50ID0gSW50LnRvX2Zsb2F0XG5sZXQgdG9faW50ID0gSW50Lm9mX2Zsb2F0XG5sZXQgb2ZfaW50NjMgaSA9IEludDYzLnRvX2Zsb2F0IGlcbmxldCBvZl9pbnQ2NCBpID0gU3RkbGliLkludDY0LnRvX2Zsb2F0IGlcbmxldCB0b19pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdFxubGV0IGlyb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xubGV0IGlyb3VuZF91Ym91bmQgPSB1cHBlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xuXG4oKiBUaGUgcGVyZm9ybWFuY2Ugb2YgdGhlIFwiZXhuXCIgcm91bmRpbmcgZnVuY3Rpb25zIGlzIGltcG9ydGFudCwgc28gdGhleSBhcmUgd3JpdHRlblxuICAgb3V0IHNlcGFyYXRlbHksIGFuZCB0dW5lZCBpbmRpdmlkdWFsbHkuICAoV2UgY291bGQgaGF2ZSB0aGUgb3B0aW9uIHZlcnNpb25zIGNhbGxcbiAgIHRoZSBcImV4blwiIHZlcnNpb25zLCBidXQgdGhhdCBpbXBvc2VzIGFyZ3VhYmx5IGdyYXR1aXRvdXMgb3ZlcmhlYWQtLS1lc3BlY2lhbGx5XG4gICBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgY2FwdHVyZSBvZiBiYWNrdHJhY2VzIGlzIGVuYWJsZWQgdXBvbiBcIndpdGhcIi0tLWFuZCB0aGF0IHNlZW1zXG4gICBub3Qgd29ydGggaXQgd2hlbiBjb21wYXJlZCB0byB0aGUgcmVsYXRpdmVseSBzbWFsbCBhbW91bnQgb2YgY29kZSBkdXBsaWNhdGlvbi4pICopXG5cbigqIEVycm9yIHJlcG9ydGluZyBiZWxvdyBpcyB2ZXJ5IGNhcmVmdWxseSBhcnJhbmdlZCBzbyB0aGF0LCBlLmcuLCBbaXJvdW5kX25lYXJlc3RfZXhuXVxuICAgaXRzZWxmIGNhbiBiZSBpbmxpbmVkIGludG8gY2FsbGVycyBzdWNoIHRoYXQgdGhleSBkb24ndCBuZWVkIHRvIGFsbG9jYXRlIGEgYm94IGZvciB0aGVcbiAgIFtmbG9hdF0gYXJndW1lbnQuICBUaGlzIGlzIGRvbmUgd2l0aCBhIGJveCBbYm94XSBmdW5jdGlvbiBjYXJlZnVsbHkgY2hvc2VuIHRvIGFsbG93IHRoZVxuICAgY29tcGlsZXIgdG8gY3JlYXRlIGEgc2VwYXJhdGUgYm94IGZvciB0aGUgZmxvYXQgb25seSBpbiBlcnJvciBjYXNlcy4gIFNlZSwgZS5nLixcbiAgIFsuLi8uLi96ZXJvL3Rlc3QvcHJpY2VfdGVzdC5tbF0gZm9yIGEgbWVjaGFuaWNhbCB0ZXN0IG9mIHRoaXMgcHJvcGVydHkgd2hlbiBidWlsZGluZ1xuICAgd2l0aCBbWF9MSUJSQVJZX0lOTElOSU5HPXRydWVdLiAqKVxuXG5sZXQgaXJvdW5kX3VwIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9kb3duIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuIGlmIHQgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCkgZWxzZSBOb25lXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKCkpXG47O1xuXG5sZXQgaXJvdW5kX3Rvd2FyZHNfemVybyB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHQgPVxuICBpZiB0ID49IGlyb3VuZF9sYm91bmQgJiYgdCA8PSBpcm91bmRfdWJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaXJvdW5kX3Rvd2FyZHNfemVyb19leG46IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoYm94IHQpXG4gICAgICAoKVxuOztcblxuKCogT3V0c2lkZSBvZiB0aGUgcmFuZ2UgKHJvdW5kX25lYXJlc3RfbGIuLnJvdW5kX25lYXJlc3RfdWIpLCBhbGwgcmVwcmVzZW50YWJsZSBkb3VibGVzXG4gICBhcmUgaW50ZWdlcnMgaW4gdGhlIG1hdGhlbWF0aWNhbCBzZW5zZSwgYW5kIFtyb3VuZF9uZWFyZXN0XSBzaG91bGQgYmUgaWRlbnRpdHkuXG5cbiAgIEhvd2V2ZXIsIGZvciBvZGQgbnVtYmVycyB3aXRoIHRoZSBhYnNvbHV0ZSB2YWx1ZSBiZXR3ZWVuIDIqKjUyIGFuZCAyKio1MywgdGhlIGZvcm11bGFcbiAgIFtyb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArIDAuNSldIGRvZXMgbm90IGhvbGQ6XG5cbiAgIHt2XG4gICAgICMgbGV0IG5haXZlX3JvdW5kX25lYXJlc3QgeCA9IGZsb29yICh4ICsuIDAuNSk7O1xuICAgICAjIGxldCB4ID0gMi4gKiogNTIuICsuIDEuOztcbiAgICAgdmFsIHggOiBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTcuXG4gICAgICMgbmFpdmVfcm91bmRfbmVhcmVzdCB4OztcbiAgICAgLSA6ICAgICBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTguXG4gICB2fVxuKilcblxubGV0IHJvdW5kX25lYXJlc3RfbGIgPSAtLigyLiAqKiA1Mi4pXG5sZXQgcm91bmRfbmVhcmVzdF91YiA9IDIuICoqIDUyLlxuXG4oKiBGb3IgW3ggPSBvbmVfdWxwIGBEb3duIDAuNV0sIHRoZSBmb3JtdWxhIFtmbG9vciAoeCArLiAwLjUpXSBmb3Igcm91bmRpbmcgdG8gbmVhcmVzdFxuICAgZG9lcyBub3Qgd29yaywgYmVjYXVzZSB0aGUgZXhhY3QgcmVzdWx0IGlzIGhhbGZ3YXkgYmV0d2VlbiBbb25lX3VscCBgRG93biAxLl0gYW5kIFsxLl0sXG4gICBhbmQgaXQgZ2V0cyByb3VuZGVkIHVwIHRvIFsxLl0gZHVlIHRvIHRoZSByb3VuZC10aWVzLXRvLWV2ZW4gcnVsZS4gKilcbmxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscCBgRG93biAwLjVcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0ID1cbiAgdFxuICArLlxuICBpZiB0ID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICB0aGVuIG9uZV91bHBfbGVzc190aGFuX2hhbGYgKCogc2luY2UgdCA8IDAuNSwgbWFrZSBzdXJlIHRoZSByZXN1bHQgaXMgPCAxLjAgKilcbiAgZWxzZSAwLjVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgKHQgKy4gMC41KSBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfNjQgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlblxuICAgIGlmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gICAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KSlcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICAgIGVsc2UgTm9uZVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF82NFxuICB8IFczMiAtPiBpcm91bmRfbmVhcmVzdF8zMlxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4bl8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsXCIgKGJveCB0KSAoKSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX25lYXJlc3RfZXhuXzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdClcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF9leG5fNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzMyXG47O1xuXG4oKiBUaGUgZm9sbG93aW5nIFtpcm91bmRfZXhuXSBhbmQgW2lyb3VuZF0gZnVuY3Rpb25zIGFyZSBzbG93ZXIgdGhhbiB0aGUgb25lcyBhYm92ZS5cbiAgIFRoZWlyIGVxdWl2YWxlbmNlIHRvIHRob3NlIGZ1bmN0aW9ucyBpcyB0ZXN0ZWQgaW4gdGhlIHVuaXQgdGVzdHMgYmVsb3cuICopXG5cbmxldFtAaW5saW5lXSBpcm91bmRfZXhuID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBaZXJvIC0+IGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHRcbiAgfCBgTmVhcmVzdCAtPiBpcm91bmRfbmVhcmVzdF9leG4gdFxuICB8IGBVcCAtPiBpcm91bmRfdXBfZXhuIHRcbiAgfCBgRG93biAtPiBpcm91bmRfZG93bl9leG4gdFxuOztcblxubGV0IGlyb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgdHJ5IFNvbWUgKGlyb3VuZF9leG4gfmRpciB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgaXNfaW5mIHQgPSAxLiAvLiB0ID0gMC5cbmxldCBpc19maW5pdGUgdCA9IHQgLS4gdCA9IDAuXG5cbmxldCBtaW5faW5hbiAoeCA6IHQpIHkgPVxuICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5XG47O1xuXG5sZXQgbWF4X2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IGFkZCA9ICggKy4gKVxubGV0IHN1YiA9ICggLS4gKVxubGV0IG5lZyA9ICggfi0uIClcbmxldCBhYnMgPSBhYnNfZmxvYXRcbmxldCBzY2FsZSA9ICggKi4gKVxubGV0IHNxdWFyZSB4ID0geCAqLiB4XG5cbm1vZHVsZSBQYXJ0cyA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgZnJhY3Rpb25hbCA6IHQgLT4gZmxvYXRcbiAgdmFsIGludGVncmFsIDogdCAtPiBmbG9hdFxuICB2YWwgbW9kZiA6IGZsb2F0IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdCAqIGZsb2F0XG5cbiAgbGV0IGZyYWN0aW9uYWwgdCA9IGZzdCB0XG4gIGxldCBpbnRlZ3JhbCB0ID0gc25kIHRcbiAgbGV0IG1vZGYgPSBtb2RmXG5lbmRcblxubGV0IG1vZGYgPSBQYXJ0cy5tb2RmXG5sZXQgcm91bmRfZG93biA9IGZsb29yXG5sZXQgcm91bmRfdXAgPSBjZWlsXG5sZXQgcm91bmRfdG93YXJkc196ZXJvIHQgPSBpZiB0ID49IDAuIHRoZW4gcm91bmRfZG93biB0IGVsc2Ugcm91bmRfdXAgdFxuXG4oKiBzZWUgdGhlIGNvbW1lbnQgYWJvdmUgW3JvdW5kX25lYXJlc3RfbGJdIGFuZCBbcm91bmRfbmVhcmVzdF91Yl0gZm9yIGFuIGV4cGxhbmF0aW9uICopXG5sZXRbQG9jYW1sLmlubGluZV0gcm91bmRfbmVhcmVzdF9pbmxpbmUgdCA9XG4gIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiICYmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gZmxvb3IgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gIGVsc2UgdCArLiAwLlxuOztcblxubGV0IHJvdW5kX25lYXJlc3QgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdFxuXG5sZXQgcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gdCA9XG4gIGlmIHQgPD0gcm91bmRfbmVhcmVzdF9sYiB8fCB0ID49IHJvdW5kX25lYXJlc3RfdWJcbiAgdGhlbiB0ICsuIDAuXG4gIGVsc2UgKFxuICAgIGxldCBmbG9vciA9IGZsb29yIHQgaW5cbiAgICAoKiBbY2VpbF9vcl9zdWNjID0gaWYgdCBpcyBhbiBpbnRlZ2VyIHRoZW4gdCArLiAxLiBlbHNlIGNlaWwgdF0uICBGYXN0ZXIgdGhhbiBbY2VpbF0uICopXG4gICAgbGV0IGNlaWxfb3Jfc3VjYyA9IGZsb29yICsuIDEuIGluXG4gICAgbGV0IGRpZmZfZmxvb3IgPSB0IC0uIGZsb29yIGluXG4gICAgbGV0IGRpZmZfY2VpbCA9IGNlaWxfb3Jfc3VjYyAtLiB0IGluXG4gICAgaWYgZGlmZl9mbG9vciA8IGRpZmZfY2VpbFxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGlmIGRpZmZfZmxvb3IgPiBkaWZmX2NlaWxcbiAgICB0aGVuIGNlaWxfb3Jfc3VjY1xuICAgIGVsc2UgaWYgKCogZXhhY3QgdGllLCBwaWNrIHRoZSBldmVuICopXG4gICAgICBtb2RfZmxvYXQgZmxvb3IgMi4gPSAwLlxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGNlaWxfb3Jfc3VjYylcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludDYzLm51bV9iaXRzXG5sZXQgaW50NjNfcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xuXG5sZXQgaW50NjNfcm91bmRfdXBfZXhuIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9kb3duX2V4biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biB0MCA9XG4gIGxldCB0ID0gKHJvdW5kX25lYXJlc3RfaW5saW5lIFtAb2NhbWwuaW5saW5lZCBhbHdheXNdKSB0MCBpblxuICBpZiB0ID4gMC5cbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChib3ggdDApXG4gICAgICAgICgpXG4gIGVsc2UgaWYgdCA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKGJveCB0MClcbiAgICAgICgpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gZiA9IEludDYzLm9mX2ludCAoaXJvdW5kX25lYXJlc3RfZXhuIGYpXG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4blxuICB8IFczMiAtPiBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4blxuOztcblxubGV0IHJvdW5kID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBOZWFyZXN0IC0+IHJvdW5kX25lYXJlc3QgdFxuICB8IGBEb3duIC0+IHJvdW5kX2Rvd24gdFxuICB8IGBVcCAtPiByb3VuZF91cCB0XG4gIHwgYFplcm8gLT4gcm91bmRfdG93YXJkc196ZXJvIHRcbjs7XG5cbm1vZHVsZSBDbGFzcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgSW5maW5pdGVcbiAgICB8IE5hblxuICAgIHwgTm9ybWFsXG4gICAgfCBTdWJub3JtYWxcbiAgICB8IFplcm9cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEluZmluaXRlOyBOYW47IE5vcm1hbDsgU3Vibm9ybWFsOyBaZXJvIF0gOiB0IGxpc3QpXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwN18gPSBcImZsb2F0Lm1sLkNsYXNzLnRcIiBpblxuICAgICBmdW5jdGlvblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmZpbml0ZVwiIHwgXCJJbmZpbml0ZVwiKSAtPiBJbmZpbml0ZVxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIC0+IE5hblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJub3JtYWxcIiB8IFwiTm9ybWFsXCIpIC0+IE5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIC0+IFN1Ym5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA4XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSA6OiBfKSBhcyBzZXhwX18wMDhfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwN18gc2V4cF9fMDA4X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgOjogXykgYXMgc2V4cF9fMDA4XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA4XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwOF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDZfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwN18gc2V4cF9fMDA2X1xuICAgICB8IHNleHBfXzAwNl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDZfXG4gICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgSW5maW5pdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5maW5pdGVcIlxuICAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgIHwgTm9ybWFsIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5vcm1hbFwiXG4gICAgICB8IFN1Ym5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdWJub3JtYWxcIlxuICAgICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiSW5maW5pdGVcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTmFuXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5vcm1hbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJTdWJub3JtYWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmVuZFxuXG5sZXQgY2xhc3NpZnkgdCA9XG4gIGxldCBtb2R1bGUgQyA9IENsYXNzIGluXG4gIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHQgd2l0aFxuICB8IEZQX25vcm1hbCAtPiBDLk5vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbCAtPiBDLlN1Ym5vcm1hbFxuICB8IEZQX3plcm8gLT4gQy5aZXJvXG4gIHwgRlBfaW5maW5pdGUgLT4gQy5JbmZpbml0ZVxuICB8IEZQX25hbiAtPiBDLk5hblxuOztcblxubGV0IGluc2VydF91bmRlcnNjb3JlcyA/KGRlbGltaXRlciA9ICdfJykgPyhzdHJpcF96ZXJvID0gZmFsc2UpIHN0cmluZyA9XG4gIG1hdGNoIFN0cmluZy5sc3BsaXQyIHN0cmluZyB+b246Jy4nIHdpdGhcbiAgfCBOb25lIC0+IEludF9jb252ZXJzaW9ucy5pbnNlcnRfZGVsaW1pdGVyIHN0cmluZyB+ZGVsaW1pdGVyXG4gIHwgU29tZSAobGVmdCwgcmlnaHQpIC0+XG4gICAgbGV0IGxlZnQgPSBJbnRfY29udmVyc2lvbnMuaW5zZXJ0X2RlbGltaXRlciBsZWZ0IH5kZWxpbWl0ZXIgaW5cbiAgICBsZXQgcmlnaHQgPVxuICAgICAgaWYgc3RyaXBfemVybyB0aGVuIFN0cmluZy5yc3RyaXAgcmlnaHQgfmRyb3A6KGZ1biBjIC0+IENoYXIuKCA9ICkgYyAnMCcpIGVsc2UgcmlnaHRcbiAgICBpblxuICAgIChtYXRjaCByaWdodCB3aXRoXG4gICAgIHwgXCJcIiAtPiBsZWZ0XG4gICAgIHwgXyAtPiBsZWZ0IF4gXCIuXCIgXiByaWdodClcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtID9kZWxpbWl0ZXIgPyhkZWNpbWFscyA9IDMpID9zdHJpcF96ZXJvID8oZXhwbGljaXRfcGx1cyA9IGZhbHNlKSBmID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBkZWNpbWFscyAwXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwidG9fc3RyaW5nX2h1bTogaW52YWxpZCBhcmd1bWVudCB+ZGVjaW1hbHM9JWRcIiBkZWNpbWFscyAoKTtcbiAgbWF0Y2ggY2xhc3NpZnkgZiB3aXRoXG4gIHwgQ2xhc3MuSW5maW5pdGUgLT4gaWYgZiA+IDAuIHRoZW4gXCJpbmZcIiBlbHNlIFwiLWluZlwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuXCJcbiAgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IHMgPVxuICAgICAgaWYgZXhwbGljaXRfcGx1cyB0aGVuIHNwcmludGYgXCIlKy4qZlwiIGRlY2ltYWxzIGYgZWxzZSBzcHJpbnRmIFwiJS4qZlwiIGRlY2ltYWxzIGZcbiAgICBpblxuICAgIGluc2VydF91bmRlcnNjb3JlcyBzID9kZWxpbWl0ZXIgP3N0cmlwX3plcm9cbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIGxldCBzZXhwID0gc2V4cF9vZl90IHQgaW5cbiAgbWF0Y2ggIVNleHAub2ZfZmxvYXRfc3R5bGUgd2l0aFxuICB8IGBOb191bmRlcnNjb3JlcyAtPiBzZXhwXG4gIHwgYFVuZGVyc2NvcmVzIC0+XG4gICAgKG1hdGNoIHNleHAgd2l0aFxuICAgICB8IExpc3QgXyAtPlxuICAgICAgIHJhaXNlX3NcbiAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgIFwiW3NleHBfb2ZfZmxvYXRdIHByb2R1Y2VkIHN0cmFuZ2Ugc2V4cFwiXG4gICAgICAgICAgICBbIFwic2V4cFwiLCBTZXhwLnNleHBfb2ZfdCBzZXhwIF0pXG4gICAgIHwgQXRvbSBzdHJpbmcgLT5cbiAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgc3RyaW5nICdFJyB0aGVuIHNleHAgZWxzZSBBdG9tIChpbnNlcnRfdW5kZXJzY29yZXMgc3RyaW5nKSlcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgPyhwcmVmaXggPSBcIlwiKSB+a2lsbyB+bWVnYSB+Z2lnYSB+dGVyYSA/cGV0YSAoKSA9XG4gICgqIFJvdW5kIGEgcmF0aW8gdG93YXJkIHRoZSBuZWFyZXN0IGludGVnZXIsIHJlc29sdmluZyB0aWVzIHRvd2FyZCB0aGUgbmVhcmVzdCBldmVuXG4gICAgIG51bWJlci4gIEZvciBzYW5lIGlucHV0cyAoaW4gcGFydGljdWxhciwgd2hlbiBbZGVub21pbmF0b3JdIGlzIGFuIGludGVnZXIgYW5kXG4gICAgIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0pIHRoaXMgc2hvdWxkIGJlIGFjY3VyYXRlLiAgT3RoZXJ3aXNlLCB0aGUgcmVzdWx0IG1pZ2h0IGJlIGFcbiAgICAgbGl0dGxlIGJpdCBvZmYsIGJ1dCB3ZSBkb24ndCByZWFsbHkgdXNlIHRoYXQgY2FzZS4gKilcbiAgbGV0IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvciB+ZGVub21pbmF0b3IgPVxuICAgIGxldCBrID0gZmxvb3IgKG51bWVyYXRvciAvLiBkZW5vbWluYXRvcikgaW5cbiAgICAoKiBpZiBbYWJzIGsgPCAyZTUzXSwgdGhlbiBib3RoIFtrXSBhbmQgW2sgKy4gMS5dIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBhbmQgaW5cbiAgICAgICBwYXJ0aWN1bGFyIFtrICsuIDEuID4ga10uICBJZiBbZGVub21pbmF0b3JdIGlzIGFsc28gYW4gaW50ZWdlciwgYW5kXG4gICAgICAgW2FicyAoZGVub21pbmF0b3IgKi4gKGsgKy4gMSkpIDwgMmU1M10gKGFuZCBpbiBzb21lIG90aGVyIGNhc2VzLCB0b28pLCB0aGVuIFtsb3dlcl1cbiAgICAgICBhbmQgW2hpZ2hlcl0gYXJlIGFjdHVhbGx5IGJvdGggYWNjdXJhdGUuICBTaW5jZSAocm91Z2hseSlcbiAgICAgICBbbnVtZXJhdG9yID0gZGVub21pbmF0b3IgKi4ga10gdGhlbiBmb3IgW2FicyBudW1lcmF0b3IgPCAyZTUyXSB3ZSBzaG91bGQgYmVcbiAgICAgICBmaW5lLiAqKVxuICAgIGxldCBsb3dlciA9IGRlbm9taW5hdG9yICouIGsgaW5cbiAgICBsZXQgaGlnaGVyID0gZGVub21pbmF0b3IgKi4gKGsgKy4gMS4pIGluXG4gICAgKCogU3VidHJhY3RpbmcgbnVtYmVycyB3aXRoaW4gYSBmYWN0b3Igb2YgdHdvIGZyb20gZWFjaCBvdGhlciBpcyBhY2N1cmF0ZS5cbiAgICAgICBTbyBlaXRoZXIgdGhlIHR3byBzdWJ0cmFjdGlvbnMgYmVsb3cgYXJlIGFjY3VyYXRlLCBvciBrID0gMCwgb3IgayA9IC0xLlxuICAgICAgIEluIGNhc2Ugb2YgYSB0aWUsIHJvdW5kIHRvIGV2ZW4uICopXG4gICAgbGV0IGRpZmZfcmlnaHQgPSBoaWdoZXIgLS4gbnVtZXJhdG9yIGluXG4gICAgbGV0IGRpZmZfbGVmdCA9IG51bWVyYXRvciAtLiBsb3dlciBpblxuICAgIGxldCBrID0gaXJvdW5kX25lYXJlc3RfZXhuIGsgaW5cbiAgICBpZiBkaWZmX3JpZ2h0IDwgZGlmZl9sZWZ0XG4gICAgdGhlbiBrICsgMVxuICAgIGVsc2UgaWYgZGlmZl9yaWdodCA+IGRpZmZfbGVmdFxuICAgIHRoZW4ga1xuICAgIGVsc2UgaWYgKCogYSB0aWUgKilcbiAgICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKGsgbW9kIDIpIDBcbiAgICB0aGVuIGtcbiAgICBlbHNlIGsgKyAxXG4gIGluXG4gIG1hdGNoIGNsYXNzaWZ5IHQgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIHQgPCAwLjAgdGhlbiBcIi1pbmYgIFwiIGVsc2UgXCJpbmYgIFwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuICBcIlxuICB8IENsYXNzLlN1Ym5vcm1hbCB8IENsYXNzLk5vcm1hbCB8IENsYXNzLlplcm8gLT5cbiAgICBsZXQgZ28gdCA9XG4gICAgICBsZXQgY29udl9vbmUgdCA9XG4gICAgICAgIGFzc2VydCAoMC4gPD0gdCAmJiB0IDwgOTk5Ljk1KTtcbiAgICAgICAgbGV0IHggPSBwcmVmaXggXiBmb3JtYXRfZmxvYXQgXCIlLjFmXCIgdCBpblxuICAgICAgICAoKiBGaXggdGhlIFwiLjBcIiBzdWZmaXggKilcbiAgICAgICAgaWYgU3RyaW5nLmlzX3N1ZmZpeCB4IH5zdWZmaXg6XCIuMFwiXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB4ID0gQnl0ZXMub2Zfc3RyaW5nIHggaW5cbiAgICAgICAgICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCB4IGluXG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAxKSAnICc7XG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAyKSAnICc7XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp4KVxuICAgICAgICBlbHNlIHhcbiAgICAgIGluXG4gICAgICBsZXQgY29udiBtYWcgdCBkZW5vbWluYXRvciA9XG4gICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgKGRlbm9taW5hdG9yID0gMTAwLiAmJiB0ID49IDk5OS45NSlcbiAgICAgICAgICB8fCAoZGVub21pbmF0b3IgPj0gMTAwXzAwMC4gJiYgdCA+PSByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Ljk5OV81KSkpO1xuICAgICAgICBhc3NlcnQgKHQgPCByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Xzk5OS41KSk7XG4gICAgICAgIGxldCBpLCBkID1cbiAgICAgICAgICBsZXQgayA9IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvcjp0IH5kZW5vbWluYXRvciBpblxuICAgICAgICAgICgqIFttb2RdIGlzIG9rYXkgaGVyZSBiZWNhdXNlIHdlIGtub3cgaSA+PSAwLiAqKVxuICAgICAgICAgIGsgLyAxMCwgayBtb2QgMTBcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgICAgICBhc3NlcnQgKDAgPD0gaSAmJiBpIDwgMTAwMCk7XG4gICAgICAgIGFzc2VydCAoMCA8PSBkICYmIGQgPCAxMCk7XG4gICAgICAgIGlmIGQgPSAwXG4gICAgICAgIHRoZW4gc3ByaW50ZiBcIiVzJWQlcyBcIiBwcmVmaXggaSBtYWdcbiAgICAgICAgZWxzZSBzcHJpbnRmIFwiJXMlZCVzJWRcIiBwcmVmaXggaSBtYWcgZFxuICAgICAgaW5cbiAgICAgICgqIFdoaWxlIHRoZSBzdGFuZGFyZCBtZXRyaWMgcHJlZml4ZXMgKGUuZy4gY2FwaXRhbCBcIk1cIiByYXRoZXIgdGhhbiBcIm1cIiwgWzFdKSBhcmVcbiAgICAgICAgIG5vbWluYWxseSBtb3JlIGNvcnJlY3QsIHRoaXMgaGluZGVycyByZWFkYWJpbGl0eSBpbiBvdXIgY2FzZS4gIEUuZy4sIDEwRzYgYW5kXG4gICAgICAgICAxMDY2IGxvb2sgdG9vIHNpbWlsYXIuICBUaGF0J3MgYW4gZXh0cmVtZSBleGFtcGxlLCBidXQgaW4gZ2VuZXJhbCBrLG0sZyx0LHBcbiAgICAgICAgIHByb2JhYmx5IHN0YW5kIG91dCBiZXR0ZXIgdGhhbiBLLE0sRyxULFAgd2hlbiBpbnRlcnNwZXJzZWQgd2l0aCBkaWdpdHMuXG5cbiAgICAgICAgIFsxXSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldHJpY19wcmVmaXggKilcbiAgICAgICgqIFRoZSB0cmljayBoZXJlIGlzIHRoYXQ6XG4gICAgICAgICAtIHRoZSBmaXJzdCBib3VuZGFyeSAoOTk5Ljk1KSBhcyBhIGZsb2F0IGlzIHNsaWdodGx5IG92ZXItcmVwcmVzZW50ZWQgKHNvIGl0IGlzXG4gICAgICAgICAgIGJldHRlciBhcHByb3hpbWF0ZWQgYXMgXCIxa1wiIHRoYW4gYXMgXCI5OTkuOVwiKSxcbiAgICAgICAgIC0gdGhlIG90aGVyIGJvdW5kYXJpZXMgYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQsIGJlY2F1c2UgdGhleSBhcmUgaW50ZWdlcnMuXG4gICAgICAgICAgIFRoYXQncyB3aHkgdGhlIHN0cmljdCBlcXVhbGl0aWVzIGJlbG93IGRvIGV4YWN0bHkgd2hhdCB3ZSB3YW50LiAqKVxuICAgICAgaWYgdCA8IDk5OS45NUUwXG4gICAgICB0aGVuIGNvbnZfb25lIHRcbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUzXG4gICAgICB0aGVuIGNvbnYga2lsbyB0IDEwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUU2XG4gICAgICB0aGVuIGNvbnYgbWVnYSB0IDEwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFOVxuICAgICAgdGhlbiBjb252IGdpZ2EgdCAxMDBfMDAwXzAwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUxMlxuICAgICAgdGhlbiBjb252IHRlcmEgdCAxMDBfMDAwXzAwMF8wMDAuXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggcGV0YSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBzcHJpbnRmIFwiJXMlLjFlXCIgcHJlZml4IHRcbiAgICAgICAgfCBTb21lIHBldGEgLT5cbiAgICAgICAgICBpZiB0IDwgOTk5Ljk1RTE1XG4gICAgICAgICAgdGhlbiBjb252IHBldGEgdCAxMDBfMDAwXzAwMF8wMDBfMDAwLlxuICAgICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0KVxuICAgIGluXG4gICAgaWYgdCA+PSAwLiB0aGVuIGdvIHQgZWxzZSBcIi1cIiBeIGdvIH4tLnRcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmcgdCA9XG4gIHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0b20gdCB+a2lsbzpcImtcIiB+bWVnYTpcIm1cIiB+Z2lnYTpcImdcIiB+dGVyYTpcInRcIiB+cGV0YTpcInBcIiAoKVxuOztcblxuKCogUGVyZm9ybWFuY2Ugbm90ZTogSW5pdGlhbGl6aW5nIHRoZSBhY2N1bXVsYXRvciB0byAxIHJlc3VsdHMgaW4gb25lIGV4dHJhXG4gICBtdWx0aXBseTsgZS5nLiwgdG8gY29tcHV0ZSB4ICoqIDQsIHdlIGluIHByaW5jaXBsZSBvbmx5IG5lZWQgMiBtdWx0aXBsaWVzLFxuICAgYnV0IHRoaXMgZnVuY3Rpb24gd2lsbCBoYXZlIDMgbXVsdGlwbGllcy4gIEhvd2V2ZXIsIGF0dGVtcHRzIHRvIGF2b2lkIHRoaXNcbiAgIChsaWtlIGRlY3JlbWVudGluZyBuIGFuZCBpbml0aWFsaXppbmcgYWNjdW0gdG8gYmUgeCwgb3IgaGFuZGxpbmcgc21hbGxcbiAgIGV4cG9uZW50cyBhcyBhIHNwZWNpYWwgY2FzZSkgaGF2ZSBub3QgeWllbGRlZCBhbnl0aGluZyB0aGF0IGlzIGEgbmV0XG4gICBpbXByb3ZlbWVudC5cbiopXG5sZXQgaW50X3BvdyB4IG4gPVxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gMS5cbiAgZWxzZSAoXG4gICAgKCogVXNpbmcgW3ggKy4gKC0wLildIG9uIHRoZSBmb2xsb3dpbmcgbGluZSBjb252aW5jZXMgdGhlIGNvbXBpbGVyIHRvIGF2b2lkIGEgY2VydGFpblxuICAgICAgIGJveGluZyAodGhhdCB3b3VsZCByZXN1bHQgaW4gYWxsb2NhdGlvbiBpbiBlYWNoIGl0ZXJhdGlvbikuICBTb29uLCB0aGUgY29tcGlsZXJcbiAgICAgICBzaG91bGRuJ3QgbmVlZCB0aGlzIFwiaGludFwiIHRvIGF2b2lkIHRoZSBib3hpbmcuICBUaGUgcmVhc29uIHdlIGFkZCAtMCByYXRoZXIgdGhhbiAwXG4gICAgICAgaXMgdGhhdCBbeCArLiAoLTAuKV0gaXMgYXBwYXJlbnRseSBhbHdheXMgdGhlIHNhbWUgYXMgW3hdLCB3aGVyZWFzIFt4ICsuIDAuXSBpc1xuICAgICAgIG5vdCwgaW4gdGhhdCBpdCBzZW5kcyBbLTAuXSB0byBbMC5dLiAgVGhpcyBtYWtlcyBhIGRpZmZlcmVuY2UgYmVjYXVzZSB3ZSB3YW50XG4gICAgICAgW2ludF9wb3cgKC0wLikgKC0xKV0gdG8gcmV0dXJuIG5lZ19pbmZpbml0eSBqdXN0IGxpa2UgWy0wLiAqKiAtMS5dIHdvdWxkLiAgKilcbiAgICBsZXQgeCA9IHJlZiAoeCArLiAtMC4pIGluXG4gICAgbGV0IG4gPSByZWYgbiBpblxuICAgIGxldCBhY2N1bSA9IHJlZiAxLiBpblxuICAgIGlmICFuIDwgMFxuICAgIHRoZW4gKFxuICAgICAgKCogeCAqKiBuID0gKDEveCkgKiogLW4gKilcbiAgICAgIHggOj0gMS4gLy4gIXg7XG4gICAgICBuIDo9IH4tICghbik7XG4gICAgICBpZiAhbiA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBuIG11c3QgaGF2ZSBiZWVuIG1pbl9pbnQsIHNvIGl0IGlzIG5vdyBzbyBiaWcgdGhhdCBpdCBoYXMgd3JhcHBlZCBhcm91bmQuXG4gICAgICAgICAgIFdlIGRlY3JlbWVudCBpdCBzbyB0aGF0IGl0IGxvb2tzIHBvc2l0aXZlIGFnYWluLCBidXQgYWNjb3JkaW5nbHkgaGF2ZVxuICAgICAgICAgICB0byBwdXQgYW4gZXh0cmEgZmFjdG9yIG9mIHggaW4gdGhlIGFjY3VtdWxhdG9yLlxuICAgICAgICAqKVxuICAgICAgICBhY2N1bSA6PSAheDtcbiAgICAgICAgZGVjciBuKSk7XG4gICAgKCogTGV0dGluZyBbYV0gZGVub3RlICh0aGUgb3JpZ2luYWwgdmFsdWUgb2YpIFt4ICoqIG5dLCB3ZSBtYWludGFpblxuICAgICAgIHRoZSBpbnZhcmlhbnQgdGhhdCBbKHggKiogbikgKi4gYWNjdW0gPSBhXS4gKilcbiAgICB3aGlsZSAhbiA+IDEgZG9cbiAgICAgIGlmICFuIGxhbmQgMSA8PiAwIHRoZW4gYWNjdW0gOj0gIXggKi4gIWFjY3VtO1xuICAgICAgeCA6PSAheCAqLiAheDtcbiAgICAgIG4gOj0gIW4gbHNyIDFcbiAgICBkb25lO1xuICAgICgqIG4gaXMgbmVjZXNzYXJpbHkgMSBhdCB0aGlzIHBvaW50LCBzbyB0aGVyZSBpcyBvbmUgYWRkaXRpb25hbFxuICAgICAgIG11bHRpcGxpY2F0aW9uIGJ5IHguICopXG4gICAgIXggKi4gIWFjY3VtKVxuOztcblxubGV0IHJvdW5kX2dlbiB4IH5ob3cgPVxuICBpZiB4ID0gMC5cbiAgdGhlbiAwLlxuICBlbHNlIGlmIG5vdCAoaXNfZmluaXRlIHgpXG4gIHRoZW4geFxuICBlbHNlIChcbiAgICAoKiBTaWduaWZpY2FudCBkaWdpdHMgYW5kIGRlY2ltYWwgZGlnaXRzLiAqKVxuICAgIGxldCBzZCwgZGQgPVxuICAgICAgbWF0Y2ggaG93IHdpdGhcbiAgICAgIHwgYHNpZ25pZmljYW50X2RpZ2l0cyBzZCAtPlxuICAgICAgICBsZXQgZGQgPSBzZCAtIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICAgIHwgYGRlY2ltYWxfZGlnaXRzIGRkIC0+XG4gICAgICAgIGxldCBzZCA9IGRkICsgdG9faW50IChyb3VuZF91cCAobG9nMTAgKGFicyB4KSkpIGluXG4gICAgICAgIHNkLCBkZFxuICAgIGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGlmIHNkIDwgMFxuICAgIHRoZW4gMC5cbiAgICBlbHNlIGlmIHNkID49IDE3XG4gICAgdGhlbiB4XG4gICAgZWxzZSAoXG4gICAgICAoKiBDaG9vc2UgdGhlIG9yZGVyIHRoYXQgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQuIFNtYWxsIHBvc2l0aXZlXG4gICAgICAgICBpbnRlZ2VycyBhcmUsIGJ1dCB0aGVpciBpbnZlcnNlcyBpbiBtb3N0IGNhc2VzIGFyZSBub3QuICopXG4gICAgICBsZXQgYWJzX2RkID0gSW50LmFicyBkZCBpblxuICAgICAgaWYgYWJzX2RkID4gMjIgfHwgc2QgPj0gMTZcbiAgICAgICgqIDEwKioyMiBpcyBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgYnV0IDEwKioyMyBpcyBub3QsIHNvIHVzZSB0aGUgc2xvd1xuICAgICAgICAgcGF0aC4gIFNpbWlsYXJseSwgaWYgd2UgbmVlZCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJlc3VsdCwgdGhlbiB0aGUgaW50ZWdlclxuICAgICAgICAgW3JvdW5kX25lYXJlc3QgKHggPG9wPiBvcmRlcildIG1pZ2h0IG5vdCBiZSBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgc2luY2VcbiAgICAgICAgIGZvciBzb21lIHJhbmdlcyB3ZSBvbmx5IGhhdmUgMTUgZGlnaXRzIG9mIHByZWNpc2lvbiBndWFyYW50ZWVkLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHdlIGFyZSBzdGlsbCByb3VuZGluZyB0d2ljZSBoZXJlOlxuXG4gICAgICAgICAxKSBmaXJzdCB0aW1lIHdoZW4gcm91bmRpbmcgW3ggKi4gb3JkZXJdIG9yIFt4IC8uIG9yZGVyXSB0byB0aGUgbmVhcmVzdCBmbG9hdFxuICAgICAgICAgKGp1c3QgdGhlIG5vcm1hbCB3YXkgZmxvYXRpbmctcG9pbnQgbXVsdGlwbGljYXRpb24gb3IgZGl2aXNpb24gd29ya3MpLFxuXG4gICAgICAgICAyKSBzZWNvbmQgdGltZSB3aGVuIGFwcGx5aW5nIFtyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbl0gdG8gdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgIGFib3ZlIG9wZXJhdGlvblxuXG4gICAgICAgICBTbyBmb3IgYXJndW1lbnRzIHdpdGhpbiBhbiB1bHAgZnJvbSBhIHRpZSB3ZSBtaWdodCBzdGlsbCBwcm9kdWNlIGFuIG9mZi1ieS1vbmVcbiAgICAgICAgIHJlc3VsdC4gKilcbiAgICAgIHRoZW4gb2Zfc3RyaW5nIChzcHJpbnRmIFwiJS4qZ1wiIHNkIHgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG9yZGVyID0gaW50X3BvdyAxMC4gYWJzX2RkIGluXG4gICAgICAgIGlmIGRkID49IDBcbiAgICAgICAgdGhlbiByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAqLiBvcmRlcikgLy4gb3JkZXJcbiAgICAgICAgZWxzZSByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAvLiBvcmRlcikgKi4gb3JkZXIpKSlcbjs7XG5cbmxldCByb3VuZF9zaWduaWZpY2FudCB4IH5zaWduaWZpY2FudF9kaWdpdHMgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBzaWduaWZpY2FudF9kaWdpdHMgMFxuICB0aGVuXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LnJvdW5kX3NpZ25pZmljYW50OiBpbnZhbGlkIGFyZ3VtZW50IHNpZ25pZmljYW50X2RpZ2l0czolZFwiXG4gICAgICBzaWduaWZpY2FudF9kaWdpdHNcbiAgICAgICgpXG4gIGVsc2Ugcm91bmRfZ2VuIHggfmhvdzooYHNpZ25pZmljYW50X2RpZ2l0cyBzaWduaWZpY2FudF9kaWdpdHMpXG47O1xuXG5sZXQgcm91bmRfZGVjaW1hbCB4IH5kZWNpbWFsX2RpZ2l0cyA9IHJvdW5kX2dlbiB4IH5ob3c6KGBkZWNpbWFsX2RpZ2l0cyBkZWNpbWFsX2RpZ2l0cylcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgKCogY2xhbXBfdW5jaGVja2VkIGlzIGluIGZsb2F0MC5tbCAqKVxuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICgqIEFsc28gZmFpbHMgaWYgW21pbl0gb3IgW21heF0gaXMgbmFuICopXG4gIGlmIG1pbiA8PSBtYXhcbiAgdGhlbiBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICBlbHNlXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuOztcblxubGV0ICggKyApID0gKCArLiApXG5sZXQgKCAtICkgPSAoIC0uIClcbmxldCAoICogKSA9ICggKi4gKVxubGV0ICggKiogKSA9ICggKiogKVxubGV0ICggLyApID0gKCAvLiApXG5sZXQgKCAlICkgPSAoICUuIClcbmxldCAoIH4tICkgPSAoIH4tLiApXG5cbmxldCBzaWduX2V4biB0IDogU2lnbi50ID1cbiAgaWYgdCA+IDAuXG4gIHRoZW4gUG9zXG4gIGVsc2UgaWYgdCA8IDAuXG4gIHRoZW4gTmVnXG4gIGVsc2UgaWYgdCA9IDAuXG4gIHRoZW4gWmVyb1xuICBlbHNlIEVycm9yLnJhaXNlX3MgKFNleHAubWVzc2FnZSBcIkZsb2F0LnNpZ25fZXhuIG9mIE5BTlwiIFsgXCJcIiwgc2V4cF9vZl90IHQgXSlcbjs7XG5cbmxldCBzaWduX29yX25hbiB0IDogU2lnbl9vcl9uYW4udCA9XG4gIGlmIHQgPiAwLiB0aGVuIFBvcyBlbHNlIGlmIHQgPCAwLiB0aGVuIE5lZyBlbHNlIGlmIHQgPSAwLiB0aGVuIFplcm8gZWxzZSBOYW5cbjs7XG5cbmxldCBpZWVlX25lZ2F0aXZlIHQgPVxuICBsZXQgYml0cyA9IFN0ZGxpYi5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgUG9seS4oYml0cyA8IFN0ZGxpYi5JbnQ2NC56ZXJvKVxuOztcblxubGV0IGV4cG9uZW50X2JpdHMgPSAxMVxubGV0IG1hbnRpc3NhX2JpdHMgPSA1MlxubGV0IGV4cG9uZW50X21hc2s2NCA9IEludDY0LihzaGlmdF9sZWZ0IG9uZSBleHBvbmVudF9iaXRzIC0gb25lKVxubGV0IGV4cG9uZW50X21hc2sgPSBJbnQ2NC50b19pbnRfZXhuIGV4cG9uZW50X21hc2s2NFxubGV0IG1hbnRpc3NhX21hc2sgPSBJbnQ2My4oc2hpZnRfbGVmdCBvbmUgbWFudGlzc2FfYml0cyAtIG9uZSlcbmxldCBtYW50aXNzYV9tYXNrNjQgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYV9tYXNrXG5cbmxldCBpZWVlX2V4cG9uZW50IHQgPVxuICBsZXQgYml0cyA9IFN0ZGxpYi5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgSW50NjQuKGJpdF9hbmQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYml0cyBtYW50aXNzYV9iaXRzKSBleHBvbmVudF9tYXNrNjQpXG4gIHw+IFN0ZGxpYi5JbnQ2NC50b19pbnRcbjs7XG5cbmxldCBpZWVlX21hbnRpc3NhIHQgPVxuICBsZXQgYml0cyA9IFN0ZGxpYi5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgKCogVGhpcyBpcyBzYWZlIGJlY2F1c2UgbWFudGlzc2FfbWFzazY0IDwgSW50NjMubWF4X3ZhbHVlICopXG4gIChJbnQ2My5vZl9pbnQ2NF90cnVuYykgU3RkbGliLkludDY0Lihsb2dhbmQgYml0cyBtYW50aXNzYV9tYXNrNjQpXG47O1xuXG5sZXQgY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgaWYgSW50LihiaXRfYW5kIGV4cG9uZW50IGV4cG9uZW50X21hc2sgPD4gZXhwb25lbnQpXG4gIHRoZW4gZmFpbHdpdGhmIFwiZXhwb25lbnQgJWQgb3V0IG9mIHJhbmdlIFswLCAlZF1cIiBleHBvbmVudCBleHBvbmVudF9tYXNrICgpXG4gIGVsc2UgaWYgSW50NjMuKGJpdF9hbmQgbWFudGlzc2EgbWFudGlzc2FfbWFzayA8PiBtYW50aXNzYSlcbiAgdGhlblxuICAgIGZhaWx3aXRoZlxuICAgICAgXCJtYW50aXNzYSAlcyBvdXQgb2YgcmFuZ2UgWzAsICVzXVwiXG4gICAgICAoSW50NjMudG9fc3RyaW5nIG1hbnRpc3NhKVxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYV9tYXNrKVxuICAgICAgKClcbiAgZWxzZSAoXG4gICAgbGV0IHNpZ25fYml0cyA9IGlmIG5lZ2F0aXZlIHRoZW4gU3RkbGliLkludDY0Lm1pbl9pbnQgZWxzZSBTdGRsaWIuSW50NjQuemVybyBpblxuICAgIGxldCBleHB0X2JpdHMgPVxuICAgICAgU3RkbGliLkludDY0LnNoaWZ0X2xlZnQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQgZXhwb25lbnQpIG1hbnRpc3NhX2JpdHNcbiAgICBpblxuICAgIGxldCBtYW50X2JpdHMgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYSBpblxuICAgIGxldCBiaXRzID0gU3RkbGliLkludDY0Lihsb2dvciBzaWduX2JpdHMgKGxvZ29yIGV4cHRfYml0cyBtYW50X2JpdHMpKSBpblxuICAgIFN0ZGxpYi5JbnQ2NC5mbG9hdF9vZl9iaXRzIGJpdHMpXG47O1xuXG5sZXQgY3JlYXRlX2llZWUgfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EgPVxuICBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSlcbjs7XG5cbm1vZHVsZSBUZXJzZSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0X29mX3NleHAgPSB0X29mX3NleHBcbiAgbGV0IHRvX3N0cmluZyB4ID0gUHJpbnRmLnNwcmludGYgXCIlLjhHXCIgeFxuICBsZXQgc2V4cF9vZl90IHggPSBTZXhwLkF0b20gKHRvX3N0cmluZyB4KVxuICBsZXQgb2Zfc3RyaW5nIHggPSBvZl9zdHJpbmcgeFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxuKCogVGhlc2UgYXJlIHBhcnRseSBoZXJlIGFzIGEgcGVyZm9ybWFuY2UgaGFjayB0byBhdm9pZCBzb21lIGJveGluZyB3ZSdyZSBnZXR0aW5nIHdpdGhcbiAgIHRoZSB2ZXJzaW9ucyB3ZSBnZXQgZnJvbSBbV2l0aF96ZXJvXS4gIFRoZXkgYWxzbyBtYWtlIFtGbG9hdC5pc19uZWdhdGl2ZSBuYW5dIGFuZFxuICAgW0Zsb2F0LmlzX25vbl9wb3NpdGl2ZSBuYW5dIHJldHVybiBbZmFsc2VdOyB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10gcmV0dXJuXG4gICBbdHJ1ZV0uICopXG5sZXQgaXNfcG9zaXRpdmUgdCA9IHQgPiAwLlxubGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gdCA+PSAwLlxubGV0IGlzX25lZ2F0aXZlIHQgPSB0IDwgMC5cbmxldCBpc19ub25fcG9zaXRpdmUgdCA9IHQgPD0gMC5cblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRmxvYXRcIlxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgZW5kKVxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCAlICkgPSAoICUgKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludCA9IG9mX2ludFxuICBsZXQgb2ZfZmxvYXQgeCA9IHhcbmVuZFxuXG5tb2R1bGUgT19kb3QgPSBzdHJ1Y3RcbiAgbGV0ICggKi4gKSA9ICggKiApXG4gIGxldCAoICsuICkgPSAoICsgKVxuICBsZXQgKCAtLiApID0gKCAtIClcbiAgbGV0ICggLy4gKSA9ICggLyApXG4gIGxldCAoICUuICkgPSAoICUgKVxuICBsZXQgKCB+LS4gKSA9ICggfi0gKVxuICBsZXQgKCAqKi4gKSA9ICggKiogKVxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBib3ggPSBib3hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCA9IGNsYW1wX3VuY2hlY2tlZFxuICBsZXQgbG93ZXJfYm91bmRfZm9yX2ludCA9IGxvd2VyX2JvdW5kX2Zvcl9pbnRcbiAgbGV0IHVwcGVyX2JvdW5kX2Zvcl9pbnQgPSB1cHBlcl9ib3VuZF9mb3JfaW50XG4gIGxldCBzcGVjaWFsaXplZF9oYXNoID0gaGFzaF9mbG9hdFxuICBsZXQgb25lX3VscF9sZXNzX3RoYW5faGFsZiA9IG9uZV91bHBfbGVzc190aGFuX2hhbGZcbiAgbGV0IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuID0gaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG5cbiAgbGV0IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuID0gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG5cbiAgbGV0IGlyb3VuZF9uZWFyZXN0X2V4bl82NCA9IGlyb3VuZF9uZWFyZXN0X2V4bl82NFxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuKCogVGhlc2UgZnVuY3Rpb25zIHNwZWNpZmljYWxseSByZXBsYWNlIGRlZmF1bHRzIGluIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5cblxuICAgVGhlIGRlc2lyZWQgYmVoYXZpb3IgaGVyZSBpcyB0byBwcm9wYWdhdGUgYSBuYW4gaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5hbi4gQmVjYXVzZSB0aGVcbiAgIGZpcnN0IGNvbXBhcmlzb24gd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIGlmIGVpdGhlciBhcmd1bWVudCBpcyBuYW4sIGl0IHN1ZmZpY2VzIHRvXG4gICBjaGVjayBpZiB4IGlzIG5hbi4gVGhlbiwgd2hlbiB4IGlzIG5hbiBvciBib3RoIHggYW5kIHkgYXJlIG5hbiwgd2UgcmV0dXJuIHggPSBuYW47IGFuZFxuICAgd2hlbiB5IGlzIG5hbiBidXQgbm90IHgsIHdlIHJldHVybiB5ID0gbmFuLlxuXG4gICBUaGVyZSBhcmUgdmFyaW91cyB3YXlzIHRvIGltcGxlbWVudCB0aGVzZSBmdW5jdGlvbnMuICBUaGUgYmVuY2htYXJrIGJlbG93IHNob3dzIGEgZmV3XG4gICBkaWZmZXJlbnQgdmVyc2lvbnMuICBUaGlzIGJlbmNobWFyayB3YXMgcnVuIG92ZXIgYW4gYXJyYXkgb2YgcmFuZG9tIGZsb2F0cyAobm9uZSBvZlxuICAgd2hpY2ggYXJlIG5hbikuXG5cbiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAg4pSCIE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFRpbWUvUnVuIOKUglxuICAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICDilIIgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeSDilIIgICAyLjQydXMg4pSCXG4gICDilIIgaWYgaXNfbmFuIHggfHwgeCA8IHkgdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAyLjAydXMg4pSCXG4gICDilIIgaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjg4dXMg4pSCXG4gICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblxuICAgVGhlIGJlbmNobWFyayBiZWxvdyB3YXMgcnVuIHdoZW4geCA+IHkgaXMgYWx3YXlzIHRydWUgKGFnYWluLCBubyBuYW4gdmFsdWVzKS5cblxuICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICDilIIgTmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgVGltZS9SdW4g4pSCXG4gICDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgIOKUgiBpZiBpc19uYW4geCB0aGVuIHggZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5IOKUgiAgIDIuODN1cyDilIJcbiAgIOKUgiBpZiBpc19uYW4geCB8fCB4IDwgeSB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuOTd1cyDilIJcbiAgIOKUgiBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuNTZ1cyDilIJcbiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuKilcbmxldCBtaW4gKHggOiB0KSB5ID0gaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxubGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID4geSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzg0MDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9GaWVsZHNsaWIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGlCQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzg0MTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9CdWZmZXJfaW50ZiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsbUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozODQyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsNCIsImExIiwiYTIiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiQmFzZV9CeXRlcyIsIkJhc2VfSW1wb3J0IiwiU3RkbGliX0J1ZmZlciIsIkJhc2VfQmxpdCIsImNyZWF0ZSIsImNvbnRlbnRzIiwidG9fYnl0ZXMiLCJudGgiLCJsZW5ndGgiLCJjbGVhciIsInJlc2V0IiwiYWRkX2NoYXIiLCJhZGRfc3RyaW5nIiwiYWRkX2J5dGVzIiwiYWRkX2J1ZmZlciIsImFkZF9zdWJzdHJpbmciLCJ0IiwicyIsInBvcyIsImxlbiIsImFkZF9zdWJieXRlcyIsInNleHBfb2ZfdCIsImNhbWxfYnVmZmVyX2xlbmd0aCIsImNhbWxfYnVmZmVyX2JsaXQiLCJ1bnNhZmVfYmxpdCIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiVG9fYnl0ZXMiLCJibGl0IiwiYmxpdG8iLCJzdWIiLCJzdWJvIiwiVG9fc3RyaW5nIiwiQmFzZV9CdWZmZXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9idWZmZXIubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFLElBQUFDLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBQyxJQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxjQUFBQyxHQUFBQyxHQUFBQyxLQUFBQztBQUFBQSxJQ0trQyxzQ0FBeUI7QUFBQTtBQUFBLFlBQUFDLGFBQUFKLEdBQUFDLEdBQUFDLEtBQUFDO0FBQUFBLElBQzFCLHNDQUF3QjtBQUFBO0FBQUEsWUFBQUUsVUFBQUw7QUFBQUEsUUFBQSxNQUN4QjtBQUFBLElBQVk7QUFBQTtBQUFBO0FBQUEsSUFBQU0scUJEUDdDO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxZQUFBbkIsU0FBQWUsS0M2QndCLHNDQUFnQjtBQUFBLE9BQUFYLFdEN0J4QztBQUFBLFlBQUFnQixZQUFBQyxLQUFBQyxTQUFBQyxLQUFBQyxTQUFBVDtBQUFBQSxJQ2lDUSxvRUFBNEM7QUFBQTtBQUFBO0FBQUEsSUFBQVU7QUFBQUEsTURqQ3BEO0FBQUE7QUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQVAsZ0JBQUE7QUFBQSxJQUFBUSxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQnVmZmVyX2ludGZcbmluY2x1ZGUgU3RkbGliLkJ1ZmZlclxuXG5sZXQgY29udGVudHNfYnl0ZXMgPSB0b19ieXRlc1xubGV0IGFkZF9zdWJzdHJpbmcgdCBzIH5wb3MgfmxlbiA9IGFkZF9zdWJzdHJpbmcgdCBzIHBvcyBsZW5cbmxldCBhZGRfc3ViYnl0ZXMgdCBzIH5wb3MgfmxlbiA9IGFkZF9zdWJieXRlcyB0IHMgcG9zIGxlblxubGV0IHNleHBfb2ZfdCB0ID0gc2V4cF9vZl9zdHJpbmcgKGNvbnRlbnRzIHQpXG5cbmxldCBjYW1sX2J1ZmZlcl9sZW5ndGggPVxuICAoU3RkbGliLk9iai5tYWdpYyAoU3RkbGliLkJ1ZmZlci5sZW5ndGggOiB0IC0+IGludCkgOiAodFtAbG9jYWxdKSAtPiBpbnQpXG47O1xuXG5sZXQgY2FtbF9idWZmZXJfYmxpdCA9XG4gIChTdGRsaWIuT2JqLm1hZ2ljXG4gICAgIChTdGRsaWIuQnVmZmVyLmJsaXQgOiBTdGRsaWIuQnVmZmVyLnQgLT4gaW50IC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiB1bml0KVxuICAgOiAoU3RkbGliLkJ1ZmZlci50W0Bsb2NhbF0pIC0+IGludCAtPiAoQnl0ZXMudFtAbG9jYWxdKSAtPiBpbnQgLT4gaW50IC0+IHVuaXQpXG47O1xuXG5tb2R1bGUgVG9fYnl0ZXMgPVxuICBCbGl0Lk1ha2VfZGlzdGluY3RcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gY2FtbF9idWZmZXJfbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IEJ5dGVzLnRcblxuICAgICAgbGV0IGNyZWF0ZSB+bGVuID0gQnl0ZXMuY3JlYXRlIGxlblxuICAgICAgbGV0IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aFxuXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgICAgICBjYW1sX2J1ZmZlcl9ibGl0IHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuICAgICAgOztcbiAgICBlbmQpXG5cbmluY2x1ZGUgVG9fYnl0ZXNcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChTdGRsaWIuQnVmZmVyKSAoVG9fYnl0ZXMpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzg1MjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiZWxpZGVkX21lc3NhZ2UiLCJCYXNlX0V4biIsIkJhc2VfU3lzMCIsIkJhc2VfU3RyaW5nIiwiQmFzZV9MaXN0IiwiU3RkbGliX1ByaW50ZXhjIiwiQmFzZV9JbnQiLCJlbGlkZSIsImdldCIsIm9wdCIsInBhcmFtIiwiYXRfbW9zdF9udW1fZnJhbWVzIiwidG9fc3RyaW5nIiwidCIsInRvX3N0cmluZ19saXN0Iiwic2V4cF9vZl90IiwieCIsInNldF9yZWNvcmRpbmciLCJhbV9yZWNvcmRpbmciLCJjc3RfT0NBTUxSVU5QQVJBTSIsImNzdF9iIiwibW9zdF9yZWNlbnQiLCJtb3N0X3JlY2VudF9mb3JfZXhuIiwiZXhuIiwid2l0aF9yZWNvcmRpbmciLCJiIiwic2F2ZWQiLCJpbml0aWFsaXplX21vZHVsZSIsIm1hdGNoIiwib2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhIiwiQmFzZV9CYWNrdHJhY2UiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9iYWNrdHJhY2UubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsWUFBQUMsSUFBQUMsS0FBQUM7QUFBQUEsUUFBQUMscUJDUVE7QUFBQSxJQUNOLDZEQUFnRDtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUFJaEQsbUNBQW1DLGtDQUF5QztBQUFBO0FBQUEsWUFBQUMsZUFBQUQ7QUFBQUEsUUFBQSxNQUdwQztBQUFBLElBQWE7QUFBQTtBQUFBLFlBQUFFLFVBQUFGO0FBQUFBLFFBQUEsTUFDakI7QUFBQSxJQUFWLG1EQUFBRyxHQUEwQyxjQUFXLEdBQUU7QUFBQTtBQUFBO0FBQUEsSUFBQUMsZ0JEakJuRjtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyxZQUFBWCxPQ3NCdUIseUNBQW9DO0FBQUEsWUFBQVksb0JBQUFDO0FBQUFBLElBR3BELDJDQUE0QyxtQkFBMEI7QUFBQTtBQUFBLFlBQUFDLGVBQUFDLEdBQUE5QjtBQUFBQSxRQUFBK0IsUUFnQjdEO0FBQUEsSUFDWjtBQUFBLElBQWU7QUFBQTtBQUFBO0FBQUEsc0JBQUFoQixPQUNvQix1Q0FBbUIsR0FBQztBQUFBO0FBQUEsWUFBQWlCLGtCQUFBakI7QUFBQUEsUUFBQWtCLFFBWi9DO0FBQUEsSUFBMEI7QUFBQTtBQUFBLE1BQUFaLElBQUE7QUFBQSxZQUVwQjtBQUFBLFlBQVk7QUFBQSxNQUFBYTtBQUFBQSxRQUFaO0FBQUE7QUFBQTtBQUFBLHdCRGpDbEI7QUFBQTtBQUFBLFNBQUFBLGlDQ2dDZ0I7QUFBQSxjQUdaO0FBQUEsaUJBQThDLGtDQVlHO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EL0NyRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPSBTdGRsaWIuUHJpbnRleGMucmF3X2JhY2t0cmFjZVxuXG5sZXQgZWxpZGUgPSByZWYgZmFsc2VcbmxldCBlbGlkZWRfbWVzc2FnZSA9IFwiPGJhY2t0cmFjZSBlbGlkZWQgaW4gdGVzdD5cIlxuXG5sZXQgZ2V0ID8oYXRfbW9zdF9udW1fZnJhbWVzID0gSW50Lm1heF92YWx1ZSkgKCkgPVxuICBTdGRsaWIuUHJpbnRleGMuZ2V0X2NhbGxzdGFjayBhdF9tb3N0X251bV9mcmFtZXNcbjs7XG5cbmxldCB0b19zdHJpbmcgdCA9XG4gIGlmICFlbGlkZSB0aGVuIGVsaWRlZF9tZXNzYWdlIGVsc2UgU3RkbGliLlByaW50ZXhjLnJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHRcbjs7XG5cbmxldCB0b19zdHJpbmdfbGlzdCB0ID0gU3RyaW5nLnNwbGl0X2xpbmVzICh0b19zdHJpbmcgdClcbmxldCBzZXhwX29mX3QgdCA9IFNleHAuTGlzdCAoTGlzdC5tYXAgKHRvX3N0cmluZ19saXN0IHQpIH5mOihmdW4geCAtPiBTZXhwLkF0b20geCkpXG5cbm1vZHVsZSBFeG4gPSBzdHJ1Y3RcbiAgbGV0IHNldF9yZWNvcmRpbmcgPSBTdGRsaWIuUHJpbnRleGMucmVjb3JkX2JhY2t0cmFjZVxuICBsZXQgYW1fcmVjb3JkaW5nID0gU3RkbGliLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXNcbiAgbGV0IG1vc3RfcmVjZW50ICgpID0gU3RkbGliLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpXG5cbiAgbGV0IG1vc3RfcmVjZW50X2Zvcl9leG4gZXhuID1cbiAgICBpZiBFeG4uaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCBleG4gdGhlbiBTb21lIChtb3N0X3JlY2VudCAoKSkgZWxzZSBOb25lXG4gIDs7XG5cbiAgKCogV2UgdHVybiBvbiBiYWNrdHJhY2VzIGJ5IGRlZmF1bHQgaWYgT0NBTUxSVU5QQVJBTSBkb2Vzbid0IGV4cGxpY2l0bHkgbWVudGlvbiB0aGVtLiAqKVxuICBsZXQgbWF5YmVfc2V0X3JlY29yZGluZyAoKSA9XG4gICAgbGV0IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyA9XG4gICAgICBtYXRjaCBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgfCBTb21lIHggLT4gTGlzdC5leGlzdHMgKFN0cmluZy5zcGxpdCB4IH5vbjonLCcpIH5mOihTdHJpbmcuaXNfcHJlZml4IH5wcmVmaXg6XCJiXCIpXG4gICAgaW5cbiAgICBpZiBub3Qgb2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhY2VzIHRoZW4gc2V0X3JlY29yZGluZyB0cnVlXG4gIDs7XG5cbiAgKCogdGhlIGNhbGxlciBzZXQgc29tZXRoaW5nLCB0aGV5IGFyZSByZXNwb25zaWJsZSAqKVxuXG4gIGxldCB3aXRoX3JlY29yZGluZyBiIH5mID1cbiAgICBsZXQgc2F2ZWQgPSBhbV9yZWNvcmRpbmcgKCkgaW5cbiAgICBzZXRfcmVjb3JkaW5nIGI7XG4gICAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBzZXRfcmVjb3JkaW5nIHNhdmVkKVxuICA7O1xuZW5kXG5cbmxldCBpbml0aWFsaXplX21vZHVsZSAoKSA9IEV4bi5tYXliZV9zZXRfcmVjb3JkaW5nICgpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzg2MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiQmFzZV9SZWYiLCJCYXNlX09wdGlvbiIsIkJhc2VfTGlzdCIsIkJhc2VfQXJyYXkiLCJTaGFkb3dfc3RkbGliIiwiQmFzZV9TZXhwX3dpdGhfY29tcGFyYWJsZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9Cb29sIiwiQmFzZV9DaGFyIiwiQmFzZV9FeG4iLCJCYXNlX0Zsb2F0IiwiQmFzZV9JbnQiLCJCYXNlX0ludDMyIiwiQmFzZV9JbnQ2NCIsIkJhc2VfTmF0aXZlaW50IiwiQmFzZV9TdHJpbmciLCJCYXNlX0J5dGVzIiwiQmFzZV9Vbml0IiwiQmFzZV9FcnJvciIsIkJhc2VfQ29udGFpbmVyX2ludGYiLCJCYXNlX0JhY2t0cmFjZSIsIkV4aXQiLCJOb3RfZm91bmQiLCJtYXhfaW50IiwibWluX2ludCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbl9mbG9hdCIsImNoYXJfb2ZfaW50Iiwic3RyaW5nX29mX2Jvb2wiLCJib29sX29mX3N0cmluZ19vcHQiLCJib29sX29mX3N0cmluZyIsInN0cmluZ19vZl9pbnQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9mbG9hdCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnRfb3B0IiwicmVhZF9pbnQiLCJyZWFkX2Zsb2F0X29wdCIsInJlYWRfZmxvYXQiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsIm9wZW5fb3V0X2dlbiIsImZsdXNoIiwiZmx1c2hfYWxsIiwib3V0cHV0X2NoYXIiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0X2J5dGVzIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfdmFsdWUiLCJzZWVrX291dCIsInBvc19vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJzZXRfYmluYXJ5X21vZGVfb3V0Iiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwib3Blbl9pbl9nZW4iLCJpbnB1dF9jaGFyIiwiaW5wdXRfbGluZSIsImlucHV0IiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2J5dGUiLCJpbnB1dF9iaW5hcnlfaW50IiwiaW5wdXRfdmFsdWUiLCJzZWVrX2luIiwicG9zX2luIiwiaW5fY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9pbiIsImNsb3NlX2luX25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX2luIiwic3RyaW5nX29mX2Zvcm1hdCIsInN5bWJvbCIsImV4aXQiLCJhdF9leGl0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJ1bnNhZmVfcmVhbGx5X2lucHV0IiwiZG9fYXRfZXhpdCIsImRvX2RvbWFpbl9sb2NhbF9hdF9leGl0IiwiaGFzaF9mb2xkX3QiLCJoYXNoIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwiTm90X2ZvdW5kX3MiLCJPZl9zZXhwX2Vycm9yIiwibWVzc2FnZSIsImRlZmF1bHRfaW5kZW50IiwicHBfaHVtIiwicHBfaHVtX2luZGVudCIsInBwX21hY2giLCJwcCIsInRvX3N0cmluZ19odW0iLCJ0b19zdHJpbmdfbWFjaCIsInRvX3N0cmluZyIsIm9mX2Zsb2F0X3N0eWxlIiwib2ZfaW50X3N0eWxlIiwidF9zZXhwX2dyYW1tYXIiLCJpbnZhcmlhbnQiLCJvZl9zdHJpbmciLCJlcXVhbCIsImNvbXBhcmUiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsIlNleHAiLCJhbV90ZXN0aW5nIiwiRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMiLCJjb21wYXJlX2FycmF5IiwiZXF1YWxfYXJyYXkiLCJnbG9iYWxpemVfYXJyYXkiLCJhcnJheV9vZl9zZXhwIiwic2V4cF9vZl9hcnJheSIsImFycmF5X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9ib29sIiwiZXF1YWxfYm9vbCIsImdsb2JhbGl6ZV9ib29sIiwiaGFzaF9mb2xkX2Jvb2wiLCJmdW5jIiwiaGFzaF9ib29sIiwieCIsImJvb2xfb2Zfc2V4cCIsInNleHBfb2ZfYm9vbCIsImJvb2xfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9jaGFyIiwiZXF1YWxfY2hhciIsImdsb2JhbGl6ZV9jaGFyIiwiaGFzaF9mb2xkX2NoYXIiLCJoYXNoX2NoYXIiLCJjaGFyX29mX3NleHAiLCJzZXhwX29mX2NoYXIiLCJjaGFyX3NleHBfZ3JhbW1hciIsInNleHBfb2ZfZXhuIiwiY29tcGFyZV9mbG9hdCIsImVxdWFsX2Zsb2F0IiwiZ2xvYmFsaXplX2Zsb2F0IiwiaGFzaF9mb2xkX2Zsb2F0IiwiaGFzaF9mbG9hdCIsImZsb2F0X29mX3NleHAiLCJzZXhwX29mX2Zsb2F0IiwiZmxvYXRfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9pbnQiLCJlcXVhbF9pbnQiLCJnbG9iYWxpemVfaW50IiwiaGFzaF9mb2xkX2ludCIsImhhc2hfaW50IiwiaW50X29mX3NleHAiLCJzZXhwX29mX2ludCIsImludF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2ludDMyIiwiZXF1YWxfaW50MzIiLCJnbG9iYWxpemVfaW50MzIiLCJoYXNoX2ZvbGRfaW50MzIiLCJoYXNoX2ludDMyIiwiaW50MzJfb2Zfc2V4cCIsInNleHBfb2ZfaW50MzIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2ludDY0IiwiZXF1YWxfaW50NjQiLCJnbG9iYWxpemVfaW50NjQiLCJoYXNoX2ZvbGRfaW50NjQiLCJoYXNoX2ludDY0IiwiaW50NjRfb2Zfc2V4cCIsInNleHBfb2ZfaW50NjQiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2xpc3QiLCJlcXVhbF9saXN0IiwiZ2xvYmFsaXplX2xpc3QiLCJoYXNoX2ZvbGRfbGlzdCIsImxpc3Rfb2Zfc2V4cCIsInNleHBfb2ZfbGlzdCIsImxpc3Rfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9uYXRpdmVpbnQiLCJlcXVhbF9uYXRpdmVpbnQiLCJnbG9iYWxpemVfbmF0aXZlaW50IiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfbmF0aXZlaW50IiwibmF0aXZlaW50X29mX3NleHAiLCJzZXhwX29mX25hdGl2ZWludCIsIm5hdGl2ZWludF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX29wdGlvbiIsImVxdWFsX29wdGlvbiIsImdsb2JhbGl6ZV9vcHRpb24iLCJoYXNoX2ZvbGRfb3B0aW9uIiwib3B0aW9uX29mX3NleHAiLCJzZXhwX29mX29wdGlvbiIsIm9wdGlvbl9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX3JlZiIsImVxdWFsX3JlZiIsImdsb2JhbGl6ZV9yZWYiLCJyZWZfb2Zfc2V4cCIsInNleHBfb2ZfcmVmIiwicmVmX3NleHBfZ3JhbW1hciIsImNvbXBhcmVfc3RyaW5nIiwiZXF1YWxfc3RyaW5nIiwiZ2xvYmFsaXplX3N0cmluZyIsImhhc2hfZm9sZF9zdHJpbmciLCJoYXNoX3N0cmluZyIsInN0cmluZ19vZl9zZXhwIiwic2V4cF9vZl9zdHJpbmciLCJzdHJpbmdfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9ieXRlcyIsImVxdWFsX2J5dGVzIiwiZ2xvYmFsaXplX2J5dGVzIiwiYnl0ZXNfb2Zfc2V4cCIsInNleHBfb2ZfYnl0ZXMiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJjb21wYXJlX3VuaXQiLCJlcXVhbF91bml0IiwiZ2xvYmFsaXplX3VuaXQiLCJoYXNoX2ZvbGRfdW5pdCIsImhhc2hfdW5pdCIsInVuaXRfb2Zfc2V4cCIsInNleHBfb2ZfdW5pdCIsInVuaXRfc2V4cF9ncmFtbWFyIiwibG5vdCIsImFicyIsInplcm8iLCJpbmNsdWRlIiwic3ltYm9sX2NvbmNhdCIsImZzdCIsInNuZCIsImZhaWx3aXRoIiwiaW52YWxpZF9hcmciLCJyYWlzZV9zIiwiRXhwb3J0IiwiQ29udGludWVfb3Jfc3RvcCIsIkJhc2UiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYmFzZS9iYXNlLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBMUIsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQTJCLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsWUFBQUMsbUJBQUFDO0FBQUFBLElDb040QixnREFBcUM7QUFBQTtBQUFBO0FBQUEsSUFBQUMsZURwTmpFO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsWUFBQUMsVUFBQUMsR0MwT2EsMEJBQU07QUFBQTtBQUFBLElBQUFDLGVBQWY7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBVCxTQUFBO0FBQUEsWUFBQVUsVUFBQVIsR0EwQlMsNEJBQU07QUFBQTtBQUFBLElBQUFTLGVBQWY7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFsQixTQUFBO0FBQUEsWUFBQW1CLFdBQUFqQixHQWdDUyw0QkFBTTtBQUFBO0FBQUEsSUFBQWtCLGdCQUFmO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUExQixTQUFBO0FBQUEsWUFBQTJCLFNBQUF6QixHQXVCUyw0QkFBTTtBQUFBO0FBQUEsSUFBQTBCLGNBQWY7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQWxDLFNBQUE7QUFBQSxZQUFBbUMsV0FBQWpDLEdBMEJTLDRCQUFNO0FBQUE7QUFBQSxJQUFBa0MsZ0JBQWY7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUExQyxTQUFBO0FBQUEsWUFBQTJDLFdBQUF6QyxHQTBCUyw0QkFBTTtBQUFBO0FBQUEsSUFBQTBDLGdCQUFmO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsa0JBQUExRDtBQUFBQSxJQTZDd0IsK0NBQW9DO0FBQUE7QUFBQTtBQUFBLElBQUEyRCxvQkE3QzVEO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQXpELFNBQUE7QUFBQSxZQUFBMEQsZUFBQXhELEdBbUVTLDRCQUFNO0FBQUE7QUFBQSxJQUFBeUQsb0JBQWY7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxvQkFBQXpFO0FBQUFBLElBcUR3QixpREFBc0M7QUFBQTtBQUFBO0FBQUEsSUFBQTBFLGNBckQ5RDtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsWUFBQUMsaUJBQUEvRTtBQUFBQSxJQStFd0IsOENBQW1DO0FBQUE7QUFBQTtBQUFBLElBQUFnRixpQkEvRTNEO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxZQUFBQyxZQUFBN0UsR0FxR1Msa0NBQU07QUFBQTtBQUFBLElBQUE4RSxpQkFBZjtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUE1RixTQUFBO0FBQUEsWUFBQTZGLFVBQUEzRixHQXlDUyw0QkFBTTtBQUFBO0FBQUEsSUFBQTRGLGVBQWY7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBbkosV0FBQTtBQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFvSixPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBdEosV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUE7QUFBQSxJQUFBK0IsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBRixRQUFBO0FBQUEsSUFBQUQsUUFBQTtBQUFBLElBQUEwSCxVQUFBO0FBQUEsSUFBQXZKLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBd0osZ0JBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUF0SCxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBRSxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUUsY0FBQTtBQUFBLElBQUFFLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFuSixZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFvSixTQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBdEosWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQStCLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUYsUUFBQTtBQUFBLElBQUFELFFBQUE7QUFBQSxJQUFBN0IsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUF3SixrQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFOLFlBQUE7QUFBQSxJQUFBUSxtQkFBQTtBQUFBLElBQUFwSixnQkFBQTtBQUFBLEdBd0ZLO0FBQUE7QUFBQSxJQUFBcUo7QUFBQUEsTUFBOEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR4cEJ2QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqIFRoaXMgbW9kdWxlIGlzIHRoZSB0b3BsZXZlbCBvZiB0aGUgQmFzZSBsaWJyYXJ5OyBpdCdzIHdoYXQgeW91IGdldCB3aGVuIHlvdSB3cml0ZVxuICAgIFtvcGVuIEJhc2VdLlxuXG4gICAgVGhlIGdvYWwgb2YgQmFzZSBpcyBib3RoIHRvIGJlIGEgbW9yZSBjb21wbGV0ZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIHJpY2hlciBBUElzLFxuICAgIGFuZCB0byBiZSBtb3JlIGNvbnNpc3RlbnQgaW4gaXRzIGRlc2lnbi4gRm9yIGluc3RhbmNlLCBpbiB0aGUgc3RhbmRhcmQgbGlicmFyeVxuICAgIHNvbWUgdGhpbmdzIGhhdmUgbW9kdWxlcyBhbmQgb3RoZXJzIGRvbid0OyBpbiBCYXNlLCBldmVyeXRoaW5nIGlzIGEgbW9kdWxlLlxuXG4gICAgQmFzZSBleHRlbmRzIHNvbWUgbW9kdWxlcyBhbmQgZGF0YSBzdHJ1Y3R1cmVzIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIGxpa2UgW0FycmF5XSxcbiAgICBbQnVmZmVyXSwgW0J5dGVzXSwgW0NoYXJdLCBbSGFzaHRibF0sIFtJbnQzMl0sIFtJbnQ2NF0sIFtMYXp5XSwgW0xpc3RdLCBbTWFwXSxcbiAgICBbTmF0aXZlaW50XSwgW1ByaW50Zl0sIFtSYW5kb21dLCBbU2V0XSwgW1N0cmluZ10sIFtTeXNdLCBhbmQgW1VjaGFyXS4gT25lIGtleVxuICAgIGRpZmZlcmVuY2UgaXMgdGhhdCBCYXNlIGRvZXNuJ3QgdXNlIGV4Y2VwdGlvbnMgYXMgbXVjaCBhcyB0aGUgc3RhbmRhcmQgbGlicmFyeSBhbmRcbiAgICBpbnN0ZWFkIG1ha2VzIGhlYXZ5IHVzZSBvZiB0aGUgW1Jlc3VsdF0gdHlwZSwgYXMgaW46XG5cbiAgICB7WyB0eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYiBdfVxuXG4gICAgQmFzZSBhbHNvIGFkZHMgZW50aXJlbHkgbmV3IG1vZHVsZXMsIG1vc3Qgbm90YWJseTpcblxuICAgIC0gW0NvbXBhcmFibGVdLCBbQ29tcGFyYXRvcl0sIGFuZCBbQ29tcGFyaXNvbnNdIGluIGxpZXUgb2YgcG9seW1vcnBoaWMgY29tcGFyZS5cbiAgICAtIFtDb250YWluZXJdLCB3aGljaCBwcm92aWRlcyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGFjcm9zcyBjb250YWluZXItbGlrZSBkYXRhXG4gICAgICBzdHJ1Y3R1cmVzIChhcnJheXMsIGxpc3RzLCBzdHJpbmdzKS5cbiAgICAtIFtSZXN1bHRdLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSwgc3VwcG9ydGluZyB0aGUgb3ItZXJyb3IgcGF0dGVybi5cbiopXG5cbigqXyBXZSBoaWRlIHRoaXMgZnJvbSB0aGUgd2ViIGRvY3MgYmVjYXVzZSB0aGUgbGluZSB3cmFwcGluZyBpcyBiYWQsIG1ha2luZyBpdFxuICBwcmV0dHkgbXVjaCBpbnNjcnV0YWJsZS4gKilcbigqKi8qKilcblxuKCogVGhlIGludGVudCBpcyB0byBzaGFkb3cgYWxsIG9mIElOUklBJ3Mgc3RhbmRhcmQgbGlicmFyeS4gIE1vZHVsZXMgYmVsb3cgd291bGQgY2F1c2VcbiAgIGNvbXBpbGF0aW9uIGVycm9ycyB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbSBbU2hhZG93X3N0ZGxpYl0gYmVmb3JlIGluY2x1c2lvbi4gKilcblxuaW5jbHVkZSAoXG4gIFNoYWRvd19zdGRsaWIgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICBlbmRcbiAgKCogTW9kdWxlcyBkZWZpbmVkIGluIEJhc2UgKilcbiAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICB3aXRoIG1vZHVsZSBBdG9taWMgOj0gU2hhZG93X3N0ZGxpYi5BdG9taWNcbiAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gIHdpdGggbW9kdWxlIEJ5dGVzIDo9IFNoYWRvd19zdGRsaWIuQnl0ZXNcbiAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gIHdpdGggbW9kdWxlIEZsb2F0IDo9IFNoYWRvd19zdGRsaWIuRmxvYXRcbiAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgd2l0aCBtb2R1bGUgSW5fY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLkluX2NoYW5uZWxcbiAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gIHdpdGggbW9kdWxlIEludDMyIDo9IFNoYWRvd19zdGRsaWIuSW50MzJcbiAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICB3aXRoIG1vZHVsZSBMaXN0IDo9IFNoYWRvd19zdGRsaWIuTGlzdFxuICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gIHdpdGggbW9kdWxlIE9wdGlvbiA6PSBTaGFkb3dfc3RkbGliLk9wdGlvblxuICB3aXRoIG1vZHVsZSBPdXRfY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLk91dF9jaGFubmVsXG4gIHdpdGggbW9kdWxlIFByaW50ZiA6PSBTaGFkb3dfc3RkbGliLlByaW50ZlxuICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICB3aXRoIG1vZHVsZSBSZXN1bHQgOj0gU2hhZG93X3N0ZGxpYi5SZXN1bHRcbiAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgd2l0aCBtb2R1bGUgU3RyaW5nIDo9IFNoYWRvd19zdGRsaWIuU3RyaW5nXG4gIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gIHdpdGggbW9kdWxlIFVuaXQgOj0gU2hhZG93X3N0ZGxpYi5Vbml0XG4gICgqIFN1cHBvcnQgZm9yIGdlbmVyYXRlZCBsZXhlcnMgKilcbiAgd2l0aCBtb2R1bGUgTGV4aW5nIDo9IFNoYWRvd19zdGRsaWIuTGV4aW5nXG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0IDo9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA6PSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDRcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gIHdpdGggdHlwZSAnYSByZWYgOj0gJ2EgcmVmKVxuICBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiovKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmVcbm1vZHVsZSBBcnJheSA9IEFycmF5XG5tb2R1bGUgQXZsdHJlZSA9IEF2bHRyZWVcbm1vZHVsZSBCYWNrdHJhY2UgPSBCYWNrdHJhY2Vcbm1vZHVsZSBCaW5hcnlfc2VhcmNoID0gQmluYXJ5X3NlYXJjaFxubW9kdWxlIEJpbmFyeV9zZWFyY2hhYmxlID0gQmluYXJ5X3NlYXJjaGFibGVcbm1vZHVsZSBCbGl0ID0gQmxpdFxubW9kdWxlIEJvb2wgPSBCb29sXG5tb2R1bGUgQnVmZmVyID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgPSBCeXRlc1xubW9kdWxlIENoYXIgPSBDaGFyXG5tb2R1bGUgQ29tcGFyYWJsZSA9IENvbXBhcmFibGVcbm1vZHVsZSBDb21wYXJhdG9yID0gQ29tcGFyYXRvclxubW9kdWxlIENvbXBhcmlzb25zID0gQ29tcGFyaXNvbnNcbm1vZHVsZSBDb250YWluZXIgPSBDb250YWluZXJcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXJcbm1vZHVsZSBFcXVhbCA9IEVxdWFsXG5tb2R1bGUgRXJyb3IgPSBFcnJvclxubW9kdWxlIEV4biA9IEV4blxubW9kdWxlIEZpZWxkID0gRmllbGRcbm1vZHVsZSBGbG9hdCA9IEZsb2F0XG5tb2R1bGUgRmxvYXRhYmxlID0gRmxvYXRhYmxlXG5tb2R1bGUgRm4gPSBGblxubW9kdWxlIEZvcm1hdHRlciA9IEZvcm1hdHRlclxubW9kdWxlIEhhc2ggPSBIYXNoXG5tb2R1bGUgSGFzaF9zZXQgPSBIYXNoX3NldFxubW9kdWxlIEhhc2hhYmxlID0gSGFzaGFibGVcbm1vZHVsZSBIYXNoZXIgPSBIYXNoZXJcbm1vZHVsZSBIYXNodGJsID0gSGFzaHRibFxubW9kdWxlIElkZW50aWZpYWJsZSA9IElkZW50aWZpYWJsZVxubW9kdWxlIEluZGV4ZWRfY29udGFpbmVyID0gSW5kZXhlZF9jb250YWluZXJcbm1vZHVsZSBJbmZvID0gSW5mb1xubW9kdWxlIEludCA9IEludFxubW9kdWxlIEludF9jb252ZXJzaW9ucyA9IEludF9jb252ZXJzaW9uc1xubW9kdWxlIEludDMyID0gSW50MzJcbm1vZHVsZSBJbnQ2MyA9IEludDYzXG5tb2R1bGUgSW50NjQgPSBJbnQ2NFxubW9kdWxlIEludGFibGUgPSBJbnRhYmxlXG5tb2R1bGUgSW50X21hdGggPSBJbnRfbWF0aFxubW9kdWxlIEludmFyaWFudCA9IEludmFyaWFudFxubW9kdWxlIExhenkgPSBMYXp5XG5tb2R1bGUgTGlzdCA9IExpc3Rcbm1vZHVsZSBNYXAgPSBNYXBcbm1vZHVsZSBNYXliZV9ib3VuZCA9IE1heWJlX2JvdW5kXG5tb2R1bGUgTW9uYWQgPSBNb25hZFxubW9kdWxlIE5hdGl2ZWludCA9IE5hdGl2ZWludFxubW9kdWxlIE5vdGhpbmcgPSBOb3RoaW5nXG5tb2R1bGUgT3B0aW9uID0gT3B0aW9uXG5tb2R1bGUgT3B0aW9uX2FycmF5ID0gT3B0aW9uX2FycmF5XG5tb2R1bGUgT3JfZXJyb3IgPSBPcl9lcnJvclxubW9kdWxlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24gPSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uXG5tb2R1bGUgT3JkZXJpbmcgPSBPcmRlcmluZ1xubW9kdWxlIFBvbHkgPSBQb2x5XG5cbm1vZHVsZSBQb3Bjb3VudCA9IFBvcGNvdW50XG5bQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTgtMTBdIHVzZSBbcG9wY291bnRdIGZ1bmN0aW9ucyBpbiB0aGUgaW5kaXZpZHVhbCBpbnQgbW9kdWxlc1wiXVxuXG5tb2R1bGUgUHJldHR5X3ByaW50ZXIgPSBQcmV0dHlfcHJpbnRlclxubW9kdWxlIFByaW50ZiA9IFByaW50ZlxubW9kdWxlIExpbmtlZF9xdWV1ZSA9IExpbmtlZF9xdWV1ZVxubW9kdWxlIFF1ZXVlID0gUXVldWVcbm1vZHVsZSBSYW5kb20gPSBSYW5kb21cbm1vZHVsZSBSZWYgPSBSZWZcbm1vZHVsZSBSZXN1bHQgPSBSZXN1bHRcbm1vZHVsZSBTZXF1ZW5jZSA9IFNlcXVlbmNlXG5tb2R1bGUgU2V0ID0gU2V0XG5tb2R1bGUgU2V4cGFibGUgPSBTZXhwYWJsZVxubW9kdWxlIFNpZ24gPSBTaWduXG5tb2R1bGUgU2lnbl9vcl9uYW4gPSBTaWduX29yX25hblxubW9kdWxlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uID0gU291cmNlX2NvZGVfcG9zaXRpb25cbm1vZHVsZSBTdGFjayA9IFN0YWNrXG5tb2R1bGUgU3RhZ2VkID0gU3RhZ2VkXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nYWJsZSA9IFN0cmluZ2FibGVcbm1vZHVsZSBTeXMgPSBTeXNcbm1vZHVsZSBUID0gVFxubW9kdWxlIFR5cGVfZXF1YWwgPSBUeXBlX2VxdWFsXG5tb2R1bGUgVW5pZm9ybV9hcnJheSA9IFVuaWZvcm1fYXJyYXlcbm1vZHVsZSBVbml0ID0gVW5pdFxubW9kdWxlIFVjaGFyID0gVWNoYXJcbm1vZHVsZSBWYXJpYW50ID0gVmFyaWFudFxubW9kdWxlIFdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm5cbm1vZHVsZSBXb3JkX3NpemUgPSBXb3JkX3NpemVcblxuKCogQXZvaWQgYSBsZXZlbCBvZiBpbmRpcmVjdGlvbiBmb3IgdXNlcyBvZiB0aGUgc2lnbmF0dXJlcyBkZWZpbmVkIGluIFtUXS4gKilcbmluY2x1ZGUgVFxuXG4oKiBUaGlzIGlzIGEgaGFjayBzbyB0aGF0IG9kb2MgY3JlYXRlcyBiZXR0ZXIgZG9jdW1lbnRhdGlvbi4gKilcbm1vZHVsZSBTZXhwID0gc3RydWN0XG4gIGluY2x1ZGUgU2V4cF93aXRoX2NvbXBhcmFibGUgKCoqIEBpbmxpbmUgKilcbmVuZFxuXG4oKiovKiopXG5cbm1vZHVsZSBFeHBvcnRlZF9mb3Jfc3BlY2lmaWNfdXNlcyA9IHN0cnVjdFxuICBtb2R1bGUgRmllbGRzbGliID0gRmllbGRzbGliXG4gIG1vZHVsZSBHbG9iYWxpemUgPSBHbG9iYWxpemVcbiAgbW9kdWxlIE9ial9sb2NhbCA9IE9ial9sb2NhbFxuICBtb2R1bGUgUHB4X2NvbXBhcmVfbGliID0gUHB4X2NvbXBhcmVfbGliXG4gIG1vZHVsZSBQcHhfZW51bWVyYXRlX2xpYiA9IFBweF9lbnVtZXJhdGVfbGliXG4gIG1vZHVsZSBQcHhfaGFzaF9saWIgPSBQcHhfaGFzaF9saWJcbiAgbW9kdWxlIFZhcmlhbnRzbGliID0gVmFyaWFudHNsaWJcblxuICBsZXQgYW1fdGVzdGluZyA9IGFtX3Rlc3RpbmdcbmVuZFxuXG4oKiovKiopXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgKCogW2Rlcml2aW5nIGhhc2hdIGlzIG1pc3NpbmcgZm9yIFthcnJheV0gYW5kIFtyZWZdIHNpbmNlIHRoZXNlIHR5cGVzIGFyZSBtdXRhYmxlLiAqKVxuICB0eXBlICdhIGFycmF5ID0gJ2EgQXJyYXkudFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGludCA9IEFycmF5LmNvbXBhcmVcbiAgbGV0IGVxdWFsX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBib29sID0gQXJyYXkuZXF1YWxcblxuICBsZXQgZ2xvYmFsaXplX2FycmF5IDpcbiAgICAnYS4gKCgnYVtAb2NhbWwubG9jYWxdKSAtPiAnYSkgLT4gKCdhIGFycmF5W0BvY2FtbC5sb2NhbF0pIC0+ICdhIGFycmF5XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wMDlfKVxuICAgICAgICA6ICAoKChhX18wMDlfW0BvY2FtbC5sb2NhbF0pIC0+IGFfXzAwOV8pIC0+IChhX18wMDlfIGFycmF5W0BvY2FtbC5sb2NhbF0pXG4gICAgICAgICAgICAtPiBhX18wMDlfIGFycmF5KSAtPlxuICAgICAgQXJyYXkuZ2xvYmFsaXplXG4gIDs7XG5cbiAgbGV0IGFycmF5X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIGFycmF5ID1cbiAgICBBcnJheS50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9hcnJheSA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBhcnJheSAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIEFycmF5LnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBhcnJheV9zZXhwX2dyYW1tYXIgOlxuICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBhcnJheSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBBcnJheS50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJvb2wgPSBCb29sLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9ib29sID0gKEJvb2wuY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQpXG4gIGxldCBlcXVhbF9ib29sID0gKEJvb2wuZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbClcblxuICBsZXQgKGdsb2JhbGl6ZV9ib29sIDogKGJvb2xbQG9jYW1sLmxvY2FsXSkgLT4gYm9vbCkgPVxuICAgIChCb29sLmdsb2JhbGl6ZSA6IChib29sW0BvY2FtbC5sb2NhbF0pIC0+IGJvb2wpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfYm9vbCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYm9vbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEJvb2wuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfYm9vbCA6IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEJvb2wuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBib29sX29mX3NleHAgPSAoQm9vbC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gYm9vbClcbiAgbGV0IHNleHBfb2ZfYm9vbCA9IChCb29sLnNleHBfb2ZfdCA6IGJvb2wgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJvb2xfc2V4cF9ncmFtbWFyIDogYm9vbCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBCb29sLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGNoYXIgPSBDaGFyLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9jaGFyID0gKENoYXIuY29tcGFyZSA6IGNoYXIgLT4gY2hhciAtPiBpbnQpXG4gIGxldCBlcXVhbF9jaGFyID0gKENoYXIuZXF1YWwgOiBjaGFyIC0+IGNoYXIgLT4gYm9vbClcblxuICBsZXQgKGdsb2JhbGl6ZV9jaGFyIDogKGNoYXJbQG9jYW1sLmxvY2FsXSkgLT4gY2hhcikgPVxuICAgIChDaGFyLmdsb2JhbGl6ZSA6IChjaGFyW0BvY2FtbC5sb2NhbF0pIC0+IGNoYXIpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfY2hhciA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gY2hhciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIENoYXIuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfY2hhciA6IGNoYXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IENoYXIuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBjaGFyX29mX3NleHAgPSAoQ2hhci50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gY2hhcilcbiAgbGV0IHNleHBfb2ZfY2hhciA9IChDaGFyLnNleHBfb2ZfdCA6IGNoYXIgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGNoYXJfc2V4cF9ncmFtbWFyIDogY2hhciBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBDaGFyLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGV4biA9IEV4bi50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX2V4biA9IChFeG4uc2V4cF9vZl90IDogZXhuIC0+IFNleHBsaWIwLlNleHAudClcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgZmxvYXQgPSBGbG9hdC50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfZmxvYXQgPSAoRmxvYXQuY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludClcbiAgbGV0IGVxdWFsX2Zsb2F0ID0gKEZsb2F0LmVxdWFsIDogZmxvYXQgLT4gZmxvYXQgLT4gYm9vbClcblxuICBsZXQgKGdsb2JhbGl6ZV9mbG9hdCA6IChmbG9hdFtAb2NhbWwubG9jYWxdKSAtPiBmbG9hdCkgPVxuICAgIChGbG9hdC5nbG9iYWxpemUgOiAoZmxvYXRbQG9jYW1sLmxvY2FsXSkgLT4gZmxvYXQpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfZmxvYXQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGZsb2F0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgRmxvYXQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfZmxvYXQgOiBmbG9hdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gRmxvYXQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBmbG9hdF9vZl9zZXhwID0gKEZsb2F0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBmbG9hdClcbiAgbGV0IHNleHBfb2ZfZmxvYXQgPSAoRmxvYXQuc2V4cF9vZl90IDogZmxvYXQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGZsb2F0X3NleHBfZ3JhbW1hciA6IGZsb2F0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEZsb2F0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludCA9IEludC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50ID0gKEludC5jb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQgPSAoSW50LmVxdWFsIDogaW50IC0+IGludCAtPiBib29sKVxuXG4gIGxldCAoZ2xvYmFsaXplX2ludCA6IChpbnRbQG9jYW1sLmxvY2FsXSkgLT4gaW50KSA9XG4gICAgKEludC5nbG9iYWxpemUgOiAoaW50W0BvY2FtbC5sb2NhbF0pIC0+IGludClcbiAgOztcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIEludC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQgOiBpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludF9vZl9zZXhwID0gKEludC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50KVxuICBsZXQgc2V4cF9vZl9pbnQgPSAoSW50LnNleHBfb2ZfdCA6IGludCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50X3NleHBfZ3JhbW1hciA6IGludCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50MzIgPSBJbnQzMi50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50MzIgPSAoSW50MzIuY29tcGFyZSA6IGludDMyIC0+IGludDMyIC0+IGludClcbiAgbGV0IGVxdWFsX2ludDMyID0gKEludDMyLmVxdWFsIDogaW50MzIgLT4gaW50MzIgLT4gYm9vbClcblxuICBsZXQgKGdsb2JhbGl6ZV9pbnQzMiA6IChpbnQzMltAb2NhbWwubG9jYWxdKSAtPiBpbnQzMikgPVxuICAgIChJbnQzMi5nbG9iYWxpemUgOiAoaW50MzJbQG9jYW1sLmxvY2FsXSkgLT4gaW50MzIpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50MzIgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludDMyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgSW50MzIuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50MzIgOiBpbnQzMiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50MzIuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnQzMl9vZl9zZXhwID0gKEludDMyLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQzMilcbiAgbGV0IHNleHBfb2ZfaW50MzIgPSAoSW50MzIuc2V4cF9vZl90IDogaW50MzIgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludDMyX3NleHBfZ3JhbW1hciA6IGludDMyIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludDMyLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludDY0ID0gSW50NjQudFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludDY0ID0gKEludDY0LmNvbXBhcmUgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQ2NCA9IChJbnQ2NC5lcXVhbCA6IGludDY0IC0+IGludDY0IC0+IGJvb2wpXG5cbiAgbGV0IChnbG9iYWxpemVfaW50NjQgOiAoaW50NjRbQG9jYW1sLmxvY2FsXSkgLT4gaW50NjQpID1cbiAgICAoSW50NjQuZ2xvYmFsaXplIDogKGludDY0W0BvY2FtbC5sb2NhbF0pIC0+IGludDY0KVxuICA7O1xuXG4gIGxldCAoaGFzaF9mb2xkX2ludDY0IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQ2NCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEludDY0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludDY0IDogaW50NjQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludDY0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50NjRfb2Zfc2V4cCA9IChJbnQ2NC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50NjQpXG4gIGxldCBzZXhwX29mX2ludDY0ID0gKEludDY0LnNleHBfb2ZfdCA6IGludDY0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnQ2NF9zZXhwX2dyYW1tYXIgOiBpbnQ2NCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQ2NC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSBsaXN0ID0gJ2EgTGlzdC50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gaW50ID0gTGlzdC5jb21wYXJlXG4gIGxldCBlcXVhbF9saXN0IDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gYm9vbCA9IExpc3QuZXF1YWxcblxuICBsZXQgZ2xvYmFsaXplX2xpc3QgOlxuICAgICdhLiAoKCdhW0BvY2FtbC5sb2NhbF0pIC0+ICdhKSAtPiAoJ2EgbGlzdFtAb2NhbWwubG9jYWxdKSAtPiAnYSBsaXN0XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNjJfKVxuICAgICAgICA6ICAoKChhX18wNjJfW0BvY2FtbC5sb2NhbF0pIC0+IGFfXzA2Ml8pIC0+IChhX18wNjJfIGxpc3RbQG9jYW1sLmxvY2FsXSlcbiAgICAgICAgICAgIC0+IGFfXzA2Ml8gbGlzdCkgLT5cbiAgICAgIExpc3QuZ2xvYmFsaXplXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9saXN0IDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSBsaXN0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIExpc3QuaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgbGlzdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBsaXN0ID1cbiAgICBMaXN0LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2xpc3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgbGlzdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIExpc3Quc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGxpc3Rfc2V4cF9ncmFtbWFyIDpcbiAgICAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgbGlzdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBMaXN0LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgbmF0aXZlaW50ID0gTmF0aXZlaW50LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LmNvbXBhcmUgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGludClcbiAgbGV0IGVxdWFsX25hdGl2ZWludCA9IChOYXRpdmVpbnQuZXF1YWwgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGJvb2wpXG5cbiAgbGV0IChnbG9iYWxpemVfbmF0aXZlaW50IDogKG5hdGl2ZWludFtAb2NhbWwubG9jYWxdKSAtPiBuYXRpdmVpbnQpID1cbiAgICAoTmF0aXZlaW50Lmdsb2JhbGl6ZSA6IChuYXRpdmVpbnRbQG9jYW1sLmxvY2FsXSkgLT4gbmF0aXZlaW50KVxuICA7O1xuXG4gIGxldCAoaGFzaF9mb2xkX25hdGl2ZWludCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gbmF0aXZlaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgTmF0aXZlaW50Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gTmF0aXZlaW50Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgbmF0aXZlaW50X29mX3NleHAgPSAoTmF0aXZlaW50LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBuYXRpdmVpbnQpXG4gIGxldCBzZXhwX29mX25hdGl2ZWludCA9IChOYXRpdmVpbnQuc2V4cF9vZl90IDogbmF0aXZlaW50IC0+IFNleHBsaWIwLlNleHAudClcblxuICBsZXQgKG5hdGl2ZWludF9zZXhwX2dyYW1tYXIgOiBuYXRpdmVpbnQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBOYXRpdmVpbnQudF9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2Egb3B0aW9uID0gJ2EgT3B0aW9uLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBpbnQgPVxuICAgIE9wdGlvbi5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBib29sID1cbiAgICBPcHRpb24uZXF1YWxcbiAgOztcblxuICBsZXQgZ2xvYmFsaXplX29wdGlvbiA6XG4gICAgJ2EuICgoJ2FbQG9jYW1sLmxvY2FsXSkgLT4gJ2EpIC0+ICgnYSBvcHRpb25bQG9jYW1sLmxvY2FsXSkgLT4gJ2Egb3B0aW9uXG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wODVfKVxuICAgICAgICA6ICAoKChhX18wODVfW0BvY2FtbC5sb2NhbF0pIC0+IGFfXzA4NV8pIC0+IChhX18wODVfIG9wdGlvbltAb2NhbWwubG9jYWxdKVxuICAgICAgICAgICAgLT4gYV9fMDg1XyBvcHRpb24pIC0+XG4gICAgICBPcHRpb24uZ2xvYmFsaXplXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9vcHRpb24gOlxuICAgICdhLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+ICdhIG9wdGlvblxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBPcHRpb24uaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgb3B0aW9uX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIG9wdGlvbiA9XG4gICAgT3B0aW9uLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX29wdGlvbiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBvcHRpb24gLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBPcHRpb24uc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IG9wdGlvbl9zZXhwX2dyYW1tYXIgOlxuICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBvcHRpb24gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gT3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgcmVmID0gJ2EgUmVmLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBpbnQgPSBSZWYuY29tcGFyZVxuICBsZXQgZXF1YWxfcmVmIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGJvb2wgPSBSZWYuZXF1YWxcblxuICBsZXQgZ2xvYmFsaXplX3JlZiA6ICdhLiAoKCdhW0BvY2FtbC5sb2NhbF0pIC0+ICdhKSAtPiAoJ2EgcmVmW0BvY2FtbC5sb2NhbF0pIC0+ICdhIHJlZiA9XG4gICAgZnVuICh0eXBlIGFfXzEwMl8pXG4gICAgICAgIDogICgoKGFfXzEwMl9bQG9jYW1sLmxvY2FsXSkgLT4gYV9fMTAyXykgLT4gKGFfXzEwMl8gcmVmW0BvY2FtbC5sb2NhbF0pXG4gICAgICAgICAgICAtPiBhX18xMDJfIHJlZikgLT5cbiAgICAgIFJlZi5nbG9iYWxpemVcbiAgOztcblxuICBsZXQgcmVmX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHJlZiA9XG4gICAgUmVmLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3JlZiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSByZWYgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBSZWYuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IHJlZl9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgcmVmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZWYudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBzdHJpbmcgPSBTdHJpbmcudFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3N0cmluZyA9IChTdHJpbmcuY29tcGFyZSA6IHN0cmluZyAtPiBzdHJpbmcgLT4gaW50KVxuICBsZXQgZXF1YWxfc3RyaW5nID0gKFN0cmluZy5lcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbClcblxuICBsZXQgKGdsb2JhbGl6ZV9zdHJpbmcgOiAoc3RyaW5nW0BvY2FtbC5sb2NhbF0pIC0+IHN0cmluZykgPVxuICAgIChTdHJpbmcuZ2xvYmFsaXplIDogKHN0cmluZ1tAb2NhbWwubG9jYWxdKSAtPiBzdHJpbmcpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfc3RyaW5nIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBTdHJpbmcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfc3RyaW5nIDogc3RyaW5nIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBTdHJpbmcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzdHJpbmdfb2Zfc2V4cCA9IChTdHJpbmcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHN0cmluZylcbiAgbGV0IHNleHBfb2Zfc3RyaW5nID0gKFN0cmluZy5zZXhwX29mX3QgOiBzdHJpbmcgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHN0cmluZ19zZXhwX2dyYW1tYXIgOiBzdHJpbmcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJ5dGVzID0gQnl0ZXMudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2J5dGVzID0gKEJ5dGVzLmNvbXBhcmUgOiBieXRlcyAtPiBieXRlcyAtPiBpbnQpXG4gIGxldCBlcXVhbF9ieXRlcyA9IChCeXRlcy5lcXVhbCA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGJvb2wpXG5cbiAgbGV0IChnbG9iYWxpemVfYnl0ZXMgOiAoYnl0ZXNbQG9jYW1sLmxvY2FsXSkgLT4gYnl0ZXMpID1cbiAgICAoQnl0ZXMuZ2xvYmFsaXplIDogKGJ5dGVzW0BvY2FtbC5sb2NhbF0pIC0+IGJ5dGVzKVxuICA7O1xuXG4gIGxldCBieXRlc19vZl9zZXhwID0gKEJ5dGVzLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBieXRlcylcbiAgbGV0IHNleHBfb2ZfYnl0ZXMgPSAoQnl0ZXMuc2V4cF9vZl90IDogYnl0ZXMgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJ5dGVzX3NleHBfZ3JhbW1hciA6IGJ5dGVzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEJ5dGVzLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIHVuaXQgPSBVbml0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV91bml0ID0gKFVuaXQuY29tcGFyZSA6IHVuaXQgLT4gdW5pdCAtPiBpbnQpXG4gIGxldCBlcXVhbF91bml0ID0gKFVuaXQuZXF1YWwgOiB1bml0IC0+IHVuaXQgLT4gYm9vbClcblxuICBsZXQgKGdsb2JhbGl6ZV91bml0IDogKHVuaXRbQG9jYW1sLmxvY2FsXSkgLT4gdW5pdCkgPVxuICAgIChVbml0Lmdsb2JhbGl6ZSA6ICh1bml0W0BvY2FtbC5sb2NhbF0pIC0+IHVuaXQpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfdW5pdCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdW5pdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIFVuaXQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfdW5pdCA6IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFVuaXQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB1bml0X29mX3NleHAgPSAoVW5pdC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdW5pdClcbiAgbGV0IHNleHBfb2ZfdW5pdCA9IChVbml0LnNleHBfb2ZfdCA6IHVuaXQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHVuaXRfc2V4cF9ncmFtbWFyIDogdW5pdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBVbml0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICAoKiogRm9ybWF0IHN0dWZmICopXG5cbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcblxuICAoKiogTGlzdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIExpc3QuSW5maXhcblxuICAoKiogSW50IG9wZXJhdG9ycyBhbmQgY29tcGFyaXNvbnMgKilcblxuICBpbmNsdWRlIEludC5PXG4gIGluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICgqKiBGbG9hdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIEZsb2F0Lk9fZG90XG5cbiAgKCogVGhpcyBpcyBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBiZSBvcHRpbWl6ZWQgYXdheSBpbiBtb3JlIGNvbnRleHRzLiAqKVxuXG4gICgqKiBSZXZlcnNlIGFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbeCB8PiBnIHw+IGZdIGlzIGVxdWl2YWxlbnQgdG8gW2YgKGcgKHgpKV0uICopXG4gIGV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgoJ2EgLT4gJ2IpW0Bsb2NhbF9vcHRdKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuICAoKiogQXBwbGljYXRpb24gb3BlcmF0b3IuIFtnIEBAIGYgQEAgeF0gaXMgZXF1aXZhbGVudCB0byBbZyAoZiAoeCkpXS4gKilcbiAgZXh0ZXJuYWwgKCBAQCApIDogKCgnYSAtPiAnYilbQGxvY2FsX29wdF0pIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4gICgqKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuICAoKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuICBleHRlcm5hbCAoICYmICkgOiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgZXh0ZXJuYWwgKCB8fCApIDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlc2VxdW9yXCJcbiAgZXh0ZXJuYWwgbm90IDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuICAoKiBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5LiAqKVxuICBleHRlcm5hbCBpZ25vcmUgOiAoX1tAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbiAgKCoqIENvbW1vbiBzdHJpbmcgb3BlcmF0aW9ucyAqKVxuICBsZXQgKCBeICkgPSBTdHJpbmcuKCBeIClcblxuICAoKiogUmVmZXJlbmNlIG9wZXJhdGlvbnMgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfbW9kaWZ5IHdoZW4gcG9zc2libGUgYW5kXG4gICAgIHRvIGtlZXAgcmVmZXJlbmNlIHVuYm94aW5nIHdvcmtpbmcgKilcbiAgZXh0ZXJuYWwgKCAhICkgOiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWZpZWxkMFwiXG4gIGV4dGVybmFsIHJlZiA6ICdhIC0+ICgnYSByZWZbQGxvY2FsX29wdF0pID0gXCIlbWFrZW11dGFibGVcIlxuICBleHRlcm5hbCAoIDo9ICkgOiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxuICAoKiogUGFpciBvcGVyYXRpb25zICopXG5cbiAgbGV0IGZzdCA9IGZzdFxuICBsZXQgc25kID0gc25kXG5cbiAgKCoqIEV4Y2VwdGlvbnMgc3R1ZmYgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBtYXkgcmV3cml0ZSAnJXJhaXNlJyBhcyAnJXJlcmFpc2UnLiAqKVxuICBleHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG4gIGxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG4gIGxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gICgqKiBNaXNjICopXG5cbiAgZXh0ZXJuYWwgcGh5c19lcXVhbCA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXFcIlxuICBleHRlcm5hbCBmb3JjZSA6ICgnYSBMYXp5LnRbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuaW5jbHVkZSBDb250YWluZXJfaW50Zi5FeHBvcnQgKCoqIEBpbmxpbmUgKilcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zID0gTm90X2ZvdW5kX3NcblxuKCogV2UgcGVyZm9ybSB0aGVzZSBzaWRlIGVmZmVjdHMgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdGhlbSB0byBydW4gZm9yIGFueSBjb2RlIHRoYXQgdXNlc1xuICAgW0Jhc2VdLiAgSWYgdGhpcyB3ZXJlIGluIGFub3RoZXIgbW9kdWxlIGluIFtCYXNlXSB0aGF0IHdhcyBub3QgdXNlZCBpbiBzb21lIHByb2dyYW0sXG4gICB0aGVuIHRoZSBzaWRlIGVmZmVjdHMgbWlnaHQgbm90IGJlIHJ1biBpbiB0aGF0IHByb2dyYW0uICBUaGlzIHdpbGwgcnVuIGFzIGxvbmcgYXMgdGhlXG4gICBwcm9ncmFtIHJlZmVycyB0byBhdCBsZWFzdCBvbmUgdmFsdWUgZGlyZWN0bHkgaW4gW0Jhc2VdOyByZWZlcnJpbmcgdG8gdmFsdWVzIGluXG4gICBbQmFzZS5Cb29sXSwgZm9yIGV4YW1wbGUsIGlzIG5vdCBzdWZmaWNpZW50LiAqKVxubGV0ICgpID0gQmFja3RyYWNlLmluaXRpYWxpemVfbW9kdWxlICgpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
