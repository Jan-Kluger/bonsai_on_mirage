// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Incr_map__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Incr_map = [0];
   runtime.caml_register_global(0, Incr_map, "Incr_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map__Incr_map_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map_Incr_map_intf = "Incr_map__Incr_map_intf",
    cst_incr_map = "incr_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map_Incr_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Expect_test_collector[6][1], "src/incr_map_intf.ml");
   caml_call2(Ppx_inline_test_lib[5], cst_incr_map, "incr_map_intf.ml");
   var Instrumentation = [0];
   caml_call1(Ppx_inline_test_lib[6], cst_incr_map);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map_Incr_map_intf);
   var Incr_map_Incr_map_intf = [0, Instrumentation];
   runtime.caml_register_global
    (11, Incr_map_Incr_map_intf, cst_Incr_map_Incr_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map
//# unitInfo: Requires: Base__Option, CamlinternalLazy, Core, Core__Bool, Core__Info, Core__Int, Core__Lazy, Core__List, Core__Map, Core__Maybe_bound, Core__Option, Core__Sequence, Core__Set, Core__Tuple, Expect_test_collector, Incr_map__Incr_map_intf, Incremental, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map = "Incr_map",
    cst_incr_map = "incr_map",
    cst_src_incr_map_ml = "src/incr_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Int = global_data.Core__Int,
    Core_Map = global_data.Core__Map,
    Core = global_data.Core,
    Incremental = global_data.Incremental,
    Core_Option = global_data.Core__Option,
    Core_Info = global_data.Core__Info,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Core_List = global_data.Core__List,
    Core_Bool = global_data.Core__Bool,
    Core_Tuple = global_data.Core__Tuple,
    Assert_failure = global_data.Assert_failure,
    Core_Maybe_bound = global_data.Core__Maybe_bound,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Lazy = global_data.Core__Lazy,
    Core_Set = global_data.Core__Set,
    Base_Option = global_data.Base__Option,
    Core_Sequence = global_data.Core__Sequence,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Expect_test_collector[6][1], cst_src_incr_map_ml);
   caml_call2(Ppx_inline_test_lib[5], cst_incr_map, "incr_map.ml");
   var
    _a_ = [0, cst_src_incr_map_ml, 329, 11],
    _b_ = [0, 1],
    _c_ = [0, 1],
    cst_impossible_case_BUG_in_inc =
      "impossible case: BUG in incr_map.ml subrange",
    _d_ = [0, 1],
    cst_BUG_Hit_supposedly_impossi =
      "BUG: Hit supposedly impossible case in Incr_map.index_by",
    _e_ = [0, 1],
    _f_ = [0, "to_"],
    _g_ = [0, "from"],
    cst_Invalid_indices = "Invalid indices",
    _h_ = [0, 0, 0],
    _i_ = [0, cst_src_incr_map_ml, 1444, 10],
    _j_ = [0, cst_src_incr_map_ml, 1443, 10],
    _k_ = [0, cst_src_incr_map_ml, 1459, 6],
    _l_ = [0, [0, 0, 0]],
    _m_ = [0, cst_src_incr_map_ml, 1459, 6],
    _n_ = [0, cst_src_incr_map_ml, 1459, 6],
    _o_ = [0, cst_src_incr_map_ml, 1459, 6],
    _p_ = [0, cst_src_incr_map_ml, 1459, 6],
    _q_ = [0, cst_src_incr_map_ml, 1459, 6],
    _r_ = [0, cst_src_incr_map_ml, 1459, 6],
    _s_ = [0, cst_src_incr_map_ml, 1459, 6],
    _t_ = [0, cst_src_incr_map_ml, 1459, 6],
    _u_ = [0, [0, 0, 0]],
    _v_ = [0, 1],
    _w_ = [0, 1],
    _x_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1];
   function no_instrumentation(f){return caml_call1(f, 0);}
   function with_old(instrumentation, i, f){
    var old = [0, 0];
    return caml_call2
            (Incremental[76][3][5],
             i,
             function(a){
              return caml_call1
                      (instrumentation,
                       function(param){
                        var b = caml_call2(f, old[1], a);
                        old[1] = [0, [0, a, b]];
                        return b;
                       });
             });
   }
   function cutoff(opt, map, cutoff){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    function data_equal(old_value, new_value){
     return caml_call3(Incremental[58][10], cutoff, old_value, new_value);
    }
    return with_old
            (instrumentation,
             map,
             function(old, cur){
              if(! old) return cur;
              var old$0 = old[1][2];
              return caml_call5
                      (Core_Map[85],
                       old$0,
                       cur,
                       data_equal,
                       old$0,
                       function(acc, param){
                        var change = param[2], key = param[1], _dr_ = change[1];
                        if(847852583 === _dr_)
                         return caml_call2(Core_Map[45], acc, key);
                        if(1013247643 <= _dr_){
                         var new_value = change[2][2];
                         return caml_call3(Core_Map[36], acc, key, new_value);
                        }
                        var new$0 = change[2];
                        return caml_call3(Core_Map[35], acc, key, new$0);
                       });
             });
   }
   function unordered_fold
   (instrumentation,
    _dl_,
    update,
    specialized_initial,
    _dk_,
    opt,
    map,
    init,
    add,
    remove){
    var
     data_equal =
       _dl_ ? _dl_[1] : function(_dq_, _dp_){return _dq_ === _dp_ ? 1 : 0;},
     finalize = _dk_ ? _dk_[1] : function(_do_){return _do_;},
     revert_to_init_when_empty = opt ? opt[1] : 0;
    function default$0(key, old_data, new_data, acc){
     return caml_call3
             (add, key, new_data, caml_call3(remove, key, old_data, acc));
    }
    var update$0 = caml_call2(Core_Option[35], update, default$0);
    return with_old
            (instrumentation,
             map,
             function(old, new_in){
              if(old){
               var match = old[1], old_out = match[2], old_in = match[1];
               a:
               {
                if(revert_to_init_when_empty){
                 var _dm_ = caml_call1(Core_Map[33], new_in);
                 if(caml_call2(Core[89], _dm_, 0)){var init$0 = init; break a;}
                }
                var
                 init$0 =
                   caml_call5
                    (Core_Map[85],
                     old_in,
                     new_in,
                     data_equal,
                     old_out,
                     function(acc, param){
                      var change = param[2], key = param[1], _dn_ = change[1];
                      if(847852583 === _dn_){
                       var old = change[2];
                       return caml_call3(remove, key, old, acc);
                      }
                      if(1013247643 <= _dn_){
                       var match = change[2], new$0 = match[2], old$0 = match[1];
                       return caml_call4(update$0, key, old$0, new$0, acc);
                      }
                      var new$1 = change[2];
                      return caml_call3(add, key, new$1, acc);
                     });
               }
               var acc = init$0;
              }
              else if(specialized_initial)
               var
                initial = specialized_initial[1],
                acc = caml_call2(initial, init, new_in);
              else
               var acc = caml_call3(Core_Map[59], new_in, init, add);
              return caml_call1(finalize, acc);
             });
   }
   function unordered_fold_nested_maps
   (instrumentation,
    opt,
    revert_to_init_when_empty,
    update,
    incr_map,
    init,
    add,
    remove){
    var
     data_equal =
       opt ? opt[1] : function(_dj_, _di_){return _dj_ === _di_ ? 1 : 0;};
    if(update)
     var update$0 = update[1], update$1 = update$0;
    else
     var
      update$1 =
        function(outer_key, inner_key, old_data, new_data, acc){
         return caml_call4
                 (add,
                  outer_key,
                  inner_key,
                  new_data,
                  caml_call4(remove, outer_key, inner_key, old_data, acc));
        };
    return unordered_fold
            (instrumentation,
             0,
             [0,
              function(outer_key, old_inner_map, new_inner_map, acc){
               return caml_call2
                       (caml_call3
                         (Core_Map[85], old_inner_map, new_inner_map, data_equal),
                        acc,
                        function(acc, param){
                         var diff = param[2], inner_key = param[1], _dh_ = diff[1];
                         if(847852583 === _dh_){
                          var data_removed = diff[2];
                          return caml_call4
                                  (remove, outer_key, inner_key, data_removed, acc);
                         }
                         if(1013247643 <= _dh_){
                          var
                           match = diff[2],
                           new_data = match[2],
                           old_data = match[1];
                          return caml_call5
                                  (update$1, outer_key, inner_key, old_data, new_data, acc);
                         }
                         var data_added = diff[2];
                         return caml_call4
                                 (add, outer_key, inner_key, data_added, acc);
                        });
              }],
             0,
             0,
             revert_to_init_when_empty,
             incr_map,
             init,
             function(outer_key, inner_map, acc){
              return caml_call3
                      (Core_Map[59],
                       inner_map,
                       acc,
                       function(inner_key, data, acc){
                        return caml_call4(add, outer_key, inner_key, data, acc);
                       });
             },
             function(outer_key, inner_map, acc){
              return caml_call3
                      (Core_Map[59],
                       inner_map,
                       acc,
                       function(inner_key, data, acc){
                        return caml_call4(remove, outer_key, inner_key, data, acc);
                       });
             });
   }
   function with_comparator(get_comparator, x, f){
    var
     _df_ = caml_call2(Incremental[10], x, get_comparator),
     _dg_ = caml_call2(Incremental[34], 0, _df_);
    return caml_call2(Incremental[26], _dg_, f);
   }
   function with_comparator$0(map, f){
    return with_comparator(Core_Map[2], map, f);
   }
   function of_set(opt, set){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator
            (Core_Set[6],
             set,
             function(comparator){
              var
               old_input = [0, caml_call1(Core_Set[3][1], comparator)],
               old_output = [0, caml_call1(Core_Map[118][1], comparator)];
              return caml_call2
                      (Incremental[10],
                       set,
                       function(new_input){
                        return caml_call1
                                (instrumentation,
                                 function(param){
                                  var
                                   _dd_ = old_output[1],
                                   _de_ = caml_call2(Core_Set[18], old_input[1], new_input),
                                   new_output =
                                     caml_call3
                                      (Core_Sequence[18],
                                       _de_,
                                       _dd_,
                                       function(output, param){
                                        if(0 === param[0]){
                                         var k = param[1];
                                         return caml_call2(Core_Map[45], output, k);
                                        }
                                        var k$0 = param[1];
                                        return caml_call3(Core_Map[35], output, k$0, 0);
                                       });
                                  old_input[1] = new_input;
                                  old_output[1] = new_output;
                                  return new_output;
                                 });
                       });
             });
   }
   function generic_mapi(witness, instrumentation, opt, map, f){
    var
     data_equal =
       opt ? opt[1] : function(_dc_, _db_){return _dc_ === _db_ ? 1 : 0;};
    return with_old
            (instrumentation,
             map,
             function(old, input){
              if(0 !== caml_call1(Core_Map[33], input) && old){
               var
                match = old[1],
                old_output = match[2],
                old_input = match[1];
               return caml_call5
                       (Core_Map[85],
                        old_input,
                        input,
                        data_equal,
                        old_output,
                        function(output, param){
                         var change = param[2], key = param[1], _da_ = change[1];
                         if(847852583 === _da_)
                          return caml_call2(Core_Map[45], output, key);
                         var
                          new_data = 1013247643 <= _da_ ? change[2][2] : change[2],
                          res = caml_call2(f, key, new_data);
                         if(! witness)
                          return caml_call3(Core_Map[36], output, key, res);
                         if(! res) return caml_call2(Core_Map[45], output, key);
                         var output_data = res[1];
                         return caml_call3(Core_Map[36], output, key, output_data);
                        });
              }
              return witness
                      ? caml_call2(Core_Map[67], input, f)
                      : caml_call2(Core_Map[56], input, f);
             });
   }
   function mapi(opt, data_equal, map, f){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return generic_mapi(0, instrumentation, data_equal, map, f);
   }
   function filter_mapi(opt, data_equal, map, f){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return generic_mapi(1, instrumentation, data_equal, map, f);
   }
   function map(instrumentation, data_equal, map, f){
    return mapi
            (instrumentation,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map(instrumentation, data_equal, map, f){
    return filter_mapi
            (instrumentation,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function with_old2(instrumentation, i1, i2, f){
    var old = [0, 0];
    return caml_call3
            (Incremental[12],
             i1,
             i2,
             function(a1, a2){
              return caml_call1
                      (instrumentation,
                       function(param){
                        var b = caml_call3(f, old[1], a1, a2);
                        old[1] = [0, [0, a1, a2, b]];
                        return b;
                       });
             });
   }
   function unordered_fold_with_extra
   (_c4_,
    _c3_,
    _c2_,
    update,
    specialized_initial,
    _c1_,
    opt,
    map,
    extra,
    init,
    add,
    remove,
    extra_changed){
    var
     instrumentation = _c4_ ? _c4_[1] : no_instrumentation,
     data_equal =
       _c3_ ? _c3_[1] : function(_c$_, _c__){return _c$_ === _c__ ? 1 : 0;},
     extra_equal =
       _c2_ ? _c2_[1] : function(_c9_, _c8_){return _c9_ === _c8_ ? 1 : 0;},
     finalize = _c1_ ? _c1_[1] : function(_c7_){return _c7_;},
     revert_to_init_when_empty = opt ? opt[1] : 0;
    function default$0(key, old_data, new_data, acc, extra){
     return caml_call4
             (add,
              key,
              new_data,
              caml_call4(remove, key, old_data, acc, extra),
              extra);
    }
    var update$0 = caml_call2(Core_Option[35], update, default$0);
    return with_old2
            (instrumentation,
             map,
             extra,
             function(old, new_in, new_extra){
              if(old){
               var
                match = old[1],
                old_out = match[3],
                old_extra = match[2],
                old_in = match[1],
                acc =
                  caml_call2(extra_equal, old_extra, new_extra)
                   ? old_out
                   : caml_call4
                     (extra_changed, old_extra, new_extra, old_in, old_out);
               a:
               {
                if(revert_to_init_when_empty){
                 var _c5_ = caml_call1(Core_Map[33], new_in);
                 if(caml_call2(Core[89], _c5_, 0)){var init$0 = init; break a;}
                }
                var
                 init$0 =
                   caml_call5
                    (Core_Map[85],
                     old_in,
                     new_in,
                     data_equal,
                     acc,
                     function(acc, param){
                      var change = param[2], key = param[1], _c6_ = change[1];
                      if(847852583 === _c6_){
                       var old = change[2];
                       return caml_call4(remove, key, old, acc, new_extra);
                      }
                      if(1013247643 <= _c6_){
                       var match = change[2], new$0 = match[2], old$0 = match[1];
                       return caml_call5
                               (update$0, key, old$0, new$0, acc, new_extra);
                      }
                      var new$1 = change[2];
                      return caml_call4(add, key, new$1, acc, new_extra);
                     });
               }
               var acc$0 = init$0;
              }
              else if(specialized_initial)
               var
                initial = specialized_initial[1],
                acc$0 = caml_call3(initial, init, new_in, new_extra);
              else
               var
                acc$0 =
                  caml_call3
                   (Core_Map[59],
                    new_in,
                    init,
                    function(key, data, acc){
                     return caml_call4(add, key, data, acc, new_extra);
                    });
              return caml_call1(finalize, acc$0);
             });
   }
   function mapi_count(_cX_, opt, input, comparator, f){
    var
     instrumentation = _cX_ ? _cX_[1] : no_instrumentation,
     data_equal =
       opt ? opt[1] : function(_c0_, _cZ_){return _c0_ === _cZ_ ? 1 : 0;};
    function add(new_key, acc){
     return caml_call3
             (Core_Map[41],
              acc,
              new_key,
              function(param){
               if(! param) return 1;
               var n = param[1];
               return n + 1 | 0;
              });
    }
    function remove(new_key, acc){
     return caml_call3
             (Core_Map[40],
              acc,
              new_key,
              function(param){
               if(! param) return 0;
               var n = param[1];
               return 1 === n ? 0 : [0, n - 1 | 0];
              });
    }
    return unordered_fold
            (instrumentation,
             [0, data_equal],
             [0,
              function(key, old_data, new_data, acc){
               var
                prev_key = caml_call2(f, key, old_data),
                new_key = caml_call2(f, key, new_data),
                _cY_ = caml_call2(comparator[1][1], prev_key, new_key);
               return caml_call2(Core[89], _cY_, 0)
                       ? acc
                       : add(new_key, remove(prev_key, acc));
              }],
             0,
             0,
             0,
             input,
             caml_call1(Core_Map[4], comparator),
             function(key, data, acc){
              return add(caml_call2(f, key, data), acc);
             },
             function(key, data, acc){
              return remove(caml_call2(f, key, data), acc);
             });
   }
   function map_count(instrumentation, data_equal, input, comparator, f){
    return mapi_count
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function min_helper(map){
    var match = caml_call1(Core_Map[86], map);
    if(! match) return 0;
    var min = match[1][1];
    return [0, min];
   }
   function max_helper(map){
    var match = caml_call1(Core_Map[88], map);
    if(! match) return 0;
    var max = match[1][1];
    return [0, max];
   }
   function bounds_helper(map){
    var
     match = caml_call1(Core_Map[86], map),
     match$0 = caml_call1(Core_Map[88], map);
    if(match){
     if(match$0){
      var max = match$0[1][1], min = match[1][1];
      return [0, [0, min, max]];
     }
    }
    else if(! match$0) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function mapi_min(instrumentation, data_equal, input, comparator, f){
    var _cW_ = mapi_count(instrumentation, data_equal, input, comparator, f);
    return caml_call2(Incremental[10], _cW_, min_helper);
   }
   function mapi_max(instrumentation, data_equal, input, comparator, f){
    var _cV_ = mapi_count(instrumentation, data_equal, input, comparator, f);
    return caml_call2(Incremental[10], _cV_, max_helper);
   }
   function mapi_bounds(instrumentation, data_equal, input, comparator, f){
    var _cU_ = mapi_count(instrumentation, data_equal, input, comparator, f);
    return caml_call2(Incremental[10], _cU_, bounds_helper);
   }
   function map_min(instrumentation, data_equal, input, comparator, f){
    return mapi_min
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function map_max(instrumentation, data_equal, input, comparator, f){
    return mapi_max
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function min_value(instrumentation, data_equal, input, comparator){
    return map_min
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(_cT_){return _cT_;});
   }
   function max_value(instrumentation, data_equal, input, comparator){
    return map_max
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(_cS_){return _cS_;});
   }
   function map_bounds(instrumentation, data_equal, input, comparator, f){
    return mapi_bounds
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function value_bounds(instrumentation, data_equal, input, comparator){
    return map_bounds
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(_cR_){return _cR_;});
   }
   function merge_shared_impl
   (old, new_left_map, new_right_map, data_equal_left, data_equal_right, f){
    var comparator = caml_call1(Core_Map[2], new_left_map);
    if(old)
     var
      x = old[1],
      old_output = x[3],
      old_right_map = x[2],
      old_left_map = x[1];
    else
     var
      old_left_map$0 = caml_call1(Core_Map[118][1], comparator),
      old_output = old_left_map$0,
      old_right_map = old_left_map$0,
      old_left_map = old_left_map$0;
    var
     left_diff =
       caml_call3(Core_Map[84], old_left_map, new_left_map, data_equal_left),
     right_diff =
       caml_call3
        (Core_Map[84], old_right_map, new_right_map, data_equal_right),
     _cP_ =
       caml_call3
        (Core_Sequence[62],
         left_diff,
         right_diff,
         function(_cQ_, param){
          var right_key = param[1], left_key = _cQ_[1];
          return caml_call2(comparator[1], left_key, right_key);
         });
    return caml_call3
            (Core_Sequence[18],
             _cP_,
             old_output,
             function(output, diff_element){
              if(2 === diff_element[0])
               var left_key = diff_element[1][1], key$0 = left_key;
              else
               var key = diff_element[1][1], key$0 = key;
              return caml_call4(f, old_output, key$0, output, diff_element);
             });
   }
   function new_data_from_diff_element(param){
    var _cO_ = param[1];
    if(847852583 === _cO_) return 0;
    var x = 1013247643 <= _cO_ ? param[2][2] : param[2];
    return [0, x];
   }
   function merge(_cI_, _cH_, opt, left_map, right_map, f){
    var
     instrumentation = _cI_ ? _cI_[1] : no_instrumentation,
     data_equal_left =
       _cH_ ? _cH_[1] : function(_cN_, _cM_){return _cN_ === _cM_ ? 1 : 0;},
     data_equal_right =
       opt ? opt[1] : function(_cL_, _cK_){return _cL_ === _cK_ ? 1 : 0;};
    return with_old2
            (instrumentation,
             left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              return merge_shared_impl
                      (old,
                       new_left_map,
                       new_right_map,
                       data_equal_left,
                       data_equal_right,
                       function(param, key, output, diff_element){
                        switch(diff_element[0]){
                          case 0:
                           var
                            left_diff = diff_element[1][2],
                            right_data_opt =
                              caml_call2(Core_Map[42], new_right_map, key),
                            right_data_opt$0 = right_data_opt,
                            left_data_opt = new_data_from_diff_element(left_diff);
                           break;
                          case 1:
                           var
                            right_diff = diff_element[1][2],
                            right_data_opt$1 = new_data_from_diff_element(right_diff),
                            right_data_opt$0 = right_data_opt$1,
                            left_data_opt = caml_call2(Core_Map[42], new_left_map, key);
                           break;
                          default:
                           var
                            right_diff$0 = diff_element[2][2],
                            left_diff$0 = diff_element[1][2],
                            right_data_opt$2 = new_data_from_diff_element(right_diff$0),
                            left_data_opt$0 = new_data_from_diff_element(left_diff$0),
                            right_data_opt$0 = right_data_opt$2,
                            left_data_opt = left_data_opt$0;
                        }
                        if(left_data_opt){
                         var x = left_data_opt[1];
                         if(right_data_opt$0)
                          var
                           y = right_data_opt$0[1],
                           _cJ_ = caml_call2(f, key, [0, 737457313, [0, x, y]]);
                         else
                          var _cJ_ = caml_call2(f, key, [0, 847852583, x]);
                         var output_data_opt = _cJ_;
                        }
                        else if(right_data_opt$0)
                         var
                          y$0 = right_data_opt$0[1],
                          output_data_opt = caml_call2(f, key, [0, -57574468, y$0]);
                        else
                         var output_data_opt = 0;
                        if(! output_data_opt)
                         return caml_call2(Core_Map[45], output, key);
                        var data = output_data_opt[1];
                        return caml_call3(Core_Map[36], output, key, data);
                       });
             });
   }
   function merge_both_some(_cu_, _ct_, _cs_, opt, left_map, right_map, f){
    var
     instrumentation = _cu_ ? _cu_[1] : no_instrumentation,
     data_equal_left =
       _ct_ ? _ct_[1] : function(_cG_, _cF_){return _cG_ === _cF_ ? 1 : 0;},
     data_equal_right =
       _cs_ ? _cs_[1] : function(_cE_, _cD_){return _cE_ === _cD_ ? 1 : 0;},
     out_equal =
       opt ? opt[1] : function(_cC_, _cB_){return _cC_ === _cB_ ? 1 : 0;};
    return with_old2
            (instrumentation,
             left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              var
               comparator = caml_call1(Core_Map[2], new_left_map),
               empty = caml_call1(Core_Map[118][1], comparator),
               match = caml_call1(Core_Map[33], new_left_map),
               match$0 = caml_call1(Core_Map[33], new_right_map);
              if(0 !== match && 0 !== match$0)
               return merge_shared_impl
                       (old,
                        new_left_map,
                        new_right_map,
                        data_equal_left,
                        data_equal_right,
                        function(old_output, key, output, diff_element){
                         switch(diff_element[0]){
                           case 0:
                            var
                             left_diff = diff_element[1][2],
                             _cv_ = new_data_from_diff_element(left_diff),
                             left_and_right_data_opt =
                               caml_call2
                                (Base_Option[27][4][2],
                                 _cv_,
                                 function(left_data){
                                  var _cA_ = caml_call2(Core_Map[42], new_right_map, key);
                                  return caml_call2
                                          (Base_Option[27][4][3],
                                           _cA_,
                                           function(right_data){return [0, left_data, right_data];});
                                 });
                            break;
                           case 1:
                            var
                             right_diff = diff_element[1][2],
                             _cw_ = new_data_from_diff_element(right_diff),
                             left_and_right_data_opt =
                               caml_call2
                                (Base_Option[27][4][2],
                                 _cw_,
                                 function(right_data){
                                  var _cz_ = caml_call2(Core_Map[42], new_left_map, key);
                                  return caml_call2
                                          (Base_Option[27][4][3],
                                           _cz_,
                                           function(left_data){return [0, left_data, right_data];});
                                 });
                            break;
                           default:
                            var
                             right_diff$0 = diff_element[2][2],
                             left_diff$0 = diff_element[1][2],
                             _cx_ = new_data_from_diff_element(left_diff$0),
                             left_and_right_data_opt =
                               caml_call2
                                (Base_Option[27][4][2],
                                 _cx_,
                                 function(left_data){
                                  var _cy_ = new_data_from_diff_element(right_diff$0);
                                  return caml_call2
                                          (Base_Option[27][4][3],
                                           _cy_,
                                           function(right_data){return [0, left_data, right_data];});
                                 });
                         }
                         var prev_out = caml_call2(Core_Map[42], old_output, key);
                         if(! left_and_right_data_opt)
                          return prev_out
                                  ? caml_call2(Core_Map[45], output, key)
                                  : output;
                         var
                          match = left_and_right_data_opt[1],
                          y = match[2],
                          x = match[1],
                          data = caml_call3(f, key, x, y);
                         if(prev_out){
                          var prev_out$0 = prev_out[1];
                          if(caml_call2(out_equal, data, prev_out$0)) return output;
                         }
                         return caml_call3(Core_Map[36], output, key, data);
                        });
              return empty;
             });
   }
   function generic_mapi_with_comparator
   (witness, instrumentation, cutoff, opt, lhs, comparator, f){
    var
     data_equal =
       opt ? opt[1] : function(_cr_, _cq_){return _cr_ === _cq_ ? 1 : 0;},
     incremental_state = caml_call1(Incremental[4], lhs),
     empty_map = caml_call1(Core_Map[118][1], comparator),
     prev_map = [0, empty_map],
     prev_nodes = [0, empty_map],
     acc = [0, empty_map],
     result =
       caml_call3
        (Incremental[79][2][2],
         incremental_state,
         0,
         function(param){return acc[1];}),
     on_inner_change =
       witness
        ? function
         (key, opt){
          var old = acc[1];
          if(opt)
           var data = opt[1], _cp_ = caml_call3(Core_Map[36], old, key, data);
          else
           var _cp_ = caml_call2(Core_Map[45], old, key);
          acc[1] = _cp_;
          return 0;
         }
        : function
         (key, data){
          acc[1] = caml_call3(Core_Map[36], acc[1], key, data);
          return 0;
         },
     lhs_change = [];
    caml_update_dummy
     (lhs_change,
      [246,
       function(_ci_){
        return caml_call2
                (Incremental[10],
                 lhs,
                 function(map){
                  return caml_call1
                          (instrumentation,
                           function(param){
                            var
                             new_nodes =
                               caml_call5
                                (Core_Map[85],
                                 prev_map[1],
                                 map,
                                 data_equal,
                                 prev_nodes[1],
                                 function(nodes, param){
                                  var changed = param[2], key = param[1], _cj_ = changed[1];
                                  if(847852583 === _cj_){
                                   var
                                    match = caml_call2(Core_Map[43], nodes, key),
                                    dep = match[2],
                                    node = match[1],
                                    nodes$0 = caml_call2(Core_Map[45], nodes, key);
                                   caml_call2(Incremental[79][2][7], result, dep);
                                   acc[1] = caml_call2(Core_Map[45], acc[1], key);
                                   caml_call1(Incremental[79][2][5], node);
                                   return nodes$0;
                                  }
                                  if(1013247643 <= _cj_){
                                   var node$0 = caml_call2(Core_Map[43], nodes, key)[1];
                                   caml_call1(Incremental[79][2][4], node$0);
                                   return nodes;
                                  }
                                  var
                                   node$1 =
                                     caml_call3
                                      (Incremental[79][2][2],
                                       incremental_state,
                                       0,
                                       function(param){
                                        return caml_call2(Core_Map[43], prev_map[1], key);
                                       });
                                  caml_call2
                                   (Core_Option[42],
                                    cutoff,
                                    function(c){
                                     var _co_ = caml_call1(Incremental[79][2][3], node$1);
                                     return caml_call2(Incremental[59], _co_, c);
                                    });
                                  var
                                   _ck_ = caml_call1(Core[242], lhs_change),
                                   _cl_ = caml_call2(Incremental[79][1][2], 0, _ck_);
                                  caml_call2(Incremental[79][2][6], node$1, _cl_);
                                  var
                                   _cm_ =
                                     caml_call2
                                      (f, key, caml_call1(Incremental[79][2][3], node$1)),
                                   user_function_dep =
                                     caml_call2
                                      (Incremental[79][1][2],
                                       [0, function(_cn_){return on_inner_change(key, _cn_);}],
                                       _cm_);
                                  caml_call2(Incremental[79][2][6], result, user_function_dep);
                                  return caml_call3
                                          (Core_Map[36], nodes, key, [0, node$1, user_function_dep]);
                                 });
                            prev_nodes[1] = new_nodes;
                            prev_map[1] = map;
                            return 0;
                           });
                 });
       }]);
    var
     _cg_ = caml_call1(Core[242], lhs_change),
     _ch_ = caml_call2(Incremental[79][1][2], 0, _cg_);
    caml_call2(Incremental[79][2][6], result, _ch_);
    return caml_call1(Incremental[79][2][3], result);
   }
   function filter_mapi$0(opt, cutoff, data_equal, map, f){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator
                      (1, instrumentation, cutoff, data_equal, map, comparator, f);
             });
   }
   function mapi$0(opt, cutoff, data_equal, map, f){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator
                      (0, instrumentation, cutoff, data_equal, map, comparator, f);
             });
   }
   function map$0(instrumentation, cutoff, data_equal, map, f){
    return mapi$0
            (instrumentation,
             cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map$0(instrumentation, cutoff, data_equal, map, f){
    return filter_mapi$0
            (instrumentation,
             cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function merge$0
   (instrumentation, cutoff, data_equal_left, data_equal_right, map1, map2, f){
    return filter_mapi$0
            (instrumentation,
             cutoff,
             0,
             merge
              (instrumentation,
               data_equal_left,
               data_equal_right,
               map1,
               map2,
               function(param, diff){return [0, diff];}),
             function(key, diff){return caml_call2(f, key, diff);});
   }
   function unzip_mapi
   (opt, data_equal, left_result_equal, right_result_equal, input, f){
    var
     instrumentation = opt ? opt[1] : no_instrumentation,
     pair =
       with_comparator$0
        (input,
         function(comparator){
          var
           data_equal$0 =
             data_equal
              ? data_equal[1]
              : function(_cf_, _ce_){return _cf_ === _ce_ ? 1 : 0;},
           left_result_equal$0 =
             left_result_equal
              ? left_result_equal[1]
              : function(_cd_, _cc_){return _cd_ === _cc_ ? 1 : 0;},
           right_result_equal$0 =
             right_result_equal
              ? right_result_equal[1]
              : function(_cb_, _ca_){return _cb_ === _ca_ ? 1 : 0;},
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[118][1], comparator),
           left_acc = [0, empty_map],
           left_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return left_acc[1];}),
           right_acc = [0, empty_map],
           right_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return right_acc[1];}),
           prev_map = [0, empty_map],
           input_change =
             caml_call2
              (Incremental[10],
               input,
               function(map){
                return caml_call1
                        (instrumentation,
                         function(param){
                          var
                           match = caml_call1(Core_Map[32], prev_map[1]),
                           match$0 = caml_call1(Core_Map[32], map);
                          a:
                          {
                           if(match){
                            if(! match$0){
                             var
                              left$0 =
                                caml_call2
                                 (Core_Map[56],
                                  map,
                                  function(key, data){
                                   var l = caml_call2(f, key, data)[1];
                                   return l;
                                  }),
                              right$0 =
                                caml_call2
                                 (Core_Map[56],
                                  map,
                                  function(key, data){
                                   var r = caml_call2(f, key, data)[2];
                                   return r;
                                  }),
                              right = right$0,
                              left = left$0;
                             break a;
                            }
                           }
                           else if(! match$0){
                            var
                             _b7_ =
                               caml_call5
                                (Core_Map[85],
                                 prev_map[1],
                                 map,
                                 data_equal$0,
                                 [0, left_acc[1], right_acc[1]],
                                 function(_b8_, param){
                                  var
                                   changed = param[2],
                                   key = param[1],
                                   right = _b8_[2],
                                   left = _b8_[1],
                                   _b9_ = changed[1];
                                  if(847852583 === _b9_){
                                   var _b__ = caml_call2(Core_Map[45], right, key);
                                   return [0, caml_call2(Core_Map[45], left, key), _b__];
                                  }
                                  if(1013247643 <= _b9_){
                                   var
                                    match = changed[2],
                                    new$0 = match[2],
                                    prev = match[1],
                                    match$0 = caml_call2(f, key, prev),
                                    prev_b = match$0[2],
                                    prev_a = match$0[1],
                                    match$1 = caml_call2(f, key, new$0),
                                    new_b = match$1[2],
                                    new_a = match$1[1],
                                    left$0 =
                                      caml_call2(left_result_equal$0, prev_a, new_a)
                                       ? left
                                       : caml_call3(Core_Map[36], left, key, new_a),
                                    right$0 =
                                      caml_call2(right_result_equal$0, prev_b, new_b)
                                       ? right
                                       : caml_call3(Core_Map[36], right, key, new_b);
                                   return [0, left$0, right$0];
                                  }
                                  var
                                   element = changed[2],
                                   match$2 = caml_call2(f, key, element),
                                   b = match$2[2],
                                   a = match$2[1],
                                   _b$_ = caml_call3(Core_Map[36], right, key, b);
                                  return [0, caml_call3(Core_Map[36], left, key, a), _b$_];
                                 }),
                             right = _b7_[2],
                             left = _b7_[1];
                            break a;
                           }
                           var right = empty_map, left = empty_map;
                          }
                          if(1 - (left_acc[1] === left ? 1 : 0))
                           caml_call1(Incremental[79][2][4], left_result);
                          if(1 - (right_acc[1] === right ? 1 : 0))
                           caml_call1(Incremental[79][2][4], right_result);
                          left_acc[1] = left;
                          right_acc[1] = right;
                          prev_map[1] = map;
                          return 0;
                         });
               }),
           _b3_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], left_result, _b3_);
          var _b4_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], right_result, _b4_);
          var
           _b5_ = caml_call1(Incremental[79][2][3], right_result),
           _b6_ = [0, caml_call1(Incremental[79][2][3], left_result), _b5_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _b6_);
         }),
     _b0_ = caml_call2(Incremental[10], pair, function(_b2_){return _b2_[2];});
    return [0,
            caml_call2(Incremental[10], pair, function(_b1_){return _b1_[1];}),
            _b0_];
   }
   function unzip
   (instrumentation, left_result_equal, right_result_equal, input){
    var
     data_equal =
       caml_call3
        (Core_Option[24],
         left_result_equal,
         right_result_equal,
         function(l, r){return caml_call2(Core_Tuple[1][10], l, r);});
    return unzip_mapi
            (instrumentation,
             data_equal,
             left_result_equal,
             right_result_equal,
             input,
             function(param, data){return data;});
   }
   function unzip_mapi$0(opt, cutoff, data_equal, input, f){
    var
     instrumentation = opt ? opt[1] : no_instrumentation,
     pair =
       with_comparator$0
        (input,
         function(comparator){
          var
           data_equal$0 =
             data_equal
              ? data_equal[1]
              : function(_bZ_, _bY_){return _bZ_ === _bY_ ? 1 : 0;},
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[118][1], comparator),
           prev_map = [0, empty_map],
           prev_nodes = [0, empty_map],
           left_acc = [0, empty_map],
           left_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return left_acc[1];}),
           right_acc = [0, empty_map],
           right_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return right_acc[1];}),
           input_change = [];
          caml_update_dummy
           (input_change,
            [246,
             function(_bT_){
              return caml_call2
                      (Incremental[10],
                       input,
                       function(map){
                        return caml_call1
                                (instrumentation,
                                 function(param){
                                  var
                                   new_nodes =
                                     caml_call5
                                      (Core_Map[85],
                                       prev_map[1],
                                       map,
                                       data_equal$0,
                                       prev_nodes[1],
                                       function(nodes, param){
                                        var changed = param[2], key = param[1], _bU_ = changed[1];
                                        if(847852583 === _bU_){
                                         var
                                          match = caml_call2(Core_Map[43], nodes, key),
                                          right_dep = match[3],
                                          left_dep = match[2],
                                          node = match[1],
                                          nodes$0 = caml_call2(Core_Map[45], nodes, key);
                                         caml_call2(Incremental[79][2][7], left_result, left_dep);
                                         caml_call2(Incremental[79][2][7], right_result, right_dep);
                                         left_acc[1] = caml_call2(Core_Map[45], left_acc[1], key);
                                         right_acc[1] = caml_call2(Core_Map[45], right_acc[1], key);
                                         caml_call1(Incremental[79][2][5], node);
                                         return nodes$0;
                                        }
                                        if(1013247643 <= _bU_){
                                         var node$0 = caml_call2(Core_Map[43], nodes, key)[1];
                                         caml_call1(Incremental[79][2][4], node$0);
                                         return nodes;
                                        }
                                        var
                                         node$1 =
                                           caml_call3
                                            (Incremental[79][2][2],
                                             incremental_state,
                                             0,
                                             function(param){
                                              return caml_call2(Core_Map[43], prev_map[1], key);
                                             });
                                        caml_call2
                                         (Core_Option[42],
                                          cutoff,
                                          function(c){
                                           var _bX_ = caml_call1(Incremental[79][2][3], node$1);
                                           return caml_call2(Incremental[59], _bX_, c);
                                          });
                                        var
                                         _bV_ = caml_call1(Core[242], input_change),
                                         _bW_ = caml_call2(Incremental[79][1][2], 0, _bV_);
                                        caml_call2(Incremental[79][2][6], node$1, _bW_);
                                        var
                                         match$0 =
                                           caml_call2
                                            (f, key, caml_call1(Incremental[79][2][3], node$1)),
                                         right_incr = match$0[2],
                                         left_incr = match$0[1],
                                         left_user_function_dep =
                                           caml_call2
                                            (Incremental[79][1][2],
                                             [0,
                                              function(data){
                                               left_acc[1] =
                                                caml_call3(Core_Map[36], left_acc[1], key, data);
                                               return 0;
                                              }],
                                             left_incr),
                                         right_user_function_dep =
                                           caml_call2
                                            (Incremental[79][1][2],
                                             [0,
                                              function(data){
                                               right_acc[1] =
                                                caml_call3(Core_Map[36], right_acc[1], key, data);
                                               return 0;
                                              }],
                                             right_incr);
                                        caml_call2
                                         (Incremental[79][2][6], left_result, left_user_function_dep);
                                        caml_call2
                                         (Incremental[79][2][6],
                                          right_result,
                                          right_user_function_dep);
                                        return caml_call3
                                                (Core_Map[36],
                                                 nodes,
                                                 key,
                                                 [0, node$1, left_user_function_dep, right_user_function_dep]);
                                       });
                                  prev_nodes[1] = new_nodes;
                                  prev_map[1] = map;
                                  return 0;
                                 });
                       });
             }]);
          var
           _bN_ = caml_call1(Core[242], input_change),
           _bO_ = caml_call2(Incremental[79][1][2], 0, _bN_);
          caml_call2(Incremental[79][2][6], left_result, _bO_);
          var
           _bP_ = caml_call1(Core[242], input_change),
           _bQ_ = caml_call2(Incremental[79][1][2], 0, _bP_);
          caml_call2(Incremental[79][2][6], right_result, _bQ_);
          var
           _bR_ = caml_call1(Incremental[79][2][3], right_result),
           _bS_ = [0, caml_call1(Incremental[79][2][3], left_result), _bR_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _bS_);
         }),
     _bK_ = caml_call2(Incremental[10], pair, function(_bM_){return _bM_[2];});
    return [0,
            caml_call2(Incremental[10], pair, function(_bL_){return _bL_[1];}),
            _bK_];
   }
   function keys(opt, map){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              function add(key, param, acc){
               return caml_call2(Core_Set[12], acc, key);
              }
              function remove(key, param, acc){
               return caml_call2(Core_Set[13], acc, key);
              }
              function data_equal(_bJ_, param){return 1;}
              return unordered_fold
                      (instrumentation,
                       [0, data_equal],
                       0,
                       0,
                       0,
                       _b_,
                       map,
                       caml_call1(Core_Set[3][1], comparator),
                       add,
                       remove);
             });
   }
   function partition_mapi(opt, data_equal, map, f){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              var empty = caml_call1(Core_Map[118][1], comparator);
              return unordered_fold
                      (instrumentation,
                       data_equal,
                       [0,
                        function(key, _bG_, data, param){
                         var
                          second = param[2],
                          first = param[1],
                          match = caml_call2(f, key, data);
                         if(0 === match[0]){
                          var
                           data$0 = match[1],
                           _bH_ = caml_call2(Core_Map[45], second, key);
                          return [0,
                                  caml_call3(Core_Map[36], first, key, data$0),
                                  _bH_];
                         }
                         var
                          data$1 = match[1],
                          _bI_ = caml_call3(Core_Map[36], second, key, data$1);
                         return [0, caml_call2(Core_Map[45], first, key), _bI_];
                        }],
                       0,
                       0,
                       _c_,
                       map,
                       [0, empty, empty],
                       function(key, data, param){
                        var
                         second = param[2],
                         first = param[1],
                         match = caml_call2(f, key, data);
                        if(0 === match[0]){
                         var data$0 = match[1];
                         return [0,
                                 caml_call3(Core_Map[35], first, key, data$0),
                                 second];
                        }
                        var data$1 = match[1];
                        return [0,
                                first,
                                caml_call3(Core_Map[35], second, key, data$1)];
                       },
                       function(key, _bE_, param){
                        var
                         second = param[2],
                         first = param[1],
                         _bF_ = caml_call2(Core_Map[45], second, key);
                        return [0, caml_call2(Core_Map[45], first, key), _bF_];
                       });
             });
   }
   function partition_mapi$0(instrumentation, cutoff, data_equal, map, f){
    return partition_mapi
            (instrumentation,
             0,
             mapi$0(instrumentation, cutoff, data_equal, map, f),
             function(param, data){return data;});
   }
   function flatten(state, map){
    var
     _bC_ = caml_call1(Core_Map[2], map),
     result = [0, caml_call1(Core_Map[118][1], _bC_)],
     node =
       caml_call3
        (Incremental[79][2][2], state, 0, function(param){return result[1];});
    caml_call2
     (Core_Map[49],
      map,
      function(key, incr){
       var
        _bD_ =
          caml_call2
           (Incremental[79][1][2],
            [0,
             function(a){
              result[1] = caml_call3(Core_Map[36], result[1], key, a);
              return 0;
             }],
            incr);
       return caml_call2(Incremental[79][2][6], node, _bD_);
      });
    return caml_call1(Incremental[79][2][3], node);
   }
   function join(opt, map_incr){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator$0
            (map_incr,
             function(comparator){
              var
               incremental_state = caml_call1(Incremental[4], map_incr),
               empty_map = caml_call1(Core_Map[118][1], comparator),
               result_map = [0, empty_map],
               old_map_of_incrs = [0, empty_map],
               current_dependencies = [0, empty_map],
               result =
                 caml_call3
                  (Incremental[79][2][2],
                   incremental_state,
                   0,
                   function(param){return result_map[1];});
              function add_subnode(current_dependencies, key, data_node){
               var
                new_dep =
                  caml_call2
                   (Incremental[79][1][2],
                    [0,
                     function(data){
                      result_map[1] =
                       caml_call3(Core_Map[36], result_map[1], key, data);
                      return 0;
                     }],
                    data_node);
               caml_call2(Incremental[79][2][6], result, new_dep);
               return caml_call3
                       (Core_Map[36], current_dependencies, key, new_dep);
              }
              function remove_subnode(current_dependencies, key){
               var dep = caml_call2(Core_Map[43], current_dependencies, key);
               caml_call2(Incremental[79][2][7], result, dep);
               result_map[1] = caml_call2(Core_Map[45], result_map[1], key);
               return caml_call2(Core_Map[45], current_dependencies, key);
              }
              var
               lhs_change =
                 caml_call2
                  (Incremental[10],
                   map_incr,
                   function(map_of_incrs){
                    return caml_call1
                            (instrumentation,
                             function(param){
                              var
                               new_dependency_map =
                                 caml_call5
                                  (Core_Map[85],
                                   old_map_of_incrs[1],
                                   map_of_incrs,
                                   function(_bB_, _bA_){return _bB_ === _bA_ ? 1 : 0;},
                                   current_dependencies[1],
                                   function(current_dependencies, param){
                                    var diff = param[2], key = param[1], _bz_ = diff[1];
                                    if(847852583 === _bz_)
                                     return remove_subnode(current_dependencies, key);
                                    if(1013247643 <= _bz_){
                                     var data_node = diff[2][2];
                                     return add_subnode
                                             (remove_subnode(current_dependencies, key), key, data_node);
                                    }
                                    var data_node$0 = diff[2];
                                    return add_subnode(current_dependencies, key, data_node$0);
                                   });
                              current_dependencies[1] = new_dependency_map;
                              old_map_of_incrs[1] = map_of_incrs;
                              return 0;
                             });
                   }),
               _by_ = caml_call2(Incremental[79][1][2], 0, lhs_change);
              caml_call2(Incremental[79][2][6], result, _by_);
              return caml_call1(Incremental[79][2][3], result);
             });
   }
   function separate(opt, input_map, data_equal){
    var
     instrumentation = opt ? opt[1] : no_instrumentation,
     incremental_state = caml_call1(Incremental[4], input_map);
    return with_comparator$0
            (input_map,
             function(comparator){
              var
               empty = caml_call1(Core_Map[118][1], comparator),
               state = [0, empty, empty, empty],
               output_map_node =
                 caml_call3
                  (Incremental[79][2][2],
                   incremental_state,
                   0,
                   function(param){return state[3];});
              function make_node_depend_on_input_map_(node, input_map_changed){
               var
                _bx_ = caml_call1(Core_Lazy[32], input_map_changed),
                dependency = caml_call2(Incremental[79][1][2], 0, _bx_);
               return caml_call2(Incremental[79][2][6], node, dependency);
              }
              var input_map_changed = [];
              caml_update_dummy
               (input_map_changed,
                [246,
                 function(_bq_){
                  return caml_call2
                          (Incremental[10],
                           input_map,
                           function(input_map){
                            return caml_call1
                                    (instrumentation,
                                     function(param){
                                      var
                                       prev_input_map = state[1],
                                       match =
                                         caml_call5
                                          (Core_Map[85],
                                           prev_input_map,
                                           input_map,
                                           data_equal,
                                           [0, state[2], state[3]],
                                           function(_br_, param){
                                            var
                                             change = param[2],
                                             key = param[1],
                                             output_map = _br_[2],
                                             expert_nodes = _br_[1],
                                             _bs_ = change[1];
                                            if(847852583 === _bs_){
                                             var old_node = caml_call2(Core_Map[43], expert_nodes, key);
                                             caml_call1(Incremental[79][2][5], old_node);
                                             caml_call1(Incremental[79][2][4], output_map_node);
                                             var _bt_ = caml_call2(Core_Map[45], output_map, key);
                                             return [0,
                                                     caml_call2(Core_Map[45], expert_nodes, key),
                                                     _bt_];
                                            }
                                            if(1013247643 <= _bs_){
                                             var _bu_ = caml_call2(Core_Map[43], expert_nodes, key);
                                             caml_call1(Incremental[79][2][4], _bu_);
                                             return [0, expert_nodes, output_map];
                                            }
                                            var
                                             node =
                                               caml_call3
                                                (Incremental[79][2][2],
                                                 incremental_state,
                                                 0,
                                                 function(param){
                                                  return caml_call2(Core_Map[43], state[1], key);
                                                 });
                                            make_node_depend_on_input_map_(node, input_map_changed);
                                            caml_call1(Incremental[79][2][4], output_map_node);
                                            var
                                             _bv_ = caml_call1(Incremental[79][2][3], node),
                                             _bw_ = caml_call3(Core_Map[35], output_map, key, _bv_);
                                            return [0,
                                                    caml_call3(Core_Map[35], expert_nodes, key, node),
                                                    _bw_];
                                           }),
                                       output_map = match[2],
                                       expert_nodes = match[1];
                                      state[1] = input_map;
                                      state[2] = expert_nodes;
                                      state[3] = output_map;
                                      return 0;
                                     });
                           });
                 }]);
              make_node_depend_on_input_map_
               (output_map_node, input_map_changed);
              return caml_call1(Incremental[79][2][3], output_map_node);
             });
   }
   function subrange(_ba_, opt, map_incr, range){
    var
     instrumentation = _ba_ ? _ba_[1] : no_instrumentation,
     data_equal =
       opt ? opt[1] : function(_bp_, _bo_){return _bp_ === _bo_ ? 1 : 0;};
    return with_old2
            (instrumentation,
             map_incr,
             range,
             function(old, map, range){
              var compare = caml_call1(Core_Map[2], map)[1];
              function equal(l, r){
               var _bn_ = caml_call2(compare, l, r);
               return caml_call2(Core[89], _bn_, 0);
              }
              function maybe_bound_equal(a_008, b_009){
               if(a_008 === b_009) return 1;
               if(typeof a_008 === "number"){
                if(typeof b_009 === "number") return 1;
                if(1 === b_009[0]) return 0;
               }
               else{
                if(0 === a_008[0]){
                 var a_010 = a_008[1];
                 if(typeof b_009 !== "number" && 0 === b_009[0]){
                  var b_011 = b_009[1];
                  return equal(a_010, b_011);
                 }
                 return 0;
                }
                var a_012 = a_008[1];
                if(typeof b_009 === "number") return 0;
                if(0 !== b_009[0]){
                 var b_013 = b_009[1];
                 return equal(a_012, b_013);
                }
               }
               return 0;
              }
              function range_is_empty(min, max){
               a:
               if(typeof min !== "number"){
                if(0 === min[0]){
                 var min$0 = min[1];
                 if(typeof max === "number") break a;
                 if(0 === max[0]){
                  var
                   max$0 = max[1],
                   _bk_ = caml_call2(compare, min$0, max$0);
                  return caml_call2(Core[90], _bk_, 0);
                 }
                 var max$1 = max[1], min$1 = min$0;
                }
                else{
                 var _bm_ = min[1];
                 if(typeof max === "number") break a;
                 var max$1 = max[1], min$1 = _bm_;
                }
                var _bl_ = caml_call2(compare, min$1, max$1);
                return caml_call2(Core[87], _bl_, 0);
               }
               return 0;
              }
              function range_includes(min, max, key){
               var _bj_ = caml_call3(Core_Maybe_bound[19], min, key, compare);
               return _bj_
                       ? caml_call3(Core_Maybe_bound[20], max, key, compare)
                       : _bj_;
              }
              if(! range){
               var _bc_ = caml_call1(Core_Map[2], map);
               return caml_call1(Core_Map[118][1], _bc_);
              }
              var range$0 = range[1], max = range$0[2], min = range$0[1];
              function from_scratch(param){
               return caml_call3(Core_Map[101], map, min, max);
              }
              if(old){
               var _bb_ = old[1], match = _bb_[2];
               if(match){
                var
                 old_range = match[1],
                 old_min = old_range[1],
                 old_map = _bb_[1],
                 old_max = old_range[2];
                if
                 (!
                  range_is_empty(old_min, old_max)
                  &&
                   !
                   range_is_empty(min, old_max)
                   && ! range_is_empty(old_min, max)){
                 var old_res = _bb_[3], old_max$0 = old_range[2];
                 return caml_call1
                         (Core[262],
                          function(param){
                           function apply_diff_in_intersection(_bg_, param$0){
                            var
                             data = param$0[2],
                             key = param$0[1],
                             map = _bg_[2],
                             outside = _bg_[1],
                             _bf_ = range_includes(min, max, key),
                             _bh_ = _bf_ ? range_includes(old_min, old_max$0, key) : _bf_;
                            if(! _bh_){
                             var outside$0 = outside - 1 | 0;
                             return 0 <= outside$0
                                     ? [0, outside$0, caml_call2(Core_Map[45], map, key)]
                                     : caml_call1(param, from_scratch(0));
                            }
                            var _bi_ = data[1];
                            if(847852583 === _bi_)
                             return [0, outside, caml_call2(Core_Map[45], map, key)];
                            var data$0 = 1013247643 <= _bi_ ? data[2][2] : data[2];
                            return [0,
                                    outside,
                                    caml_call3(Core_Map[36], map, key, data$0)];
                           }
                           var
                            outside_cutoff = caml_call1(Core_Map[33], old_res) / 4 | 0,
                            with_updated_values_in_interse =
                              caml_call5
                                (Core_Map[85],
                                 old_map,
                                 map,
                                 data_equal,
                                 [0, outside_cutoff, old_res],
                                 apply_diff_in_intersection)
                               [2];
                           if
                            (caml_call4
                              (Core_Tuple[1][10],
                               maybe_bound_equal,
                               maybe_bound_equal,
                               old_range,
                               range$0))
                            return with_updated_values_in_interse;
                           var
                            without_keys_out_of_range =
                              caml_call3
                               (Core_Map[101], with_updated_values_in_interse, min, max);
                           function map_append_exn(lower_part, upper_part){
                            var
                             match = caml_call2(Core_Map[100], lower_part, upper_part);
                            if(typeof match === "number")
                             return caml_call1(Core[5], cst_impossible_case_BUG_in_inc);
                            var map = match[2];
                            return map;
                           }
                           if(typeof old_min === "number")
                            var
                             _bd_ = caml_call1(Core_Map[2], map),
                             lower_part = caml_call1(Core_Map[118][1], _bd_);
                           else if(0 === old_min[0])
                            var
                             old_min$0 = old_min[1],
                             lower_part =
                               caml_call3(Core_Map[101], map, min, [1, old_min$0]);
                           else
                            var
                             old_min$1 = old_min[1],
                             lower_part =
                               caml_call3(Core_Map[101], map, min, [0, old_min$1]);
                           if(typeof old_max$0 === "number")
                            var
                             _be_ = caml_call1(Core_Map[2], map),
                             upper_part = caml_call1(Core_Map[118][1], _be_);
                           else if(0 === old_max$0[0])
                            var
                             old_max = old_max$0[1],
                             upper_part =
                               caml_call3(Core_Map[101], map, [1, old_max], max);
                           else
                            var
                             old_max$1 = old_max$0[1],
                             upper_part =
                               caml_call3(Core_Map[101], map, [0, old_max$1], max);
                           var
                            with_new_keys_now_in_range =
                              map_append_exn
                               (lower_part,
                                map_append_exn(without_keys_out_of_range, upper_part));
                           return with_new_keys_now_in_range;
                          });
                }
                return from_scratch(0);
               }
              }
              return from_scratch(0);
             });
   }
   function rekey(opt, data_equal, map_incr, outer_comparator, f){
    var
     instrumentation = opt ? opt[1] : no_instrumentation,
     _a8_ =
       unordered_fold
        (instrumentation,
         data_equal,
         [0,
          function(key, old_data, new_data, param){
           var
            adds = param[2],
            output = param[1],
            prev_key = caml_call2(f, key, old_data),
            new_key = caml_call2(f, key, new_data),
            _a$_ =
              caml_call2
               (caml_call1(Core_Map[2], output)[1], prev_key, new_key);
           if(caml_call2(Core[89], _a$_, 0))
            return [0,
                    caml_call3(Core_Map[36], output, new_key, new_data),
                    adds];
           var output$0 = caml_call2(Core_Map[45], output, prev_key);
           return [0, output$0, [0, [0, new_key, new_data], adds]];
          }],
         0,
         [0,
          function(param){
           var
            adds = param[2],
            output = param[1],
            output$0 =
              caml_call3
               (Core_List[20],
                adds,
                output,
                function(output, param){
                 var data = param[2], key = param[1];
                 return caml_call3(Core_Map[35], output, key, data);
                });
           return [0, output$0, 0];
          }],
         _d_,
         map_incr,
         [0, caml_call1(Core_Map[4], outer_comparator), 0],
         function(key, data, param){
          var
           adds = param[2],
           output = param[1],
           new_entry = [0, caml_call2(f, key, data), data];
          return [0, output, [0, new_entry, adds]];
         },
         function(key, data, param){
          var
           adds = param[2],
           output = param[1],
           _a__ = caml_call2(f, key, data);
          return [0, caml_call2(Core_Map[45], output, _a__), adds];
         });
    return caml_call2(Incremental[10], _a8_, function(_a9_){return _a9_[1];});
   }
   function index_byi(opt, data_equal, map_incr, outer_comparator, index){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator$0
            (map_incr,
             function(inner_comparator){
              return unordered_fold
                      (instrumentation,
                       data_equal,
                       0,
                       0,
                       0,
                       _e_,
                       map_incr,
                       caml_call1(Core_Map[4], outer_comparator),
                       function(inner_key, data, outer_map){
                        var match = caml_call2(index, inner_key, data);
                        if(! match) return outer_map;
                        var outer_key = match[1];
                        return caml_call3
                                (Core_Map[41],
                                 outer_map,
                                 outer_key,
                                 function(param){
                                  if(! param)
                                   return caml_call3
                                           (Core_Map[118][2], inner_comparator, inner_key, data);
                                  var inner_map = param[1];
                                  return caml_call3(Core_Map[35], inner_map, inner_key, data);
                                 });
                       },
                       function(inner_key, data, outer_map){
                        var match = caml_call2(index, inner_key, data);
                        if(! match) return outer_map;
                        var outer_key = match[1];
                        return caml_call3
                                (Core_Map[40],
                                 outer_map,
                                 outer_key,
                                 function(param){
                                  if(! param)
                                   return caml_call1(Core[5], cst_BUG_Hit_supposedly_impossi);
                                  var
                                   inner_map = param[1],
                                   inner_map$0 = caml_call2(Core_Map[45], inner_map, inner_key);
                                  return caml_call1(Core_Map[32], inner_map$0)
                                          ? 0
                                          : [0, inner_map$0];
                                 });
                       });
             });
   }
   function index_by(instrumentation, data_equal, map_incr, comparator, index){
    return index_byi
            (instrumentation,
             data_equal,
             map_incr,
             comparator,
             function(param, data){return caml_call1(index, data);});
   }
   function is_known(param){
    if(typeof param === "number" && param) return 0;
    return 1;
   }
   function to_option(param){
    if(typeof param === "number") return 0;
    var k = param[1];
    return [0, k];
   }
   function find_key_range_linear(from, to, map){
    var
     len = caml_call1(Core_Map[33], map),
     begin_key = caml_call2(Core_Int[86], from, len) ? 0 : 1,
     end_key = caml_call2(Core_Int[86], to, len) ? 0 : 1;
    function find_keys(fold, start_pos, advance_pos){
     return caml_call1
             (Core[262],
              function(param){
               return caml_call3
                       (fold,
                        map,
                        [0, begin_key, end_key, start_pos],
                        function(key, _a7_, param$0){
                         var
                          pos = param$0[3],
                          end_key = param$0[2],
                          begin_key = param$0[1],
                          begin_key$0 =
                            caml_call2(Core_Int[88], pos, from) ? [0, key] : begin_key,
                          end_key$0 =
                            caml_call2(Core_Int[88], pos, to) ? [0, key] : end_key;
                         if(is_known(begin_key$0) && is_known(end_key$0))
                          return caml_call1(param, [0, begin_key$0, end_key$0, pos]);
                         return [0,
                                 begin_key$0,
                                 end_key$0,
                                 caml_call1(advance_pos, pos)];
                        });
              });
    }
    var
     match =
       caml_call2(Core[91], to, len - from | 0)
        ? find_keys(Core_Map[59], 0, function(pos){return pos + 1 | 0;})
        : find_keys
          (Core_Map[61], len - 1 | 0, function(pos){return pos - 1 | 0;}),
     end_key$0 = match[2],
     begin_key$0 = match[1],
     _a6_ = to_option(begin_key$0);
    return caml_call2
            (Core_Option[30],
             _a6_,
             function(begin_key){return [0, begin_key, to_option(end_key$0)];});
   }
   function find_offset(compare, key, changed_key, change){
    var _a4_ = caml_call2(compare, changed_key, key);
    if(! caml_call2(Core_Int[90], _a4_, 0)) return 0;
    if(typeof change !== "number"){
     var _a5_ = change[1];
     if(-57574468 === _a5_) return -1;
     if(847852583 === _a5_) return 1;
    }
    return 0;
   }
   function rank(opt, map, key){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              var compare_key = comparator[1];
              function same_key(a, b){
               var _a3_ = caml_call2(compare_key, a, b);
               return caml_call2(Core[89], _a3_, 0);
              }
              function process(old, new_map, new_key){
               var old$0 = old;
               for(;;){
                if(! caml_call2(Core_Map[46], new_map, new_key)) return 0;
                if(old$0){
                 var
                  match = old$0[1],
                  old_rank = match[3],
                  old_key = match[2],
                  old_map = match[1];
                 if(new_map === old_map && same_key(old_key, new_key))
                  return old_rank;
                 if(old_rank){
                  var old_rank$0 = old_rank[1];
                  if(new_map !== old_map){
                   if(same_key(new_key, old_key))
                    return [0,
                            caml_call5
                             (Core_Map[85],
                              old_map,
                              new_map,
                              function(_a2_, param){return 1;},
                              old_rank$0,
                              function(acc, param){
                               var diff = param[2], diff_key = param[1];
                               if(typeof diff !== "number"){
                                var _aZ_ = diff[1];
                                if(-57574468 === _aZ_){
                                 var _a0_ = caml_call2(compare_key, diff_key, new_key);
                                 if(caml_call2(Core[91], _a0_, 0)) return acc + 1 | 0;
                                }
                                else if(847852583 === _aZ_){
                                 var _a1_ = caml_call2(compare_key, diff_key, new_key);
                                 if(caml_call2(Core[91], _a1_, 0)) return acc - 1 | 0;
                                }
                               }
                               return acc;
                              })];
                   var
                    old_rank$1 =
                      process
                       ([0, [0, old_map, old_key, [0, old_rank$0]]],
                        new_map,
                        old_key),
                    old$1 = [0, [0, new_map, old_key, old_rank$1]];
                   old$0 = old$1;
                   continue;
                  }
                  var _aX_ = caml_call2(compare_key, new_key, old_key);
                  if(caml_call2(Core[91], _aX_, 0))
                   var
                    upper_bound = [1, old_key],
                    lower_bound = [1, new_key],
                    subrange =
                      caml_call3(Core_Map[101], new_map, lower_bound, upper_bound),
                    _aY_ =
                      (old_rank$0 - caml_call1(Core_Map[33], subrange) | 0) - 1
                      | 0;
                  else
                   var
                    upper_bound$0 = [1, new_key],
                    lower_bound$0 = [1, old_key],
                    subrange$0 =
                      caml_call3
                       (Core_Map[101], new_map, lower_bound$0, upper_bound$0),
                    _aY_ =
                      (old_rank$0 + caml_call1(Core_Map[33], subrange$0) | 0) + 1
                      | 0;
                  return [0, _aY_];
                 }
                }
                return caml_call2(Core_Map[107], new_map, new_key);
               }
              }
              return with_old2(instrumentation, map, key, process);
             });
   }
   function subrange_by_rank(opt, data_equal, map, range){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    function find_key_range(range){
     return with_old2
             (instrumentation,
              map,
              range,
              function(old, map, param){
               var
                to = param[2],
                from = param[1],
                _aH_ = caml_call2(Core_Int[90], to, from),
                _aI_ = _aH_ || caml_call2(Core_Int[90], from, 0);
               if(_aI_){
                var
                 _aJ_ =
                   [0, [1, [0, _f_, [0, caml_call1(Core[363], to), 0]]], 0],
                 _aK_ =
                   [0,
                    [1, [0, _g_, [0, caml_call1(Core[363], from), 0]]],
                    _aJ_],
                 _aL_ =
                   [1,
                    [0,
                     caml_call1(Sexplib0_Sexp_conv[7], cst_Invalid_indices),
                     _aK_]];
                caml_call1(Core[255], _aL_);
               }
               if(old){
                var _aM_ = old[1], _aN_ = _aM_[3];
                if(_aN_){
                 var
                  _aO_ = _aN_[1],
                  end_key_opt$0 = _aO_[2],
                  begin_key = _aO_[1],
                  match = _aM_[2],
                  old_to = match[2],
                  old_from = match[1],
                  old_map = _aM_[1],
                  _aP_ = caml_call1(Core_Map[2], map)[1],
                  range_offset_begin = from - old_from | 0,
                  range_offset_end = to - old_to | 0,
                  adjust_and_offset =
                    function(by$1, key$1){
                     a:
                     {
                      if
                       (caml_call2(Core[87], by$1, 0)
                        && ! caml_call2(Core_Map[46], map, key$1)){var _aW_ = 1; break a;}
                      var _aW_ = 0;
                     }
                     var by$2 = by$1 + _aW_ | 0, key = key$1, by = by$2;
                     for(;;){
                      if(caml_call2(Core_Int[88], by, 0)) return [0, key];
                      if(caml_call2(Core_Int[90], by, 0))
                       var add = 1, closest_dir = -640801497;
                      else
                       var add = -1, closest_dir = -779285466;
                      var
                       match = caml_call3(Core_Map[104], map, closest_dir, key);
                      if(! match) return 0;
                      var key$0 = match[1][1], by$0 = by + add | 0;
                      key = key$0;
                      by = by$0;
                     }
                    },
                  diff =
                    function(init, f){
                     return caml_call5
                             (Core_Map[85],
                              old_map,
                              map,
                              function(_aV_, param){return 1;},
                              init,
                              f);
                    };
                 if(end_key_opt$0)
                  var
                   end_key = end_key_opt$0[1],
                   match$0 =
                     diff
                      (_h_,
                       function(_aS_, param){
                        var
                         change = param[2],
                         key = param[1],
                         offset_end = _aS_[2],
                         offset_begin = _aS_[1],
                         _aT_ =
                           offset_end + find_offset(_aP_, end_key, key, change) | 0;
                        return [0,
                                offset_begin + find_offset(_aP_, begin_key, key, change) | 0,
                                _aT_];
                       }),
                   map_offset_end = match$0[2],
                   map_offset_begin = match$0[1],
                   end_key_opt$1 =
                     adjust_and_offset
                      (map_offset_end + range_offset_end | 0, end_key),
                   end_key_opt$2 = end_key_opt$1,
                   begin_key_opt =
                     adjust_and_offset
                      (map_offset_begin + range_offset_begin | 0, begin_key);
                 else
                  var
                   map_offset_begin$0 =
                     diff
                      (0,
                       function(offset_begin, param){
                        var change = param[2], key = param[1];
                        return offset_begin
                               + find_offset(_aP_, begin_key, key, change)
                               | 0;
                       }),
                   _aG_ = find_key_range_linear(to, to, map),
                   end_key_opt =
                     caml_call2
                      (Core_Option[30], _aG_, function(_aU_){return _aU_[1];}),
                   begin_key_opt$0 =
                     adjust_and_offset
                      (map_offset_begin$0 + range_offset_begin | 0, begin_key),
                   end_key_opt$2 = end_key_opt,
                   begin_key_opt = begin_key_opt$0;
                 var _aQ_ = caml_call1(Core_Map[46], map);
                 if(! caml_call2(Core_Option[44], begin_key_opt, _aQ_))
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _j_], 1);
                 var _aR_ = caml_call1(Core_Map[46], map);
                 if(caml_call2(Core_Option[44], end_key_opt$2, _aR_))
                  return caml_call2
                          (Core_Option[30],
                           begin_key_opt,
                           function(begin_key){return [0, begin_key, end_key_opt$2];});
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _i_], 1);
                }
               }
               return find_key_range_linear(from, to, map);
              });
    }
    function symbol(new$0, bound){
     return caml_call2
             (Core_Maybe_bound[18], bound, function(param){return new$0;});
    }
    var
     _aw_ = caml_call1(Incremental[4], map),
     return$0 = caml_call1(Incremental[9], _aw_),
     _ax_ =
       caml_call2
        (Incremental[76][3][5],
         range,
         function(param){
          return typeof param[1] === "number"
                  ? typeof param[2] === "number" ? 0 : 3
                  : typeof param[2] === "number" ? 2 : 1;
         }),
     key_range =
       caml_call2
        (Incremental[76][3][1],
         _ax_,
         function(param){
          if(3 < param >>> 0)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
          switch(param){
            case 0:
             return caml_call1(return$0, _l_);
            case 1:
             var
              l =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var _aF_ = param[1];
                   if(typeof _aF_ !== "number"){
                    var pattern_syntax_014 = _aF_[1];
                    if(typeof param[2] !== "number") return pattern_syntax_014;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _m_], 1);
                  }),
              lb =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var pattern_syntax_015 = param[1];
                   if
                    (typeof pattern_syntax_015 !== "number"
                     && typeof param[2] !== "number")
                    return pattern_syntax_015;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _n_], 1);
                  }),
              u =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] !== "number"){
                    var match = param[2];
                    if(typeof match !== "number"){
                     var pattern_syntax_016 = match[1];
                     return pattern_syntax_016;
                    }
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _o_], 1);
                  }),
              ub =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] !== "number"){
                    var pattern_syntax_017 = param[2];
                    if(typeof pattern_syntax_017 !== "number")
                     return pattern_syntax_017;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _p_], 1);
                  }),
              let_syntax_022 =
                find_key_range(caml_call2(Incremental[40], l, u)),
              _ay_ = caml_call2(Incremental[76][3][20], lb, ub),
              _az_ = caml_call2(Incremental[76][3][20], let_syntax_022, _ay_);
             return caml_call2
                     (Incremental[76][3][5],
                      _az_,
                      function(param){
                       var
                        match = param[2],
                        ub = match[2],
                        lb = match[1],
                        key_range = param[1];
                       if(! key_range) return 0;
                       var
                        _aD_ = key_range[1],
                        match$0 = _aD_[2],
                        begin_key = _aD_[1];
                       if(! match$0) return [0, [0, symbol(begin_key, lb), 0]];
                       var end_key = match$0[1], _aE_ = symbol(end_key, ub);
                       return [0, [0, symbol(begin_key, lb), _aE_]];
                      });
            case 2:
             var
              l$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var _aC_ = param[1];
                   if(typeof _aC_ !== "number"){
                    var pattern_syntax_018 = _aC_[1];
                    if(typeof param[2] === "number") return pattern_syntax_018;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _q_], 1);
                  }),
              lb$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var pattern_syntax_019 = param[1];
                   if
                    (typeof pattern_syntax_019 !== "number"
                     && typeof param[2] === "number")
                    return pattern_syntax_019;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _r_], 1);
                  }),
              let_syntax_026 =
                find_key_range(caml_call2(Incremental[40], l$0, l$0)),
              _aA_ = caml_call2(Incremental[76][3][20], let_syntax_026, lb$0);
             return caml_call2
                     (Incremental[76][3][5],
                      _aA_,
                      function(param){
                       var lb = param[2], key_range = param[1];
                       if(! key_range) return 0;
                       var key = key_range[1][1];
                       return [0, [0, symbol(key, lb), 0]];
                      });
            default:
             var
              u$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] === "number"){
                    var match = param[2];
                    if(typeof match !== "number"){
                     var pattern_syntax_020 = match[1];
                     return pattern_syntax_020;
                    }
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _s_], 1);
                  }),
              ub$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] === "number"){
                    var pattern_syntax_021 = param[2];
                    if(typeof pattern_syntax_021 !== "number")
                     return pattern_syntax_021;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _t_], 1);
                  }),
              let_syntax_029 =
                find_key_range(caml_call2(Incremental[40], u$0, u$0)),
              _aB_ = caml_call2(Incremental[76][3][20], let_syntax_029, ub$0);
             return caml_call2
                     (Incremental[76][3][5],
                      _aB_,
                      function(param){
                       var ub = param[2], key_range = param[1];
                       if(! key_range) return _u_;
                       var key = key_range[1][1];
                       return [0, [0, 0, symbol(key, ub)]];
                      });
          }
         });
    return subrange(0, data_equal, map, key_range);
   }
   function transpose(_am_, opt, k2_comparator, m){
    var
     instrumentation = _am_ ? _am_[1] : no_instrumentation,
     data_equal =
       opt ? opt[1] : function(_av_, _au_){return _av_ === _au_ ? 1 : 0;};
    return with_comparator$0
            (m,
             function(k1_comparator){
              function update(k1, old_data, new_data, acc){
               return caml_call5
                       (Core_Map[85],
                        old_data,
                        new_data,
                        data_equal,
                        acc,
                        function(acc, param){
                         var diff = param[2], k2 = param[1], _ar_ = diff[1];
                         if(847852583 === _ar_)
                          var value = 0;
                         else
                          var
                           x = 1013247643 <= _ar_ ? diff[2][2] : diff[2],
                           value = [0, x];
                         return caml_call3
                                 (Core_Map[40],
                                  acc,
                                  k2,
                                  function(acc_inner){
                                   var
                                    _as_ = caml_call1(Core_Map[118][1], k1_comparator),
                                    _at_ = caml_call2(Core_Option[35], acc_inner, _as_),
                                    acc_inner$0 =
                                      caml_call3
                                       (Core_Map[40], _at_, k1, function(param){return value;});
                                   return caml_call1(Core_Map[32], acc_inner$0)
                                           ? 0
                                           : [0, acc_inner$0];
                                  });
                        });
              }
              function add(key, data){
               var _ap_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_aq_){return update(key, _ap_, data, _aq_);};
              }
              function remove(key, data){
               var _an_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_ao_){return update(key, data, _an_, _ao_);};
              }
              return unordered_fold
                      (instrumentation,
                       0,
                       [0, update],
                       0,
                       0,
                       _v_,
                       m,
                       caml_call1(Core_Map[4], k2_comparator),
                       add,
                       remove);
             });
   }
   function collapse_by(opt, data_equal, map_incr, merge_keys, comparator){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return unordered_fold_nested_maps
            (instrumentation,
             data_equal,
             _w_,
             [0,
              function(outer_key, inner_key, param, new_data, acc){
               var _al_ = caml_call2(merge_keys, outer_key, inner_key);
               return caml_call3(Core_Map[36], acc, _al_, new_data);
              }],
             map_incr,
             caml_call1(Core_Map[4], comparator),
             function(outer_key, inner_key, data, acc){
              var _ak_ = caml_call2(merge_keys, outer_key, inner_key);
              return caml_call3(Core_Map[35], acc, _ak_, data);
             },
             function(outer_key, inner_key, param, acc){
              var _aj_ = caml_call2(merge_keys, outer_key, inner_key);
              return caml_call2(Core_Map[45], acc, _aj_);
             });
   }
   function collapse(instrumentation, data_equal, map_incr, inner_comparator){
    return with_comparator$0
            (map_incr,
             function(outer_comparator){
              var
               inner_comparator$0 = inner_comparator[1],
               comparator =
                 caml_call2
                  (Core_Tuple[1][5], outer_comparator, inner_comparator$0);
              return collapse_by
                      (instrumentation,
                       data_equal,
                       map_incr,
                       Core_Tuple[1][6],
                       [0, comparator]);
             });
   }
   function expand
   (opt, data_equal, map_incr, outer_comparator, inner_comparator){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return unordered_fold
            (instrumentation,
             data_equal,
             [0,
              function(_ai_, param, new_data, acc){
               var inner_key = _ai_[2], outer_key = _ai_[1];
               return caml_call3
                       (Core_Map[41],
                        acc,
                        outer_key,
                        function(param){
                         if(! param)
                          return caml_call3
                                  (Core_Map[5], inner_comparator, inner_key, new_data);
                         var map = param[1];
                         return caml_call3(Core_Map[36], map, inner_key, new_data);
                        });
              }],
             0,
             0,
             _x_,
             map_incr,
             caml_call1(Core_Map[4], outer_comparator),
             function(param, data, acc){
              var inner_key = param[2], outer_key = param[1];
              return caml_call3
                      (Core_Map[41],
                       acc,
                       outer_key,
                       function(param){
                        if(! param)
                         return caml_call3
                                 (Core_Map[5], inner_comparator, inner_key, data);
                        var map = param[1];
                        return caml_call3(Core_Map[35], map, inner_key, data);
                       });
             },
             function(_ag_, param, acc){
              var inner_key = _ag_[2], outer_key = _ag_[1];
              return caml_call3
                      (Core_Map[40],
                       acc,
                       outer_key,
                       function(param){
                        if(! param) return 0;
                        var
                         map = param[1],
                         map$0 = caml_call2(Core_Map[45], map, inner_key),
                         _ah_ = 1 - caml_call1(Core_Map[32], map$0);
                        return caml_call2(Core_Option[56], _ah_, map$0);
                       });
             });
   }
   function counti(opt, data_equal, map_incr, f){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return unordered_fold
            (instrumentation,
             data_equal,
             0,
             0,
             0,
             _y_,
             map_incr,
             0,
             function(key, data, count){
              return caml_call2(f, key, data) ? count + 1 | 0 : count;
             },
             function(key, data, count){
              return caml_call2(f, key, data) ? count - 1 | 0 : count;
             });
   }
   function count(instrumentation, data_equal, map_incr, f){
    return counti
            (instrumentation,
             data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function existsi(instrumentation, data_equal, map_incr, f){
    var _af_ = counti(instrumentation, data_equal, map_incr, f);
    return caml_call2
            (Incremental[10],
             _af_,
             function(count){return caml_call2(Core[92], count, 0);});
   }
   function exists(instrumentation, data_equal, map_incr, f){
    return existsi
            (instrumentation,
             data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function sum(opt, data_equal, map_incr, Group, f){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return unordered_fold
            (instrumentation,
             data_equal,
             0,
             0,
             0,
             _z_,
             map_incr,
             Group[1],
             function(param, v, acc){
              var _ae_ = caml_call1(f, v);
              return caml_call2(Group[2], acc, _ae_);
             },
             function(param, v, acc){
              var _ad_ = caml_call1(f, v);
              return caml_call2(Group[3], acc, _ad_);
             });
   }
   function for_alli(instrumentation, data_equal, map_incr, f){
    var
     _ac_ =
       counti
        (instrumentation,
         data_equal,
         map_incr,
         function(key, data){return 1 - caml_call2(f, key, data);});
    return caml_call2
            (Incremental[10],
             _ac_,
             function(count){return caml_call2(Core[89], count, 0);});
   }
   function for_all(instrumentation, data_equal, map_incr, f){
    return for_alli
            (instrumentation,
             data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function unordered_fold$0
   (opt,
    data_equal,
    update,
    specialized_initial,
    finalize,
    revert_to_init_when_empty,
    map,
    init,
    add,
    remove){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return unordered_fold
            (instrumentation,
             data_equal,
             update,
             specialized_initial,
             finalize,
             revert_to_init_when_empty,
             map,
             init,
             add,
             remove);
   }
   function unordered_fold_nested_maps$0
   (opt,
    data_equal,
    revert_to_init_when_empty,
    update,
    map,
    init,
    add,
    remove){
    var instrumentation = opt ? opt[1] : no_instrumentation;
    return unordered_fold_nested_maps
            (instrumentation,
             data_equal,
             revert_to_init_when_empty,
             update,
             map,
             init,
             add,
             remove);
   }
   var
    For_testing = [0, find_key_range_linear],
    _A_ = [0, "node_is_unnecessary"],
    _B_ = [0, "node_is_invalid"],
    _C_ = [0, "node_is_const"],
    _D_ = [0, "node_info"],
    _E_ = [0, "saved_value"],
    _F_ = [0, "entries"],
    _G_ = [0, "actual_value"],
    _H_ = [0, "key"];
   function M(K){return [0];}
   function create(_V_, opt, input_map, comparator){
    var
     instrumentation = _V_ ? _V_[1] : no_instrumentation,
     data_equal =
       opt ? opt[1] : function(_ab_, _aa_){return _ab_ === _aa_ ? 1 : 0;},
     self = [];
    caml_update_dummy
     (self,
      [246,
       function(param){
        var
         updater_node =
           caml_call2
            (Incremental[10],
             input_map,
             function(input_map){
              return caml_call1
                      (instrumentation,
                       function(param){
                        var _Y_ = caml_obj_tag(self);
                        a:
                        if(250 === _Y_)
                         var self$0 = self[1];
                        else{
                         if(246 !== _Y_ && 244 !== _Y_){var self$0 = self; break a;}
                         var self$0 = caml_call1(CamlinternalLazy[2], self);
                        }
                        caml_call5
                         (Core_Map[85],
                          self$0[1],
                          input_map,
                          data_equal,
                          0,
                          function(_Z_, param){
                           var
                            changed_value = param[2],
                            key = param[1],
                            entries = caml_call2(Core_Map[39], self$0[2], key);
                           return caml_call2
                                   (Core_List[19],
                                    entries,
                                    function(entry){
                                     var ___ = changed_value[1];
                                     if(847852583 === ___)
                                      var _$_ = 0;
                                     else
                                      var
                                       new_value =
                                         1013247643 <= ___ ? changed_value[2][2] : changed_value[2],
                                       _$_ = [0, new_value];
                                     entry[1] = _$_;
                                     return caml_call1(Incremental[79][2][4], entry[2]);
                                    });
                          });
                        self$0[1] = input_map;
                        return 0;
                       });
             }),
         empty_map = caml_call1(Core_Map[118][1], comparator),
         _X_ = caml_call1(Incremental[4], input_map);
        return [0,
                empty_map,
                empty_map,
                updater_node,
                caml_call2(Incremental[50][2], _X_, 0)];
       }]);
    var _W_ = caml_obj_tag(self);
    if(250 === _W_) return self[1];
    if(246 !== _W_ && 244 !== _W_) return self;
    return caml_call1(CamlinternalLazy[2], self);
   }
   function find(t, key){
    var match = caml_call2(Core_Map[39], t[2], key);
    if(match){
     var entry = match[1];
     return caml_call1(Incremental[79][2][3], entry[2]);
    }
    var incremental_state = caml_call1(Incremental[4], t[3]);
    return caml_call3
            (Incremental[50][3],
             incremental_state,
             t[4],
             function(param){
              var entry = [];
              caml_update_dummy
               (entry,
                [246,
                 function(param){
                  var
                   _R_ =
                     caml_call3
                      (Incremental[79][2][2],
                       incremental_state,
                       [0,
                        function(is_now_observable){
                         var _S_ = caml_obj_tag(entry);
                         a:
                         if(250 === _S_)
                          var entry$0 = entry[1];
                         else{
                          if(246 !== _S_ && 244 !== _S_){var entry$0 = entry; break a;
                          }
                          var entry$0 = caml_call1(CamlinternalLazy[2], entry);
                         }
                         var
                          current_entries = caml_call2(Core_Map[39], t[2], key),
                          is_linked =
                            caml_call2
                             (Core_List[23],
                              current_entries,
                              function(_U_){return entry$0 === _U_ ? 1 : 0;});
                         if(caml_call2(Core_Bool[28], is_linked, is_now_observable))
                          return 0;
                         if(is_now_observable){
                          t[2] =
                           caml_call3
                            (Core_Map[41],
                             t[2],
                             key,
                             function(param){
                              if(param){
                               var other_entries = param[1];
                               if(other_entries){
                                var other_entry = other_entries[1];
                                entry$0[1] = other_entry[1];
                                return [0, entry$0, other_entries];
                               }
                              }
                              entry$0[1] = caml_call2(Core_Map[42], t[1], key);
                              return [0, entry$0, 0];
                             });
                          return 0;
                         }
                         var
                          new_entries =
                            caml_call2
                             (Core_List[11],
                              current_entries,
                              function(x){return 1 - (entry$0 === x ? 1 : 0);}),
                          _T_ =
                            caml_call1(Core_List[18], new_entries)
                             ? caml_call2(Core_Map[45], t[2], key)
                             : caml_call3(Core_Map[36], t[2], key, new_entries);
                         t[2] = _T_;
                         return 0;
                        }],
                       function(param){return caml_call1(Core[242], entry)[1];});
                  return [0, caml_call2(Core_Map[42], t[1], key), _R_];
                 }]);
              var _P_ = caml_obj_tag(entry);
              a:
              if(250 === _P_)
               var entry$0 = entry[1];
              else{
               if(246 !== _P_ && 244 !== _P_){var entry$0 = entry; break a;}
               var entry$0 = caml_call1(CamlinternalLazy[2], entry);
              }
              var _Q_ = caml_call2(Incremental[79][1][2], 0, t[3]);
              caml_call2(Incremental[79][2][6], entry$0[2], _Q_);
              return caml_call1(Incremental[79][2][3], entry$0[2]);
             });
   }
   function sexp_of_t(sexp_of_key, sexp_of_value, t){
    var
     info_per_key =
       caml_call3
        (Core_Map[81],
         t[1],
         t[2],
         function(key, data){
          var _I_ = data[1];
          if(737457313 === _I_)
           var
            match = data[2],
            entries = match[2],
            x = match[1],
            actual_value = [0, x],
            entries$0 = entries,
            actual_value$0 = actual_value;
          else if(847852583 <= _I_)
           var x$0 = data[2], entries$0 = 0, actual_value$0 = [0, x$0];
          else
           var y = data[2], entries$0 = y, actual_value$0 = 0;
          var
           match$0 =
             [0,
              [1,
               [0,
                _F_,
                [0,
                 caml_call2
                  (Core[431],
                   function(entry){
                    var
                     saved_value = entry[1],
                     node = entry[2],
                     node$0 = caml_call1(Incremental[79][2][3], node),
                     match = caml_call1(Incremental[67], node$0),
                     _K_ = caml_call1(Incremental[5], node$0),
                     match$0 = caml_call2(Core_Option[56], _K_, 0),
                     _L_ = 1 - caml_call1(Incremental[6], node$0),
                     match$1 = caml_call2(Core_Option[56], _L_, 0),
                     _M_ = 1 - caml_call1(Incremental[7], node$0),
                     _N_ = caml_call2(Core_Option[56], _M_, 0),
                     match$2 = 0;
                    if(_N_)
                     var
                      v = _N_[1],
                      match$3 =
                        [0,
                         [1, [0, _A_, [0, caml_call1(Core[534], v), 0]]],
                         match$2];
                    else
                     var match$3 = match$2;
                    if(match$1)
                     var
                      v$0 = match$1[1],
                      match$4 =
                        [0,
                         [1, [0, _B_, [0, caml_call1(Core[534], v$0), 0]]],
                         match$3];
                    else
                     var match$4 = match$3;
                    if(match$0)
                     var
                      v$1 = match$0[1],
                      match$5 =
                        [0,
                         [1, [0, _C_, [0, caml_call1(Core[534], v$1), 0]]],
                         match$4];
                    else
                     var match$5 = match$4;
                    if(match)
                     var
                      v$2 = match[1],
                      _O_ =
                        [0,
                         [1, [0, _D_, [0, caml_call1(Core_Info[6], v$2), 0]]],
                         match$5];
                    else
                     var _O_ = match$5;
                    return [1,
                            [0,
                             [1,
                              [0,
                               _E_,
                               [0, caml_call2(Core[466], sexp_of_value, saved_value), 0]]],
                             _O_]];
                   },
                   entries$0),
                 0]]],
              0];
          if(actual_value$0)
           var
            v = actual_value$0[1],
            _J_ =
              [0,
               [1, [0, _G_, [0, caml_call1(sexp_of_value, v), 0]]],
               match$0];
          else
           var _J_ = match$0;
          return [0,
                  [1,
                   [0,
                    [1, [0, _H_, [0, caml_call1(sexp_of_key, key), 0]]],
                    _J_]]];
         });
    return [1, caml_call1(Core_Map[77], info_per_key)];
   }
   caml_call1(Ppx_inline_test_lib[6], cst_incr_map);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map);
   var
    Incr_map =
      [0,
       of_set,
       filter_mapi,
       mapi,
       filter_map,
       map,
       filter_mapi$0,
       map$0,
       filter_map$0,
       mapi$0,
       partition_mapi,
       partition_mapi$0,
       unordered_fold$0,
       unordered_fold_with_extra,
       cutoff,
       mapi_count,
       map_count,
       mapi_min,
       mapi_max,
       map_min,
       map_max,
       min_value,
       max_value,
       mapi_bounds,
       map_bounds,
       value_bounds,
       merge,
       merge_both_some,
       merge$0,
       unzip,
       unzip_mapi,
       unzip_mapi$0,
       flatten,
       join,
       separate,
       keys,
       rank,
       subrange,
       subrange_by_rank,
       rekey,
       index_byi,
       index_by,
       unordered_fold_nested_maps$0,
       transpose,
       collapse,
       collapse_by,
       expand,
       counti,
       count,
       for_alli,
       for_all,
       existsi,
       exists,
       sum,
       [0, create, find, M, [0, sexp_of_t]],
       For_testing,
       function(Incr){
        function flatten$0(x){return flatten(Incr[2][3], x);}
        function M(K){return [0];}
        return [0,
                of_set,
                filter_mapi,
                mapi,
                filter_map,
                map,
                filter_mapi$0,
                mapi$0,
                filter_map$0,
                map$0,
                partition_mapi,
                partition_mapi$0,
                unordered_fold$0,
                unordered_fold_with_extra,
                cutoff,
                mapi_count,
                map_count,
                mapi_min,
                mapi_max,
                map_min,
                map_max,
                min_value,
                max_value,
                mapi_bounds,
                map_bounds,
                value_bounds,
                merge,
                merge_both_some,
                unzip,
                unzip_mapi,
                unzip_mapi$0,
                merge$0,
                flatten$0,
                join,
                separate,
                keys,
                rank,
                subrange,
                subrange_by_rank,
                rekey,
                index_byi,
                index_by,
                unordered_fold_nested_maps$0,
                transpose,
                collapse,
                collapse_by,
                expand,
                counti,
                count,
                for_alli,
                for_all,
                existsi,
                exists,
                sum,
                [0, create, find, M, [0, sexp_of_t]],
                For_testing];
       }];
   runtime.caml_register_global(65, Incr_map, cst_Incr_map);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5jcl9tYXAuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImluY3JfbWFwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJJbmNyX21hcCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImluY3JfbWFwLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfSW5jcl9tYXBfSW5jcl9tYXBfaW50ZiIsImNzdF9pbmNyX21hcCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlBweF9tb2R1bGVfdGltZXJfcnVudGltZSIsIlBweF9iZW5jaF9saWJfQmVuY2htYXJrX2FjY3VtdSIsIkV4cGVjdF90ZXN0X2NvbGxlY3RvciIsIlBweF9pbmxpbmVfdGVzdF9saWIiLCJJbnN0cnVtZW50YXRpb24iLCJJbmNyX21hcF9JbmNyX21hcF9pbnRmIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2luY3JfbWFwL2luY3JfbWFwX2ludGYubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsR0NBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFDLGtCQUFBO0FBQUEsR0FzdENHO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUMseUJBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHR0Q0giLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIENvcmVcblxubW9kdWxlIEluc3RydW1lbnRhdGlvbiA9IHN0cnVjdFxuICAoKiogQWxsIFtJbmNyX21hcF0gZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgW2luc3RydW1lbnRhdGlvbl0gcGFyYW1ldGVyIHRoYXQgaGFzIHR5cGVcbiAgICAgIFtJbnN0cnVtZW50YXRpb24udF0uICBBIHZhbHVlIG9mIHRoaXMgdHlwZSBpcyBhIHJlY29yZCBjb250YWluaW5nIGEgZnVuY3Rpb24gd2hpY2hcbiAgICAgIGlzIHBvbHltb3JwaGljIG92ZXIgYSB1bml2ZXJzYWxseS1xdWFudGlmaWVkIHR5cGUgWydhXS4gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWRcbiAgICAgIGEgW3VuaXQgLT4gJ2FdIGZ1bmN0aW9uLCB3aGljaCBtdXN0IGJlIGltbWVkaWF0ZWx5IGV4ZWN1dGVkLCBhbmQgdGhlIHJlc3VsdCBvZlxuICAgICAgd2hpY2ggbXVzdCBiZSByZXR1cm5lZC5cblxuICAgICAgVGhlIGZ1bmN0aW9uIHBhc3NlZCB0byB0aGUgaW5zdHJ1bWVudG9yIHdpbGwgYmUgZG9pbmcgdGhlIGJ1bGsgb2YgdGhlIHdvcmsgZm9yIHRoZVxuICAgICAgW0luY3JfbWFwXSBmdW5jdGlvbiBpbiBxdWVzdGlvbiAodXN1YWxseSBhIFtNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZl0pLlxuXG4gICAgICBZb3UgbWF5IHdhbnQgdG8gdXNlIHRoZSBJbnN0cnVtZW50YXRpb24gQVBJIHRvIGFzc2lzdCBpbiBwZXJmb3JtYW5jZSBwcm9maWxpbmcgbGlrZVxuICAgICAgc286XG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBwcm9maWxlIG5hbWUgPVxuICAgICAgICAgIHsgSW5jcl9tYXAuSW5zdHJ1bWVudGF0aW9uLmYgPSBmdW4gZiAtPlxuICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gVGltZS5ub3cgKCkgaW5cbiAgICAgICAgICAgICAgbGV0IHIgPSBmICgpIGluXG4gICAgICAgICAgICAgIGxldCBhZnRlciA9IFRpbWUubm93ICgpIGluXG4gICAgICAgICAgICAgIGxldCBkZWx0YSA9IFRpbWUuc3ViIGFmdGVyIGJlZm9yZSBpblxuICAgICAgICAgICAgICBwcmludGYgXCIlcyB0b29rICVzXCIgbmFtZSAoVGltZS5TcGFuLnRvX3N0cmluZ19odW0gZGVsdGEpO1xuICAgICAgICAgICAgICByXG4gICAgICAgICAgfVxuICAgICAgICA7O1xuXG4gICAgICAgIEluY3JfbWFwLm1hcCB+aW5zdHJ1bWVudGF0aW9uOihwcm9maWxlIFwiZm9vXCIpIH5mOm1hcF9mb29cbiAgICAgIF19ICopXG5cbiAgdHlwZSB0ID0geyBmIDogJ2EuICh1bml0IC0+ICdhKSAtPiAnYSB9IFtAQHVuYm94ZWRdXG5lbmRcblxuKCoqIFtTX2dlbl0gaXMgdGhlIHR5cGUgb2YgdGhlIG1vZHVsZSByZXR1cm5lZCBieSBbSW5jcl9tYXAuTWFrZV0uICBJdCBpcyBhIHNwZWNpYWxpemF0aW9uXG4gICAgb2YgdGhlIGludGVyZmFjZSBvZiBbSW5jcl9tYXBdLCB3aXRoOlxuXG4gICAgLSB0aGUgWyd3XSBzdGF0ZV93aXRuZXNzIHR5cGUgcGFyYW1ldGVyIHJlbW92ZWRcbiAgICAtIHRoZSBbSW5jcmVtZW50YWwuU3RhdGUudF0gYXJndW1lbnQgcmVtb3ZlZFxuXG4gICAgVGhlIGNvbW1lbnRzIGZvciBjb21wb25lbnRzIG9mIFtTX2dlbl0gYXJlIGluIFttb2R1bGUgdHlwZSBJbmNyX21hcF0gYmVsb3cuICopXG5tb2R1bGUgdHlwZSBTX2dlbiA9IHNpZ1xuICBtb2R1bGUgSW5jciA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgbW9kdWxlIEN1dG9mZiA6IHNpZ1xuICAgICAgdHlwZSAnYSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBJbnN0cnVtZW50YXRpb24gPSBJbnN0cnVtZW50YXRpb25cblxuICB2YWwgb2Zfc2V0XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ICgnaywgJ2NtcCkgU2V0LnQgSW5jci50XG4gICAgLT4gKCdrLCB1bml0LCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBtYXBpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgbWFwXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KCd2MSAtPiAndjIpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBmaWx0ZXJfbWFwaSdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondjEgSW5jci5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSBJbmNyLnQgLT4gJ3YyIG9wdGlvbiBJbmNyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBtYXBpJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIEluY3IudCAtPiAndjIgSW5jci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgZmlsdGVyX21hcCdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondjEgSW5jci5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KCd2MSBJbmNyLnQgLT4gJ3YyIG9wdGlvbiBJbmNyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBtYXAnXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9jdXRvZmY6J3YxIEluY3IuQ3V0b2ZmLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOigndjEgSW5jci50IC0+ICd2MiBJbmNyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoKCdrLCAndjIsICdjbXApIE1hcC50ICogKCdrLCAndjMsICdjbXApIE1hcC50KSBJbmNyLnRcblxuICB2YWwgcGFydGl0aW9uX21hcGknXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9jdXRvZmY6J3YxIEluY3IuQ3V0b2ZmLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgSW5jci50IC0+ICgndjIsICd2MykgRWl0aGVyLnQgSW5jci50KVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgKiAoJ2ssICd2MywgJ2NtcCkgTWFwLnQpIEluY3IudFxuXG4gIHZhbCB1bm9yZGVyZWRfZm9sZFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiA/dXBkYXRlOihrZXk6J2sgLT4gb2xkX2RhdGE6J3YgLT4gbmV3X2RhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ID9zcGVjaWFsaXplZF9pbml0aWFsOihpbml0OidhY2MgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgLT4gJ2FjYylcbiAgICAtPiA/ZmluYWxpemU6KCdhY2MgLT4gJ2FjYylcbiAgICAtPiA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTpib29sXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gYWRkOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gcmVtb3ZlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjYyBJbmNyLnRcblxuICB2YWwgdW5vcmRlcmVkX2ZvbGRfd2l0aF9leHRyYVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiA/ZXh0cmFfZXF1YWw6KCdleHRyYSAtPiAnZXh0cmEgLT4gYm9vbClcbiAgICAtPiA/dXBkYXRlOihrZXk6J2sgLT4gb2xkX2RhdGE6J3YgLT4gbmV3X2RhdGE6J3YgLT4gJ2FjYyAtPiAnZXh0cmEgLT4gJ2FjYylcbiAgICAtPiA/c3BlY2lhbGl6ZWRfaW5pdGlhbDooaW5pdDonYWNjIC0+ICgnaywgJ3YsICdlKSBNYXAudCAtPiAnZXh0cmEgLT4gJ2FjYylcbiAgICAtPiA/ZmluYWxpemU6KCdhY2MgLT4gJ2FjYylcbiAgICAtPiA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTpib29sXG4gICAgLT4gKCdrLCAndiwgJ2UpIE1hcC50IEluY3IudFxuICAgIC0+ICdleHRyYSBJbmNyLnRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBhZGQ6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2V4dHJhIC0+ICdhY2MpXG4gICAgLT4gcmVtb3ZlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+IGV4dHJhX2NoYW5nZWQ6XG4gICAgICAgICAob2xkX2V4dHJhOidleHRyYVxuICAgICAgICAgIC0+IG5ld19leHRyYTonZXh0cmFcbiAgICAgICAgICAtPiBpbnB1dDooJ2ssICd2LCAnZSkgTWFwLnRcbiAgICAgICAgICAtPiAnYWNjXG4gICAgICAgICAgLT4gJ2FjYylcbiAgICAtPiAnYWNjIEluY3IudFxuXG4gIHZhbCBjdXRvZmZcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gY3V0b2ZmOid2IEluY3JlbWVudGFsLkN1dG9mZi50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIG1hcGlfY291bnRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOignazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrMSAtPiBkYXRhOid2IC0+ICdrMilcbiAgICAtPiAoJ2syLCBpbnQsICdjbXAyKSBNYXAudCBJbmNyLnRcblxuICB2YWwgbWFwX2NvdW50XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KCd2IC0+ICdrMilcbiAgICAtPiAoJ2syLCBpbnQsICdjbXAyKSBNYXAudCBJbmNyLnRcblxuICB2YWwgbWFwaV9taW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAncilcbiAgICAtPiAnciBvcHRpb24gSW5jci50XG5cbiAgdmFsIG1hcGlfbWF4XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ3IpXG4gICAgLT4gJ3Igb3B0aW9uIEluY3IudFxuXG4gIHZhbCBtYXBfbWluXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooJ3YgLT4gJ3IpXG4gICAgLT4gJ3Igb3B0aW9uIEluY3IudFxuXG4gIHZhbCBtYXBfbWF4XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooJ3YgLT4gJ3IpXG4gICAgLT4gJ3Igb3B0aW9uIEluY3IudFxuXG4gIHZhbCBtaW5fdmFsdWVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3YsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBvcHRpb24gSW5jci50XG5cbiAgdmFsIG1heF92YWx1ZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOigndiwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IG9wdGlvbiBJbmNyLnRcblxuICB2YWwgbWFwaV9ib3VuZHNcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAncilcbiAgICAtPiAoJ3IgKiAncikgb3B0aW9uIEluY3IudFxuXG4gIHZhbCBtYXBfYm91bmRzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooJ3YgLT4gJ3IpXG4gICAgLT4gKCdyICogJ3IpIG9wdGlvbiBJbmNyLnRcblxuICB2YWwgdmFsdWVfYm91bmRzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGNvbXBhcmF0b3I6KCd2LCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCd2ICogJ3YpIG9wdGlvbiBJbmNyLnRcblxuICB2YWwgbWVyZ2VcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWxfbGVmdDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9kYXRhX2VxdWFsX3JpZ2h0OigndjIgLT4gJ3YyIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNYXAuTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pXG4gICAgLT4gKCdrLCAndjMsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBtZXJnZV9ib3RoX3NvbWVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWxfbGVmdDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9kYXRhX2VxdWFsX3JpZ2h0OigndjIgLT4gJ3YyIC0+IGJvb2wpXG4gICAgLT4gP291dF9lcXVhbDooJ3YzIC0+ICd2MyAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+ICd2MSAtPiAndjIgLT4gJ3YzKVxuICAgIC0+ICgnaywgJ3YzLCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgdW56aXBcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2xlZnRfcmVzdWx0X2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gP3JpZ2h0X3Jlc3VsdF9lcXVhbDooJ3YyIC0+ICd2MiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxICogJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50ICogKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCB1bnppcF9tYXBpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID9sZWZ0X3Jlc3VsdF9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9yaWdodF9yZXN1bHRfZXF1YWw6KCd2MiAtPiAndjIgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAndjEgKiAndjIpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudCAqICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgdW56aXBfbWFwaSdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondiBJbmNyLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgSW5jci50IC0+ICd2MSBJbmNyLnQgKiAndjIgSW5jci50KVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnQgKiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIG1lcmdlJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOigndjEsICd2MikgTWFwLk1lcmdlX2VsZW1lbnQudCBJbmNyLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWxfbGVmdDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9kYXRhX2VxdWFsX3JpZ2h0OigndjIgLT4gJ3YyIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNYXAuTWVyZ2VfZWxlbWVudC50IEluY3IudCAtPiAndjMgb3B0aW9uIEluY3IudClcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIGZsYXR0ZW4gOiAoJ2ssICd2IEluY3IudCwgJ2NtcCkgTWFwLnQgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIGpvaW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCdrLCAndiBJbmNyLnQsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBzZXBhcmF0ZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YgSW5jci50LCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwga2V5c1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoJ2ssICd2LCAnYykgTWFwLnQgSW5jci50XG4gICAgLT4gKCdrLCAnYykgU2V0LnQgSW5jci50XG5cbiAgdmFsIHJhbmtcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgQmFzZS5NYXAudCBJbmNyLnRcbiAgICAtPiAnayBJbmNyLnRcbiAgICAtPiBpbnQgb3B0aW9uIEluY3IudFxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2sgTWF5YmVfYm91bmQuQXNfbG93ZXJfYm91bmQudCAqICdrIE1heWJlX2JvdW5kLkFzX3VwcGVyX2JvdW5kLnQpIG9wdGlvbiBJbmNyLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgc3VicmFuZ2VfYnlfcmFua1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoaW50IE1heWJlX2JvdW5kLkFzX2xvd2VyX2JvdW5kLnQgKiBpbnQgTWF5YmVfYm91bmQuQXNfdXBwZXJfYm91bmQudCkgSW5jci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIHJla2V5XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonazEgLT4gZGF0YTondiAtPiAnazIpXG4gICAgLT4gKCdrMiwgJ3YsICdjbXAyKSBNYXAudCBJbmNyLnRcblxuICB2YWwgaW5kZXhfYnlpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaW5uZXJfa2V5LCAndiwgJ2lubmVyX2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ291dGVyX2tleSwgJ291dGVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGluZGV4OihrZXk6J2lubmVyX2tleSAtPiBkYXRhOid2IC0+ICdvdXRlcl9rZXkgb3B0aW9uKVxuICAgIC0+ICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgaW5kZXhfYnlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOignb3V0ZXJfa2V5LCAnb3V0ZXJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaW5kZXg6KCd2IC0+ICdvdXRlcl9rZXkgb3B0aW9uKVxuICAgIC0+ICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gP3JldmVydF90b19pbml0X3doZW5fZW1wdHk6Ym9vbFxuICAgIC0+ID91cGRhdGU6XG4gICAgICAgICAob3V0ZXJfa2V5OidvdXRlcl9rZXlcbiAgICAgICAgICAtPiBpbm5lcl9rZXk6J2lubmVyX2tleVxuICAgICAgICAgIC0+IG9sZF9kYXRhOid2XG4gICAgICAgICAgLT4gbmV3X2RhdGE6J3ZcbiAgICAgICAgICAtPiAnYWNjXG4gICAgICAgICAgLT4gJ2FjYylcbiAgICAtPiAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gYWRkOihvdXRlcl9rZXk6J291dGVyX2tleSAtPiBpbm5lcl9rZXk6J2lubmVyX2tleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiByZW1vdmU6KG91dGVyX2tleTonb3V0ZXJfa2V5IC0+IGlubmVyX2tleTonaW5uZXJfa2V5IC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICdhY2MgSW5jci50XG5cbiAgdmFsIHRyYW5zcG9zZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2syLCAnazJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgKCdrMiwgJ3YsICdrMl9jbXApIE1hcC50LCAnazFfY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2syLCAoJ2sxLCAndiwgJ2sxX2NtcCkgTWFwLnQsICdrMl9jbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBjb2xsYXBzZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ2lubmVyX2tleSwgJ2lubmVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICggJ291dGVyX2tleSAqICdpbm5lcl9rZXlcbiAgICAgICAsICd2XG4gICAgICAgLCAoJ291dGVyX2NtcCwgJ2lubmVyX2NtcCkgVHVwbGUyLmNvbXBhcmF0b3Jfd2l0bmVzcyApXG4gICAgICAgICBNYXAudFxuICAgICAgICAgSW5jci50XG5cbiAgdmFsIGNvbGxhcHNlX2J5XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBtZXJnZV9rZXlzOignb3V0ZXJfa2V5IC0+ICdpbm5lcl9rZXkgLT4gJ2NvbWJpbmVkX2tleSlcbiAgICAtPiBjb21wYXJhdG9yOignY29tYmluZWRfa2V5LCAnY29tYmluZWRfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdjb21iaW5lZF9rZXksICd2LCAnY29tYmluZWRfY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgZXhwYW5kXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnb3V0ZXJfa2V5ICogJ2lubmVyX2tleSwgJ3YsICd0dXBsZV9jbXApIE1hcC50IEluY3IudFxuICAgIC0+IG91dGVyX2NvbXBhcmF0b3I6KCdvdXRlcl9rZXksICdvdXRlcl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpbm5lcl9jb21wYXJhdG9yOignaW5uZXJfa2V5LCAnaW5uZXJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdvdXRlcl9rZXksICgnaW5uZXJfa2V5LCAndiwgJ2lubmVyX2NtcCkgTWFwLnQsICdvdXRlcl9jbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBjb3VudGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAtPiBpbnQgSW5jci50XG5cbiAgdmFsIGNvdW50XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+IChfLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiBpbnQgSW5jci50XG5cbiAgdmFsIGZvcl9hbGxpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gYm9vbCBJbmNyLnRcblxuICB2YWwgZm9yX2FsbFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoXywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gYm9vbCBJbmNyLnRcblxuICB2YWwgZXhpc3RzaVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+IGJvb2wgSW5jci50XG5cbiAgdmFsIGV4aXN0c1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoXywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gYm9vbCBJbmNyLnRcblxuICB2YWwgc3VtXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+IChfLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gKG1vZHVsZSBBYnN0cmFjdF9hbGdlYnJhLkNvbW11dGF0aXZlX2dyb3VwLldpdGhvdXRfc2V4cCB3aXRoIHR5cGUgdCA9ICd1KVxuICAgIC0+IGY6KCd2IC0+ICd1KVxuICAgIC0+ICd1IEluY3IudFxuXG4gIG1vZHVsZSBMb29rdXAgOiBzaWdcbiAgICB0eXBlICgnaywgJ3YsICdjbXApIHRcblxuICAgIHZhbCBjcmVhdGVcbiAgICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgICAtPiBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICB2YWwgZmluZCA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgLT4gJ3Ygb3B0aW9uIEluY3IudFxuXG4gICAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICAgICAgdHlwZSB0XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgICBlbmQpIDogc2lnXG4gICAgICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnIDogc2lnXG4gICAgICB2YWwgc2V4cF9vZl90IDogKCdrIC0+IFNleHAudCkgLT4gKCd2IC0+IFNleHAudCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBTZXhwLnRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIEZvcl90ZXN0aW5nIDogc2lnXG4gICAgdmFsIGZpbmRfa2V5X3JhbmdlX2xpbmVhclxuICAgICAgOiAgZnJvbTppbnRcbiAgICAgIC0+IHRvXzppbnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSBCYXNlLk1hcC50XG4gICAgICAtPiAoJ2EgKiAnYSBvcHRpb24pIG9wdGlvblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmNyX21hcCA9IHNpZ1xuICAoKiogRnVuY3Rpb25zIGZvciB1c2luZyBtYXBzIGVmZmljaWVudGx5IHdpdGhpbiBJbmNyZW1lbnRhbC4gIFRoZSBnb2FsIG9mIHRoZSBhbGdvcml0aG1zXG4gICAgICBoZXJlIGlzIHRvIGRvIHdvcmsgb24gdGhlIG91dHB1dCBvZiB0aGUgY29tcHV0YXRpb24gcHJvcG9ydGlvbmFsIHRvIHRoZSBhbW91bnQgb2ZcbiAgICAgIHdvcmsgZG9uZSBvbiB0aGUgaW5wdXQuICBpLmUuLCBba10gbW9kaWZpY2F0aW9ucyB0byB0aGUgaW5wdXQgbWFwIGZvciBzb21lXG4gICAgICBjb21wdXRhdGlvbiB3aWxsIHJlc3VsdCBpbiBba10gbW9kaWZpY2F0aW9ucyB0byB0aGUgb3V0cHV0IG1hcC4gIFRoZSBjaGFuZ2VzIHRvIHRoZVxuICAgICAgaW5wdXQgbWFwIGFyZSB0eXBpY2FsbHkgY29tcHV0ZWQgdXNpbmcgW01hcC5zeW1tZXRyaWNfZGlmZl0uXG5cbiAgICAgIFVubGVzcyBzdGF0ZWQgb3RoZXJ3aXNlLCB0aGUgbm9uLWluY3JlbWVudGFsIHNlbWFudGljcyBvZiB0aGVzZSBmdW5jdGlvbnMgKGkuZS4uLFxuICAgICAgaWdub3JpbmcgcGVyZm9ybWFuY2UpIGlzIHRoZSBzYW1lIGFzIHRoZSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uIGluIENvcmUncyBbTWFwXVxuICAgICAgbW9kdWxlLiAgKilcblxuICBtb2R1bGUgSW5zdHJ1bWVudGF0aW9uID0gSW5zdHJ1bWVudGF0aW9uXG5cbiAgdmFsIG9mX3NldFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoKCdrLCAnY21wKSBTZXQudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrLCB1bml0LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndjEsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIG1hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndjEsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooJ3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgbWFwXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigndjEgLT4gJ3YyKVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIGZpbHRlcl9tYXBpJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTooJ3YxLCAndykgSW5jcmVtZW50YWwudCAtPiAoJ3YyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgbWFwJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigoJ3YxLCAndykgSW5jcmVtZW50YWwudCAtPiAoJ3YyLCAndykgSW5jcmVtZW50YWwudClcbiAgICAtPiAoKCdrLCAndjIsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gIHZhbCBmaWx0ZXJfbWFwJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigoJ3YxLCAndykgSW5jcmVtZW50YWwudCAtPiAoJ3YyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgbWFwaSdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondjEgSW5jcmVtZW50YWwuQ3V0b2ZmLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3cpIEluY3JlbWVudGFsLnQgLT4gKCd2MiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndjEsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgKiAoJ2ssICd2MywgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOlxuICAgICAgICAgKGtleTona1xuICAgICAgICAgIC0+IGRhdGE6KCd2MSwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAoKCd2MiwgJ3YzKSBFaXRoZXIudCwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCAqICgnaywgJ3YzLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW3Vub3JkZXJlZF9mb2xkIGkgfmluaXQgfmFkZCB+cmVtb3ZlXSBjb25zdHJ1Y3RzIGEgbW9yZSBpbmNyZW1lbnRhbCB2ZXJzaW9uIG9mOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQlbWFwIG0gPSBpIGluXG4gICAgICAgIE1hcC5mb2xkIG0gfmluaXQgfmY6YWRkXG4gICAgICBdfVxuXG4gICAgICBhc3N1bWluZyB0aGF0IFtyZW1vdmVdIGlzIHRoZSBpbnZlcnNlIG9mIFthZGRdLCBhbmQgdGhhdCB0aGUgb3BlcmF0aW9ucyBmb3JcbiAgICAgIGRpZmZlcmVudCBrZXlzIGNhbiBiZSBwZXJmb3JtZWQgaW4gYW55IG9yZGVyLiBOb3RlIHRoYXQgW2RhdGFfZXF1YWxdIGRlZmF1bHRzXG4gICAgICB0byBbcGh5c19lcXVhbF0sIGJ1dCBhIG1vcmUgcHJlY2lzZSBlcXVhbGl0eSBjYW4gYmUgcHJvdmlkZWQgaW5zdGVhZC5cblxuICAgICAgV2hlbiB0aGUgZGF0YSBmb3IgYSBrZXkgdXBkYXRlcywgYnkgZGVmYXVsdCBbcmVtb3ZlXSBpcyBjYWxsZWQgb24gdGhlIG9sZCBkYXRhXG4gICAgICBhbmQgdGhlbiBbYWRkXSBpcyBjYWxsZWQgb24gdGhlIG5ldyBkYXRhLlxuICAgICAgW3VwZGF0ZV0gcHJvdmlkZXMgYW4gYWx0ZXJuYXRpdmUgc2luZ2xlIGZ1bmN0aW9uIHRvIGNhbGwgZWFjaCB0aW1lIGEga2V5J3MgZGF0YVxuICAgICAgdXBkYXRlcywgYW5kIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgZWZmaWNpZW5jeS5cblxuICAgICAgRm9yIHRoZSBpbml0aWFsIGNvbXB1dGF0aW9uLCBieSBkZWZhdWx0IFthZGRdIGlzIGNhbGxlZCBvbiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZVxuICAgICAgbWFwLiBBcyB0aGlzIGNhbiBiZSBpbmVmZmljaWVudCwgW3NwZWNpYWxpemVkX2luaXRpYWxdIGNhbiBiZSBwcm92aWRlZCB0byBwZXJmb3JtXG4gICAgICB0aGUgY29tcHV0YXRpb24gaW4gYSBtb3JlIGVmZmVjdGl2ZSB3YXkuXG5cbiAgICAgIElmIFtyZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XSBpcyB0cnVlLCB0aGVuIGlmIHRoZSBpbnB1dCBtYXAgdHJhbnNpdGlvbnMgZnJvbVxuICAgICAgYmVpbmcgZnVsbCB0byBlbXB0eSwgdGhlbiBpbnN0ZWFkIG9mIGNhbGxpbmcgW3JlbW92ZV0gb24gZXZlcnkga3YtcGFpciwgaXQgd2lsbFxuICAgICAgaW5zdGVhZCBqdXN0IHNldCB0aGUgb3V0cHV0IHRvIHdoYXRldmVyIHlvdSd2ZSBwYXNzZWQgYXMgW2luaXRdLlxuICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgb2YgW3JldmVydF90b19pbml0X3doZW5fZW1wdHldIGlzIFtmYWxzZV0sIHNvIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgICBkb2VzIG5vdCBhcHBseSBhdXRvbWF0aWNhbGx5LlxuXG4gICAgICBbZmluYWxpemVdIGRlZmF1bHRzIHRvIFtGbi5pZF0gaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgYWNjdW11bGF0b3IgdmFsdWVcbiAgICAgIGlzIHN0b3JlZCBhbmQgcmV0dXJuZWQgZHVyaW5nIHN0YWJpbGl6YXRpb24uICBZb3UgY2FuIHVzZSBpdCB0byBlLmcuIHByb2Nlc3MgdGhlXG4gICAgICBmb2xkIG9wZXJhdGlvbnMgaW4gYSBkaWZmZXJlbnQgb3JkZXIuICopXG4gIHZhbCB1bm9yZGVyZWRfZm9sZFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiA/dXBkYXRlOihrZXk6J2sgLT4gb2xkX2RhdGE6J3YgLT4gbmV3X2RhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ID9zcGVjaWFsaXplZF9pbml0aWFsOihpbml0OidhY2MgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgLT4gJ2FjYylcbiAgICAtPiA/ZmluYWxpemU6KCdhY2MgLT4gJ2FjYylcbiAgICAtPiA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTpib29sXG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGFkZDooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+IHJlbW92ZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICgnYWNjLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbdW5vcmRlcmVkX2ZvbGRfd2l0aF9leHRyYV0gaXMgc2ltaWxhciB0byBbdW5vcmRlcmVkX2ZvbGRdLCBidXQgaXQgYWxzb1xuICAgICAgZGVwZW5kcyBvbiBhbm90aGVyIGFyYml0cmFyeSBpbmNyZW1lbnRhbCB2YWx1ZSB3aGljaCBjYW4gYmUgZmFjdG9yZWQgaW50b1xuICAgICAgdGhlIGZvbGRpbmcgY29tcHV0YXRpb24uICopXG4gIHZhbCB1bm9yZGVyZWRfZm9sZF93aXRoX2V4dHJhXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID9leHRyYV9lcXVhbDooJ2V4dHJhIC0+ICdleHRyYSAtPiBib29sKVxuICAgIC0+ID91cGRhdGU6KGtleTonayAtPiBvbGRfZGF0YTondiAtPiBuZXdfZGF0YTondiAtPiAnYWNjIC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+ID9zcGVjaWFsaXplZF9pbml0aWFsOihpbml0OidhY2MgLT4gKCdrLCAndiwgJ2UpIE1hcC50IC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+ID9maW5hbGl6ZTooJ2FjYyAtPiAnYWNjKVxuICAgIC0+ID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OmJvb2xcbiAgICAtPiAoKCdrLCAndiwgJ2UpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgnZXh0cmEsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gYWRkOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+IHJlbW92ZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnZXh0cmEgLT4gJ2FjYylcbiAgICAtPiBleHRyYV9jaGFuZ2VkOlxuICAgICAgICAgKG9sZF9leHRyYTonZXh0cmFcbiAgICAgICAgICAtPiBuZXdfZXh0cmE6J2V4dHJhXG4gICAgICAgICAgLT4gaW5wdXQ6KCdrLCAndiwgJ2UpIE1hcC50XG4gICAgICAgICAgLT4gJ2FjY1xuICAgICAgICAgIC0+ICdhY2MpXG4gICAgLT4gKCdhY2MsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFtjdXRvZmZdIGFwcGxpZXMgYSBjdXRvZmYgdG8gdmFsdWVzIGluIHRoZSBtYXAgYXMgdGhleSBwYXNzIHRocm91Z2ggdGhlXG4gICAgICBmdW5jdGlvbi4gIEl0IGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBjYWxsaW5nIFtJbmNyX21hcC5tYXAnXSB3aXRoIGFuXG4gICAgICBbSW5jci5zZXRfY3V0b2ZmXSBpbnNpZGUsIGJ1dCB3aXRoIGNvbnNpZGVyYWJseSBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kXG4gICAgICBtZW1vcnkgdXNhZ2UuICopXG4gIHZhbCBjdXRvZmZcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGN1dG9mZjondiBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogR2l2ZW4gYW4gaW5wdXQgbWFwIGFuZCBhIGZ1bmN0aW9uIG1hcHBpbmcgYSBrdi1wYWlyIHRvIGEgbmV3XG4gICAgICB2YWx1ZSwgW21hcGlfY291bnRdIHdpbGwgY29tcHV0ZSBhIG11bHRpLXNldCBrZXllZCBvbiB0aGF0XG4gICAgICBuZXcgdmFsdWUuXG5cbiAgICAgIEFueSB2YWx1ZSB0aGF0IHdvdWxkIG90aGVyd2lzZSBoYXZlIGEgY291bnQgb2YgXCIwXCIgaXMgaW5zdGVhZFxuICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG5cbiAgICAgIEl0IGlzIGFzc3VtZWQgdGhhdCBbZl0gaXMgcXVpdGUgZmFzdCBhcyB0aGUgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAgY2FsbGVkIG1vcmUgb2Z0ZW4gdGhhbiBzdHJpY3RseSBuZWNlc3NhcnksIGJ1dCBpdCBkb2VzIHRoaXNcbiAgICAgIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpbmcgYW4gZXh0cmEgbWFwLiAgSWYgW2ZdIGlzIHZlcnkgc2xvd1xuICAgICAgYW5kIHlvdSBkb24ndCBtaW5kIHRoZSBleHRyYSBhbGxvY2F0aW9ucywgdXNlXG4gICAgICBbSW5jcl9tYXAuaW5kZXhfYnlpXSBjb21wb3NlZCB3aXRoIFtJbmNyX21hcC5tYXAgfmY6TWFwLmxlbmd0aF0gKilcbiAgdmFsIG1hcGlfY291bnRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnazEsICd2LCAnY21wMSkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonazEgLT4gZGF0YTondiAtPiAnazIpXG4gICAgLT4gKCgnazIsIGludCwgJ2NtcDIpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBUaGUgc2FtZSBhcyBbbWFwaV9jb3VudF0gYnV0IHRoZSBbZl0gZnVuY3Rpb24gb25seSBnZXRzIHRvIHNlZSB0aGVcbiAgICAgIGRhdGEgaW5zdGVhZCBvZiBib3RoIHRoZSBrZXkgYW5kIHRoZSBkYXRhLiAqKVxuICB2YWwgbWFwX2NvdW50XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2sxLCAndiwgJ2NtcDEpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAnazIpXG4gICAgLT4gKCgnazIsIGludCwgJ2NtcDIpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBDb21wdXRlcyB0aGUgc21hbGxlc3QgW3JdIHdoZXJlIFtyXSBpcyBjb21wdXRlZCBmb3IgZWFjaCBrdi1wYWlyIGluIHRoZVxuICAgICAgaW5wdXQgbWFwLiAqKVxuICB2YWwgbWFwaV9taW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ3IpXG4gICAgLT4gKCdyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIGxhcmdlc3QgW3JdIHdoZXJlIFtyXSBpcyBjb21wdXRlZCBmb3IgZWFjaCBrdi1wYWlyIGluIHRoZVxuICAgICAgaW5wdXQgbWFwLiAqKVxuICB2YWwgbWFwaV9tYXhcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ3IpXG4gICAgLT4gKCdyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIHNtYWxsZXN0IFtyXSB3aGVyZSBbcl0gaXMgY29tcHV0ZWQgZm9yIGVhY2gga3YtcGFpciBpbiB0aGVcbiAgICAgIGlucHV0IG1hcC4gKilcbiAgdmFsIG1hcF9taW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooJ3YgLT4gJ3IpXG4gICAgLT4gKCdyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIGxhcmdlc3QgW3JdIHdoZXJlIFtyXSBpcyBjb21wdXRlZCBmb3IgZWFjaCBrdi1wYWlyIGluIHRoZVxuICAgICAgaW5wdXQgbWFwLiAqKVxuICB2YWwgbWFwX21heFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAncilcbiAgICAtPiAoJ3Igb3B0aW9uLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBDb21wdXRlcyB0aGUgc21hbGxlc3QgZGF0YSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBtYXAuICopXG4gIHZhbCBtaW5fdmFsdWVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCd2LCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIGxhcmdlc3QgZGF0YSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBtYXAuICopXG4gIHZhbCBtYXhfdmFsdWVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCd2LCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgW21pbiAqIG1heF0gd2hlcmUgdGhlIHZhbHVlIGlzIGNvbXB1dGVkIGZvciBlYWNoIGt2LXBhaXJcbiAgICAgIGluIHRoZSBpbnB1dCBtYXAgKilcbiAgdmFsIG1hcGlfYm91bmRzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBjb21wYXJhdG9yOignciwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdyKVxuICAgIC0+ICgoJ3IgKiAncikgb3B0aW9uLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBDb21wdXRlcyBbbWluICogbWF4XSB3aGVyZSB0aGUgdmFsdWUgaXMgY29tcHV0ZWQgZm9yIGVhY2gga3YtcGFpclxuICAgICAgaW4gdGhlIGlucHV0IG1hcCAqKVxuICB2YWwgbWFwX2JvdW5kc1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAncilcbiAgICAtPiAoKCdyICogJ3IpIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIHNtYWxsZXN0IGFuZCBsYXJnZXN0IGRhdGEgdmFsdWUgZnJvbSB0aGUgaW5wdXQgbWFwLiAqKVxuICB2YWwgdmFsdWVfYm91bmRzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBjb21wYXJhdG9yOigndiwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgoJ3YgKiAndikgb3B0aW9uLCAndykgSW5jcmVtZW50YWwudFxuXG5cbiAgKCoqIExpa2UgW21lcmdlXSBpbiBbQmFzZS5NYXAubWVyZ2VdLiBOb3RlIHRoYXQgW2ZdIGlzIGNhbGxlZCBhdCBtb3N0IG9uY2UgcGVyIGtleSBpblxuICAgICAgYW55IGdpdmVuIHN0YWJpbGl6YXRpb24uICopXG4gIHZhbCBtZXJnZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbF9sZWZ0OigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gP2RhdGFfZXF1YWxfcmlnaHQ6KCd2MiAtPiAndjIgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndjEsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooa2V5OidrIC0+ICgndjEsICd2MikgTWFwLk1lcmdlX2VsZW1lbnQudCAtPiAndjMgb3B0aW9uKVxuICAgIC0+ICgoJ2ssICd2MywgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFttZXJnZV9ib3RoX3NhbWVdIGlzIGxpa2UgW21lcmdlXSwgYnV0IG9wdGltaXplZCBmb3IgdGhlIGNhc2Ugd2hlcmUgeW91IG9ubHkgY2FyZVxuICAgICAgYWJvdXQgdGhlIGNhc2Ugd2hlcmUgYm90aCBtYXBzIGNvbnRhaW4gYSBwYXJ0aWN1bGFyIGtleS4gKilcbiAgdmFsIG1lcmdlX2JvdGhfc29tZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbF9sZWZ0OigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gP2RhdGFfZXF1YWxfcmlnaHQ6KCd2MiAtPiAndjIgLT4gYm9vbClcbiAgICAtPiA/b3V0X2VxdWFsOigndjMgLT4gJ3YzIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrLCAndjIsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiAndjEgLT4gJ3YyIC0+ICd2MylcbiAgICAtPiAoKCdrLCAndjMsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBMaWtlIFttZXJnZV0sIGJ1dCBvcGVyYXRpbmcgdXNpbmcgaW5jcmVtZW50YWwgbm9kZXMuIFRoaXMgaXMgYSBnb29kIHVzZSBjYXNlIGZvclxuICAgICAgW3BweF9wYXR0ZXJuX2JpbmRdLiAqKVxuICB2YWwgbWVyZ2UnXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9jdXRvZmY6KCd2MSwgJ3YyKSBNYXAuTWVyZ2VfZWxlbWVudC50IEluY3JlbWVudGFsLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWxfbGVmdDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9kYXRhX2VxdWFsX3JpZ2h0OigndjIgLT4gJ3YyIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrLCAndjIsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6XG4gICAgICAgICAoa2V5OidrXG4gICAgICAgICAgLT4gKCgndjEsICd2MikgTWFwLk1lcmdlX2VsZW1lbnQudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAoJ3YzIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YzLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgdW56aXBcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2xlZnRfcmVzdWx0X2VxdWFsOignYSAtPiAnYSAtPiBib29sKVxuICAgIC0+ID9yaWdodF9yZXN1bHRfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ2EgKiAnYiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCgnaywgJ2EsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudCAqICgoJ2ssICdiLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW3VuemlwX21hcGldIGlzIHNpbWlsYXIgdG8gW0xpc3QudW56aXBdLCBidXQgZm9yIGluY3JlbWVudGFsIG1hcHMuIE5vdGUgdGhhdCBbZl0gbWF5XG4gICAgICBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgb24gYSBzaW5nbGUgZWxlbWVudC4gKilcbiAgdmFsIHVuemlwX21hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gP2xlZnRfcmVzdWx0X2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gP3JpZ2h0X3Jlc3VsdF9lcXVhbDooJ3YyIC0+ICd2MiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAndjEgKiAndjIpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgICAqICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFt1bnppcF9tYXBpJ10gaXMgbGlrZSBbdW56aXBfbWFwaV0sIGJ1dCBhbGxvd3MgeW91IHRvIGRlZmluZSB0aGUgbWFwcGluZyBmcm9tIHRoZVxuICAgICAgaW5wdXQgbWFwJ3MgZWxlbWVudHMgdG8gdGhlIG91dHB1dCBtYXBzJyBlbGVtZW50cyBpbmNyZW1lbnRhbGx5LlxuXG4gICAgICBUaGUgbmFpdmUgaW1wbGVtZW50YXRpb24gKHNlZSBiZWxvdykgcHJvZHVjZXMgd29yc2UgSW5jcmVtZW50YWwgZ3JhcGhzLlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgdGVtcCA9XG4gICAgICAgICAgSW5jcl9tYXAubWFwaScgaW5wdXQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICBmIH5rZXkgfmRhdGEgfD4gVHVwbGUyLnVuY3VycnkgSW5jci5ib3RoKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbGVmdCA9IEluY3JfbWFwLm1hcCB0ZW1wIH5mOlR1cGxlMi5nZXQxIGluXG4gICAgICAgIGxldCByaWdodCA9IEluY3JfbWFwLm1hcCB0ZW1wIH5mOlR1cGxlMi5nZXQyIGluXG4gICAgICAgIGxlZnQsIHJpZ2h0XG4gICAgICBdfSAqKVxuICB2YWwgdW56aXBfbWFwaSdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondiBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOlxuICAgICAgICAgKGtleTona1xuICAgICAgICAgIC0+IGRhdGE6KCd2LCAndykgSW5jcmVtZW50YWwudFxuICAgICAgICAgIC0+ICgndjEsICd3KSBJbmNyZW1lbnRhbC50ICogKCd2MiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgICAqICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFRoaXMgaXMgdGhlIFwiZWFzeVwiIHZlcnNpb24gb2YgW2pvaW5dICopXG4gIHZhbCBmbGF0dGVuXG4gICAgOiAgJ3cgSW5jcmVtZW50YWwuU3RhdGUudFxuICAgIC0+ICgnaywgKCd2LCAndykgSW5jcmVtZW50YWwudCwgJ2NtcCkgTWFwLnRcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFRoZSBub24taW5jcmVtZW50YWwgc2VtYW50aWNzIG9mIHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IGZ1bmN0aW9uLiAgSXRzXG4gICAgICBwdXJwb3NlIGlzIHRvIGNvbGxhcHNlIHRoZSBleHRyYSBsZXZlbCBvZiBpbmNyZW1lbnRhbGl0eSBhdCB0aGUgbGV2ZWwgb2YgdGhlIGRhdGEgb2ZcbiAgICAgIHRoZSBtYXAuKilcbiAgdmFsIGpvaW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCgnaywgKCd2LCAndykgSW5jcmVtZW50YWwudCwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gIHZhbCBzZXBhcmF0ZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAoJ3YsICd3KSBJbmNyZW1lbnRhbC50LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwga2V5c1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoKCdrLCAndiwgJ2MpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgoJ2ssICdjKSBTZXQudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIFtyYW5rXSBvZiBhIGtleSAoZ2l2ZW4gaW5jcmVtZW50YWxseSkgaW5zaWRlIG9mIGEgbWFwIChhbHNvXG4gICAgICBpbmNyZW1lbnRhbCkuICBUaGUgdHJhZGl0aW9uYWwgW01hcC5yYW5rXSBmdW5jdGlvbiBpcyBPKG4pLCBhbmQgdGhpcyBpbmNyZW1lbnRhbFxuICAgICAgcmFuayBmdW5jdGlvbiBoYXMgdGhlIGZvbGxvd2luZyBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3M6XG5cbiAgICAgIGRlZmluaXRpb25zOlxuICAgICAgbiA6IHRoZSBzaXplIG9mIHRoZSBtYXBcbiAgICAgIHIgOiB0aGUgdGltZSB0byBjb21wdXRlIFtNYXAuc3ltbWV0cmljX2RpZmZdIGJldHdlZW4gdGhlIHR3byBtYXBzXG4gICAgICBrIDogdGhlIGNoYW5nZSBpbiByYW5rIG9mIHRoZSBrZXkgYmV0d2VlbiB0d28gc3RhYmlsaXphdGlvbnNcblxuICAgICAgbm90ZSB0aGF0IFtyXSBhbmQgW2tdIGFyZSBfbXVjaF8gc21hbGxlciB0aGFuIFtuXSBmb3IgbW9zdCBwcmFjdGljYWwgcHVycG9zZXNcblxuICAgICAgLSBPKGxvZyBuKSB3aGVuIHRoZSBrZXkgaXMgbm90IGluIHRoZSBtYXAuXG4gICAgICAgIFRoaXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG90aGVyIGV2ZXJ5IG90aGVyIHNjZW5hcmlvLlxuICAgICAgLSBPKG4pIG9uIHRoZSBpbml0aWFsIHN0YWJpbGl6YXRpb25cbiAgICAgIC0gTyhuKSB3aGVuIHRoZSBrZXkgdHJhbnNpdGlvbnMgZnJvbSBub3QgYmVpbmcgaW4gdGhlIG1hcCB0byBiZWluZyBpbiB0aGUgbWFwXG4gICAgICAtIE8obG9nIG4gKyByKSB3aGVuIHRoZSBtYXAgY2hhbmdlc1xuICAgICAgLSBPKGxvZyBuICsgaykgd2hlbiB0aGUga2V5IGNoYW5nZXNcbiAgICAgIC0gTyhsb2cgbiArIHIgKyBrKSB3aGVuIGJvdGgga2V5IGFuZCBtYXAgY2hhbmdlICopXG4gIHZhbCByYW5rXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBCYXNlLk1hcC50LCAnc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgnaywgJ3N0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoaW50IG9wdGlvbiwgJ3N0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcblxuICAoKiogW3N1YnJhbmdlIG1hcCAobWluLCBtYXgpXSBjb25zdHJ1Y3RzIGFuIGluY3JlbWVudGFsIHN1Ym1hcCB0aGF0IGluY2x1ZGVzIGFsbCBvZiB0aGVcbiAgICAgIGtleXMgYW5kIGRhdGEgZnJvbSBbbWFwXSBiZXR3ZWVuIFttaW5dIGFuZCBbbWF4XSwgYW5kIG5vbmUgb2YgdGhlIGtleXMgb3V0c2lkZSB0aGVcbiAgICAgIHJhbmdlLlxuXG4gICAgICBbc3VicmFuZ2UgbWFwIE5vbmVdIGlzIHRoZSBlbXB0eSBtYXAuIFtyYW5nZV0gYmVpbmcgW05vbmVdIG1lYW5zIG5vIGVsZW1lbnRzIGFyZVxuICAgICAgY2hvc2VuLlxuXG4gICAgICBOb3RlIHRoYXQgaW5jcmVtZW50YWwgY2hhbmdlcyBoYXZlIGEgcnVudGltZSBvZiBPKChrICsgbSkgbG9nIG4pIHdoZXJlIGsgaXMgdGhlIHNpemVcbiAgICAgIG9mIHRoZSBjaGFuZ2VzIHRvIHRoZSB1bmRlcmx5aW5nIG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZiB0aGUgY2hhbmdlcyB0byB0aGVcbiAgICAgIGVsZW1lbnRzIGNvbnRhaW5lZCBieSB0aGUgcmFuZ2UuIFRoZSBjb21wbGV4aXR5IG9mIHRoZSBpbml0aWFsIGNvbXB1dGF0aW9uIGlzIHRoZVxuICAgICAgc2FtZSBhcyB0aGUgaW5jcmVtZW50YWwgY29tcHV0YXRpb24sIHdpdGggc29tZSBzaW1wbGlmaWNhdGlvbi4gayA9IDAgYmVjYXVzZSB3ZSBoYXZlXG4gICAgICBub3QgbWFkZSBhbnkgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBtYXAgeWV0LCBhbmQgbSBlcXVhbHMgdGhlIHNpemUgb2YgdGhlIHJhbmdlLFxuICAgICAgYmVjYXVzZSB0aGUgaW5pdGlhbCByYW5nZSBpcyBlbXB0eS4gKilcbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoICgnayBNYXliZV9ib3VuZC5Bc19sb3dlcl9ib3VuZC50ICogJ2sgTWF5YmVfYm91bmQuQXNfdXBwZXJfYm91bmQudCkgb3B0aW9uXG4gICAgICAgLCAndyApXG4gICAgICAgICBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbc3VicmFuZ2VfYnlfcmFuayBtYXAgKHMsIGUpXSBjb25zdHJ1Y3RzIGFuIGluY3JlbWVudGFsIHN1Ym1hcCB0aGF0IGluY2x1ZGVzIChlLXMrMSlcbiAgICAgIGtleXMgYmV0d2VlbiBzLXRoIGFuZCBlLXRoLCBpbmNsdXNpdmUuXG5cbiAgICAgIElmIHMgaXMgZ3JlYXRlciBvciBlcXVhbCB0byBtYXAgbGVuZ3RoLCB0aGUgcmVzdWx0IGlzIGVtcHR5LlxuICAgICAgSWYgZSBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIG1hcCBsZW5ndGgsIHRoZSByZXN1bHQgY29udGFpbnMga2V5cyBmcm9tIHMtdGggdG8gdGhlXG4gICAgICBsYXN0IG9uZS5cblxuICAgICAgUmFpc2VzIGZvciBpbnZhbGlkIGluZGljZXMgLSBzIDwgMCBvciBlIDwgcy5cblxuICAgICAgUnVudGltZSBvZiB0aGUgaW5pdGlhbCBjb21wdXRhdGlvbiBpcyBPKG1pbihlLCBuLXMpICsgbG9nKG4pKSwgaS5lLiBsaW5lYXIsXG4gICAgICBidXQgb3B0aW1pemVkIGZvciByYW5nZXMgY2xvc2UgdG8gYmVnaW5uaW5nIG9yIGVuZC5cblxuICAgICAgUnVudGltZSBvZiB0aGUgaW5jcmVtZW50YWwgY29tcHV0YXRpb24gaXMgTyhsb2cobikgKyBrICsgKG0rbScpICogbG9nKG4pKSB3aGVyZTpcbiAgICAgIC0gayBpcyB0aGUgc2l6ZSBvZiB0aGUgZGlmZlxuICAgICAgLSBtIGlzIHRoZSB0b3RhbCBpbXBhY3Qgb2YgbWFwIGNoYW5nZXMgb24gdGhlIHJhbmdlLCBib3VuZGVkIGJ5IGsgKGUuZy4gaWYgd2UgYWRkXG4gICAgICAgIDEwMDEga2V5cyBhbmQgcmVtb3ZlIDEwMDAgYmVsb3cgcywgdGhlbiBtID0gMSlcbiAgICAgIC0gbScgPSBPKCB8bmV3IHMgLSBvbGQgc3wgKyB8bmV3IGUgLSBvbGQgZXwgKS5cbiAgKilcbiAgdmFsIHN1YnJhbmdlX2J5X3JhbmtcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICggaW50IE1heWJlX2JvdW5kLkFzX2xvd2VyX2JvdW5kLnQgKiBpbnQgTWF5YmVfYm91bmQuQXNfdXBwZXJfYm91bmQudFxuICAgICAgICwgJ3cgKVxuICAgICAgICAgSW5jcmVtZW50YWwudFxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW3Jla2V5XSB0cmFuc2Zvcm1zIGEgbWFwIGJ5IG1vZGlmeWluZyB0aGUgdHlwZSBvZiB0aGUga2V5LiAgVGhlIHVzZXIgaXNcbiAgICAgIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IFtmXSBkb2Vzbid0IHJldHVybiB0aGUgc2FtZSBvdXRwdXQga2V5IGZvclxuICAgICAgbXVsdGlwbGUgaW5wdXQga2V5cy5cblxuICAgICAgVGhpcyBmdW5jdGlvbiBhc3N1bWVzIFtmXSBpcyBjaGVhcCB0byBjb21wdXRlIGFuZCBhY2NvcmRpbmdseSBtYXkgY2FsbFxuICAgICAgaXQgbXVsdGlwbGUgdGltZXMuICopXG4gIHZhbCByZWtleVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrMSwgJ3YsICdjbXAxKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBjb21wYXJhdG9yOignazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrMSAtPiBkYXRhOid2IC0+ICdrMilcbiAgICAtPiAoKCdrMiwgJ3YsICdjbXAyKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW2luZGV4X2J5aSBtYXAgfmNvbXBhcmF0b3IgfmluZGV4XSBjb25zdHJ1Y3RzIGFuIGluY3JlbWVudGFsIG1hcC1vZi1tYXBzIHdoZXJlIGVhY2hcbiAgICAgIGtleS1kYXRhIHBhaXIgb2YgdGhlIGlucHV0IG1hcCBpcyBwcmVzZW50IGluIG9uZSAob3Igbm9uZSkgb2YgdGhlIGlubmVyIG1hcHMuXG4gICAgICBbaW5kZXhdIHNwZWNpZmllcyB0aGUgb3V0ZXIgbWFwIGtleSB1bmRlciB3aGljaCBlYWNoIG9yaWdpbmFsIGtleS1kYXRhIHBhaXIgaXNcbiAgICAgIGZvdW5kLlxuXG4gICAgICBBbGwgb2YgdGhlIHJlc3VsdGluZyBpbm5lciBtYXBzIGFyZSBndWFyYW50ZWVkIHRvIGJlIG5vbi1lbXB0eTsgaWYgdGhlIGlubmVyIG1hcFxuICAgICAgd291bGQgb3RoZXJ3aXNlIGJlIGVtcHR5LCB0aGVuIHRoZSBrZXkgZm9yIHRoYXQgbWFwIGlzIGluc3RlYWQgcmVtb3ZlZCBmcm9tIHRoZVxuICAgICAgb3V0ZXIgbWFwLlxuXG4gICAgICBBbiBhbGwtYXQtb25jZSB2ZXJzaW9uIG9mIFtpbmRleF9ieV0gd291bGQgbG9vayBsaWtlOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgaW5kZXhfYnlpIG1hcCB+Y29tcGFyYXRvciB+aW5kZXggPVxuICAgICAgICAgIE1hcC50b19hbGlzdCBtYXBcbiAgICAgICAgICB8PiBMaXN0LmZpbHRlcl9tYXAgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgbWF0Y2ggaW5kZXggfmtleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgfCBTb21lIGluZGV4IC0+IFNvbWUgKGluZGV4LCAoa2V5LCBkYXRhKSkpXG4gICAgICAgICAgfD4gTWFwLm9mX2FsaXN0X211bHRpIGNvbXBhcmF0b3JcbiAgICAgICAgICB8PiBNYXAubWFwIH5mOihNYXAub2ZfYWxpc3RfZXhuIChNYXAuY29tcGFyYXRvcl9zIG1hcCkpXG4gICAgICAgIDs7XG4gICAgICBdfSAqKVxuICB2YWwgaW5kZXhfYnlpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdvdXRlcl9rZXksICdvdXRlcl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpbmRleDooa2V5Oidpbm5lcl9rZXkgLT4gZGF0YTondiAtPiAnb3V0ZXJfa2V5IG9wdGlvbilcbiAgICAtPiAoICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudFxuICAgICAgICwgJ3cgKVxuICAgICAgICAgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbaW5kZXhfYnkgbWFwIH5jb21wYXJhdG9yIH5pbmRleF0gaXMgbGlrZSBbaW5kZXhfYnlpIG1hcCB+Y29tcGFyYXRvciB+aW5kZXhdLCBidXRcbiAgICAgIHRoZSBbaW5kZXhdIGZ1bmN0aW9uIGRvZXMgbm90IHRha2UgdGhlIGlubmVyIG1hcCdzIFtrZXldLiAqKVxuICB2YWwgaW5kZXhfYnlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaW5uZXJfa2V5LCAndiwgJ2lubmVyX2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ291dGVyX2tleSwgJ291dGVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGluZGV4OigndiAtPiAnb3V0ZXJfa2V5IG9wdGlvbilcbiAgICAtPiAoICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudFxuICAgICAgICwgJ3cgKVxuICAgICAgICAgSW5jcmVtZW50YWwudFxuXG4gIHZhbCB1bm9yZGVyZWRfZm9sZF9uZXN0ZWRfbWFwc1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTpib29sXG4gICAgLT4gP3VwZGF0ZTpcbiAgICAgICAgIChvdXRlcl9rZXk6J291dGVyX2tleVxuICAgICAgICAgIC0+IGlubmVyX2tleTonaW5uZXJfa2V5XG4gICAgICAgICAgLT4gb2xkX2RhdGE6J3ZcbiAgICAgICAgICAtPiBuZXdfZGF0YTondlxuICAgICAgICAgIC0+ICdhY2NcbiAgICAgICAgICAtPiAnYWNjKVxuICAgIC0+ICggKCdvdXRlcl9rZXksICgnaW5uZXJfa2V5LCAndiwgJ2lubmVyX2NtcCkgTWFwLnQsICdvdXRlcl9jbXApIE1hcC50XG4gICAgICAgLCAndyApXG4gICAgICAgICBJbmNyZW1lbnRhbC50XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gYWRkOihvdXRlcl9rZXk6J291dGVyX2tleSAtPiBpbm5lcl9rZXk6J2lubmVyX2tleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiByZW1vdmU6KG91dGVyX2tleTonb3V0ZXJfa2V5IC0+IGlubmVyX2tleTonaW5uZXJfa2V5IC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICgnYWNjLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbdHJhbnNwb3NlXSBmbGlwcyB0aGUgb3JkZXIgb2YgYSBkb3VibHkgbmVzdGVkIGluY3JlbWVudGFsIG1hcC5cblxuICAgICAgQWxsIGlubmVyIG1hcCBpbnN0YW5jZXMgd2lsbCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50LiAqKVxuICB2YWwgdHJhbnNwb3NlXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnazIsICdrMl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoKCdrMSwgKCdrMiwgJ3YsICdrMl9jbXApIE1hcC50LCAnazFfY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrMiwgKCdrMSwgJ3YsICdrMV9jbXApIE1hcC50LCAnazJfY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgY29sbGFwc2VcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICAgIEluY3JlbWVudGFsLnRcbiAgICAtPiBjb21wYXJhdG9yOignaW5uZXJfa2V5LCAnaW5uZXJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCAoICdvdXRlcl9rZXkgKiAnaW5uZXJfa2V5XG4gICAgICAgICAsICd2XG4gICAgICAgICAsICgnb3V0ZXJfY21wLCAnaW5uZXJfY21wKSBUdXBsZTIuY29tcGFyYXRvcl93aXRuZXNzIClcbiAgICAgICAgICAgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICAgIEluY3JlbWVudGFsLnRcblxuICAoKiogW2NvbGxhcHNlX2J5XSBpcyBzaW1pbGFyIHRvIFtjb2xsYXBzZV0sIGJ1dCBpdCBhbGxvd3MgdGhlIHVzZXIgdG9cbiAgICAgIGNob29zZSBob3cgdG8gY29tYmluZSB0aGUgdHdvIGtleXMgZnJvbSB0aGUgb3V0ZXIgYW5kIGlubmVyIG1hcHMuXG4gICAgICBUaGlzIGRvZXMgbWVhbiB0aGF0IGl0J3MgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBpbXBsZW1lbnRvciBvZiB0aGVcbiAgICAgIFttZXJnZV9rZXlzXSBmdW5jdGlvbiB0byB1cGhvbGQgdGhpcyBpbnZhcmlhbnQ6XG5cbiAgICAgID4gYSBtZXJnZWQta2V5IGJlaW5nIGVxdWFsIHRvIGFub3RoZXIgbWVyZ2VkLWtleSBpbXBsaWVzIHRoYXQgdGhlXG4gICAgICA+IG91dGVyLWtleXMgYW5kIGlubmVyLWtleXMgd2hpY2ggd2VyZSB1c2VkIHRvIGJ1aWxkIHRoZSBtZXJnZWQga2V5cyBhbHNvXG4gICAgICA+IGNvbXBhcmUgdG8gYmUgZXF1YWwgdG8gb25lIGFub3RoZXJcblxuICAgICAgVGhlIFt+Y29tcGFyYXRvcl0gYXJndW1lbnQgdGhlIGZpcnN0LWNsYXNzIG1vZHVsZSBvZiB0aGUgb3V0cHV0IGtleSwgaXRcbiAgICAgIHVzdWFsbHkgbG9va3MgbGlrZSB0aGlzOlxuICAgICAgWyB+Y29tcGFyYXRvcjoobW9kdWxlIENvbWJpbmVkX2tleSkgXVxuICAgICAgYnV0IG1ha2Ugc3VyZSB0aGF0IHRoZSBtb2R1bGUgaW1wbGVtZW50cyB0aGUgW0NvbXBhcmF0b3IuU10gc2lnbmF0dXJlLiAqKVxuICB2YWwgY29sbGFwc2VfYnlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICAgIEluY3JlbWVudGFsLnRcbiAgICAtPiBtZXJnZV9rZXlzOignb3V0ZXJfa2V5IC0+ICdpbm5lcl9rZXkgLT4gJ2NvbWJpbmVkX2tleSlcbiAgICAtPiBjb21wYXJhdG9yOignY29tYmluZWRfa2V5LCAnY29tYmluZWRfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCgnY29tYmluZWRfa2V5LCAndiwgJ2NvbWJpbmVkX2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIENvbnZlcnQgYSBtYXAgd2l0aCB0dXBsZXMgZm9yIGtleXMgaW50byBhIG5lc3RlZCBtYXAuIFRoaXMgb3BlcmF0aW9uIGlzIHJvdWdobHkgdGhlXG4gICAgICBpbnZlcnNlIG9mIFtjb2xsYXBzZV0sIHRob3VnaCBpZiB0aGVyZSBhcmUgb3V0ZXIga2V5cyBpbiB0aGUgdW5jb2xsYXBzZWQgbWFwIHRoYXRcbiAgICAgIGNvcnJlc3BvbmQgdG8gZW1wdHkgaW5uZXIgbWFwcywgdGhlIG91dGVyIGtleXMgd2lsbCBiZSBkcm9wcGVkIGZyb20gdGhlIGV4cGFuZGVkXG4gICAgICBtYXAuICopXG4gIHZhbCBleHBhbmRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnb3V0ZXJfa2V5ICogJ2lubmVyX2tleSwgJ3YsICd0dXBsZV9jbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IG91dGVyX2NvbXBhcmF0b3I6KCdvdXRlcl9rZXksICdvdXRlcl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpbm5lcl9jb21wYXJhdG9yOignaW5uZXJfa2V5LCAnaW5uZXJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICAgIEluY3JlbWVudGFsLnRcblxuICB2YWwgY291bnRpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+IChpbnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIGNvdW50XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoXywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKGludCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZm9yX2FsbGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gKGJvb2wsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIGZvcl9hbGxcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKChfLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiAoYm9vbCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZXhpc3RzaVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAtPiAoYm9vbCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZXhpc3RzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoXywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKGJvb2wsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIEluY3JlbWVudGFsbHkgY29tcHV0ZSB0aGUgc3VtIG9mIGFsbCBvZiB0aGUgdmFsdWVzIGluIHRoZSBtYXAuXG5cbiAgICAgIEJld2FyZSBvZiBmbG9hdCdzIG5lZ2F0aXZlIGluZmluaXRpZXMuIFRoZXkgYXJlbid0IGNvbW11dGF0aXZlIGFuZCB3aWxsIG1pc2JlaGF2ZVxuICAgICAgaGVyZS5cbiAgKilcbiAgdmFsIHN1bVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKF8sICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAobW9kdWxlIEFic3RyYWN0X2FsZ2VicmEuQ29tbXV0YXRpdmVfZ3JvdXAuV2l0aG91dF9zZXhwIHdpdGggdHlwZSB0ID0gJ3UpXG4gICAgLT4gZjooJ3YgLT4gJ3UpXG4gICAgLT4gKCd1LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbKCdrLCAndikgTG9va3VwLnRdIHByb3ZpZGVzIGEgd2F5IHRvIGxvb2t1cCBrZXlzIGluIGEgbWFwIHdoaWNoIHVzZXMgc3ltbWV0cmljXG4gICAgICBkaWZmcyB0byB0cmlnZ2VyIHVwZGF0ZXMgb2YgdGhlIGxvb2t1cHMuXG5cbiAgICAgIFRoZSBjb21wbGV4aXR5IG9mIGFuIHVwZGF0ZSBkZXBlbmRzIG9uOlxuICAgICAgLSBbbl06IHRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgbGFyZ2VyIG9mIHRoZSBvbGQvdXBkYXRlZCBpbnB1dCBtYXBcbiAgICAgIC0gW2tdOiB0aGUgbnVtYmVyIG9mIGxvb2t1cCBub2RlcyBjcmVhdGVkIHVzaW5nIFtmaW5kXVxuICAgICAgLSBbbV06IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHN5bWRpZmYgb2YgdGhlIG1hcHNcbiAgICAgIC0gW3N5bWRpZmYobildOiB0aGUgY29zdCBvZiBwZXJmb3JtaW5nIHRoZSBzeW1kaWZmIG9uIHRoZSBtYXAgKG0gPD0gc3ltZGlmZihuKSA8PSBuKVxuXG4gICAgICBFYWNoIHVwZGF0ZSBzaG91bGQgY29zdCBbTyhzeW1kaWZmKG4pICsgbSAqIGxvZyBrKV0sIHNvIHRoaXMgd2lsbCBiZSBlZmZpY2llbnQgd2hlblxuICAgICAgdGhlcmUgYXJlIGEgbG90IG9mIGxvb2t1cHMgKGNsb3NlIHRvIG4pIGludG8gYSBtYXAgd2hpY2ggY2FuIGJlIGVmZmljaWVudGx5XG4gICAgICBzeW1kaWZmZWQgKGFuZCB0aGVyZWZvcmUgaGFzIGEgc21hbGwgbnVtYmVyIG9mIGNoYW5nZXMgYWxzbykuIFRoZSBjb3N0IG9mIHVwZGF0aW5nXG4gICAgICB3aGVuIHBlcmZvcm1pbmcgdGhlIHNhbWUgbG9va3VwcyBieSBtZWFucyBvZiBbSW5jci5tYXAgfmY6KGZ1biBtIC0+IE1hcC5maW5kIG0ga2V5KV1cbiAgICAgIGlzIFtPKGsgKiBsb2cgbildLlxuICAqKVxuICBtb2R1bGUgTG9va3VwIDogc2lnXG4gICAgdHlwZSAoJ2ssICd2LCAnY21wLCAndykgdFxuXG4gICAgKCoqIENyZWF0ZSB0aGUgbG9va3VwIHN0cnVjdHVyZSBvbiBhbiBpbmNyZW1lbnRhbCBtYXAuICopXG4gICAgdmFsIGNyZWF0ZVxuICAgICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICAtPiBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wLCAndykgdFxuXG4gICAgKCoqIENyZWF0ZSBhIG5vZGUgd2hpY2ggcGVyZm9ybXMgW01hcC5maW5kXSBvbiB0aGUgaW5wdXQgbWFwLlxuXG4gICAgICAgIFtmaW5kIChjcmVhdGUgaW5jcl9tYXApIGtleV0gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gW0luY3IubWFwIH5mOihmdW4gbSAtPlxuICAgICAgICBNYXAuZmluZCBtIGtleSkgaW5jcl9tYXBdLCBidXQgd2hlbiB5b3UgY2FsbCBbZmluZF0gbWFueSB0aW1lcyBmb3IgYSBzaW5nbGVcbiAgICAgICAgW2NyZWF0ZV0gdGhlIG5vZGVzIHNob3VsZCB1cGRhdGUgbW9yZSBlZmZpY2llbnRseSBpbiBzdGFiaWxpc2F0aW9uIHdoZW4gW2luY3JfbWFwXVxuICAgICAgICBjaGFuZ2VzIGluIGEgd2F5IHdoaWNoIGNhbiBiZSBlZmZpY2llbnRseSBkaWZmZWQuXG5cbiAgICAgICAgVGhpcyB3aWxsIHJlLXVzZSBleGlzdGluZyBub2RlcyB3aGVuIGl0IGNhbiwgYnV0IHdpbGwgbm90IGFsd2F5cyBkbyBzby5cbiAgICAqKVxuICAgIHZhbCBmaW5kIDogKCdrLCAndiwgXywgJ3cpIHQgLT4gJ2sgLT4gKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAgICgqKiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlZmVyIHRvIHRoZSB0eXBlIGZvciBhIGdpdmVuIGtleS4gKilcbiAgICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgICB0eXBlIHRcbiAgICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICAgIGVuZCkgOiBzaWdcbiAgICAgIHR5cGUgbm9ucmVjICgndiwgJ3cpIHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MsICd3KSB0XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnIDogc2lnXG4gICAgICB2YWwgc2V4cF9vZl90IDogKCdrIC0+IFNleHAudCkgLT4gKCd2IC0+IFNleHAudCkgLT4gKCdrLCAndiwgJ2NtcCwgXykgdCAtPiBTZXhwLnRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIEZvcl90ZXN0aW5nIDogc2lnXG4gICAgdmFsIGZpbmRfa2V5X3JhbmdlX2xpbmVhclxuICAgICAgOiAgZnJvbTppbnRcbiAgICAgIC0+IHRvXzppbnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSBCYXNlLk1hcC50XG4gICAgICAtPiAoJ2EgKiAnYSBvcHRpb24pIG9wdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2dlbiA9IFNfZ2VuXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgc3RhdGVfd2l0bmVzc1xuXG4gICAgaW5jbHVkZVxuICAgICAgU19nZW5cbiAgICAgIHdpdGggdHlwZSAnYSBJbmNyLnQgPSAoJ2EsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICBhbmQgdHlwZSAnYSBJbmNyLkN1dG9mZi50ID0gJ2EgSW5jcmVtZW50YWwuQ3V0b2ZmLnRcbiAgICAgICBhbmQgdHlwZSAoJ2ssICd2LCAnY21wKSBMb29rdXAudCA9ICgnaywgJ3YsICdjbXAsIHN0YXRlX3dpdG5lc3MpIExvb2t1cC50XG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlIChJbmNyIDogSW5jcmVtZW50YWwuUykgOlxuICAgIFMgd2l0aCB0eXBlIHN0YXRlX3dpdG5lc3MgOj0gSW5jci5zdGF0ZV93aXRuZXNzIGFuZCBtb2R1bGUgSW5jciA6PSBJbmNyXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo2MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJpbmNyX21hcC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0luY3JfbWFwIiwiY3N0X2luY3JfbWFwIiwiY3N0X3NyY19pbmNyX21hcF9tbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfb2JqX3RhZyIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiQ29yZV9JbnQiLCJDb3JlX01hcCIsIkNvcmUiLCJJbmNyZW1lbnRhbCIsIkNvcmVfT3B0aW9uIiwiQ29yZV9JbmZvIiwiQ2FtbGludGVybmFsTGF6eSIsIkNvcmVfTGlzdCIsIkNvcmVfQm9vbCIsIkNvcmVfVHVwbGUiLCJBc3NlcnRfZmFpbHVyZSIsIkNvcmVfTWF5YmVfYm91bmQiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJDb3JlX0xhenkiLCJDb3JlX1NldCIsIkJhc2VfT3B0aW9uIiwiQ29yZV9TZXF1ZW5jZSIsIlBweF9tb2R1bGVfdGltZXJfcnVudGltZSIsIlBweF9iZW5jaF9saWJfQmVuY2htYXJrX2FjY3VtdSIsIkV4cGVjdF90ZXN0X2NvbGxlY3RvciIsIlBweF9pbmxpbmVfdGVzdF9saWIiLCJjc3RfaW1wb3NzaWJsZV9jYXNlX0JVR19pbl9pbmMiLCJjc3RfQlVHX0hpdF9zdXBwb3NlZGx5X2ltcG9zc2kiLCJjc3RfSW52YWxpZF9pbmRpY2VzIiwibm9faW5zdHJ1bWVudGF0aW9uIiwid2l0aF9vbGQiLCJpbnN0cnVtZW50YXRpb24iLCJpIiwib2xkIiwiYSIsInBhcmFtIiwiYiIsImN1dG9mZiIsIm9wdCIsIm1hcCIsImRhdGFfZXF1YWwiLCJvbGRfdmFsdWUiLCJuZXdfdmFsdWUiLCJjdXIiLCJhY2MiLCJjaGFuZ2UiLCJrZXkiLCJuZXciLCJ1bm9yZGVyZWRfZm9sZCIsInVwZGF0ZSIsInNwZWNpYWxpemVkX2luaXRpYWwiLCJpbml0IiwiYWRkIiwicmVtb3ZlIiwiZmluYWxpemUiLCJyZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5IiwiZGVmYXVsdCIsIm9sZF9kYXRhIiwibmV3X2RhdGEiLCJuZXdfaW4iLCJtYXRjaCIsIm9sZF9vdXQiLCJvbGRfaW4iLCJpbml0aWFsIiwidW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHMiLCJpbmNyX21hcCIsIm91dGVyX2tleSIsImlubmVyX2tleSIsIm9sZF9pbm5lcl9tYXAiLCJuZXdfaW5uZXJfbWFwIiwiZGlmZiIsImRhdGFfcmVtb3ZlZCIsImRhdGFfYWRkZWQiLCJpbm5lcl9tYXAiLCJkYXRhIiwid2l0aF9jb21wYXJhdG9yIiwiZ2V0X2NvbXBhcmF0b3IiLCJ4Iiwib2Zfc2V0Iiwic2V0IiwiY29tcGFyYXRvciIsIm9sZF9pbnB1dCIsIm9sZF9vdXRwdXQiLCJuZXdfaW5wdXQiLCJuZXdfb3V0cHV0Iiwib3V0cHV0IiwiayIsImdlbmVyaWNfbWFwaSIsIndpdG5lc3MiLCJpbnB1dCIsInJlcyIsIm91dHB1dF9kYXRhIiwibWFwaSIsImZpbHRlcl9tYXBpIiwiZmlsdGVyX21hcCIsIndpdGhfb2xkMiIsImkxIiwiaTIiLCJ1bm9yZGVyZWRfZm9sZF93aXRoX2V4dHJhIiwiZXh0cmEiLCJleHRyYV9jaGFuZ2VkIiwiZXh0cmFfZXF1YWwiLCJuZXdfZXh0cmEiLCJvbGRfZXh0cmEiLCJtYXBpX2NvdW50IiwibmV3X2tleSIsIm4iLCJwcmV2X2tleSIsIm1hcF9jb3VudCIsIm1pbl9oZWxwZXIiLCJtaW4iLCJtYXhfaGVscGVyIiwibWF4IiwiYm91bmRzX2hlbHBlciIsIm1hcGlfbWluIiwibWFwaV9tYXgiLCJtYXBpX2JvdW5kcyIsIm1hcF9taW4iLCJtYXBfbWF4IiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwibWFwX2JvdW5kcyIsInZhbHVlX2JvdW5kcyIsIm1lcmdlX3NoYXJlZF9pbXBsIiwibmV3X2xlZnRfbWFwIiwibmV3X3JpZ2h0X21hcCIsImRhdGFfZXF1YWxfbGVmdCIsImRhdGFfZXF1YWxfcmlnaHQiLCJvbGRfcmlnaHRfbWFwIiwib2xkX2xlZnRfbWFwIiwibGVmdF9kaWZmIiwicmlnaHRfZGlmZiIsInJpZ2h0X2tleSIsImxlZnRfa2V5IiwiZGlmZl9lbGVtZW50IiwibmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQiLCJtZXJnZSIsImxlZnRfbWFwIiwicmlnaHRfbWFwIiwicmlnaHRfZGF0YV9vcHQiLCJsZWZ0X2RhdGFfb3B0IiwieSIsIm91dHB1dF9kYXRhX29wdCIsIm1lcmdlX2JvdGhfc29tZSIsIm91dF9lcXVhbCIsImVtcHR5IiwibGVmdF9hbmRfcmlnaHRfZGF0YV9vcHQiLCJsZWZ0X2RhdGEiLCJyaWdodF9kYXRhIiwicHJldl9vdXQiLCJnZW5lcmljX21hcGlfd2l0aF9jb21wYXJhdG9yIiwibGhzIiwiaW5jcmVtZW50YWxfc3RhdGUiLCJlbXB0eV9tYXAiLCJwcmV2X21hcCIsInByZXZfbm9kZXMiLCJyZXN1bHQiLCJvbl9pbm5lcl9jaGFuZ2UiLCJsaHNfY2hhbmdlIiwibmV3X25vZGVzIiwibm9kZXMiLCJjaGFuZ2VkIiwiZGVwIiwibm9kZSIsImMiLCJ1c2VyX2Z1bmN0aW9uX2RlcCIsIm1hcDEiLCJtYXAyIiwidW56aXBfbWFwaSIsImxlZnRfcmVzdWx0X2VxdWFsIiwicmlnaHRfcmVzdWx0X2VxdWFsIiwicGFpciIsImxlZnRfYWNjIiwibGVmdF9yZXN1bHQiLCJyaWdodF9hY2MiLCJyaWdodF9yZXN1bHQiLCJpbnB1dF9jaGFuZ2UiLCJsZWZ0IiwibCIsInJpZ2h0IiwiciIsInByZXYiLCJwcmV2X2IiLCJwcmV2X2EiLCJuZXdfYiIsIm5ld19hIiwiZWxlbWVudCIsInVuemlwIiwicmlnaHRfZGVwIiwibGVmdF9kZXAiLCJyaWdodF9pbmNyIiwibGVmdF9pbmNyIiwibGVmdF91c2VyX2Z1bmN0aW9uX2RlcCIsInJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwIiwia2V5cyIsInBhcnRpdGlvbl9tYXBpIiwic2Vjb25kIiwiZmlyc3QiLCJmbGF0dGVuIiwic3RhdGUiLCJpbmNyIiwiam9pbiIsIm1hcF9pbmNyIiwicmVzdWx0X21hcCIsIm9sZF9tYXBfb2ZfaW5jcnMiLCJjdXJyZW50X2RlcGVuZGVuY2llcyIsImFkZF9zdWJub2RlIiwiZGF0YV9ub2RlIiwibmV3X2RlcCIsInJlbW92ZV9zdWJub2RlIiwibWFwX29mX2luY3JzIiwibmV3X2RlcGVuZGVuY3lfbWFwIiwic2VwYXJhdGUiLCJpbnB1dF9tYXAiLCJvdXRwdXRfbWFwX25vZGUiLCJtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF8iLCJpbnB1dF9tYXBfY2hhbmdlZCIsImRlcGVuZGVuY3kiLCJwcmV2X2lucHV0X21hcCIsIm91dHB1dF9tYXAiLCJleHBlcnRfbm9kZXMiLCJvbGRfbm9kZSIsInN1YnJhbmdlIiwicmFuZ2UiLCJjb21wYXJlIiwiZXF1YWwiLCJtYXliZV9ib3VuZF9lcXVhbCIsImFfMDA4IiwiYl8wMDkiLCJhXzAxMCIsImJfMDExIiwiYV8wMTIiLCJiXzAxMyIsInJhbmdlX2lzX2VtcHR5IiwicmFuZ2VfaW5jbHVkZXMiLCJmcm9tX3NjcmF0Y2giLCJvbGRfcmFuZ2UiLCJvbGRfbWluIiwib2xkX21hcCIsIm9sZF9tYXgiLCJvbGRfcmVzIiwiYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24iLCJvdXRzaWRlIiwib3V0c2lkZV9jdXRvZmYiLCJ3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2UiLCJ3aXRob3V0X2tleXNfb3V0X29mX3JhbmdlIiwibWFwX2FwcGVuZF9leG4iLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIndpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlIiwicmVrZXkiLCJvdXRlcl9jb21wYXJhdG9yIiwiYWRkcyIsIm5ld19lbnRyeSIsImluZGV4X2J5aSIsImluZGV4IiwiaW5uZXJfY29tcGFyYXRvciIsIm91dGVyX21hcCIsImluZGV4X2J5IiwiaXNfa25vd24iLCJ0b19vcHRpb24iLCJmaW5kX2tleV9yYW5nZV9saW5lYXIiLCJmcm9tIiwidG8iLCJsZW4iLCJiZWdpbl9rZXkiLCJlbmRfa2V5IiwiZmluZF9rZXlzIiwiZm9sZCIsInN0YXJ0X3BvcyIsImFkdmFuY2VfcG9zIiwicG9zIiwiZmluZF9vZmZzZXQiLCJjaGFuZ2VkX2tleSIsInJhbmsiLCJjb21wYXJlX2tleSIsInNhbWVfa2V5IiwicHJvY2VzcyIsIm5ld19tYXAiLCJvbGRfcmFuayIsIm9sZF9rZXkiLCJkaWZmX2tleSIsInVwcGVyX2JvdW5kIiwibG93ZXJfYm91bmQiLCJzdWJyYW5nZV9ieV9yYW5rIiwiZmluZF9rZXlfcmFuZ2UiLCJlbmRfa2V5X29wdCIsIm9sZF90byIsIm9sZF9mcm9tIiwicmFuZ2Vfb2Zmc2V0X2JlZ2luIiwicmFuZ2Vfb2Zmc2V0X2VuZCIsImFkanVzdF9hbmRfb2Zmc2V0IiwiYnkiLCJjbG9zZXN0X2RpciIsIm9mZnNldF9lbmQiLCJvZmZzZXRfYmVnaW4iLCJtYXBfb2Zmc2V0X2VuZCIsIm1hcF9vZmZzZXRfYmVnaW4iLCJiZWdpbl9rZXlfb3B0Iiwic3ltYm9sIiwiYm91bmQiLCJyZXR1cm4iLCJrZXlfcmFuZ2UiLCJwYXR0ZXJuX3N5bnRheF8wMTQiLCJsYiIsInBhdHRlcm5fc3ludGF4XzAxNSIsInUiLCJwYXR0ZXJuX3N5bnRheF8wMTYiLCJ1YiIsInBhdHRlcm5fc3ludGF4XzAxNyIsImxldF9zeW50YXhfMDIyIiwicGF0dGVybl9zeW50YXhfMDE4IiwicGF0dGVybl9zeW50YXhfMDE5IiwibGV0X3N5bnRheF8wMjYiLCJwYXR0ZXJuX3N5bnRheF8wMjAiLCJwYXR0ZXJuX3N5bnRheF8wMjEiLCJsZXRfc3ludGF4XzAyOSIsInRyYW5zcG9zZSIsImsyX2NvbXBhcmF0b3IiLCJtIiwiazFfY29tcGFyYXRvciIsImsxIiwiazIiLCJ2YWx1ZSIsImFjY19pbm5lciIsImNvbGxhcHNlX2J5IiwibWVyZ2Vfa2V5cyIsImNvbGxhcHNlIiwiZXhwYW5kIiwiY291bnRpIiwiY291bnQiLCJleGlzdHNpIiwiZXhpc3RzIiwic3VtIiwiR3JvdXAiLCJ2IiwiZm9yX2FsbGkiLCJmb3JfYWxsIiwiRm9yX3Rlc3RpbmciLCJNIiwiSyIsImNyZWF0ZSIsInNlbGYiLCJ1cGRhdGVyX25vZGUiLCJjaGFuZ2VkX3ZhbHVlIiwiZW50cmllcyIsImVudHJ5IiwiZmluZCIsInQiLCJpc19ub3dfb2JzZXJ2YWJsZSIsImN1cnJlbnRfZW50cmllcyIsImlzX2xpbmtlZCIsIm90aGVyX2VudHJpZXMiLCJvdGhlcl9lbnRyeSIsIm5ld19lbnRyaWVzIiwic2V4cF9vZl90Iiwic2V4cF9vZl9rZXkiLCJzZXhwX29mX3ZhbHVlIiwiaW5mb19wZXJfa2V5IiwiYWN0dWFsX3ZhbHVlIiwic2F2ZWRfdmFsdWUiLCJJbmNyX21hcCIsIkluY3IiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvaW5jcl9tYXAvaW5jcl9tYXAubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxtQkFBQTtB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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUFDO0FBQUFBLGlCQUFBcEssVUFBQXpILEdBbEJHLDZCQUFzQjtBQUFBLGlCQUFBc1EsRUFBQUMsR0R4MkR4QyxXQ3MzRE87QUFBQSxRRHQzRFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0MwM0RlO0FBQUE7QUFBQSxFRDEzRGYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIENvcmVcbmluY2x1ZGUgSW5jcl9tYXBfaW50ZlxuXG5sZXQgbm9faW5zdHJ1bWVudGF0aW9uID0geyBJbnN0cnVtZW50YXRpb24uZiA9IChmdW4gZiAtPiBmICgpKSB9XG5cbigqKiBUaGlzIHR5cGUgbGV0cyB1cyBjYXB0dXJlIHRoZSBraW5kIG9mIG1hcCBmdW5jdGlvbiBiZWluZyBwZXJmb3JtZWQsIHNvIHdlIGNhbiB3aXRoXG4gICAgb25lIGltcGxlbWVudGF0aW9uIHBlcmZvcm0gbWFwIGFuZCBmaWx0ZXItbWFwIG9wZXJhdGlvbnMuXG5cbiAgICBIZXJlLCBbJ2lucHV0X2RhdGFdIGlzIHRoZSB0eXBlIG9mIGRhdGEgaW4gdGhlIGlucHV0IG1hcCwgWydvdXRwdXRfZGF0YV0gaXMgdGhlIHR5cGVcbiAgICBvZiBkYXRhIGluIHRoZSBvdXRwdXQgbWFwLCBhbmQgWydmX291dHB1dF0gaXMgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBbfmZdIGZ1bmN0aW9uXG4gICAgcGFzc2VkIHRvIHRoZSBtYXBwaW5nIGZ1bmN0aW9uLiAqKVxubW9kdWxlIE1hcF90eXBlID0gc3RydWN0XG4gIHR5cGUgKCdpbnB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsICdmX291dHB1dCkgdCA9XG4gICAgfCBNYXAgOiAoJ2lucHV0X2RhdGEsICdvdXRwdXRfZGF0YSwgJ291dHB1dF9kYXRhKSB0XG4gICAgfCBGaWx0ZXJfbWFwIDogKCdpbnB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSBvcHRpb24pIHRcblxuICAoKiBUaGUgZXh0cmEgdHlwZSB2YXJpYWJsZSAnYSBpcyB0byBhbGxvdyBpbiBmdXR1cmU6XG4gICAgIHwgRmlsdGVyIDogKCdvdXRwdXRfZGF0YSwgJ291dHB1dF9kYXRhLCBib29sKSB0ICopXG5lbmRcblxubW9kdWxlIEdlbmVyaWMgPSBzdHJ1Y3RcbiAgbGV0IHdpdGhfb2xkIH5pbnN0cnVtZW50YXRpb24gaSB+ZiA9XG4gICAgbGV0IG9wZW4gSW5jcmVtZW50YWwuTGV0X3N5bnRheCBpblxuICAgIGxldCBvbGQgPSByZWYgTm9uZSBpblxuICAgIGxldCVtYXAgYSA9IGkgaW5cbiAgICBpbnN0cnVtZW50YXRpb24uSW5zdHJ1bWVudGF0aW9uLmYgKGZ1biAoKSAtPlxuICAgICAgbGV0IGIgPSBmIH5vbGQ6IW9sZCBhIGluXG4gICAgICBvbGQgOj0gU29tZSAoYSwgYik7XG4gICAgICBiKVxuICA7O1xuXG4gIGxldCBjdXRvZmYgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pIG1hcCB+Y3V0b2ZmID1cbiAgICBsZXQgZGF0YV9lcXVhbCBvbGRfdmFsdWUgbmV3X3ZhbHVlID1cbiAgICAgIEluY3JlbWVudGFsLkN1dG9mZi5zaG91bGRfY3V0b2ZmIGN1dG9mZiB+b2xkX3ZhbHVlIH5uZXdfdmFsdWVcbiAgICBpblxuICAgIHdpdGhfb2xkIH5pbnN0cnVtZW50YXRpb24gbWFwIH5mOihmdW4gfm9sZCBjdXIgLT5cbiAgICAgIG1hdGNoIG9sZCB3aXRoXG4gICAgICB8IE5vbmUgLT4gY3VyXG4gICAgICB8IFNvbWUgKF9vbGRfaW4sIG9sZCkgLT5cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmYgfmRhdGFfZXF1YWwgfmluaXQ6b2xkIG9sZCBjdXIgfmY6KGZ1biBhY2MgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgfCBgTGVmdCBfb2xkIC0+IE1hcC5yZW1vdmUgYWNjIGtleVxuICAgICAgICAgIHwgYFJpZ2h0IG5ld18gLT4gTWFwLmFkZF9leG4gYWNjIH5rZXkgfmRhdGE6bmV3X1xuICAgICAgICAgIHwgYFVuZXF1YWwgKF9vbGQsIG5ld192YWx1ZSkgLT4gTWFwLnNldCBhY2MgfmtleSB+ZGF0YTpuZXdfdmFsdWUpKVxuICA7O1xuXG4gIGxldCB1bm9yZGVyZWRfZm9sZFxuICAgICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID91cGRhdGVcbiAgICAgICAgP3NwZWNpYWxpemVkX2luaXRpYWxcbiAgICAgICAgPyhmaW5hbGl6ZSA9IEZuLmlkKVxuICAgICAgICA/KHJldmVydF90b19pbml0X3doZW5fZW1wdHkgPSBmYWxzZSlcbiAgICAgICAgbWFwXG4gICAgICAgIH5pbml0XG4gICAgICAgIH5hZGRcbiAgICAgICAgfnJlbW92ZVxuICAgID1cbiAgICBsZXQgdXBkYXRlID1cbiAgICAgIGxldCBkZWZhdWx0IH5rZXkgfm9sZF9kYXRhIH5uZXdfZGF0YSBhY2MgPVxuICAgICAgICBhZGQgfmtleSB+ZGF0YTpuZXdfZGF0YSAocmVtb3ZlIH5rZXkgfmRhdGE6b2xkX2RhdGEgYWNjKVxuICAgICAgaW5cbiAgICAgIE9wdGlvbi52YWx1ZSB1cGRhdGUgfmRlZmF1bHRcbiAgICBpblxuICAgIHdpdGhfb2xkIH5pbnN0cnVtZW50YXRpb24gbWFwIH5mOihmdW4gfm9sZCBuZXdfaW4gLT5cbiAgICAgIGxldCBhY2MgPVxuICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAobWF0Y2ggc3BlY2lhbGl6ZWRfaW5pdGlhbCB3aXRoXG4gICAgICAgICAgIHwgTm9uZSAtPiBNYXAuZm9sZCB+aW5pdCB+ZjphZGQgbmV3X2luXG4gICAgICAgICAgIHwgU29tZSBpbml0aWFsIC0+IGluaXRpYWwgfmluaXQgbmV3X2luKVxuICAgICAgICB8IFNvbWUgKG9sZF9pbiwgb2xkX291dCkgLT5cbiAgICAgICAgICBpZiByZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5ICYmIE1hcC5sZW5ndGggbmV3X2luID0gMFxuICAgICAgICAgIHRoZW4gaW5pdFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIH5pbml0Om9sZF9vdXRcbiAgICAgICAgICAgICAgb2xkX2luXG4gICAgICAgICAgICAgIG5ld19pblxuICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICB+ZjooZnVuIGFjYyAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgICAgICAgICAgICB8IGBMZWZ0IG9sZCAtPiByZW1vdmUgfmtleSB+ZGF0YTpvbGQgYWNjXG4gICAgICAgICAgICAgICAgfCBgUmlnaHQgbmV3XyAtPiBhZGQgfmtleSB+ZGF0YTpuZXdfIGFjY1xuICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgKG9sZCwgbmV3XykgLT4gdXBkYXRlIH5rZXkgfm9sZF9kYXRhOm9sZCB+bmV3X2RhdGE6bmV3XyBhY2MpXG4gICAgICBpblxuICAgICAgZmluYWxpemUgYWNjKVxuICA7O1xuXG4gIGxldCB1bm9yZGVyZWRfZm9sZF9uZXN0ZWRfbWFwc1xuICAgICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XG4gICAgICAgID91cGRhdGVcbiAgICAgICAgaW5jcl9tYXBcbiAgICAgICAgfmluaXRcbiAgICAgICAgfmFkZFxuICAgICAgICB+cmVtb3ZlXG4gICAgPVxuICAgIGxldCB1cGRhdGUgPVxuICAgICAgbWF0Y2ggdXBkYXRlIHdpdGhcbiAgICAgIHwgU29tZSB1cGRhdGUgLT4gdXBkYXRlXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICAgIGFkZFxuICAgICAgICAgICAgfm91dGVyX2tleVxuICAgICAgICAgICAgfmlubmVyX2tleVxuICAgICAgICAgICAgfmRhdGE6bmV3X2RhdGFcbiAgICAgICAgICAgIChyZW1vdmUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhOm9sZF9kYXRhIGFjYylcbiAgICBpblxuICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICBpbmNyX21hcFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgP3JldmVydF90b19pbml0X3doZW5fZW1wdHlcbiAgICAgIH5pbml0XG4gICAgICB+dXBkYXRlOihmdW4gfmtleTpvdXRlcl9rZXkgfm9sZF9kYXRhOm9sZF9pbm5lcl9tYXAgfm5ld19kYXRhOm5ld19pbm5lcl9tYXAgYWNjIC0+XG4gICAgICAgIChNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZiBvbGRfaW5uZXJfbWFwIG5ld19pbm5lcl9tYXAgfmRhdGFfZXF1YWwpXG4gICAgICAgICAgfmluaXQ6YWNjXG4gICAgICAgICAgfmY6KGZ1biBhY2MgKGlubmVyX2tleSwgZGlmZikgLT5cbiAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgfCBgTGVmdCBkYXRhX3JlbW92ZWQgLT4gcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpkYXRhX3JlbW92ZWQgYWNjXG4gICAgICAgICAgICB8IGBSaWdodCBkYXRhX2FkZGVkIC0+IGFkZCB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6ZGF0YV9hZGRlZCBhY2NcbiAgICAgICAgICAgIHwgYFVuZXF1YWwgKG9sZF9kYXRhLCBuZXdfZGF0YSkgLT5cbiAgICAgICAgICAgICAgdXBkYXRlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYykgW0Bub250YWlsXSlcbiAgICAgIH5hZGQ6KGZ1biB+a2V5Om91dGVyX2tleSB+ZGF0YTppbm5lcl9tYXAgYWNjIC0+XG4gICAgICAgIE1hcC5mb2xkIGlubmVyX21hcCB+aW5pdDphY2MgfmY6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBhY2MgLT5cbiAgICAgICAgICBhZGQgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYykpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleTpvdXRlcl9rZXkgfmRhdGE6aW5uZXJfbWFwIGFjYyAtPlxuICAgICAgICBNYXAuZm9sZCBpbm5lcl9tYXAgfmluaXQ6YWNjIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgYWNjIC0+XG4gICAgICAgICAgcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YSBhY2MpKVxuICA7O1xuXG4gIGxldCB3aXRoX2NvbXBhcmF0b3InIGdldF9jb21wYXJhdG9yIHggZiA9XG4gICAgSW5jcmVtZW50YWwuYmluZCAoSW5jcmVtZW50YWwuZnJlZXplIChJbmNyZW1lbnRhbC5tYXAgeCB+ZjpnZXRfY29tcGFyYXRvcikpIH5mXG4gIDs7XG5cbiAgKCoqIENhcHR1cmVzIHRoZSBjb21wYXJhdG9yICh3aGljaCBjYW4ndCBjaGFuZ2UgYW55d2F5LCBzaW5jZSB0aGUgdHlwZSBkZXRlcm1pbmVzIHRoZVxuICAgICAgY29tcGFyYXRvcikgYnkgZnJlZXppbmcgdGhlIGNvcnJlc3BvbmRpbmcgbWFwLiAgTm90ZSB0aGF0IGJ5IGZpcnN0IHVzaW5nIEluY3JlbWVudGFsLm1hcCB0b1xuICAgICAgZ2V0IHRoZSBjb21wYXJhdG9yIG91dCBvZiB0aGUgbWFwLCB3ZSBhbGxvdyB0aGUgaW5pdGlhbCBtYXAgaXRzZWxmIHRvIGJlIGdhcmJhZ2VcbiAgICAgIGNvbGxlY3RlZCAqKVxuICBsZXQgd2l0aF9jb21wYXJhdG9yIG1hcCBmID0gd2l0aF9jb21wYXJhdG9yJyBNYXAuY29tcGFyYXRvciBtYXAgZlxuXG4gIGxldCBvZl9zZXQgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pIHNldCA9XG4gICAgd2l0aF9jb21wYXJhdG9yJyBTZXQuY29tcGFyYXRvciBzZXQgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgb2xkX2lucHV0ID0gcmVmIChTZXQuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcikgaW5cbiAgICAgIGxldCBvbGRfb3V0cHV0ID0gcmVmIChNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcikgaW5cbiAgICAgIEluY3JlbWVudGFsLm1hcCBzZXQgfmY6KGZ1biBuZXdfaW5wdXQgLT5cbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbi5mIChmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgbmV3X291dHB1dCA9XG4gICAgICAgICAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICAgICAgICAgIChTZXQuc3ltbWV0cmljX2RpZmYgIW9sZF9pbnB1dCBuZXdfaW5wdXQpXG4gICAgICAgICAgICAgIH5pbml0OiFvbGRfb3V0cHV0XG4gICAgICAgICAgICAgIH5mOihmdW4gb3V0cHV0IC0+IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgfCBGaXJzdCBrIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtcbiAgICAgICAgICAgICAgICB8IFNlY29uZCBrIC0+IE1hcC5hZGRfZXhuIG91dHB1dCB+a2V5OmsgfmRhdGE6KCkpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBvbGRfaW5wdXQgOj0gbmV3X2lucHV0O1xuICAgICAgICAgIG9sZF9vdXRwdXQgOj0gbmV3X291dHB1dDtcbiAgICAgICAgICBuZXdfb3V0cHV0KSkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaVxuICAgICAgICAodHlwZSBpbnB1dF9kYXRhIG91dHB1dF9kYXRhIGZfb3V0cHV0IHN0YXRlX3dpdG5lc3MpXG4gICAgICAgICh3aXRuZXNzIDogKGlucHV0X2RhdGEsIG91dHB1dF9kYXRhLCBmX291dHB1dCkgTWFwX3R5cGUudClcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICAobWFwIDogKCgna2V5LCBpbnB1dF9kYXRhLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgfihmIDoga2V5OidrZXkgLT4gZGF0YTppbnB1dF9kYXRhIC0+IGZfb3V0cHV0KVxuICAgID1cbiAgICB3aXRoX29sZCB+aW5zdHJ1bWVudGF0aW9uIG1hcCB+ZjooZnVuIH5vbGQgaW5wdXQgLT5cbiAgICAgIG1hdGNoIG9sZCwgTWFwLmxlbmd0aCBpbnB1dCB3aXRoXG4gICAgICB8IF8sIDAgfCBOb25lLCBfIC0+XG4gICAgICAgIChtYXRjaCB3aXRuZXNzIHdpdGhcbiAgICAgICAgIHwgTWFwX3R5cGUuTWFwIC0+IChNYXAubWFwaSBpbnB1dCB+ZiA6ICgna2V5LCBvdXRwdXRfZGF0YSwgJ2NtcCkgTWFwLnQpXG4gICAgICAgICB8IE1hcF90eXBlLkZpbHRlcl9tYXAgLT4gTWFwLmZpbHRlcl9tYXBpIGlucHV0IH5mKVxuICAgICAgfCBTb21lIChvbGRfaW5wdXQsIG9sZF9vdXRwdXQpLCBfIC0+XG4gICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgb2xkX2lucHV0XG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgIH5pbml0Om9sZF9vdXRwdXRcbiAgICAgICAgICB+ZjooZnVuIG91dHB1dCAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICBtYXRjaCBjaGFuZ2Ugd2l0aFxuICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtleVxuICAgICAgICAgICAgfCBgUmlnaHQgbmV3X2RhdGEgfCBgVW5lcXVhbCAoXywgbmV3X2RhdGEpIC0+XG4gICAgICAgICAgICAgIGxldCByZXMgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgICAgICAgKG1hdGNoIHdpdG5lc3Mgd2l0aFxuICAgICAgICAgICAgICAgfCBNYXBfdHlwZS5NYXAgLT4gTWFwLnNldCBvdXRwdXQgfmtleSB+ZGF0YTpyZXNcbiAgICAgICAgICAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggcmVzIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG91dHB1dCBrZXlcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBvdXRwdXRfZGF0YSAtPiBNYXAuc2V0IG91dHB1dCB+a2V5IH5kYXRhOm91dHB1dF9kYXRhKSkpKVxuICA7O1xuXG4gIGxldCBtYXBpID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGdlbmVyaWNfbWFwaSBNYXAgfmluc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgZ2VuZXJpY19tYXBpIEZpbHRlcl9tYXAgfmluc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgOztcblxuICBsZXQgbWFwID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBtYXBpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgZmlsdGVyX21hcGkgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCB3aXRoX29sZDIgfmluc3RydW1lbnRhdGlvbiBpMSBpMiB+ZiA9XG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgSW5jcmVtZW50YWwubWFwMiBpMSBpMiB+ZjooZnVuIGExIGEyIC0+XG4gICAgICBpbnN0cnVtZW50YXRpb24uSW5zdHJ1bWVudGF0aW9uLmYgKGZ1biAoKSAtPlxuICAgICAgICBsZXQgYiA9IGYgfm9sZDohb2xkIGExIGEyIGluXG4gICAgICAgIG9sZCA6PSBTb21lIChhMSwgYTIsIGIpO1xuICAgICAgICBiKSlcbiAgOztcblxuICBsZXQgdW5vcmRlcmVkX2ZvbGRfd2l0aF9leHRyYVxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgPyhleHRyYV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID91cGRhdGVcbiAgICAgICAgP3NwZWNpYWxpemVkX2luaXRpYWxcbiAgICAgICAgPyhmaW5hbGl6ZSA9IEZuLmlkKVxuICAgICAgICA/KHJldmVydF90b19pbml0X3doZW5fZW1wdHkgPSBmYWxzZSlcbiAgICAgICAgbWFwXG4gICAgICAgIGV4dHJhXG4gICAgICAgIH5pbml0XG4gICAgICAgIH5hZGRcbiAgICAgICAgfnJlbW92ZVxuICAgICAgICB+ZXh0cmFfY2hhbmdlZFxuICAgID1cbiAgICBsZXQgdXBkYXRlID1cbiAgICAgIGxldCBkZWZhdWx0IH5rZXkgfm9sZF9kYXRhIH5uZXdfZGF0YSBhY2MgZXh0cmEgPVxuICAgICAgICBhZGQgfmtleSB+ZGF0YTpuZXdfZGF0YSAocmVtb3ZlIH5rZXkgfmRhdGE6b2xkX2RhdGEgYWNjIGV4dHJhKSBleHRyYVxuICAgICAgaW5cbiAgICAgIE9wdGlvbi52YWx1ZSB1cGRhdGUgfmRlZmF1bHRcbiAgICBpblxuICAgIHdpdGhfb2xkMiB+aW5zdHJ1bWVudGF0aW9uIG1hcCBleHRyYSB+ZjooZnVuIH5vbGQgbmV3X2luIG5ld19leHRyYSAtPlxuICAgICAgbGV0IGFjYyA9XG4gICAgICAgIG1hdGNoIG9sZCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIChtYXRjaCBzcGVjaWFsaXplZF9pbml0aWFsIHdpdGhcbiAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgTWFwLmZvbGQgbmV3X2luIH5pbml0IH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIH5rZXkgfmRhdGEgYWNjIG5ld19leHRyYSlcbiAgICAgICAgICAgfCBTb21lIGluaXRpYWwgLT4gaW5pdGlhbCB+aW5pdCBuZXdfaW4gbmV3X2V4dHJhKVxuICAgICAgICB8IFNvbWUgKG9sZF9pbiwgb2xkX2V4dHJhLCBvbGRfb3V0KSAtPlxuICAgICAgICAgIGxldCBhY2MgPVxuICAgICAgICAgICAgaWYgZXh0cmFfZXF1YWwgb2xkX2V4dHJhIG5ld19leHRyYVxuICAgICAgICAgICAgdGhlbiBvbGRfb3V0XG4gICAgICAgICAgICBlbHNlIGV4dHJhX2NoYW5nZWQgfm9sZF9leHRyYSB+bmV3X2V4dHJhIH5pbnB1dDpvbGRfaW4gb2xkX291dFxuICAgICAgICAgIGluXG4gICAgICAgICAgaWYgcmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eSAmJiBNYXAubGVuZ3RoIG5ld19pbiA9IDBcbiAgICAgICAgICB0aGVuIGluaXRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICB+aW5pdDphY2NcbiAgICAgICAgICAgICAgb2xkX2luXG4gICAgICAgICAgICAgIG5ld19pblxuICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICB+ZjooZnVuIGFjYyAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgICAgICAgICAgICB8IGBMZWZ0IG9sZCAtPiByZW1vdmUgfmtleSB+ZGF0YTpvbGQgYWNjIG5ld19leHRyYVxuICAgICAgICAgICAgICAgIHwgYFJpZ2h0IG5ld18gLT4gYWRkIH5rZXkgfmRhdGE6bmV3XyBhY2MgbmV3X2V4dHJhXG4gICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAob2xkLCBuZXdfKSAtPlxuICAgICAgICAgICAgICAgICAgdXBkYXRlIH5rZXkgfm9sZF9kYXRhOm9sZCB+bmV3X2RhdGE6bmV3XyBhY2MgbmV3X2V4dHJhKVxuICAgICAgaW5cbiAgICAgIGZpbmFsaXplIGFjYylcbiAgOztcblxuICBsZXQgbWFwaV9jb3VudFxuICAgICAgICAodHlwZSBhIGNtcClcbiAgICAgICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGlucHV0XG4gICAgICAgIH4oY29tcGFyYXRvciA6IChtb2R1bGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApKVxuICAgICAgICB+ZlxuICAgID1cbiAgICBsZXQgbW9kdWxlIE0gPSAodmFsIGNvbXBhcmF0b3IpIGluXG4gICAgbGV0IGFkZCBuZXdfa2V5IGFjYyA9XG4gICAgICBNYXAudXBkYXRlIGFjYyBuZXdfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT4gMVxuICAgICAgICB8IFNvbWUgbiAtPiBuICsgMSlcbiAgICBpblxuICAgIGxldCByZW1vdmUgbmV3X2tleSBhY2MgPVxuICAgICAgTWFwLmNoYW5nZSBhY2MgbmV3X2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIDEgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgbiAtPiBTb21lIChuIC0gMSkpXG4gICAgaW5cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIGlucHV0XG4gICAgICB+aW5pdDooTWFwLmVtcHR5IChtb2R1bGUgTSkpXG4gICAgICB+YWRkOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIChmIH5rZXkgfmRhdGEpIGFjYylcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiByZW1vdmUgKGYgfmtleSB+ZGF0YSkgYWNjKVxuICAgICAgfnVwZGF0ZTooZnVuIH5rZXkgfm9sZF9kYXRhIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgbGV0IHByZXZfa2V5ID0gZiB+a2V5IH5kYXRhOm9sZF9kYXRhIGluXG4gICAgICAgIGxldCBuZXdfa2V5ID0gZiB+a2V5IH5kYXRhOm5ld19kYXRhIGluXG4gICAgICAgIGlmIE0uY29tcGFyYXRvci5jb21wYXJlIHByZXZfa2V5IG5ld19rZXkgPSAwXG4gICAgICAgIHRoZW4gYWNjXG4gICAgICAgIGVsc2UgYWNjIHw+IHJlbW92ZSBwcmV2X2tleSB8PiBhZGQgbmV3X2tleSlcbiAgOztcblxuICBsZXQgbWFwX2NvdW50ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIG1hcGlfY291bnQgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPlxuICAgICAgZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtaW5faGVscGVyIG1hcCA9XG4gICAgbWF0Y2ggTWFwLm1pbl9lbHQgbWFwIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSAobWluLCBfKSAtPiBTb21lIG1pblxuICA7O1xuXG4gIGxldCBtYXhfaGVscGVyIG1hcCA9XG4gICAgbWF0Y2ggTWFwLm1heF9lbHQgbWFwIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSAobWF4LCBfKSAtPiBTb21lIG1heFxuICA7O1xuXG4gIGxldCBib3VuZHNfaGVscGVyIG1hcCA9XG4gICAgbWF0Y2ggTWFwLm1pbl9lbHQgbWFwLCBNYXAubWF4X2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtaW4sIF8pLCBTb21lIChtYXgsIF8pIC0+IFNvbWUgKG1pbiwgbWF4KVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgbWFwaV9taW4gP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwXG4gICAgICB+ZjptaW5faGVscGVyXG4gICAgICAobWFwaV9jb3VudCA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mKVxuICA7O1xuXG4gIGxldCBtYXBpX21heCA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXBcbiAgICAgIH5mOm1heF9oZWxwZXJcbiAgICAgIChtYXBpX2NvdW50ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYpXG4gIDs7XG5cbiAgbGV0IG1hcGlfYm91bmRzID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcFxuICAgICAgfmY6Ym91bmRzX2hlbHBlclxuICAgICAgKG1hcGlfY291bnQgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZilcbiAgOztcblxuICBsZXQgbWFwX21pbiA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX21pbiA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+XG4gICAgICBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1hcF9tYXggP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9tYXggP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPlxuICAgICAgZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtaW5fdmFsdWUgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX21pbiA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOkZuLmlkXG4gIDs7XG5cbiAgbGV0IG1heF92YWx1ZSA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yID1cbiAgICBtYXBfbWF4ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6Rm4uaWRcbiAgOztcblxuICBsZXQgbWFwX2JvdW5kcyA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX2JvdW5kcyA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+XG4gICAgICBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHZhbHVlX2JvdW5kcyA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yID1cbiAgICBtYXBfYm91bmRzID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6Rm4uaWRcbiAgOztcblxuICBsZXQgbWVyZ2Vfc2hhcmVkX2ltcGxcbiAgICAgICAgfm9sZFxuICAgICAgICB+bmV3X2xlZnRfbWFwXG4gICAgICAgIH5uZXdfcmlnaHRfbWFwXG4gICAgICAgIH5kYXRhX2VxdWFsX2xlZnRcbiAgICAgICAgfmRhdGFfZXF1YWxfcmlnaHRcbiAgICAgICAgfmZcbiAgICA9XG4gICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBuZXdfbGVmdF9tYXAgaW5cbiAgICBsZXQgb2xkX2xlZnRfbWFwLCBvbGRfcmlnaHRfbWFwLCBvbGRfb3V0cHV0ID1cbiAgICAgIG1hdGNoIG9sZCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgICAgZW1wdHksIGVtcHR5LCBlbXB0eVxuICAgICAgfCBTb21lIHggLT4geFxuICAgIGluXG4gICAgbGV0IGxlZnRfZGlmZiA9XG4gICAgICBNYXAuc3ltbWV0cmljX2RpZmYgb2xkX2xlZnRfbWFwIG5ld19sZWZ0X21hcCB+ZGF0YV9lcXVhbDpkYXRhX2VxdWFsX2xlZnRcbiAgICBpblxuICAgIGxldCByaWdodF9kaWZmID1cbiAgICAgIE1hcC5zeW1tZXRyaWNfZGlmZiBvbGRfcmlnaHRfbWFwIG5ld19yaWdodF9tYXAgfmRhdGFfZXF1YWw6ZGF0YV9lcXVhbF9yaWdodFxuICAgIGluXG4gICAgKCogV2UgbWVyZ2UgdGhlIHR3byBzaWRlcyBvZiB0aGUgZGlmZnMgdG9nZXRoZXIgc28gd2UgY2FuIG1ha2Ugc3VyZSB0byBoYW5kbGUgZWFjaFxuICAgICAgIGtleSBleGFjdGx5IG9uY2UuIFRoaXMgcmVsaWVzIG9uIHN5bW1ldHJpYyBkaWZmIGdpdmluZyBzb3J0ZWQgb3V0cHV0LiAqKVxuICAgIFNlcXVlbmNlLm1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAgICAgbGVmdF9kaWZmXG4gICAgICByaWdodF9kaWZmXG4gICAgICB+Y29tcGFyZTooZnVuIChsZWZ0X2tleSwgXykgKHJpZ2h0X2tleSwgXykgLT4gY29tcGFyYXRvci5jb21wYXJlIGxlZnRfa2V5IHJpZ2h0X2tleSlcbiAgICB8PiBTZXF1ZW5jZS5mb2xkIH5pbml0Om9sZF9vdXRwdXQgfmY6KGZ1biBvdXRwdXQgZGlmZl9lbGVtZW50IC0+XG4gICAgICBsZXQga2V5ID1cbiAgICAgICAgbWF0Y2ggZGlmZl9lbGVtZW50IHdpdGhcbiAgICAgICAgfCBMZWZ0IChrZXksIF8pIHwgUmlnaHQgKGtleSwgXykgLT4ga2V5XG4gICAgICAgIHwgQm90aCAoKGxlZnRfa2V5LCBfKSwgKF9yaWdodF9rZXksIF8pKSAtPlxuICAgICAgICAgICgqIGNvbXBhcmlzb24gZnVuY3Rpb25zIGNhbiBiZSBleHBlbnNpdmUhICopXG4gICAgICAgICAgKCogYXNzZXJ0IChjb21wYXJhdG9yLmNvbXBhcmUgbGVmdF9rZXkgcmlnaHRfa2V5ID0gMCk7ICopXG4gICAgICAgICAgbGVmdF9rZXlcbiAgICAgIGluXG4gICAgICBmIH5vbGRfb3V0cHV0IH5rZXkgfm91dHB1dCB+ZGlmZl9lbGVtZW50KVxuICA7O1xuXG4gIGxldCBuZXdfZGF0YV9mcm9tX2RpZmZfZWxlbWVudCA9IGZ1bmN0aW9uXG4gICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICB8IGBSaWdodCB4IHwgYFVuZXF1YWwgKF8sIHgpIC0+IFNvbWUgeFxuICA7O1xuXG4gIGxldCBtZXJnZVxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgPyhkYXRhX2VxdWFsX2xlZnQgPSBwaHlzX2VxdWFsKVxuICAgICAgICA/KGRhdGFfZXF1YWxfcmlnaHQgPSBwaHlzX2VxdWFsKVxuICAgICAgICBsZWZ0X21hcFxuICAgICAgICByaWdodF9tYXBcbiAgICAgICAgfmZcbiAgICA9XG4gICAgd2l0aF9vbGQyXG4gICAgICBsZWZ0X21hcFxuICAgICAgcmlnaHRfbWFwXG4gICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICB+ZjooZnVuIH5vbGQgbmV3X2xlZnRfbWFwIG5ld19yaWdodF9tYXAgLT5cbiAgICAgICAgbWVyZ2Vfc2hhcmVkX2ltcGxcbiAgICAgICAgICB+b2xkXG4gICAgICAgICAgfm5ld19sZWZ0X21hcFxuICAgICAgICAgIH5uZXdfcmlnaHRfbWFwXG4gICAgICAgICAgfmRhdGFfZXF1YWxfbGVmdFxuICAgICAgICAgIH5kYXRhX2VxdWFsX3JpZ2h0XG4gICAgICAgICAgfmY6KGZ1biB+b2xkX291dHB1dDpfIH5rZXkgfm91dHB1dCB+ZGlmZl9lbGVtZW50IC0+XG4gICAgICAgICAgICAoKiBUaGVzZSB2YWx1ZXMgcmVwcmVzZW50IHdoZXRoZXIgdGhlcmUgaXMgZGF0YSBmb3IgdGhlIGdpdmVuIGtleSBpbiB0aGUgbmV3XG4gICAgICAgICAgICAgICBpbnB1dCBpbiB0aGUgbGVmdCBhbmQgcmlnaHQgbWFwLiAqKVxuICAgICAgICAgICAgbGV0IGxlZnRfZGF0YV9vcHQsIHJpZ2h0X2RhdGFfb3B0ID1cbiAgICAgICAgICAgICAgbWF0Y2ggZGlmZl9lbGVtZW50IHdpdGhcbiAgICAgICAgICAgICAgfCBCb3RoICgoXywgbGVmdF9kaWZmKSwgKF8sIHJpZ2h0X2RpZmYpKSAtPlxuICAgICAgICAgICAgICAgIG5ld19kYXRhX2Zyb21fZGlmZl9lbGVtZW50IGxlZnRfZGlmZiwgbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgcmlnaHRfZGlmZlxuICAgICAgICAgICAgICB8IExlZnQgKF8sIGxlZnRfZGlmZikgLT5cbiAgICAgICAgICAgICAgICBuZXdfZGF0YV9mcm9tX2RpZmZfZWxlbWVudCBsZWZ0X2RpZmYsIE1hcC5maW5kIG5ld19yaWdodF9tYXAga2V5XG4gICAgICAgICAgICAgIHwgUmlnaHQgKF8sIHJpZ2h0X2RpZmYpIC0+XG4gICAgICAgICAgICAgICAgTWFwLmZpbmQgbmV3X2xlZnRfbWFwIGtleSwgbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgcmlnaHRfZGlmZlxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxldCBvdXRwdXRfZGF0YV9vcHQgPVxuICAgICAgICAgICAgICBtYXRjaCBsZWZ0X2RhdGFfb3B0LCByaWdodF9kYXRhX29wdCB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgU29tZSB4LCBOb25lIC0+IGYgfmtleSAoYExlZnQgeClcbiAgICAgICAgICAgICAgfCBOb25lLCBTb21lIHkgLT4gZiB+a2V5IChgUmlnaHQgeSlcbiAgICAgICAgICAgICAgfCBTb21lIHgsIFNvbWUgeSAtPiBmIH5rZXkgKGBCb3RoICh4LCB5KSlcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBtYXRjaCBvdXRwdXRfZGF0YV9vcHQgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtleVxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT4gTWFwLnNldCBvdXRwdXQgfmtleSB+ZGF0YSkpXG4gIDs7XG5cbiAgbGV0IG1lcmdlX2JvdGhfc29tZVxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgPyhkYXRhX2VxdWFsX2xlZnQgPSBwaHlzX2VxdWFsKVxuICAgICAgICA/KGRhdGFfZXF1YWxfcmlnaHQgPSBwaHlzX2VxdWFsKVxuICAgICAgICA/KG91dF9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGxlZnRfbWFwXG4gICAgICAgIHJpZ2h0X21hcFxuICAgICAgICB+ZlxuICAgID1cbiAgICB3aXRoX29sZDJcbiAgICAgIGxlZnRfbWFwXG4gICAgICByaWdodF9tYXBcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgIH5mOihmdW4gfm9sZCBuZXdfbGVmdF9tYXAgbmV3X3JpZ2h0X21hcCAtPlxuICAgICAgICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIG5ld19sZWZ0X21hcCBpblxuICAgICAgICBsZXQgZW1wdHkgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICBtYXRjaCBNYXAubGVuZ3RoIG5ld19sZWZ0X21hcCwgTWFwLmxlbmd0aCBuZXdfcmlnaHRfbWFwIHdpdGhcbiAgICAgICAgKCogQmVjYXVzZSB3ZSBvbmx5IGNhcmUgYWJvdXQga2V5cyB0aGF0IGFyZSBpbiBib3RoIG1hcHMsIGlmIGVpdGhlciBtYXAgaXNcbiAgICAgICAgICAgZW1wdHksIGJhaWwgZWFybHkuICopXG4gICAgICAgIHwgMCwgXyB8IF8sIDAgLT4gZW1wdHlcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgbWVyZ2Vfc2hhcmVkX2ltcGxcbiAgICAgICAgICAgIH5vbGRcbiAgICAgICAgICAgIH5uZXdfbGVmdF9tYXBcbiAgICAgICAgICAgIH5uZXdfcmlnaHRfbWFwXG4gICAgICAgICAgICB+ZGF0YV9lcXVhbF9sZWZ0XG4gICAgICAgICAgICB+ZGF0YV9lcXVhbF9yaWdodFxuICAgICAgICAgICAgfmY6KGZ1biB+b2xkX291dHB1dCB+a2V5IH5vdXRwdXQgfmRpZmZfZWxlbWVudCAtPlxuICAgICAgICAgICAgICBsZXQgbGVmdF9hbmRfcmlnaHRfZGF0YV9vcHQgPVxuICAgICAgICAgICAgICAgIGxldCBvcGVuIE9wdGlvbi5MZXRfc3ludGF4IGluXG4gICAgICAgICAgICAgICAgbWF0Y2ggZGlmZl9lbGVtZW50IHdpdGhcbiAgICAgICAgICAgICAgICB8IEJvdGggKChfLCBsZWZ0X2RpZmYpLCAoXywgcmlnaHRfZGlmZikpIC0+XG4gICAgICAgICAgICAgICAgICBsZXQlYmluZCBsZWZ0X2RhdGEgPSBuZXdfZGF0YV9mcm9tX2RpZmZfZWxlbWVudCBsZWZ0X2RpZmYgaW5cbiAgICAgICAgICAgICAgICAgIGxldCVtYXAgcmlnaHRfZGF0YSA9IG5ld19kYXRhX2Zyb21fZGlmZl9lbGVtZW50IHJpZ2h0X2RpZmYgaW5cbiAgICAgICAgICAgICAgICAgIGxlZnRfZGF0YSwgcmlnaHRfZGF0YVxuICAgICAgICAgICAgICAgIHwgTGVmdCAoXywgbGVmdF9kaWZmKSAtPlxuICAgICAgICAgICAgICAgICAgbGV0JWJpbmQgbGVmdF9kYXRhID0gbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgbGVmdF9kaWZmIGluXG4gICAgICAgICAgICAgICAgICBsZXQlbWFwIHJpZ2h0X2RhdGEgPSBNYXAuZmluZCBuZXdfcmlnaHRfbWFwIGtleSBpblxuICAgICAgICAgICAgICAgICAgbGVmdF9kYXRhLCByaWdodF9kYXRhXG4gICAgICAgICAgICAgICAgfCBSaWdodCAoXywgcmlnaHRfZGlmZikgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgbWF0Y2ggYXJtIGJpbmRzIFtyaWdodF9kYXRhXSBmaXJzdCBiZWNhdXNlIHRoZSBtYXAgbG9va3VwXG4gICAgICAgICAgICAgICAgICAgICBpcyBzbG93ZXIgdGhhbiBjYWxsaW5nIFtuZXdfZGF0YV9mcm9tX2RpZmZfZWxlbWVudF0uICopXG4gICAgICAgICAgICAgICAgICBsZXQlYmluZCByaWdodF9kYXRhID0gbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgcmlnaHRfZGlmZiBpblxuICAgICAgICAgICAgICAgICAgbGV0JW1hcCBsZWZ0X2RhdGEgPSBNYXAuZmluZCBuZXdfbGVmdF9tYXAga2V5IGluXG4gICAgICAgICAgICAgICAgICBsZWZ0X2RhdGEsIHJpZ2h0X2RhdGFcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCogbG9vayBmb3IgdGhlIHByZXZpb3VzbHkgY29tcHV0ZWQgdmFsdWUgdG8gc2VlIGlmIHdlIGFjdHVhbGx5IG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgYWRkIG9yIHJlbW92ZSB0aGUga2V5LiAqKVxuICAgICAgICAgICAgICBsZXQgcHJldl9vdXQgPSBNYXAuZmluZCBvbGRfb3V0cHV0IGtleSBpblxuICAgICAgICAgICAgICBtYXRjaCBsZWZ0X2FuZF9yaWdodF9kYXRhX29wdCB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSAoeCwgeSkgLT5cbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGYgfmtleSB4IHkgaW5cbiAgICAgICAgICAgICAgICAobWF0Y2ggcHJldl9vdXQgd2l0aFxuICAgICAgICAgICAgICAgICAoKiBpZiB0aGUgbmV3IHJlc3VsdCBpcyB0aGUgc2FtZSBhcyB0aGUgb2xkLCBkb24ndCBjaGFuZ2UgdGhlIG1hcCAqKVxuICAgICAgICAgICAgICAgICB8IFNvbWUgcHJldl9vdXQgd2hlbiBvdXRfZXF1YWwgZGF0YSBwcmV2X291dCAtPiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE1hcC5zZXQgb3V0cHV0IH5rZXkgfmRhdGEpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgIChtYXRjaCBwcmV2X291dCB3aXRoXG4gICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgfCBTb21lIF8gLT4gTWFwLnJlbW92ZSBvdXRwdXQga2V5KSkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgICAgICh0eXBlIGlucHV0X2RhdGEgb3V0cHV0X2RhdGEgZl9vdXRwdXQgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgKHdpdG5lc3MgOiAoaW5wdXRfZGF0YSwgb3V0cHV0X2RhdGEsIGZfb3V0cHV0KSBNYXBfdHlwZS50KVxuICAgICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID9jdXRvZmZcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgKGxocyA6ICgoJ2tleSwgaW5wdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oY29tcGFyYXRvciA6ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLnQpXG4gICAgICAgIH4oZiA6XG4gICAgICAgICAgICBrZXk6J2tleVxuICAgICAgICAgIC0+IGRhdGE6KGlucHV0X2RhdGEsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAoZl9vdXRwdXQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgOiAoKCdrZXksIG91dHB1dF9kYXRhLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBsaHMgaW5cbiAgICBsZXQgZW1wdHlfbWFwID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICBsZXQgcHJldl9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IHByZXZfbm9kZXMgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGFjYyA6ICgna2V5LCBvdXRwdXRfZGF0YSwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIWFjYykgaW5cbiAgICBsZXQgKG9uX2lubmVyX2NoYW5nZSA6IGtleTona2V5IC0+IGZfb3V0cHV0IC0+IHVuaXQpID1cbiAgICAgIG1hdGNoIHdpdG5lc3Mgd2l0aFxuICAgICAgfCBNYXBfdHlwZS5NYXAgLT4gZnVuIH5rZXkgZGF0YSAtPiBhY2MgOj0gTWFwLnNldCAhYWNjIH5rZXkgfmRhdGFcbiAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPlxuICAgICAgICBmdW4gfmtleSBvcHQgLT5cbiAgICAgICAgICBsZXQgb2xkID0gIWFjYyBpblxuICAgICAgICAgIGFjY1xuICAgICAgICAgIDo9IChtYXRjaCBvcHQgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IE1hcC5yZW1vdmUgb2xkIGtleVxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT4gTWFwLnNldCBvbGQgfmtleSB+ZGF0YSlcbiAgICBpblxuICAgIGxldCByZWMgbGhzX2NoYW5nZSA9XG4gICAgICBsYXp5XG4gICAgICAgIChJbmNyZW1lbnRhbC5tYXAgbGhzIH5mOihmdW4gbWFwIC0+XG4gICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5JbnN0cnVtZW50YXRpb24uZiAoZnVuICgpIC0+XG4gICAgICAgICAgICAgbGV0IG5ld19ub2RlcyA9XG4gICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICAhcHJldl9tYXBcbiAgICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICAgIH5pbml0OiFwcmV2X25vZGVzXG4gICAgICAgICAgICAgICAgIH5mOihmdW4gbm9kZXMgKGtleSwgY2hhbmdlZCkgLT5cbiAgICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IGBVbmVxdWFsIF8gLT5cbiAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBfZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLm1ha2Vfc3RhbGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gTWFwLnJlbW92ZSBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSByZXN1bHQgZGVwO1xuICAgICAgICAgICAgICAgICAgICAgYWNjIDo9IE1hcC5yZW1vdmUgIWFjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgICBFLk5vZGUuaW52YWxpZGF0ZSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgICAgICAgICB8IGBSaWdodCBfIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9XG4gICAgICAgICAgICAgICAgICAgICAgIEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgIE1hcC5maW5kX2V4biAhcHJldl9tYXAga2V5KVxuICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgIE9wdGlvbi5pdGVyIGN1dG9mZiB+ZjooZnVuIGMgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuc2V0X2N1dG9mZiAoRS5Ob2RlLndhdGNoIG5vZGUpIGMpO1xuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IG5vZGUgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGxoc19jaGFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgIGxldCB1c2VyX2Z1bmN0aW9uX2RlcCA9XG4gICAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAoZiB+a2V5IH5kYXRhOihFLk5vZGUud2F0Y2ggbm9kZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgfm9uX2NoYW5nZToob25faW5uZXJfY2hhbmdlIH5rZXkpXG4gICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCB1c2VyX2Z1bmN0aW9uX2RlcDtcbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zZXQgbm9kZXMgfmtleSB+ZGF0YToobm9kZSwgdXNlcl9mdW5jdGlvbl9kZXApKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgcHJldl9ub2RlcyA6PSBuZXdfbm9kZXM7XG4gICAgICAgICAgICAgcHJldl9tYXAgOj0gbWFwKSkpXG4gICAgaW5cbiAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBsaHNfY2hhbmdlKSk7XG4gICAgRS5Ob2RlLndhdGNoIHJlc3VsdFxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaScgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgTWFwX3R5cGUuRmlsdGVyX21hcFxuICAgICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID9jdXRvZmZcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgbWFwXG4gICAgICAgIH5mXG4gICAgICAgIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBtYXBpJyA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbikgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBnZW5lcmljX21hcGlfd2l0aF9jb21wYXJhdG9yJ1xuICAgICAgICBNYXBfdHlwZS5NYXBcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBtYXBpJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCcgP2luc3RydW1lbnRhdGlvbiA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgZmlsdGVyX21hcGknID9pbnN0cnVtZW50YXRpb24gP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtZXJnZScgP2luc3RydW1lbnRhdGlvbiA/Y3V0b2ZmID9kYXRhX2VxdWFsX2xlZnQgP2RhdGFfZXF1YWxfcmlnaHQgbWFwMSBtYXAyIH5mID1cbiAgICBtZXJnZVxuICAgICAgP2luc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxfbGVmdFxuICAgICAgP2RhdGFfZXF1YWxfcmlnaHRcbiAgICAgIG1hcDFcbiAgICAgIG1hcDJcbiAgICAgIH5mOihmdW4gfmtleTpfIGRpZmYgLT4gU29tZSBkaWZmKVxuICAgIHw+IGZpbHRlcl9tYXBpJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgfmY6KGZ1biB+a2V5IH5kYXRhOmRpZmYgLT4gZiB+a2V5IGRpZmYpXG4gIDs7XG5cbiAgbGV0IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgICh0eXBlIHYgdjEgdjIgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICA/KGRhdGFfZXF1YWwgOiB2IC0+IHYgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8obGVmdF9yZXN1bHRfZXF1YWwgOiB2MSAtPiB2MSAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgPyhyaWdodF9yZXN1bHRfZXF1YWwgOiB2MiAtPiB2MiAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgKGlucHV0IDogKCgna2V5LCB2LCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgfihjb21wYXJhdG9yIDogKCdrZXksICdjbXApIENvbXBhcmF0b3IudClcbiAgICAgICAgfihmIDoga2V5OidrZXkgLT4gZGF0YTp2IC0+IHYxICogdjIpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBsZWZ0X2FjYyA6ICgna2V5LCB2MSwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBsZWZ0X3Jlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhbGVmdF9hY2MpIGluXG4gICAgbGV0IHJpZ2h0X2FjYyA6ICgna2V5LCB2MiwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByaWdodF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJpZ2h0X2FjYykgaW5cbiAgICBsZXQgcHJldl9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGlucHV0X2NoYW5nZSA9XG4gICAgICBJbmNyZW1lbnRhbC5tYXAgaW5wdXQgfmY6KGZ1biBtYXAgLT5cbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbi5mIChmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgbGVmdCwgcmlnaHQgPVxuICAgICAgICAgICAgbWF0Y2ggTWFwLmlzX2VtcHR5ICFwcmV2X21hcCwgTWFwLmlzX2VtcHR5IG1hcCB3aXRoXG4gICAgICAgICAgICB8IHRydWUsIHRydWUgfCBmYWxzZSwgdHJ1ZSAtPiBlbXB0eV9tYXAsIGVtcHR5X21hcFxuICAgICAgICAgICAgfCB0cnVlLCBmYWxzZSAtPlxuICAgICAgICAgICAgICAoKiBNYXBwaW5nIG9uIGEgbWFwIGlzIHdheSBmYXN0ZXIgdGhhbiBzeW1tZXRyaWMgZGlmZmluZyBhbmQgdGhlblxuICAgICAgICAgICAgICAgICBidWlsZGluZyB0aGUgbWFwcyB1cCBwaWVjZSBieSBwaWVjZSwgc28gd2UgZG8gdGhpcyB3aGVuZXZlciB3ZVxuICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uIGZyb20gXCJlbXB0eVwiIHRvIFwic29tZXRoaW5nXCIsIHdoaWNoIHdpbGwgYWxtb3N0IGFsd2F5c1xuICAgICAgICAgICAgICAgICBoYXBwZW4gb24gdGhlIGZpcnN0IHN0YWJpbGl6YXRpb24uICopXG4gICAgICAgICAgICAgIGxldCBsZWZ0ID1cbiAgICAgICAgICAgICAgICBNYXAubWFwaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgbCwgXyA9IGYgfmtleSB+ZGF0YSBpblxuICAgICAgICAgICAgICAgICAgbClcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IHJpZ2h0ID1cbiAgICAgICAgICAgICAgICBNYXAubWFwaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgXywgciA9IGYgfmtleSB+ZGF0YSBpblxuICAgICAgICAgICAgICAgICAgcilcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGVmdCwgcmlnaHRcbiAgICAgICAgICAgIHwgZmFsc2UsIGZhbHNlIC0+XG4gICAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICAhcHJldl9tYXBcbiAgICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgICB+aW5pdDooIWxlZnRfYWNjLCAhcmlnaHRfYWNjKVxuICAgICAgICAgICAgICAgIH5mOihmdW4gKGxlZnQsIHJpZ2h0KSAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgICB8IGBVbmVxdWFsIChwcmV2LCBuZXdfKSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldl9hLCBwcmV2X2IgPSBmIH5rZXkgfmRhdGE6cHJldiBpblxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3X2EsIG5ld19iID0gZiB+a2V5IH5kYXRhOm5ld18gaW5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnQgPVxuICAgICAgICAgICAgICAgICAgICAgIGlmIGxlZnRfcmVzdWx0X2VxdWFsIHByZXZfYSBuZXdfYVxuICAgICAgICAgICAgICAgICAgICAgIHRoZW4gbGVmdFxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgTWFwLnNldCBsZWZ0IH5rZXkgfmRhdGE6bmV3X2FcbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgICBpZiByaWdodF9yZXN1bHRfZXF1YWwgcHJldl9iIG5ld19iXG4gICAgICAgICAgICAgICAgICAgICAgdGhlbiByaWdodFxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgTWFwLnNldCByaWdodCB+a2V5IH5kYXRhOm5ld19iXG4gICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTWFwLnJlbW92ZSBsZWZ0IGtleSwgTWFwLnJlbW92ZSByaWdodCBrZXlcbiAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IGVsZW1lbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGEsIGIgPSBmIH5rZXkgfmRhdGE6ZWxlbWVudCBpblxuICAgICAgICAgICAgICAgICAgICBNYXAuc2V0IGxlZnQgfmtleSB+ZGF0YTphLCBNYXAuc2V0IHJpZ2h0IH5rZXkgfmRhdGE6YilcbiAgICAgICAgICBpblxuICAgICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCAhbGVmdF9hY2MgbGVmdCkgdGhlbiBFLk5vZGUubWFrZV9zdGFsZSBsZWZ0X3Jlc3VsdDtcbiAgICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgIXJpZ2h0X2FjYyByaWdodCkgdGhlbiBFLk5vZGUubWFrZV9zdGFsZSByaWdodF9yZXN1bHQ7XG4gICAgICAgICAgbGVmdF9hY2MgOj0gbGVmdDtcbiAgICAgICAgICByaWdodF9hY2MgOj0gcmlnaHQ7XG4gICAgICAgICAgcHJldl9tYXAgOj0gbWFwKSlcbiAgICBpblxuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbnB1dF9jaGFuZ2UpO1xuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgaW5wdXRfY2hhbmdlKTtcbiAgICBFLk5vZGUud2F0Y2ggbGVmdF9yZXN1bHQsIEUuTm9kZS53YXRjaCByaWdodF9yZXN1bHRcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaVxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgP2xlZnRfcmVzdWx0X2VxdWFsXG4gICAgICAgID9yaWdodF9yZXN1bHRfZXF1YWxcbiAgICAgICAgaW5wdXRcbiAgICAgICAgfmZcbiAgICA9XG4gICAgbGV0IHBhaXIgPVxuICAgICAgd2l0aF9jb21wYXJhdG9yIGlucHV0IChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgICBpbnB1dFxuICAgICAgICB8PiB1bnppcF9tYXBpX3dpdGhfY29tcGFyYXRvclxuICAgICAgICAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICAgICAgID9sZWZ0X3Jlc3VsdF9lcXVhbFxuICAgICAgICAgICAgID9yaWdodF9yZXN1bHRfZXF1YWxcbiAgICAgICAgICAgICB+Y29tcGFyYXRvclxuICAgICAgICAgICAgIH5mXG4gICAgICAgIHw+IFR1cGxlMi51bmN1cnJ5IEluY3JlbWVudGFsLmJvdGgpXG4gICAgaW5cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6ZnN0IHBhaXIsIEluY3JlbWVudGFsLm1hcCB+ZjpzbmQgcGFpclxuICA7O1xuXG4gIGxldCB1bnppcCA/aW5zdHJ1bWVudGF0aW9uID9sZWZ0X3Jlc3VsdF9lcXVhbCA/cmlnaHRfcmVzdWx0X2VxdWFsIGlucHV0ID1cbiAgICBsZXQgZGF0YV9lcXVhbCA9XG4gICAgICBPcHRpb24ubWFwMiBsZWZ0X3Jlc3VsdF9lcXVhbCByaWdodF9yZXN1bHRfZXF1YWwgfmY6KGZ1biBsIHIgLT5cbiAgICAgICAgVHVwbGUyLmVxdWFsIH5lcTE6bCB+ZXEyOnIpXG4gICAgaW5cbiAgICB1bnppcF9tYXBpXG4gICAgICA/aW5zdHJ1bWVudGF0aW9uXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgP2xlZnRfcmVzdWx0X2VxdWFsXG4gICAgICA/cmlnaHRfcmVzdWx0X2VxdWFsXG4gICAgICBpbnB1dFxuICAgICAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZGF0YSlcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgICAgICh0eXBlIHYgdjEgdjIgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChpbnB1dCA6ICgoJ2tleSwgdiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oY29tcGFyYXRvciA6ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLnQpXG4gICAgICAgIH4oZiA6XG4gICAgICAgICAgICBrZXk6J2tleVxuICAgICAgICAgIC0+IGRhdGE6KHYsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAodjEsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQgKiAodjIsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBwcmV2X21hcCA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcHJldl9ub2RlcyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9hY2MgOiAoJ2tleSwgdjEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIWxlZnRfYWNjKSBpblxuICAgIGxldCByaWdodF9hY2MgOiAoJ2tleSwgdjIsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmlnaHRfcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFyaWdodF9hY2MpIGluXG4gICAgbGV0IGxlZnRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IGxlZnRfYWNjIDo9IE1hcC5zZXQgIWxlZnRfYWNjIH5rZXkgfmRhdGEgaW5cbiAgICBsZXQgcmlnaHRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IHJpZ2h0X2FjYyA6PSBNYXAuc2V0ICFyaWdodF9hY2MgfmtleSB+ZGF0YSBpblxuICAgIGxldCByZWMgaW5wdXRfY2hhbmdlID1cbiAgICAgIGxhenlcbiAgICAgICAgKEluY3JlbWVudGFsLm1hcCBpbnB1dCB+ZjooZnVuIG1hcCAtPlxuICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uSW5zdHJ1bWVudGF0aW9uLmYgKGZ1biAoKSAtPlxuICAgICAgICAgICAgIGxldCBuZXdfbm9kZXMgPVxuICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICAgIXByZXZfbWFwXG4gICAgICAgICAgICAgICAgIG1hcFxuICAgICAgICAgICAgICAgICB+aW5pdDohcHJldl9ub2Rlc1xuICAgICAgICAgICAgICAgICB+ZjooZnVuIG5vZGVzIChrZXksIGNoYW5nZWQpIC0+XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCBfIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgX2xlZnRfZGVwLCBfcmlnaHRfZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLm1ha2Vfc3RhbGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgbGVmdF9kZXAsIHJpZ2h0X2RlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IE1hcC5yZW1vdmUgbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgbGVmdF9yZXN1bHQgbGVmdF9kZXA7XG4gICAgICAgICAgICAgICAgICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgcmlnaHRfcmVzdWx0IHJpZ2h0X2RlcDtcbiAgICAgICAgICAgICAgICAgICAgIGxlZnRfYWNjIDo9IE1hcC5yZW1vdmUgIWxlZnRfYWNjIGtleTtcbiAgICAgICAgICAgICAgICAgICAgIHJpZ2h0X2FjYyA6PSBNYXAucmVtb3ZlICFyaWdodF9hY2Mga2V5O1xuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmludmFsaWRhdGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgfCBgUmlnaHQgXyAtPlxuICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICBNYXAuZmluZF9leG4gIXByZXZfbWFwIGtleSlcbiAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICBPcHRpb24uaXRlciBjdXRvZmYgfmY6KGZ1biBjIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLnNldF9jdXRvZmYgKEUuTm9kZS53YXRjaCBub2RlKSBjKTtcbiAgICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBub2RlIChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBpbnB1dF9jaGFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0X2luY3IsIHJpZ2h0X2luY3IgPSBmIH5rZXkgfmRhdGE6KEUuTm9kZS53YXRjaCBub2RlKSBpblxuICAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnRfdXNlcl9mdW5jdGlvbl9kZXAgPVxuICAgICAgICAgICAgICAgICAgICAgICBFLkRlcGVuZGVuY3kuY3JlYXRlIGxlZnRfaW5jciB+b25fY2hhbmdlOihsZWZ0X29uX2lubmVyX2NoYW5nZSB+a2V5KVxuICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgIGxldCByaWdodF91c2VyX2Z1bmN0aW9uX2RlcCA9XG4gICAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICByaWdodF9pbmNyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfm9uX2NoYW5nZToocmlnaHRfb25faW5uZXJfY2hhbmdlIH5rZXkpXG4gICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IGxlZnRfdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgcmlnaHRfcmVzdWx0IHJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwO1xuICAgICAgICAgICAgICAgICAgICAgTWFwLnNldFxuICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICB+a2V5XG4gICAgICAgICAgICAgICAgICAgICAgIH5kYXRhOihub2RlLCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwLCByaWdodF91c2VyX2Z1bmN0aW9uX2RlcCkpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBwcmV2X25vZGVzIDo9IG5ld19ub2RlcztcbiAgICAgICAgICAgICBwcmV2X21hcCA6PSBtYXApKSlcbiAgICBpblxuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgaW5wdXRfY2hhbmdlKSk7XG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgaW5wdXRfY2hhbmdlKSk7XG4gICAgRS5Ob2RlLndhdGNoIGxlZnRfcmVzdWx0LCBFLk5vZGUud2F0Y2ggcmlnaHRfcmVzdWx0XG4gIDs7XG5cbiAgbGV0IHVuemlwX21hcGknID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgbGV0IHBhaXIgPVxuICAgICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgICAgbWFwXG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yJyB+aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgfmNvbXBhcmF0b3IgfmZcbiAgICAgICAgfD4gVHVwbGUyLnVuY3VycnkgSW5jcmVtZW50YWwuYm90aClcbiAgICBpblxuICAgIEluY3JlbWVudGFsLm1hcCB+Zjpmc3QgcGFpciwgSW5jcmVtZW50YWwubWFwIH5mOnNuZCBwYWlyXG4gIDs7XG5cbiAgbGV0IGtleXMgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pIG1hcCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBhZGQgfmtleSB+ZGF0YTpfIGFjYyA9IFNldC5hZGQgYWNjIGtleSBpblxuICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhOl8gYWNjID0gU2V0LnJlbW92ZSBhY2Mga2V5IGluXG4gICAgICBsZXQgZGF0YV9lcXVhbCBfIF8gPSB0cnVlIGluXG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICBtYXBcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICB+aW5pdDooU2V0LlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IpXG4gICAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgfmFkZFxuICAgICAgICB+cmVtb3ZlKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbikgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgIH5pbml0OihlbXB0eSwgZW1wdHkpXG4gICAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgICAgfnVwZGF0ZTooZnVuIH5rZXkgfm9sZF9kYXRhOl8gfm5ld19kYXRhOmRhdGEgKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IEZpcnN0IGRhdGEgLT4gTWFwLnNldCBmaXJzdCB+a2V5IH5kYXRhLCBNYXAucmVtb3ZlIHNlY29uZCBrZXlcbiAgICAgICAgICB8IFNlY29uZCBkYXRhIC0+IE1hcC5yZW1vdmUgZmlyc3Qga2V5LCBNYXAuc2V0IHNlY29uZCB+a2V5IH5kYXRhKVxuICAgICAgICB+YWRkOihmdW4gfmtleSB+ZGF0YSAoZmlyc3QsIHNlY29uZCkgLT5cbiAgICAgICAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgICAgICAgIHwgRmlyc3QgZGF0YSAtPiBNYXAuYWRkX2V4biBmaXJzdCB+a2V5IH5kYXRhLCBzZWNvbmRcbiAgICAgICAgICB8IFNlY29uZCBkYXRhIC0+IGZpcnN0LCBNYXAuYWRkX2V4biBzZWNvbmQgfmtleSB+ZGF0YSlcbiAgICAgICAgfnJlbW92ZTooZnVuIH5rZXkgfmRhdGE6XyAoZmlyc3QsIHNlY29uZCkgLT5cbiAgICAgICAgICBNYXAucmVtb3ZlIGZpcnN0IGtleSwgTWFwLnJlbW92ZSBzZWNvbmQga2V5KSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGknID9pbnN0cnVtZW50YXRpb24gP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIG1hcGknID9pbnN0cnVtZW50YXRpb24gP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgICB8PiBwYXJ0aXRpb25fbWFwaSA/aW5zdHJ1bWVudGF0aW9uIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGRhdGEpXG4gIDs7XG5cbiAgbGV0IGZsYXR0ZW4gc3RhdGUgbWFwID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgcmVzdWx0ID0gcmVmIChNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKSkgaW5cbiAgICBsZXQgbm9kZSA9IEUuTm9kZS5jcmVhdGUgc3RhdGUgKGZ1biAoKSAtPiAhcmVzdWx0KSBpblxuICAgIE1hcC5pdGVyaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhOmluY3IgLT5cbiAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeVxuICAgICAgICBub2RlXG4gICAgICAgIChFLkRlcGVuZGVuY3kuY3JlYXRlIGluY3Igfm9uX2NoYW5nZTooZnVuIGEgLT5cbiAgICAgICAgICAgcmVzdWx0IDo9IE1hcC5zZXQgIXJlc3VsdCB+a2V5IH5kYXRhOmEpKSk7XG4gICAgRS5Ob2RlLndhdGNoIG5vZGVcbiAgOztcblxuICBsZXQgam9pbl93aXRoX2NvbXBhcmF0b3Igfmluc3RydW1lbnRhdGlvbiBtYXBfaW5jciB+Y29tcGFyYXRvciA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgbWFwX2luY3IgaW5cbiAgICBsZXQgZW1wdHlfbWFwID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICBsZXQgcmVzdWx0X21hcCA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgb2xkX21hcF9vZl9pbmNycyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgY3VycmVudF9kZXBlbmRlbmNpZXMgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IHJlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhcmVzdWx0X21hcCkgaW5cbiAgICBsZXQgYWRkX3N1Ym5vZGUgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleSB+ZGF0YV9ub2RlID1cbiAgICAgIGxldCBuZXdfZGVwID1cbiAgICAgICAgRS5EZXBlbmRlbmN5LmNyZWF0ZSBkYXRhX25vZGUgfm9uX2NoYW5nZTooZnVuIGRhdGEgLT5cbiAgICAgICAgICByZXN1bHRfbWFwIDo9IE1hcC5zZXQgIXJlc3VsdF9tYXAgfmtleSB+ZGF0YSlcbiAgICAgIGluXG4gICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgcmVzdWx0IG5ld19kZXA7XG4gICAgICBNYXAuc2V0IGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfmRhdGE6bmV3X2RlcFxuICAgIGluXG4gICAgbGV0IHJlbW92ZV9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgPVxuICAgICAgbGV0IGRlcCA9IE1hcC5maW5kX2V4biBjdXJyZW50X2RlcGVuZGVuY2llcyBrZXkgaW5cbiAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSByZXN1bHQgZGVwO1xuICAgICAgcmVzdWx0X21hcCA6PSBNYXAucmVtb3ZlICFyZXN1bHRfbWFwIGtleTtcbiAgICAgIE1hcC5yZW1vdmUgY3VycmVudF9kZXBlbmRlbmNpZXMga2V5XG4gICAgaW5cbiAgICBsZXQgbGhzX2NoYW5nZSA9XG4gICAgICBJbmNyZW1lbnRhbC5tYXAgbWFwX2luY3IgfmY6KGZ1biBtYXBfb2ZfaW5jcnMgLT5cbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbi5mIChmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgbmV3X2RlcGVuZGVuY3lfbWFwID1cbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsOnBoeXNfZXF1YWxcbiAgICAgICAgICAgICAgIW9sZF9tYXBfb2ZfaW5jcnNcbiAgICAgICAgICAgICAgbWFwX29mX2luY3JzXG4gICAgICAgICAgICAgIH5pbml0OiFjdXJyZW50X2RlcGVuZGVuY2llc1xuICAgICAgICAgICAgICB+ZjooZnVuIGN1cnJlbnRfZGVwZW5kZW5jaWVzIChrZXksIGRpZmYpIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IHJlbW92ZV9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXlcbiAgICAgICAgICAgICAgICB8IGBSaWdodCBkYXRhX25vZGUgLT4gYWRkX3N1Ym5vZGUgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleSB+ZGF0YV9ub2RlXG4gICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAoXywgZGF0YV9ub2RlKSAtPlxuICAgICAgICAgICAgICAgICAgcmVtb3ZlX3N1Ym5vZGUgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleSB8PiBhZGRfc3Vibm9kZSB+a2V5IH5kYXRhX25vZGUpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBjdXJyZW50X2RlcGVuZGVuY2llcyA6PSBuZXdfZGVwZW5kZW5jeV9tYXA7XG4gICAgICAgICAgb2xkX21hcF9vZl9pbmNycyA6PSBtYXBfb2ZfaW5jcnMpKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBsaHNfY2hhbmdlKTtcbiAgICBFLk5vZGUud2F0Y2ggcmVzdWx0XG4gIDs7XG5cbiAgbGV0IGpvaW4gPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pIG1hcCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGpvaW5fd2l0aF9jb21wYXJhdG9yIH5pbnN0cnVtZW50YXRpb24gbWFwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIG1vZHVsZSBTZXBhcmF0ZV9zdGF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCwgJ3cpIHQgPVxuICAgICAgeyBtdXRhYmxlIGlucHV0X21hcCA6ICgnaywgJ3YsICdjbXApIE1hcC50XG4gICAgICA7IG11dGFibGUgZXhwZXJ0X25vZGVzIDogKCdrLCAoJ3YsICd3KSBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS50LCAnY21wKSBNYXAudFxuICAgICAgOyBtdXRhYmxlIG91dHB1dF9tYXAgOiAoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLnQsICdjbXApIE1hcC50XG4gICAgICB9XG5cbiAgICBsZXQgY3JlYXRlIGNvbXBhcmF0b3IgPVxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIHsgaW5wdXRfbWFwID0gZW1wdHk7IGV4cGVydF9ub2RlcyA9IGVtcHR5OyBvdXRwdXRfbWFwID0gZW1wdHkgfVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlX2xvb2t1cF9ub2RlIHN0YXRlIHQga2V5ID1cbiAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZSBzdGF0ZSAoZnVuICgpIC0+IE1hcC5maW5kX2V4biB0LmlucHV0X21hcCBrZXkpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHNlcGFyYXRlID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSBpbnB1dF9tYXAgfmRhdGFfZXF1YWwgPVxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIGlucHV0X21hcCBpblxuICAgIHdpdGhfY29tcGFyYXRvciBpbnB1dF9tYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgc3RhdGUgPSBTZXBhcmF0ZV9zdGF0ZS5jcmVhdGUgY29tcGFyYXRvciBpblxuICAgICAgbGV0IG91dHB1dF9tYXBfbm9kZSA9XG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+IHN0YXRlLm91dHB1dF9tYXApXG4gICAgICBpblxuICAgICAgbGV0IG1ha2Vfbm9kZV9kZXBlbmRfb25faW5wdXRfbWFwX2NoYW5nZWQgbm9kZSB+aW5wdXRfbWFwX2NoYW5nZWQgPVxuICAgICAgICBsZXQgZGVwZW5kZW5jeSA9XG4gICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0LkRlcGVuZGVuY3kuY3JlYXRlIChMYXp5LmZvcmNlX3ZhbCBpbnB1dF9tYXBfY2hhbmdlZClcbiAgICAgICAgaW5cbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuYWRkX2RlcGVuZGVuY3kgbm9kZSBkZXBlbmRlbmN5XG4gICAgICBpblxuICAgICAgKCogV2Ugd2FudCB0byBtYWtlIG5vZGVzIGRlcGVuZCBvbiBbaW5wdXRfbWFwX2NoYW5nZWRdIHNvIHRoYXQgW2lucHV0X21hcF9jaGFuZ2VkXVxuICAgICAgICAgaXMgYWxsb3dlZCB0byBtYWtlIHRoZW0gc3RhbGUsIGJ1dCB3ZSBkbyBub3Qgd2FudCB0aGVtIHRvIGJlIHJlY29tcHV0ZWQgZm9yIGFueVxuICAgICAgICAgb3RoZXIgcmVhc29uLiBTbyB3ZSBtYWtlIFtpbnB1dF9tYXBfY2hhbmdlZF0gYSB1bml0IGluY3JlbWVudGFsICh0aGF0IHRoZXJlZm9yZVxuICAgICAgICAgbmV2ZXIgY2hhbmdlcykgYW5kIHRoaXMgd2F5IFtvdXRwdXRfbWFwX25vZGVdIGFuZCB0aGUgbG9va3VwIG5vZGVzIHdpbGwgb25seSBiZVxuICAgICAgICAgcmVjb21wdXRlZCB3aGVuIHRoZXkgYXJlIGV4cGxpY2l0bHkgbWFkZSBzdGFsZS5cbiAgICAgICopXG4gICAgICBsZXQgcmVjIGlucHV0X21hcF9jaGFuZ2VkID1cbiAgICAgICAgbGF6eVxuICAgICAgICAgIChJbmNyZW1lbnRhbC5tYXAgaW5wdXRfbWFwIH5mOihmdW4gaW5wdXRfbWFwIC0+XG4gICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbi5mIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgIGxldCBwcmV2X2lucHV0X21hcCA9IHN0YXRlLmlucHV0X21hcCBpblxuICAgICAgICAgICAgICAgbGV0IGV4cGVydF9ub2Rlcywgb3V0cHV0X21hcCA9XG4gICAgICAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgICAgICAgcHJldl9pbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgICBpbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICAgIH5pbml0OihzdGF0ZS5leHBlcnRfbm9kZXMsIHN0YXRlLm91dHB1dF9tYXApXG4gICAgICAgICAgICAgICAgICAgfmY6KGZ1biAoZXhwZXJ0X25vZGVzLCBvdXRwdXRfbWFwKSAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2Ugd2l0aFxuICAgICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfb2xkX3ZhbHVlIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGRfbm9kZSA9IE1hcC5maW5kX2V4biBleHBlcnRfbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmludmFsaWRhdGUgb2xkX25vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgb3V0cHV0X21hcF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICBNYXAucmVtb3ZlIGV4cGVydF9ub2RlcyBrZXksIE1hcC5yZW1vdmUgb3V0cHV0X21hcCBrZXlcbiAgICAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IF9uZXdfdmFsdWUgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIFNlcGFyYXRlX3N0YXRlLmNyZWF0ZV9sb29rdXBfbm9kZSBpbmNyZW1lbnRhbF9zdGF0ZSBzdGF0ZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfY2hhbmdlZCBub2RlIH5pbnB1dF9tYXBfY2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSBvdXRwdXRfbWFwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICggTWFwLmFkZF9leG4gZXhwZXJ0X25vZGVzIH5rZXkgfmRhdGE6bm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAsIE1hcC5hZGRfZXhuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB+a2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB+ZGF0YTooSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggbm9kZSkgKVxuICAgICAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAoX29sZF92YWx1ZSwgX25ld192YWx1ZSkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSAoTWFwLmZpbmRfZXhuIGV4cGVydF9ub2RlcyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICBleHBlcnRfbm9kZXMsIG91dHB1dF9tYXApXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgc3RhdGUuaW5wdXRfbWFwIDwtIGlucHV0X21hcDtcbiAgICAgICAgICAgICAgIHN0YXRlLmV4cGVydF9ub2RlcyA8LSBleHBlcnRfbm9kZXM7XG4gICAgICAgICAgICAgICBzdGF0ZS5vdXRwdXRfbWFwIDwtIG91dHB1dF9tYXApKSlcbiAgICAgIGluXG4gICAgICBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG91dHB1dF9tYXBfbm9kZSB+aW5wdXRfbWFwX2NoYW5nZWQ7XG4gICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBvdXRwdXRfbWFwX25vZGUpXG4gIDs7XG5cbiAgKCogSnVzdCBmb3IgZGVyaXZpbmcgc3RydWN0dXJhbCBlcXVhbGl0eS4gKilcbiAgdHlwZSAnYSBtYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgPSAnYSBNYXliZV9ib3VuZC50ID1cbiAgICB8IEluY2wgb2YgJ2FcbiAgICB8IEV4Y2wgb2YgJ2FcbiAgICB8IFVuYm91bmRlZFxuICBbQEBkZXJpdmluZyBlcXVhbF1cblxuICBsZXQgc3VicmFuZ2VcbiAgICAgICAgKHR5cGUgayB2IGNtcCBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgKG1hcF9pbmNyIDogKChrLCB2LCBjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICByYW5nZVxuICAgID1cbiAgICB3aXRoX29sZDIgfmluc3RydW1lbnRhdGlvbiBtYXBfaW5jciByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIHJhbmdlIC0+XG4gICAgICBsZXQgY29tcGFyZSA9IChNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgIGxldCBlcXVhbCBsIHIgPSBjb21wYXJlIGwgciA9IDAgaW5cbiAgICAgIGxldCAoID4gKSBhIGIgPSBjb21wYXJlIGEgYiA+IDBcbiAgICAgIGFuZCAoID49ICkgYSBiID0gY29tcGFyZSBhIGIgPj0gMCBpblxuICAgICAgbGV0IG1heWJlX2JvdW5kX2VxdWFsIGEgYiA6IGJvb2wgPSBlcXVhbF9tYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgZXF1YWwgYSBiIGluXG4gICAgICBsZXQgcmFuZ2VfaXNfZW1wdHkgfm1pbiB+bWF4IDogYm9vbCA9XG4gICAgICAgIG1hdGNoIG1pbiwgbWF4IHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQsIChVbmJvdW5kZWQgfCBFeGNsIF8gfCBJbmNsIF8pIHwgKEV4Y2wgXyB8IEluY2wgXyksIFVuYm91bmRlZCAtPiBmYWxzZVxuICAgICAgICB8IEluY2wgbWluLCBJbmNsIG1heCAtPiBtaW4gPiBtYXhcbiAgICAgICAgfCBFeGNsIG1pbiwgRXhjbCBtYXggfCBJbmNsIG1pbiwgRXhjbCBtYXggfCBFeGNsIG1pbiwgSW5jbCBtYXggLT4gbWluID49IG1heFxuICAgICAgaW5cbiAgICAgIGxldCByYW5nZV9pbmNsdWRlcyB+bWluIH5tYXgga2V5IDogYm9vbCA9XG4gICAgICAgIE1heWJlX2JvdW5kLmlzX2xvd2VyX2JvdW5kIG1pbiB+b2ZfOmtleSB+Y29tcGFyZVxuICAgICAgICAmJiBNYXliZV9ib3VuZC5pc191cHBlcl9ib3VuZCBtYXggfm9mXzprZXkgfmNvbXBhcmVcbiAgICAgIGluXG4gICAgICBtYXRjaCByYW5nZSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKCogRW1wdHkgbmV3IHJhbmdlIG1lYW5zIGVtcHR5IG1hcCAqKVxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKVxuICAgICAgfCBTb21lICgobWluLCBtYXgpIGFzIHJhbmdlKSAtPlxuICAgICAgICBsZXQgZnJvbV9zY3JhdGNoICgpID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDptYXggaW5cbiAgICAgICAgKG1hdGNoIG9sZCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBTb21lIChfLCBOb25lLCBfKSAtPlxuICAgICAgICAgICAoKiBubyBvbGQgcmFuZ2UgKilcbiAgICAgICAgICAgZnJvbV9zY3JhdGNoICgpXG4gICAgICAgICB8IFNvbWUgKF8sIFNvbWUgKG9sZF9taW4sIG9sZF9tYXgpLCBfKVxuICAgICAgICAgICB3aGVuIHJhbmdlX2lzX2VtcHR5IH5taW46b2xkX21pbiB+bWF4Om9sZF9tYXhcbiAgICAgICAgICAgICB8fCByYW5nZV9pc19lbXB0eSB+bWluIH5tYXg6b2xkX21heFxuICAgICAgICAgICAgIHx8IHJhbmdlX2lzX2VtcHR5IH5taW46b2xkX21pbiB+bWF4IC0+XG4gICAgICAgICAgICgqIGVtcHR5IG9sZCByYW5nZSBvciBvbGQgcmFuZ2UgZGlzam9pbnQgd2l0aCBuZXcgKilcbiAgICAgICAgICAgZnJvbV9zY3JhdGNoICgpXG4gICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIFNvbWUgKChvbGRfbWluLCBvbGRfbWF4KSBhcyBvbGRfcmFuZ2UpLCBvbGRfcmVzKSAtPlxuICAgICAgICAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgICAgICAgICAoKiBSZXR1cm5zIHRydWUgaWZmIHRoZSBrZXkgaXMgaW4gYm90aCBuZXcgYW5kIG9sZCByYW5nZXMgKilcbiAgICAgICAgICAgICBsZXQgaW5fcmFuZ2VfaW50ZXJzZWN0aW9uIGtleSA9XG4gICAgICAgICAgICAgICByYW5nZV9pbmNsdWRlcyB+bWluIH5tYXgga2V5XG4gICAgICAgICAgICAgICAmJiByYW5nZV9pbmNsdWRlcyB+bWluOm9sZF9taW4gfm1heDpvbGRfbWF4IGtleVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogQXBwbHkgY2hhbmdlcyB0byBrZXlzIHdoaWNoIGFyZSBpbiB0aGUgaW50ZXJzZWN0aW9uIG9mIGJvdGggcmFuZ2VzLlxuXG4gICAgICAgICAgICAgICAgW291dHNpZGVdIGlzIHRoZSBudW1iZXIgb2YgdXBkYXRlcyBvdXRzaWRlIHRoZSByYW5nZSBpbnRlcnNlY3Rpb24gdGhhdCB3ZVxuICAgICAgICAgICAgICAgIHRvbGVyYXRlIGJlZm9yZSBnaXZpbmcgdXAgYW5kIHJlY29uc3RydWN0aW5nIGJhc2VkIG9uIHRoZSBuZXcgcmFuZ2UuIFRoaXNcbiAgICAgICAgICAgICAgICBpcyBhbiBvcHRpbWlzYXRpb24gaW4gdGhlIGNhc2UgdGhhdCB0aGUgbWFwIGNoYW5nZXMgaW4gYSB2ZXJ5IGJpZyB3YXksIGF0XG4gICAgICAgICAgICAgICAgd2hpY2ggcG9pbnQgY29tcHV0aW5nIGJhc2VkIG9uIHRoZSBuZXcgcmFuZ2UgaXMgY2hlYXBlci4gICopXG4gICAgICAgICAgICAgbGV0IGFwcGx5X2RpZmZfaW5faW50ZXJzZWN0aW9uIChvdXRzaWRlLCBtYXApIChrZXksIGRhdGEpID1cbiAgICAgICAgICAgICAgIGlmIGluX3JhbmdlX2ludGVyc2VjdGlvbiBrZXlcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICBtYXRjaCBkYXRhIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IG91dHNpZGUsIE1hcC5yZW1vdmUgbWFwIGtleVxuICAgICAgICAgICAgICAgICB8IGBSaWdodCBkYXRhIHwgYFVuZXF1YWwgKF8sIGRhdGEpIC0+IG91dHNpZGUsIE1hcC5zZXQgbWFwIH5rZXkgfmRhdGEpXG4gICAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICAgbGV0IG91dHNpZGUgPSBvdXRzaWRlIC0gMSBpblxuICAgICAgICAgICAgICAgICBpZiBJbnQuTy4ob3V0c2lkZSA8IDApXG4gICAgICAgICAgICAgICAgIHRoZW4gcmV0dXJuIChmcm9tX3NjcmF0Y2ggKCkpXG4gICAgICAgICAgICAgICAgIGVsc2Ugb3V0c2lkZSwgTWFwLnJlbW92ZSBtYXAga2V5KVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogRmlyc3QgdXBkYXRlIHRoZSBrZXlzIGluIC9ib3RoLyB0aGUgb2xkIGFuZCB0aGUgbmV3IHJhbmdlLiAqKVxuICAgICAgICAgICAgIGxldCB3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2VjdGlvbiA9XG4gICAgICAgICAgICAgICAoKiBDdXRvZmYgdGhlIGJpZyBkaWZmIGNvbXB1dGF0aW9uIGlmIHdlIHJlYWNoIE8ofHN1Ym1hcHwpIG51bWJlciBvZlxuICAgICAgICAgICAgICAgICAgY2hhbmdlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSByYW5nZSAqKVxuICAgICAgICAgICAgICAgbGV0IG91dHNpZGVfY3V0b2ZmID0gTWFwLmxlbmd0aCBvbGRfcmVzIC8gNCBpblxuICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICAgb2xkX21hcFxuICAgICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgICAgfmluaXQ6KG91dHNpZGVfY3V0b2ZmLCBvbGRfcmVzKVxuICAgICAgICAgICAgICAgICB+ZjphcHBseV9kaWZmX2luX2ludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgfD4gc25kXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBpZiBUdXBsZTIuZXF1YWwgfmVxMTptYXliZV9ib3VuZF9lcXVhbCB+ZXEyOm1heWJlX2JvdW5kX2VxdWFsIG9sZF9yYW5nZSByYW5nZVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICgqIFRoZXJlIGFyZSBubyBrZXlzIHRvIHJlbW92ZSBhbmQgZXZlcnl0aGluZyBpbiByYW5nZSBpcyB1cGRhdGVkLiAqKVxuICAgICAgICAgICAgICAgd2l0aF91cGRhdGVkX3ZhbHVlc19pbl9pbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICgqIFJlbW92ZSBhbnkga2V5cyB3aGljaCBhcmUgbm90IGluIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgICBsZXQgd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSA9XG4gICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZVxuICAgICAgICAgICAgICAgICAgIHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgfmxvd2VyX2JvdW5kOm1pblxuICAgICAgICAgICAgICAgICAgIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAoKiBBZGQgaW4gYW55IGtleXMgd2hpY2ggYXJlIGluIHRoZSBuZXcgcmFuZ2UgYnV0IG5vdCB0aGUgb2xkIHJhbmdlLiAqKVxuICAgICAgICAgICAgICAgbGV0IHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlID1cbiAgICAgICAgICAgICAgICAgbGV0IG1hcF9hcHBlbmRfZXhuIGxvd2VyX3BhcnQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggTWFwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgT2sgbWFwIC0+IG1hcFxuICAgICAgICAgICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT5cbiAgICAgICAgICAgICAgICAgICAgIGZhaWx3aXRoIFwiaW1wb3NzaWJsZSBjYXNlOiBCVUcgaW4gaW5jcl9tYXAubWwgc3VicmFuZ2VcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBsZXQgbG93ZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21pbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9taW4gLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOm1pbiB+dXBwZXJfYm91bmQ6KEluY2wgb2xkX21pbilcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21pbiAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDooRXhjbCBvbGRfbWluKVxuICAgICAgICAgICAgICAgICBhbmQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21heCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9tYXggLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOihJbmNsIG9sZF9tYXgpIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21heCAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6KEV4Y2wgb2xkX21heCkgfnVwcGVyX2JvdW5kOm1heFxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBtYXBfYXBwZW5kX2V4blxuICAgICAgICAgICAgICAgICAgIGxvd2VyX3BhcnRcbiAgICAgICAgICAgICAgICAgICAobWFwX2FwcGVuZF9leG4gd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSB1cHBlcl9wYXJ0KVxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlKSkpKVxuICA7O1xuXG4gIGxldCByZWtleVxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgbWFwX2luY3JcbiAgICAgICAgfmNvbXBhcmF0b3I6b3V0ZXJfY29tcGFyYXRvclxuICAgICAgICB+ZlxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgbWFwX2luY3JcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IsIFtdKVxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgKG91dHB1dCwgYWRkcykgLT5cbiAgICAgICAgbGV0IG5ld19lbnRyeSA9IGYgfmtleSB+ZGF0YSwgZGF0YSBpblxuICAgICAgICBvdXRwdXQsIG5ld19lbnRyeSA6OiBhZGRzKVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXkgfmRhdGEgKG91dHB1dCwgYWRkcykgLT4gTWFwLnJlbW92ZSBvdXRwdXQgKGYgfmtleSB+ZGF0YSksIGFkZHMpXG4gICAgICB+dXBkYXRlOihmdW4gfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIChvdXRwdXQsIGFkZHMpIC0+XG4gICAgICAgIGxldCBwcmV2X2tleSA9IGYgfmtleSB+ZGF0YTpvbGRfZGF0YSBpblxuICAgICAgICBsZXQgbmV3X2tleSA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICBpZiAoTWFwLmNvbXBhcmF0b3Igb3V0cHV0KS5jb21wYXJlIHByZXZfa2V5IG5ld19rZXkgPSAwXG4gICAgICAgIHRoZW4gTWFwLnNldCBvdXRwdXQgfmtleTpuZXdfa2V5IH5kYXRhOm5ld19kYXRhLCBhZGRzXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBvdXRwdXQgPSBNYXAucmVtb3ZlIG91dHB1dCBwcmV2X2tleSBpblxuICAgICAgICAgIG91dHB1dCwgKG5ld19rZXksIG5ld19kYXRhKSA6OiBhZGRzKSlcbiAgICAgIH5maW5hbGl6ZTooZnVuIChvdXRwdXQsIGFkZHMpIC0+XG4gICAgICAgIGxldCBvdXRwdXQgPVxuICAgICAgICAgIExpc3QuZm9sZCBhZGRzIH5pbml0Om91dHB1dCB+ZjooZnVuIG91dHB1dCAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgTWFwLmFkZF9leG4gb3V0cHV0IH5rZXkgfmRhdGEpXG4gICAgICAgIGluXG4gICAgICAgIG91dHB1dCwgW10pXG4gICAgfD4gSW5jcmVtZW50YWwubWFwIH5mOmZzdFxuICA7O1xuXG4gIGxldCBpbmRleF9ieWlcbiAgICAgICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcF9pbmNyXG4gICAgICAgIH5jb21wYXJhdG9yOm91dGVyX2NvbXBhcmF0b3JcbiAgICAgICAgfmluZGV4XG4gICAgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXBfaW5jciAoZnVuIGlubmVyX2NvbXBhcmF0b3IgLT5cbiAgICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgICAgbWFwX2luY3JcbiAgICAgICAgfmluaXQ6KE1hcC5lbXB0eSBvdXRlcl9jb21wYXJhdG9yKVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH5hZGQ6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBvdXRlcl9tYXAgLT5cbiAgICAgICAgICBtYXRjaCBpbmRleCB+a2V5OmlubmVyX2tleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG91dGVyX21hcFxuICAgICAgICAgIHwgU29tZSBvdXRlcl9rZXkgLT5cbiAgICAgICAgICAgIE1hcC51cGRhdGUgb3V0ZXJfbWFwIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIGlubmVyX2tleSBkYXRhIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3JcbiAgICAgICAgICAgICAgfCBTb21lIGlubmVyX21hcCAtPiBNYXAuYWRkX2V4biBpbm5lcl9tYXAgfmtleTppbm5lcl9rZXkgfmRhdGEpKVxuICAgICAgICB+cmVtb3ZlOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgb3V0ZXJfbWFwIC0+XG4gICAgICAgICAgbWF0Y2ggaW5kZXggfmtleTppbm5lcl9rZXkgfmRhdGEgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBvdXRlcl9tYXBcbiAgICAgICAgICB8IFNvbWUgb3V0ZXJfa2V5IC0+XG4gICAgICAgICAgICBNYXAuY2hhbmdlIG91dGVyX21hcCBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGZhaWx3aXRoIFwiQlVHOiBIaXQgc3VwcG9zZWRseSBpbXBvc3NpYmxlIGNhc2UgaW4gSW5jcl9tYXAuaW5kZXhfYnlcIlxuICAgICAgICAgICAgICB8IFNvbWUgaW5uZXJfbWFwIC0+XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyX21hcCA9IE1hcC5yZW1vdmUgaW5uZXJfbWFwIGlubmVyX2tleSBpblxuICAgICAgICAgICAgICAgIGlmIE1hcC5pc19lbXB0eSBpbm5lcl9tYXAgdGhlbiBOb25lIGVsc2UgU29tZSBpbm5lcl9tYXApKSlcbiAgOztcblxuICBsZXQgaW5kZXhfYnkgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvciB+aW5kZXggPVxuICAgIGluZGV4X2J5aVxuICAgICAgP2luc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgfmluZGV4OihmdW4gfmtleTpfIH5kYXRhIC0+IGluZGV4IGRhdGEpXG4gIDs7XG5cblxuICAoKiogRmluZCB0d28ga2V5cyBpbiBtYXAgYnkgaW5kZXgsIE8obikuIFdlIHVzZSBqdXN0IG9uZSBmb2xkICh0d28gTWFwLm50aCB3b3VsZCB1c2UgdHdvKVxuICAgICAgYW5kIG9wdGltaXplIGZvciBrZXlzIGNsb3NlIHRvIGVpdGhlciBiZWdpbm5pbmcgb3IgZW5kIGJ5IHVzaW5nIGVpdGhlciBmb2xkIG9yXG4gICAgICBmb2xkX3JpZ2h0LlxuICAqKVxuICBtb2R1bGUgS2V5X3N0YXR1cyA9IHN0cnVjdFxuICAgIHR5cGUgJ2sgdCA9XG4gICAgICB8IEtub3duIG9mICdrXG4gICAgICB8IEtub3duX25vbmVcbiAgICAgIHwgVW5rbm93blxuXG4gICAgbGV0IGlzX2tub3duID0gZnVuY3Rpb25cbiAgICAgIHwgVW5rbm93biAtPiBmYWxzZVxuICAgICAgfCBfIC0+IHRydWVcbiAgICA7O1xuXG4gICAgbGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgICB8IFVua25vd24gfCBLbm93bl9ub25lIC0+IE5vbmVcbiAgICAgIHwgS25vd24gayAtPiBTb21lIGtcbiAgICA7O1xuICBlbmRcblxuICBsZXQgZmluZF9rZXlfcmFuZ2VfbGluZWFyICh0eXBlIGspIH5mcm9tIH50b18gKG1hcCA6IChrLCBfLCBfKSBNYXAudClcbiAgICA6IChrICogayBvcHRpb24pIG9wdGlvblxuICAgID1cbiAgICBsZXQgb3BlbiBLZXlfc3RhdHVzIGluXG4gICAgbGV0IGxlbiA9IE1hcC5sZW5ndGggbWFwIGluXG4gICAgbGV0IGJlZ2luX2tleSA9IGlmIEludC4oID49ICkgZnJvbSBsZW4gdGhlbiBLbm93bl9ub25lIGVsc2UgVW5rbm93biBpblxuICAgIGxldCBlbmRfa2V5ID0gaWYgSW50LiggPj0gKSB0b18gbGVuIHRoZW4gS25vd25fbm9uZSBlbHNlIFVua25vd24gaW5cbiAgICBsZXQgZmluZF9rZXlzIGZvbGQgfnN0YXJ0X3BvcyB+YWR2YW5jZV9wb3MgPVxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICAgIGZvbGRcbiAgICAgICAgICBtYXBcbiAgICAgICAgICB+aW5pdDooYmVnaW5fa2V5LCBlbmRfa2V5LCBzdGFydF9wb3MpXG4gICAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhOl8gKGJlZ2luX2tleSwgZW5kX2tleSwgcG9zKSAtPlxuICAgICAgICAgICAgbGV0IGJlZ2luX2tleSA9IGlmIEludC4oID0gKSBwb3MgZnJvbSB0aGVuIEtub3duIGtleSBlbHNlIGJlZ2luX2tleSBpblxuICAgICAgICAgICAgbGV0IGVuZF9rZXkgPSBpZiBJbnQuKCA9ICkgcG9zIHRvXyB0aGVuIEtub3duIGtleSBlbHNlIGVuZF9rZXkgaW5cbiAgICAgICAgICAgIGlmIGlzX2tub3duIGJlZ2luX2tleSAmJiBpc19rbm93biBlbmRfa2V5XG4gICAgICAgICAgICB0aGVuIHJldHVybiAoYmVnaW5fa2V5LCBlbmRfa2V5LCBwb3MpXG4gICAgICAgICAgICBlbHNlIGJlZ2luX2tleSwgZW5kX2tleSwgYWR2YW5jZV9wb3MgcG9zKSlcbiAgICBpblxuICAgIGxldCBiZWdpbl9rZXksIGVuZF9rZXksIF8gPVxuICAgICAgKCogU2VhcmNoaW5nIGZyb20gbGVmdCB0YWtlcyBPKHRvXyksIGZyb20gcmlnaHQgLSBPKGxlbiAtIGZyb20pLCBzbyBzZWxlY3QgdGhlXG4gICAgICAgICBzbWFsbGVyIG9uZS4gKilcbiAgICAgIGlmIHRvXyA8IGxlbiAtIGZyb21cbiAgICAgIHRoZW4gZmluZF9rZXlzIE1hcC5mb2xkIH5zdGFydF9wb3M6MCB+YWR2YW5jZV9wb3M6KGZ1biBwb3MgLT4gcG9zICsgMSlcbiAgICAgIGVsc2UgZmluZF9rZXlzIE1hcC5mb2xkX3JpZ2h0IH5zdGFydF9wb3M6KGxlbiAtIDEpIH5hZHZhbmNlX3BvczooZnVuIHBvcyAtPiBwb3MgLSAxKVxuICAgIGluXG4gICAgT3B0aW9uLm1hcCAoS2V5X3N0YXR1cy50b19vcHRpb24gYmVnaW5fa2V5KSB+ZjooZnVuIGJlZ2luX2tleSAtPlxuICAgICAgYmVnaW5fa2V5LCBLZXlfc3RhdHVzLnRvX29wdGlvbiBlbmRfa2V5KVxuICA7O1xuXG4gIGxldCBudGhfZnJvbV9laXRoZXJfc2lkZSAodHlwZSBrKSBuIChtYXAgOiAoaywgXywgXykgTWFwLnQpIDogayBvcHRpb24gPVxuICAgIE9wdGlvbi5tYXAgfmY6ZnN0IChmaW5kX2tleV9yYW5nZV9saW5lYXIgfmZyb206biB+dG9fOm4gbWFwKVxuICA7O1xuXG4gICgqKiBGaW5kIGtleSBbYnldIHBvc2l0aW9ucyBlYXJsaWVyL2xhdGVyIGluIGEgbWFwLiBSZXR1cm5zIG5vbmUgaWYgb3V0IG9mIGJvdW5kcy4gKilcbiAgbGV0IHJlYyBvZmZzZXQgKGtleSA6ICdrKSAobWFwIDogKCdrLCBfLCBfKSBNYXAudCkgfmJ5IDogJ2sgb3B0aW9uID1cbiAgICBpZiBJbnQuKCA9ICkgYnkgMFxuICAgIHRoZW4gU29tZSBrZXlcbiAgICBlbHNlIChcbiAgICAgIGxldCBjbG9zZXN0X2RpciwgYWRkID1cbiAgICAgICAgaWYgSW50LiggPCApIGJ5IDAgdGhlbiBgTGVzc190aGFuLCAxIGVsc2UgYEdyZWF0ZXJfdGhhbiwgLTFcbiAgICAgIGluXG4gICAgICBtYXRjaCBNYXAuY2xvc2VzdF9rZXkgbWFwIGNsb3Nlc3RfZGlyIGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIChrZXksIF8pIC0+IG9mZnNldCBrZXkgbWFwIH5ieTooYnkgKyBhZGQpKVxuICA7O1xuXG4gICgqKiBGaW5kIGhvdyB3ZSBuZWVkIHRvIG1vdmUgW2tleV0gaWYgW2NoYW5nZWRfa2V5XSBjaGFuZ2VkIGluIHRoZSBnaXZlblxuICAgICAgd2F5ICopXG4gIGxldCBmaW5kX29mZnNldCB+Y29tcGFyZSB+a2V5IH5jaGFuZ2VkX2tleSBjaGFuZ2UgPVxuICAgIGlmIEludC4oIDwgKSAoY29tcGFyZSBjaGFuZ2VkX2tleSBrZXkpIDBcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICB8IGBMZWZ0IF8gLT4gMVxuICAgICAgfCBgUmlnaHQgXyAtPiAtMVxuICAgICAgfCBfIC0+IDApXG4gICAgZWxzZSAwXG4gIDs7XG5cbiAgbGV0IHJhbmtcbiAgICAgICAgKHR5cGUgayB2IGNtcCBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgKG1hcCA6ICgoaywgdiwgY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgKGtleSA6IChrLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgc2FtZV9rZXkgYSBiID0gY29tcGFyZV9rZXkgYSBiID0gMCBpblxuICAgICAgbGV0IHdoZW5fa2V5X2NoYW5nZWQgfm1hcCB+b2xkX2tleSB+bmV3X2tleSB+b2xkX3JhbmsgPVxuICAgICAgICBpZiBjb21wYXJlX2tleSBuZXdfa2V5IG9sZF9rZXkgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIElmIHRoZSBuZXcga2V5IGlzIHNtYWxsZXIgdGhhbiB0aGUgb2xkIGtleSwgZmluZCB0aGUgc2l6ZSBvZiB0aGUgbWFwIHN1YnJhbmdlXG4gICAgICAgICAgICAgYmV0d2VlbiB0aGVtIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBwcmV2aW91cyByYW5rICopXG4gICAgICAgICAgbGV0IGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCA9IEV4Y2wgbmV3X2tleSwgRXhjbCBvbGRfa2V5IGluXG4gICAgICAgICAgbGV0IHN1YnJhbmdlID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIGluXG4gICAgICAgICAgb2xkX3JhbmsgLSBNYXAubGVuZ3RoIHN1YnJhbmdlIC0gMSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogT3RoZXJ3aXNlLCB0aGUgbmV3IGtleSBpcyBsYXJnZXIgdGhhbiB0aGUgb2xkIGtleSwgc28gZmluZCB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgICAgICBtYXAgc3VicmFuZ2UgYmV0d2VlbiB0aGVtIGFuZCBhZGQgaXQgdG8gdGhlIHByZXZpb3VzIHJhbmsgKilcbiAgICAgICAgICBsZXQgbG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kID0gRXhjbCBvbGRfa2V5LCBFeGNsIG5ld19rZXkgaW5cbiAgICAgICAgICBsZXQgc3VicmFuZ2UgPSBNYXAuc3VicmFuZ2UgbWFwIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgaW5cbiAgICAgICAgICBvbGRfcmFuayArIE1hcC5sZW5ndGggc3VicmFuZ2UgKyAxKVxuICAgICAgaW5cbiAgICAgIGxldCB3aGVuX21hcF9jaGFuZ2VkIH5vbGRfbWFwIH5uZXdfbWFwIH5rZXkgfm9sZF9yYW5rID1cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAoKiBXZSBkb24ndCBjYXJlIGFib3V0IHRoZSBkYXRhLCBzbyBvcHRpbWl6ZSB0aGVzZSBjaGVja3MgKilcbiAgICAgICAgICB+ZGF0YV9lcXVhbDooZnVuIF8gXyAtPiB0cnVlKVxuICAgICAgICAgIG9sZF9tYXBcbiAgICAgICAgICBuZXdfbWFwXG4gICAgICAgICAgfmluaXQ6b2xkX3JhbmtcbiAgICAgICAgICB+ZjooZnVuIGFjYyAoZGlmZl9rZXksIGRpZmYpIC0+XG4gICAgICAgICAgICBtYXRjaCBkaWZmIHdpdGhcbiAgICAgICAgICAgIHwgYExlZnQgXyB3aGVuIGNvbXBhcmVfa2V5IGRpZmZfa2V5IGtleSA8IDAgLT4gYWNjIC0gMVxuICAgICAgICAgICAgfCBgUmlnaHQgXyB3aGVuIGNvbXBhcmVfa2V5IGRpZmZfa2V5IGtleSA8IDAgLT4gYWNjICsgMVxuICAgICAgICAgICAgfCBfIC0+IGFjYylcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIHByb2Nlc3MgfihvbGQgOiAoKGssIHYsIF8pIE1hcC50ICogXyAqIF8pIG9wdGlvbikgbmV3X21hcCAobmV3X2tleSA6IGspID1cbiAgICAgICAgaWYgbm90IChNYXAubWVtIG5ld19tYXAgbmV3X2tleSlcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIG9sZCB3aXRoXG4gICAgICAgICAgKCogSWYgdGhlIG1hcCBhbmQga2V5IGFyZSB0aGUgc2FtZSwganVzdCByZXVzZSB0aGUgb2xkIHJhbmsgKilcbiAgICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIG9sZF9yYW5rKVxuICAgICAgICAgICAgd2hlbiBwaHlzX2VxdWFsIG5ld19tYXAgb2xkX21hcCAmJiBzYW1lX2tleSBvbGRfa2V5IG5ld19rZXkgLT4gb2xkX3JhbmtcbiAgICAgICAgICAoKiBJZiB0aGUgbWFwIGlzIHRoZSBzYW1lIGJ1dCB0aGUga2V5IGNoYW5nZWQgKilcbiAgICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIFNvbWUgb2xkX3JhbmspIHdoZW4gcGh5c19lcXVhbCBuZXdfbWFwIG9sZF9tYXAgLT5cbiAgICAgICAgICAgIFNvbWUgKHdoZW5fa2V5X2NoYW5nZWQgfm1hcDpuZXdfbWFwIH5vbGRfa2V5IH5uZXdfa2V5IH5vbGRfcmFuaylcbiAgICAgICAgICAoKiBJZiB0aGUga2V5IGlzIHRoZSBzYW1lIGJ1dCB0aGUgbWFwIGNoYW5nZWQgKilcbiAgICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIFNvbWUgb2xkX3JhbmspIHdoZW4gc2FtZV9rZXkgbmV3X2tleSBvbGRfa2V5IC0+XG4gICAgICAgICAgICBTb21lICh3aGVuX21hcF9jaGFuZ2VkIH5vbGRfbWFwIH5uZXdfbWFwIH5rZXk6bmV3X2tleSB+b2xkX3JhbmspXG4gICAgICAgICAgKCogSWYgYm90aCB0aGUgbWFwIGFuZCB0aGUga2V5IGNoYW5nZWQsIHRoaXMgY2FuIGJlIHNpbXVsYXRlZCBhcyB0aGVcbiAgICAgICAgICAgICBtYXAgY2hhbmdpbmcgZm9sbG93ZWQgYnkgdGhlIGtleSBjaGFuZ2luZyAqKVxuICAgICAgICAgIHwgU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykgLT5cbiAgICAgICAgICAgICgqIFdlIGNhbGwgW3Byb2Nlc3NdIHJlY3Vyc2l2ZWx5IGluc3RlYWQgb2YgZGlyZWN0bHkgY2FsbGluZ1xuICAgICAgICAgICAgICAgW3doZW5fbWFwX2NoYW5nZWRdIGZvbGxvd2VkIGJ5IFt3aGVuX2tleV9jaGFuZ2VkXSBzaW5jZSBpdCBtaWdodCBiZSB0aGVcbiAgICAgICAgICAgICAgIGNhc2UgdGhhdCBbb2xkX2tleV0gaXMgaW4gW29sZF9tYXBdIGFuZCBbbmV3X2tleV0gaXMgaW4gW25ld19tYXBdLCBidXRcbiAgICAgICAgICAgICAgIFtvbGRfa2V5XSBpcyBub3QgaW4gW25ld19tYXBdLiAqKVxuICAgICAgICAgICAgbGV0IG9sZF9yYW5rID1cbiAgICAgICAgICAgICAgcHJvY2VzcyB+b2xkOihTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSkgbmV3X21hcCBvbGRfa2V5XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgcHJvY2VzcyB+b2xkOihTb21lIChuZXdfbWFwLCBvbGRfa2V5LCBvbGRfcmFuaykpIG5ld19tYXAgbmV3X2tleVxuICAgICAgICAgICgqIElmIHRoZSBwcmV2aW91cyBrZXkgd2FzIG5vdCBpbiB0aGUgbWFwIG9yIHRoaXMgaXMgdGhlIGZpcnN0IHN0YWJpbGl6YXRpb24sXG4gICAgICAgICAgICAgY29tcHV0ZSB0aGUgcmFuayBmcm9tIHNjcmF0Y2ggKilcbiAgICAgICAgICB8IFNvbWUgKF8sIF8sIE5vbmUpIHwgTm9uZSAtPiBNYXAucmFuayBuZXdfbWFwIG5ld19rZXkpXG4gICAgICBpblxuICAgICAgd2l0aF9vbGQyIH5pbnN0cnVtZW50YXRpb24gbWFwIGtleSB+Zjpwcm9jZXNzKVxuICA7O1xuXG4gICgqKiBSYW5nZSBtYXAgYnkgaW5kaWNlcyAqKVxuICBsZXQgc3VicmFuZ2VfYnlfcmFua1xuICAgICAgICAodHlwZSBrIHN0YXRlX3dpdG5lc3MpXG4gICAgICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICAobWFwIDogKChrLCBfLCBfKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgKHJhbmdlIDogKGludCBNYXliZV9ib3VuZC50ICogaW50IE1heWJlX2JvdW5kLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgPVxuICAgIGxldCBmaW5kX2tleV9yYW5nZSAocmFuZ2UgOiAoaW50ICogaW50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgOiAoKGsgKiBrIG9wdGlvbikgb3B0aW9uLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICA9XG4gICAgICB3aXRoX29sZDIgbWFwIHJhbmdlIH5pbnN0cnVtZW50YXRpb24gfmY6KGZ1biB+b2xkIG1hcCAoZnJvbSwgdG9fKSAtPlxuICAgICAgICAoKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbm8ga2V5cywgb25seSBiZWdpbiBrZXksIG9yIGJlZ2luIGFuZCBlbmQga2V5cy5cbiAgICAgICAgICAgVGhlc2UgYXJlIHRoZSBrZXlzIGF0IFtmcm9tXSBhbmQgW3RvX10gcG9zaXRpb25zIGluIHRoZSBtYXAsIG9yIE5vbmUgaWYgdGhlXG4gICAgICAgICAgIGluZGljZXMgYXJlIHRvbyBiaWcuIEFzIGFsd2F5cyBbMCA8PSBmcm9tICYmIGZyb20gPD0gdG9fXSwgdGhlcmUgaXMgbm9cbiAgICAgICAgICAgcG9zc2liaWxpdHkgb2Ygb25seSBbdG9fXSBiZWluZyBhIHZhbGlkIHBvc2l0aW9uLlxuICAgICAgICAqKVxuICAgICAgICBpZiBJbnQuKCA8ICkgdG9fIGZyb20gfHwgSW50LiggPCApIGZyb20gMFxuICAgICAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiSW52YWxpZCBpbmRpY2VzXCIgKGZyb20gOiBpbnQpICh0b18gOiBpbnQpXTtcbiAgICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgfCBTb21lIChvbGRfbWFwLCAob2xkX2Zyb20sIG9sZF90byksIFNvbWUgKGJlZ2luX2tleSwgZW5kX2tleV9vcHQpKSAtPlxuICAgICAgICAgIGxldCBmaW5kX29mZnNldCA9IGZpbmRfb2Zmc2V0IH5jb21wYXJlOihNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgICAgICBsZXQgcmFuZ2Vfb2Zmc2V0X2JlZ2luID0gZnJvbSAtIG9sZF9mcm9tIGluXG4gICAgICAgICAgbGV0IHJhbmdlX29mZnNldF9lbmQgPSB0b18gLSBvbGRfdG8gaW5cbiAgICAgICAgICBsZXQgYWRqdXN0X2FuZF9vZmZzZXQgfmJ5IGtleSA9XG4gICAgICAgICAgICBsZXQgYnkgPSBieSArIGlmIGJ5ID49IDAgJiYgbm90IChNYXAubWVtIG1hcCBrZXkpIHRoZW4gMSBlbHNlIDAgaW5cbiAgICAgICAgICAgIG9mZnNldCBrZXkgbWFwIH5ieVxuICAgICAgICAgIGluXG4gICAgICAgICAgKCogV2Ugb25seSBjYXJlIGFib3V0IHRoZSBrZXlzIGNoYW5naW5nIGFuZCBub3QgdGhlIGRhdGEsIHNvIFtkYXRhX2VxdWFsXSBoZXJlXG4gICAgICAgICAgICAgY2FuIGJlIGFsd2F5cyB0cnVlICopXG4gICAgICAgICAgbGV0IGRpZmYgfmluaXQgfmYgPVxuICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmYgfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gdHJ1ZSkgb2xkX21hcCBtYXAgfmluaXQgfmZcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBiZWdpbl9rZXlfb3B0LCBlbmRfa2V5X29wdCA9XG4gICAgICAgICAgICBtYXRjaCBlbmRfa2V5X29wdCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZW5kX2tleSAtPlxuICAgICAgICAgICAgICBsZXQgbWFwX29mZnNldF9iZWdpbiwgbWFwX29mZnNldF9lbmQgPVxuICAgICAgICAgICAgICAgIGRpZmYgfmluaXQ6KDAsIDApIH5mOihmdW4gKG9mZnNldF9iZWdpbiwgb2Zmc2V0X2VuZCkgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgICAgICAgICAgKCBvZmZzZXRfYmVnaW4gKyBmaW5kX29mZnNldCB+a2V5OmJlZ2luX2tleSB+Y2hhbmdlZF9rZXk6a2V5IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgLCBvZmZzZXRfZW5kICsgZmluZF9vZmZzZXQgfmtleTplbmRfa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlICkpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICggYWRqdXN0X2FuZF9vZmZzZXQgYmVnaW5fa2V5IH5ieToobWFwX29mZnNldF9iZWdpbiArIHJhbmdlX29mZnNldF9iZWdpbilcbiAgICAgICAgICAgICAgLCBhZGp1c3RfYW5kX29mZnNldCBlbmRfa2V5IH5ieToobWFwX29mZnNldF9lbmQgKyByYW5nZV9vZmZzZXRfZW5kKSApXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgbGV0IG1hcF9vZmZzZXRfYmVnaW4gPVxuICAgICAgICAgICAgICAgIGRpZmYgfmluaXQ6MCB+ZjooZnVuIG9mZnNldF9iZWdpbiAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICBvZmZzZXRfYmVnaW4gKyBmaW5kX29mZnNldCB+a2V5OmJlZ2luX2tleSB+Y2hhbmdlZF9rZXk6a2V5IGNoYW5nZSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCBhZGp1c3RfYW5kX29mZnNldCBiZWdpbl9rZXkgfmJ5OihtYXBfb2Zmc2V0X2JlZ2luICsgcmFuZ2Vfb2Zmc2V0X2JlZ2luKVxuICAgICAgICAgICAgICAsIG50aF9mcm9tX2VpdGhlcl9zaWRlIHRvXyBtYXAgKVxuICAgICAgICAgIGluXG4gICAgICAgICAgYXNzZXJ0IChPcHRpb24uZm9yX2FsbCB+ZjooTWFwLm1lbSBtYXApIGJlZ2luX2tleV9vcHQpO1xuICAgICAgICAgIGFzc2VydCAoT3B0aW9uLmZvcl9hbGwgfmY6KE1hcC5tZW0gbWFwKSBlbmRfa2V5X29wdCk7XG4gICAgICAgICAgT3B0aW9uLm1hcCBiZWdpbl9rZXlfb3B0IH5mOihmdW4gYmVnaW5fa2V5IC0+IGJlZ2luX2tleSwgZW5kX2tleV9vcHQpXG4gICAgICAgIHwgTm9uZSB8IFNvbWUgKF8sIF8sIE5vbmUpIC0+XG4gICAgICAgICAgKCogT24gZmlyc3QgcnVuICh3aGVuIHdlIGhhdmUgdG8pIG9yIHdoZW4gYm90aCB0aGUga2V5cyBhcmUgbm9uZSwgcnVuIE8obilcbiAgICAgICAgICAgICBzY2FuLiBUaGlzIGlzIGZpbmUgZm9yIGtleXMtYXJlLW5vbmUgY2FzZSBhcyBpdCBoYXBwZW5zIHdoZW4gdGhlIHBvc2l0aW9uc1xuICAgICAgICAgICAgIGFyZSBwYXN0IGVuZCBvZiB0aGUgbWFwLCBzbyB0aGV5IHNob3VsZG4ndCBiZSB0b28gZmFyIGZyb20gZW5kIGFmdGVyIHRoZVxuICAgICAgICAgICAgIG1hcCBjaGFuZ2VzLCBhbmQgW2ZpbmRfa2V5X3JhbmdlX2xpbmVhcl0gaXMgZmFzdCBpbiBzdWNoIGNhc2UuICopXG4gICAgICAgICAgZmluZF9rZXlfcmFuZ2VfbGluZWFyIG1hcCB+ZnJvbSB+dG9fKVxuICAgIGluXG4gICAgKCogSGFuZGxlIGRpZmZlcmVudCBNYXliZV9ib3VuZCBjYXNlcyBhbmQgY2FsbCBmaW5kX2tleV9yYW5nZSBpZiBuZWNlc3NhcnkuIEl0J3NcbiAgICAgICBuaWNlciB0byBkbyB0aGlzIGhlcmUgYXMgb3Bwb3NlZCB0byBtYWtpbmcgZmluZF9rZXlfcmFuZ2UgZXZlbiBtb3JlIGNvbXBsaWNhdGVkICopXG4gICAgbGV0IG9wZW4gSW5jcmVtZW50YWwuTGV0X3N5bnRheCBpblxuICAgIGxldCAoID4+PiApIG5ld18gYm91bmQgPSBNYXliZV9ib3VuZC5tYXAgfmY6KGZ1biBfIC0+IG5ld18pIGJvdW5kIGluXG4gICAgbGV0IHJldHVybiA9IEluY3JlbWVudGFsLnJldHVybiAoSW5jcmVtZW50YWwuc3RhdGUgbWFwKSBpblxuICAgIGxldCBrZXlfcmFuZ2UgPVxuICAgICAgbWF0Y2glcGF0dGVybl9iaW5kIHJhbmdlIHdpdGhcbiAgICAgIHwgTWF5YmVfYm91bmQuVW5ib3VuZGVkLCBNYXliZV9ib3VuZC5VbmJvdW5kZWQgLT5cbiAgICAgICAgcmV0dXJuIChTb21lIChNYXliZV9ib3VuZC5VbmJvdW5kZWQsIE1heWJlX2JvdW5kLlVuYm91bmRlZCkpXG4gICAgICB8ICggKChNYXliZV9ib3VuZC5JbmNsIGwgfCBNYXliZV9ib3VuZC5FeGNsIGwpIGFzIGxiKVxuICAgICAgICAsICgoTWF5YmVfYm91bmQuSW5jbCB1IHwgTWF5YmVfYm91bmQuRXhjbCB1KSBhcyB1YikgKSAtPlxuICAgICAgICBsZXQlbWFwIGtleV9yYW5nZSA9IGZpbmRfa2V5X3JhbmdlIChJbmNyZW1lbnRhbC5ib3RoIGwgdSlcbiAgICAgICAgYW5kIGxiID0gbGJcbiAgICAgICAgYW5kIHViID0gdWIgaW5cbiAgICAgICAgKG1hdGNoIGtleV9yYW5nZSB3aXRoXG4gICAgICAgICB8IFNvbWUgKGJlZ2luX2tleSwgU29tZSBlbmRfa2V5KSAtPiBTb21lIChiZWdpbl9rZXkgPj4+IGxiLCBlbmRfa2V5ID4+PiB1YilcbiAgICAgICAgIHwgU29tZSAoYmVnaW5fa2V5LCBOb25lKSAtPiBTb21lIChiZWdpbl9rZXkgPj4+IGxiLCBVbmJvdW5kZWQpXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgKChNYXliZV9ib3VuZC5JbmNsIGwgfCBNYXliZV9ib3VuZC5FeGNsIGwpIGFzIGxiKSwgTWF5YmVfYm91bmQuVW5ib3VuZGVkIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggbCBsKVxuICAgICAgICBhbmQgbGIgPSBsYiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoa2V5LCBfKSAtPiBTb21lIChrZXkgPj4+IGxiLCBVbmJvdW5kZWQpXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgTWF5YmVfYm91bmQuVW5ib3VuZGVkLCAoKE1heWJlX2JvdW5kLkluY2wgdSB8IE1heWJlX2JvdW5kLkV4Y2wgdSkgYXMgdWIpIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggdSB1KVxuICAgICAgICBhbmQgdWIgPSB1YiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoa2V5LCBfKSAtPiBTb21lIChVbmJvdW5kZWQsIGtleSA+Pj4gdWIpXG4gICAgICAgICAoKiBJbiB0aGlzIGNhc2UsIHRoZSB1cHBlciBib3VuZCB3YXMgbGFyZ2VyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGVcbiAgICAgICAgICAgIG1hcCwgc28gdGhlIHVwcGVyIGJvdW5kIGZvciB0aGUga2V5IHJhbmdlIGlzIFtVbmJvdW5kZWRdLlxuICAgICAgICAgICAgVGhpcyBiZWhhdmlvciBpcyBkZW1vbnN0cmF0ZWQgaW4gYSB0ZXN0IGluIFsuLi90ZXN0L3Rlc3Rfc3VicmFuZ2UubWxdLiAqKVxuICAgICAgICAgfCBOb25lIC0+IFNvbWUgKFVuYm91bmRlZCwgVW5ib3VuZGVkKSlcbiAgICBpblxuICAgIHN1YnJhbmdlID9kYXRhX2VxdWFsIG1hcCBrZXlfcmFuZ2VcbiAgOztcblxuICBsZXQgdHJhbnNwb3NlXG4gICAgOiB0eXBlIGsxIGsyIHYgazFfY21wIGsyX2NtcCBzdGF0ZV93aXRuZXNzLlxuICAgICAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgICAgLT4gP2RhdGFfZXF1YWw6KHYgLT4gdiAtPiBib29sKVxuICAgICAgLT4gKGsyLCBrMl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAgIC0+ICgoazEsIChrMiwgdiwgazJfY21wKSBNYXAudCwgazFfY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgLT4gKChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGZ1biA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbikgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbCkgazJfY29tcGFyYXRvciBtIC0+XG4gICAgICB3aXRoX2NvbXBhcmF0b3IgbSAoZnVuIGsxX2NvbXBhcmF0b3IgLT5cbiAgICAgICAgbGV0IHVwZGF0ZVxuICAgICAgICAgIDogIGtleTprMSAtPiBvbGRfZGF0YTooazIsIHYsIGsyX2NtcCkgTWFwLnQgLT4gbmV3X2RhdGE6KGsyLCB2LCBrMl9jbXApIE1hcC50XG4gICAgICAgICAgICAtPiAoazIsIChrMSwgdiwgazFfY21wKSBNYXAudCwgazJfY21wKSBNYXAudFxuICAgICAgICAgICAgLT4gKGsyLCAoazEsIHYsIGsxX2NtcCkgTWFwLnQsIGsyX2NtcCkgTWFwLnRcbiAgICAgICAgICA9XG4gICAgICAgICAgZnVuIH5rZXk6azEgfm9sZF9kYXRhIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIG9sZF9kYXRhXG4gICAgICAgICAgICAgIG5ld19kYXRhXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgIH5pbml0OmFjY1xuICAgICAgICAgICAgICB+ZjooZnVuIGFjYyAoazIsIGRpZmYpIC0+XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID1cbiAgICAgICAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IHggfCBgVW5lcXVhbCAoXywgeCkgLT4gU29tZSB4XG4gICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBNYXAuY2hhbmdlIGFjYyBrMiB+ZjooZnVuIGFjY19pbm5lciAtPlxuICAgICAgICAgICAgICAgICAgbGV0IGFjY19pbm5lciA9XG4gICAgICAgICAgICAgICAgICAgIE1hcC5jaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAoT3B0aW9uLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgYWNjX2lubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfmRlZmF1bHQ6KE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOmsxX2NvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgICAgICAgIGsxXG4gICAgICAgICAgICAgICAgICAgICAgfmY6KGZ1biBfIC0+IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgIGlmIE1hcC5pc19lbXB0eSBhY2NfaW5uZXIgdGhlbiBOb25lIGVsc2UgU29tZSBhY2NfaW5uZXIpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgYWRkIH5rZXkgfmRhdGEgPVxuICAgICAgICAgIHVwZGF0ZSB+a2V5IH5vbGRfZGF0YTooTWFwLmVtcHR5IGsyX2NvbXBhcmF0b3IpIH5uZXdfZGF0YTpkYXRhXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZW1vdmUgfmtleSB+ZGF0YSA9XG4gICAgICAgICAgdXBkYXRlIH5rZXkgfm9sZF9kYXRhOmRhdGEgfm5ld19kYXRhOihNYXAuZW1wdHkgazJfY29tcGFyYXRvcilcbiAgICAgICAgaW5cbiAgICAgICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgICAgICBtXG4gICAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICAgIH5pbml0OihNYXAuZW1wdHkgazJfY29tcGFyYXRvcilcbiAgICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgICAgfnVwZGF0ZVxuICAgICAgICAgIH5hZGRcbiAgICAgICAgICB+cmVtb3ZlKVxuICA7O1xuXG4gIGxldCBjb2xsYXBzZV9ieVxuICAgICAgICAodHlwZSBvdXRlcl9rZXkgb3V0ZXJfY21wIGlubmVyX2tleSBpbm5lcl9jbXAgY29tYmluZWRfa2V5IGNvbWJpbmVkX2NtcClcbiAgICAgICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXBfaW5jciA6XG4gICAgICAgICAgICgob3V0ZXJfa2V5LCAoaW5uZXJfa2V5LCBfLCBpbm5lcl9jbXApIE1hcC50LCBvdXRlcl9jbXApIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KG1lcmdlX2tleXMgOiBvdXRlcl9rZXkgLT4gaW5uZXJfa2V5IC0+IGNvbWJpbmVkX2tleSlcbiAgICAgICAgfihjb21wYXJhdG9yIDogKGNvbWJpbmVkX2tleSwgY29tYmluZWRfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50KVxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZF9uZXN0ZWRfbWFwc1xuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IGNvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+dXBkYXRlOihmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5vbGRfZGF0YTpfIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLnNldCBhY2MgfmtleToobWVyZ2Vfa2V5cyBvdXRlcl9rZXkgaW5uZXJfa2V5KSB+ZGF0YTpuZXdfZGF0YSlcbiAgICAgIH5hZGQ6KGZ1biB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGEgYWNjIC0+XG4gICAgICAgIE1hcC5hZGRfZXhuIGFjYyB+a2V5OihtZXJnZV9rZXlzIG91dGVyX2tleSBpbm5lcl9rZXkpIH5kYXRhKVxuICAgICAgfnJlbW92ZTooZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpfIGFjYyAtPlxuICAgICAgICBNYXAucmVtb3ZlIGFjYyAobWVyZ2Vfa2V5cyBvdXRlcl9rZXkgaW5uZXJfa2V5KSlcbiAgOztcblxuICBsZXQgY29sbGFwc2VcbiAgICAgICAgKHR5cGUgb3V0ZXJfa2V5IG91dGVyX2NtcCBpbm5lcl9rZXkgaW5uZXJfY21wKVxuICAgICAgICA/aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXBfaW5jciA6XG4gICAgICAgICAgICgob3V0ZXJfa2V5LCAoaW5uZXJfa2V5LCBfLCBpbm5lcl9jbXApIE1hcC50LCBvdXRlcl9jbXApIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+Y29tcGFyYXRvcjooaW5uZXJfY29tcGFyYXRvciA6IChpbm5lcl9rZXksIGlubmVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudClcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIChmdW4gb3V0ZXJfY29tcGFyYXRvciAtPlxuICAgICAgbGV0IG1vZHVsZSBDbXAgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gb3V0ZXJfa2V5ICogaW5uZXJfa2V5XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gKG91dGVyX2NtcCwgaW5uZXJfY21wKSBUdXBsZTIuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICAgICAgbGV0IGNvbXBhcmF0b3IgPVxuICAgICAgICAgIGxldCBpbm5lcl9jb21wYXJhdG9yID1cbiAgICAgICAgICAgIGxldCBtb2R1bGUgTSA9ICh2YWwgaW5uZXJfY29tcGFyYXRvcikgaW5cbiAgICAgICAgICAgIE0uY29tcGFyYXRvclxuICAgICAgICAgIGluXG4gICAgICAgICAgVHVwbGUyLmNvbXBhcmF0b3Igb3V0ZXJfY29tcGFyYXRvciBpbm5lcl9jb21wYXJhdG9yXG4gICAgICAgIDs7XG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICBjb2xsYXBzZV9ieVxuICAgICAgICA/aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcF9pbmNyXG4gICAgICAgIH5tZXJnZV9rZXlzOlR1cGxlMi5jcmVhdGVcbiAgICAgICAgfmNvbXBhcmF0b3I6KG1vZHVsZSBDbXApKVxuICA7O1xuXG4gIGxldCBleHBhbmRcbiAgICAgICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcF9pbmNyXG4gICAgICAgIH5vdXRlcl9jb21wYXJhdG9yXG4gICAgICAgIH5pbm5lcl9jb21wYXJhdG9yXG4gICAgPVxuICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgbWFwX2luY3JcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgb3V0ZXJfY29tcGFyYXRvcilcbiAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5OihvdXRlcl9rZXksIGlubmVyX2tleSkgfm9sZF9kYXRhOl8gfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICBNYXAudXBkYXRlIGFjYyBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IE1hcC5zaW5nbGV0b24gaW5uZXJfY29tcGFyYXRvciBpbm5lcl9rZXkgbmV3X2RhdGFcbiAgICAgICAgICB8IFNvbWUgbWFwIC0+IE1hcC5zZXQgbWFwIH5rZXk6aW5uZXJfa2V5IH5kYXRhOm5ld19kYXRhKSlcbiAgICAgIH5hZGQ6KGZ1biB+a2V5OihvdXRlcl9rZXksIGlubmVyX2tleSkgfmRhdGEgYWNjIC0+XG4gICAgICAgIE1hcC51cGRhdGUgYWNjIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gTWFwLnNpbmdsZXRvbiBpbm5lcl9jb21wYXJhdG9yIGlubmVyX2tleSBkYXRhXG4gICAgICAgICAgfCBTb21lIG1hcCAtPiBNYXAuYWRkX2V4biBtYXAgfmtleTppbm5lcl9rZXkgfmRhdGEpKVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXk6KG91dGVyX2tleSwgaW5uZXJfa2V5KSB+ZGF0YTpfIGFjYyAtPlxuICAgICAgICBNYXAuY2hhbmdlIGFjYyBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgbWFwIC0+XG4gICAgICAgICAgICBsZXQgbWFwID0gTWFwLnJlbW92ZSBtYXAgaW5uZXJfa2V5IGluXG4gICAgICAgICAgICBPcHRpb24uc29tZV9pZiAobm90IChNYXAuaXNfZW1wdHkgbWFwKSkgbWFwKSlcbiAgOztcblxuICBsZXQgY291bnRpID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6MFxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgY291bnQgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBjb3VudCAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBjb3VudCAtIDEgZWxzZSBjb3VudClcbiAgOztcblxuICBsZXQgY291bnQgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgY291bnRpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBleGlzdHNpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCAoY291bnRpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYpIH5mOihmdW4gY291bnQgLT5cbiAgICAgIGNvdW50IDw+IDApXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mID1cbiAgICBleGlzdHNpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBzdW1cbiAgICAgICAgKHR5cGUgdSlcbiAgICAgICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXBfaW5jciA6ICgoXywgXywgXykgTWFwLnQsIF8pIEluY3JlbWVudGFsLnQpXG4gICAgICAgIChtb2R1bGUgR3JvdXAgOiBBYnN0cmFjdF9hbGdlYnJhLkNvbW11dGF0aXZlX2dyb3VwLldpdGhvdXRfc2V4cCB3aXRoIHR5cGUgdCA9IHUpXG4gICAgICAgIH5mXG4gICAgPVxuICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgbWFwX2luY3JcbiAgICAgIH5pbml0Okdyb3VwLnplcm9cbiAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgIH5hZGQ6KGZ1biB+a2V5Ol8gfmRhdGE6diBhY2MgLT4gR3JvdXAuKCArICkgYWNjIChmIHYpKVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXk6XyB+ZGF0YTp2IGFjYyAtPiBHcm91cC4oIC0gKSBhY2MgKGYgdikpXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGxpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcFxuICAgICAgKGNvdW50aSA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgbm90IChmIH5rZXkgfmRhdGEpKSlcbiAgICAgIH5mOihmdW4gY291bnQgLT4gY291bnQgPSAwKVxuICA7O1xuXG4gIGxldCBmb3JfYWxsID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGZvcl9hbGxpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCB1bm9yZGVyZWRfZm9sZFxuICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgP3VwZGF0ZVxuICAgICAgICA/c3BlY2lhbGl6ZWRfaW5pdGlhbFxuICAgICAgICA/ZmluYWxpemVcbiAgICAgICAgP3JldmVydF90b19pbml0X3doZW5fZW1wdHlcbiAgICAgICAgbWFwXG4gICAgICAgIH5pbml0XG4gICAgICAgIH5hZGRcbiAgICAgICAgfnJlbW92ZVxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgID91cGRhdGVcbiAgICAgID9zcGVjaWFsaXplZF9pbml0aWFsXG4gICAgICA/ZmluYWxpemVcbiAgICAgID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XG4gICAgICBtYXBcbiAgICAgIH5pbml0XG4gICAgICB+YWRkXG4gICAgICB+cmVtb3ZlXG4gIDs7XG5cbiAgbGV0IHVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzXG4gICAgICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eVxuICAgICAgICA/dXBkYXRlXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5pdFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmVcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eVxuICAgICAgP3VwZGF0ZVxuICAgICAgbWFwXG4gICAgICB+aW5pdFxuICAgICAgfmFkZFxuICAgICAgfnJlbW92ZVxuICA7O1xuXG4gIG1vZHVsZSBGb3JfdGVzdGluZyA9IHN0cnVjdFxuICAgIGxldCBmaW5kX2tleV9yYW5nZV9saW5lYXIgPSBmaW5kX2tleV9yYW5nZV9saW5lYXJcbiAgZW5kXG5cbiAgbW9kdWxlIExvb2t1cCA9IHN0cnVjdFxuICAgIHR5cGUgKCd2LCAndykgZW50cnkgPVxuICAgICAgeyBtdXRhYmxlIHNhdmVkX3ZhbHVlIDogJ3Ygb3B0aW9uXG4gICAgICA7IG5vZGUgOiAoJ3Ygb3B0aW9uLCAndykgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUudFxuICAgICAgfVxuXG4gICAgdHlwZSAoJ2ssICd2LCAnY21wLCAndykgdCA9XG4gICAgICB7IG11dGFibGUgc2F2ZWRfbWFwIDogKCdrLCAndiwgJ2NtcCkgTWFwLnRcbiAgICAgICgqIFdlIG1heSBoYXZlIG11bHRpcGxlIGVudHJpZXMgcGVyIGtleSBpZiBub2RlcyBiZWNvbWUgbmVjZXNzYXJ5IGFnYWluIGFmdGVyIGJlaW5nXG4gICAgICAgICByZW1vdmVkLiAqKVxuICAgICAgOyBtdXRhYmxlIGxvb2t1cF9lbnRyaWVzIDogKCdrLCAoJ3YsICd3KSBlbnRyeSBsaXN0LCAnY21wKSBNYXAudFxuICAgICAgOyB1cGRhdGVyX25vZGUgOiAodW5pdCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgIDsgc2NvcGUgOiAndyBJbmNyZW1lbnRhbC5TY29wZS50XG4gICAgICB9XG5cbiAgICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgICB0eXBlIHRcbiAgICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICAgIGVuZCkgPVxuICAgIHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCd2LCAndykgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcywgJ3cpIHRcbiAgICBlbmRcblxuICAgIGxldCBjcmVhdGVcbiAgICAgICAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICAgIGlucHV0X21hcFxuICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICA9XG4gICAgICBsZXQgcmVjIHNlbGYgPVxuICAgICAgICBsYXp5XG4gICAgICAgICAgKGxldCB1cGRhdGVyX25vZGUgPVxuICAgICAgICAgICAgIEluY3JlbWVudGFsLm1hcCBpbnB1dF9tYXAgfmY6KGZ1biBpbnB1dF9tYXAgLT5cbiAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5JbnN0cnVtZW50YXRpb24uZiAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgIGxldCAobGF6eSBzZWxmKSA9IHNlbGYgaW5cbiAgICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgICBzZWxmLnNhdmVkX21hcFxuICAgICAgICAgICAgICAgICAgIGlucHV0X21hcFxuICAgICAgICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICAgICAgfmluaXQ6KClcbiAgICAgICAgICAgICAgICAgICB+ZjooZnVuICgpIChrZXksIGNoYW5nZWRfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgZW50cmllcyA9IE1hcC5maW5kX211bHRpIHNlbGYubG9va3VwX2VudHJpZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgICBMaXN0Lml0ZXIgZW50cmllcyB+ZjooZnVuIGVudHJ5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgIDwtIChtYXRjaCBjaGFuZ2VkX3ZhbHVlIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IG5ld192YWx1ZSB8IGBVbmVxdWFsIChfLCBuZXdfdmFsdWUpIC0+IFNvbWUgbmV3X3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSBlbnRyeS5ub2RlKSk7XG4gICAgICAgICAgICAgICAgIHNlbGYuc2F2ZWRfbWFwIDwtIGlucHV0X21hcCkpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICAgICB7IHNhdmVkX21hcCA9IGVtcHR5X21hcFxuICAgICAgICAgICA7IGxvb2t1cF9lbnRyaWVzID0gZW1wdHlfbWFwXG4gICAgICAgICAgIDsgdXBkYXRlcl9ub2RlXG4gICAgICAgICAgIDsgc2NvcGUgPSBJbmNyZW1lbnRhbC5TY29wZS5jdXJyZW50IChJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dF9tYXApICgpXG4gICAgICAgICAgIH0pXG4gICAgICBpblxuICAgICAgTGF6eS5mb3JjZSBzZWxmXG4gICAgOztcblxuICAgIGxldFtAY29sZF0gc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5IH5pc19ub3dfb2JzZXJ2YWJsZSA9XG4gICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgIGxldCBjdXJyZW50X2VudHJpZXMgPSBNYXAuZmluZF9tdWx0aSB0Lmxvb2t1cF9lbnRyaWVzIGtleSBpblxuICAgICAgbGV0IGlzX2xpbmtlZCA9IExpc3QuZXhpc3RzIGN1cnJlbnRfZW50cmllcyB+ZjoocGh5c19lcXVhbCBlbnRyeSkgaW5cbiAgICAgIGlmIEJvb2wuZXF1YWwgaXNfbGlua2VkIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuICgpXG4gICAgICBlbHNlIGlmIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuXG4gICAgICAgIHQubG9va3VwX2VudHJpZXNcbiAgICAgICAgPC0gTWFwLnVwZGF0ZSB0Lmxvb2t1cF9lbnRyaWVzIGtleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IFNvbWUgKG90aGVyX2VudHJ5IDo6IF8gYXMgb3RoZXJfZW50cmllcykgLT5cbiAgICAgICAgICAgICgqIFVwZGF0ZSB0aGlzIGVudHJ5J3MgdmFsdWUgdG8gYmUgY3VycmVudC4gKilcbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIG90aGVyX2VudHJ5LnNhdmVkX3ZhbHVlO1xuICAgICAgICAgICAgZW50cnkgOjogb3RoZXJfZW50cmllc1xuICAgICAgICAgIHwgTm9uZSB8IFNvbWUgW10gLT5cbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIE1hcC5maW5kIHQuc2F2ZWRfbWFwIGtleTtcbiAgICAgICAgICAgIFsgZW50cnkgXSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV3X2VudHJpZXMgPVxuICAgICAgICAgIExpc3QuZmlsdGVyIGN1cnJlbnRfZW50cmllcyB+ZjooZnVuIHggLT4gbm90IChwaHlzX2VxdWFsIGVudHJ5IHgpKVxuICAgICAgICBpblxuICAgICAgICB0Lmxvb2t1cF9lbnRyaWVzXG4gICAgICAgIDwtIChpZiBMaXN0LmlzX2VtcHR5IG5ld19lbnRyaWVzXG4gICAgICAgICAgICB0aGVuIE1hcC5yZW1vdmUgdC5sb29rdXBfZW50cmllcyBrZXlcbiAgICAgICAgICAgIGVsc2UgTWFwLnNldCB0Lmxvb2t1cF9lbnRyaWVzIH5rZXkgfmRhdGE6bmV3X2VudHJpZXMpKVxuICAgIDs7XG5cbiAgICBsZXRbQGNvbGRdIHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleSA9XG4gICAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSB0LnVwZGF0ZXJfbm9kZSBpblxuICAgICAgSW5jcmVtZW50YWwuU2NvcGUud2l0aGluIGluY3JlbWVudGFsX3N0YXRlIHQuc2NvcGUgfmY6KGZ1biAoKSAtPlxuICAgICAgICBsZXQgcmVjIGVudHJ5ID1cbiAgICAgICAgICBsYXp5XG4gICAgICAgICAgICB7IHNhdmVkX3ZhbHVlID0gTWFwLmZpbmQgdC5zYXZlZF9tYXAga2V5XG4gICAgICAgICAgICA7IG5vZGUgPVxuICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgaW5jcmVtZW50YWxfc3RhdGVcbiAgICAgICAgICAgICAgICAgIChmdW4gKCkgLT4gKGZvcmNlIGVudHJ5KS5zYXZlZF92YWx1ZSlcbiAgICAgICAgICAgICAgICAgIH5vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZTooc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5KVxuICAgICAgICAgICAgfVxuICAgICAgICBpblxuICAgICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuYWRkX2RlcGVuZGVuY3lcbiAgICAgICAgICBlbnRyeS5ub2RlXG4gICAgICAgICAgKEluY3JlbWVudGFsLkV4cGVydC5EZXBlbmRlbmN5LmNyZWF0ZSB0LnVwZGF0ZXJfbm9kZSk7XG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIGVudHJ5Lm5vZGUpXG4gICAgOztcblxuICAgIGxldCBmaW5kIHQga2V5ID1cbiAgICAgIG1hdGNoIE1hcC5maW5kX211bHRpIHQubG9va3VwX2VudHJpZXMga2V5IHdpdGhcbiAgICAgIHwgZW50cnkgOjogXyAtPiBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBlbnRyeS5ub2RlXG4gICAgICB8IFtdIC0+IHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleVxuICAgIDs7XG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnID0gc3RydWN0XG4gICAgICBsZXRbQGNvbGRdIHNleHBfb2ZfZW50cnkgc2V4cF9vZl92YWx1ZSBlbnRyeSA9XG4gICAgICAgIGxldCB7IHNhdmVkX3ZhbHVlOyBub2RlIH0gPSBlbnRyeSBpblxuICAgICAgICBsZXQgbm9kZSA9IEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIG5vZGUgaW5cbiAgICAgICAgWyVzZXhwXG4gICAgICAgICAgeyBzYXZlZF92YWx1ZSA6IHZhbHVlIG9wdGlvblxuICAgICAgICAgIDsgbm9kZV9pbmZvID0gKEluY3JlbWVudGFsLnVzZXJfaW5mbyBub2RlIDogKEluZm8udCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX2NvbnN0ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChJbmNyZW1lbnRhbC5pc19jb25zdCBub2RlKSAoKVxuICAgICAgICAgICAgICAgOiAodW5pdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX2ludmFsaWQgPVxuICAgICAgICAgICAgICAoT3B0aW9uLnNvbWVfaWYgKG5vdCAoSW5jcmVtZW50YWwuaXNfdmFsaWQgbm9kZSkpICgpXG4gICAgICAgICAgICAgICA6ICh1bml0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICA7IG5vZGVfaXNfdW5uZWNlc3NhcnkgPVxuICAgICAgICAgICAgICAoT3B0aW9uLnNvbWVfaWYgKG5vdCAoSW5jcmVtZW50YWwuaXNfbmVjZXNzYXJ5IG5vZGUpKSAoKVxuICAgICAgICAgICAgICAgOiAodW5pdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgfV1cbiAgICAgIDs7XG5cbiAgICAgIGxldFtAY29sZF0gc2V4cF9vZl90IHNleHBfb2Zfa2V5IHNleHBfb2ZfdmFsdWUgdCA9XG4gICAgICAgIGxldCBpbmZvX3Blcl9rZXkgPVxuICAgICAgICAgIE1hcC5tZXJnZSB0LnNhdmVkX21hcCB0Lmxvb2t1cF9lbnRyaWVzIH5mOihmdW4gfmtleSBkYXRhIC0+XG4gICAgICAgICAgICBsZXQgYWN0dWFsX3ZhbHVlLCBlbnRyaWVzID1cbiAgICAgICAgICAgICAgbWF0Y2ggZGF0YSB3aXRoXG4gICAgICAgICAgICAgIHwgYExlZnQgeCAtPiBTb21lIHgsIFtdXG4gICAgICAgICAgICAgIHwgYFJpZ2h0IHkgLT4gTm9uZSwgeVxuICAgICAgICAgICAgICB8IGBCb3RoICh4LCB5KSAtPiBTb21lIHgsIHlcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBTb21lXG4gICAgICAgICAgICAgIFslc2V4cFxuICAgICAgICAgICAgICAgIHsga2V5IDoga2V5XG4gICAgICAgICAgICAgICAgOyBhY3R1YWxfdmFsdWUgOiAodmFsdWUgb3B0aW9uW0BzZXhwLm9wdGlvbl0pXG4gICAgICAgICAgICAgICAgOyBlbnRyaWVzIDogdmFsdWUgZW50cnkgbGlzdFxuICAgICAgICAgICAgICAgIH1dKVxuICAgICAgICBpblxuICAgICAgICBTZXhwLkxpc3QgKE1hcC5kYXRhIGluZm9fcGVyX2tleSlcbiAgICAgIDs7XG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBzdGF0ZV93aXRuZXNzXG5cbiAgaW5jbHVkZVxuICAgIFNfZ2VuXG4gICAgd2l0aCB0eXBlICdhIEluY3IudCA9ICgnYSwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICBhbmQgdHlwZSAnYSBJbmNyLkN1dG9mZi50ID0gJ2EgSW5jcmVtZW50YWwuQ3V0b2ZmLnRcbiAgICAgYW5kIHR5cGUgKCdrLCAndiwgJ2NtcCkgTG9va3VwLnQgPSAoJ2ssICd2LCAnY21wLCBzdGF0ZV93aXRuZXNzKSBHZW5lcmljLkxvb2t1cC50XG5lbmRcblxubW9kdWxlIE1ha2UgKEluY3IgOiBJbmNyZW1lbnRhbC5TKSA9IHN0cnVjdFxuICBpbmNsdWRlIEdlbmVyaWNcbiAgbW9kdWxlIEluc3RydW1lbnRhdGlvbiA9IEluc3RydW1lbnRhdGlvblxuXG4gIGxldCBmbGF0dGVuIHggPSBmbGF0dGVuIEluY3IuU3RhdGUudCB4XG5cbiAgbW9kdWxlIExvb2t1cCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgTG9va3VwXG5cbiAgICB0eXBlICgnaywgJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wLCBJbmNyLnN0YXRlX3dpdG5lc3MpIExvb2t1cC50XG5cbiAgICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgICB0eXBlIHRcbiAgICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICAgIGVuZCkgOiBzaWdcbiAgICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBHZW5lcmljXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
