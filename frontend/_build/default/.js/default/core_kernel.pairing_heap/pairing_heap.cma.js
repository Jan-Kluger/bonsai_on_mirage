// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Pairing_heap
//# unitInfo: Requires: Base__Container, Core, Core__Array, Core__Int, Core__List, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Pairing_heap = "Pairing_heap",
    cst_pairing_heap = "pairing_heap",
    cst_pairing_heap_src_pairing_h = "pairing_heap/src/pairing_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Array = global_data.Core__Array,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Option = global_data.Core__Option,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Base_Container = global_data.Base__Container;
   caml_call1(Ppx_module_timer_runtime[4], cst_Pairing_heap);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_pairing_heap);
   caml_call1(Expect_test_collector[6][1], cst_pairing_heap_src_pairing_h);
   caml_call2(Ppx_inline_test_lib[5], cst_pairing_heap, "pairing_heap.ml");
   var
    empty = Tuple_pool[3][4],
    is_empty = Tuple_pool[3][5],
    equal = Tuple_pool[3][7],
    dummy_id = -1,
    _a_ = [0, cst_pairing_heap_src_pairing_h, 110, 4],
    dummy = 0;
   function child(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][4]);
   }
   function sibling(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][5]);
   }
   function prev(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][6]);
   }
   function id(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][7]);
   }
   function set_child(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][4], v);
   }
   function set_sibling(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][5], v);
   }
   function set_prev(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][6], v);
   }
   function value_exn(t, pool){
    if(caml_call1(is_empty, t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][3]);
   }
   function allocate(value, pool, id){
    var
     _E_ = caml_call1(empty, 0),
     _F_ = caml_call1(empty, 0),
     _G_ = caml_call1(empty, 0);
    return caml_call6(Tuple_pool[21], pool, value, _G_, _F_, _E_, id);
   }
   function free(t, pool){return caml_call2(Tuple_pool[16], pool, t);}
   function disconnect_sibling(t, pool){
    var sibling$0 = sibling(t, pool);
    if(1 - caml_call1(is_empty, sibling$0)){
     set_sibling(t, caml_call1(empty, 0), pool);
     set_prev(sibling$0, caml_call1(empty, 0), pool);
    }
    return sibling$0;
   }
   function disconnect_child(t, pool){
    var child$0 = child(t, pool);
    if(1 - caml_call1(is_empty, child$0)){
     set_child(t, caml_call1(empty, 0), pool);
     set_prev(child$0, caml_call1(empty, 0), pool);
    }
    return child$0;
   }
   function detach(t, pool){
    if(1 - caml_call1(is_empty, t)){
     var prev$0 = prev(t, pool);
     if(1 - caml_call1(is_empty, prev$0)){
      var
       relation_to_prev =
         caml_call2(equal, t, child(prev$0, pool)) ? -977688164 : -560648958;
      set_prev(t, caml_call1(empty, 0), pool);
      var sibling = disconnect_sibling(t, pool);
      if(-560648958 <= relation_to_prev)
       set_sibling(prev$0, sibling, pool);
      else
       set_child(prev$0, sibling, pool);
      if(1 - caml_call1(is_empty, sibling))
       return set_prev(sibling, prev$0, pool);
     }
    }
   }
   function create(capacity){
    var
     _B_ = caml_call1(Tuple_pool[3][4], 0),
     _C_ = caml_call1(Tuple_pool[3][4], 0),
     _D_ = [0, 0, caml_call1(Tuple_pool[3][4], 0), _C_, _B_, dummy_id];
    return caml_call3(Tuple_pool[9], Tuple_pool[1][21], capacity, _D_);
   }
   var
    _c_ = Core_Int[62],
    _d_ = [0, cst_pairing_heap_src_pairing_h, 239, 10],
    _e_ = [0, cst_pairing_heap_src_pairing_h, 237, 8],
    _f_ = [0, cst_pairing_heap_src_pairing_h, 246, 2],
    cst_Heap_top_exn_called_on_an_ = "Heap.top_exn called on an empty heap";
   function invariant(param, t){
    if
     (!
      caml_call1(is_empty, t[3])
      && ! caml_call1(is_empty, sibling(t[3], t[2])))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     _z_ = caml_call1(empty, 0),
     to_visit$2 = [0, [0, t[3], _z_, 0], 0],
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var
      to_visit$0 = to_visit[2],
      match = to_visit[1],
      maybe_parent_value = match[3],
      expected_prev = match[2],
      node = match[1];
     if(caml_call1(is_empty, node))
      to_visit = to_visit$0;
     else{
      var this_value = value_exn(node, t[2]);
      if(! caml_call2(equal, prev(node, t[2]), expected_prev))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      let this_value$0 = this_value;
      caml_call2
       (Core_Option[42],
        maybe_parent_value,
        function(parent_value){
         var _A_ = caml_call2(t[1], parent_value, this_value$0);
         if(caml_call2(Core[88], _A_, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
        });
      var
       _y_ =
         [0, [0, sibling(node, t[2]), node, maybe_parent_value], to_visit$0],
       to_visit$1 = [0, [0, child(node, t[2]), node, [0, this_value]], _y_];
      to_visit = to_visit$1;
     }
    }
   }
   function create$0(opt, cmp, param){
    var min_size = opt ? opt[1] : 1, _x_ = caml_call1(empty, 0);
    return [0, cmp, create(min_size), _x_, 0];
   }
   function copy(param){
    var
     cmp = param[1],
     pool$0 = param[2],
     start = param[3],
     num_of_allocated_nodes = param[4],
     pool = create(caml_call1(Tuple_pool[11], pool$0));
    function copy_node(node, to_visit){
     if(caml_call1(is_empty, node))
      return [0, caml_call1(empty, 0), to_visit];
     var
      _v_ = id(node, pool$0),
      new_node = allocate(value_exn(node, pool$0), pool, _v_),
      _w_ = [0, [0, new_node, -560648958, sibling(node, pool$0)], to_visit],
      to_visit$0 = [0, [0, new_node, -977688164, child(node, pool$0)], _w_];
     return [0, new_node, to_visit$0];
    }
    var
     match$1 = copy_node(start, 0),
     to_visit$1 = match$1[2],
     new_start = match$1[1],
     to_visit = to_visit$1;
    for(;;){
     if(! to_visit) return [0, cmp, pool, new_start, num_of_allocated_nodes];
     var
      rest = to_visit[2],
      match = to_visit[1],
      node_to_copy = match[3],
      slot = match[2],
      node_to_update = match[1],
      match$0 = copy_node(node_to_copy, rest),
      to_visit$0 = match$0[2],
      new_node = match$0[1];
     if(-560648958 <= slot)
      set_sibling(node_to_update, new_node, pool);
     else
      set_child(node_to_update, new_node, pool);
     if(1 - caml_call1(is_empty, new_node))
      set_prev(new_node, node_to_update, pool);
     to_visit = to_visit$0;
    }
   }
   function merge(t, root1, root2){
    if(caml_call1(is_empty, root1)) return root2;
    if(caml_call1(is_empty, root2)) return root1;
    function add_child(t, node, new_child){
     var pool = t[2], current_child = disconnect_child(node, pool);
     set_sibling(new_child, current_child, pool);
     if(1 - caml_call1(is_empty, current_child))
      set_prev(current_child, new_child, pool);
     set_child(node, new_child, pool);
     set_prev(new_child, node, pool);
     return node;
    }
    var
     v1 = value_exn(root1, t[2]),
     v2 = value_exn(root2, t[2]),
     _u_ = caml_call2(t[1], v1, v2);
    return caml_call2(Core[91], _u_, 0)
            ? add_child(t, root1, root2)
            : add_child(t, root2, root1);
   }
   function top_exn(t){
    return caml_call1(is_empty, t[3])
            ? caml_call1(Core[5], cst_Heap_top_exn_called_on_an_)
            : value_exn(t[3], t[2]);
   }
   function top(t){return caml_call1(is_empty, t[3]) ? 0 : [0, top_exn(t)];}
   function add_node(t$1, v){
    var t = t$1[2];
    if(caml_call1(Tuple_pool[14], t)){
     var t$0 = t$1[2];
     t$1[2] = caml_call2(Tuple_pool[13], 0, t$0);
    }
    t$1[4] = t$1[4] + 1 | 0;
    var _t_ = caml_call1(_c_, t$1[4]), node = allocate(v, t$1[2], _t_);
    t$1[3] = merge(t$1, t$1[3], node);
    return node;
   }
   function add(t, v){add_node(t, v); return 0;}
   var max_stack_depth = 1000;
   function loop(t, depth, head$0){
    if(! caml_call2(Core[87], depth, max_stack_depth)){
     if(caml_call1(is_empty, head$0)) return head$0;
     var next1$0 = disconnect_sibling(head$0, t[2]);
     if(caml_call1(is_empty, next1$0)) return head$0;
     var
      next2$0 = disconnect_sibling(next1$0, t[2]),
      _s_ = loop(t, depth + 1 | 0, next2$0);
     return merge(t, merge(t, head$0, next1$0), _s_);
    }
    a:
    {
     b:
     {
      var acc = 0, head = head$0;
      for(;;){
       if(caml_call1(is_empty, head)) break b;
       var next1 = disconnect_sibling(head, t[2]);
       if(caml_call1(is_empty, next1)) break;
       var
        next2 = disconnect_sibling(next1, t[2]),
        acc$0 = [0, merge(t, head, next1), acc];
       acc = acc$0;
       head = next2;
      }
      var match = [0, head, acc];
      break a;
     }
     var match = acc;
    }
    if(! match) return caml_call1(empty, 0);
    var h = match[1];
    if(! match[2]) return h;
    var xs = match[2];
    return caml_call3
            (Core_List[20],
             xs,
             h,
             function(acc, heap){return merge(t, acc, heap);});
   }
   function remove_non_empty(t, node){
    var pool = t[2];
    detach(node, pool);
    var
     head = disconnect_child(node, pool),
     merged_children = loop(t, 0, head),
     new_root =
       caml_call2(equal, t[3], node)
        ? merged_children
        : merge(t, t[3], merged_children);
    free(node, pool);
    t[3] = new_root;
    return 0;
   }
   function remove_top(t){
    var _r_ = 1 - caml_call1(is_empty, t[3]);
    return _r_ ? remove_non_empty(t, t[3]) : _r_;
   }
   function clear(t){
    var _p_ = 1 - caml_call1(is_empty, t[3]);
    if(_p_){
     var pool = t[2], node$0 = t[3], node = node$0;
     for(;;){
      var child$0 = child(node, pool), sibling$0 = sibling(node, pool);
      if(caml_call1(is_empty, child$0))
       if(caml_call1(is_empty, sibling$0)){
        var prev$0 = prev(node, pool);
        detach(node, pool);
        free(node, pool);
        if(! (1 - caml_call1(is_empty, prev$0))){
         t[3] = caml_call1(empty, 0);
         var _q_ = 0;
         break;
        }
        node = prev$0;
       }
       else
        node = sibling$0;
      else
       node = child$0;
     }
    }
    else
     var _q_ = _p_;
    return _q_;
   }
   function pop_exn(t){var r = top_exn(t); remove_top(t); return r;}
   function pop(t){return caml_call1(is_empty, t[3]) ? 0 : [0, pop_exn(t)];}
   function pop_if(t, f){
    var match = top(t);
    if(! match) return 0;
    var v = match[1];
    return caml_call1(f, v) ? (remove_top(t), [0, v]) : 0;
   }
   function fold(t, init, f){
    var
     pool = t[2],
     to_visit$2 = [0, t[3], 0],
     acc = init,
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return acc;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      to_visit = to_visit$0;
     else{
      var
       _o_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _o_],
       acc$0 = caml_call2(f, acc, value_exn(node, pool));
      acc = acc$0;
      to_visit = to_visit$1;
     }
    }
   }
   function iter(t, f){
    var pool = t[2], to_visit$2 = [0, t[3], 0], to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      to_visit = to_visit$0;
     else{
      caml_call1(f, value_exn(node, pool));
      var
       _n_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _n_];
      to_visit = to_visit$1;
     }
    }
   }
   function length(t){var t$0 = t[2]; return caml_call1(Tuple_pool[12], t$0);}
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    _b_ = Core_Int[92],
    C = caml_call1(Base_Container[17], [0, fold, iter$0, length$0]);
   function is_empty$0(t){return caml_call1(is_empty, t[3]);}
   var
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7],
    cst_Heap_value_exn_node_was_re =
      "Heap.value_exn: node was removed from the heap",
    cst_cannot_remove_from_a_diffe = "cannot remove from a different heap";
   function of_array(arr, cmp){
    var t = create$0([0, arr.length - 1], cmp, 0);
    caml_call2(Core_Array[32], arr, function(v){return add(t, v);});
    return t;
   }
   function of_list(l, cmp){
    return of_array(caml_call1(Core_Array[21], l), cmp);
   }
   function sexp_of_t(f, t){
    var
     _k_ = t[1],
     _l_ = caml_call1(to_array, t),
     _m_ = caml_call2(Core_Array[115], _l_, _k_);
    return caml_call2(Core_Array[17], f, _m_);
   }
   function is_node_valid(t){
    var _j_ = t[2];
    return caml_call2(_b_, id(t[1], t[3][2]), _j_);
   }
   function value_exn$0(t){
    return is_node_valid(t)
            ? value_exn(t[1], t[3][2])
            : caml_call1(Core[5], cst_Heap_value_exn_node_was_re);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var x_001 = is_node_valid(t) ? [0, value_exn(t[1], t[3][2])] : 0;
    return caml_call2(Core[466], sexp_of_a, x_001);
   }
   function remove(t, token){
    if(t !== token[3])
     return caml_call1(Core[5], cst_cannot_remove_from_a_diffe);
    var _h_ = 1 - caml_call1(is_empty, token[1]);
    if(_h_){
     if(is_node_valid(token)) remove_non_empty(t, token[1]);
     token[1] = caml_call1(empty, 0);
     var _i_ = 0;
    }
    else
     var _i_ = _h_;
    return _i_;
   }
   function add_removable(t, v){
    var node = add_node(t, v);
    return [0, node, id(node, t[2]), t];
   }
   function update(t, token, v){remove(t, token); return add_removable(t, v);}
   function find_elt(t, f){
    var nodes$2 = [0, t[3], 0], nodes = nodes$2;
    for(;;){
     if(! nodes) return 0;
     var nodes$0 = nodes[2], node = nodes[1];
     if(caml_call1(is_empty, node))
      nodes = nodes$0;
     else{
      if(caml_call1(f, value_exn(node, t[2])))
       return [0, [0, node, id(node, t[2]), t]];
      var
       _g_ = [0, child(node, t[2]), nodes$0],
       nodes$1 = [0, sibling(node, t[2]), _g_];
      nodes = nodes$1;
     }
    }
   }
   function value(t, heap){return value_exn(t, heap[2]);}
   var Elt = [0, value];
   function update$0(t, elt, v){
    remove_non_empty(t, elt);
    return add_node(t, v);
   }
   var Unsafe = [0, Elt, add_node, remove_non_empty, update$0];
   caml_call1(Ppx_inline_test_lib[6], cst_pairing_heap);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Pairing_heap);
   var
    Pairing_heap =
      [0,
       sexp_of_t,
       mem,
       length,
       is_empty$0,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       invariant,
       min_elt,
       max_elt,
       create$0,
       of_array,
       of_list,
       top,
       top_exn,
       add,
       remove_top,
       clear,
       pop,
       pop_exn,
       pop_if,
       copy,
       [0, sexp_of_t$0, value_exn$0],
       add_removable,
       remove,
       update,
       find_elt,
       Unsafe];
   runtime.caml_register_global(26, Pairing_heap, cst_Pairing_heap);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFpcmluZ19oZWFwLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwYWlyaW5nX2hlYXAuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9QYWlyaW5nX2hlYXAiLCJjc3RfcGFpcmluZ19oZWFwIiwiY3N0X3BhaXJpbmdfaGVhcF9zcmNfcGFpcmluZ19oIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDYiLCJhNCIsImE1IiwiZ2xvYmFsX2RhdGEiLCJDb3JlIiwiQ29yZV9BcnJheSIsIkNvcmVfTGlzdCIsIkFzc2VydF9mYWlsdXJlIiwiQ29yZV9PcHRpb24iLCJUdXBsZV9wb29sIiwiUHB4X21vZHVsZV90aW1lcl9ydW50aW1lIiwiUHB4X2JlbmNoX2xpYl9CZW5jaG1hcmtfYWNjdW11IiwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yIiwiUHB4X2lubGluZV90ZXN0X2xpYiIsIkNvcmVfSW50IiwiQmFzZV9Db250YWluZXIiLCJlbXB0eSIsImlzX2VtcHR5IiwiZXF1YWwiLCJkdW1teV9pZCIsImR1bW15IiwiY2hpbGQiLCJ0IiwicG9vbCIsInNpYmxpbmciLCJwcmV2IiwiaWQiLCJzZXRfY2hpbGQiLCJ2Iiwic2V0X3NpYmxpbmciLCJzZXRfcHJldiIsInZhbHVlX2V4biIsImFsbG9jYXRlIiwidmFsdWUiLCJmcmVlIiwiZGlzY29ubmVjdF9zaWJsaW5nIiwiZGlzY29ubmVjdF9jaGlsZCIsImRldGFjaCIsInJlbGF0aW9uX3RvX3ByZXYiLCJjcmVhdGUiLCJjYXBhY2l0eSIsImNzdF9IZWFwX3RvcF9leG5fY2FsbGVkX29uX2FuXyIsImludmFyaWFudCIsInBhcmFtIiwidG9fdmlzaXQiLCJtYXRjaCIsIm1heWJlX3BhcmVudF92YWx1ZSIsImV4cGVjdGVkX3ByZXYiLCJub2RlIiwidGhpc192YWx1ZSIsInBhcmVudF92YWx1ZSIsIm9wdCIsImNtcCIsIm1pbl9zaXplIiwiY29weSIsInN0YXJ0IiwibnVtX29mX2FsbG9jYXRlZF9ub2RlcyIsImNvcHlfbm9kZSIsIm5ld19ub2RlIiwibmV3X3N0YXJ0IiwicmVzdCIsIm5vZGVfdG9fY29weSIsInNsb3QiLCJub2RlX3RvX3VwZGF0ZSIsIm1lcmdlIiwicm9vdDEiLCJyb290MiIsImFkZF9jaGlsZCIsIm5ld19jaGlsZCIsImN1cnJlbnRfY2hpbGQiLCJ2MSIsInYyIiwidG9wX2V4biIsInRvcCIsImFkZF9ub2RlIiwiYWRkIiwibWF4X3N0YWNrX2RlcHRoIiwibG9vcCIsImRlcHRoIiwiaGVhZCIsIm5leHQxIiwibmV4dDIiLCJhY2MiLCJoIiwieHMiLCJoZWFwIiwicmVtb3ZlX25vbl9lbXB0eSIsIm1lcmdlZF9jaGlsZHJlbiIsIm5ld19yb290IiwicmVtb3ZlX3RvcCIsImNsZWFyIiwicG9wX2V4biIsInIiLCJwb3AiLCJwb3BfaWYiLCJmb2xkIiwiaW5pdCIsIml0ZXIiLCJsZW5ndGgiLCJDIiwibWVtIiwiZXhpc3RzIiwiZm9yX2FsbCIsImNvdW50Iiwic3VtIiwiZmluZCIsImZpbmRfbWFwIiwidG9fbGlzdCIsInRvX2FycmF5IiwibWluX2VsdCIsIm1heF9lbHQiLCJmb2xkX3Jlc3VsdCIsImZvbGRfdW50aWwiLCJjc3RfSGVhcF92YWx1ZV9leG5fbm9kZV93YXNfcmUiLCJjc3RfY2Fubm90X3JlbW92ZV9mcm9tX2FfZGlmZmUiLCJvZl9hcnJheSIsImFyciIsIm9mX2xpc3QiLCJsIiwic2V4cF9vZl90IiwiaXNfbm9kZV92YWxpZCIsInNleHBfb2ZfYSIsInhfMDAxIiwicmVtb3ZlIiwidG9rZW4iLCJhZGRfcmVtb3ZhYmxlIiwidXBkYXRlIiwiZmluZF9lbHQiLCJub2RlcyIsIkVsdCIsImVsdCIsIlVuc2FmZSIsIlBhaXJpbmdfaGVhcCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9jb3JlX2tlcm5lbC9wYWlyaW5nX2hlYXAvcGFpcmluZ19oZWFwLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLEdDQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyxNQUFBQyxHQUFBQztBQUFBQSxJQWtHc0Is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eUJBQTZCO0FBQUEsS0FDbEI7QUFBQSxlQUFhO0FBQUE7QUFBQTtBQUFBLGVBSFM7QUFBQTtBQUFBLEdBR1I7QUFBQSxZQUFBQyxjQUFBdkcsR0FBQU07QUFBQUEsUUFBQW9CLE9BSW5CO0FBQUEsSUFDcUIsbUNBQXlCO0FBQUEsR0FBRTtBQUFBLFlBQUE4RSxPQUFBeEcsR0FBQXNHLE9BQUFoRyxHQUkzRCxrQkFBYywwQkFDRztBQUFBLFlBQUFtRyxTQUFBekcsR0FBQTlCO0FBQUFBLFFBQUF3SSxVQWVMLGNBQUFBLFFBQUE7QUFBQTtBQUFBLEtBVlYsWUFDUTtBQUFBLFNBQUFBLFVBRFIsVUFBQWhGLE9BQUE7QUFBQSxLQUdLO0FBQUEsTUFDRTtBQUFBO0FBQUEsTUFDSyxHQUFGLGNBQUU7QUFBQSxPQUNnQyx3Q0FBeUI7QUFBQTtBQUFBLGFBRXJCO0FBQUEsT0FBQWdGLFVBQWxDO0FBQUEsTUFBOEI7QUFBQTtBQUFBO0FBQUEsR0FFZjtBQUFBLFlBQUEvRixNQUFBWCxHQUFBK0QsTUFRViw0QkFBZ0M7QUFBQSxPQUFBNEMsTUFSckQ7QUFBQSxZQUFBSCxTQUFBeEcsR0FBQTRHLEtBQUF0RztBQUFBQSxJQWVFO0FBQUEsSUFBWSxxQkFDSztBQUFBO0FBQUEsT0FBQXVHLFNBaEJuQjtBQUFBLEdBa0JDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURsbEJIIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBDb3JlXG5tb2R1bGUgUG9vbCA9IFR1cGxlX3Bvb2xcbm1vZHVsZSBQb2ludGVyID0gUG9vbC5Qb2ludGVyXG5cbigqIFRoaXMgcG9vbCBob2xkcyBub2RlcyB0aGF0IHdvdWxkIGJlIHJlcHJlc2VudGVkIG1vcmUgdHJhZGl0aW9uYWxseSBhczpcblxuICAge1tcbiAgICAgdHlwZSAnYSB0ID1cbiAgICAgICB8IEVtcHR5XG4gICAgICAgfCBIZWFwIG9mICdhICogJ2EgdCBsaXN0IF19XG5cbiAgIFdlIHdpbGwgcmVwcmVzZW50IHRoZW0gYXMgYSBsZWZ0LWNoaWxkLCByaWdodC1zaWJsaW5nIHRyZWUgaW4gYSB0cmlwbGV0XG4gICAodmFsdWUgKiBsZWZ0X2NoaWxkICogcmlnaHRfc2libGluZykuICBUaGUgbGVmdCBjaGlsZCBhbmQgYWxsIHJpZ2h0IHNpYmxpbmdzXG4gICBvZiB0aGUgbGVmdCBjaGlsZCBmb3JtIGEgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJoZWFwcyBvZiBhIGdpdmVuIGhlYXA6XG5cbiAgIHt2XG4gICAgICAgICBBXG4gICAgICAgIC9cbiAgICAgICBCIC0+IEMgLT4gRCAtPiBFIC0+IEZcbiAgICAgIC8gICAgICAgICAvICAgICAgICAgL1xuICAgICBHICAgICAgICAgSC0+SS0+SiAgIEstPkxcbiAgIHZ9ICopXG5cbm1vZHVsZSBOb2RlIDogc2lnXG4gICgqIEV4cG9zaW5nIFtwcml2YXRlIGludF0gaXMgYSBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudCwgYmVjYXVzZSBpdCBhbGxvd3NcbiAgICAgdGhlIGNvbXBpbGVyIHRvIHNraXAgdGhlIHdyaXRlIGJhcnJpZXIuICopXG5cbiAgdHlwZSAnYSB0ID0gcHJpdmF0ZSBpbnRcblxuICBtb2R1bGUgSWQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICAgIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gIGVuZFxuXG4gIG1vZHVsZSBQb29sIDogc2lnXG4gICAgdHlwZSAnYSBub2RlID0gJ2EgdFxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNyZWF0ZSA6IG1pbl9zaXplOmludCAtPiAnYSB0XG4gICAgdmFsIGlzX2Z1bGwgOiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgZ3JvdyA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSBub2RlIC0+ICdhIG5vZGUgKiAnYSB0XG4gIGVuZFxuXG4gICgqKiBbYWxsb2NhdGUgdiB+cG9vbF0gYWxsb2NhdGVzIGEgbmV3IG5vZGUgZnJvbSB0aGUgcG9vbCB3aXRoIG5vIGNoaWxkIG9yIHNpYmxpbmcgKilcbiAgdmFsIGFsbG9jYXRlIDogJ2EgLT4gcG9vbDonYSBQb29sLnQgLT4gaWQ6SWQudCAtPiAnYSB0XG5cbiAgKCoqIFtmcmVlIHQgfnBvb2xdIGZyZWVzIFt0XSBmb3IgcmV1c2UuICBJdCBpcyBhbiBlcnJvciB0byBhY2Nlc3MgW3RdIGFmdGVyIHRoaXMuICopXG4gIHZhbCBmcmVlIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiB1bml0XG5cbiAgKCoqIGEgc3BlY2lhbCBbdF0gdGhhdCByZXByZXNlbnRzIHRoZSBlbXB0eSBub2RlICopXG4gIHZhbCBlbXB0eSA6IHVuaXQgLT4gJ2EgdFxuXG4gIHZhbCBpc19lbXB0eSA6ICdhIHQgLT4gYm9vbFxuICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuXG4gICgqKiBbdmFsdWVfZXhuIHQgfnBvb2xdIHJldHVybiB0aGUgdmFsdWUgb2YgW3RdLCByYWlzZSBpZiBbaXNfZW1wdHkgdF0gKilcbiAgdmFsIHZhbHVlX2V4biA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2FcblxuICB2YWwgaWQgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IElkLnRcbiAgdmFsIGNoaWxkIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG4gIHZhbCBzaWJsaW5nIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIFtwcmV2IHRdIGlzIGVpdGhlciB0aGUgcGFyZW50IG9mIFt0XSBvciB0aGUgc2libGluZyBpbW1lZGlhdGVseSBsZWZ0IG9mIFt0XSAqKVxuICB2YWwgcHJldiA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBbYWRkX2NoaWxkIHQgfmNoaWxkIH5wb29sXSBBZGQgYSBjaGlsZCB0byBbdF0sIHByZXNlcnZpbmcgZXhpc3RpbmcgY2hpbGRyZW4gYXNcbiAgICAgIHNpYmxpbmdzIG9mIFtjaGlsZF0uIFt0XSBhbmQgW2NoaWxkXSBzaG91bGQgbm90IGJlIGVtcHR5IGFuZCBbY2hpbGRdIHNob3VsZCBoYXZlIG5vXG4gICAgICBzaWJsaW5nIGFuZCBoYXZlIG5vIHByZXYgbm9kZS4gKilcbiAgdmFsIGFkZF9jaGlsZCA6ICdhIHQgLT4gY2hpbGQ6J2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiB1bml0XG5cbiAgKCoqIGRpc2Nvbm5lY3QgYW5kIHJldHVybiB0aGUgc2libGluZyAqKVxuICB2YWwgZGlzY29ubmVjdF9zaWJsaW5nIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIGRpc2Nvbm5lY3QgYW5kIHJldHVybiB0aGUgY2hpbGQgKilcbiAgdmFsIGRpc2Nvbm5lY3RfY2hpbGQgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogW2RldGFjaCB0IH5wb29sXSByZW1vdmVzIFt0XSBmcm9tIHRoZSB0cmVlLCBhZGp1c3RpbmcgcG9pbnRlcnMgYXJvdW5kIGl0LiBBZnRlclxuICAgICAgW2RldGFjaF0sIFt0XSBpcyB0aGUgcm9vdCBvZiBhIHN0YW5kYWxvbmUgaGVhcCwgd2hpY2ggaXMgZGV0YWNoZWQgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgIGhlYXAuICopXG4gIHZhbCBkZXRhY2ggOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgSWQgPSBJbnRcblxuICBsZXQgZHVtbXlfaWQgOiBJZC50ID0gLTFcblxuICB0eXBlICdhIG5vZGUgPVxuICAgICgnYSwgJ2Egbm9kZSBQb2ludGVyLnQsICdhIG5vZGUgUG9pbnRlci50LCAnYSBub2RlIFBvaW50ZXIudCwgSWQudCkgUG9vbC5TbG90cy50NVxuXG4gIHR5cGUgJ2EgdCA9ICdhIG5vZGUgUG9pbnRlci50XG5cbiAgbGV0IGVtcHR5ID0gUG9pbnRlci5udWxsXG4gIGxldCBpc19lbXB0eSA9IFBvaW50ZXIuaXNfbnVsbFxuICBsZXQgZXF1YWwgPSBQb2ludGVyLnBoeXNfZXF1YWxcbiAgbGV0IHZhbHVlIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQwXG4gIGxldCBjaGlsZCB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50MVxuICBsZXQgc2libGluZyB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50MlxuICBsZXQgcHJldiB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50M1xuICBsZXQgaWQgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDRcblxuICAoKiBsZXQgc2V0X3ZhbHVlICAgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MCB2ICopXG4gIGxldCBzZXRfY2hpbGQgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MSB2XG4gIGxldCBzZXRfc2libGluZyB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQyIHZcbiAgbGV0IHNldF9wcmV2IHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDMgdlxuXG4gIGxldCB2YWx1ZV9leG4gdCB+cG9vbCA9XG4gICAgYXNzZXJ0IChub3QgKGlzX2VtcHR5IHQpKTtcbiAgICB2YWx1ZSB0IH5wb29sXG4gIDs7XG5cbiAgbGV0IGFsbG9jYXRlIHZhbHVlIH5wb29sIH5pZCA9IFBvb2wubmV3NSBwb29sIHZhbHVlIChlbXB0eSAoKSkgKGVtcHR5ICgpKSAoZW1wdHkgKCkpIGlkXG4gIGxldCBmcmVlIHQgfnBvb2wgPSBQb29sLnVuc2FmZV9mcmVlIHBvb2wgdFxuXG4gIGxldCBkaXNjb25uZWN0X3NpYmxpbmcgdCB+cG9vbCA9XG4gICAgbGV0IHNpYmxpbmcgPSBzaWJsaW5nIHQgfnBvb2wgaW5cbiAgICBpZiBub3QgKGlzX2VtcHR5IHNpYmxpbmcpXG4gICAgdGhlbiAoXG4gICAgICBzZXRfc2libGluZyB0IChlbXB0eSAoKSkgfnBvb2w7XG4gICAgICBzZXRfcHJldiBzaWJsaW5nIChlbXB0eSAoKSkgfnBvb2wpO1xuICAgIHNpYmxpbmdcbiAgOztcblxuICBsZXQgZGlzY29ubmVjdF9jaGlsZCB0IH5wb29sID1cbiAgICBsZXQgY2hpbGQgPSBjaGlsZCB0IH5wb29sIGluXG4gICAgaWYgbm90IChpc19lbXB0eSBjaGlsZClcbiAgICB0aGVuIChcbiAgICAgIHNldF9jaGlsZCB0IChlbXB0eSAoKSkgfnBvb2w7XG4gICAgICBzZXRfcHJldiBjaGlsZCAoZW1wdHkgKCkpIH5wb29sKTtcbiAgICBjaGlsZFxuICA7O1xuXG4gIGxldCBhZGRfY2hpbGQgdCB+Y2hpbGQ6bmV3X2NoaWxkIH5wb29sID1cbiAgICAoKiBhc3NlcnRpb25zIHdlIHdvdWxkIG1ha2UsIGJ1dCBmb3Igc3BlZWQ6XG4gICAgICAgYXNzZXJ0IChub3QgKGlzX2VtcHR5IHQpKTtcbiAgICAgICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgbmV3X2NoaWxkKSk7XG4gICAgICAgYXNzZXJ0IChpc19lbXB0eSAoc2libGluZyBuZXdfY2hpbGQgfnBvb2wpKTtcbiAgICAgICBhc3NlcnQgKGlzX2VtcHR5IChwcmV2IG5ld19jaGlsZCB+cG9vbCkpO1xuICAgICopXG4gICAgbGV0IGN1cnJlbnRfY2hpbGQgPSBkaXNjb25uZWN0X2NoaWxkIHQgfnBvb2wgaW5cbiAgICAoKiBhZGQgW25ld19jaGlsZF0gdG8gdGhlIGxpc3Qgb2YgW3RdJ3MgY2hpbGRyZW4gKHdoaWNoIG1heSBiZSBlbXB0eSkgKilcbiAgICBzZXRfc2libGluZyBuZXdfY2hpbGQgY3VycmVudF9jaGlsZCB+cG9vbDtcbiAgICBpZiBub3QgKGlzX2VtcHR5IGN1cnJlbnRfY2hpbGQpIHRoZW4gc2V0X3ByZXYgY3VycmVudF9jaGlsZCBuZXdfY2hpbGQgfnBvb2w7XG4gICAgc2V0X2NoaWxkIHQgbmV3X2NoaWxkIH5wb29sO1xuICAgIHNldF9wcmV2IG5ld19jaGlsZCB0IH5wb29sXG4gIDs7XG5cbiAgbGV0IGRldGFjaCB0IH5wb29sID1cbiAgICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gICAgdGhlbiAoXG4gICAgICBsZXQgcHJldiA9IHByZXYgdCB+cG9vbCBpblxuICAgICAgaWYgbm90IChpc19lbXB0eSBwcmV2KVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCByZWxhdGlvbl90b19wcmV2ID0gaWYgZXF1YWwgdCAoY2hpbGQgcHJldiB+cG9vbCkgdGhlbiBgY2hpbGQgZWxzZSBgc2libGluZyBpblxuICAgICAgICBzZXRfcHJldiB0IChlbXB0eSAoKSkgfnBvb2w7XG4gICAgICAgIGxldCBzaWJsaW5nID0gZGlzY29ubmVjdF9zaWJsaW5nIHQgfnBvb2wgaW5cbiAgICAgICAgKG1hdGNoIHJlbGF0aW9uX3RvX3ByZXYgd2l0aFxuICAgICAgICAgfCBgY2hpbGQgLT4gc2V0X2NoaWxkIHByZXYgc2libGluZyB+cG9vbFxuICAgICAgICAgfCBgc2libGluZyAtPiBzZXRfc2libGluZyBwcmV2IHNpYmxpbmcgfnBvb2wpO1xuICAgICAgICBpZiBub3QgKGlzX2VtcHR5IHNpYmxpbmcpIHRoZW4gc2V0X3ByZXYgc2libGluZyBwcmV2IH5wb29sKSlcbiAgOztcblxuICBtb2R1bGUgUG9vbCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIG5vZGUgUG9vbC50XG4gICAgdHlwZSBub25yZWMgJ2Egbm9kZSA9ICdhIG5vZGUgUG9pbnRlci50XG5cbiAgICBsZXQgY3JlYXRlICh0eXBlIGEpIH5taW5fc2l6ZTpjYXBhY2l0eSA6IGEgdCA9XG4gICAgICBQb29sLmNyZWF0ZVxuICAgICAgICBQb29sLlNsb3RzLnQ1XG4gICAgICAgIH5jYXBhY2l0eVxuICAgICAgICB+ZHVtbXk6XG4gICAgICAgICAgKCAoT2JqLm1hZ2ljIE5vbmUgOiBhKVxuICAgICAgICAgICwgUG9pbnRlci5udWxsICgpXG4gICAgICAgICAgLCBQb2ludGVyLm51bGwgKClcbiAgICAgICAgICAsIFBvaW50ZXIubnVsbCAoKVxuICAgICAgICAgICwgZHVtbXlfaWQgKVxuICAgIDs7XG5cbiAgICBsZXQgaXNfZnVsbCB0ID0gUG9vbC5pc19mdWxsIHRcbiAgICBsZXQgbGVuZ3RoIHQgPSBQb29sLmxlbmd0aCB0XG4gICAgbGV0IGdyb3cgdCA9IFBvb2wuZ3JvdyB0XG5cbiAgICBsZXQgY29weSB0IHN0YXJ0ID1cbiAgICAgIGxldCB0JyA9IGNyZWF0ZSB+bWluX3NpemU6KFBvb2wuY2FwYWNpdHkgdCkgaW5cbiAgICAgIGxldCBjb3B5X25vZGUgbm9kZSB0b192aXNpdCA9XG4gICAgICAgIGlmIGlzX2VtcHR5IG5vZGVcbiAgICAgICAgdGhlbiBlbXB0eSAoKSwgdG9fdmlzaXRcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogd2UgdXNlIHRoZSBzYW1lIGlkLCBidXQgdGhhdCdzIG9rIHNpbmNlIGlkcyBzaG91bGQgYmUgdW5pcXVlIHBlciBoZWFwICopXG4gICAgICAgICAgbGV0IG5ld19ub2RlID1cbiAgICAgICAgICAgIGFsbG9jYXRlICh2YWx1ZV9leG4gbm9kZSB+cG9vbDp0KSB+cG9vbDp0JyB+aWQ6KGlkIG5vZGUgfnBvb2w6dClcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCB0b192aXNpdCA9XG4gICAgICAgICAgICAobmV3X25vZGUsIGBjaGlsZCwgY2hpbGQgbm9kZSB+cG9vbDp0KVxuICAgICAgICAgICAgOjogKG5ld19ub2RlLCBgc2libGluZywgc2libGluZyBub2RlIH5wb29sOnQpXG4gICAgICAgICAgICA6OiB0b192aXNpdFxuICAgICAgICAgIGluXG4gICAgICAgICAgbmV3X25vZGUsIHRvX3Zpc2l0KVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgbG9vcCB0b192aXNpdCA9XG4gICAgICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IChub2RlX3RvX3VwZGF0ZSwgc2xvdCwgbm9kZV90b19jb3B5KSA6OiByZXN0IC0+XG4gICAgICAgICAgbGV0IG5ld19ub2RlLCB0b192aXNpdCA9IGNvcHlfbm9kZSBub2RlX3RvX2NvcHkgcmVzdCBpblxuICAgICAgICAgIChtYXRjaCBzbG90IHdpdGhcbiAgICAgICAgICAgfCBgY2hpbGQgLT4gc2V0X2NoaWxkIG5vZGVfdG9fdXBkYXRlIG5ld19ub2RlIH5wb29sOnQnXG4gICAgICAgICAgIHwgYHNpYmxpbmcgLT4gc2V0X3NpYmxpbmcgbm9kZV90b191cGRhdGUgbmV3X25vZGUgfnBvb2w6dCcpO1xuICAgICAgICAgIGlmIG5vdCAoaXNfZW1wdHkgbmV3X25vZGUpIHRoZW4gc2V0X3ByZXYgbmV3X25vZGUgbm9kZV90b191cGRhdGUgfnBvb2w6dCc7XG4gICAgICAgICAgbG9vcCB0b192aXNpdFxuICAgICAgaW5cbiAgICAgIGxldCBuZXdfc3RhcnQsIHRvX3Zpc2l0ID0gY29weV9ub2RlIHN0YXJ0IFtdIGluXG4gICAgICBsb29wIHRvX3Zpc2l0O1xuICAgICAgbmV3X3N0YXJ0LCB0J1xuICAgIDs7XG4gIGVuZFxuZW5kXG5cbnR5cGUgJ2EgdCA9XG4gIHsgKCogY21wIGlzIHBsYWNlZCBmaXJzdCB0byBzaG9ydC1jaXJjdWl0IHBvbHltb3JwaGljIGNvbXBhcmUgKilcbiAgICBjbXAgOiAnYSAtPiAnYSAtPiBpbnRcbiAgOyBtdXRhYmxlIHBvb2wgOiAnYSBOb2RlLlBvb2wudFxuICA7ICgqIGludmFyaWFudDogIFtyb290XSBuZXZlciBoYXMgYSBzaWJsaW5nICopXG4gICAgbXV0YWJsZSByb290IDogJ2EgTm9kZS50XG4gIDsgbXV0YWJsZSBudW1fb2ZfYWxsb2NhdGVkX25vZGVzIDogaW50XG4gIH1cblxubGV0IGludmFyaWFudCBfIHQgPVxuICBsZXQgcmVjIGxvb3AgdG9fdmlzaXQgPVxuICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICB8IFtdIC0+ICgpXG4gICAgfCAobm9kZSwgZXhwZWN0ZWRfcHJldiwgbWF5YmVfcGFyZW50X3ZhbHVlKSA6OiByZXN0IC0+XG4gICAgICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgbm9kZSlcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgdGhpc192YWx1ZSA9IE5vZGUudmFsdWVfZXhuIG5vZGUgfnBvb2w6dC5wb29sIGluXG4gICAgICAgIGFzc2VydCAoTm9kZS5lcXVhbCAoTm9kZS5wcmV2IG5vZGUgfnBvb2w6dC5wb29sKSBleHBlY3RlZF9wcmV2KTtcbiAgICAgICAgT3B0aW9uLml0ZXIgbWF5YmVfcGFyZW50X3ZhbHVlIH5mOihmdW4gcGFyZW50X3ZhbHVlIC0+XG4gICAgICAgICAgYXNzZXJ0ICh0LmNtcCBwYXJlbnRfdmFsdWUgdGhpc192YWx1ZSA8PSAwKSk7XG4gICAgICAgIGxvb3BcbiAgICAgICAgICAoKE5vZGUuY2hpbGQgbm9kZSB+cG9vbDp0LnBvb2wsIG5vZGUsIFNvbWUgdGhpc192YWx1ZSlcbiAgICAgICAgICAgOjogKE5vZGUuc2libGluZyBub2RlIH5wb29sOnQucG9vbCwgbm9kZSwgbWF5YmVfcGFyZW50X3ZhbHVlKVxuICAgICAgICAgICA6OiByZXN0KSlcbiAgICAgIGVsc2UgbG9vcCByZXN0XG4gIGluXG4gIGFzc2VydCAoTm9kZS5pc19lbXB0eSB0LnJvb3QgfHwgTm9kZS5pc19lbXB0eSAoTm9kZS5zaWJsaW5nIHQucm9vdCB+cG9vbDp0LnBvb2wpKTtcbiAgbG9vcCBbIHQucm9vdCwgTm9kZS5lbXB0eSAoKSwgTm9uZSBdXG47O1xuXG5sZXQgY3JlYXRlID8obWluX3NpemUgPSAxKSB+Y21wICgpID1cbiAgeyBjbXBcbiAgOyBwb29sID0gTm9kZS5Qb29sLmNyZWF0ZSB+bWluX3NpemVcbiAgOyByb290ID0gTm9kZS5lbXB0eSAoKVxuICA7IG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgPSAwXG4gIH1cbjs7XG5cbmxldCBjb3B5IHsgY21wOyBwb29sOyByb290OyBudW1fb2ZfYWxsb2NhdGVkX25vZGVzIH0gPVxuICBsZXQgcm9vdCwgcG9vbCA9IE5vZGUuUG9vbC5jb3B5IHBvb2wgcm9vdCBpblxuICB7IGNtcDsgcG9vbDsgcm9vdDsgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyB9XG47O1xuXG5sZXQgYWxsb2NhdGUgdCB2ID1cbiAgaWYgTm9kZS5Qb29sLmlzX2Z1bGwgdC5wb29sIHRoZW4gdC5wb29sIDwtIE5vZGUuUG9vbC5ncm93IHQucG9vbDtcbiAgdC5udW1fb2ZfYWxsb2NhdGVkX25vZGVzIDwtIHQubnVtX29mX2FsbG9jYXRlZF9ub2RlcyArIDE7XG4gIE5vZGUuYWxsb2NhdGUgdiB+cG9vbDp0LnBvb2wgfmlkOihOb2RlLklkLm9mX2ludCB0Lm51bV9vZl9hbGxvY2F0ZWRfbm9kZXMpXG47O1xuXG4oKiB0cmFuc2xhdGlvbjpcbiAgIHtbXG4gICAgIG1hdGNoIHJvb3QxLCByb290MiB3aXRoXG4gICAgIHwgTm9uZSwgaCB8IGgsIE5vbmUgLT4gaFxuICAgICB8IFNvbWUgKE5vZGUgKHYxLCBjaGlsZHJlbjEpKSwgU29tZSAoTm9kZSAodjIsIGNoaWxkcmVuMikpIC0+XG4gICAgICAgaWYgdjEgPCB2MlxuICAgICAgIHRoZW4gU29tZSAoTm9kZSAodjEsIHJvb3QyIDo6IGNoaWxkcmVuMSkpXG4gICAgICAgZWxzZSBTb21lIChOb2RlICh2Miwgcm9vdDEgOjogY2hpbGRyZW4yKSlcbiAgIF19XG5cbiAgIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBuZWl0aGVyIHJvb3QgaGFzIGEgcHJldiBub2RlICh1c3VhbGx5IGJlY2F1c2UgdGhlIGlucHV0cyBjb21lXG4gICBmcm9tIFtkaXNjb25uZWN0XypdIG9yIGFyZSB0aGUgdG9wIG9mIHRoZSBoZWFwIG9yIGFyZSB0aGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24pLiAqKVxubGV0IG1lcmdlIHQgcm9vdDEgcm9vdDIgPVxuICBpZiBOb2RlLmlzX2VtcHR5IHJvb3QxXG4gIHRoZW4gcm9vdDJcbiAgZWxzZSBpZiBOb2RlLmlzX2VtcHR5IHJvb3QyXG4gIHRoZW4gcm9vdDFcbiAgZWxzZSAoXG4gICAgbGV0IGFkZF9jaGlsZCB0IG5vZGUgfmNoaWxkID1cbiAgICAgIE5vZGUuYWRkX2NoaWxkIG5vZGUgfnBvb2w6dC5wb29sIH5jaGlsZDtcbiAgICAgIG5vZGVcbiAgICBpblxuICAgIGxldCB2MSA9IE5vZGUudmFsdWVfZXhuIHJvb3QxIH5wb29sOnQucG9vbCBpblxuICAgIGxldCB2MiA9IE5vZGUudmFsdWVfZXhuIHJvb3QyIH5wb29sOnQucG9vbCBpblxuICAgIGlmIHQuY21wIHYxIHYyIDwgMFxuICAgIHRoZW4gYWRkX2NoaWxkIHQgcm9vdDEgfmNoaWxkOnJvb3QyXG4gICAgZWxzZSBhZGRfY2hpbGQgdCByb290MiB+Y2hpbGQ6cm9vdDEpXG47O1xuXG5sZXQgdG9wX2V4biB0ID1cbiAgaWYgTm9kZS5pc19lbXB0eSB0LnJvb3RcbiAgdGhlbiBmYWlsd2l0aCBcIkhlYXAudG9wX2V4biBjYWxsZWQgb24gYW4gZW1wdHkgaGVhcFwiXG4gIGVsc2UgTm9kZS52YWx1ZV9leG4gdC5yb290IH5wb29sOnQucG9vbFxuOztcblxubGV0IHRvcCB0ID0gaWYgTm9kZS5pc19lbXB0eSB0LnJvb3QgdGhlbiBOb25lIGVsc2UgU29tZSAodG9wX2V4biB0KVxuXG5sZXQgYWRkX25vZGUgdCB2ID1cbiAgbGV0IG5vZGUgPSBhbGxvY2F0ZSB0IHYgaW5cbiAgdC5yb290IDwtIG1lcmdlIHQgdC5yb290IG5vZGU7XG4gIG5vZGVcbjs7XG5cbmxldCBhZGQgdCB2ID0gaWdub3JlIChhZGRfbm9kZSB0IHYgOiBfIE5vZGUudClcblxuKCogW21lcmdlX3BhaXJzXSB0YWtlcyBhIGxpc3Qgb2YgaGVhcCByb290cyBhbmQgbWVyZ2VzIGNvbnNlY3V0aXZlIHBhaXJzLCByZWR1Y2luZyB0aGVcbiAgIGxpc3Qgb2YgbGVuZ3RoIG4gdG8gbi8yLiAgVGhlbiBpdCBtZXJnZXMgdGhlIG1lcmdlZCBwYWlycyBpbnRvIGEgc2luZ2xlIGhlYXAuICBPbmVcbiAgIGludHVpdGlvbiBpcyB0aGF0IHRoaXMgaXMgc29tZXdoYXQgbGlrZSBidWlsZGluZyBhIHNpbmdsZSBsZXZlbCBvZiBhIGJpbmFyeSB0cmVlLlxuXG4gICBUaGUgb3V0cHV0IGhlYXAgZG9lcyBub3QgY29udGFpbiB0aGUgdmFsdWUgdGhhdCB3YXMgYXQgdGhlIHJvb3Qgb2YgdGhlIGlucHV0IGhlYXAuXG5cbiAgIFdlIGJyZWFrIHRoZSBmdW5jdGlvbiBpbnRvIHR3byBwYXJ0cy4gIEEgZmlyc3Qgc3RhZ2UgdGhhdCBpcyB3aWxsaW5nIHRvIHVzZSBsaW1pdGVkXG4gICBzdGFjayBpbnN0ZWFkIG9mIGhlYXAgYWxsb2NhdGlvbiBmb3IgYm9va2tlZXBpbmcsIGFuZCBhIHNlY29uZCBzdGFnZSB0aGF0IHNoaWZ0cyB0b1xuICAgdXNpbmcgYSBsaXN0IGFzIGFuIGFjY3VtdWxhdG9yIGlmIHdlIGdvIHRvbyBkZWVwLlxuXG4gICBUaGlzIGNhbiBiZSBtYWRlIHRhaWwgcmVjdXJzaXZlIGFuZCBub24tYWxsb2NhdGluZyBieSBzdGFydGluZyB3aXRoIGFuIGVtcHR5IGhlYXAgYW5kXG4gICBtZXJnaW5nIG1lcmdlZCBwYWlycyBpbnRvIGl0LiBVbmZvcnR1bmF0ZWx5IHRoaXMgXCJsZWZ0IGZvbGRcIiB2ZXJzaW9uIGlzIG5vdCB3aGF0IGlzXG4gICBkZXNjcmliZWQgaW4gdGhlIG9yaWdpbmFsIHBhcGVyIGJ5IEZyZWRtYW4gZXQgYWwuOyB0aGV5IHNwZWNpZmljYWxseSBzYXkgdGhhdFxuICAgY2hpbGRyZW4gc2hvdWxkIGJlIG1lcmdlZCB0b2dldGhlciBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpc3QgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgIGxpc3QuIChbbWVyZ2VdIGlzIG5vdCBhc3NvY2lhdGl2ZSwgc28gb3JkZXIgbWF0dGVycy4pXG4qKVxuKCogdHJhbnNsYXRpb246XG4gICB7W1xuICAgICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICAgICB8IFtdIC0+IGFjY1xuICAgICAgIHwgW2hlYWRdIC0+IGhlYWQgOjogYWNjXG4gICAgICAgfCBoZWFkIDo6IG5leHQxIDo6IG5leHQyIC0+IGxvb3AgKG1lcmdlIGhlYWQgbmV4dDEgOjogYWNjKSBuZXh0MlxuICAgICBpblxuICAgICBtYXRjaCBsb29wIFtdIGNoaWxkcmVuIHdpdGhcbiAgICAgfCBbXSAtPiBOb25lXG4gICAgIHwgW2hdIC0+IFNvbWUgaFxuICAgICB8IHggOjogeHMgLT4gU29tZSAoTGlzdC5mb2xkIHhzIH5pbml0OnggfmY6bWVyZ2UpXG4gICBdfVxuKilcbmxldCBhbGxvY2F0aW5nX21lcmdlX3BhaXJzIHQgaGVhZCA9XG4gIGxldCByZWMgbG9vcCBhY2MgaGVhZCA9XG4gICAgaWYgTm9kZS5pc19lbXB0eSBoZWFkXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIChcbiAgICAgIGxldCBuZXh0MSA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIGhlYWQgfnBvb2w6dC5wb29sIGluXG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5leHQxXG4gICAgICB0aGVuIGhlYWQgOjogYWNjXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG5leHQyID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgbmV4dDEgfnBvb2w6dC5wb29sIGluXG4gICAgICAgIGxvb3AgKG1lcmdlIHQgaGVhZCBuZXh0MSA6OiBhY2MpIG5leHQyKSlcbiAgaW5cbiAgbWF0Y2ggbG9vcCBbXSBoZWFkIHdpdGhcbiAgfCBbXSAtPiBOb2RlLmVtcHR5ICgpXG4gIHwgWyBoIF0gLT4gaFxuICB8IHggOjogeHMgLT4gTGlzdC5mb2xkIHhzIH5pbml0OnggfmY6KGZ1biBhY2MgaGVhcCAtPiBtZXJnZSB0IGFjYyBoZWFwKVxuOztcblxuKCogdHJhbnNsYXRpb246XG4gICB7W1xuICAgICBtYXRjaCB0LnJvb3Qgd2l0aFxuICAgICB8IE5vZGUgKF8sIGNoaWxkcmVuKSAtPlxuICAgICAgIGxldCByZWMgbG9vcCBkZXB0aCBjaGlsZHJlbiA9XG4gICAgICAgICBpZiBkZXB0aCA+PSBtYXhfc3RhY2tfZGVwdGhcbiAgICAgICAgIHRoZW4gYWxsb2NhdGluZ19tZXJnZV9wYWlycyB0IGNoaWxkZW5cbiAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgbWF0Y2ggY2hpbGRyZW4gd2l0aFxuICAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICAgfCBbaGVhZF0gLT4gU29tZSBoZWFkXG4gICAgICAgICAgIHwgaGVhZCA6OiBuZXh0MSA6OiBuZXh0MiAtPlxuICAgICAgICAgICAgIG1lcmdlIChtZXJnZSBoZWFkIG5leHQxKSAobG9vcCAoZGVwdGggKyAxKSBuZXh0MilcbiAgICAgICAgIGVuZFxuICAgICAgIGluXG4gICAgICAgbG9vcCAwIGNoaWxkcmVuXG4gICBdfVxuKilcbmxldCBtZXJnZV9wYWlycyA9XG4gIGxldCBtYXhfc3RhY2tfZGVwdGggPSAxXzAwMCBpblxuICBsZXQgcmVjIGxvb3AgdCBkZXB0aCBoZWFkID1cbiAgICBpZiBkZXB0aCA+PSBtYXhfc3RhY2tfZGVwdGhcbiAgICB0aGVuIGFsbG9jYXRpbmdfbWVyZ2VfcGFpcnMgdCBoZWFkXG4gICAgZWxzZSBpZiBOb2RlLmlzX2VtcHR5IGhlYWRcbiAgICB0aGVuIGhlYWRcbiAgICBlbHNlIChcbiAgICAgIGxldCBuZXh0MSA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIGhlYWQgfnBvb2w6dC5wb29sIGluXG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5leHQxXG4gICAgICB0aGVuIGhlYWRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV4dDIgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBuZXh0MSB+cG9vbDp0LnBvb2wgaW5cbiAgICAgICAgKCogbWVyZ2UgdGhlIGZpcnN0IHR3byBub2RlcyBpbiBvdXIgbGlzdCwgYW5kIHRoZW4gbWVyZ2UgdGhlIHJlc3VsdCB3aXRoIHRoZVxuICAgICAgICAgICByZXN1bHQgb2YgcmVjdXJzaXZlbHkgY2FsbGluZyBtZXJnZV9wYWlycyBvbiB0aGUgdGFpbCAqKVxuICAgICAgICBtZXJnZSB0IChtZXJnZSB0IGhlYWQgbmV4dDEpIChsb29wIHQgKGRlcHRoICsgMSkgbmV4dDIpKSlcbiAgaW5cbiAgZnVuIHQgaGVhZCAtPiBsb29wIHQgMCBoZWFkXG47O1xuXG5sZXQgcmVtb3ZlX25vbl9lbXB0eSB0IG5vZGUgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBOb2RlLmRldGFjaCBub2RlIH5wb29sO1xuICBsZXQgbWVyZ2VkX2NoaWxkcmVuID0gbWVyZ2VfcGFpcnMgdCAoTm9kZS5kaXNjb25uZWN0X2NoaWxkIG5vZGUgfnBvb2wpIGluXG4gIGxldCBuZXdfcm9vdCA9XG4gICAgaWYgTm9kZS5lcXVhbCB0LnJvb3Qgbm9kZSB0aGVuIG1lcmdlZF9jaGlsZHJlbiBlbHNlIG1lcmdlIHQgdC5yb290IG1lcmdlZF9jaGlsZHJlblxuICBpblxuICBOb2RlLmZyZWUgbm9kZSB+cG9vbDtcbiAgdC5yb290IDwtIG5ld19yb290XG47O1xuXG5sZXQgcmVtb3ZlX3RvcCB0ID0gaWYgbm90IChOb2RlLmlzX2VtcHR5IHQucm9vdCkgdGhlbiByZW1vdmVfbm9uX2VtcHR5IHQgdC5yb290XG5cbigqIE5vdGUgdGhhdCB0aGlzIGlzIHRhaWwtcmVjdXJzaXZlIGFuZCB0aGF0IGVhY2ggbm9kZSBpcyB2aXNpdGVkIGF0IG1vc3QgMyB0aW1lcyAob25jZVxuICAgZm9yIGVhY2ggYnJhbmNoIG9mIHRoZSBcImlmXCIpLCBzbyBpdCB0YWtlcyBsaW5lYXIgdGltZSBhbmQgY29uc3RhbnQgc3BhY2UuICopXG5sZXQgcmVjIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IG5vZGUgfnBvb2wgPVxuICBsZXQgY2hpbGQgPSBOb2RlLmNoaWxkIG5vZGUgfnBvb2wgaW5cbiAgbGV0IHNpYmxpbmcgPSBOb2RlLnNpYmxpbmcgbm9kZSB+cG9vbCBpblxuICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgY2hpbGQpXG4gIHRoZW4gcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgY2hpbGQgfnBvb2xcbiAgZWxzZSBpZiBub3QgKE5vZGUuaXNfZW1wdHkgc2libGluZylcbiAgdGhlbiByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBzaWJsaW5nIH5wb29sXG4gIGVsc2UgKFxuICAgIGxldCBwcmV2ID0gTm9kZS5wcmV2IG5vZGUgfnBvb2wgaW5cbiAgICBOb2RlLmRldGFjaCBub2RlIH5wb29sO1xuICAgIE5vZGUuZnJlZSBub2RlIH5wb29sO1xuICAgIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBwcmV2KSB0aGVuIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IHByZXYgfnBvb2wpXG47O1xuXG5sZXQgY2xlYXIgdCA9XG4gIGlmIG5vdCAoTm9kZS5pc19lbXB0eSB0LnJvb3QpXG4gIHRoZW4gKFxuICAgIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IHQucm9vdCB+cG9vbDp0LnBvb2w7XG4gICAgdC5yb290IDwtIE5vZGUuZW1wdHkgKCkpXG47O1xuXG5sZXQgcG9wX2V4biB0ID1cbiAgbGV0IHIgPSB0b3BfZXhuIHQgaW5cbiAgcmVtb3ZlX3RvcCB0O1xuICByXG47O1xuXG5sZXQgcG9wIHQgPSBpZiBOb2RlLmlzX2VtcHR5IHQucm9vdCB0aGVuIE5vbmUgZWxzZSBTb21lIChwb3BfZXhuIHQpXG5cbmxldCBwb3BfaWYgdCBmID1cbiAgbWF0Y2ggdG9wIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgdiAtPlxuICAgIGlmIGYgdlxuICAgIHRoZW4gKFxuICAgICAgcmVtb3ZlX3RvcCB0O1xuICAgICAgU29tZSB2KVxuICAgIGVsc2UgTm9uZVxuOztcblxuKCogcGFpcmluZyBoZWFwcyBhcmUgbm90IGJhbGFuY2VkIHRyZWVzLCBhbmQgdGhlcmVmb3JlIHdlIGNhbid0IHJlbHkgb24gYSBiYWxhbmNlXG4gICBwcm9wZXJ0eSB0byBzdG9wIG91cnNlbHZlcyBmcm9tIG92ZXJmbG93aW5nIHRoZSBzdGFjay4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBsZXQgcmVjIGxvb3AgYWNjIHRvX3Zpc2l0ID1cbiAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IG5vZGUgOjogcmVzdCAtPlxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBub2RlXG4gICAgICB0aGVuIGxvb3AgYWNjIHJlc3RcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdG9fdmlzaXQgPSBOb2RlLnNpYmxpbmcgfnBvb2wgbm9kZSA6OiBOb2RlLmNoaWxkIH5wb29sIG5vZGUgOjogcmVzdCBpblxuICAgICAgICBsb29wIChmIGFjYyAoTm9kZS52YWx1ZV9leG4gfnBvb2wgbm9kZSkpIHRvX3Zpc2l0KVxuICBpblxuICBsb29wIGluaXQgWyB0LnJvb3QgXSBbQG5vbnRhaWxdXG47O1xuXG4oKiBhbG1vc3QgaWRlbnRpY2FsIHRvIGZvbGQsIGNvcGllZCBmb3Igc3BlZWQgcHVycG9zZXMgKilcbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBsZXQgcmVjIGxvb3AgdG9fdmlzaXQgPVxuICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICB8IFtdIC0+ICgpXG4gICAgfCBub2RlIDo6IHJlc3QgLT5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbm9kZVxuICAgICAgdGhlbiBsb29wIHJlc3RcbiAgICAgIGVsc2UgKFxuICAgICAgICBmIChOb2RlLnZhbHVlX2V4biB+cG9vbCBub2RlKTtcbiAgICAgICAgbGV0IHRvX3Zpc2l0ID0gTm9kZS5zaWJsaW5nIH5wb29sIG5vZGUgOjogTm9kZS5jaGlsZCB+cG9vbCBub2RlIDo6IHJlc3QgaW5cbiAgICAgICAgbG9vcCB0b192aXNpdClcbiAgaW5cbiAgbG9vcCBbIHQucm9vdCBdIFtAbm9udGFpbF1cbjs7XG5cbmxldCBsZW5ndGggdCA9IE5vZGUuUG9vbC5sZW5ndGggdC5wb29sXG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBpc19lbXB0eSB0ID0gTm9kZS5pc19lbXB0eSB0LnJvb3RcbmxldCBtZW0gPSBDLm1lbVxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCB0b19hcnJheSA9IEMudG9fYXJyYXlcbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcblxubGV0IG9mX2FycmF5IGFyciB+Y21wID1cbiAgbGV0IHQgPSBjcmVhdGUgfm1pbl9zaXplOihBcnJheS5sZW5ndGggYXJyKSB+Y21wICgpIGluXG4gIEFycmF5Lml0ZXIgYXJyIH5mOihmdW4gdiAtPiBhZGQgdCB2KTtcbiAgdFxuOztcblxubGV0IG9mX2xpc3QgbCB+Y21wID0gb2ZfYXJyYXkgKEFycmF5Lm9mX2xpc3QgbCkgfmNtcFxubGV0IHNleHBfb2ZfdCBmIHQgPSBBcnJheS5zZXhwX29mX3QgZiAodG9fYXJyYXkgdCB8PiBBcnJheS5zb3J0ZWRfY29weSB+Y29tcGFyZTp0LmNtcClcblxubW9kdWxlIEVsdCA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID1cbiAgICB7IG11dGFibGUgbm9kZSA6ICdhIE5vZGUudFxuICAgIDsgbm9kZV9pZCA6IE5vZGUuSWQudFxuICAgIDsgaGVhcCA6ICdhIHRcbiAgICB9XG5cbiAgKCogSWYgaWRzIGFyZSBkaWZmZXJlbnQsIGl0IG1lYW5zIHRoYXQgdGhlIG5vZGUgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGJ5IHNvbWVcbiAgICAgb3RoZXIgbWVhbnMgKGFuZCBwb3NzaWJseSByZXVzZWQpLiAqKVxuICBsZXQgaXNfbm9kZV92YWxpZCB0ID0gTm9kZS5JZC5lcXVhbCAoTm9kZS5pZCB+cG9vbDp0LmhlYXAucG9vbCB0Lm5vZGUpIHQubm9kZV9pZFxuXG4gIGxldCB2YWx1ZSB0ID1cbiAgICBpZiBpc19ub2RlX3ZhbGlkIHQgdGhlbiBTb21lIChOb2RlLnZhbHVlX2V4biB0Lm5vZGUgfnBvb2w6dC5oZWFwLnBvb2wpIGVsc2UgTm9uZVxuICA7O1xuXG4gIGxldCB2YWx1ZV9leG4gdCA9XG4gICAgaWYgaXNfbm9kZV92YWxpZCB0XG4gICAgdGhlbiBOb2RlLnZhbHVlX2V4biB0Lm5vZGUgfnBvb2w6dC5oZWFwLnBvb2xcbiAgICBlbHNlIGZhaWx3aXRoIFwiSGVhcC52YWx1ZV9leG46IG5vZGUgd2FzIHJlbW92ZWQgZnJvbSB0aGUgaGVhcFwiXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IFslc2V4cCAodmFsdWUgdCA6IGEgb3B0aW9uKV1cbmVuZFxuXG5sZXQgcmVtb3ZlIHQgKHRva2VuIDogXyBFbHQudCkgPVxuICBpZiBub3QgKHBoeXNfZXF1YWwgdCB0b2tlbi5oZWFwKVxuICB0aGVuIGZhaWx3aXRoIFwiY2Fubm90IHJlbW92ZSBmcm9tIGEgZGlmZmVyZW50IGhlYXBcIlxuICBlbHNlIGlmIG5vdCAoTm9kZS5pc19lbXB0eSB0b2tlbi5ub2RlKVxuICB0aGVuIChcbiAgICBpZiBFbHQuaXNfbm9kZV92YWxpZCB0b2tlbiB0aGVuIHJlbW92ZV9ub25fZW1wdHkgdCB0b2tlbi5ub2RlO1xuICAgIHRva2VuLm5vZGUgPC0gTm9kZS5lbXB0eSAoKSlcbjs7XG5cbmxldCBhZGRfcmVtb3ZhYmxlIHQgdiA9XG4gIGxldCBub2RlID0gYWRkX25vZGUgdCB2IGluXG4gIHsgRWx0Lm5vZGU7IGhlYXAgPSB0OyBub2RlX2lkID0gTm9kZS5pZCB+cG9vbDp0LnBvb2wgbm9kZSB9XG47O1xuXG5sZXQgdXBkYXRlIHQgdG9rZW4gdiA9XG4gIHJlbW92ZSB0IHRva2VuO1xuICBhZGRfcmVtb3ZhYmxlIHQgdlxuOztcblxubGV0IGZpbmRfZWx0ID1cbiAgbGV0IHJlYyBsb29wIHQgZiBub2RlcyA9XG4gICAgbWF0Y2ggbm9kZXMgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgbm9kZSA6OiByZXN0IC0+XG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5vZGVcbiAgICAgIHRoZW4gbG9vcCB0IGYgcmVzdFxuICAgICAgZWxzZSBpZiBmIChOb2RlLnZhbHVlX2V4biBub2RlIH5wb29sOnQucG9vbClcbiAgICAgIHRoZW4gU29tZSB7IEVsdC5ub2RlOyBoZWFwID0gdDsgbm9kZV9pZCA9IE5vZGUuaWQgfnBvb2w6dC5wb29sIG5vZGUgfVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIHQgZiAoTm9kZS5zaWJsaW5nIG5vZGUgfnBvb2w6dC5wb29sIDo6IE5vZGUuY2hpbGQgbm9kZSB+cG9vbDp0LnBvb2wgOjogcmVzdClcbiAgaW5cbiAgZnVuIHQgfmYgLT4gbG9vcCB0IGYgWyB0LnJvb3QgXVxuOztcblxubW9kdWxlIFVuc2FmZSA9IHN0cnVjdFxuICBtb2R1bGUgRWx0ID0gc3RydWN0XG4gICAgdHlwZSAnYSBoZWFwID0gJ2EgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIE5vZGUudFxuXG4gICAgbGV0IHZhbHVlIHQgaGVhcCA9IE5vZGUudmFsdWVfZXhuIH5wb29sOmhlYXAucG9vbCB0XG4gIGVuZFxuXG4gIGxldCBhZGRfcmVtb3ZhYmxlID0gYWRkX25vZGVcbiAgbGV0IHJlbW92ZSA9IHJlbW92ZV9ub25fZW1wdHlcblxuICBsZXQgdXBkYXRlIHQgZWx0IHYgPVxuICAgIHJlbW92ZSB0IGVsdDtcbiAgICBhZGRfcmVtb3ZhYmxlIHQgdlxuICA7O1xuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
