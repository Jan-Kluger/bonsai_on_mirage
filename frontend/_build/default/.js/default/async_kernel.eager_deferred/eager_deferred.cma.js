// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Eager_deferred__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Eager_deferred = [0];
   runtime.caml_register_global(0, Eager_deferred, "Eager_deferred__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred__Import
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Eager_deferred_Import = [0];
   runtime.caml_register_global
    (0, Eager_deferred_Import, "Eager_deferred__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred__Eager_deferred0
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Throttle, Base__Monad, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Eager_deferred_Eager_defer = "Eager_deferred__Eager_deferred0",
    cst_eager_deferred = "eager_deferred";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Eager_deferred_Eager_defer);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_eager_deferred);
   caml_call1
    (Expect_test_collector[6][1], "eager_deferred/src/eager_deferred0.ml");
   caml_call2
    (Ppx_inline_test_lib[5], cst_eager_deferred, "eager_deferred0.ml");
   var
    sexp_of_t = Async_kernel_Deferred[1],
    return$0 = Async_kernel_Deferred[12];
   function bind(t, f){
    return caml_call1(Async_kernel_Deferred[7], t)
            ? caml_call1(f, caml_call1(Async_kernel_Deferred[6], t))
            : caml_call2(Async_kernel_Deferred[11], t, f);
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return caml_call1(Async_kernel_Deferred[7], t)
                ? caml_call1
                  (return$0,
                   caml_call1(f, caml_call1(Async_kernel_Deferred[6], t)))
                : caml_call2(Async_kernel_Deferred[13], t, f);
       }],
    T = [0, sexp_of_t, return$0, bind, map],
    sexp_of_t$0 = T[1],
    include = caml_call1(Base_Monad[1], [0, T[3], T[2], T[4]]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    all = include[9],
    Let_syntax = include[11],
    create = Async_kernel_Deferred[3],
    don_t_wait_for = Async_kernel_Deferred[25],
    invariant = Async_kernel_Deferred[2],
    is_determined = Async_kernel_Deferred[7],
    never = Async_kernel_Deferred[19],
    peek = Async_kernel_Deferred[5],
    unit = Async_kernel_Deferred[18],
    value_exn = Async_kernel_Deferred[6];
   function upon(t, f){
    return caml_call1(is_determined, t)
            ? caml_call1(f, caml_call1(value_exn, t))
            : caml_call2(Async_kernel_Deferred[4], t, f);
   }
   function both(t1, t2){
    return caml_call1
            (create,
             function(result){
              function f(a1){
               function f(a2){
                return caml_call2(Async_kernel_Ivar[14], result, [0, a1, a2]);
               }
               return caml_call1(is_determined, t2)
                       ? f(caml_call1(value_exn, t2))
                       : caml_call2(Async_kernel_Deferred[4], t2, f);
              }
              return caml_call1(is_determined, t1)
                      ? f(caml_call1(value_exn, t1))
                      : caml_call2(Async_kernel_Deferred[4], t1, f);
             });
   }
   function ok(t){
    return caml_call1(is_determined, t)
            ? caml_call1(return$1, [0, caml_call1(value_exn, t)])
            : caml_call1(Async_kernel_Deferred[33], t);
   }
   function ignore_m(t){
    return caml_call1(is_determined, t)
            ? unit
            : caml_call1(Async_kernel_Deferred[15], t);
   }
   function any(ts){
    var match = caml_call2(Core_List[27], ts, is_determined);
    if(! match) return caml_call1(Async_kernel_Deferred[23], ts);
    var x = match[1];
    return caml_call1(return$1, caml_call1(value_exn, x));
   }
   function any_unit(ts){
    return caml_call2(Core_List[23], ts, is_determined)
            ? unit
            : caml_call1(Async_kernel_Deferred[24], ts);
   }
   var
    symbol_bind$0 = Monad_infix[1],
    symbol_map$0 = Monad_infix[2],
    Infix = [0, symbol_bind$0, symbol_map$0, upon],
    _a_ = [0, 0],
    _b_ = [0, 0];
   function repeat_until_finished(state, f){
    return caml_call1
            (create,
             function(finished){
              function loop(state){
               var _y_ = caml_call1(f, state);
               return caml_call2
                       (Infix[3],
                        _y_,
                        function(param){
                         if(990972795 <= param[1]){
                          var state = param[2];
                          return loop(state);
                         }
                         var result = param[2];
                         return caml_call2(Async_kernel_Ivar[14], finished, result);
                        });
              }
              return loop(state);
             });
   }
   function foldi(t, init, f){
    return caml_call1
            (create,
             function(result){
              function loop(t, i, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1], _x_ = caml_call3(f, i, b, x);
               return caml_call2
                       (Infix[3], _x_, function(b){return loop(xs, i + 1 | 0, b);});
              }
              return loop(t, 0, init);
             });
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _u_ = Core_List[57],
     _v_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          var _w_ = caml_call2(f, i, a);
          return caml_call2
                  (Let_syntax[4][3], _w_, function(b){return [0, b, bs];});
         });
    return caml_call2(Let_syntax[3], _v_, _u_);
   }
   function all$0(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    return ignore_m(fold(ds, 0, function(param, d){return d;}));
   }
   function iteri(how, t, f){
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _s_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _t_ = caml_call1(Core[261], _s_);
    return all_unit(caml_call2(Core_List[41], t, _t_));
   }
   function mapi(how, t, f){
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _q_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _r_ = caml_call1(Core[261], _q_);
    return all$0(caml_call2(Core_List[41], t, _r_));
   }
   function filteri(how, t, f){
    var _o_ = mapi(how, t, f);
    return caml_call2
            (Let_syntax[4][3],
             _o_,
             function(bools){
              var
               _p_ =
                 caml_call4
                  (Core_List[65],
                   t,
                   bools,
                   0,
                   function(ac, x, b){return b ? [0, x, ac] : ac;});
              return caml_call1(Core_List[57], _p_);
             });
   }
   function filter_mapi(how, t, f){
    var _m_ = Core_List[129], _n_ = mapi(how, t, f);
    return caml_call2(Let_syntax[3], _n_, _m_);
   }
   function concat_mapi(how, t, f){
    var _k_ = Core_List[10], _l_ = mapi(how, t, f);
    return caml_call2(Let_syntax[3], _l_, _k_);
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(Let_syntax[1], 0);
     var tl = t[2], hd = t[1], _j_ = caml_call2(f, i, hd);
     return caml_call2
             (Let_syntax[4][2],
              _j_,
              function(some){
               return some
                       ? caml_call1(Let_syntax[1], some)
                       : find_mapi(tl, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              var _i_ = caml_call2(f, i, elt);
              return caml_call2
                      (Let_syntax[4][3],
                       _i_,
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              var _h_ = caml_call1(f, elt);
              return caml_call2
                      (Let_syntax[4][3],
                       _h_,
                       function(param){return param ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          var _g_ = caml_call2(f, i, elt);
          return caml_call2
                  (Let_syntax[4][3], _g_, function(b){return b ? _a_ : 0;});
         });
    return caml_call2
            (Let_syntax[4][3], _f_, function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    var
     _d_ =
       find_mapi
        (t,
         function(i, elt){
          var _e_ = caml_call2(f, i, elt);
          return caml_call2
                  (Let_syntax[4][3], _e_, function(b){return b ? 0 : _b_;});
         });
    return caml_call2
            (Let_syntax[4][3], _d_, function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map$1(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map$1
            (how, caml_call2(Core_List[40], n, function(_c_){return _c_;}), f);
   }
   var
    List =
      [0,
       foldi,
       fold,
       seqmapi,
       all$0,
       all_unit,
       iteri,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       find_mapi,
       findi,
       find,
       existsi,
       for_alli,
       iter,
       map$1,
       filter,
       filter_map,
       concat_map,
       find_map,
       exists,
       for_all,
       init],
    all_unit$0 = List[5];
   caml_call1(Ppx_inline_test_lib[6], cst_eager_deferred);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Eager_deferred_Eager_defer);
   var
    Eager_deferred_Eager_deferred0 =
      [0,
       T,
       sexp_of_t$0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       all,
       Let_syntax,
       create,
       don_t_wait_for,
       invariant,
       is_determined,
       never,
       peek,
       unit,
       value_exn,
       upon,
       both,
       ok,
       ignore_m,
       any,
       any_unit,
       Infix,
       repeat_until_finished,
       List,
       all_unit$0];
   runtime.caml_register_global
    (19, Eager_deferred_Eager_deferred0, cst_Eager_deferred_Eager_defer);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred__Eager_deferred_result
//# unitInfo: Requires: Base__Monad, Core__Printf, Core__Result, Eager_deferred__Eager_deferred0, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Eager_deferred_Eager_defer = "Eager_deferred__Eager_deferred_result",
    cst_eager_deferred = "eager_deferred";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Result = global_data.Core__Result,
    Eager_deferred_Eager_deferred0 =
      global_data.Eager_deferred__Eager_deferred0,
    Core_Printf = global_data.Core__Printf,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Eager_deferred_Eager_defer);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_eager_deferred);
   caml_call1
    (Expect_test_collector[6][1],
     "eager_deferred/src/eager_deferred_result.ml");
   caml_call2
    (Ppx_inline_test_lib[5], cst_eager_deferred, "eager_deferred_result.ml");
   var T = [0];
   function combine(t1, t2, ok, err){
    var _a_ = caml_call2(Eager_deferred_Eager_deferred0[11][4][4], t1, t2);
    return caml_call2
            (Eager_deferred_Eager_deferred0[11][4][3],
             _a_,
             function(param){
              var t2 = param[2], t1 = param[1];
              return caml_call4(Core_Result[41], t1, t2, ok, err);
             });
   }
   function return$0(a){
    return caml_call1(Eager_deferred_Eager_deferred0[7], [0, a]);
   }
   function bind(t, f){
    return caml_call2
            (Eager_deferred_Eager_deferred0[6],
             t,
             function(error){
              if(0 !== error[0])
               return caml_call1(Eager_deferred_Eager_deferred0[7], error);
              var a = error[1];
              return caml_call1(f, a);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return caml_call2
                (Eager_deferred_Eager_deferred0[8],
                 t,
                 function(r){return caml_call2(Core_Result[39], r, f);});
       }],
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function fail(x){
    return caml_call1(Eager_deferred_Eager_deferred0[7], [1, x]);
   }
   function failf(format){return caml_call2(Core_Printf[4], fail, format);}
   function map_error(t, f){
    return caml_call2
            (Eager_deferred_Eager_deferred0[8],
             t,
             function(r){return caml_call2(Core_Result[40], r, f);});
   }
   caml_call1(Ppx_inline_test_lib[6], cst_eager_deferred);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Eager_deferred_Eager_defer);
   var
    Eager_deferred_Eager_deferred_ =
      [0,
       T,
       combine,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       fail,
       failf,
       map_error];
   runtime.caml_register_global
    (15, Eager_deferred_Eager_deferred_, cst_Eager_deferred_Eager_defer);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred__Eager_deferred_or_error
//# unitInfo: Requires: Async_kernel__Monitor, Async_kernel__Throttle, Base__Applicative, Core, Core__Error, Core__List, Core__Or_error, Core__Result, Eager_deferred__Eager_deferred0, Eager_deferred__Eager_deferred_result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Eager_deferred_Eager_defer = "Eager_deferred__Eager_deferred_or_error",
    cst_eager_deferred = "eager_deferred";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Core_Or_error = global_data.Core__Or_error,
    Eager_deferred_Eager_deferred0 =
      global_data.Eager_deferred__Eager_deferred0,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Eager_deferred_Eager_deferred_ =
      global_data.Eager_deferred__Eager_deferred_result,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Eager_deferred_Eager_defer);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_eager_deferred);
   caml_call1
    (Expect_test_collector[6][1],
     "eager_deferred/src/eager_deferred_or_error.ml");
   caml_call2
    (Ppx_inline_test_lib[5], cst_eager_deferred, "eager_deferred_or_error.ml");
   var
    ignore_m = Eager_deferred_Eager_deferred_[11],
    join = Eager_deferred_Eager_deferred_[10],
    return$0 = Eager_deferred_Eager_deferred_[8],
    bind = Eager_deferred_Eager_deferred_[7],
    Monad_infix = Eager_deferred_Eager_deferred_[6],
    symbol_bind = Eager_deferred_Eager_deferred_[3];
   function apply(f, x){
    return caml_call4
            (Eager_deferred_Eager_deferred_[2],
             f,
             x,
             function(f, x){return caml_call1(f, x);},
             function(e1, e2){
              return caml_call2(Core_Error[24], 0, [0, e1, [0, e2, 0]]);
             });
   }
   var
    map = [0, -198771759, Eager_deferred_Eager_deferred_[9]],
    include = caml_call1(Base_Applicative[6], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol_map = include[7],
    all = include[11],
    all_unit = include[12],
    symbol_bind$0 = Monad_infix[1],
    symbol_map$0 = Monad_infix[2],
    Open_on_rhs = [0];
   function fail(error){
    var _J_ = caml_call1(Core_Result[28], error);
    return caml_call1(Eager_deferred_Eager_deferred0[7], _J_);
   }
   function ok_exn(t){
    return caml_call2(Eager_deferred_Eager_deferred0[8], t, Core_Or_error[36]);
   }
   function of_exn(backtrace, exn){
    var _I_ = caml_call2(Core_Or_error[37], backtrace, exn);
    return caml_call1(Eager_deferred_Eager_deferred0[7], _I_);
   }
   function of_exn_result(backtrace, t){
    var _H_ = caml_call1(Core_Or_error[38], backtrace);
    return caml_call2(Eager_deferred_Eager_deferred0[8], t, _H_);
   }
   function error(msg, v, sexp_of){
    var _G_ = caml_call5(Core_Or_error[39], 0, 0, msg, v, sexp_of);
    return caml_call1(Eager_deferred_Eager_deferred0[7], _G_);
   }
   function error_s(sexp){
    var _F_ = caml_call1(Core_Or_error[40], sexp);
    return caml_call1(Eager_deferred_Eager_deferred0[7], _F_);
   }
   function error_string(msg){
    var _E_ = caml_call1(Core_Or_error[41], msg);
    return caml_call1(Eager_deferred_Eager_deferred0[7], _E_);
   }
   function errorf(format){
    return caml_call2(Core[248], error_string, format);
   }
   function tag(t, tag){
    var _C_ = Core_Or_error[43];
    return caml_call2
            (Eager_deferred_Eager_deferred0[8],
             t,
             function(_D_){return caml_call2(_C_, _D_, tag);});
   }
   function tag_s(t, tag){
    var _A_ = Core_Or_error[44];
    return caml_call2
            (Eager_deferred_Eager_deferred0[8],
             t,
             function(_B_){return caml_call2(_A_, _B_, tag);});
   }
   function tag_s_lazy(t, tag){
    var _y_ = Core_Or_error[45];
    return caml_call2
            (Eager_deferred_Eager_deferred0[8],
             t,
             function(_z_){return caml_call2(_y_, _z_, tag);});
   }
   function tag_arg(t, message, a, sexp_of_a){
    return caml_call2
            (Eager_deferred_Eager_deferred0[8],
             t,
             function(t){
              return caml_call4(Core_Or_error[46], t, message, a, sexp_of_a);
             });
   }
   function unimplemented(msg){
    var _x_ = caml_call1(Core_Or_error[47], msg);
    return caml_call1(Eager_deferred_Eager_deferred0[7], _x_);
   }
   function combine_errors(l){
    var
     _v_ = Core_Or_error[51],
     _w_ = caml_call1(Eager_deferred_Eager_deferred0[10], l);
    return caml_call2(Eager_deferred_Eager_deferred0[8], _w_, _v_);
   }
   function combine_errors_unit(l){
    var
     _t_ = Core_Or_error[52],
     _u_ = caml_call1(Eager_deferred_Eager_deferred0[10], l);
    return caml_call2(Eager_deferred_Eager_deferred0[8], _u_, _t_);
   }
   function filter_ok_at_least_one(l){
    var
     _r_ = Core_Or_error[53],
     _s_ = caml_call1(Eager_deferred_Eager_deferred0[10], l);
    return caml_call2(Eager_deferred_Eager_deferred0[8], _s_, _r_);
   }
   function find_map_ok(l, f){
    return caml_call2
            (Eager_deferred_Eager_deferred0[27],
             [0, l, 0],
             function(param){
              var errors = param[2], l = param[1];
              if(l){
               var tl = l[2], hd = l[1], _p_ = caml_call1(f, hd);
               return caml_call2
                       (Eager_deferred_Eager_deferred0[8],
                        _p_,
                        function(param){
                         if(0 === param[0]){
                          var result = param[1];
                          return [0, -289386606, [0, result]];
                         }
                         var current_error = param[1];
                         return [0, 990972795, [0, tl, [0, current_error, errors]]];
                        });
              }
              var
               _q_ = caml_call1(Core_List[57], errors),
               errors$0 = caml_call2(Core_Error[24], 0, _q_);
              return caml_call1
                      (Eager_deferred_Eager_deferred0[7],
                       [0, -289386606, [1, errors$0]]);
             });
   }
   var ok_unit = caml_call1(return$1, 0), _a_ = [0, 0], _b_ = [0, 0];
   function try_with(extract_exn, run$0, rest, here, name, f){
    function _m_(ok){
     if(0 === ok[0]) return ok;
     var exn = ok[1];
     return [1, caml_call2(Core_Error[25], 0, exn)];
    }
    var
     _n_ = 0,
     run = run$0 ? run$0[1] : 3903734,
     _o_ =
       caml_call2
        (caml_call5
          (Async_kernel_Monitor[16], here, _n_, name, extract_exn, [0, run]),
         rest,
         f);
    return caml_call2(Eager_deferred_Eager_deferred0[8], _o_, _m_);
   }
   function try_with_join(extract_exn, run, rest, here, name, f){
    var
     _k_ = Core_Or_error[27],
     _l_ = try_with(extract_exn, run, rest, here, name, f);
    return caml_call2(Eager_deferred_Eager_deferred0[8], _l_, _k_);
   }
   function foldi(list, acc, f){
    function loop(i, acc, param){
     if(! param) return caml_call1(return$1, acc);
     var tl = param[2], hd = param[1];
     return caml_call2
             (bind,
              caml_call3(f, i, acc, hd),
              function(acc){return loop(i + 1 | 0, acc, tl);});
    }
    return loop(0, acc, list);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function iteri(how, t, f){
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _i_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _j_ = caml_call1(Core[261], _i_);
    return caml_call1(all_unit, caml_call2(Core_List[41], t, _j_));
   }
   function mapi(how, t, f){
    if(typeof how === "number" && -676829465 > how){
     var _f_ = Core_List[57];
     return caml_call2
             (symbol_map$0,
              foldi
               (t,
                0,
                function(i, bs, a){
                 return caml_call2
                         (map$0,
                          caml_call2(f, i, a),
                          function(b){return [0, b, bs];});
                }),
              _f_);
    }
    var
     _g_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _h_ = caml_call1(Core[261], _g_);
    return caml_call1(all, caml_call2(Core_List[41], t, _h_));
   }
   function filter_mapi(how, t, f){
    var _e_ = Core_List[129];
    return caml_call2(symbol_map$0, mapi(how, t, f), _e_);
   }
   function concat_mapi(how, t, f){
    var _d_ = Core_List[10];
    return caml_call2(symbol_map$0, mapi(how, t, f), _d_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, x){
              return caml_call2
                      (map$0,
                       caml_call2(f, i, x),
                       function(b){return b ? [0, x] : 0;});
             });
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(return$1, 0);
     var tl = t[2], hd = t[1];
     return caml_call2
             (bind,
              caml_call2(f, i, hd),
              function(some){
               return some
                       ? caml_call1(return$1, some)
                       : find_mapi(tl, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              return caml_call2
                      (map$0,
                       caml_call2(f, i, elt),
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              return caml_call2
                      (map$0,
                       caml_call1(f, elt),
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                return caml_call2
                        (map$0,
                         caml_call2(f, i, elt),
                         function(b){return b ? _a_ : 0;});
               }),
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                return caml_call2
                        (map$0,
                         caml_call2(f, i, elt),
                         function(b){return b ? 0 : _b_;});
               }),
             function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map$1(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map$1
            (how, caml_call2(Core_List[40], n, function(_c_){return _c_;}), f);
   }
   function repeat_until_finished(state, f){
    return caml_call2
            (bind,
             caml_call1(f, state),
             function(param){
              if(990972795 <= param[1]){
               var state = param[2];
               return repeat_until_finished(state, f);
              }
              var state$0 = param[2];
              return caml_call1(return$1, state$0);
             });
   }
   caml_call1(Ppx_inline_test_lib[6], cst_eager_deferred);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Eager_deferred_Eager_defer);
   var
    Eager_deferred_Eager_deferred_$0 =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       fail,
       ok_unit,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       find_map_ok,
       try_with,
       try_with_join,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       [0,
        foldi,
        fold,
        find,
        findi,
        find_map,
        find_mapi,
        exists,
        existsi,
        for_all,
        for_alli,
        all,
        all_unit,
        init,
        iter,
        iteri,
        map$1,
        mapi,
        filter,
        filteri,
        filter_map,
        filter_mapi,
        concat_map,
        concat_mapi],
       repeat_until_finished];
   runtime.caml_register_global
    (23, Eager_deferred_Eager_deferred_$0, cst_Eager_deferred_Eager_defer);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred__Eager_deferred_memo
//# unitInfo: Requires: Async_kernel__Deferred_memo, Eager_deferred__Eager_deferred0, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Eager_deferred_Eager_defer = "Eager_deferred__Eager_deferred_memo",
    cst_eager_deferred = "eager_deferred";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Eager_deferred_Eager_deferred0 =
      global_data.Eager_deferred__Eager_deferred0,
    Async_kernel_Deferred_memo = global_data.Async_kernel__Deferred_memo;
   caml_call1(Ppx_module_timer_runtime[4], cst_Eager_deferred_Eager_defer);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_eager_deferred);
   caml_call1
    (Expect_test_collector[6][1], "eager_deferred/src/eager_deferred_memo.ml");
   caml_call2
    (Ppx_inline_test_lib[5], cst_eager_deferred, "eager_deferred_memo.ml");
   var
    include =
      caml_call1
       (Async_kernel_Deferred_memo[1],
        [0,
         Eager_deferred_Eager_deferred0[3],
         Eager_deferred_Eager_deferred0[4]]),
    general = include[1],
    recursive = include[2],
    unit = include[3];
   caml_call1(Ppx_inline_test_lib[6], cst_eager_deferred);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Eager_deferred_Eager_defer);
   var Eager_deferred_Eager_deferred_ = [0, general, recursive, unit];
   runtime.caml_register_global
    (13, Eager_deferred_Eager_deferred_, cst_Eager_deferred_Eager_defer);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred__Eager_deferred_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Eager_deferred_Eager_defer = "Eager_deferred__Eager_deferred_intf",
    cst_eager_deferred = "eager_deferred";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Eager_deferred_Eager_defer);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_eager_deferred);
   caml_call1
    (Expect_test_collector[6][1], "eager_deferred/src/eager_deferred_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[5], cst_eager_deferred, "eager_deferred_intf.ml");
   caml_call1(Ppx_inline_test_lib[6], cst_eager_deferred);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Eager_deferred_Eager_defer);
   var Eager_deferred_Eager_deferred_ = [0];
   runtime.caml_register_global
    (11, Eager_deferred_Eager_deferred_, cst_Eager_deferred_Eager_defer);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred__Eager_deferred1
//# unitInfo: Requires: Eager_deferred__Eager_deferred0, Eager_deferred__Eager_deferred_memo, Eager_deferred__Eager_deferred_or_error, Eager_deferred__Eager_deferred_result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Eager_deferred_Eager_defer = "Eager_deferred__Eager_deferred1",
    cst_eager_deferred = "eager_deferred";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Eager_deferred_Eager_deferred0 =
      global_data.Eager_deferred__Eager_deferred0,
    Eager_deferred_Eager_deferred_ =
      global_data.Eager_deferred__Eager_deferred_result,
    Eager_deferred_Eager_deferred_$0 =
      global_data.Eager_deferred__Eager_deferred_memo,
    Eager_deferred_Eager_deferred_$1 =
      global_data.Eager_deferred__Eager_deferred_or_error;
   caml_call1(Ppx_module_timer_runtime[4], cst_Eager_deferred_Eager_defer);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_eager_deferred);
   caml_call1
    (Expect_test_collector[6][1], "eager_deferred/src/eager_deferred1.ml");
   caml_call2
    (Ppx_inline_test_lib[5], cst_eager_deferred, "eager_deferred1.ml");
   var
    symbol_bind = Eager_deferred_Eager_deferred0[3],
    symbol_map = Eager_deferred_Eager_deferred0[4],
    Monad_infix = Eager_deferred_Eager_deferred0[5],
    bind = Eager_deferred_Eager_deferred0[6],
    return$0 = Eager_deferred_Eager_deferred0[7],
    map = Eager_deferred_Eager_deferred0[8],
    join = Eager_deferred_Eager_deferred0[9],
    all = Eager_deferred_Eager_deferred0[10],
    Let_syntax = Eager_deferred_Eager_deferred0[11],
    create = Eager_deferred_Eager_deferred0[12],
    don_t_wait_for = Eager_deferred_Eager_deferred0[13],
    invariant = Eager_deferred_Eager_deferred0[14],
    is_determined = Eager_deferred_Eager_deferred0[15],
    never = Eager_deferred_Eager_deferred0[16],
    peek = Eager_deferred_Eager_deferred0[17],
    unit = Eager_deferred_Eager_deferred0[18],
    value_exn = Eager_deferred_Eager_deferred0[19],
    upon = Eager_deferred_Eager_deferred0[20],
    both = Eager_deferred_Eager_deferred0[21],
    ok = Eager_deferred_Eager_deferred0[22],
    ignore_m = Eager_deferred_Eager_deferred0[23],
    any = Eager_deferred_Eager_deferred0[24],
    any_unit = Eager_deferred_Eager_deferred0[25],
    Infix = Eager_deferred_Eager_deferred0[26],
    repeat_until_finished = Eager_deferred_Eager_deferred0[27],
    List = Eager_deferred_Eager_deferred0[28],
    all_unit = Eager_deferred_Eager_deferred0[29];
   caml_call1(Ppx_inline_test_lib[6], cst_eager_deferred);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Eager_deferred_Eager_defer);
   var
    Eager_deferred_Eager_deferred1 =
      [0,
       invariant,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Infix,
       any,
       any_unit,
       both,
       create,
       don_t_wait_for,
       is_determined,
       never,
       ok,
       peek,
       unit,
       upon,
       value_exn,
       repeat_until_finished,
       [0,
        List[1],
        List[2],
        List[13],
        List[12],
        List[21],
        List[11],
        List[22],
        List[14],
        List[23],
        List[15],
        List[4],
        List[5],
        List[24],
        List[16],
        List[6],
        List[17],
        List[7],
        List[18],
        List[8],
        List[19],
        List[9],
        List[20],
        List[10]],
       Eager_deferred_Eager_deferred_$1,
       Eager_deferred_Eager_deferred_$0,
       [0,
        Eager_deferred_Eager_deferred_[3],
        Eager_deferred_Eager_deferred_[4],
        Eager_deferred_Eager_deferred_[5],
        Eager_deferred_Eager_deferred_[6],
        Eager_deferred_Eager_deferred_[7],
        Eager_deferred_Eager_deferred_[8],
        Eager_deferred_Eager_deferred_[9],
        Eager_deferred_Eager_deferred_[10],
        Eager_deferred_Eager_deferred_[11],
        Eager_deferred_Eager_deferred_[12],
        Eager_deferred_Eager_deferred_[13],
        Eager_deferred_Eager_deferred_[14],
        Eager_deferred_Eager_deferred_[15],
        Eager_deferred_Eager_deferred_[16],
        Eager_deferred_Eager_deferred_[2]]];
   runtime.caml_register_global
    (15, Eager_deferred_Eager_deferred1, cst_Eager_deferred_Eager_defer);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Eager_deferred
//# unitInfo: Requires: Async_kernel__Deferred, Eager_deferred__Eager_deferred1, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Eager_deferred = "Eager_deferred",
    cst_eager_deferred = "eager_deferred";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Eager_deferred_Eager_deferred1 =
      global_data.Eager_deferred__Eager_deferred1,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred;
   caml_call1(Ppx_module_timer_runtime[4], cst_Eager_deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_eager_deferred);
   caml_call1
    (Expect_test_collector[6][1], "eager_deferred/src/eager_deferred.ml");
   caml_call2(Ppx_inline_test_lib[5], cst_eager_deferred, "eager_deferred.ml");
   var
    invariant = Eager_deferred_Eager_deferred1[1],
    symbol_bind = Eager_deferred_Eager_deferred1[2],
    symbol_map = Eager_deferred_Eager_deferred1[3],
    Monad_infix = Eager_deferred_Eager_deferred1[4],
    bind = Eager_deferred_Eager_deferred1[5],
    return$0 = Eager_deferred_Eager_deferred1[6],
    map = Eager_deferred_Eager_deferred1[7],
    join = Eager_deferred_Eager_deferred1[8],
    ignore_m = Eager_deferred_Eager_deferred1[9],
    all = Eager_deferred_Eager_deferred1[10],
    all_unit = Eager_deferred_Eager_deferred1[11],
    Let_syntax = Eager_deferred_Eager_deferred1[12],
    Infix = Eager_deferred_Eager_deferred1[13],
    any = Eager_deferred_Eager_deferred1[14],
    any_unit = Eager_deferred_Eager_deferred1[15],
    both = Eager_deferred_Eager_deferred1[16],
    create = Eager_deferred_Eager_deferred1[17],
    don_t_wait_for = Eager_deferred_Eager_deferred1[18],
    is_determined = Eager_deferred_Eager_deferred1[19],
    never = Eager_deferred_Eager_deferred1[20],
    ok = Eager_deferred_Eager_deferred1[21],
    peek = Eager_deferred_Eager_deferred1[22],
    unit = Eager_deferred_Eager_deferred1[23],
    upon = Eager_deferred_Eager_deferred1[24],
    value_exn = Eager_deferred_Eager_deferred1[25],
    repeat_until_finished = Eager_deferred_Eager_deferred1[26],
    List = Eager_deferred_Eager_deferred1[27],
    Or_error = Eager_deferred_Eager_deferred1[28],
    Memo = Eager_deferred_Eager_deferred1[29],
    Result = Eager_deferred_Eager_deferred1[30],
    sexp_of_t = Async_kernel_Deferred[1],
    invariant$0 = Eager_deferred_Eager_deferred1[1],
    symbol_bind$0 = Eager_deferred_Eager_deferred1[2],
    symbol_map$0 = Eager_deferred_Eager_deferred1[3],
    Monad_infix$0 = Eager_deferred_Eager_deferred1[4],
    bind$0 = Eager_deferred_Eager_deferred1[5],
    return$1 = Eager_deferred_Eager_deferred1[6],
    map$0 = Eager_deferred_Eager_deferred1[7],
    join$0 = Eager_deferred_Eager_deferred1[8],
    ignore_m$0 = Eager_deferred_Eager_deferred1[9],
    all$0 = Eager_deferred_Eager_deferred1[10],
    all_unit$0 = Eager_deferred_Eager_deferred1[11],
    Let_syntax$0 = Eager_deferred_Eager_deferred1[12],
    Infix$0 = Eager_deferred_Eager_deferred1[13],
    any$0 = Eager_deferred_Eager_deferred1[14],
    any_unit$0 = Eager_deferred_Eager_deferred1[15],
    both$0 = Eager_deferred_Eager_deferred1[16],
    create$0 = Eager_deferred_Eager_deferred1[17],
    don_t_wait_for$0 = Eager_deferred_Eager_deferred1[18],
    is_determined$0 = Eager_deferred_Eager_deferred1[19],
    never$0 = Eager_deferred_Eager_deferred1[20],
    ok$0 = Eager_deferred_Eager_deferred1[21],
    peek$0 = Eager_deferred_Eager_deferred1[22],
    unit$0 = Eager_deferred_Eager_deferred1[23],
    upon$0 = Eager_deferred_Eager_deferred1[24],
    value_exn$0 = Eager_deferred_Eager_deferred1[25],
    repeat_until_finished$0 = Eager_deferred_Eager_deferred1[26],
    List$0 = Eager_deferred_Eager_deferred1[27],
    Or_error$0 = Eager_deferred_Eager_deferred1[28],
    Memo$0 = Eager_deferred_Eager_deferred1[29],
    Result$0 = Eager_deferred_Eager_deferred1[30],
    Deferred =
      [0,
       sexp_of_t,
       invariant$0,
       symbol_bind$0,
       symbol_map$0,
       Monad_infix$0,
       bind$0,
       return$1,
       map$0,
       join$0,
       ignore_m$0,
       all$0,
       all_unit$0,
       Let_syntax$0,
       Infix$0,
       any$0,
       any_unit$0,
       both$0,
       create$0,
       don_t_wait_for$0,
       is_determined$0,
       never$0,
       ok$0,
       peek$0,
       unit$0,
       upon$0,
       value_exn$0,
       repeat_until_finished$0,
       List$0,
       Or_error$0,
       Memo$0,
       Result$0],
    include = Eager_deferred_Eager_deferred1[12],
    return$2 = include[1],
    symbol_bind$1 = include[2],
    symbol_map$1 = include[3],
    Let_syntax$1 = include[4],
    upon$1 = Eager_deferred_Eager_deferred1[24],
    symbol = Eager_deferred_Eager_deferred1[13][3];
   function symbol$0(x, f){
    return caml_call2
            (symbol_bind$1,
             x,
             function(error){
              if(0 !== error[0]) return caml_call1(return$2, error);
              var v = error[1];
              return caml_call1(f, v);
             });
   }
   function symbol$1(x, f){
    return caml_call2
            (symbol_map$1,
             x,
             function(error){
              if(0 !== error[0]) return error;
              var v = error[1];
              return [0, caml_call1(f, v)];
             });
   }
   var
    Use =
      [0,
       Deferred,
       return$2,
       symbol_bind$1,
       symbol_map$1,
       Let_syntax$1,
       upon$1,
       symbol,
       symbol$0,
       symbol$1];
   caml_call1(Ppx_inline_test_lib[6], cst_eager_deferred);
   caml_call1(Expect_test_collector[6][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Eager_deferred);
   var
    Eager_deferred =
      [0,
       invariant,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Infix,
       any,
       any_unit,
       both,
       create,
       don_t_wait_for,
       is_determined,
       never,
       ok,
       peek,
       unit,
       upon,
       value_exn,
       repeat_until_finished,
       List,
       Or_error,
       Memo,
       Result,
       Use];
   runtime.caml_register_global(13, Eager_deferred, cst_Eager_deferred);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWFnZXJfZGVmZXJyZWQuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImVhZ2VyX2RlZmVycmVkLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJFYWdlcl9kZWZlcnJlZCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsaUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJlYWdlcl9kZWZlcnJlZC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiRWFnZXJfZGVmZXJyZWRfSW1wb3J0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyx3QkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImVhZ2VyX2RlZmVycmVkLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXIiLCJjc3RfZWFnZXJfZGVmZXJyZWQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJDb3JlX0xpc3QiLCJBc3luY19rZXJuZWxfVGhyb3R0bGUiLCJDb3JlIiwiQXN5bmNfa2VybmVsX0l2YXIiLCJBc3luY19rZXJuZWxfRGVmZXJyZWQiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiQmFzZV9Nb25hZCIsInNleHBfb2ZfdCIsInJldHVybiIsImJpbmQiLCJ0IiwibWFwIiwiVCIsImluY2x1ZGUiLCJzeW1ib2xfYmluZCIsInN5bWJvbF9tYXAiLCJNb25hZF9pbmZpeCIsImpvaW4iLCJhbGwiLCJMZXRfc3ludGF4IiwiY3JlYXRlIiwiZG9uX3Rfd2FpdF9mb3IiLCJpbnZhcmlhbnQiLCJpc19kZXRlcm1pbmVkIiwibmV2ZXIiLCJwZWVrIiwidW5pdCIsInZhbHVlX2V4biIsInVwb24iLCJib3RoIiwidDEiLCJ0MiIsInJlc3VsdCIsIm9rIiwiaWdub3JlX20iLCJhbnkiLCJ0cyIsIm1hdGNoIiwieCIsImFueV91bml0IiwiSW5maXgiLCJyZXBlYXRfdW50aWxfZmluaXNoZWQiLCJzdGF0ZSIsImZpbmlzaGVkIiwibG9vcCIsInBhcmFtIiwiZm9sZGkiLCJpbml0IiwiaSIsImIiLCJ4cyIsImZvbGQiLCJhIiwic2VxbWFwaSIsImJzIiwiZHMiLCJhbGxfdW5pdCIsImQiLCJpdGVyaSIsImhvdyIsIm1hcGkiLCJmaWx0ZXJpIiwiYm9vbHMiLCJhYyIsImZpbHRlcl9tYXBpIiwiY29uY2F0X21hcGkiLCJmaW5kX21hcGkiLCJ0bCIsImhkIiwic29tZSIsImZpbmRpIiwiZWx0IiwiZmluZCIsImV4aXN0c2kiLCJmb3JfYWxsaSIsIml0ZXIiLCJmaWx0ZXIiLCJmaWx0ZXJfbWFwIiwiY29uY2F0X21hcCIsImZpbmRfbWFwIiwiZXhpc3RzIiwiZm9yX2FsbCIsIm4iLCJMaXN0IiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWQwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FzeW5jX2tlcm5lbC9l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QUFBQSxZQUFBMkIsU0FBQXJFLEdBQUF0QjtBQUFBQSxJQUM3Qyw2QkFBQXlELE9BQUFPLEdBQTJCLHVCQUFHLEdBQUM7QUFBQTtBQUFBLFlBQUE0QixPQUFBdEUsR0FBQXRCO0FBQUFBLElBQ2pDLDJCQUFBeUQsT0FBQU8sR0FBeUIsdUJBQUcsR0FBQztBQUFBO0FBQUEsWUFBQTZCLFFBQUF2RSxHQUFBdEI7QUFBQUEsSUFDNUIsNEJBQUF5RCxPQUFBTyxHQUEwQix1QkFBRyxHQUFDO0FBQUE7QUFBQSxZQUFBTCxLQUFBWSxLQUFBdUIsR0FBQTlGO0FBQUFBLElBQ25CLE9BQXNCO0FBQUEsa0JBQXRCLDJDRHpLaEMsaUJDeUt5RDtBQUFBO0FBQUE7QUFBQSxJQUFBK0Y7QUFBQUEsTUF6S3pEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQTNCLGFBQUE7QUFBQSxHQTRLNEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUE0QjtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVENUs1QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQ29yZVxub3BlbiEgQXN5bmNfa2VybmVsXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSArJ2EgdCA9ICdhIERlZmVycmVkLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgcmV0dXJuID0gRGVmZXJyZWQucmV0dXJuXG5cbiAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCB0IHRoZW4gZiAoRGVmZXJyZWQudmFsdWVfZXhuIHQpIGVsc2UgRGVmZXJyZWQuYmluZCB0IH5mXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mID1cbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHRcbiAgICB0aGVuIHJldHVybiAoZiAoRGVmZXJyZWQudmFsdWVfZXhuIHQpKVxuICAgIGVsc2UgRGVmZXJyZWQubWFwIHQgfmZcbiAgOztcblxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgTW9uYWQuTWFrZSAoVClcblxubGV0IGNyZWF0ZSA9IERlZmVycmVkLmNyZWF0ZVxubGV0IGRvbid0X3dhaXRfZm9yID0gRGVmZXJyZWQuZG9uJ3Rfd2FpdF9mb3JcbmxldCBpbnZhcmlhbnQgPSBEZWZlcnJlZC5pbnZhcmlhbnRcbmxldCBpc19kZXRlcm1pbmVkID0gRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZFxubGV0IG5ldmVyID0gRGVmZXJyZWQubmV2ZXJcbmxldCBwZWVrID0gRGVmZXJyZWQucGVla1xubGV0IHVuaXQgPSBEZWZlcnJlZC51bml0XG5sZXQgdmFsdWVfZXhuID0gRGVmZXJyZWQudmFsdWVfZXhuXG5sZXQgdXBvbiB0IGYgPSBpZiBpc19kZXRlcm1pbmVkIHQgdGhlbiBmICh2YWx1ZV9leG4gdCkgZWxzZSBEZWZlcnJlZC51cG9uIHQgZlxuXG5sZXQgYm90aCB0MSB0MiA9XG4gIGNyZWF0ZSAoZnVuIHJlc3VsdCAtPiB1cG9uIHQxIChmdW4gYTEgLT4gdXBvbiB0MiAoZnVuIGEyIC0+IEl2YXIuZmlsbCByZXN1bHQgKGExLCBhMikpKSlcbjs7XG5cbmxldCBvayB0ID0gaWYgaXNfZGV0ZXJtaW5lZCB0IHRoZW4gcmV0dXJuIChPayAodmFsdWVfZXhuIHQpKSBlbHNlIERlZmVycmVkLm9rIHRcbmxldCBpZ25vcmVfbSB0ID0gaWYgaXNfZGV0ZXJtaW5lZCB0IHRoZW4gdW5pdCBlbHNlIERlZmVycmVkLmlnbm9yZV9tIHRcblxubGV0IGFueSB0cyA9XG4gIG1hdGNoIExpc3QuZmluZCB0cyB+Zjppc19kZXRlcm1pbmVkIHdpdGhcbiAgfCBTb21lIHggLT4gcmV0dXJuICh2YWx1ZV9leG4geClcbiAgfCBOb25lIC0+IERlZmVycmVkLmFueSB0c1xuOztcblxubGV0IGFueV91bml0IHRzID1cbiAgaWYgTGlzdC5leGlzdHMgdHMgfmY6KGlzX2RldGVybWluZWQgOiB1bml0IHQgLT4gYm9vbClcbiAgdGhlbiB1bml0XG4gIGVsc2UgRGVmZXJyZWQuYW55X3VuaXQgdHNcbjs7XG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbGV0ICggPj4+ICkgPSB1cG9uXG5lbmRcblxubGV0IHJlcGVhdF91bnRpbF9maW5pc2hlZCBzdGF0ZSBmID1cbiAgbGV0IG9wZW4gSW5maXggaW5cbiAgY3JlYXRlIChmdW4gZmluaXNoZWQgLT5cbiAgICBsZXQgcmVjIGxvb3Agc3RhdGUgPVxuICAgICAgZiBzdGF0ZVxuICAgICAgPj4+IGZ1bmN0aW9uXG4gICAgICB8IGBSZXBlYXQgc3RhdGUgLT4gbG9vcCBzdGF0ZVxuICAgICAgfCBgRmluaXNoZWQgcmVzdWx0IC0+IEl2YXIuZmlsbCBmaW5pc2hlZCByZXN1bHRcbiAgICBpblxuICAgIGxvb3Agc3RhdGUpXG47O1xuXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBvcGVuIEluZml4XG4gIG9wZW4gTGV0X3N5bnRheFxuXG4gIGxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgICBjcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICAgIGxldCByZWMgbG9vcCB0IGkgYiA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgICB8IHggOjogeHMgLT4gZiBpIGIgeCA+Pj4gZnVuIGIgLT4gbG9vcCB4cyAoaSArIDEpIGJcbiAgICAgIGluXG4gICAgICBsb29wIHQgMCBpbml0KVxuICA7O1xuXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBmb2xkaSB0IH5pbml0IH5mOihmdW4gXyBhIHggLT4gZiBhIHgpXG5cbiAgbGV0IHNlcW1hcGkgdCB+ZiA9XG4gICAgZm9sZGkgdCB+aW5pdDpbXSB+ZjooZnVuIGkgYnMgYSAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGEgaW5cbiAgICAgIGIgOjogYnMpXG4gICAgPj58IExpc3QucmV2XG4gIDs7XG5cbiAgbGV0IGFsbCBkcyA9IHNlcW1hcGkgZHMgfmY6KGZ1biBfIHggLT4geClcbiAgbGV0IGFsbF91bml0IGRzID0gaWdub3JlX20gKGZvbGQgZHMgfmluaXQ6KCkgfmY6KGZ1biAoKSBkIC0+IGQpIDogdW5pdCBULnQpXG5cbiAgbGV0IGl0ZXJpIH5ob3cgdCB+ZiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgIGFsbF91bml0IChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gICAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuICA7O1xuXG4gIGxldCBtYXBpIH5ob3cgdCB+ZiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgIGFsbCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICAgIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG4gIDs7XG5cbiAgbGV0IGZpbHRlcmkgfmhvdyB0IH5mID1cbiAgICBsZXQlbWFwIGJvb2xzID0gbWFwaSB0IH5ob3cgfmYgaW5cbiAgICBMaXN0LnJldlxuICAgICAgKExpc3QuZm9sZDJfZXhuIHQgYm9vbHMgfmluaXQ6W10gfmY6KGZ1biBhYyB4IGIgLT4gaWYgYiB0aGVuIHggOjogYWMgZWxzZSBhYykpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgdCB+aG93IH5mID4+fCBMaXN0LmZpbHRlcl9vcHRcbiAgbGV0IGNvbmNhdF9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgdCB+aG93IH5mID4+fCBMaXN0LmNvbmNhdFxuXG4gIGxldCBmaW5kX21hcGkgdCB+ZiA9XG4gICAgbGV0IHJlYyBmaW5kX21hcGkgdCB+ZiBpID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiByZXR1cm4gTm9uZVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2glYmluZCBmIGkgaGQgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwaSB0bCB+ZiAoaSArIDEpXG4gICAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICAgIGluXG4gICAgZmluZF9tYXBpIHQgfmYgMFxuICA7O1xuXG4gIGxldCBmaW5kaSB0IH5mID1cbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGZpbmQgdCB+ZiA9IGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT4gaWYlbWFwIGYgZWx0IHRoZW4gU29tZSBlbHQgZWxzZSBOb25lKVxuXG4gIGxldCBleGlzdHNpIHQgfmYgPVxuICAgIG1hdGNoJW1hcFxuICAgICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICAgIGlmIGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgICB3aXRoXG4gICAgfCBTb21lICgpIC0+IHRydWVcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9XG4gICAgbWF0Y2glbWFwXG4gICAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgICAgaWYgbm90IGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgICB3aXRoXG4gICAgfCBTb21lICgpIC0+IGZhbHNlXG4gICAgfCBOb25lIC0+IHRydWVcbiAgOztcblxuICBsZXQgaXRlciB+aG93IHQgfmYgPSBpdGVyaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgbWFwIH5ob3cgdCB+ZiA9IG1hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZpbHRlciB+aG93IHQgfmYgPSBmaWx0ZXJpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmaWx0ZXJfbWFwIH5ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBjb25jYXRfbWFwIH5ob3cgdCB+ZiA9IGNvbmNhdF9tYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZm9yX2FsbCB0IH5mID0gZm9yX2FsbGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBpbml0IH5ob3cgbiB+ZiA9IG1hcCB+aG93IChMaXN0LmluaXQgbiB+ZjpGbi5pZCkgfmZcbmVuZFxuXG5sZXQgYWxsX3VuaXQgPSBMaXN0LmFsbF91bml0XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDIxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImVhZ2VyX2RlZmVycmVkLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXIiLCJjc3RfZWFnZXJfZGVmZXJyZWQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJnbG9iYWxfZGF0YSIsIkNvcmVfUmVzdWx0IiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWQwIiwiQ29yZV9QcmludGYiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiQmFzZV9Nb25hZCIsIlQiLCJjb21iaW5lIiwidDEiLCJ0MiIsIm9rIiwiZXJyIiwicGFyYW0iLCJyZXR1cm4iLCJhIiwiYmluZCIsInQiLCJlcnJvciIsIm1hcCIsInIiLCJpbmNsdWRlIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiTGV0X3N5bnRheCIsIk1vbmFkX2luZml4Iiwiam9pbiIsImlnbm9yZV9tIiwiYWxsIiwiYWxsX3VuaXQiLCJmYWlsIiwieCIsImZhaWxmIiwiZm9ybWF0IiwibWFwX2Vycm9yIiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWRfIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FzeW5jX2tlcm5lbC9lYWdlcl9kZWZlcnJlZC9lYWdlcl9kZWZlcnJlZF9yZXN1bHQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsR0NBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFDLElBQUE7QUFBQSxZQUFBQyxRQUFBQyxJQUFBQyxJQUFBQyxJQUFBQztBQUFBQSxRQUFBLE1BZWU7QUFBQSxJQUFFO0FBQUE7QUFBQTtBQUFBLHNCQUFBQztBQUFBQSxrQkFBQUgsS0FBZixVQUFBRCxLQUFBO0FBQUEsY0FFQSxtREFBNkI7QUFBQTtBQUFBO0FBQUEsWUFBQUssU0FBQUM7QUFBQUEsSUFNWiw0REFBc0I7QUFBQTtBQUFBLFlBQUFDLEtBQUFDLEdBQUExQjtBQUFBQSxJQUduQztBQUFBO0FBQUE7QUFBQSxzQkFBQTJCO0FBQUFBLGNBQW1CO0FBQUEsZUFFSywyREFBc0I7QUFBQSxrQkFBQUgsSUFGM0I7QUFBQSxjQUNQLHVCQUNrQztBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFJO0FBQUFBLE1BNUJwRDtBQUFBO0FBQUEsZ0JBQUFGLEdBQUExQjtBQUFBQSxRQStCbUI7QUFBQTtBQUFBO0FBQUEsMEJBQUE2QixHQUE0Qix3Q0FBZSxHQUFDO0FBQUE7QUFBQSxJQUFBQyxVQS9CL0Q7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQVQsU0FBQTtBQUFBLElBQUFGLFdBQUE7QUFBQSxJQUFBSyxRQUFBO0FBQUEsSUFBQU8sT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLFlBQUFDLEtBQUFDO0FBQUFBLElBbUNhLDREQUF5QjtBQUFBO0FBQUEsWUFBQUMsTUFBQUMsUUFDbkIsK0NBQTJCO0FBQUEsWUFBQUMsVUFBQWpCLEdBQUExQjtBQUFBQSxJQUN6QjtBQUFBO0FBQUE7QUFBQSxzQkFBQTZCLEdBQTRCLHdDQUFxQixHQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQWU7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURyQ3ZFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBDb3JlXG5vcGVuISBBc3luY19rZXJuZWxcbm9wZW4hIEltcG9ydFxubW9kdWxlIERlZmVycmVkID0gRWFnZXJfZGVmZXJyZWQwXG5vcGVuIERlZmVycmVkLkxldF9zeW50YXhcblxuKCogQ29waWVkIGZyb20gW2RlZmVycmVkX3Jlc3VsdC5tbF0uICBUaGVyZSBzaG91bGQgYmUgbm8gZGlmZnMgYmVsb3cgdGhpcyBsaW5lLiAqKVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2Vycm9yKSB0ID0gKCdhLCAnZXJyb3IpIFJlc3VsdC50IERlZmVycmVkLnRcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBsZXQlbWFwIHQxID0gdDFcbiAgYW5kIHQyID0gdDIgaW5cbiAgUmVzdWx0LmNvbWJpbmUgdDEgdDIgfm9rIH5lcnJcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHJldHVybiBhID0gRGVmZXJyZWQucmV0dXJuIChPayBhKVxuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBEZWZlcnJlZC5iaW5kIHQgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgT2sgYSAtPiBmIGFcbiAgICAgICAgfCBFcnJvciBfIGFzIGVycm9yIC0+IERlZmVycmVkLnJldHVybiBlcnJvcilcbiAgICA7O1xuXG4gICAgbGV0IG1hcCB0IH5mID0gRGVmZXJyZWQubWFwIHQgfmY6KGZ1biByIC0+IFJlc3VsdC5tYXAgciB+ZilcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5sZXQgZmFpbCB4ID0gRGVmZXJyZWQucmV0dXJuIChFcnJvciB4KVxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxubGV0IG1hcF9lcnJvciB0IH5mID0gRGVmZXJyZWQubWFwIHQgfmY6KGZ1biByIC0+IFJlc3VsdC5tYXBfZXJyb3IgciB+ZilcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1NTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWFnZXJfZGVmZXJyZWQuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9FYWdlcl9kZWZlcnJlZF9FYWdlcl9kZWZlciIsImNzdF9lYWdlcl9kZWZlcnJlZCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIkNvcmVfTGlzdCIsIkFzeW5jX2tlcm5lbF9UaHJvdHRsZSIsIkNvcmUiLCJDb3JlX09yX2Vycm9yIiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWQwIiwiQ29yZV9FcnJvciIsIkNvcmVfUmVzdWx0IiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWRfIiwiQXN5bmNfa2VybmVsX01vbml0b3IiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiQmFzZV9BcHBsaWNhdGl2ZSIsImlnbm9yZV9tIiwiam9pbiIsInJldHVybiIsImJpbmQiLCJNb25hZF9pbmZpeCIsInN5bWJvbF9iaW5kIiwiYXBwbHkiLCJ4IiwiZTEiLCJlMiIsIm1hcCIsImluY2x1ZGUiLCJib3RoIiwic3ltYm9sX21hcCIsImFsbCIsImFsbF91bml0IiwiT3Blbl9vbl9yaHMiLCJmYWlsIiwiZXJyb3IiLCJva19leG4iLCJ0Iiwib2ZfZXhuIiwiYmFja3RyYWNlIiwiZXhuIiwib2ZfZXhuX3Jlc3VsdCIsIm1zZyIsInYiLCJzZXhwX29mIiwiZXJyb3JfcyIsInNleHAiLCJlcnJvcl9zdHJpbmciLCJlcnJvcmYiLCJmb3JtYXQiLCJ0YWciLCJ0YWdfcyIsInRhZ19zX2xhenkiLCJ0YWdfYXJnIiwibWVzc2FnZSIsImEiLCJzZXhwX29mX2EiLCJ1bmltcGxlbWVudGVkIiwiY29tYmluZV9lcnJvcnMiLCJsIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX21hcF9vayIsInBhcmFtIiwiZXJyb3JzIiwidGwiLCJoZCIsInJlc3VsdCIsImN1cnJlbnRfZXJyb3IiLCJva191bml0IiwidHJ5X3dpdGgiLCJleHRyYWN0X2V4biIsInJ1biIsInJlc3QiLCJoZXJlIiwibmFtZSIsIm9rIiwidHJ5X3dpdGhfam9pbiIsImZvbGRpIiwibGlzdCIsImFjYyIsImxvb3AiLCJpIiwiZm9sZCIsImluaXQiLCJpdGVyaSIsImhvdyIsIm1hcGkiLCJicyIsImIiLCJmaWx0ZXJfbWFwaSIsImNvbmNhdF9tYXBpIiwiZmlsdGVyaSIsImZpbmRfbWFwaSIsInNvbWUiLCJmaW5kaSIsImVsdCIsImZpbmQiLCJleGlzdHNpIiwiZm9yX2FsbGkiLCJpdGVyIiwiZmlsdGVyIiwiZmlsdGVyX21hcCIsImNvbmNhdF9tYXAiLCJmaW5kX21hcCIsImV4aXN0cyIsImZvcl9hbGwiLCJuIiwicmVwZWF0X3VudGlsX2ZpbmlzaGVkIiwic3RhdGUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy95YW5uaWNrLy5vcGFtL2JvbnNhaS1mcm9udGVuZC9saWIvYXN5bmNfa2VybmVsL2VhZ2VyX2RlZmVycmVkL2VhZ2VyX2RlZmVycmVkX29yX2Vycm9yLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLEdDQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxjQUFBO0FB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QTZCLEtBQUFFLEtBQUFxQixHQUFBbkg7QUFBQUEsSUFDbkIsT0FBc0I7QUFBQSxrQkFBdEIsMkNEdE1oQyxpQkNzTXlEO0FBQUE7QUFBQSxZQUFBb0gsc0JBQUFDLE9BQUFySDtBQUFBQSxJQUk1QyxPQUFPO0FBQUE7QUFBQSxhQUFQO0FBQUEsc0JBQUF1RTtBQUFBQSxjQUFYO0FBQUEsbUJBQUE4QyxRQUFBO0FBQUEsZUFDbUIsc0NBQ2M7QUFBQTtBQUFBLGtCQUFBQSxVQUZqQztBQUFBLGNBRXFCLG9DQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBbkc7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVENU1uQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQ29yZVxub3BlbiEgQXN5bmNfa2VybmVsXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBEZWZlcnJlZCA9IEVhZ2VyX2RlZmVycmVkMFxubW9kdWxlIERlZmVycmVkX3Jlc3VsdCA9IEVhZ2VyX2RlZmVycmVkX3Jlc3VsdFxuXG5tb2R1bGUgTW9uaXRvciA9IHN0cnVjdFxuICBsZXQgdHJ5X3dpdGggPyhydW4gPSBgTm93KSA9IE1vbml0b3IudHJ5X3dpdGggfnJ1blxuZW5kXG5cbigqIENvcGllZCBmcm9tIFtkZWZlcnJlZF9vcl9lcnJvci5tbF0uICBUaGVyZSBzaG91bGQgYmUgbm8gZGlmZnMgYmVsb3cgdGhpcyBsaW5lLiAqKVxuXG5pbmNsdWRlIChEZWZlcnJlZF9yZXN1bHQgOiBNb25hZC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBEZWZlcnJlZF9yZXN1bHQudClcblxudHlwZSAnYSB0ID0gJ2EgT3JfZXJyb3IudCBEZWZlcnJlZC50XG5cbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGxldCBhcHBseSBmIHggPVxuICAgICAgRGVmZXJyZWRfcmVzdWx0LmNvbWJpbmVcbiAgICAgICAgZlxuICAgICAgICB4XG4gICAgICAgIH5vazooZnVuIGYgeCAtPiBmIHgpXG4gICAgICAgIH5lcnI6KGZ1biBlMSBlMiAtPiBFcnJvci5vZl9saXN0IFsgZTE7IGUyIF0pXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgKCogZnJvbSBBcHBsaWNhdGl2ZS5NYWtlICopXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICBlbmRcbmVuZFxuXG5vcGVuIExldF9zeW50YXhcblxubGV0IGZhaWwgZXJyb3IgPSBEZWZlcnJlZC5yZXR1cm4gKFJlc3VsdC5mYWlsIGVycm9yKVxubGV0IG9rX2V4biB0ID0gRGVmZXJyZWQubWFwIHQgfmY6T3JfZXJyb3Iub2tfZXhuXG5sZXQgb2ZfZXhuID9iYWNrdHJhY2UgZXhuID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5vZl9leG4gP2JhY2t0cmFjZSBleG4pXG5sZXQgb2ZfZXhuX3Jlc3VsdCA/YmFja3RyYWNlIHQgPSBEZWZlcnJlZC5tYXAgdCB+ZjooT3JfZXJyb3Iub2ZfZXhuX3Jlc3VsdCA/YmFja3RyYWNlKVxubGV0IGVycm9yIG1zZyB2IHNleHBfb2YgPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLmVycm9yIG1zZyB2IHNleHBfb2YpXG5sZXQgZXJyb3JfcyBzZXhwID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zIHNleHApXG5sZXQgZXJyb3Jfc3RyaW5nIG1zZyA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIG1zZylcbmxldCBlcnJvcmYgZm9ybWF0ID0ga3NwcmludGYgZXJyb3Jfc3RyaW5nIGZvcm1hdFxubGV0IHRhZyB0IH50YWcgPSBEZWZlcnJlZC5tYXAgdCB+ZjooT3JfZXJyb3IudGFnIH50YWcpXG5sZXQgdGFnX3MgdCB+dGFnID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLnRhZ19zIH50YWcpXG5sZXQgdGFnX3NfbGF6eSB0IH50YWcgPSBEZWZlcnJlZC5tYXAgdCB+ZjooT3JfZXJyb3IudGFnX3NfbGF6eSB+dGFnKVxuXG5sZXQgdGFnX2FyZyB0IG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBEZWZlcnJlZC5tYXAgdCB+ZjooZnVuIHQgLT4gT3JfZXJyb3IudGFnX2FyZyB0IG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgdW5pbXBsZW1lbnRlZCBtc2cgPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLnVuaW1wbGVtZW50ZWQgbXNnKVxubGV0IGNvbWJpbmVfZXJyb3JzIGwgPSBEZWZlcnJlZC5tYXAgKERlZmVycmVkLmFsbCBsKSB+ZjpPcl9lcnJvci5jb21iaW5lX2Vycm9yc1xubGV0IGNvbWJpbmVfZXJyb3JzX3VuaXQgbCA9IERlZmVycmVkLm1hcCAoRGVmZXJyZWQuYWxsIGwpIH5mOk9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXRcblxubGV0IGZpbHRlcl9va19hdF9sZWFzdF9vbmUgbCA9XG4gIERlZmVycmVkLm1hcCAoRGVmZXJyZWQuYWxsIGwpIH5mOk9yX2Vycm9yLmZpbHRlcl9va19hdF9sZWFzdF9vbmVcbjs7XG5cbmxldCBmaW5kX21hcF9vayBsIH5mID1cbiAgRGVmZXJyZWQucmVwZWF0X3VudGlsX2ZpbmlzaGVkIChsLCBbXSkgKGZ1biAobCwgZXJyb3JzKSAtPlxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGxldCBlcnJvcnMgPSBFcnJvci5vZl9saXN0IChMaXN0LnJldiBlcnJvcnMpIGluXG4gICAgICBEZWZlcnJlZC5yZXR1cm4gKGBGaW5pc2hlZCAoRXJyb3IgZXJyb3JzKSlcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBEZWZlcnJlZC5tYXAgKGYgaGQpIH5mOihmdW5jdGlvblxuICAgICAgICB8IEVycm9yIGN1cnJlbnRfZXJyb3IgLT4gYFJlcGVhdCAodGwsIGN1cnJlbnRfZXJyb3IgOjogZXJyb3JzKVxuICAgICAgICB8IE9rIHJlc3VsdCAtPiBgRmluaXNoZWQgKE9rIHJlc3VsdCkpKVxuOztcblxubGV0IG9rX3VuaXQgPSByZXR1cm4gKClcblxubGV0IHRyeV93aXRoID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYgPVxuICBEZWZlcnJlZC5tYXAgKE1vbml0b3IudHJ5X3dpdGggP2V4dHJhY3RfZXhuID9ydW4gP3Jlc3QgP2hlcmUgP25hbWUgZikgfmY6KGZ1bmN0aW9uXG4gICAgfCBFcnJvciBleG4gLT4gRXJyb3IgKEVycm9yLm9mX2V4biBleG4pXG4gICAgfCBPayBfIGFzIG9rIC0+IG9rKVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gP2V4dHJhY3RfZXhuID9ydW4gP3Jlc3QgP2hlcmUgP25hbWUgZiA9XG4gIERlZmVycmVkLm1hcCAodHJ5X3dpdGggP2V4dHJhY3RfZXhuID9ydW4gP3Jlc3QgP2hlcmUgP25hbWUgZikgfmY6T3JfZXJyb3Iuam9pblxuOztcblxubW9kdWxlIExpc3QgPSBzdHJ1Y3RcbiAgbGV0IGZvbGRpIGxpc3QgfmluaXQ6YWNjIH5mID1cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gYWNjXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCViaW5kIGFjYyA9IGYgaSBhY2MgaGQgaW5cbiAgICAgICAgbG9vcCAoaSArIDEpIGFjYyB0bFxuICAgIGluXG4gICAgbG9vcCAwIGFjYyBsaXN0XG4gIDs7XG5cbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IGZvbGRpIHQgfmluaXQgfmY6KGZ1biBfIGEgeCAtPiBmIGEgeClcblxuICBsZXQgc2VxbWFwaSB0IH5mID1cbiAgICBmb2xkaSB0IH5pbml0OltdIH5mOihmdW4gaSBicyBhIC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgYSBpblxuICAgICAgYiA6OiBicylcbiAgICA+PnwgTGlzdC5yZXZcbiAgOztcblxuICBsZXQgYWxsID0gYWxsXG4gIGxldCBhbGxfdW5pdCA9IGFsbF91bml0XG5cbiAgbGV0IGl0ZXJpIH5ob3cgdCB+ZiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgIGFsbF91bml0IChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gICAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuICA7O1xuXG4gIGxldCBtYXBpIH5ob3cgdCB+ZiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgIGFsbCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICAgIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgdCB+aG93IH5mID4+fCBMaXN0LmZpbHRlcl9vcHRcbiAgbGV0IGNvbmNhdF9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgdCB+aG93IH5mID4+fCBMaXN0LmNvbmNhdFxuXG4gIGxldCBmaWx0ZXJpIH5ob3cgdCB+ZiA9XG4gICAgZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgeCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IHJldHVybiBOb25lXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCViaW5kIGYgaSBoZCB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gZmluZF9tYXBpIHRsIH5mIChpICsgMSlcbiAgICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gICAgaW5cbiAgICBmaW5kX21hcGkgdCB+ZiAwXG4gIDs7XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5cbiAgbGV0IGZpbmRpIHQgfmYgPVxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lIChpLCBlbHQpIGVsc2UgTm9uZSlcbiAgOztcblxuICBsZXQgZmluZCB0IH5mID1cbiAgICBmaW5kX21hcCB0IH5mOihmdW4gZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbiAgOztcblxuICBsZXQgZXhpc3RzaSB0IH5mID1cbiAgICBtYXRjaCVtYXBcbiAgICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gICAgd2l0aFxuICAgIHwgU29tZSAoKSAtPiB0cnVlXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGxpIHQgfmYgPVxuICAgIG1hdGNoJW1hcFxuICAgICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gICAgd2l0aFxuICAgIHwgU29tZSAoKSAtPiBmYWxzZVxuICAgIHwgTm9uZSAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IGl0ZXIgfmhvdyB0IH5mID0gaXRlcmkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IG1hcCB+aG93IHQgfmYgPSBtYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmaWx0ZXIgfmhvdyB0IH5mID0gZmlsdGVyaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmlsdGVyX21hcCB+aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgY29uY2F0X21hcCB+aG93IHQgfmYgPSBjb25jYXRfbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgaW5pdCB+aG93IG4gfmYgPSBtYXAgfmhvdyAoTGlzdC5pbml0IG4gfmY6Rm4uaWQpIH5mXG5lbmRcblxubGV0IHJlYyByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZiA9XG4gIG1hdGNoJWJpbmQgZiBzdGF0ZSB3aXRoXG4gIHwgYFJlcGVhdCBzdGF0ZSAtPiByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZlxuICB8IGBGaW5pc2hlZCBzdGF0ZSAtPiByZXR1cm4gc3RhdGVcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTAwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJlYWdlcl9kZWZlcnJlZC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X0VhZ2VyX2RlZmVycmVkX0VhZ2VyX2RlZmVyIiwiY3N0X2VhZ2VyX2RlZmVycmVkIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiUHB4X21vZHVsZV90aW1lcl9ydW50aW1lIiwiUHB4X2JlbmNoX2xpYl9CZW5jaG1hcmtfYWNjdW11IiwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yIiwiUHB4X2lubGluZV90ZXN0X2xpYiIsIkVhZ2VyX2RlZmVycmVkX0VhZ2VyX2RlZmVycmVkMCIsIkFzeW5jX2tlcm5lbF9EZWZlcnJlZF9tZW1vIiwiaW5jbHVkZSIsImdlbmVyYWwiLCJyZWN1cnNpdmUiLCJ1bml0IiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWRfIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FzeW5jX2tlcm5lbC9lYWdlcl9kZWZlcnJlZC9lYWdlcl9kZWZlcnJlZF9tZW1vLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxHQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsR0FHNEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxpQ0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVESDVDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBDb3JlXG5vcGVuISBBc3luY19rZXJuZWxcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBEZWZlcnJlZC5NZW1vLk1ha2UgKEVhZ2VyX2RlZmVycmVkMClcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMDY1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImVhZ2VyX2RlZmVycmVkLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXIiLCJjc3RfZWFnZXJfZGVmZXJyZWQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWRfIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FzeW5jX2tlcm5lbC9lYWdlcl9kZWZlcnJlZC9lYWdlcl9kZWZlcnJlZF9pbnRmLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxHQ0FBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBc0pHO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUMsaUNBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRKSCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQ29yZVxub3BlbiEgQXN5bmNfa2VybmVsXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIHR5cGUgRWFnZXJfZGVmZXJyZWRfb3JfZXJyb3IgPSBzaWdcbiAgdHlwZSArJ2EgZGVmZXJyZWRcbiAgdHlwZSAnYSB0ID0gJ2EgT3JfZXJyb3IudCBkZWZlcnJlZFxuXG4gIGluY2x1ZGUgTW9uYWQuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIGZhaWwgOiBFcnJvci50IC0+IF8gdFxuICB2YWwgb2tfdW5pdCA6IHVuaXQgdFxuICB2YWwgb2tfZXhuIDogJ2EgdCAtPiAnYSBkZWZlcnJlZFxuICB2YWwgb2ZfZXhuIDogP2JhY2t0cmFjZTpbIGBHZXQgfCBgVGhpcyBvZiBzdHJpbmcgXSAtPiBleG4gLT4gXyB0XG5cbiAgdmFsIG9mX2V4bl9yZXN1bHRcbiAgICA6ICA/YmFja3RyYWNlOlsgYEdldCB8IGBUaGlzIG9mIHN0cmluZyBdXG4gICAgLT4gKCdhLCBleG4pIFJlc3VsdC50IGRlZmVycmVkXG4gICAgLT4gJ2EgdFxuXG4gIHZhbCBlcnJvciA6IHN0cmluZyAtPiAnYSAtPiAoJ2EgLT4gU2V4cC50KSAtPiBfIHRcbiAgdmFsIGVycm9yX3MgOiBTZXhwLnQgLT4gXyB0XG4gIHZhbCBlcnJvcl9zdHJpbmcgOiBzdHJpbmcgLT4gXyB0XG4gIHZhbCBlcnJvcmYgOiAoJ2EsIHVuaXQsIHN0cmluZywgXyB0KSBmb3JtYXQ0IC0+ICdhXG4gIHZhbCB0YWcgOiAnYSB0IC0+IHRhZzpzdHJpbmcgLT4gJ2EgdFxuICB2YWwgdGFnX3MgOiAnYSB0IC0+IHRhZzpTZXhwLnQgLT4gJ2EgdFxuICB2YWwgdGFnX3NfbGF6eSA6ICdhIHQgLT4gdGFnOlNleHAudCBMYXp5LnQgLT4gJ2EgdFxuICB2YWwgdGFnX2FyZyA6ICdhIHQgLT4gc3RyaW5nIC0+ICdiIC0+ICgnYiAtPiBTZXhwLnQpIC0+ICdhIHRcbiAgdmFsIHVuaW1wbGVtZW50ZWQgOiBzdHJpbmcgLT4gXyB0XG4gIHZhbCBmaW5kX21hcF9vayA6ICdhIGxpc3QgLT4gZjooJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuXG4gICgqKiBOb3RlIHRoYXQgW3RyeV93aXRoIGZdIGlzIGVhZ2VyIG9ubHkgaW4gdGhlIFtPa10gY2FzZS4gKilcbiAgdmFsIHRyeV93aXRoXG4gICAgOiAgP2V4dHJhY3RfZXhuOmJvb2xcbiAgICAtPiA/cnVuOlsgYE5vdyB8IGBTY2hlZHVsZSBdXG4gICAgLT4gP3Jlc3Q6WyBgTG9nIHwgYFJhaXNlIHwgYENhbGwgb2YgZXhuIC0+IHVuaXQgXSAoKiogZGVmYXVsdCBpcyBbYFJhaXNlXSAqKVxuICAgIC0+ID9oZXJlOkxleGluZy5wb3NpdGlvblxuICAgIC0+ID9uYW1lOnN0cmluZ1xuICAgIC0+ICh1bml0IC0+ICdhIGRlZmVycmVkKVxuICAgIC0+ICdhIHRcblxuICAoKiogTm90ZSB0aGF0IFt0cnlfd2l0aF9qb2luIGZdIGlzIGVhZ2VyIG9ubHkgd2hlbiBubyBleGNlcHRpb24gaXMgcmFpc2VkIGJ5IFtmXS4gKilcbiAgdmFsIHRyeV93aXRoX2pvaW5cbiAgICA6ICA/ZXh0cmFjdF9leG46Ym9vbFxuICAgIC0+ID9ydW46WyBgTm93IHwgYFNjaGVkdWxlIF1cbiAgICAtPiA/cmVzdDpbIGBMb2cgfCBgUmFpc2UgfCBgQ2FsbCBvZiBleG4gLT4gdW5pdCBdICgqKiBkZWZhdWx0IGlzIFtgUmFpc2VdICopXG4gICAgLT4gP2hlcmU6TGV4aW5nLnBvc2l0aW9uXG4gICAgLT4gP25hbWU6c3RyaW5nXG4gICAgLT4gKHVuaXQgLT4gJ2EgdClcbiAgICAtPiAnYSB0XG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuICB2YWwgY29tYmluZV9lcnJvcnNfdW5pdCA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuICB2YWwgZmlsdGVyX29rX2F0X2xlYXN0X29uZSA6ICdhIHQgbGlzdCAtPiAnYSBsaXN0IHRcblxuICBtb2R1bGUgTGlzdCA6IE1vbmFkX3NlcXVlbmNlLlMgd2l0aCB0eXBlICdhIG1vbmFkIDo9ICdhIHQgd2l0aCB0eXBlICdhIHQgOj0gJ2EgbGlzdFxuXG4gIHZhbCByZXBlYXRfdW50aWxfZmluaXNoZWRcbiAgICA6ICAnc3RhdGVcbiAgICAtPiAoJ3N0YXRlIC0+IFsgYFJlcGVhdCBvZiAnc3RhdGUgfCBgRmluaXNoZWQgb2YgJ3Jlc3VsdCBdIHQpXG4gICAgLT4gJ3Jlc3VsdCB0XG5lbmRcblxubW9kdWxlIHR5cGUgRWFnZXJfZGVmZXJyZWQxID0gc2lnXG4gIHR5cGUgKydhIHRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgTW9uYWQgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gIG1vZHVsZSBJbmZpeCA6IHNpZ1xuICAgIGluY2x1ZGUgTW9uYWQuSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgdmFsICggPj4+ICkgOiAnYSB0IC0+ICgnYSAtPiB1bml0KSAtPiB1bml0XG4gIGVuZFxuXG4gIHZhbCBhbnkgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuICB2YWwgYW55X3VuaXQgOiB1bml0IHQgbGlzdCAtPiB1bml0IHRcbiAgdmFsIGJvdGggOiAnYSB0IC0+ICdiIHQgLT4gKCdhICogJ2IpIHRcbiAgdmFsIGNyZWF0ZSA6ICgnYSBJdmFyLnQgLT4gdW5pdCkgLT4gJ2EgdFxuICB2YWwgZG9uJ3Rfd2FpdF9mb3IgOiB1bml0IHQgLT4gdW5pdFxuICB2YWwgaXNfZGV0ZXJtaW5lZCA6ICdhIHQgLT4gYm9vbFxuICB2YWwgbmV2ZXIgOiB1bml0IC0+IF8gdFxuICB2YWwgb2sgOiAnYSB0IC0+ICgnYSwgXykgQ29yZS5SZXN1bHQudCB0XG4gIHZhbCBwZWVrIDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIHVuaXQgOiB1bml0IHRcbiAgdmFsIHVwb24gOiAnYSB0IC0+ICgnYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCB2YWx1ZV9leG4gOiAnYSB0IC0+ICdhXG5cbiAgdmFsIHJlcGVhdF91bnRpbF9maW5pc2hlZFxuICAgIDogICdzdGF0ZVxuICAgIC0+ICgnc3RhdGUgLT4gWyBgUmVwZWF0IG9mICdzdGF0ZSB8IGBGaW5pc2hlZCBvZiAncmVzdWx0IF0gdClcbiAgICAtPiAncmVzdWx0IHRcblxuICBtb2R1bGUgTGlzdCA6IE1vbmFkX3NlcXVlbmNlLlMgd2l0aCB0eXBlICdhIG1vbmFkIDo9ICdhIHQgd2l0aCB0eXBlICdhIHQgOj0gJ2EgbGlzdFxuICBtb2R1bGUgT3JfZXJyb3IgOiBFYWdlcl9kZWZlcnJlZF9vcl9lcnJvciB3aXRoIHR5cGUgJ2EgZGVmZXJyZWQgOj0gJ2EgdFxuICBtb2R1bGUgTWVtbyA6IERlZmVycmVkLk1lbW8uUyB3aXRoIHR5cGUgJ2EgZGVmZXJyZWQgOj0gJ2EgdFxuXG4gIG1vZHVsZSBSZXN1bHQgOiBzaWdcbiAgICBpbmNsdWRlIE1vbmFkLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgUmVzdWx0LnQgRGVmZXJyZWQudFxuXG4gICAgdmFsIGZhaWwgOiAnZXJyIC0+IChfLCAnZXJyKSB0XG5cbiAgICAoKiogZS5nLiwgW2ZhaWxmIFwiQ291bGRuJ3QgZmluZCBibG9vZ2xlICVzXCIgKEJsb29nbGUudG9fc3RyaW5nIGIpXS4gKilcbiAgICB2YWwgZmFpbGYgOiAoJ2EsIHVuaXQsIHN0cmluZywgKF8sIHN0cmluZykgdCkgZm9ybWF0NCAtPiAnYVxuXG4gICAgdmFsIG1hcF9lcnJvciA6ICgnb2ssICdlcnJvcjEpIHQgLT4gZjooJ2Vycm9yMSAtPiAnZXJyb3IyKSAtPiAoJ29rLCAnZXJyb3IyKSB0XG5cbiAgICAoKiogW2NvbWJpbmVdIHdhaXRzIG9uIGJvdGggaW5wdXRzIGFuZCBjb21iaW5lcyB0aGVpciByZXN1bHRzIHVzaW5nIFtSZXN1bHQuY29tYmluZV0uICopXG4gICAgdmFsIGNvbWJpbmVcbiAgICAgIDogICgnb2sxLCAnZXJyKSB0XG4gICAgICAtPiAoJ29rMiwgJ2VycikgdFxuICAgICAgLT4gb2s6KCdvazEgLT4gJ29rMiAtPiAnb2szKVxuICAgICAgLT4gZXJyOignZXJyIC0+ICdlcnIgLT4gJ2VycilcbiAgICAgIC0+ICgnb2szLCAnZXJyKSB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSArJ2EgdFxuXG4gIGluY2x1ZGUgRWFnZXJfZGVmZXJyZWQxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHQgKCoqIEBvcGVuICopXG5cbiAgKCoqIEludGVuZGVkIHVzYWdlIGlzIHRvIFtvcGVuIEVhZ2VyX2RlZmVycmVkLlVzZV0gdG8gc2hhZG93IG9wZXJhdGlvbnMgZnJvbSB0aGVcbiAgICAgIG5vbi1lYWdlciB3b3JsZCBhbmQgcmViaW5kIHRoZW0gdG8gdGhlaXIgZWFnZXIgY291bnRlcnBhcnRzLiAqKVxuICBtb2R1bGUgVXNlIDogc2lnXG4gICAgbW9kdWxlIERlZmVycmVkIDogc2lnXG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIEVhZ2VyX2RlZmVycmVkMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIE1vbmFkLkluZml4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIERlZmVycmVkLkxldF9zeW50YXhcblxuICAgIHZhbCB1cG9uIDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICAgIHZhbCAoID4+PiApIDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICAgdmFsICggPj49PyApXG4gICAgICA6ICAoJ2EsICdlKSBDb3JlLlJlc3VsdC50IHRcbiAgICAgIC0+ICgnYSAtPiAoJ2IsICdlKSBDb3JlLlJlc3VsdC50IHQpXG4gICAgICAtPiAoJ2IsICdlKSBDb3JlLlJlc3VsdC50IHRcblxuICAgIHZhbCAoID4+fD8gKSA6ICgnYSwgJ2UpIENvcmUuUmVzdWx0LnQgdCAtPiAoJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIENvcmUuUmVzdWx0LnQgdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBFYWdlcl9kZWZlcnJlZCA9IHNpZ1xuICBtb2R1bGUgdHlwZSBTID0gU1xuXG4gIGluY2x1ZGUgUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBEZWZlcnJlZC50XG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImVhZ2VyX2RlZmVycmVkLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXIiLCJjc3RfZWFnZXJfZGVmZXJyZWQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJQcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUiLCJQcHhfYmVuY2hfbGliX0JlbmNobWFya19hY2N1bXUiLCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IiLCJQcHhfaW5saW5lX3Rlc3RfbGliIiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWQwIiwiRWFnZXJfZGVmZXJyZWRfRWFnZXJfZGVmZXJyZWRfIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiTW9uYWRfaW5maXgiLCJiaW5kIiwicmV0dXJuIiwibWFwIiwiam9pbiIsImFsbCIsIkxldF9zeW50YXgiLCJjcmVhdGUiLCJkb25fdF93YWl0X2ZvciIsImludmFyaWFudCIsImlzX2RldGVybWluZWQiLCJuZXZlciIsInBlZWsiLCJ1bml0IiwidmFsdWVfZXhuIiwidXBvbiIsImJvdGgiLCJvayIsImlnbm9yZV9tIiwiYW55IiwiYW55X3VuaXQiLCJJbmZpeCIsInJlcGVhdF91bnRpbF9maW5pc2hlZCIsIkxpc3QiLCJhbGxfdW5pdCIsIkVhZ2VyX2RlZmVycmVkX0VhZ2VyX2RlZmVycmVkMSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL3lhbm5pY2svLm9wYW0vYm9uc2FpLWZyb250ZW5kL2xpYi9hc3luY19rZXJuZWwvZWFnZXJfZGVmZXJyZWQvZWFnZXJfZGVmZXJyZWQxLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFBO0FBQUFBLE1BQUE7QUFBQSxJQUFBQTtBQUFBQSxNQUFBO0FBQUEsR0NBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLEdBR3lDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVESHpDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJpbmNsdWRlIEVhZ2VyX2RlZmVycmVkMFxubW9kdWxlIE1lbW8gPSBFYWdlcl9kZWZlcnJlZF9tZW1vXG5tb2R1bGUgUmVzdWx0ID0gRWFnZXJfZGVmZXJyZWRfcmVzdWx0XG5tb2R1bGUgT3JfZXJyb3IgPSBFYWdlcl9kZWZlcnJlZF9vcl9lcnJvclxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyNTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWFnZXJfZGVmZXJyZWQuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9FYWdlcl9kZWZlcnJlZCIsImNzdF9lYWdlcl9kZWZlcnJlZCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIlBweF9tb2R1bGVfdGltZXJfcnVudGltZSIsIlBweF9iZW5jaF9saWJfQmVuY2htYXJrX2FjY3VtdSIsIkV4cGVjdF90ZXN0X2NvbGxlY3RvciIsIlBweF9pbmxpbmVfdGVzdF9saWIiLCJFYWdlcl9kZWZlcnJlZF9FYWdlcl9kZWZlcnJlZDEiLCJBc3luY19rZXJuZWxfRGVmZXJyZWQiLCJpbnZhcmlhbnQiLCJzeW1ib2xfYmluZCIsInN5bWJvbF9tYXAiLCJNb25hZF9pbmZpeCIsImJpbmQiLCJyZXR1cm4iLCJtYXAiLCJqb2luIiwiaWdub3JlX20iLCJhbGwiLCJhbGxfdW5pdCIsIkxldF9zeW50YXgiLCJJbmZpeCIsImFueSIsImFueV91bml0IiwiYm90aCIsImNyZWF0ZSIsImRvbl90X3dhaXRfZm9yIiwiaXNfZGV0ZXJtaW5lZCIsIm5ldmVyIiwib2siLCJwZWVrIiwidW5pdCIsInVwb24iLCJ2YWx1ZV9leG4iLCJyZXBlYXRfdW50aWxfZmluaXNoZWQiLCJMaXN0IiwiT3JfZXJyb3IiLCJNZW1vIiwiUmVzdWx0Iiwic2V4cF9vZl90IiwiRGVmZXJyZWQiLCJpbmNsdWRlIiwic3ltYm9sIiwieCIsImVycm9yIiwidiIsIlVzZSIsIkVhZ2VyX2RlZmVycmVkIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMveWFubmljay8ub3BhbS9ib25zYWktZnJvbnRlbmQvbGliL2FzeW5jX2tlcm5lbC9lYWdlcl9kZWZlcnJlZC9lYWdlcl9kZWZlcnJlZC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsR0NBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQTlCLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUU7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUEzQixXQUFBO0FBQUEsSUFBQUosZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQVMsZUFBQTtBQUFBLElBQUFZLFNBQUE7QUFBQSxJQUFBVSxTQUFBO0FBQUEsWUFBQUEsU0FBQUMsR0FBQTdDO0FBQUFBLElBc0JJO0FBQUE7QUFBQTtBQUFBLHNCQUFBOEM7QUFBQUEsY0FDSSxtQkFDa0Isa0NBQ1Q7QUFBQSxrQkFBQUMsSUFGVDtBQUFBLGNBRU0sdUJBQUc7QUFBQTtBQUFBO0FBQUEsWUFBQUgsU0FBQUMsR0FBQTdDO0FBQUFBLElBSWI7QUFBQTtBQUFBO0FBQUEsc0JBQUE4QztBQUFBQSxjQUNJLG1CQUNrQjtBQUFBLGtCQUFBQyxJQURsQjtBQUFBLGNBRVMsNEJBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQWhDdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQWtDRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEbENIIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBDb3JlXG5vcGVuISBBc3luY19rZXJuZWxcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgdHlwZSBTID0gRWFnZXJfZGVmZXJyZWRfaW50Zi5TXG5cbmluY2x1ZGUgRWFnZXJfZGVmZXJyZWQxXG5cbm1vZHVsZSBVc2UgPSBzdHJ1Y3RcbiAgbW9kdWxlIERlZmVycmVkID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgRGVmZXJyZWQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBFYWdlcl9kZWZlcnJlZDFcbiAgZW5kXG5cbiAgaW5jbHVkZSAoRWFnZXJfZGVmZXJyZWQxIDogTW9uYWQuSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgRGVmZXJyZWQudClcbiAgaW5jbHVkZSBFYWdlcl9kZWZlcnJlZDEuTGV0X3N5bnRheFxuXG4gIGxldCB1cG9uID0gRWFnZXJfZGVmZXJyZWQxLnVwb25cbiAgbGV0ICggPj4+ICkgPSBFYWdlcl9kZWZlcnJlZDEuSW5maXguKCA+Pj4gKVxuXG4gIGxldCAoID4+PT8gKSB4IGYgPVxuICAgIHhcbiAgICA+Pj0gZnVuY3Rpb25cbiAgICB8IEVycm9yIF8gYXMgZXJyb3IgLT4gcmV0dXJuIGVycm9yXG4gICAgfCBPayB2IC0+IGYgdlxuICA7O1xuXG4gIGxldCAoID4+fD8gKSB4IGYgPVxuICAgIHhcbiAgICA+PnwgZnVuY3Rpb25cbiAgICB8IEVycm9yIF8gYXMgZXJyb3IgLT4gZXJyb3JcbiAgICB8IE9rIHYgLT4gT2sgKGYgdilcbiAgOztcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
